diff --git a/README.md b/README.md
index 53173680..b1a559b4 100644
--- a/README.md
+++ b/README.md
@@ -1,6 +1,6 @@
 ## Tinker
 [![license](http://img.shields.io/badge/license-BSD3-brightgreen.svg?style=flat)](https://github.com/Tencent/tinker/blob/master/LICENSE)
-[![Release Version](https://img.shields.io/badge/release-1.7.1-red.svg)](https://github.com/Tencent/tinker/releases) 
+[![Release Version](https://img.shields.io/badge/release-1.7.5-red.svg)](https://github.com/Tencent/tinker/releases) 
 [![PRs Welcome](https://img.shields.io/badge/PRs-welcome-brightgreen.svg)](https://github.com/Tencent/tinker/pulls)
 [![WeChat Approved](https://img.shields.io/badge/Wechat_Approved-1.6.2-red.svg)](https://github.com/Tencent/tinker/wiki)
 
@@ -14,7 +14,7 @@ Add tinker-gradle-plugin as a dependency in your main `build.gradle` in the root
 ```gradle
 buildscript {
     dependencies {
-        classpath ('com.tencent.tinker:tinker-patch-gradle-plugin:1.7.1')
+        classpath ('com.tencent.tinker:tinker-patch-gradle-plugin:1.7.5')
     }
 }
 ```
@@ -24,9 +24,9 @@ Then you need to "apply" the plugin and add dependencies by adding the following
 ```gradle
 dependencies {
     //optional, help to generate the final application 
-    compile('com.tencent.tinker:tinker-android-anno:1.7.1')
+    provided('com.tencent.tinker:tinker-android-anno:1.7.5')
     //tinker's main Android lib
-    compile('com.tencent.tinker:tinker-android-lib:1.7.1') 
+    compile('com.tencent.tinker:tinker-android-lib:1.7.5') 
 }
 ...
 ...
diff --git a/gradle.properties b/gradle.properties
index 8842bf2c..5dbcb90b 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -16,5 +16,5 @@
 # This option should only be used with decoupled projects. More details, visit
 # http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
 # org.gradle.parallel=true
-VERSION_NAME_PREFIX=1.8.0
+VERSION_NAME_PREFIX=1.7.6
 VERSION_NAME_SUFFIX=
\ No newline at end of file
diff --git a/gradle/android-artifacts.gradle b/gradle/android-artifacts.gradle
index 47735f09..1d14ded6 100644
--- a/gradle/android-artifacts.gradle
+++ b/gradle/android-artifacts.gradle
@@ -87,6 +87,8 @@ publishing {
     }
 }
 
-task buildAndPublishLocalMaven(dependsOn: ['build', 'publishTinkerPatchPublicationToMavenLocal']) {}
+task buildAndPublishTinkerToLocalMaven(dependsOn: ['build', 'publishTinkerPatchPublicationToMavenLocal']) {
+    group = 'tinker'
+}
 //depend checkstyle
 project.tasks.getByName("check").dependsOn tasks.getByName("checkstyle")
diff --git a/gradle/java-artifacts.gradle b/gradle/java-artifacts.gradle
index 9b8b6e3b..8f498a2e 100644
--- a/gradle/java-artifacts.gradle
+++ b/gradle/java-artifacts.gradle
@@ -39,7 +39,9 @@ publishing {
     }
 }
 
-task buildAndPublishLocalMaven(dependsOn: ['build', 'publishTinkerPatchPublicationToMavenLocal']) {}
+task buildAndPublishTinkerToLocalMaven(dependsOn: ['build', 'publishTinkerPatchPublicationToMavenLocal']) {
+    group = 'tinker'
+}
 
 //depend checkstyle
 project.tasks.getByName("check").dependsOn tasks.getByName("checkstyle")
\ No newline at end of file
diff --git a/third-party/aosp-dexutils/build.gradle b/third-party/aosp-dexutils/build.gradle
index 4153cea7..1844d317 100644
--- a/third-party/aosp-dexutils/build.gradle
+++ b/third-party/aosp-dexutils/build.gradle
@@ -5,7 +5,8 @@ apply plugin: 'java'
 version rootProject.ext.VERSION_NAME
 group rootProject.ext.GROUP
 
-task buildSdk(type: Copy, dependsOn: [build]) {
+task buildTinkerSdk(type: Copy, dependsOn: [build]) {
+    group = "tinker"
     from('build/libs') {
         include '*.jar'
         exclude '*javadoc.jar'
diff --git a/third-party/bsdiff-util/build.gradle b/third-party/bsdiff-util/build.gradle
index 4153cea7..1844d317 100644
--- a/third-party/bsdiff-util/build.gradle
+++ b/third-party/bsdiff-util/build.gradle
@@ -5,7 +5,8 @@ apply plugin: 'java'
 version rootProject.ext.VERSION_NAME
 group rootProject.ext.GROUP
 
-task buildSdk(type: Copy, dependsOn: [build]) {
+task buildTinkerSdk(type: Copy, dependsOn: [build]) {
+    group = "tinker"
     from('build/libs') {
         include '*.jar'
         exclude '*javadoc.jar'
diff --git a/tinker-android/tinker-android-anno/build.gradle b/tinker-android/tinker-android-anno/build.gradle
index d74f33c2..263ca599 100644
--- a/tinker-android/tinker-android-anno/build.gradle
+++ b/tinker-android/tinker-android-anno/build.gradle
@@ -21,7 +21,8 @@ sourceSets {
     }
 }
 
-task buildSdk(type: Copy, dependsOn: [build]) {
+task buildTinkerSdk(type: Copy, dependsOn: [build]) {
+    group = "tinker"
     from('build/libs') {
         include '*.jar'
         exclude '*javadoc.jar'
diff --git a/tinker-android/tinker-android-lib/build.gradle b/tinker-android/tinker-android-lib/build.gradle
index 7f9c60b2..bcc8b83f 100644
--- a/tinker-android/tinker-android-lib/build.gradle
+++ b/tinker-android/tinker-android-lib/build.gradle
@@ -20,7 +20,8 @@ dependencies {
     compile project(':tinker-android:tinker-android-loader')
 }
 
-task buildSdk(type: Copy, dependsOn: [build]) {
+task buildTinkerSdk(type: Copy, dependsOn: [build]) {
+    group = "tinker"
     from("$buildDir/outputs/aar/") {
         include "${project.getName()}-release.aar"
     }
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/DefaultPatchListener.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/DefaultPatchListener.java
index b4cf11d0..356c11db 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/DefaultPatchListener.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/DefaultPatchListener.java
@@ -41,24 +41,23 @@ public DefaultPatchListener(Context context) {
      * you can overwrite it
      *
      * @param path
-     * @param isUpgrade
      * @return
      */
     @Override
-    public int onPatchReceived(String path, boolean isUpgrade) {
+    public int onPatchReceived(String path) {
 
-        int returnCode = patchCheck(path, isUpgrade);
+        int returnCode = patchCheck(path);
 
         if (returnCode == ShareConstants.ERROR_PATCH_OK) {
-            TinkerPatchService.runPatchService(context, path, isUpgrade);
+            TinkerPatchService.runPatchService(context, path);
         } else {
-            Tinker.with(context).getLoadReporter().onLoadPatchListenerReceiveFail(new File(path), returnCode, isUpgrade);
+            Tinker.with(context).getLoadReporter().onLoadPatchListenerReceiveFail(new File(path), returnCode);
         }
         return returnCode;
 
     }
 
-    protected int patchCheck(String path, boolean isUpgrade) {
+    protected int patchCheck(String path) {
         Tinker manager = Tinker.with(context);
         //check SharePreferences also
         if (!manager.isTinkerEnabled() || !ShareTinkerInternals.isTinkerEnableWithSharedPreferences(context)) {
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/PatchListener.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/PatchListener.java
index 7d65c555..1f18c491 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/PatchListener.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/PatchListener.java
@@ -20,5 +20,5 @@
  * Created by zhangshaowen on 16/3/14.
  */
 public interface PatchListener {
-    int onPatchReceived(String path, boolean isUpgrade);
+    int onPatchReceived(String path);
 }
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/BasePatchInternal.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/BasePatchInternal.java
index 5ef3d88d..732166f2 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/BasePatchInternal.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/BasePatchInternal.java
@@ -43,7 +43,6 @@
     protected static final String RES_META_FILE        = ShareConstants.RES_META_FILE;
 
     protected static final int TYPE_DEX         = ShareConstants.TYPE_DEX;
-    protected static final int TYPE_DEX_FOR_ART = ShareConstants.TYPE_DEX_FOR_ART;
     protected static final int TYPE_Library     = ShareConstants.TYPE_LIBRARY;
     protected static final int TYPE_RESOURCE    = ShareConstants.TYPE_RESOURCE;
 
@@ -89,7 +88,7 @@ public static boolean extract(ZipFile zipFile, ZipEntry entryFile, File extractT
     }
 
     public static int getMetaCorruptedCode(int type) {
-        if (type == TYPE_DEX || type == TYPE_DEX_FOR_ART) {
+        if (type == TYPE_DEX) {
             return ShareConstants.ERROR_PACKAGE_CHECK_DEX_META_CORRUPTED;
         } else if (type == TYPE_Library) {
             return ShareConstants.ERROR_PACKAGE_CHECK_LIB_META_CORRUPTED;
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/BsDiffPatchInternal.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/BsDiffPatchInternal.java
index 45e241b2..7414b007 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/BsDiffPatchInternal.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/BsDiffPatchInternal.java
@@ -42,7 +42,7 @@
     private static final String TAG = "Tinker.BsDiffPatchInternal";
 
     protected static boolean tryRecoverLibraryFiles(Tinker manager, ShareSecurityCheck checker, Context context,
-                                                    String patchVersionDirectory, File patchFile, boolean isUpgradePatch) {
+                                                    String patchVersionDirectory, File patchFile) {
 
         if (!manager.isEnabledForNativeLib()) {
             TinkerLog.w(TAG, "patch recover, library is not enabled");
@@ -55,19 +55,19 @@ protected static boolean tryRecoverLibraryFiles(Tinker manager, ShareSecurityChe
             return true;
         }
         long begin = SystemClock.elapsedRealtime();
-        boolean result = patchLibraryExtractViaBsDiff(context, patchVersionDirectory, libMeta, patchFile, isUpgradePatch);
+        boolean result = patchLibraryExtractViaBsDiff(context, patchVersionDirectory, libMeta, patchFile);
         long cost = SystemClock.elapsedRealtime() - begin;
-        TinkerLog.i(TAG, "recover lib result:%b, cost:%d, isUpgradePatch:%b", result, cost, isUpgradePatch);
+        TinkerLog.i(TAG, "recover lib result:%b, cost:%d", result, cost);
         return result;
     }
 
 
-    private static boolean patchLibraryExtractViaBsDiff(Context context, String patchVersionDirectory, String meta, File patchFile, boolean isUpgradePatch) {
+    private static boolean patchLibraryExtractViaBsDiff(Context context, String patchVersionDirectory, String meta, File patchFile) {
         String dir = patchVersionDirectory + "/" + SO_PATH + "/";
-        return extractBsDiffInternals(context, dir, meta, patchFile, TYPE_Library, isUpgradePatch);
+        return extractBsDiffInternals(context, dir, meta, patchFile, TYPE_Library);
     }
 
-    private static boolean extractBsDiffInternals(Context context, String dir, String meta, File patchFile, int type, boolean isUpgradePatch) {
+    private static boolean extractBsDiffInternals(Context context, String dir, String meta, File patchFile, int type) {
         //parse
         ArrayList<ShareBsDiffPatchInfo> patchList = new ArrayList<>();
 
@@ -110,7 +110,7 @@ private static boolean extractBsDiffInternals(Context context, String dir, Strin
                 final String fileMd5 = info.md5;
                 if (!SharePatchFileUtil.checkIfMd5Valid(fileMd5)) {
                     TinkerLog.w(TAG, "meta file md5 mismatch, type:%s, name: %s, md5: %s", ShareTinkerInternals.getTypeString(type), info.name, info.md5);
-                    manager.getPatchReporter().onPatchPackageCheckFail(patchFile, isUpgradePatch, BasePatchInternal.getMetaCorruptedCode(type));
+                    manager.getPatchReporter().onPatchPackageCheckFail(patchFile, BasePatchInternal.getMetaCorruptedCode(type));
                     return false;
                 }
                 String middle;
@@ -140,21 +140,21 @@ private static boolean extractBsDiffInternals(Context context, String dir, Strin
 
                 if (patchFileEntry == null) {
                     TinkerLog.w(TAG, "patch entry is null. path:" + patchRealPath);
-                    manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.name, type, isUpgradePatch);
+                    manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.name, type);
                     return false;
                 }
 
                 if (patchFileMd5.equals("0")) {
                     if (!extract(patch, patchFileEntry, extractedFile, fileMd5, false)) {
                         TinkerLog.w(TAG, "Failed to extract file " + extractedFile.getPath());
-                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.name, type, isUpgradePatch);
+                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.name, type);
                         return false;
                     }
                 } else {
                     //we do not check the intermediate files' md5 to save time, use check whether it is 32 length
                     if (!SharePatchFileUtil.checkIfMd5Valid(patchFileMd5)) {
                         TinkerLog.w(TAG, "meta file md5 mismatch, type:%s, name: %s, md5: %s", ShareTinkerInternals.getTypeString(type), info.name, patchFileMd5);
-                        manager.getPatchReporter().onPatchPackageCheckFail(patchFile, isUpgradePatch, BasePatchInternal.getMetaCorruptedCode(type));
+                        manager.getPatchReporter().onPatchPackageCheckFail(patchFile, BasePatchInternal.getMetaCorruptedCode(type));
                         return false;
                     }
 
@@ -162,7 +162,7 @@ private static boolean extractBsDiffInternals(Context context, String dir, Strin
 
                     if (rawApkFileEntry == null) {
                         TinkerLog.w(TAG, "apk entry is null. path:" + patchRealPath);
-                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.name, type, isUpgradePatch);
+                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.name, type);
                         return false;
                     }
 
@@ -172,7 +172,7 @@ private static boolean extractBsDiffInternals(Context context, String dir, Strin
                     String rawEntryCrc = String.valueOf(rawApkFileEntry.getCrc());
                     if (!rawEntryCrc.equals(rawApkCrc)) {
                         TinkerLog.e(TAG, "apk entry %s crc is not equal, expect crc: %s, got crc: %s", patchRealPath, rawApkCrc, rawEntryCrc);
-                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.name, type, isUpgradePatch);
+                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.name, type);
                         return false;
                     }
                     InputStream oldStream = null;
@@ -189,7 +189,7 @@ private static boolean extractBsDiffInternals(Context context, String dir, Strin
                     //go go go bsdiff get the
                     if (!SharePatchFileUtil.verifyFileMd5(extractedFile, fileMd5)) {
                         TinkerLog.w(TAG, "Failed to recover diff file " + extractedFile.getPath());
-                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.name, type, isUpgradePatch);
+                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.name, type);
                         SharePatchFileUtil.safeDeleteFile(extractedFile);
                         return false;
                     }
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java
index 03ba6974..765c6da1 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java
@@ -21,9 +21,9 @@
 import android.os.SystemClock;
 
 import com.tencent.tinker.commons.dexpatcher.DexPatchApplier;
-import com.tencent.tinker.commons.dexpatcher.struct.SmallPatchedDexItemFile;
 import com.tencent.tinker.lib.tinker.Tinker;
 import com.tencent.tinker.lib.util.TinkerLog;
+import com.tencent.tinker.loader.TinkerParallelDexOptimizer;
 import com.tencent.tinker.loader.TinkerRuntimeException;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
 import com.tencent.tinker.loader.shareutil.ShareDexDiffPatchInfo;
@@ -31,8 +31,6 @@
 import com.tencent.tinker.loader.shareutil.ShareSecurityCheck;
 import com.tencent.tinker.loader.shareutil.ShareTinkerInternals;
 
-import dalvik.system.DexFile;
-
 import java.io.BufferedInputStream;
 import java.io.BufferedOutputStream;
 import java.io.File;
@@ -52,8 +50,7 @@
     protected static final String TAG = "Tinker.DexDiffPatchInternal";
 
     protected static boolean tryRecoverDexFiles(Tinker manager, ShareSecurityCheck checker, Context context,
-                                                String patchVersionDirectory, File patchFile, boolean isUpgradePatch) {
-
+                                                String patchVersionDirectory, File patchFile) {
         if (!manager.isEnabledForDex()) {
             TinkerLog.w(TAG, "patch recover, dex is not enabled");
             return true;
@@ -66,55 +63,70 @@ protected static boolean tryRecoverDexFiles(Tinker manager, ShareSecurityCheck c
         }
 
         long begin = SystemClock.elapsedRealtime();
-        boolean result = patchDexExtractViaDexDiff(context, patchVersionDirectory, dexMeta, patchFile, isUpgradePatch);
+        boolean result = patchDexExtractViaDexDiff(context, patchVersionDirectory, dexMeta, patchFile);
         long cost = SystemClock.elapsedRealtime() - begin;
-        TinkerLog.i(TAG, "recover dex result:%b, cost:%d, isUpgradePatch:%b", result, cost, isUpgradePatch);
+        TinkerLog.i(TAG, "recover dex result:%b, cost:%d", result, cost);
         return result;
     }
 
-    private static boolean patchDexExtractViaDexDiff(Context context, String patchVersionDirectory, String meta, File patchFile, boolean isUpgradePatch) {
+    private static boolean patchDexExtractViaDexDiff(Context context, String patchVersionDirectory, String meta, final File patchFile) {
         String dir = patchVersionDirectory + "/" + DEX_PATH + "/";
 
-        int dexType = ShareTinkerInternals.isVmArt() ? TYPE_DEX_FOR_ART : TYPE_DEX;
-        if (!extractDexDiffInternals(context, dir, meta, patchFile, dexType, isUpgradePatch)) {
+        if (!extractDexDiffInternals(context, dir, meta, patchFile, TYPE_DEX)) {
             TinkerLog.w(TAG, "patch recover, extractDiffInternals fail");
             return false;
         }
 
-        Tinker manager = Tinker.with(context);
+        final Tinker manager = Tinker.with(context);
 
         File dexFiles = new File(dir);
         File[] files = dexFiles.listFiles();
 
         if (files != null) {
-            String optimizeDexDirectory = patchVersionDirectory + "/" + DEX_OPTIMIZE_PATH + "/";
+            final String optimizeDexDirectory = patchVersionDirectory + "/" + DEX_OPTIMIZE_PATH + "/";
             File optimizeDexDirectoryFile = new File(optimizeDexDirectory);
 
             if (!optimizeDexDirectoryFile.exists()) {
                 optimizeDexDirectoryFile.mkdirs();
             }
 
-            for (File file : files) {
-                try {
-                    String outputPathName = SharePatchFileUtil.optimizedPathFor(file, optimizeDexDirectoryFile);
-                    long start = System.currentTimeMillis();
-                    DexFile.loadDex(file.getAbsolutePath(), outputPathName, 0);
-                    TinkerLog.i(TAG, "success dex optimize file, path: %s, use time: %d", file.getPath(), (System.currentTimeMillis() - start));
-                } catch (Throwable e) {
-                    TinkerLog.e(TAG, "dex optimize or load failed, path:" + file.getPath());
-                    //delete file
-                    SharePatchFileUtil.safeDeleteFile(file);
-                    manager.getPatchReporter().onPatchDexOptFail(patchFile, file, optimizeDexDirectory, file.getName(), e, isUpgradePatch);
-                    return false;
-                }
-            }
+            TinkerLog.w(TAG, "patch recover, try to optimize dex file count:%d", files.length);
+
+            boolean isSuccess = TinkerParallelDexOptimizer.optimizeAll(
+                    files, optimizeDexDirectoryFile,
+                    new TinkerParallelDexOptimizer.ResultCallback() {
+                        long start;
+                        @Override
+                        public void onStart(File dexFile, File optimizedDir) {
+                            start = System.currentTimeMillis();
+                            TinkerLog.i(TAG, "start to optimize dex %s", dexFile.getPath());
+                        }
+
+                        @Override
+                        public void onSuccess(File dexFile, File optimizedDir) {
+                            // Do nothing.
+                            TinkerLog.i(TAG, "success to optimize dex %s use time %d",
+                                dexFile.getPath(), (System.currentTimeMillis() - start));
+                        }
+
+                        @Override
+                        public void onFailed(File dexFile, File optimizedDir, Throwable thr) {
+                            TinkerLog.i(TAG, "fail to optimize dex %s use time %d",
+                                dexFile.getPath(), (System.currentTimeMillis() - start));
+
+                            SharePatchFileUtil.safeDeleteFile(dexFile);
+                            manager.getPatchReporter().onPatchDexOptFail(patchFile, dexFile, optimizeDexDirectory, dexFile.getName(), thr);
+                        }
+                    }
+            );
+
+            return isSuccess;
         }
 
         return true;
     }
 
-
-    private static boolean extractDexDiffInternals(Context context, String dir, String meta, File patchFile, int type, boolean isUpgradePatch) {
+    private static boolean extractDexDiffInternals(Context context, String dir, String meta, File patchFile, int type) {
         //parse
         ArrayList<ShareDexDiffPatchInfo> patchList = new ArrayList<>();
 
@@ -144,28 +156,6 @@ private static boolean extractDexDiffInternals(Context context, String dir, Stri
             apk = new ZipFile(apkPath);
             patch = new ZipFile(patchFile);
 
-            SmallPatchedDexItemFile smallPatchInfoFile = null;
-
-            if (ShareTinkerInternals.isVmArt()) {
-                File extractedFile = new File(dir + ShareConstants.DEX_SMALLPATCH_INFO_FILE);
-                ZipEntry smallPatchInfoEntry = patch.getEntry(ShareConstants.DEX_SMALLPATCH_INFO_FILE);
-                if (smallPatchInfoEntry != null) {
-                    InputStream smallPatchInfoIs = null;
-                    try {
-                        smallPatchInfoIs = patch.getInputStream(smallPatchInfoEntry);
-                        smallPatchInfoFile = new SmallPatchedDexItemFile(smallPatchInfoIs);
-                    } catch (Throwable e) {
-                        TinkerLog.w(TAG, "failed to read small patched info. reason: " + e.getMessage());
-                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, ShareConstants.DEX_SMALLPATCH_INFO_FILE, type, isUpgradePatch);
-                        return false;
-                    } finally {
-                        SharePatchFileUtil.closeQuietly(smallPatchInfoIs);
-                    }
-                } else {
-                    TinkerLog.w(TAG, "small patch info is not exists, it's ok now.");
-                }
-            }
-
             for (ShareDexDiffPatchInfo info : patchList) {
                 long start = System.currentTimeMillis();
 
@@ -180,11 +170,15 @@ private static boolean extractDexDiffInternals(Context context, String dir, Stri
                 String dexDiffMd5 = info.dexDiffMd5;
                 String oldDexCrc = info.oldDexCrC;
 
+                if (!ShareTinkerInternals.isVmArt() && info.destMd5InDvm.equals("0")) {
+                    TinkerLog.w(TAG, "patch dex %s is only for art, just continue", patchRealPath);
+                    continue;
+                }
                 String extractedFileMd5 = ShareTinkerInternals.isVmArt() ? info.destMd5InArt : info.destMd5InDvm;
 
                 if (!SharePatchFileUtil.checkIfMd5Valid(extractedFileMd5)) {
                     TinkerLog.w(TAG, "meta file md5 invalid, type:%s, name: %s, md5: %s", ShareTinkerInternals.getTypeString(type), info.rawName, extractedFileMd5);
-                    manager.getPatchReporter().onPatchPackageCheckFail(patchFile, isUpgradePatch, BasePatchInternal.getMetaCorruptedCode(type));
+                    manager.getPatchReporter().onPatchPackageCheckFail(patchFile, BasePatchInternal.getMetaCorruptedCode(type));
                     return false;
                 }
 
@@ -210,25 +204,25 @@ private static boolean extractDexDiffInternals(Context context, String dir, Stri
                 if (oldDexCrc.equals("0")) {
                     if (patchFileEntry == null) {
                         TinkerLog.w(TAG, "patch entry is null. path:" + patchRealPath);
-                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type, isUpgradePatch);
+                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type);
                         return false;
                     }
 
                     //it is a new file, but maybe we need to repack the dex file
                     if (!extractDexFile(patch, patchFileEntry, extractedFile, info)) {
                         TinkerLog.w(TAG, "Failed to extract raw patch file " + extractedFile.getPath());
-                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type, isUpgradePatch);
+                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type);
                         return false;
                     }
                 } else if (dexDiffMd5.equals("0")) {
-                    // skip process old dex for dalvik vm
+                    // skip process old dex for real dalvik vm
                     if (!ShareTinkerInternals.isVmArt()) {
                         continue;
                     }
 
                     if (rawApkFileEntry == null) {
                         TinkerLog.w(TAG, "apk entry is null. path:" + patchRealPath);
-                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type, isUpgradePatch);
+                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type);
                         return false;
                     }
 
@@ -236,110 +230,60 @@ private static boolean extractDexDiffInternals(Context context, String dir, Stri
                     String rawEntryCrc = String.valueOf(rawApkFileEntry.getCrc());
                     if (!rawEntryCrc.equals(oldDexCrc)) {
                         TinkerLog.e(TAG, "apk entry %s crc is not equal, expect crc: %s, got crc: %s", patchRealPath, oldDexCrc, rawEntryCrc);
-                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type, isUpgradePatch);
+                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type);
                         return false;
                     }
 
-                    InputStream oldDexIs = null;
-                    try {
-                        oldDexIs = apk.getInputStream(rawApkFileEntry);
-                        new DexPatchApplier(oldDexIs, (int) rawApkFileEntry.getSize(), null, smallPatchInfoFile).executeAndSaveTo(extractedFile);
-                    } catch (Throwable e) {
-                        TinkerLog.w(TAG, "Failed to recover dex file " + extractedFile.getPath());
-                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type, isUpgradePatch);
-                        SharePatchFileUtil.safeDeleteFile(extractedFile);
-                        return false;
-                    } finally {
-                        SharePatchFileUtil.closeQuietly(oldDexIs);
-                    }
+                    // Small patched dex generating strategy was disabled, we copy full original dex directly now.
+                    //patchDexFile(apk, patch, rawApkFileEntry, null, info, smallPatchInfoFile, extractedFile);
+                    extractDexFile(apk, rawApkFileEntry, extractedFile, info);
 
                     if (!SharePatchFileUtil.verifyDexFileMd5(extractedFile, extractedFileMd5)) {
-                        TinkerLog.w(TAG, "Failed to recover dex file " + extractedFile.getPath());
-                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type, isUpgradePatch);
+                        TinkerLog.w(TAG, "Failed to recover dex file when verify patched dex: " + extractedFile.getPath());
+                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type);
                         SharePatchFileUtil.safeDeleteFile(extractedFile);
                         return false;
                     }
                 } else {
                     if (patchFileEntry == null) {
                         TinkerLog.w(TAG, "patch entry is null. path:" + patchRealPath);
-                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type, isUpgradePatch);
+                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type);
                         return false;
                     }
 
                     if (!SharePatchFileUtil.checkIfMd5Valid(dexDiffMd5)) {
                         TinkerLog.w(TAG, "meta file md5 invalid, type:%s, name: %s, md5: %s", ShareTinkerInternals.getTypeString(type), info.rawName, dexDiffMd5);
-                        manager.getPatchReporter().onPatchPackageCheckFail(patchFile, isUpgradePatch, BasePatchInternal.getMetaCorruptedCode(type));
+                        manager.getPatchReporter().onPatchPackageCheckFail(patchFile, BasePatchInternal.getMetaCorruptedCode(type));
                         return false;
                     }
 
                     if (rawApkFileEntry == null) {
                         TinkerLog.w(TAG, "apk entry is null. path:" + patchRealPath);
-                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type, isUpgradePatch);
+                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type);
                         return false;
                     }
                     //check source crc instead of md5 for faster
                     String rawEntryCrc = String.valueOf(rawApkFileEntry.getCrc());
                     if (!rawEntryCrc.equals(oldDexCrc)) {
                         TinkerLog.e(TAG, "apk entry %s crc is not equal, expect crc: %s, got crc: %s", patchRealPath, oldDexCrc, rawEntryCrc);
-                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type, isUpgradePatch);
+                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type);
                         return false;
                     }
 
-                    final boolean isRawDexFile = SharePatchFileUtil.isRawDexFile(info.rawName);
-                    InputStream oldInputStream = apk.getInputStream(rawApkFileEntry);
-                    InputStream newInputStream = patch.getInputStream(patchFileEntry);
-                    //if it is not the dex file or we are using jar mode, we should repack the output dex to jar
-                    try {
-                        if (!isRawDexFile || info.isJarMode) {
-                            FileOutputStream fos = new FileOutputStream(extractedFile);
-                            ZipOutputStream zos = new ZipOutputStream(new
-                                BufferedOutputStream(fos));
-
-                            try {
-                                zos.putNextEntry(new ZipEntry(ShareConstants.DEX_IN_JAR));
-                                //it is not a raw dex file, we do not want to any temp files
-                                int oldDexSize;
-                                if (!isRawDexFile) {
-                                    ZipEntry entry;
-                                    ZipInputStream zis = new ZipInputStream(oldInputStream);
-                                    while ((entry = zis.getNextEntry()) != null) {
-                                        if (ShareConstants.DEX_IN_JAR.equals(entry.getName())) break;
-                                    }
-                                    if (entry == null) {
-                                        throw new TinkerRuntimeException("can't recognize zip dex format file:" + extractedFile.getAbsolutePath());
-                                    }
-                                    oldInputStream = zis;
-                                    oldDexSize = (int) entry.getSize();
-                                } else {
-                                    oldDexSize = (int) rawApkFileEntry.getSize();
-                                }
-                                new DexPatchApplier(oldInputStream, oldDexSize, newInputStream, smallPatchInfoFile).executeAndSaveTo(zos);
-                                zos.closeEntry();
-                            } finally {
-                                SharePatchFileUtil.closeQuietly(zos);
-                            }
-
-                        } else {
-                            new DexPatchApplier(oldInputStream, (int) rawApkFileEntry.getSize(), newInputStream, smallPatchInfoFile).executeAndSaveTo(extractedFile);
-                        }
-                    } finally {
-                        SharePatchFileUtil.closeQuietly(oldInputStream);
-                        SharePatchFileUtil.closeQuietly(newInputStream);
-                    }
+                    patchDexFile(apk, patch, rawApkFileEntry, patchFileEntry, info, extractedFile);
 
                     if (!SharePatchFileUtil.verifyDexFileMd5(extractedFile, extractedFileMd5)) {
-                        TinkerLog.w(TAG, "Failed to recover dex file " + extractedFile.getPath());
-                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type, isUpgradePatch);
+                        TinkerLog.w(TAG, "Failed to recover dex file when verify patched dex: " + extractedFile.getPath());
+                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type);
                         SharePatchFileUtil.safeDeleteFile(extractedFile);
                         return false;
                     }
+
                     TinkerLog.w(TAG, "success recover dex file: %s, use time: %d",
-                        extractedFile.getPath(), (System.currentTimeMillis() - start));
+                            extractedFile.getPath(), (System.currentTimeMillis() - start));
                 }
             }
-
         } catch (Throwable e) {
-//            e.printStackTrace();
             throw new TinkerRuntimeException("patch " + ShareTinkerInternals.getTypeString(type) + " extract failed (" + e.getMessage() + ").", e);
         } finally {
             SharePatchFileUtil.closeZip(apk);
@@ -373,7 +317,7 @@ private static boolean extractDexToJar(ZipFile zipFile, ZipEntry entryFile, File
             TinkerLog.i(TAG, "try Extracting " + extractTo.getPath());
             try {
                 zos = new ZipOutputStream(new
-                    BufferedOutputStream(fos));
+                        BufferedOutputStream(fos));
                 bis = new BufferedInputStream(in);
 
                 byte[] buffer = new byte[ShareConstants.BUFFER_SIZE];
@@ -403,6 +347,16 @@ private static boolean extractDexToJar(ZipFile zipFile, ZipEntry entryFile, File
         return isExtractionSuccessful;
     }
 
+//    /**
+//     * reject dalvik vm, but sdk version is larger than 21
+//     */
+//    private static void checkVmArtProperty() {
+//        boolean art = ShareTinkerInternals.isVmArt();
+//        if (!art && Build.VERSION.SDK_INT >= 21) {
+//            throw new TinkerRuntimeException(ShareConstants.CHECK_VM_PROPERTY_FAIL + ", it is dalvik vm, but sdk version " + Build.VERSION.SDK_INT + " is larger than 21!");
+//        }
+//    }
+
     private static boolean extractDexFile(ZipFile zipFile, ZipEntry entryFile, File extractTo, ShareDexDiffPatchInfo dexInfo) throws IOException {
         final String fileMd5 = ShareTinkerInternals.isVmArt() ? dexInfo.destMd5InArt : dexInfo.destMd5InDvm;
         final String rawName = dexInfo.rawName;
@@ -414,4 +368,70 @@ private static boolean extractDexFile(ZipFile zipFile, ZipEntry entryFile, File
         return extract(zipFile, entryFile, extractTo, fileMd5, true);
     }
 
+    /**
+     * Generate patched dex file (May wrapped it by a jar if needed.)
+     * @param baseApk
+     *   OldApk.
+     * @param patchPkg
+     *   Patch package, it is also a zip file.
+     * @param oldDexEntry
+     *   ZipEntry of old dex.
+     * @param patchFileEntry
+     *   ZipEntry of patch file. (also ends with .dex) This could be null.
+     * @param patchInfo
+     *   Parsed patch info from package-meta.txt
+     * @param patchedDexFile
+     *   Patched dex file, may be a jar.
+     *
+     * <b>Notice: patchFileEntry and smallPatchInfoFile cannot both be null.</b>
+     *
+     * @throws IOException
+     */
+    private static void patchDexFile(
+            ZipFile baseApk, ZipFile patchPkg, ZipEntry oldDexEntry, ZipEntry patchFileEntry,
+            ShareDexDiffPatchInfo patchInfo,  File patchedDexFile) throws IOException {
+        InputStream oldDexStream = null;
+        InputStream patchFileStream = null;
+        try {
+            oldDexStream = baseApk.getInputStream(oldDexEntry);
+            patchFileStream = (patchFileEntry != null ? patchPkg.getInputStream(patchFileEntry) : null);
+
+            final boolean isRawDexFile = SharePatchFileUtil.isRawDexFile(patchInfo.rawName);
+            if (!isRawDexFile || patchInfo.isJarMode) {
+                ZipOutputStream zos = null;
+                try {
+                    zos = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(patchedDexFile)));
+                    zos.putNextEntry(new ZipEntry(ShareConstants.DEX_IN_JAR));
+                    // Old dex is not a raw dex file.
+                    if (!isRawDexFile) {
+                        ZipInputStream zis = null;
+                        try {
+                            zis = new ZipInputStream(oldDexStream);
+                            ZipEntry entry;
+                            while ((entry = zis.getNextEntry()) != null) {
+                                if (ShareConstants.DEX_IN_JAR.equals(entry.getName())) break;
+                            }
+                            if (entry == null) {
+                                throw new TinkerRuntimeException("can't recognize zip dex format file:" + patchedDexFile.getAbsolutePath());
+                            }
+                            new DexPatchApplier(zis, (int) entry.getSize(), patchFileStream).executeAndSaveTo(zos);
+                        } finally {
+                            SharePatchFileUtil.closeQuietly(zis);
+                        }
+                    } else {
+                        new DexPatchApplier(oldDexStream, (int) oldDexEntry.getSize(), patchFileStream).executeAndSaveTo(zos);
+                    }
+                    zos.closeEntry();
+                } finally {
+                    SharePatchFileUtil.closeQuietly(zos);
+                }
+            } else {
+                new DexPatchApplier(oldDexStream, (int) oldDexEntry.getSize(), patchFileStream).executeAndSaveTo(patchedDexFile);
+            }
+        } finally {
+            SharePatchFileUtil.closeQuietly(oldDexStream);
+            SharePatchFileUtil.closeQuietly(patchFileStream);
+        }
+    }
+
 }
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/RepairPatch.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/RepairPatch.java
deleted file mode 100644
index 48a7395b..00000000
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/RepairPatch.java
+++ /dev/null
@@ -1,121 +0,0 @@
-/*
- * Tencent is pleased to support the open source community by making Tinker available.
- *
- * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
- *
- * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- *
- * https://opensource.org/licenses/BSD-3-Clause
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is
- * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
- * either express or implied. See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.tencent.tinker.lib.patch;
-
-import android.content.Context;
-
-import com.tencent.tinker.lib.service.PatchResult;
-import com.tencent.tinker.lib.tinker.Tinker;
-import com.tencent.tinker.lib.util.TinkerLog;
-import com.tencent.tinker.loader.shareutil.ShareConstants;
-import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
-import com.tencent.tinker.loader.shareutil.SharePatchInfo;
-import com.tencent.tinker.loader.shareutil.ShareSecurityCheck;
-import com.tencent.tinker.loader.shareutil.ShareTinkerInternals;
-
-import java.io.File;
-
-/**
- * Created by zhangshaowen on 16/3/18.
- *
- * if some of a patch data(such as so, dex) is deleted,
- * we will try to repair them via RepairPatch
- * you can implement your own patch processor class
- */
-public class RepairPatch extends AbstractPatch {
-    private static final String TAG = "Tinker.RepairPatch";
-
-    @Override
-    public boolean tryPatch(Context context, String tempPatchPath, PatchResult patchResult) {
-
-        Tinker manager = Tinker.with(context);
-
-        final File patchFile = new File(tempPatchPath);
-
-        if (!manager.isTinkerEnabled() || !ShareTinkerInternals.isTinkerEnableWithSharedPreferences(context)) {
-            TinkerLog.e(TAG, "RepairPatch tryPatch:patch is disabled, just return");
-            return false;
-        }
-
-        if (!patchFile.isFile() || !patchFile.exists()) {
-            TinkerLog.e(TAG, "RepairPatch tryPatch:patch file is not found, just return");
-            return false;
-        }
-        //check the signature, we should create a new checker
-        ShareSecurityCheck signatureCheck = new ShareSecurityCheck(context);
-
-
-        int returnCode = ShareTinkerInternals.checkTinkerPackage(context, manager.getTinkerFlags(), patchFile, signatureCheck);
-        if (returnCode != ShareConstants.ERROR_PACKAGE_CHECK_OK) {
-            TinkerLog.e(TAG, "RepairPatch tryPatch:onPatchPackageCheckFail");
-            manager.getPatchReporter().onPatchPackageCheckFail(patchFile, false, returnCode);
-            return false;
-        }
-
-        patchResult.patchTinkerID = signatureCheck.getNewTinkerID();
-        patchResult.baseTinkerID = signatureCheck.getTinkerID();
-
-        //it is a old patch, so we should find a exist
-        SharePatchInfo oldInfo = manager.getTinkerLoadResultIfPresent().patchInfo;
-        String patchMd5 = SharePatchFileUtil.getMD5(patchFile);
-
-        //use md5 as version
-        patchResult.patchVersion = patchMd5;
-
-        if (oldInfo == null) {
-            TinkerLog.e(TAG, "OldPatchProcessor tryPatch:onPatchVersionCheckFail, oldInfo is null");
-            manager.getPatchReporter().onPatchVersionCheckFail(patchFile, oldInfo, patchMd5, false);
-            return false;
-        } else {
-            if (oldInfo.oldVersion == null || oldInfo.newVersion == null) {
-                TinkerLog.e(TAG, "RepairPatch tryPatch:onPatchInfoCorrupted");
-                manager.getPatchReporter().onPatchInfoCorrupted(patchFile, oldInfo.oldVersion, oldInfo.newVersion, false);
-                return false;
-            }
-            //already have patch
-            if (!oldInfo.oldVersion.equals(patchMd5) || !oldInfo.newVersion.equals(patchMd5)) {
-                TinkerLog.e(TAG, "RepairPatch tryPatch:onPatchVersionCheckFail");
-                manager.getPatchReporter().onPatchVersionCheckFail(patchFile, oldInfo, patchMd5, false);
-                return false;
-            }
-        }
-
-        //check ok
-        final String patchDirectory = manager.getPatchDirectory().getAbsolutePath();
-
-        final String patchName = SharePatchFileUtil.getPatchVersionDirectory(patchMd5);
-
-        final String patchVersionDirectory = patchDirectory + "/" + patchName;
-
-        if (!DexDiffPatchInternal.tryRecoverDexFiles(manager, signatureCheck, context, patchVersionDirectory, patchFile, false)) {
-            TinkerLog.e(TAG, "RepairPatch tryPatch:try patch dex failed");
-            return false;
-        }
-
-        if (!BsDiffPatchInternal.tryRecoverLibraryFiles(manager, signatureCheck, context, patchVersionDirectory, patchFile, false)) {
-            TinkerLog.e(TAG, "RepairPatch tryPatch:try patch library failed");
-            return false;
-        }
-
-        if (!ResDiffPatchInternal.tryRecoverResourceFiles(manager, signatureCheck, context, patchVersionDirectory, patchFile, false)) {
-            TinkerLog.e(TAG, "RepairPatch tryPatch:try patch resource failed");
-            return false;
-        }
-        return true;
-    }
-
-}
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/ResDiffPatchInternal.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/ResDiffPatchInternal.java
index 21ac8d85..412b2795 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/ResDiffPatchInternal.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/ResDiffPatchInternal.java
@@ -50,7 +50,7 @@
     protected static final String TAG = "Tinker.ResDiffPatchInternal";
 
     protected static boolean tryRecoverResourceFiles(Tinker manager, ShareSecurityCheck checker, Context context,
-                                                String patchVersionDirectory, File patchFile, boolean isUpgradePatch) {
+                                                String patchVersionDirectory, File patchFile) {
 
         if (!manager.isEnabledForResource()) {
             TinkerLog.w(TAG, "patch recover, resource is not enabled");
@@ -64,23 +64,24 @@ protected static boolean tryRecoverResourceFiles(Tinker manager, ShareSecurityCh
         }
 
         long begin = SystemClock.elapsedRealtime();
-        boolean result = patchResourceExtractViaResourceDiff(context, patchVersionDirectory, resourceMeta, patchFile, isUpgradePatch);
+        boolean result = patchResourceExtractViaResourceDiff(context, patchVersionDirectory, resourceMeta, patchFile);
         long cost = SystemClock.elapsedRealtime() - begin;
-        TinkerLog.i(TAG, "recover resource result:%b, cost:%d, isNewPatch:%b", result, cost, isUpgradePatch);
+        TinkerLog.i(TAG, "recover resource result:%b, cost:%d", result, cost);
         return result;
     }
 
-    private static boolean patchResourceExtractViaResourceDiff(Context context, String patchVersionDirectory, String meta, File patchFile, boolean isUpgradePatch) {
+    private static boolean patchResourceExtractViaResourceDiff(Context context, String patchVersionDirectory,
+                                                               String meta, File patchFile) {
         String dir = patchVersionDirectory + "/" + ShareConstants.RES_PATH + "/";
 
-        if (!extractResourceDiffInternals(context, dir, meta, patchFile, TYPE_RESOURCE, isUpgradePatch)) {
+        if (!extractResourceDiffInternals(context, dir, meta, patchFile, TYPE_RESOURCE)) {
             TinkerLog.w(TAG, "patch recover, extractDiffInternals fail");
             return false;
         }
         return true;
     }
 
-    private static boolean extractResourceDiffInternals(Context context, String dir, String meta, File patchFile, int type, boolean isUpgradePatch) {
+    private static boolean extractResourceDiffInternals(Context context, String dir, String meta, File patchFile, int type) {
         ShareResPatchInfo resPatchInfo = new ShareResPatchInfo();
         ShareResPatchInfo.parseAllResPatchInfo(meta, resPatchInfo);
         TinkerLog.i(TAG, "res dir: %s, meta: %s", dir, resPatchInfo.toString());
@@ -88,7 +89,7 @@ private static boolean extractResourceDiffInternals(Context context, String dir,
 
         if (!SharePatchFileUtil.checkIfMd5Valid(resPatchInfo.resArscMd5)) {
             TinkerLog.w(TAG, "resource meta file md5 mismatch, type:%s, md5: %s", ShareTinkerInternals.getTypeString(type), resPatchInfo.resArscMd5);
-            manager.getPatchReporter().onPatchPackageCheckFail(patchFile, isUpgradePatch, BasePatchInternal.getMetaCorruptedCode(type));
+            manager.getPatchReporter().onPatchPackageCheckFail(patchFile, BasePatchInternal.getMetaCorruptedCode(type));
             return false;
         }
         File directory = new File(dir);
@@ -117,7 +118,7 @@ private static boolean extractResourceDiffInternals(Context context, String dir,
             }
             String apkPath = applicationInfo.sourceDir;
 
-            if (!checkAndExtractResourceLargeFile(context, apkPath, directory, patchFile, resPatchInfo, type, isUpgradePatch)) {
+            if (!checkAndExtractResourceLargeFile(context, apkPath, directory, patchFile, resPatchInfo, type)) {
                 return false;
             }
 
@@ -152,7 +153,7 @@ private static boolean extractResourceDiffInternals(Context context, String dir,
                 TinkerZipEntry manifestZipEntry = oldApk.getEntry(ShareConstants.RES_MANIFEST);
                 if (manifestZipEntry == null) {
                     TinkerLog.w(TAG, "manifest patch entry is null. path:" + ShareConstants.RES_MANIFEST);
-                    manager.getPatchReporter().onPatchTypeExtractFail(patchFile, resOutput, ShareConstants.RES_MANIFEST, type, isUpgradePatch);
+                    manager.getPatchReporter().onPatchTypeExtractFail(patchFile, resOutput, ShareConstants.RES_MANIFEST, type);
                     return false;
                 }
                 ResUtil.extractTinkerEntry(oldApk, manifestZipEntry, out);
@@ -162,7 +163,7 @@ private static boolean extractResourceDiffInternals(Context context, String dir,
                     TinkerZipEntry largeZipEntry = oldApk.getEntry(name);
                     if (largeZipEntry == null) {
                         TinkerLog.w(TAG, "large patch entry is null. path:" + name);
-                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, resOutput, name, type, isUpgradePatch);
+                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, resOutput, name, type);
                         return false;
                     }
                     ShareResPatchInfo.LargeModeInfo largeModeInfo = resPatchInfo.largeModMap.get(name);
@@ -174,7 +175,7 @@ private static boolean extractResourceDiffInternals(Context context, String dir,
                     TinkerZipEntry addZipEntry = newApk.getEntry(name);
                     if (addZipEntry == null) {
                         TinkerLog.w(TAG, "add patch entry is null. path:" + name);
-                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, resOutput, name, type, isUpgradePatch);
+                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, resOutput, name, type);
                         return false;
                     }
                     ResUtil.extractTinkerEntry(newApk, addZipEntry, out);
@@ -185,7 +186,7 @@ private static boolean extractResourceDiffInternals(Context context, String dir,
                     TinkerZipEntry modZipEntry = newApk.getEntry(name);
                     if (modZipEntry == null) {
                         TinkerLog.w(TAG, "mod patch entry is null. path:" + name);
-                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, resOutput, name, type, isUpgradePatch);
+                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, resOutput, name, type);
                         return false;
                     }
                     ResUtil.extractTinkerEntry(newApk, modZipEntry, out);
@@ -211,7 +212,7 @@ private static boolean extractResourceDiffInternals(Context context, String dir,
             if (!result) {
                 TinkerLog.i(TAG, "check final new resource file fail path:%s, entry count:%d, size:%d", resOutput.getAbsolutePath(), totalEntryCount, resOutput.length());
                 SharePatchFileUtil.safeDeleteFile(resOutput);
-                manager.getPatchReporter().onPatchTypeExtractFail(patchFile, resOutput, ShareConstants.RES_NAME, type, isUpgradePatch);
+                manager.getPatchReporter().onPatchTypeExtractFail(patchFile, resOutput, ShareConstants.RES_NAME, type);
                 return false;
             }
 
@@ -224,7 +225,7 @@ private static boolean extractResourceDiffInternals(Context context, String dir,
     }
 
     private static boolean checkAndExtractResourceLargeFile(Context context, String apkPath, File directory,
-                                                            File patchFile, ShareResPatchInfo resPatchInfo, int type, boolean isUpgradePatch) {
+                                                            File patchFile, ShareResPatchInfo resPatchInfo, int type) {
         long start = System.currentTimeMillis();
         Tinker manager = Tinker.with(context);
         ZipFile apkFile = null;
@@ -236,14 +237,14 @@ private static boolean checkAndExtractResourceLargeFile(Context context, String
             File arscFile = new File(directory, ShareConstants.RES_ARSC);
             if (arscEntry == null) {
                 TinkerLog.w(TAG, "resources apk entry is null. path:" + ShareConstants.RES_ARSC);
-                manager.getPatchReporter().onPatchTypeExtractFail(patchFile, arscFile, ShareConstants.RES_ARSC, type, isUpgradePatch);
+                manager.getPatchReporter().onPatchTypeExtractFail(patchFile, arscFile, ShareConstants.RES_ARSC, type);
                 return false;
             }
             //use base resources.arsc crc to identify base.apk
             String baseArscCrc = String.valueOf(arscEntry.getCrc());
             if (!baseArscCrc.equals(resPatchInfo.arscBaseCrc)) {
                 TinkerLog.e(TAG, "resources.arsc's crc is not equal, expect crc: %s, got crc: %s", resPatchInfo.arscBaseCrc, baseArscCrc);
-                manager.getPatchReporter().onPatchTypeExtractFail(patchFile, arscFile, ShareConstants.RES_ARSC, type, isUpgradePatch);
+                manager.getPatchReporter().onPatchTypeExtractFail(patchFile, arscFile, ShareConstants.RES_ARSC, type);
                 return false;
             }
 
@@ -258,7 +259,7 @@ private static boolean checkAndExtractResourceLargeFile(Context context, String
 
                 if (largeModeInfo == null) {
                     TinkerLog.w(TAG, "resource not found largeModeInfo, type:%s, name: %s", ShareTinkerInternals.getTypeString(type), name);
-                    manager.getPatchReporter().onPatchPackageCheckFail(patchFile, isUpgradePatch, BasePatchInternal.getMetaCorruptedCode(type));
+                    manager.getPatchReporter().onPatchPackageCheckFail(patchFile, BasePatchInternal.getMetaCorruptedCode(type));
                     return false;
                 }
 
@@ -268,21 +269,21 @@ private static boolean checkAndExtractResourceLargeFile(Context context, String
                 //we do not check the intermediate files' md5 to save time, use check whether it is 32 length
                 if (!SharePatchFileUtil.checkIfMd5Valid(largeModeInfo.md5)) {
                     TinkerLog.w(TAG, "resource meta file md5 mismatch, type:%s, name: %s, md5: %s", ShareTinkerInternals.getTypeString(type), name, largeModeInfo.md5);
-                    manager.getPatchReporter().onPatchPackageCheckFail(patchFile, isUpgradePatch, BasePatchInternal.getMetaCorruptedCode(type));
+                    manager.getPatchReporter().onPatchPackageCheckFail(patchFile, BasePatchInternal.getMetaCorruptedCode(type));
                     return false;
                 }
                 patchZipFile = new ZipFile(patchFile);
                 ZipEntry patchEntry = patchZipFile.getEntry(name);
                 if (patchEntry == null) {
                     TinkerLog.w(TAG, "large mod patch entry is null. path:" + name);
-                    manager.getPatchReporter().onPatchTypeExtractFail(patchFile, largeModeInfo.file, name, type, isUpgradePatch);
+                    manager.getPatchReporter().onPatchTypeExtractFail(patchFile, largeModeInfo.file, name, type);
                     return false;
                 }
 
                 ZipEntry baseEntry = apkFile.getEntry(name);
                 if (baseEntry == null) {
                     TinkerLog.w(TAG, "resources apk entry is null. path:" + name);
-                    manager.getPatchReporter().onPatchTypeExtractFail(patchFile, largeModeInfo.file, name, type, isUpgradePatch);
+                    manager.getPatchReporter().onPatchTypeExtractFail(patchFile, largeModeInfo.file, name, type);
                     return false;
                 }
                 InputStream oldStream = null;
@@ -299,10 +300,10 @@ private static boolean checkAndExtractResourceLargeFile(Context context, String
                 if (!SharePatchFileUtil.verifyFileMd5(largeModeInfo.file, largeModeInfo.md5)) {
                     TinkerLog.w(TAG, "Failed to recover large modify file:%s", largeModeInfo.file.getPath());
                     SharePatchFileUtil.safeDeleteFile(largeModeInfo.file);
-                    manager.getPatchReporter().onPatchTypeExtractFail(patchFile, largeModeInfo.file, name, type, isUpgradePatch);
+                    manager.getPatchReporter().onPatchTypeExtractFail(patchFile, largeModeInfo.file, name, type);
                     return false;
                 }
-                TinkerLog.w(TAG, "success recover large modify file:%s , file size:%d, use time:%d", largeModeInfo.file.getPath(), largeModeInfo.file.length(), (System.currentTimeMillis() - largeStart));
+                TinkerLog.w(TAG, "success recover large modify file:%s, file size:%d, use time:%d", largeModeInfo.file.getPath(), largeModeInfo.file.length(), (System.currentTimeMillis() - largeStart));
             }
             TinkerLog.w(TAG, "success recover all large modify use time:%d", (System.currentTimeMillis() - start));
         } catch (Throwable e) {
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/UpgradePatch.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/UpgradePatch.java
index bdbcd9ba..009e5964 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/UpgradePatch.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/UpgradePatch.java
@@ -17,6 +17,7 @@
 package com.tencent.tinker.lib.patch;
 
 import android.content.Context;
+import android.os.Build;
 
 import com.tencent.tinker.lib.service.PatchResult;
 import com.tencent.tinker.lib.tinker.Tinker;
@@ -59,13 +60,10 @@ public boolean tryPatch(Context context, String tempPatchPath, PatchResult patch
         int returnCode = ShareTinkerInternals.checkTinkerPackage(context, manager.getTinkerFlags(), patchFile, signatureCheck);
         if (returnCode != ShareConstants.ERROR_PACKAGE_CHECK_OK) {
             TinkerLog.e(TAG, "UpgradePatch tryPatch:onPatchPackageCheckFail");
-            manager.getPatchReporter().onPatchPackageCheckFail(patchFile, true, returnCode);
+            manager.getPatchReporter().onPatchPackageCheckFail(patchFile, returnCode);
             return false;
         }
 
-        patchResult.patchTinkerID = signatureCheck.getNewTinkerID();
-        patchResult.baseTinkerID = signatureCheck.getTinkerID();
-
         //it is a new patch, so we should not find a exist
         SharePatchInfo oldInfo = manager.getTinkerLoadResultIfPresent().patchInfo;
         String patchMd5 = SharePatchFileUtil.getMD5(patchFile);
@@ -84,24 +82,24 @@ public boolean tryPatch(Context context, String tempPatchPath, PatchResult patch
         if (oldInfo != null) {
             if (oldInfo.oldVersion == null || oldInfo.newVersion == null) {
                 TinkerLog.e(TAG, "UpgradePatch tryPatch:onPatchInfoCorrupted");
-                manager.getPatchReporter().onPatchInfoCorrupted(patchFile, oldInfo.oldVersion, oldInfo.newVersion, true);
+                manager.getPatchReporter().onPatchInfoCorrupted(patchFile, oldInfo.oldVersion, oldInfo.newVersion);
                 return false;
             }
 
             if (oldInfo.oldVersion.equals(patchMd5) || oldInfo.newVersion.equals(patchMd5)) {
                 TinkerLog.e(TAG, "UpgradePatch tryPatch:onPatchVersionCheckFail");
-                manager.getPatchReporter().onPatchVersionCheckFail(patchFile, oldInfo, patchMd5, true);
+                manager.getPatchReporter().onPatchVersionCheckFail(patchFile, oldInfo, patchMd5);
                 return false;
             }
-            newInfo = new SharePatchInfo(oldInfo.oldVersion, patchMd5);
+            newInfo = new SharePatchInfo(oldInfo.oldVersion, patchMd5, Build.FINGERPRINT);
         } else {
-            newInfo = new SharePatchInfo("", patchMd5);
+            newInfo = new SharePatchInfo("", patchMd5, Build.FINGERPRINT);
         }
 
         //check ok, we can real recover a new patch
         final String patchDirectory = manager.getPatchDirectory().getAbsolutePath();
 
-        TinkerLog.i(TAG, "UpgradePatch tryPatch:dexDiffMd5:%s", patchMd5);
+        TinkerLog.i(TAG, "UpgradePatch tryPatch:patchMd5:%s", patchMd5);
 
         final String patchName = SharePatchFileUtil.getPatchVersionDirectory(patchMd5);
 
@@ -122,22 +120,22 @@ public boolean tryPatch(Context context, String tempPatchPath, PatchResult patch
         } catch (IOException e) {
 //            e.printStackTrace();
             TinkerLog.e(TAG, "UpgradePatch tryPatch:copy patch file fail from %s to %s", patchFile.getPath(), destPatchFile.getPath());
-            manager.getPatchReporter().onPatchTypeExtractFail(patchFile, destPatchFile, patchFile.getName(), ShareConstants.TYPE_PATCH_FILE, true);
+            manager.getPatchReporter().onPatchTypeExtractFail(patchFile, destPatchFile, patchFile.getName(), ShareConstants.TYPE_PATCH_FILE);
             return false;
         }
 
         //we use destPatchFile instead of patchFile, because patchFile may be deleted during the patch process
-        if (!DexDiffPatchInternal.tryRecoverDexFiles(manager, signatureCheck, context, patchVersionDirectory, destPatchFile, true)) {
+        if (!DexDiffPatchInternal.tryRecoverDexFiles(manager, signatureCheck, context, patchVersionDirectory, destPatchFile)) {
             TinkerLog.e(TAG, "UpgradePatch tryPatch:new patch recover, try patch dex failed");
             return false;
         }
 
-        if (!BsDiffPatchInternal.tryRecoverLibraryFiles(manager, signatureCheck, context, patchVersionDirectory, destPatchFile, true)) {
+        if (!BsDiffPatchInternal.tryRecoverLibraryFiles(manager, signatureCheck, context, patchVersionDirectory, destPatchFile)) {
             TinkerLog.e(TAG, "UpgradePatch tryPatch:new patch recover, try patch library failed");
             return false;
         }
 
-        if (!ResDiffPatchInternal.tryRecoverResourceFiles(manager, signatureCheck, context, patchVersionDirectory, destPatchFile, true)) {
+        if (!ResDiffPatchInternal.tryRecoverResourceFiles(manager, signatureCheck, context, patchVersionDirectory, destPatchFile)) {
             TinkerLog.e(TAG, "UpgradePatch tryPatch:new patch recover, try patch resource failed");
             return false;
         }
@@ -146,7 +144,7 @@ public boolean tryPatch(Context context, String tempPatchPath, PatchResult patch
 
         if (!SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile, newInfo, SharePatchFileUtil.getPatchInfoLockFile(patchDirectory))) {
             TinkerLog.e(TAG, "UpgradePatch tryPatch:new patch recover, rewrite patch info failed");
-            manager.getPatchReporter().onPatchInfoCorrupted(patchFile, newInfo.oldVersion, newInfo.newVersion, true);
+            manager.getPatchReporter().onPatchInfoCorrupted(patchFile, newInfo.oldVersion, newInfo.newVersion);
             return false;
         }
 
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultLoadReporter.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultLoadReporter.java
index 75b3a76c..f096f855 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultLoadReporter.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultLoadReporter.java
@@ -21,7 +21,6 @@
 
 import com.tencent.tinker.lib.service.TinkerPatchService;
 import com.tencent.tinker.lib.tinker.Tinker;
-import com.tencent.tinker.lib.tinker.TinkerInstaller;
 import com.tencent.tinker.lib.util.TinkerLog;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
 import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
@@ -54,12 +53,11 @@ public DefaultLoadReporter(Context context) {
      *                  {@code ShareConstants.ERROR_PATCH_NOTEXIST}            the file of tempPatchPatch file is not exist
      *                  {@code ShareConstants.ERROR_PATCH_RUNNING}             the recover service is running now, try later
      *                  {@code ShareConstants.ERROR_PATCH_INSERVICE}           the recover service can't send patch request
-     *
-     * @param isUpgrade whether is a new patch, or just recover the old patch
      */
     @Override
-    public void onLoadPatchListenerReceiveFail(File patchFile, int errorCode, boolean isUpgrade) {
-        TinkerLog.i(TAG, "patch load Reporter: patch receive fail:%s, code:%d, isUpgrade:%b", patchFile.getAbsolutePath(), errorCode, isUpgrade);
+    public void onLoadPatchListenerReceiveFail(File patchFile, int errorCode) {
+        TinkerLog.i(TAG, "patch loadReporter onLoadPatchListenerReceiveFail: patch receive fail:%s, code:%d",
+            patchFile.getAbsolutePath(), errorCode);
     }
 
 
@@ -76,7 +74,7 @@ public void onLoadPatchListenerReceiveFail(File patchFile, int errorCode, boolea
      */
     @Override
     public void onLoadPatchVersionChanged(String oldVersion, String newVersion, File patchDirectoryFile, String currentPatchName) {
-        TinkerLog.i(TAG, "patch version change from " + oldVersion + " to " + newVersion);
+        TinkerLog.i(TAG, "patch loadReporter onLoadPatchVersionChanged: patch version change from " + oldVersion + " to " + newVersion);
 
         if (oldVersion == null || newVersion == null) {
             return;
@@ -122,21 +120,10 @@ public void onLoadPatchVersionChanged(String oldVersion, String newVersion, File
      */
     @Override
     public void onLoadFileNotFound(File file, int fileType, boolean isDirectory) {
-        TinkerLog.i(TAG, "patch file not found: %s, fileType:%d, isDirectory:%b", file.getAbsolutePath(), fileType, isDirectory);
-        if (fileType == ShareConstants.TYPE_DEX || fileType == ShareConstants.TYPE_DEX_OPT
-            || fileType == ShareConstants.TYPE_LIBRARY || fileType == ShareConstants.TYPE_RESOURCE) {
-            Tinker tinker = Tinker.with(context);
+        TinkerLog.i(TAG, "patch loadReporter onLoadFileNotFound: patch file not found: %s, fileType:%d, isDirectory:%b",
+            file.getAbsolutePath(), fileType, isDirectory);
 
-            //we can recover at any process except recover process
-            if (!tinker.isPatchProcess()) {
-                File patchVersionFile = tinker.getTinkerLoadResultIfPresent().patchVersionFile;
-                if (patchVersionFile != null) {
-                    TinkerInstaller.onReceiveRepairPatch(context, patchVersionFile.getAbsolutePath());
-                }
-            }
-        } else if (fileType == ShareConstants.TYPE_PATCH_FILE || fileType == ShareConstants.TYPE_PATCH_INFO) {
-            Tinker.with(context).cleanPatch();
-        }
+        Tinker.with(context).cleanPatch();
     }
 
     /**
@@ -153,7 +140,7 @@ public void onLoadFileNotFound(File file, int fileType, boolean isDirectory) {
      */
     @Override
     public void onLoadFileMd5Mismatch(File file, int fileType) {
-        TinkerLog.i(TAG, "patch file md5 mismatch file: %s, fileType:%d", file.getAbsolutePath(), fileType);
+        TinkerLog.i(TAG, "patch load Reporter onLoadFileMd5Mismatch: patch file md5 mismatch file: %s, fileType:%d", file.getAbsolutePath(), fileType);
         //clean patch for safety
         Tinker.with(context).cleanPatch();
     }
@@ -169,8 +156,8 @@ public void onLoadFileMd5Mismatch(File file, int fileType) {
      */
     @Override
     public void onLoadPatchInfoCorrupted(String oldVersion, String newVersion, File patchInfoFile) {
-        TinkerLog.i(TAG, "patch info file damage: %s", patchInfoFile.getAbsolutePath());
-        TinkerLog.i(TAG, "patch info file damage from version: %s to version: %s", oldVersion, newVersion);
+        TinkerLog.i(TAG, "patch loadReporter onLoadPatchInfoCorrupted: patch info file damage: %s, from version: %s to version: %s",
+            patchInfoFile.getAbsolutePath(), oldVersion, newVersion);
 
         Tinker.with(context).cleanPatch();
     }
@@ -185,7 +172,7 @@ public void onLoadPatchInfoCorrupted(String oldVersion, String newVersion, File
      */
     @Override
     public void onLoadResult(File patchDirectory, int loadCode, long cost) {
-        TinkerLog.i(TAG, "patch load result, path:%s, code:%d, cost:%d", patchDirectory.getAbsolutePath(), loadCode, cost);
+        TinkerLog.i(TAG, "patch loadReporter onLoadResult: patch load result, path:%s, code:%d, cost:%d", patchDirectory.getAbsolutePath(), loadCode, cost);
         //you can just report the result here
     }
 
@@ -208,32 +195,36 @@ public void onLoadException(Throwable e, int errorCode) {
         switch (errorCode) {
             case ShareConstants.ERROR_LOAD_EXCEPTION_DEX:
                 if (e.getMessage().contains(ShareConstants.CHECK_DEX_INSTALL_FAIL)) {
-                    TinkerLog.e(TAG, "tinker dex check fail:" + e.getMessage());
+                    TinkerLog.e(TAG, "patch loadReporter onLoadException: tinker dex check fail:" + e.getMessage());
                 } else {
-                    TinkerLog.i(TAG, "patch load dex exception: %s", e);
+                    TinkerLog.i(TAG, "patch loadReporter onLoadException: patch load dex exception: %s", e);
                 }
                 ShareTinkerInternals.setTinkerDisableWithSharedPreferences(context);
                 TinkerLog.i(TAG, "dex exception disable tinker forever with sp");
                 break;
+            case ShareConstants.ERROR_LOAD_EXCEPTION_DEX_OPT:
+                TinkerLog.i(TAG, "patch load parallel dex opt exception: %s", e);
+                break;
             case ShareConstants.ERROR_LOAD_EXCEPTION_RESOURCE:
                 if (e.getMessage().contains(ShareConstants.CHECK_RES_INSTALL_FAIL)) {
-                    TinkerLog.e(TAG, "tinker res check fail:" + e.getMessage());
+                    TinkerLog.e(TAG, "patch loadReporter onLoadException: tinker res check fail:" + e.getMessage());
                 } else {
-                    TinkerLog.i(TAG, "patch load resource exception: %s", e);
+                    TinkerLog.i(TAG, "patch loadReporter onLoadException: patch load resource exception: %s", e);
                 }
                 ShareTinkerInternals.setTinkerDisableWithSharedPreferences(context);
                 TinkerLog.i(TAG, "res exception disable tinker forever with sp");
                 break;
             case ShareConstants.ERROR_LOAD_EXCEPTION_UNCAUGHT:
-                TinkerLog.i(TAG, "patch load unCatch exception: %s", e);
+                TinkerLog.i(TAG, "patch loadReporter onLoadException: patch load unCatch exception: %s", e);
                 ShareTinkerInternals.setTinkerDisableWithSharedPreferences(context);
                 TinkerLog.i(TAG, "unCaught exception disable tinker forever with sp");
                 break;
             case ShareConstants.ERROR_LOAD_EXCEPTION_UNKNOWN:
-                TinkerLog.i(TAG, "patch load unknown exception: %s", e);
+                TinkerLog.i(TAG, "patch loadReporter onLoadException: patch load unknown exception: %s", e);
                 //exception can be caught, it is no need to disable Tinker with sharedPreference
                 break;
         }
+        TinkerLog.e(TAG, "tinker load exception, welcome to submit issue to us: https://github.com/Tencent/tinker/issues");
         TinkerLog.printErrStackTrace(TAG, e, "tinker load exception");
 
         Tinker.with(context).setTinkerDisable();
@@ -257,7 +248,8 @@ public void onLoadException(Throwable e, int errorCode) {
      */
     @Override
     public void onLoadPackageCheckFail(File patchFile, int errorCode) {
-        TinkerLog.i(TAG, "load patch package check fail file path:%s, errorCode:%d", patchFile.getAbsolutePath(), errorCode);
+        TinkerLog.i(TAG, "patch loadReporter onLoadPackageCheckFail: "
+            + "load patch package check fail file path:%s, errorCode:%d", patchFile.getAbsolutePath(), errorCode);
         Tinker.with(context).cleanPatch();
     }
 }
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultPatchReporter.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultPatchReporter.java
index 88a9a406..9d1dca7e 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultPatchReporter.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultPatchReporter.java
@@ -52,7 +52,7 @@ public DefaultPatchReporter(Context context) {
      */
     @Override
     public void onPatchServiceStart(Intent intent) {
-        TinkerLog.i(TAG, "patchReporter: patch service start");
+        TinkerLog.i(TAG, "patchReporter onPatchServiceStart: patch service start");
     }
 
     /**
@@ -72,8 +72,9 @@ public void onPatchServiceStart(Intent intent) {
      *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT}          some patch file type is not supported for current tinkerFlag
      */
     @Override
-    public void onPatchPackageCheckFail(File patchFile, boolean isUpgradePatch, int errorCode) {
-        TinkerLog.i(TAG, "patchReporter: package check failed. path:%s, isUpgrade:%b, code:%d", patchFile.getAbsolutePath(), isUpgradePatch, errorCode);
+    public void onPatchPackageCheckFail(File patchFile, int errorCode) {
+        TinkerLog.i(TAG, "patchReporter onPatchPackageCheckFail: package check failed. path:%s, code:%d",
+            patchFile.getAbsolutePath(), errorCode);
         //only meta corrupted, need to delete temp files. others is just in the check time!
         if (errorCode == ShareConstants.ERROR_PACKAGE_CHECK_DEX_META_CORRUPTED
             || errorCode == ShareConstants.ERROR_PACKAGE_CHECK_LIB_META_CORRUPTED
@@ -90,11 +91,11 @@ public void onPatchPackageCheckFail(File patchFile, boolean isUpgradePatch, int
      * @param patchFile        the input patch file to recover
      * @param oldPatchInfo     the current patch info
      * @param patchFileVersion it is the md5 of the input patchFile
-     * @param isUpgradePatch   whether it is a new patch file, or just recover some of the current patch files
      */
     @Override
-    public void onPatchVersionCheckFail(File patchFile, SharePatchInfo oldPatchInfo, String patchFileVersion, boolean isUpgradePatch) {
-        TinkerLog.i(TAG, "patchReporter: patch version exist. path:%s, version:%s, isUpgrade:%b", patchFile.getAbsolutePath(), patchFileVersion, isUpgradePatch);
+    public void onPatchVersionCheckFail(File patchFile, SharePatchInfo oldPatchInfo, String patchFileVersion) {
+        TinkerLog.i(TAG, "patchReporter onPatchVersionCheckFail: patch version exist. path:%s, version:%s",
+            patchFile.getAbsolutePath(), patchFileVersion);
         //no need to delete temp files, because it is only in the check time!
     }
 
@@ -110,12 +111,11 @@ public void onPatchVersionCheckFail(File patchFile, SharePatchInfo oldPatchInfo,
      *                       {@code ShareConstants.TYPE_LIBRARY}     extract patch library fail
      *                       {@code ShareConstants.TYPE_PATCH_FILE}  copy patch file fail
      *                       {@code ShareConstants.TYPE_RESOURCE}    extract patch resource fail
-     * @param isUpgradePatch whether it is a new patch file, or just recover some of the current patch files
      */
     @Override
-    public void onPatchTypeExtractFail(File patchFile, File extractTo, String filename, int fileType, boolean isUpgradePatch) {
-        TinkerLog.i(TAG, "patchReporter: file extract fail type:%s, path:%s, extractTo:%s, filename:%s, isUpgrade:%b",
-            ShareTinkerInternals.getTypeString(fileType), patchFile.getPath(), extractTo.getPath(), filename, isUpgradePatch);
+    public void onPatchTypeExtractFail(File patchFile, File extractTo, String filename, int fileType) {
+        TinkerLog.i(TAG, "patchReporter onPatchTypeExtractFail: file extract fail type:%s, path:%s, extractTo:%s, filename:%s",
+            ShareTinkerInternals.getTypeString(fileType), patchFile.getPath(), extractTo.getPath(), filename);
         //delete temp files
         Tinker.with(context).cleanPatchByVersion(patchFile);
     }
@@ -127,12 +127,11 @@ public void onPatchTypeExtractFail(File patchFile, File extractTo, String filena
      * @param dexFile        the dex file
      * @param optDirectory
      * @param dexName        dexName try to dexOpt
-     * @param isUpgradePatch whether it is a new patch file, or just recover some of the current patch files
      */
     @Override
-    public void onPatchDexOptFail(File patchFile, File dexFile, String optDirectory, String dexName, Throwable t, boolean isUpgradePatch) {
-        TinkerLog.i(TAG, "patchReporter: dex opt fail path:%s, dexPath:%s, optDir:%s, dexName:%s, isUpgrade:%b",
-            patchFile.getAbsolutePath(), dexFile.getPath(), optDirectory, dexName, isUpgradePatch);
+    public void onPatchDexOptFail(File patchFile, File dexFile, String optDirectory, String dexName, Throwable t) {
+        TinkerLog.i(TAG, "patchReporter onPatchDexOptFail: dex opt fail path:%s, dexPath:%s, optDir:%s, dexName:%s",
+            patchFile.getAbsolutePath(), dexFile.getPath(), optDirectory, dexName);
         TinkerLog.printErrStackTrace(TAG, t, "onPatchDexOptFail:");
         //delete temp files
         Tinker.with(context).cleanPatchByVersion(patchFile);
@@ -144,11 +143,11 @@ public void onPatchDexOptFail(File patchFile, File dexFile, String optDirectory,
      * @param patchFile      the input patch file to recover
      * @param success        if it is success
      * @param cost           cost time in ms
-     * @param isUpgradePatch whether it is a new patch file, or just recover some of the current patch files
      */
     @Override
-    public void onPatchResult(File patchFile, boolean success, long cost, boolean isUpgradePatch) {
-        TinkerLog.i(TAG, "patchReporter: patch all result path:%s, success:%b, cost:%d, isUpgrade:%b", patchFile.getAbsolutePath(), success, cost, isUpgradePatch);
+    public void onPatchResult(File patchFile, boolean success, long cost) {
+        TinkerLog.i(TAG, "patchReporter onPatchResult: patch all result path:%s, success:%b, cost:%d",
+            patchFile.getAbsolutePath(), success, cost);
         //you can just report the result here
     }
 
@@ -159,11 +158,11 @@ public void onPatchResult(File patchFile, boolean success, long cost, boolean is
      * @param patchFile      the input patch file to recover
      * @param oldVersion     old patch version
      * @param newVersion     new patch version
-     * @param isUpgradePatch whether it is a new patch file, or just recover some of the current patch files
      */
     @Override
-    public void onPatchInfoCorrupted(File patchFile, String oldVersion, String newVersion, boolean isUpgradePatch) {
-        TinkerLog.i(TAG, "patchReporter: patch info is corrupted. old:%s, new:%s, isUpgradeP:%b", oldVersion, newVersion, isUpgradePatch);
+    public void onPatchInfoCorrupted(File patchFile, String oldVersion, String newVersion) {
+        TinkerLog.i(TAG, "patchReporter onPatchInfoCorrupted: patch info is corrupted. old:%s, new:%s",
+            oldVersion, newVersion);
         //patch.info is corrupted, just clean all patch
         Tinker.with(context).cleanPatch();
     }
@@ -175,11 +174,16 @@ public void onPatchInfoCorrupted(File patchFile, String oldVersion, String newVe
      *
      * @param patchFile      the input file to patch
      * @param e
-     * @param isUpgradePatch whether it is a new patch file, or just recover some of the current patch files
      */
     @Override
-    public void onPatchException(File patchFile, Throwable e, boolean isUpgradePatch) {
-        TinkerLog.i(TAG, "patchReporter: patch exception path:%s, throwable:%s, isUpgrade:%b", patchFile.getAbsolutePath(), e.getMessage(), isUpgradePatch);
+    public void onPatchException(File patchFile, Throwable e) {
+        TinkerLog.i(TAG, "patchReporter onPatchException: patch exception path:%s, throwable:%s",
+            patchFile.getAbsolutePath(), e.getMessage());
+        TinkerLog.e(TAG, "tinker patch exception, welcome to submit issue to us: https://github.com/Tencent/tinker/issues");
+//        if (e.getMessage().contains(ShareConstants.CHECK_VM_PROPERTY_FAIL)) {
+//            ShareTinkerInternals.setTinkerDisableWithSharedPreferences(context);
+//            TinkerLog.i(TAG, "check vm property exception disable tinker forever with sp");
+//        }
         TinkerLog.printErrStackTrace(TAG, e, "tinker patch exception");
         //don't accept request any more!
         Tinker.with(context).setTinkerDisable();
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/LoadReporter.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/LoadReporter.java
index 5ca258a9..6ff69254 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/LoadReporter.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/LoadReporter.java
@@ -36,9 +36,8 @@
      *                  {@code ShareConstants.ERROR_PATCH_NOTEXIST}            the file of tempPatchPatch file is not exist
      *                  {@code ShareConstants.ERROR_PATCH_RUNNING}             the recover service is running now, try later
      *                  {@code ShareConstants.ERROR_PATCH_INSERVICE}           the recover service can't send patch request
-     * @param isUpgrade whether is a new patch, or just recover the old patch
      */
-    void onLoadPatchListenerReceiveFail(File patchFile, int errorCode, boolean isUpgrade);
+    void onLoadPatchListenerReceiveFail(File patchFile, int errorCode);
 
     /**
      * we can only handle patch version change in the main process,
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/PatchReporter.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/PatchReporter.java
index e9ac07d2..7ba65da4 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/PatchReporter.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/PatchReporter.java
@@ -19,7 +19,6 @@
 
 import android.content.Intent;
 
-import com.tencent.tinker.lib.patch.RepairPatch;
 import com.tencent.tinker.lib.patch.UpgradePatch;
 import com.tencent.tinker.lib.service.DefaultTinkerResultService;
 import com.tencent.tinker.loader.shareutil.SharePatchInfo;
@@ -29,12 +28,8 @@
 /**
  * Created by zhangshaowen on 16/3/14.
  *
- * isUpgradePatch:
- * true: means that it is a newly patch, we would default use {@link UpgradePatch}
+ * means that it is a newly patch, we would default use {@link UpgradePatch}
  * to do the job
- *
- * false: means that there are some files missing in current patch, we want to repair them,
- * we would default use {@link RepairPatch} to do the recover patch job
  */
 public interface PatchReporter {
 
@@ -61,7 +56,7 @@
      *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_RESOURCE_META_CORRUPTED}         resource meta file's format check fail
      *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT}          some patch file type is not supported for current tinkerFlag
      */
-    void onPatchPackageCheckFail(File patchFile, boolean isUpgradePatch, int errorCode);
+    void onPatchPackageCheckFail(File patchFile, int errorCode);
 
     /**
      * for upgrade patch, patchFileVersion can't equal oldVersion or newVersion in oldPatchInfo
@@ -70,9 +65,8 @@
      * @param patchFile        the input patch file to recover
      * @param oldPatchInfo     the current patch info
      * @param patchFileVersion it is the md5 of the input patchFile
-     * @param isUpgradePatch   whether it is a new patch file, or just recover some of the current patch files
      */
-    void onPatchVersionCheckFail(File patchFile, SharePatchInfo oldPatchInfo, String patchFileVersion, boolean isUpgradePatch);
+    void onPatchVersionCheckFail(File patchFile, SharePatchInfo oldPatchInfo, String patchFileVersion);
 
 
     /**
@@ -87,9 +81,8 @@
      *                       {@code ShareConstants.TYPE_LIBRARY}     extract patch library fail
      *                       {@code ShareConstants.TYPE_PATCH_FILE}  copy patch file fail
      *                       {@code ShareConstants.TYPE_RESOURCE}    extract patch resource fail
-     * @param isUpgradePatch whether it is a new patch file, or just recover some of the current patch files
      */
-    void onPatchTypeExtractFail(File patchFile, File extractTo, String filename, int fileType, boolean isUpgradePatch);
+    void onPatchTypeExtractFail(File patchFile, File extractTo, String filename, int fileType);
 
 
     /**
@@ -100,9 +93,8 @@
      * @param optDirectory
      * @param dexName        dexName try to dexOpt
      * @param t              throwable
-     * @param isUpgradePatch whether it is a new patch file, or just recover some of the current patch files
      */
-    void onPatchDexOptFail(File patchFile, File dexFile, String optDirectory, String dexName, Throwable t, boolean isUpgradePatch);
+    void onPatchDexOptFail(File patchFile, File dexFile, String optDirectory, String dexName, Throwable t);
 
 
     /**
@@ -111,9 +103,8 @@
      * @param patchFile      the input patch file to recover
      * @param success        if it is success
      * @param cost           cost time in ms
-     * @param isUpgradePatch whether it is a new patch file, or just recover some of the current patch files
      */
-    void onPatchResult(File patchFile, boolean success, long cost, boolean isUpgradePatch);
+    void onPatchResult(File patchFile, boolean success, long cost);
 
     /**
      * recover patch occur unknown exception that we have wrap try catch for you!
@@ -122,9 +113,8 @@
      *
      * @param patchFile      the input file to patch
      * @param e
-     * @param isUpgradePatch whether it is a new patch file, or just recover some of the current patch files
      */
-    void onPatchException(File patchFile, Throwable e, boolean isUpgradePatch);
+    void onPatchException(File patchFile, Throwable e);
 
     /**
      * when we load a new patch, we need to rewrite the patch.info file.
@@ -133,8 +123,7 @@
      * @param patchFile      the input patch file to recover
      * @param oldVersion     old patch version
      * @param newVersion     new patch version
-     * @param isUpgradePatch whether it is a new patch file, or just recover some of the current patch files
      */
-    void onPatchInfoCorrupted(File patchFile, String oldVersion, String newVersion, boolean isUpgradePatch);
+    void onPatchInfoCorrupted(File patchFile, String oldVersion, String newVersion);
 
 }
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/AbstractResultService.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/AbstractResultService.java
index 0ecb1bca..19061bae 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/AbstractResultService.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/AbstractResultService.java
@@ -32,7 +32,6 @@
 
     private static final String RESULT_EXTRA = "result_extra";
 
-    private static Class<? extends AbstractResultService> resultServiceClass = null;
 
     /**
      * Creates an IntentService.  Invoked by your subclass's constructor.
@@ -41,27 +40,17 @@ public AbstractResultService() {
         super(AbstractResultService.class.getSimpleName());
     }
 
-    public static void runResultService(Context context, PatchResult result) {
+    public static void runResultService(Context context, PatchResult result, String resultServiceClass) {
         if (resultServiceClass == null) {
             throw new TinkerRuntimeException("resultServiceClass is null.");
         }
-        Intent intent = new Intent(context, resultServiceClass);
+        Intent intent = new Intent();
+        intent.setClassName(context, resultServiceClass);
         intent.putExtra(RESULT_EXTRA, result);
 
         context.startService(intent);
     }
 
-    public static void setResultServiceClass(Class<? extends AbstractResultService> serviceClass) {
-        resultServiceClass = serviceClass;
-        //try to load
-        try {
-            Class.forName(serviceClass.getName());
-        } catch (ClassNotFoundException e) {
-//            e.printStackTrace();
-        }
-
-    }
-
     @Override
     protected void onHandleIntent(Intent intent) {
         if (intent == null) {
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/DefaultTinkerResultService.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/DefaultTinkerResultService.java
index 078fb5ad..a9133f31 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/DefaultTinkerResultService.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/DefaultTinkerResultService.java
@@ -49,7 +49,7 @@ public void onPatchResult(PatchResult result) {
 
         // if success and newPatch, it is nice to delete the raw file, and restart at once
         // only main process can load an upgrade patch!
-        if (result.isSuccess && result.isUpgradePatch) {
+        if (result.isSuccess) {
             File rawFile = new File(result.rawPatchFilePath);
             if (rawFile.exists()) {
                 TinkerLog.i(TAG, "save delete raw patch file");
@@ -61,11 +61,6 @@ public void onPatchResult(PatchResult result) {
                 TinkerLog.i(TAG, "I have already install the newly patch version!");
             }
         }
-
-        //repair current patch fail, just clean!
-        if (!result.isSuccess && !result.isUpgradePatch) {
-            Tinker.with(getApplicationContext()).cleanPatch();
-        }
     }
 
     public boolean checkIfNeedKill(PatchResult result) {
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/PatchResult.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/PatchResult.java
index 9991c4e0..268a4dd8 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/PatchResult.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/PatchResult.java
@@ -22,8 +22,6 @@
  * Created by zhangshaowen on 16/3/19.
  */
 public class PatchResult implements Serializable {
-    public boolean isUpgradePatch;
-
     public boolean isSuccess;
 
     public String rawPatchFilePath;
@@ -35,29 +33,16 @@
     //@Nullable
     public String patchVersion;
 
-    //@Nullable
-    public String patchTinkerID;
-
-    //@Nullable
-    public String baseTinkerID;
-
     @Override
     public String toString() {
         StringBuffer sb = new StringBuffer();
         sb.append("\nPatchResult: \n");
-        sb.append("isUpgradePatch:" + isUpgradePatch + "\n");
         sb.append("isSuccess:" + isSuccess + "\n");
         sb.append("rawPatchFilePath:" + rawPatchFilePath + "\n");
         sb.append("costTime:" + costTime + "\n");
         if (patchVersion != null) {
             sb.append("patchVersion:" + patchVersion + "\n");
         }
-        if (patchTinkerID != null) {
-            sb.append("patchTinkerID:" + patchTinkerID + "\n");
-        }
-        if (baseTinkerID != null) {
-            sb.append("baseTinkerID:" + baseTinkerID + "\n");
-        }
 
         if (e != null) {
             sb.append("Throwable:" + e.getMessage() + "\n");
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/TinkerPatchService.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/TinkerPatchService.java
index 12281e2c..f8773c5a 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/TinkerPatchService.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/TinkerPatchService.java
@@ -41,10 +41,11 @@
     private static final String TAG = "Tinker.TinkerPatchService";
 
     private static final String        PATCH_PATH_EXTRA      = "patch_path_extra";
-    private static final String        PATCH_NEW_EXTRA       = "patch_new_extra";
+    private static final String        RESULT_CLASS_EXTRA    = "patch_result_class";
+
     private static       AbstractPatch upgradePatchProcessor = null;
-    private static       AbstractPatch repairPatchProcessor  = null;
-    private static       int           notificationId        = ShareConstants.TINKER_PATCH_SERVICE_NOTIFICATION;
+    private static       int                                    notificationId       = ShareConstants.TINKER_PATCH_SERVICE_NOTIFICATION;
+    private static       Class<? extends AbstractResultService> resultServiceClass   = null;
 
     /**
      * Creates an IntentService.  Invoked by your subclass's constructor.
@@ -53,17 +54,22 @@ public TinkerPatchService() {
         super(TinkerPatchService.class.getSimpleName());
     }
 
-    public static void runPatchService(Context context, String path, boolean isUpgradePatch) {
+    public static void runPatchService(Context context, String path) {
         Intent intent = new Intent(context, TinkerPatchService.class);
         intent.putExtra(PATCH_PATH_EXTRA, path);
-        intent.putExtra(PATCH_NEW_EXTRA, isUpgradePatch);
-
+        intent.putExtra(RESULT_CLASS_EXTRA, resultServiceClass.getName());
         context.startService(intent);
     }
 
-    public static void setPatchProcessor(AbstractPatch upgradePatch, AbstractPatch repairPatch) {
+    public static void setPatchProcessor(AbstractPatch upgradePatch, Class<? extends AbstractResultService> serviceClass) {
         upgradePatchProcessor = upgradePatch;
-        repairPatchProcessor = repairPatch;
+        resultServiceClass = serviceClass;
+        //try to load
+        try {
+            Class.forName(serviceClass.getName());
+        } catch (ClassNotFoundException e) {
+//            e.printStackTrace();
+        }
     }
 
     public static String getPatchPathExtra(Intent intent) {
@@ -73,11 +79,11 @@ public static String getPatchPathExtra(Intent intent) {
         return ShareIntentUtil.getStringExtra(intent, PATCH_PATH_EXTRA);
     }
 
-    public static boolean getPatchUpgradeExtra(Intent intent) {
+    public static String getPatchResultExtra(Intent intent) {
         if (intent == null) {
-            throw new TinkerRuntimeException("getPatchUpgradeExtra, but intent is null");
+            throw new TinkerRuntimeException("getPatchResultExtra, but intent is null");
         }
-        return ShareIntentUtil.getBooleanExtra(intent, PATCH_NEW_EXTRA, false);
+        return ShareIntentUtil.getStringExtra(intent, RESULT_CLASS_EXTRA);
     }
 
     /**
@@ -105,8 +111,6 @@ protected void onHandleIntent(Intent intent) {
         }
         File patchFile = new File(path);
 
-        boolean isUpgradePatch = getPatchUpgradeExtra(intent);
-
         long begin = SystemClock.elapsedRealtime();
         boolean result;
         long cost;
@@ -115,52 +119,46 @@ protected void onHandleIntent(Intent intent) {
         increasingPriority();
         PatchResult patchResult = new PatchResult();
         try {
-            if (isUpgradePatch) {
-                if (upgradePatchProcessor == null) {
-                    throw new TinkerRuntimeException("upgradePatchProcessor is null.");
-                }
-                result = upgradePatchProcessor.tryPatch(context, path, patchResult);
-
-            } else {
-                //just recover from exist patch
-                if (repairPatchProcessor == null) {
-                    throw new TinkerRuntimeException("upgradePatchProcessor is null.");
-                }
-                result = repairPatchProcessor.tryPatch(context, path, patchResult);
+            if (upgradePatchProcessor == null) {
+                throw new TinkerRuntimeException("upgradePatchProcessor is null.");
             }
+            result = upgradePatchProcessor.tryPatch(context, path, patchResult);
         } catch (Throwable throwable) {
             e = throwable;
             result = false;
-            tinker.getPatchReporter().onPatchException(patchFile, e, isUpgradePatch);
+            tinker.getPatchReporter().onPatchException(patchFile, e);
         }
 
         cost = SystemClock.elapsedRealtime() - begin;
         tinker.getPatchReporter().
-            onPatchResult(patchFile, result, cost, isUpgradePatch);
+            onPatchResult(patchFile, result, cost);
 
         patchResult.isSuccess = result;
-        patchResult.isUpgradePatch = isUpgradePatch;
         patchResult.rawPatchFilePath = path;
         patchResult.costTime = cost;
         patchResult.e = e;
 
-        AbstractResultService.runResultService(context, patchResult);
+        AbstractResultService.runResultService(context, patchResult, getPatchResultExtra(intent));
 
     }
 
     private void increasingPriority() {
-        if (Build.VERSION.SDK_INT > 24) {
-            TinkerLog.i(TAG, "for Android 7.1, we just ignore increasingPriority job");
-            return;
-        }
+//        if (Build.VERSION.SDK_INT > 24) {
+//            TinkerLog.i(TAG, "for Android 7.1, we just ignore increasingPriority job");
+//            return;
+//        }
         TinkerLog.i(TAG, "try to increase patch process priority");
-        Notification notification = new Notification();
-        if (Build.VERSION.SDK_INT < 18) {
-            startForeground(notificationId, notification);
-        } else {
-            startForeground(notificationId, notification);
-            // start InnerService
-            startService(new Intent(this, InnerService.class));
+        try {
+            Notification notification = new Notification();
+            if (Build.VERSION.SDK_INT < 18) {
+                startForeground(notificationId, notification);
+            } else {
+                startForeground(notificationId, notification);
+                // start InnerService
+                startService(new Intent(this, InnerService.class));
+            }
+        } catch (Throwable e) {
+            TinkerLog.i(TAG, "try to increase patch process priority error:" + e);
         }
     }
 
@@ -174,7 +172,7 @@ public void onCreate() {
             super.onCreate();
             try {
                 startForeground(notificationId, new Notification());
-            } catch (NullPointerException e) {
+            } catch (Throwable e) {
                 TinkerLog.e(TAG, "InnerService set service for push exception:%s.", e);
             }
             // kill
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/Tinker.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/Tinker.java
index 8e46e2e7..e14a7a9e 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/Tinker.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/Tinker.java
@@ -22,7 +22,6 @@
 import com.tencent.tinker.lib.listener.DefaultPatchListener;
 import com.tencent.tinker.lib.listener.PatchListener;
 import com.tencent.tinker.lib.patch.AbstractPatch;
-import com.tencent.tinker.lib.patch.RepairPatch;
 import com.tencent.tinker.lib.patch.UpgradePatch;
 import com.tencent.tinker.lib.reporter.DefaultLoadReporter;
 import com.tencent.tinker.lib.reporter.DefaultPatchReporter;
@@ -58,6 +57,7 @@
     final LoadReporter  loadReporter;
     final PatchReporter patchReporter;
     final File          patchInfoFile;
+    final File          patchInfoLockFile;
     final boolean       isMainProcess;
     final boolean       isPatchProcess;
     /**
@@ -76,7 +76,7 @@
     private boolean loaded = false;
 
     private Tinker(Context context, int tinkerFlags, LoadReporter loadReporter, PatchReporter patchReporter,
-                   PatchListener listener, File patchDirectory, File patchInfoFile,
+                   PatchListener listener, File patchDirectory, File patchInfoFile, File patchInfoLockFile,
                    boolean isInMainProc, boolean isPatchProcess, boolean tinkerLoadVerifyFlag) {
         this.context = context;
         this.listener = listener;
@@ -85,6 +85,7 @@ private Tinker(Context context, int tinkerFlags, LoadReporter loadReporter, Patc
         this.tinkerFlags = tinkerFlags;
         this.patchDirectory = patchDirectory;
         this.patchInfoFile = patchInfoFile;
+        this.patchInfoLockFile = patchInfoLockFile;
         this.isMainProcess = isInMainProc;
         this.tinkerLoadVerifyFlag = tinkerLoadVerifyFlag;
         this.isPatchProcess = isPatchProcess;
@@ -124,20 +125,21 @@ public static void create(Tinker tinker) {
         sInstance = tinker;
     }
 
+    public static boolean isTinkerInstalled() {
+        return sInstalled;
+    }
+
     /**
      * you must install tinker first!!
      *
      * @param intentResult
      * @param serviceClass
      * @param upgradePatch
-     * @param repairPatch
      */
     public void install(Intent intentResult, Class<? extends AbstractResultService> serviceClass,
-                        AbstractPatch upgradePatch, AbstractPatch repairPatch
-    ) {
+                        AbstractPatch upgradePatch) {
         sInstalled = true;
-        AbstractResultService.setResultServiceClass(serviceClass);
-        TinkerPatchService.setPatchProcessor(upgradePatch, repairPatch);
+        TinkerPatchService.setPatchProcessor(upgradePatch, serviceClass);
 
         if (!isTinkerEnabled()) {
             TinkerLog.e(TAG, "tinker is disabled");
@@ -165,7 +167,6 @@ public void setPatchServiceNotificationId(int id) {
         TinkerPatchService.setTinkerNotificationId(id);
     }
 
-
     /**
      * Nullable, should check the loaded flag first
      */
@@ -174,7 +175,7 @@ public TinkerLoadResult getTinkerLoadResultIfPresent() {
     }
 
     public void install(Intent intentResult) {
-        install(intentResult, DefaultTinkerResultService.class, new UpgradePatch(), new RepairPatch());
+        install(intentResult, DefaultTinkerResultService.class, new UpgradePatch());
     }
 
     public Context getContext() {
@@ -201,7 +202,6 @@ public PatchReporter getPatchReporter() {
         return patchReporter;
     }
 
-
     public boolean isTinkerEnabled() {
         return ShareTinkerInternals.isTinkerEnabled(tinkerFlags);
     }
@@ -214,10 +214,6 @@ public void setTinkerLoaded(boolean isLoaded) {
         loaded = isLoaded;
     }
 
-    public boolean isTinkerInstalled() {
-        return sInstalled;
-    }
-
     public boolean isTinkerLoadVerify() {
         return tinkerLoadVerifyFlag;
     }
@@ -242,6 +238,10 @@ public File getPatchInfoFile() {
         return patchInfoFile;
     }
 
+    public File getPatchInfoLockFile() {
+        return patchInfoLockFile;
+    }
+
     public PatchListener getPatchListener() {
         return listener;
     }
@@ -315,6 +315,7 @@ public void cleanPatchByVersion(File patchFile) {
         private PatchListener listener;
         private File          patchDirectory;
         private File          patchInfoFile;
+        private File          patchInfoLockFile;
         private Boolean       tinkerLoadVerifyFlag;
 
         /**
@@ -333,6 +334,7 @@ public Builder(Context context) {
                 return;
             }
             this.patchInfoFile = SharePatchFileUtil.getPatchInfoFile(patchDirectory.getAbsolutePath());
+            this.patchInfoLockFile = SharePatchFileUtil.getPatchInfoLockFile(patchDirectory.getAbsolutePath());
             TinkerLog.w(TAG, "tinker patch directory: %s", patchDirectory);
         }
 
@@ -410,7 +412,7 @@ public Tinker build() {
             }
 
             return new Tinker(context, status, loadReporter, patchReporter, listener, patchDirectory,
-                patchInfoFile, mainProcess, patchProcess, tinkerLoadVerifyFlag);
+                patchInfoFile, patchInfoLockFile, mainProcess, patchProcess, tinkerLoadVerifyFlag);
         }
     }
 
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerInstaller.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerInstaller.java
index 1fa7eb21..7ea178e6 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerInstaller.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerInstaller.java
@@ -43,10 +43,11 @@
      *
      * @param applicationLike
      */
-    public static void install(ApplicationLike applicationLike) {
+    public static Tinker install(ApplicationLike applicationLike) {
         Tinker tinker = new Tinker.Builder(applicationLike.getApplication()).build();
         Tinker.create(tinker);
         tinker.install(applicationLike.getTinkerResultIntent());
+        return tinker;
     }
 
     /**
@@ -59,11 +60,10 @@ public static void install(ApplicationLike applicationLike) {
      * @param listener
      * @param resultServiceClass
      * @param upgradePatchProcessor
-     * @param repairPatchProcessor
      */
-    public static void install(ApplicationLike applicationLike, LoadReporter loadReporter, PatchReporter patchReporter,
+    public static Tinker install(ApplicationLike applicationLike, LoadReporter loadReporter, PatchReporter patchReporter,
                                PatchListener listener, Class<? extends AbstractResultService> resultServiceClass,
-                               AbstractPatch upgradePatchProcessor, AbstractPatch repairPatchProcessor) {
+                               AbstractPatch upgradePatchProcessor) {
 
         Tinker tinker = new Tinker.Builder(applicationLike.getApplication())
             .tinkerFlags(applicationLike.getTinkerFlags())
@@ -73,9 +73,8 @@ public static void install(ApplicationLike applicationLike, LoadReporter loadRep
             .tinkerLoadVerifyFlag(applicationLike.getTinkerLoadVerifyFlag()).build();
 
         Tinker.create(tinker);
-        tinker.install(applicationLike.getTinkerResultIntent(), resultServiceClass, upgradePatchProcessor, repairPatchProcessor);
-
-
+        tinker.install(applicationLike.getTinkerResultIntent(), resultServiceClass, upgradePatchProcessor);
+        return tinker;
     }
 
     /**
@@ -94,18 +93,7 @@ public static void cleanPatch(Context context) {
      * @param patchLocation
      */
     public static void onReceiveUpgradePatch(Context context, String patchLocation) {
-        Tinker.with(context).getPatchListener().onPatchReceived(patchLocation, true);
-    }
-
-    /**
-     * some file does not exist, repair them with :patch process
-     * Generally you will not use it
-     *
-     * @param context
-     * @param patchLocation
-     */
-    public static void onReceiveRepairPatch(Context context, String patchLocation) {
-        Tinker.with(context).getPatchListener().onPatchReceived(patchLocation, false);
+        Tinker.with(context).getPatchListener().onPatchReceived(patchLocation);
     }
 
     /**
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerLoadResult.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerLoadResult.java
index 46316274..ddeb1791 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerLoadResult.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerLoadResult.java
@@ -18,6 +18,7 @@
 
 import android.content.Context;
 import android.content.Intent;
+import android.os.Build;
 
 import com.tencent.tinker.lib.util.TinkerLog;
 import com.tencent.tinker.loader.TinkerRuntimeException;
@@ -100,7 +101,7 @@ public boolean parseTinkerResult(Context context, Intent intentResult) {
                 resourceDirectory = new File(patchVersionDirectory, ShareConstants.RES_PATH);
                 resourceFile = new File(resourceDirectory, ShareConstants.RES_NAME);
             }
-            patchInfo = new SharePatchInfo(oldVersion, newVersion);
+            patchInfo = new SharePatchInfo(oldVersion, newVersion, Build.FINGERPRINT);
             versionChanged = !(oldVersion.equals(newVersion));
         }
 
@@ -116,6 +117,9 @@ public boolean parseTinkerResult(Context context, Intent intentResult) {
                 case ShareConstants.ERROR_LOAD_PATCH_VERSION_DEX_LOAD_EXCEPTION:
                     errorCode = ShareConstants.ERROR_LOAD_EXCEPTION_DEX;
                     break;
+                case ShareConstants.ERROR_LOAD_PATCH_VERSION_PARALLEL_DEX_OPT_EXCEPTION:
+                    errorCode = ShareConstants.ERROR_LOAD_EXCEPTION_DEX_OPT;
+                    break;
                 case ShareConstants.ERROR_LOAD_PATCH_VERSION_RESOURCE_LOAD_EXCEPTION:
                     errorCode = ShareConstants.ERROR_LOAD_EXCEPTION_RESOURCE;
                     break;
@@ -319,33 +323,6 @@ public boolean parseTinkerResult(Context context, Intent intentResult) {
 
     }
 
-    /**
-     * get the base tinkerId
-     *
-     * @return
-     */
-    public String getTinkerID() {
-        if (packageConfig != null) {
-            String tinkerId = packageConfig.get(ShareConstants.TINKER_ID);
-            return tinkerId;
-        }
-        return null;
-    }
-
-    /**
-     * get the new tinkerId
-     *
-     * @return
-     */
-    public String getNewTinkerID() {
-        if (packageConfig != null) {
-            String tinkerId = packageConfig.get(ShareConstants.NEW_TINKER_ID);
-
-            return tinkerId;
-        }
-        return null;
-    }
-
     /**
      * get package configs
      *
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/TinkerServiceInternals.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/TinkerServiceInternals.java
index 2118e23b..6a5c644b 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/TinkerServiceInternals.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/TinkerServiceInternals.java
@@ -64,7 +64,7 @@ public static boolean isTinkerPatchServiceRunning(Context context) {
             return false;
         }
         try {
-            // ActivityManagergetRunningAppProcesses()
+            // ActivityManager getRunningAppProcesses()
             List<ActivityManager.RunningAppProcessInfo> appProcessList = am
                 .getRunningAppProcesses();
 
@@ -122,7 +122,7 @@ private static String getServiceProcessName(Context context, Class<? extends Ser
         ServiceInfo serviceInfo;
         try {
             serviceInfo = packageManager.getServiceInfo(component, 0);
-        } catch (PackageManager.NameNotFoundException ignored) {
+        } catch (Throwable ignored) {
             // Service is disabled.
             return null;
         }
diff --git a/tinker-android/tinker-android-loader/build.gradle b/tinker-android/tinker-android-loader/build.gradle
index cb3264ad..b65288cc 100644
--- a/tinker-android/tinker-android-loader/build.gradle
+++ b/tinker-android/tinker-android-loader/build.gradle
@@ -19,7 +19,8 @@ dependencies {
     testCompile 'junit:junit:4.12'
 }
 
-task buildSdk(type: Copy, dependsOn: [build]) {
+task buildTinkerSdk(type: Copy, dependsOn: [build]) {
+    group = "tinker"
     from("$buildDir/outputs/aar/") {
         include "${project.getName()}-release.aar"
     }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/SystemClassLoaderAdder.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/SystemClassLoaderAdder.java
index 6678afa3..3f0f057e 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/SystemClassLoaderAdder.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/SystemClassLoaderAdder.java
@@ -72,6 +72,7 @@ public static void installDexes(Application application, PathClassLoader loader,
             }
             //install done
             sPatchDexCount = files.size();
+            Log.i(TAG, "after loaded classloader: " + classLoader + ", dex size:" + sPatchDexCount);
 
             if (!checkDexInstall(classLoader)) {
                 //reset patch dex
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerDexLoader.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerDexLoader.java
index 2d8ed266..b5e77fbf 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerDexLoader.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerDexLoader.java
@@ -29,12 +29,12 @@
 import com.tencent.tinker.loader.shareutil.ShareSecurityCheck;
 import com.tencent.tinker.loader.shareutil.ShareTinkerInternals;
 
-import dalvik.system.PathClassLoader;
-
 import java.io.File;
 import java.util.ArrayList;
 import java.util.HashMap;
 
+import dalvik.system.PathClassLoader;
+
 /**
  * Created by zhangshaowen on 16/3/8.
  * check the complete of the dex files
@@ -49,6 +49,9 @@
     private static final String                           DEX_OPTIMIZE_PATH = ShareConstants.DEX_OPTIMIZE_PATH;
     private static final ArrayList<ShareDexDiffPatchInfo> dexList           = new ArrayList<>();
 
+    private static boolean   parallelOTAResult;
+    private static Throwable parallelOTAThrowable;
+
     private TinkerDexLoader() {
     }
 
@@ -59,7 +62,7 @@ private TinkerDexLoader() {
      * @param application The application.
      */
     @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
-    public static boolean loadTinkerJars(Application application, boolean tinkerLoadVerifyFlag, String directory, Intent intentResult) {
+    public static boolean loadTinkerJars(Application application, boolean tinkerLoadVerifyFlag, String directory, Intent intentResult, boolean isSystemOTA) {
         if (dexList.isEmpty()) {
             Log.w(TAG, "there is no dex to load");
             return true;
@@ -103,6 +106,43 @@ public static boolean loadTinkerJars(Application application, boolean tinkerLoad
             }
             legalFiles.add(file);
         }
+
+        if (isSystemOTA) {
+            parallelOTAResult = true;
+            parallelOTAThrowable = null;
+            Log.w(TAG, "systemOTA, try parallel oat dexes!!!!!");
+
+            TinkerParallelDexOptimizer.optimizeAll(
+                legalFiles, optimizeDir,
+                new TinkerParallelDexOptimizer.ResultCallback() {
+                    long start;
+
+                    @Override
+                    public void onStart(File dexFile, File optimizedDir) {
+                        start = System.currentTimeMillis();
+                        Log.i(TAG, "start to optimize dex:" + dexFile.getPath());
+                    }
+
+                    @Override
+                    public void onSuccess(File dexFile, File optimizedDir) {
+                        // Do nothing.
+                        Log.i(TAG, "success to optimize dex " + dexFile.getPath() + "use time " + (System.currentTimeMillis() - start));
+                    }
+                    @Override
+                    public void onFailed(File dexFile, File optimizedDir, Throwable thr) {
+                        parallelOTAResult = false;
+                        parallelOTAThrowable = thr;
+                        Log.i(TAG, "fail to optimize dex " + dexFile.getPath() + "use time " + (System.currentTimeMillis() - start));
+                    }
+                }
+            );
+            if (!parallelOTAResult) {
+                Log.e(TAG, "parallel oat dexes failed");
+                intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_EXCEPTION, parallelOTAThrowable);
+                ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_PARALLEL_DEX_OPT_EXCEPTION);
+                return false;
+            }
+        }
         try {
             SystemClassLoaderAdder.installDexes(application, classLoader, optimizeDir, legalFiles);
         } catch (Throwable e) {
@@ -112,7 +152,6 @@ public static boolean loadTinkerJars(Application application, boolean tinkerLoad
             ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_DEX_LOAD_EXCEPTION);
             return false;
         }
-        Log.i(TAG, "after loaded classloader: " + application.getClassLoader().toString());
 
         return true;
     }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerLoader.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerLoader.java
index adfb88f7..0869e0b5 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerLoader.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerLoader.java
@@ -128,7 +128,12 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, bo
 
         //patch-641e634c
         String patchName = SharePatchFileUtil.getPatchVersionDirectory(version);
-
+        if (patchName == null) {
+            Log.w(TAG, "tryLoadPatchFiles:patchName is null");
+            //we may delete patch info file
+            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_VERSION_DIRECTORY_NOT_EXIST);
+            return;
+        }
         //tinker/patch.info/patch-641e634c
         String patchVersionDirectory = patchDirectoryPath + "/" + patchName;
         File patchVersionDirectoryFile = new File(patchVersionDirectory);
@@ -197,8 +202,12 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, bo
                 return;
             }
         }
+        //only work for art platform oat
+        boolean isSystemOTA = ShareTinkerInternals.isVmArt() && ShareTinkerInternals.isSystemOTA(patchInfo.fingerPrint);
+
         //we should first try rewrite patch info file, if there is a error, we can't load jar
-        if (mainProcess && versionChanged) {
+        if (isSystemOTA
+            || (mainProcess && versionChanged)) {
             patchInfo.oldVersion = version;
             //update old version to new
             if (!SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile, patchInfo, patchInfoLockFile)) {
@@ -215,7 +224,7 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, bo
         }
         //now we can load patch jar
         if (isEnabledForDex) {
-            boolean loadTinkerJars = TinkerDexLoader.loadTinkerJars(app, tinkerLoadVerifyFlag, patchVersionDirectory, resultIntent);
+            boolean loadTinkerJars = TinkerDexLoader.loadTinkerJars(app, tinkerLoadVerifyFlag, patchVersionDirectory, resultIntent, isSystemOTA);
             if (!loadTinkerJars) {
                 Log.w(TAG, "tryLoadPatchFiles:onPatchLoadDexesFail");
                 return;
@@ -241,16 +250,14 @@ private boolean checkSafeModeCount(TinkerApplication application) {
         String preferName = ShareConstants.TINKER_OWN_PREFERENCE_CONFIG + processName;
         //each process have its own SharedPreferences file
         SharedPreferences sp = application.getSharedPreferences(preferName, Context.MODE_PRIVATE);
-        int count = sp.getInt(ShareConstants.TINKER_SAFE_MODE_COUNT, 0);
+        int count = sp.getInt(ShareConstants.TINKER_SAFE_MODE_COUNT, 0) + 1;
         Log.w(TAG, "tinker safe mode preferName:" + preferName + " count:" + count);
         if (count >= ShareConstants.TINKER_SAFE_MODE_MAX_COUNT) {
             sp.edit().putInt(ShareConstants.TINKER_SAFE_MODE_COUNT, 0).commit();
             return false;
         }
         application.setUseSafeMode(true);
-        count++;
         sp.edit().putInt(ShareConstants.TINKER_SAFE_MODE_COUNT, count).commit();
-        Log.w(TAG, "after tinker safe mode count:" + count);
         return true;
     }
 
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerParallelDexOptimizer.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerParallelDexOptimizer.java
new file mode 100644
index 00000000..8c89a292
--- /dev/null
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerParallelDexOptimizer.java
@@ -0,0 +1,145 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.loader;
+
+import android.util.Log;
+
+import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
+
+import dalvik.system.DexFile;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.atomic.AtomicInteger;
+
+/**
+ * Created by tangyinsheng on 2016/11/15.
+ */
+
+public final class TinkerParallelDexOptimizer {
+    private static final String TAG = "ParallelDexOptimizer";
+
+    /**
+     * Optimize (trigger dexopt or dex2oat) dexes.
+     *
+     * @param dexFiles
+     * @param optimizedDir
+     * @param cb
+     *
+     * @return
+     *  If all dexes are optimized successfully, return true. Otherwise return false.
+     */
+    public synchronized static boolean optimizeAll(File[] dexFiles, File optimizedDir, ResultCallback cb) {
+        final AtomicInteger successCount = new AtomicInteger(0);
+        return optimizeAllLocked(Arrays.asList(dexFiles), optimizedDir, successCount, cb);
+    }
+
+    /**
+     * Optimize (trigger dexopt or dex2oat) dexes.
+     *
+     * @param dexFiles
+     * @param optimizedDir
+     * @param cb
+     *
+     * @return
+     *  If all dexes are optimized successfully, return true. Otherwise return false.
+     */
+    public synchronized static boolean optimizeAll(Collection<File> dexFiles, File optimizedDir, ResultCallback cb) {
+        final AtomicInteger successCount = new AtomicInteger(0);
+        return optimizeAllLocked(dexFiles, optimizedDir, successCount, cb);
+    }
+
+    private static boolean optimizeAllLocked(Collection<File> dexFiles, File optimizedDir, AtomicInteger successCount, ResultCallback cb) {
+        final CountDownLatch lauch = new CountDownLatch(dexFiles.size());
+        final ExecutorService threadPool = Executors.newCachedThreadPool();
+        long startTick = System.nanoTime();
+        for (File dexFile : dexFiles) {
+            OptimizeWorker worker = new OptimizeWorker(dexFile, optimizedDir, successCount, lauch, cb);
+            threadPool.submit(worker);
+        }
+        try {
+            lauch.await();
+            long timeCost = (System.nanoTime() - startTick) / 1000000;
+            if (successCount.get() == dexFiles.size()) {
+                Log.i(TAG, "All dexes are optimized successfully, cost: " + timeCost + " ms.");
+                return true;
+            } else {
+                Log.e(TAG, "Dexes optimizing failed, some dexes are not optimized.");
+                return false;
+            }
+        } catch (InterruptedException e) {
+            Log.w(TAG, "Dex optimizing was interrupted.", e);
+            return false;
+        } finally {
+            threadPool.shutdown();
+        }
+    }
+
+    public interface ResultCallback {
+        void onStart(File dexFile, File optimizedDir);
+        void onSuccess(File dexFile, File optimizedDir);
+        void onFailed(File dexFile, File optimizedDir, Throwable thr);
+    }
+
+    private static class OptimizeWorker implements Runnable {
+        private final File dexFile;
+        private final File optimizedDir;
+        private final AtomicInteger successCount;
+        private final CountDownLatch waitingLauch;
+        private final ResultCallback callback;
+
+        OptimizeWorker(File dexFile, File optimizedDir, AtomicInteger successCount, CountDownLatch lauch, ResultCallback cb) {
+            this.dexFile = dexFile;
+            this.optimizedDir = optimizedDir;
+            this.successCount = successCount;
+            this.waitingLauch = lauch;
+            this.callback = cb;
+        }
+
+        @Override
+        public void run() {
+            try {
+                if (dexFile == null || !dexFile.exists()) {
+                    if (callback != null) {
+                        callback.onFailed(dexFile, optimizedDir,
+                            new IOException("dex file " + dexFile.getAbsolutePath() + " is not exist!"));
+                    }
+                }
+                if (callback != null) {
+                    callback.onStart(dexFile, optimizedDir);
+                }
+                DexFile.loadDex(dexFile.getAbsolutePath(), SharePatchFileUtil.optimizedPathFor(this.dexFile, this.optimizedDir), 0);
+                successCount.incrementAndGet();
+                if (callback != null) {
+                    callback.onSuccess(dexFile, optimizedDir);
+                }
+            } catch (final Exception e) {
+                Log.e(TAG, "Failed to optimize dex: " + dexFile.getAbsolutePath(), e);
+                if (callback != null) {
+                    callback.onFailed(dexFile, optimizedDir, e);
+                }
+            } finally {
+                this.waitingLauch.countDown();
+            }
+        }
+    }
+}
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java
index 96925995..56f1c0f8 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java
@@ -23,6 +23,7 @@
 import android.util.Log;
 
 import com.tencent.tinker.loader.shareutil.ShareConstants;
+import com.tencent.tinker.loader.shareutil.ShareReflectUtil;
 
 import java.lang.ref.WeakReference;
 import java.lang.reflect.Field;
@@ -35,17 +36,19 @@
 import static android.os.Build.VERSION_CODES.KITKAT;
 
 class TinkerResourcePatcher {
-    private static final String TAG = "Tinker.ResourcePatcher";
-    private static final String TEST_STRING_NAME  = "tinker_test_resource";
-    private static final String TEST_STRING_VALUE = "only use for test tinker resource: b";
+    private static final String TAG               = "Tinker.ResourcePatcher";
+    private static final String TEST_ASSETS_VALUE = "only_use_to_test_tinker_resource.txt";
+
     // original value
     private static Collection<WeakReference<Resources>> references;
     private static AssetManager newAssetManager          = null;
     private static Method       addAssetPathMethod       = null;
     private static Method       ensureStringBlocksMethod = null;
     private static Field        assetsFiled              = null;
-    private static Field        resourcesImplFiled      = null;
-    private static Field        resDir      = null;
+    private static Field        resourcesImplFiled       = null;
+    private static Field        resDir                   = null;
+    private static Field        packagesFiled            = null;
+    private static Field        resourcePackagesFiled    = null;
 
     public static void isResourceCanPatch(Context context) throws Throwable {
         //   - Replace mResDir to point to the external resource file instead of the .apk. This is
@@ -54,7 +57,6 @@ public static void isResourceCanPatch(Context context) throws Throwable {
 
         // Find the ActivityThread instance for the current thread
         Class<?> activityThread = Class.forName("android.app.ActivityThread");
-        Object currentActivityThread = getActivityThread(context, activityThread);
         // API version 8 has PackageInfo, 10 has LoadedApk. 9, I don't know.
         Class<?> loadedApkClass;
         try {
@@ -66,7 +68,11 @@ public static void isResourceCanPatch(Context context) throws Throwable {
         mApplication.setAccessible(true);
         resDir = loadedApkClass.getDeclaredField("mResDir");
         resDir.setAccessible(true);
+        packagesFiled = activityThread.getDeclaredField("mPackages");
+        packagesFiled.setAccessible(true);
 
+        resourcePackagesFiled = activityThread.getDeclaredField("mResourcePackages");
+        resourcePackagesFiled.setAccessible(true);
         /*
         (Note: the resource directory is *also* inserted into the loadedApk in
         monkeyPatchApplication)
@@ -100,7 +106,15 @@ public static void isResourceCanPatch(Context context) throws Throwable {
         */
         // Create a new AssetManager instance and point it to the resources installed under
         // /sdcard
-        newAssetManager = AssetManager.class.getConstructor().newInstance();
+        AssetManager assets = context.getAssets();
+        // Baidu os
+        if (assets.getClass().getName().equals("android.content.res.BaiduAssetManager")) {
+            Class baiduAssetManager = Class.forName("android.content.res.BaiduAssetManager");
+            newAssetManager = (AssetManager) baiduAssetManager.getConstructor().newInstance();
+        } else {
+            newAssetManager = AssetManager.class.getConstructor().newInstance();
+        }
+
         addAssetPathMethod = AssetManager.class.getDeclaredMethod("addAssetPath", String.class);
         addAssetPathMethod.setAccessible(true);
 
@@ -133,9 +147,10 @@ public static void isResourceCanPatch(Context context) throws Throwable {
         } else {
             Field fMActiveResources = activityThread.getDeclaredField("mActiveResources");
             fMActiveResources.setAccessible(true);
+            Object thread = getActivityThread(context, activityThread);
             @SuppressWarnings("unchecked")
             HashMap<?, WeakReference<Resources>> map =
-                (HashMap<?, WeakReference<Resources>>) fMActiveResources.get(currentActivityThread);
+                (HashMap<?, WeakReference<Resources>>) fMActiveResources.get(thread);
             references = map.values();
         }
         // check resource
@@ -160,9 +175,7 @@ public static void monkeyPatchExistingResources(Context context, String external
         Class<?> activityThread = Class.forName("android.app.ActivityThread");
         Object currentActivityThread = getActivityThread(context, activityThread);
 
-        for (String fieldName : new String[]{"mPackages", "mResourcePackages"}) {
-            Field field = activityThread.getDeclaredField(fieldName);
-            field.setAccessible(true);
+        for (Field field : new Field[]{packagesFiled, resourcePackagesFiled}) {
             Object value = field.get(currentActivityThread);
 
             for (Map.Entry<String, WeakReference<?>> entry
@@ -172,14 +185,12 @@ public static void monkeyPatchExistingResources(Context context, String external
                     continue;
                 }
                 if (externalResourceFile != null) {
-                   resDir.set(loadedApk, externalResourceFile);
+                    resDir.set(loadedApk, externalResourceFile);
                 }
-
             }
         }
         // Create a new AssetManager instance and point it to the resources installed under
         // /sdcard
-
         if (((Integer) addAssetPathMethod.invoke(newAssetManager, externalResourceFile)) == 0) {
             throw new IllegalStateException("Could not create new AssetManager");
         }
@@ -196,9 +207,10 @@ public static void monkeyPatchExistingResources(Context context, String external
                 try {
                     assetsFiled.set(resources, newAssetManager);
                 } catch (Throwable ignore) {
-                    //N
+                    // N
                     Object resourceImpl = resourcesImplFiled.get(resources);
-                    Field implAssets = resourceImpl.getClass().getDeclaredField("mAssets");
+                    // for Huawei HwResourcesImpl
+                    Field implAssets = ShareReflectUtil.findField(resourceImpl, "mAssets");
                     implAssets.setAccessible(true);
                     implAssets.set(resourceImpl, newAssetManager);
                 }
@@ -213,19 +225,16 @@ public static void monkeyPatchExistingResources(Context context, String external
     }
 
     private static boolean checkResUpdate(Context context) {
-        int testStringID = context.getResources().getIdentifier(TEST_STRING_NAME, "string", context.getPackageName());
-        if (testStringID > 0) {
-            String value = context.getString(testStringID);
-            Log.w(TAG, "checkResUpdate resource value:" + value);
-
-            if (!value.equals(TEST_STRING_VALUE)) {
-                return false;
-            }
-        } else  {
-            Log.e(TAG, "checkResUpdate resource id < 0 " + testStringID);
+        try {
+            Log.e(TAG, "checkResUpdate success, found test resource assets file " + TEST_ASSETS_VALUE);
+            context.getAssets().open(TEST_ASSETS_VALUE);
+        } catch (Throwable e) {
+            Log.e(TAG, "checkResUpdate failed, can't find test resource assets file " + TEST_ASSETS_VALUE + " e:" + e.getMessage());
+            return false;
         }
         return true;
     }
+
     private static Object getActivityThread(Context context,
                                             Class<?> activityThread) {
         try {
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerUncaughtHandler.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerUncaughtHandler.java
new file mode 100644
index 00000000..20853da6
--- /dev/null
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerUncaughtHandler.java
@@ -0,0 +1,69 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.loader;
+
+import android.content.Context;
+import android.util.Log;
+
+import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
+import com.tencent.tinker.loader.shareutil.ShareTinkerInternals;
+
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.io.PrintWriter;
+
+/**
+ * Created by zhangshaowen on 16/12/1.
+ */
+
+public class TinkerUncaughtHandler implements Thread.UncaughtExceptionHandler {
+    private static final String TAG = "Tinker.UncaughtHandler";
+
+
+    private final File crashFile;
+    private final Context context;
+
+    public TinkerUncaughtHandler(Context context) {
+        this.context = context;
+        crashFile = SharePatchFileUtil.getPatchLastCrashFile(context);
+    }
+
+    @Override
+    public void uncaughtException(Thread thread, Throwable ex) {
+        Log.e(TAG, "catch exception when loading tinker:" + ex);
+        if (crashFile != null) {
+            Thread.UncaughtExceptionHandler handler = Thread.getDefaultUncaughtExceptionHandler();
+
+            //only catch real uncaught Exception
+            if (handler instanceof TinkerUncaughtHandler) {
+                PrintWriter pw = null;
+                try {
+                    pw = new PrintWriter(new FileWriter(crashFile, false));
+                    pw.println("process:" + ShareTinkerInternals.getProcessName(this.context));
+                    pw.println(ShareTinkerInternals.getExceptionCauseString(ex));
+                } catch (IOException e) {
+                    //ignore
+                    Log.e(TAG, "print crash file error:" + ex);
+                } finally {
+                    SharePatchFileUtil.closeQuietly(pw);
+                }
+            }
+        }
+        android.os.Process.killProcess(android.os.Process.myPid());
+    }
+}
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/TinkerApplication.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/TinkerApplication.java
index eb908b86..5b14d7d2 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/TinkerApplication.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/TinkerApplication.java
@@ -28,6 +28,7 @@
 
 import com.tencent.tinker.loader.TinkerLoader;
 import com.tencent.tinker.loader.TinkerRuntimeException;
+import com.tencent.tinker.loader.TinkerUncaughtHandler;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
 import com.tencent.tinker.loader.shareutil.ShareIntentUtil;
 import com.tencent.tinker.loader.shareutil.ShareReflectUtil;
@@ -151,6 +152,7 @@ private void onBaseContextAttached(Context base) {
     @Override
     protected final void attachBaseContext(Context base) {
         super.attachBaseContext(base);
+        Thread.setDefaultUncaughtExceptionHandler(new TinkerUncaughtHandler(this));
         onBaseContextAttached(base);
     }
 
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareConstants.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareConstants.java
index e3db652f..63a8b20b 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareConstants.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareConstants.java
@@ -39,17 +39,17 @@
     public static final String SO_META_FILE = "assets/so_meta.txt";
     public static final String SO_PATH      = "lib";
 
-    // If you changed this value, please change the same value in TypedValue, too.
-    public static final String DEX_SMALLPATCH_INFO_FILE = "smallpatch_info.ddextra";
 
-    public static final String DEX_META_FILE            = "assets/dex_meta.txt";
-    public static final String DEX_PATH                 = "dex";
-    public static final String DEX_OPTIMIZE_PATH        = "odex";
-    public static final String DEX_SUFFIX               = ".dex";
-    public static final String JAR_SUFFIX               = ".jar";
+    public static final String DEX_META_FILE     = "assets/dex_meta.txt";
+    public static final String DEX_PATH          = "dex";
+    public static final String DEX_OPTIMIZE_PATH = "odex";
+    public static final String DEX_SUFFIX        = ".dex";
+    public static final String JAR_SUFFIX        = ".jar";
 
     public static final String CHECK_DEX_INSTALL_FAIL = "checkDexInstall failed";
     public static final String CHECK_RES_INSTALL_FAIL = "checkResInstall failed";
+//    public static final String CHECK_VM_PROPERTY_FAIL = "checkVmArtProperty failed";
+
 
     public static final String RES_META_FILE       = "assets/res_meta.txt";
     public static final String RES_ARSC            = "resources.arsc";
@@ -67,7 +67,10 @@
     public static final String DEXMODE_JAR = "jar";
     public static final String DEX_IN_JAR  = "classes.dex";
 
-    public static final String PATCH_DIRECTORY_NAME = "tinker";
+    public static final String PATCH_DIRECTORY_NAME       = "tinker";
+    public static final String PATCH_TEMP_DIRECTORY_NAME  = "tinker_temp";
+    public static final String PATCH_TEMP_LAST_CRASH_NAME = "tinker_last_crash";
+
     public static final String PATCH_INFO_NAME      = "patch.info";
     public static final String PATCH_INFO_LOCK_NAME = "info.lock";
 
@@ -95,16 +98,13 @@
     public static final int TINKER_PATCH_SERVICE_NOTIFICATION = -1119860829;
 
     //resource type
-    public static final int TYPE_PATCH_FILE  = 1;
-    public static final int TYPE_PATCH_INFO  = 2;
-    public static final int TYPE_DEX         = 3;
-    /**
-     * for art small dex
-     */
-    public static final int TYPE_DEX_FOR_ART = 4;
-    public static final int TYPE_DEX_OPT     = 5;
-    public static final int TYPE_LIBRARY     = 6;
-    public static final int TYPE_RESOURCE    = 7;
+    public static final int TYPE_PATCH_FILE = 1;
+    public static final int TYPE_PATCH_INFO = 2;
+    public static final int TYPE_DEX        = 3;
+
+    public static final int TYPE_DEX_OPT  = 4;
+    public static final int TYPE_LIBRARY  = 5;
+    public static final int TYPE_RESOURCE = 6;
 
 
     public static final int TINKER_DISABLE             = 0x00;
@@ -115,21 +115,23 @@
     public static final int TINKER_ENABLE_ALL          = TINKER_DEX_MASK | TINKER_NATIVE_LIBRARY_MASK | TINKER_RESOURCE_MASK;
 
     //load error code
-    public static final int ERROR_LOAD_OK                                         = 0;
-    public static final int ERROR_LOAD_DISABLE                                    = -1;
-    public static final int ERROR_LOAD_PATCH_DIRECTORY_NOT_EXIST                  = -2;
-    public static final int ERROR_LOAD_PATCH_INFO_NOT_EXIST                       = -3;
-    public static final int ERROR_LOAD_PATCH_INFO_CORRUPTED                       = -4;
-    public static final int ERROR_LOAD_PATCH_INFO_BLANK                           = -5;
-    public static final int ERROR_LOAD_PATCH_VERSION_DIRECTORY_NOT_EXIST          = -6;
-    public static final int ERROR_LOAD_PATCH_VERSION_FILE_NOT_EXIST               = -7;
-    public static final int ERROR_LOAD_PATCH_PACKAGE_CHECK_FAIL                   = -9;
-    public static final int ERROR_LOAD_PATCH_VERSION_DEX_DIRECTORY_NOT_EXIST      = -10;
-    public static final int ERROR_LOAD_PATCH_VERSION_DEX_FILE_NOT_EXIST           = -11;
-    public static final int ERROR_LOAD_PATCH_VERSION_DEX_OPT_FILE_NOT_EXIST       = -12;
-    public static final int ERROR_LOAD_PATCH_VERSION_DEX_CLASSLOADER_NULL         = -13;
-    public static final int ERROR_LOAD_PATCH_VERSION_DEX_MD5_MISMATCH             = -14;
-    public static final int ERROR_LOAD_PATCH_VERSION_DEX_LOAD_EXCEPTION           = -15;
+    public static final int ERROR_LOAD_OK                                       = 0;
+    public static final int ERROR_LOAD_DISABLE                                  = -1;
+    public static final int ERROR_LOAD_PATCH_DIRECTORY_NOT_EXIST                = -2;
+    public static final int ERROR_LOAD_PATCH_INFO_NOT_EXIST                     = -3;
+    public static final int ERROR_LOAD_PATCH_INFO_CORRUPTED                     = -4;
+    public static final int ERROR_LOAD_PATCH_INFO_BLANK                         = -5;
+    public static final int ERROR_LOAD_PATCH_VERSION_DIRECTORY_NOT_EXIST        = -6;
+    public static final int ERROR_LOAD_PATCH_VERSION_FILE_NOT_EXIST             = -7;
+    public static final int ERROR_LOAD_PATCH_PACKAGE_CHECK_FAIL                 = -8;
+    public static final int ERROR_LOAD_PATCH_VERSION_DEX_DIRECTORY_NOT_EXIST    = -9;
+    public static final int ERROR_LOAD_PATCH_VERSION_DEX_FILE_NOT_EXIST         = -10;
+    public static final int ERROR_LOAD_PATCH_VERSION_DEX_OPT_FILE_NOT_EXIST     = -11;
+    public static final int ERROR_LOAD_PATCH_VERSION_DEX_CLASSLOADER_NULL       = -12;
+    public static final int ERROR_LOAD_PATCH_VERSION_DEX_MD5_MISMATCH           = -13;
+    public static final int ERROR_LOAD_PATCH_VERSION_DEX_LOAD_EXCEPTION         = -14;
+    public static final int ERROR_LOAD_PATCH_VERSION_PARALLEL_DEX_OPT_EXCEPTION = -15;
+
     public static final int ERROR_LOAD_PATCH_VERSION_LIB_DIRECTORY_NOT_EXIST      = -16;
     public static final int ERROR_LOAD_PATCH_VERSION_LIB_FILE_NOT_EXIST           = -17;
     public static final int ERROR_LOAD_PATCH_REWRITE_PATCH_INFO_FAIL              = -18;
@@ -149,6 +151,7 @@
     public static final int ERROR_LOAD_EXCEPTION_DEX      = -2;
     public static final int ERROR_LOAD_EXCEPTION_RESOURCE = -3;
     public static final int ERROR_LOAD_EXCEPTION_UNCAUGHT = -4;
+    public static final int ERROR_LOAD_EXCEPTION_DEX_OPT  = -5;
 
 
     //recover error code
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchFileUtil.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchFileUtil.java
index ddfee922..aeadf9fa 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchFileUtil.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchFileUtil.java
@@ -21,12 +21,14 @@
 import android.util.Log;
 
 import java.io.BufferedInputStream;
+import java.io.BufferedReader;
 import java.io.Closeable;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
+import java.io.InputStreamReader;
 import java.security.MessageDigest;
 import java.util.jar.JarEntry;
 import java.util.jar.JarFile;
@@ -52,6 +54,24 @@ public static File getPatchDirectory(Context context) {
         return new File(applicationInfo.dataDir, ShareConstants.PATCH_DIRECTORY_NAME);
     }
 
+    public static File getPatchTempDirectory(Context context) {
+        ApplicationInfo applicationInfo = context.getApplicationInfo();
+        if (applicationInfo == null) {
+            // Looks like running on a test Context, so just return without patching.
+            return null;
+        }
+
+        return new File(applicationInfo.dataDir, ShareConstants.PATCH_TEMP_DIRECTORY_NAME);
+    }
+
+    public static File getPatchLastCrashFile(Context context) {
+        File tempFile = getPatchTempDirectory(context);
+        if (tempFile == null) {
+            return null;
+        }
+        return new File(tempFile, ShareConstants.PATCH_TEMP_LAST_CRASH_NAME);
+    }
+
     public static File getPatchInfoFile(String patchDirectory) {
         return new File(patchDirectory + "/" + ShareConstants.PATCH_INFO_NAME);
     }
@@ -83,16 +103,33 @@ public static boolean checkIfMd5Valid(final String object) {
         return true;
     }
 
-    public static final boolean fileExists(String filePath) {
-        if (filePath == null) {
-            return false;
+    public static String checkTinkerLastUncaughtCrash(Context context) {
+        File crashFile = SharePatchFileUtil.getPatchLastCrashFile(context);
+        if (!SharePatchFileUtil.isLegalFile(crashFile)) {
+            return null;
         }
-
-        File file = new File(filePath);
-        if (file.exists()) {
-            return true;
+        StringBuffer buffer = new StringBuffer();
+        BufferedReader in = null;
+        try {
+            in = new BufferedReader(new InputStreamReader(new FileInputStream(crashFile)));
+            String line;
+            while ((line = in.readLine()) != null) {
+                buffer.append(line);
+                buffer.append("\n");
+            }
+        } catch (Exception e) {
+            Log.e(TAG, "checkTinkerLastUncaughtCrash exception: " + e);
+            return null;
+        } finally {
+            closeQuietly(in);
         }
-        return false;
+
+        return buffer.toString();
+
+    }
+
+    public static final boolean isLegalFile(File file) {
+        return file != null && file.exists() && file.isFile() && file.length() > 0;
     }
 
     /**
@@ -208,17 +245,25 @@ public static boolean verifyDexFileMd5(File file, String md5) {
             try {
                 dexJar = new ZipFile(file);
                 ZipEntry classesDex = dexJar.getEntry(ShareConstants.DEX_IN_JAR);
-
                 // no code
                 if (null == classesDex) {
+                    Log.e(TAG, "There's no entry named: " + ShareConstants.DEX_IN_JAR + " in " + file.getAbsolutePath());
                     return false;
                 }
                 fileMd5 = getMD5(dexJar.getInputStream(classesDex));
-            } catch (IOException e) {
-//                e.printStackTrace();
+            } catch (Throwable e) {
+                Log.e(TAG, "Bad dex jar file: " + file.getAbsolutePath(), e);
                 return false;
             } finally {
-                SharePatchFileUtil.closeZip(dexJar);
+                // Bugfix: some device redefined ZipFile, which is not implemented closeable.
+                // SharePatchFileUtil.closeZip(dexJar);
+                if (dexJar != null) {
+                    try {
+                        dexJar.close();
+                    } catch (Throwable thr) {
+                        // Ignored.
+                    }
+                }
             }
         }
 
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchInfo.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchInfo.java
index f787fb38..71a96450 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchInfo.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchInfo.java
@@ -16,6 +16,7 @@
 
 package com.tencent.tinker.loader.shareutil;
 
+import android.os.Build;
 import android.util.Log;
 
 import com.tencent.tinker.loader.TinkerRuntimeException;
@@ -33,17 +34,23 @@
     public static final int    MAX_EXTRACT_ATTEMPTS = ShareConstants.MAX_EXTRACT_ATTEMPTS;
     public static final String OLD_VERSION          = ShareConstants.OLD_VERSION;
     public static final String NEW_VERSION          = ShareConstants.NEW_VERSION;
+    public static final String FINGER_PRINT         = "print";
     private static final String TAG = "PatchInfo";
     public String oldVersion;
     public String newVersion;
+    public String fingerPrint;
 
-    public SharePatchInfo(String oldVer, String newVew) {
+    public SharePatchInfo(String oldVer, String newVew, String finger) {
         // TODO Auto-generated constructor stub
         this.oldVersion = oldVer;
         this.newVersion = newVew;
+        this.fingerPrint = finger;
     }
 
     public static SharePatchInfo readAndCheckPropertyWithLock(File pathInfoFile, File lockFile) {
+        if (pathInfoFile == null || lockFile == null) {
+            return null;
+        }
         File lockParentFile = lockFile.getParentFile();
         if (!lockParentFile.exists()) {
             lockParentFile.mkdirs();
@@ -70,6 +77,9 @@ public static SharePatchInfo readAndCheckPropertyWithLock(File pathInfoFile, Fil
     }
 
     public static boolean rewritePatchInfoFileWithLock(File pathInfoFile, SharePatchInfo info, File lockFile) {
+        if (pathInfoFile == null || info == null || lockFile == null) {
+            return false;
+        }
         File lockParentFile = lockFile.getParentFile();
         if (!lockParentFile.exists()) {
             lockParentFile.mkdirs();
@@ -99,6 +109,7 @@ private static SharePatchInfo readAndCheckProperty(File pathInfoFile) {
         int numAttempts = 0;
         String oldVer = null;
         String newVer = null;
+        String lastFingerPrint = null;
 
         while (numAttempts < MAX_EXTRACT_ATTEMPTS && !isReadPatchSuccessful) {
             numAttempts++;
@@ -109,8 +120,10 @@ private static SharePatchInfo readAndCheckProperty(File pathInfoFile) {
                 properties.load(inputStream);
                 oldVer = properties.getProperty(OLD_VERSION);
                 newVer = properties.getProperty(NEW_VERSION);
+                lastFingerPrint = properties.getProperty(FINGER_PRINT);
             } catch (IOException e) {
-                e.printStackTrace();
+//                e.printStackTrace();
+                Log.e(TAG, "read property failed, e:" + e);
             } finally {
                 SharePatchFileUtil.closeQuietly(inputStream);
             }
@@ -118,8 +131,9 @@ private static SharePatchInfo readAndCheckProperty(File pathInfoFile) {
             if (oldVer == null || newVer == null) {
                 continue;
             }
-            //oldver may be "" or 32 md5
-            if ((!oldVer.equals("") && !SharePatchFileUtil.checkIfMd5Valid(oldVer)) || !SharePatchFileUtil.checkIfMd5Valid(newVer)) {
+            //oldVer may be "" or 32 md5
+            if ((!oldVer.equals("") && !SharePatchFileUtil.checkIfMd5Valid(oldVer))
+                || !SharePatchFileUtil.checkIfMd5Valid(newVer)) {
                 Log.w(TAG, "path info file  corrupted:" + pathInfoFile.getAbsolutePath());
                 continue;
             } else {
@@ -128,7 +142,7 @@ private static SharePatchInfo readAndCheckProperty(File pathInfoFile) {
         }
 
         if (isReadPatchSuccessful) {
-            return new SharePatchInfo(oldVer, newVer);
+            return new SharePatchInfo(oldVer, newVer, lastFingerPrint);
         }
 
         return null;
@@ -159,6 +173,8 @@ private static boolean rewritePatchInfoFile(File pathInfoFile, SharePatchInfo in
             Properties newProperties = new Properties();
             newProperties.put(OLD_VERSION, info.oldVersion);
             newProperties.put(NEW_VERSION, info.newVersion);
+            newProperties.put(FINGER_PRINT, Build.FINGERPRINT);
+
             FileOutputStream outputStream = null;
             try {
                 outputStream = new FileOutputStream(pathInfoFile, false);
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareSecurityCheck.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareSecurityCheck.java
index d62e4693..40185a59 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareSecurityCheck.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareSecurityCheck.java
@@ -64,32 +64,6 @@ public ShareSecurityCheck(Context context) {
         return metaContentMap;
     }
 
-    /**
-     * get the base tinkerId
-     *
-     * @return
-     */
-    public String getTinkerID() {
-        if (packageProperties != null) {
-            String tinkerId = packageProperties.get(ShareConstants.TINKER_ID);
-            return tinkerId;
-        }
-        return null;
-    }
-
-    /**
-     * get the new tinkerId
-     *
-     * @return
-     */
-    public String getNewTinkerID() {
-        if (packageProperties != null) {
-            String tinkerId = packageProperties.get(ShareConstants.NEW_TINKER_ID);
-
-            return tinkerId;
-        }
-        return null;
-    }
     /**
      * Nullable
      *
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java
index aba789cc..515e343c 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java
@@ -21,12 +21,15 @@
 import android.content.SharedPreferences;
 import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageManager;
+import android.os.Build;
 import android.util.Log;
 
+import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.InputStream;
+import java.io.PrintStream;
 import java.util.HashMap;
 import java.util.Properties;
 import java.util.regex.Matcher;
@@ -47,7 +50,26 @@
     private static String tinkerID = null;
 
     public static boolean isVmArt() {
-        return VM_IS_ART;
+        return VM_IS_ART || Build.VERSION.SDK_INT >= 21;
+    }
+
+    public static boolean isSystemOTA(String lastFingerPrint) {
+        String currentFingerprint = Build.FINGERPRINT;
+        if (lastFingerPrint == null
+            || lastFingerPrint.equals("")
+            || currentFingerprint == null
+            || currentFingerprint.equals("")) {
+            Log.d(TAG, "fingerprint empty:" + lastFingerPrint + ",current:" + currentFingerprint);
+            return false;
+        } else {
+            if (lastFingerPrint.equals(currentFingerprint)) {
+                Log.d(TAG, "same fingerprint:" + currentFingerprint);
+                return false;
+            } else {
+                Log.d(TAG, "system OTA,fingerprint not equal:" + lastFingerPrint + "," + currentFingerprint);
+                return true;
+            }
+        }
     }
 
     public static boolean isNullOrNil(final String object) {
@@ -101,6 +123,7 @@ public static int checkSignatureAndTinkerID(Context context, File patchFile, Sha
             return ShareConstants.ERROR_PACKAGE_CHECK_PATCH_TINKER_ID_NOT_FOUND;
         }
         if (!oldTinkerId.equals(patchTinkerId)) {
+            Log.e(TAG, "tinkerId is not equal, base is " + oldTinkerId + ", but patch is " + patchTinkerId);
             return ShareConstants.ERROR_PACKAGE_CHECK_TINKER_ID_NOT_EQUAL;
         }
         return ShareConstants.ERROR_PACKAGE_CHECK_OK;
@@ -166,6 +189,7 @@ public static Properties fastGetPatchPackageMeta(File patchFile) {
             SharePatchFileUtil.closeZip(zipFile);
         }
     }
+
     public static String getManifestTinkerID(Context context) {
         if (tinkerID != null) {
             return tinkerID;
@@ -205,8 +229,6 @@ public static String getTypeString(int type) {
         switch (type) {
             case ShareConstants.TYPE_DEX:
                 return "dex";
-            case ShareConstants.TYPE_DEX_FOR_ART:
-                return "dex_art";
             case ShareConstants.TYPE_DEX_OPT:
                 return "dex_opt";
             case ShareConstants.TYPE_LIBRARY:
@@ -261,6 +283,9 @@ public static boolean isInMainProcess(Context context) {
 
     public static void killAllOtherProcess(Context context) {
         final ActivityManager am = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
+        if (am == null) {
+            return;
+        }
         // NOTE: getRunningAppProcess() ONLY GIVE YOU THE PROCESS OF YOUR OWN PACKAGE IN ANDROID M
         // BUT THAT'S ENOUGH HERE
         for (ActivityManager.RunningAppProcessInfo ai : am.getRunningAppProcesses()) {
@@ -365,4 +390,50 @@ private static boolean isVmArt(String versionString) {
         }
         return isArt;
     }
+
+    public static String getExceptionCauseString(final Throwable ex) {
+        final ByteArrayOutputStream bos = new ByteArrayOutputStream();
+        final PrintStream ps = new PrintStream(bos);
+
+        try {
+            // print directly
+            Throwable t = ex;
+            while (t.getCause() != null) {
+                t = t.getCause();
+            }
+            t.printStackTrace(ps);
+            return toVisualString(bos.toString());
+        } finally {
+            try {
+                bos.close();
+            } catch (IOException e) {
+            }
+        }
+    }
+
+    public static String toVisualString(String src) {
+        boolean cutFlg = false;
+        if (null == src) {
+            return null;
+        }
+        char[] chr = src.toCharArray();
+        if (null == chr) {
+            return null;
+        }
+        int i = 0;
+        for (; i < chr.length; i++) {
+            if (chr[i] > 127) {
+                chr[i] = 0;
+                cutFlg = true;
+                break;
+            }
+        }
+
+        if (cutFlg) {
+            return new String(chr, 0, i);
+        } else {
+            return src;
+        }
+    }
+
 }
diff --git a/tinker-android/tinker-android-loader/src/main/res/values/strings.xml b/tinker-android/tinker-android-loader/src/main/res/values/strings.xml
deleted file mode 100644
index 4c563702..00000000
--- a/tinker-android/tinker-android-loader/src/main/res/values/strings.xml
+++ /dev/null
@@ -1,3 +0,0 @@
-<resources>
-    <string name="tinker_test_resource">only use for test tinker resource: a</string>
-</resources>
diff --git a/tinker-build/tinker-patch-cli/build.gradle b/tinker-build/tinker-patch-cli/build.gradle
index 9b48cc3a..c1bd4e62 100644
--- a/tinker-build/tinker-patch-cli/build.gradle
+++ b/tinker-build/tinker-patch-cli/build.gradle
@@ -21,7 +21,8 @@ jar {
 }
 
 // copy the jar to work directory
-task buildSdk(type: Copy, dependsOn: [build, jar]) {
+task buildTinkerSdk(type: Copy, dependsOn: [build, jar]) {
+    group = "tinker"
     from('build/libs') {
         include '*.jar'
         exclude '*-javadoc.jar'
@@ -33,4 +34,4 @@ task buildSdk(type: Copy, dependsOn: [build, jar]) {
     into(rootProject.file("buildSdk/build"))
 }
 
-defaultTasks 'buildSdk'
+defaultTasks 'buildTinkerSdk'
diff --git a/tinker-build/tinker-patch-cli/tool_output/proguard_warning.py b/tinker-build/tinker-patch-cli/tool_output/proguard_warning.py
new file mode 100755
index 00000000..a9cb7681
--- /dev/null
+++ b/tinker-build/tinker-patch-cli/tool_output/proguard_warning.py
@@ -0,0 +1,109 @@
+#!/usr/bin/python
+# coding: utf8
+
+import os
+import sys
+
+
+def print_usage():
+    print >>sys.stderr, \
+        """usage: python proguard_warning.py mapping.txt warning.txt
+
+           the output mapping file is 'mapping_edit.txt' in the cwd directory
+        """
+    sys.exit(1)
+
+class MappingData:
+    raw_line = ""
+    key = ""
+    filed_methods = []
+
+    def __init__(self):
+        self.raw_line = ""
+        self.key = ""
+        self.filed_methods = []
+
+class RemoveProguardWarning:
+    def __init__(self):
+        self.classes = {}
+        self.class_list = []
+
+    def read_mapping_file(self, mapping):
+        current_mapping_data = None
+        with open(mapping) as fd:
+            for line in fd.readlines():
+                if not line.startswith(' '):
+                    if current_mapping_data is not None:
+                        self.classes[current_mapping_data.key] = current_mapping_data
+                        self.class_list.append(current_mapping_data.key)
+
+                    current_mapping_data = MappingData()
+                    current_mapping_data.raw_line = line
+                    current_mapping_data.key = line.split('->')[0].strip()
+                else:
+                    current_mapping_data.filed_methods.append(line)
+
+            self.classes[current_mapping_data.key] = current_mapping_data
+            self.class_list.append(current_mapping_data.key)
+
+        # print "size: ", len(self.classes)
+
+    def remove_warning(self, warning):
+        with open(warning) as fd:
+            for line in fd.readlines():
+                if not line.startswith("Warning:"):
+                    raise Exception("proguard warning must begin with 'Warning:', line=", line)
+                splits = line.split(':')
+                class_key = splits[1].strip()
+                # print "class_key", class_key
+                if class_key not in self.classes:
+                    print "Warning:can't find warning class in the mapping file, class=", class_key
+                    continue
+                warning_value = splits[2].split("'")[1] + " -> " + splits[2].split("'")[5]
+                mapping_data = self.classes[class_key]
+                # print "warning_value", warning_value
+
+                find = False
+                for mappings in mapping_data.filed_methods:
+                    if mappings.find(warning_value) != -1:
+                        mapping_data.filed_methods.remove(mappings)
+                        find = True
+                        break
+
+                if not find:
+                    print "Warning: can't find warning field or method in the mapping file:', value=", warning_value
+
+                if len(mapping_data.filed_methods) == 0:
+                    del self.classes[class_key]
+
+        output_path = os.path.join(os.getcwd(), "mapping_edit.txt")
+        with open(output_path, "w") as fw:
+            for key in self.class_list:
+                if key in self.classes:
+                    data = self.classes[key]
+                    fw.write(data.raw_line)
+                    for line in data.filed_methods:
+                        fw.write(line)
+
+    def remove_warning_mapping(self, mapping, warning):
+        self.read_mapping_file(mapping)
+        self.remove_warning(warning)
+
+    def do_command(self, args):
+        if (len(args) < 2):
+            print_usage()
+
+        mapping_path = args[0]
+        if not os.path.exists(mapping_path):
+            raise Exception("mapping file is not exist, path=%s", mapping_path)
+
+        warning_patch = args[1]
+        if not os.path.exists(warning_patch):
+            raise Exception("proguard warning file is not exist, path=%s", warning_patch)
+
+        self.remove_warning_mapping(mapping_path, warning_patch)
+
+
+
+if __name__ == '__main__':
+    RemoveProguardWarning().do_command(sys.argv[1:])
\ No newline at end of file
diff --git a/tinker-build/tinker-patch-cli/tool_output/tinker_config.xml b/tinker-build/tinker-patch-cli/tool_output/tinker_config.xml
index f62489f0..de0c6c99 100644
--- a/tinker-build/tinker-patch-cli/tool_output/tinker_config.xml
+++ b/tinker-build/tinker-patch-cli/tool_output/tinker_config.xml
@@ -82,6 +82,12 @@
         <!--or TinkerLoadResult.getPackageConfigByName-->
         <!--you must add TINKER_ID with the old apk manifest's meta TINKER_ID value-->
         <!--other config files (such as patchMessage below)is not necessary-->
+
+        <!--For sample project or any projects that copy SamplePatchListener directory,-->
+        <!--platform config field is necessary, or an error code ERROR_PATCH_CONDITION_NOT_SATISFIED(-10)-->
+        <!--will be thrown.-->
+        <configField name="platform" value="all"/>
+
         <configField name="patchMessage" value="classes.dex"/>
     </issue>
 
diff --git a/tinker-build/tinker-patch-gradle-plugin/build.gradle b/tinker-build/tinker-patch-gradle-plugin/build.gradle
index fa4fb4e2..1930bac6 100644
--- a/tinker-build/tinker-patch-gradle-plugin/build.gradle
+++ b/tinker-build/tinker-patch-gradle-plugin/build.gradle
@@ -9,7 +9,7 @@ dependencies {
     compile localGroovy()
 //    compile fileTree(dir: 'libs', include: ['*.jar'])
     compile project(':tinker-build:tinker-patch-lib')
-    compile 'com.google.gradle:osdetector-gradle-plugin:1.2.1'
+    compile 'com.google.gradle:osdetector-gradle-plugin:1.4.0'
     compile 'com.android.tools.build:gradle:2.1.0'
 }
 
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/TinkerPatchPlugin.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/TinkerPatchPlugin.groovy
index 04007409..5d7518a6 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/TinkerPatchPlugin.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/TinkerPatchPlugin.groovy
@@ -18,13 +18,12 @@ package com.tencent.tinker.build.gradle
 
 import com.tencent.tinker.build.gradle.extension.*
 import com.tencent.tinker.build.gradle.task.*
-import com.tencent.tinker.build.gradle.transform.AuxiliaryInjectTransform
 import com.tencent.tinker.build.util.FileOperation
 import com.tencent.tinker.build.util.TypedValue
 import org.gradle.api.GradleException
 import org.gradle.api.Plugin
 import org.gradle.api.Project
-import org.gradle.api.UnknownTaskException
+import org.gradle.api.Task
 
 /**
  * Registers the plugin's tasks.
@@ -37,7 +36,7 @@ class TinkerPatchPlugin implements Plugin<Project> {
 
     @Override
     public void apply(Project project) {
-        project.apply plugin: 'osdetector'
+        project.apply plugin: 'com.google.osdetector'
 
         project.extensions.create('tinkerPatch', TinkerPatchExtension)
 
@@ -51,21 +50,37 @@ class TinkerPatchPlugin implements Plugin<Project> {
 
         def configuration = project.tinkerPatch
 
-        project.android.registerTransform(new AuxiliaryInjectTransform(project))
+        if (!project.plugins.hasPlugin('com.android.application')) {
+            throw new GradleException('generateTinkerApk: Android Application plugin required')
+        }
 
-        project.afterEvaluate {
-            if (!project.plugins.hasPlugin('com.android.application')) {
-                throw new GradleException('generateTinkerApk: Android Application plugin required')
-            }
+        def android = project.extensions.android
 
-            def android = project.extensions.android
-            //add the tinker anno resource to the package exclude option
-            android.packagingOptions.exclude("META-INF/services/javax.annotation.processing.Processor")
-            android.packagingOptions.exclude("TinkerAnnoApplication.tmpl")
-            //open jumboMode
-            android.dexOptions.jumboMode = true
+        //add the tinker anno resource to the package exclude option
+        android.packagingOptions.exclude("META-INF/services/javax.annotation.processing.Processor")
+        android.packagingOptions.exclude("TinkerAnnoApplication.tmpl")
+
+        //open jumboMode
+        android.dexOptions.jumboMode = true
+
+        //close preDexLibraries
+        try {
+            android.dexOptions.preDexLibraries = false
+        } catch (Throwable e) {
+            //no preDexLibraries field, just continue
+        }
 
+        project.afterEvaluate {
+            if (!configuration.tinkerEnable) {
+                project.logger.error("tinker tasks are disabled.")
+                return
+            }
             project.logger.error("----------------------tinker build warning ------------------------------------")
+            project.logger.error("tinker auto operation: ")
+            project.logger.error("excluding annotation processor and source template from app packaging. Enable dx jumboMode to reduce package size.")
+            project.logger.error("enable dx jumboMode to reduce package size.")
+            project.logger.error("disable preDexLibraries to prevent ClassDefNotFoundException when your app is booting.")
+            project.logger.error("")
             project.logger.error("tinker will change your build configs:")
             project.logger.error("we will add TINKER_ID=${configuration.buildConfig.tinkerId} in your build output manifest file build/intermediates/manifests/full/*")
             project.logger.error("")
@@ -82,7 +97,7 @@ class TinkerPatchPlugin implements Plugin<Project> {
             project.logger.error("")
             project.logger.error("if multiDexEnabled is true")
             project.logger.error("you will find the gen multiDexKeepProguard file at ${TinkerMultidexConfigTask.MULTIDEX_CONFIG_PATH}")
-            project.logger.error("and you should copy it to your own multiDex keep proguard file yourself.")
+            project.logger.error("and we will help you to put it in the MultiDexKeepProguardFile.")
             project.logger.error("")
             project.logger.error("if applyResourceMapping file is exist")
             String tempResourceMappingPath = configuration.buildConfig.applyResourceMapping
@@ -99,17 +114,13 @@ class TinkerPatchPlugin implements Plugin<Project> {
                 def variantOutput = variant.outputs.first()
                 def variantName = variant.name.capitalize()
 
-                try {
-                    def instantRunTask = project.tasks.getByName("transformClassesWithInstantRunFor${variantName}")
-                    if (instantRunTask) {
-                        throw new GradleException(
-                                "Tinker does not support instant run mode, please trigger build"
-                                        + " by assemble${variantName} or disable instant run"
-                                        + " in 'File->Settings...'."
-                        )
-                    }
-                } catch (UnknownTaskException e) {
-                    // Not in instant run mode, continue.
+                def instantRunTask = getInstantRunTask(project, variantName)
+                if (instantRunTask != null) {
+                    throw new GradleException(
+                            "Tinker does not support instant run mode, please trigger build"
+                                    + " by assemble${variantName} or disable instant run"
+                                    + " in 'File->Settings...'."
+                    )
                 }
 
                 TinkerPatchSchemaTask tinkerPatchBuildTask = project.tasks.create("tinkerPatch${variantName}", TinkerPatchSchemaTask)
@@ -146,7 +157,13 @@ class TinkerPatchPlugin implements Plugin<Project> {
                 if (proguardEnable) {
                     TinkerProguardConfigTask proguardConfigTask = project.tasks.create("tinkerProcess${variantName}Proguard", TinkerProguardConfigTask)
                     proguardConfigTask.applicationVariant = variant
-                    variantOutput.packageApplication.dependsOn proguardConfigTask
+                    proguardConfigTask.mustRunAfter manifestTask
+
+                    def proguardTask = getProguardTask(project, variantName)
+                    if (proguardTask != null) {
+                        proguardTask.dependsOn proguardConfigTask
+                    }
+
                 }
 
                 // Add this multidex proguard settings file to the list
@@ -155,12 +172,44 @@ class TinkerPatchPlugin implements Plugin<Project> {
                 if (multiDexEnabled) {
                     TinkerMultidexConfigTask multidexConfigTask = project.tasks.create("tinkerProcess${variantName}MultidexKeep", TinkerMultidexConfigTask)
                     multidexConfigTask.applicationVariant = variant
-                    variantOutput.packageApplication.dependsOn multidexConfigTask
+                    multidexConfigTask.mustRunAfter manifestTask
+
+                    def multidexTask = getMultiDexTask(project, variantName)
+                    if (multidexTask != null) {
+                        multidexTask.dependsOn multidexConfigTask
+                    }
+                    def collectMultiDexComponentsTask = getCollectMultiDexComponentsTask(project, variantName)
+                    if (collectMultiDexComponentsTask != null) {
+                        multidexConfigTask.mustRunAfter collectMultiDexComponentsTask
+                    }
                 }
 
+                if (configuration.buildConfig.keepDexApply
+                    && FileOperation.isLegalFile(project.tinkerPatch.oldApk)) {
+                    com.tencent.tinker.build.gradle.transform.ImmutableDexTransform.inject(project, variant)
+                }
             }
         }
+    }
+
+    Task getMultiDexTask(Project project, String variantName) {
+        String multiDexTaskName = "transformClassesWithMultidexlistFor${variantName}"
+        return project.tasks.findByName(multiDexTaskName)
+    }
+
+    Task getProguardTask(Project project, String variantName) {
+        String proguardTaskName = "transformClassesAndResourcesWithProguardFor${variantName}"
+        return project.tasks.findByName(proguardTaskName)
+    }
+
+    Task getInstantRunTask(Project project, String variantName) {
+        String instantRunTask = "transformClassesWithInstantRunFor${variantName}"
+        return project.tasks.findByName(instantRunTask)
+    }
 
+    Task getCollectMultiDexComponentsTask(Project project, String variantName) {
+        String collectMultiDexComponents = "collect${variantName}MultiDexComponents"
+        return project.tasks.findByName(collectMultiDexComponents)
     }
 
 }
\ No newline at end of file
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerBuildConfigExtension.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerBuildConfigExtension.groovy
index 4ad1b62e..7d109793 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerBuildConfigExtension.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerBuildConfigExtension.groovy
@@ -49,12 +49,19 @@ public class TinkerBuildConfigExtension {
 
     boolean usingResourceMapping
 
+    /**
+     * if keepDexApply is true,class in which dex refer to the old apk.
+     * open this can reduce the dex diff file size.
+     */
+    boolean keepDexApply;
+
     public TinkerBuildConfigExtension(Project project) {
         this.project = project
         applyMapping = ""
         applyResourceMapping = ""
         tinkerId = null
         usingResourceMapping = false
+        keepDexApply = false
     }
 
     void checkParameter() {
@@ -68,6 +75,7 @@ public class TinkerBuildConfigExtension {
     public String toString() {
         """| applyMapping = ${applyMapping}
            | applyResourceMapping = ${applyResourceMapping}
+           | keepDexApply = ${keepDexApply}
            | tinkerId = ${tinkerId}
         """.stripMargin()
     }
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerDexExtension.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerDexExtension.groovy
index 0bab55fe..f600b499 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerDexExtension.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerDexExtension.groovy
@@ -32,18 +32,6 @@ public class TinkerDexExtension {
      */
     String dexMode;
 
-    /**
-     * If mUsePreGeneratedPatchDex was enabled, tinker framework would generate
-     * a dex file including all added and changed classes instead of patch info file.
-     *
-     * You can make this mode enabled if you're using any dex encrypting solutions or
-     * maintaining patches that suitable for multi-channel base packages.
-     *
-     * Notice that although you use this mode, proguard mappings should still be applied
-     * to base package and all patched packages.
-     */
-    boolean usePreGeneratedPatchDex
-
     /**
      * the dex file patterns, which dex or jar files will be deal to gen patch
      * such as [classes.dex, classes-*.dex, assets/multiDex/*.jar]
@@ -55,13 +43,14 @@ public class TinkerDexExtension {
      * such as [com.tencent.tinker.loader.*, com.tinker.sample.MyApplication]
      */
     Iterable<String> loader;
+
+
     private Project project;
 
     public TinkerDexExtension(Project project) {
         dexMode = "jar"
         pattern = []
         loader = []
-        usePreGeneratedPatchDex = false
         this.project = project
     }
 
@@ -74,7 +63,6 @@ public class TinkerDexExtension {
     @Override
     public String toString() {
         """| dexMode = ${dexMode}
-           | usePreGeneratedPatchDex = ${usePreGeneratedPatchDex}
            | pattern = ${pattern}
            | loader = ${loader}
         """.stripMargin()
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerPatchExtension.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerPatchExtension.groovy
index 17ec5b63..c3b86141 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerPatchExtension.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerPatchExtension.groovy
@@ -44,10 +44,17 @@ public class TinkerPatchExtension {
      */
     boolean useSign
 
+    /**
+     * whether use tinker
+     * default: true
+     */
+    boolean tinkerEnable
+
     public TinkerPatchExtension() {
         oldApk = ""
         ignoreWarning = false
         useSign = true
+        tinkerEnable = true
     }
 
     void checkParameter() {
@@ -67,6 +74,7 @@ public class TinkerPatchExtension {
     public String toString() {
         """| oldApk = ${oldApk}
            | ignoreWarning = ${ignoreWarning}
+           | tinkerEnable = ${tinkerEnable}
            | useSign = ${useSign}
         """.stripMargin()
     }
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerManifestTask.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerManifestTask.groovy
index 50af6687..2c4b19d1 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerManifestTask.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerManifestTask.groovy
@@ -31,6 +31,8 @@ import org.gradle.api.tasks.TaskAction
 public class TinkerManifestTask extends DefaultTask {
     static final String MANIFEST_XML = TinkerPatchPlugin.TINKER_INTERMEDIATES + "AndroidManifest.xml"
     static final String TINKER_ID = "TINKER_ID"
+    static final String TINKER_ID_PREFIX = "tinker_id_"
+
     String manifestPath
     TinkerManifestTask() {
         group = 'tinker'
@@ -43,11 +45,25 @@ public class TinkerManifestTask extends DefaultTask {
         if (tinkerValue == null || tinkerValue.isEmpty()) {
             throw new GradleException('tinkerId is not set!!!')
         }
+
+        tinkerValue = TINKER_ID_PREFIX + tinkerValue
+
         project.logger.error("tinker add ${tinkerValue} to your AndroidManifest.xml ${manifestPath}")
 
+        writeManifestMeta(manifestPath, TINKER_ID, tinkerValue)
+        addApplicationToLoaderPattern()
+        File manifestFile = new File(manifestPath)
+        if (manifestFile.exists()) {
+            FileOperation.copyFileUsingStream(manifestFile, project.file(MANIFEST_XML))
+            project.logger.error("tinker gen AndroidManifest.xml in ${MANIFEST_XML}")
+        }
+
+    }
+
+    void writeManifestMeta(String path, String name, String value) {
         def ns = new Namespace("http://schemas.android.com/apk/res/android", "android")
 
-        def xml = new XmlParser().parse(new InputStreamReader(new FileInputStream(manifestPath), "utf-8"))
+        def xml = new XmlParser().parse(new InputStreamReader(new FileInputStream(path), "utf-8"))
 
         def application = xml.application[0]
         if (application) {
@@ -55,25 +71,46 @@ public class TinkerManifestTask extends DefaultTask {
 
             // remove any old TINKER_ID elements
             def tinkerId = metaDataTags.findAll {
-                it.attributes()[ns.name].equals(TINKER_ID)
+                it.attributes()[ns.name].equals(name)
             }.each {
                 it.parent().remove(it)
             }
 
             // Add the new TINKER_ID element
-            application.appendNode('meta-data', [(ns.name): TINKER_ID, (ns.value): tinkerValue])
+            application.appendNode('meta-data', [(ns.name): name, (ns.value): value])
 
             // Write the manifest file
-            def printer = new XmlNodePrinter(new PrintWriter(manifestPath, "utf-8"))
+            def printer = new XmlNodePrinter(new PrintWriter(path, "utf-8"))
             printer.preserveWhitespace = true
             printer.print(xml)
         }
-        File manifestFile = new File(manifestPath)
-        if (manifestFile.exists()) {
-            FileOperation.copyFileUsingStream(manifestFile, project.file(MANIFEST_XML))
-            project.logger.error("tinker gen AndroidManifest.xml in ${MANIFEST_XML}")
+    }
+
+    void addApplicationToLoaderPattern() {
+        Iterable<String> loader = project.extensions.tinkerPatch.dex.loader
+        String applicationName = readManifestApplicationName(manifestPath)
+
+        if (applicationName != null && !loader.contains(applicationName)) {
+            loader.add(applicationName)
+            project.logger.error("tinker add ${applicationName} to dex loader pattern")
+        }
+        String loaderClass = "com.tencent.tinker.loader.*"
+        if (!loader.contains(loaderClass)) {
+            loader.add(loaderClass)
+            project.logger.error("tinker add ${loaderClass} to dex loader pattern")
         }
 
     }
+
+    String readManifestApplicationName(String path) {
+        def xml = new XmlParser().parse(new InputStreamReader(new FileInputStream(path), "utf-8"))
+        def ns = new Namespace("http://schemas.android.com/apk/res/android", "android")
+
+        def application = xml.application[0]
+        if (application) {
+            return application.attributes()[ns.name]
+        }
+        return null
+    }
 }
 
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerMultidexConfigTask.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerMultidexConfigTask.groovy
index edc22e81..b713c39b 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerMultidexConfigTask.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerMultidexConfigTask.groovy
@@ -16,12 +16,10 @@
 
 package com.tencent.tinker.build.gradle.task
 
-import com.tencent.tinker.build.auxiliaryclass.AuxiliaryClassInjector
 import com.tencent.tinker.build.gradle.TinkerPatchPlugin
 import org.gradle.api.DefaultTask
 import org.gradle.api.tasks.TaskAction
 
-
 /**
  * The configuration properties.
  *
@@ -51,20 +49,19 @@ public class TinkerMultidexConfigTask extends DefaultTask {
 
     @TaskAction
     def updateTinkerProguardConfig() {
-        def file = project.file(MULTIDEX_CONFIG_PATH)
+        File file = project.file(MULTIDEX_CONFIG_PATH)
         project.logger.error("try update tinker multidex keep proguard file with ${file}")
 
         // Create the directory if it doesn't exist already
         file.getParentFile().mkdirs()
 
-        // Write our recommended proguard settings to this file
-        FileWriter fr = new FileWriter(file.path)
-
-        fr.write(MULTIDEX_CONFIG_SETTINGS)
-        fr.write("\n")
+        StringBuffer lines = new StringBuffer()
+        lines.append("\n")
+             .append("#tinker multidex keep patterns:\n")
+             .append(MULTIDEX_CONFIG_SETTINGS)
+             .append("\n")
+             .append("#your dex.loader patterns here\n")
 
-        //unlike proguard, if loader endwith *, we must change to **
-        fr.write("#your dex.loader patterns here\n")
         Iterable<String> loader = project.extensions.tinkerPatch.dex.loader
         for (String pattern : loader) {
             if (pattern.endsWith("*")) {
@@ -72,12 +69,44 @@ public class TinkerMultidexConfigTask extends DefaultTask {
                     pattern += "*"
                 }
             }
-            fr.write("-keep class " + pattern + " {\n" +
+            lines.append("-keep class " + pattern + " {\n" +
                     "    *;\n" +
                     "}\n")
-            fr.write("\n")
+                    .append("\n")
+        }
+
+        // Write our recommended proguard settings to this file
+        FileWriter fr = new FileWriter(file.path)
+        try {
+            for (String line : lines) {
+                fr.write(line)
+            }
+        } finally {
+            fr.close()
+        }
+
+        File multiDexKeepProguard = null
+        try {
+            multiDexKeepProguard = applicationVariant.getVariantData().getScope().getManifestKeepListProguardFile()
+        } catch (Throwable ignore) {
+            try {
+                multiDexKeepProguard = applicationVariant.getVariantData().getScope().getManifestKeepListFile()
+            } catch (Throwable e) {
+                project.logger.error("can't find getManifestKeepListFile method, exception:${e}")
+            }
+        }
+        if (multiDexKeepProguard == null) {
+            project.logger.error("auto add multidex keep pattern fail, you can only copy ${file} to your own multiDex keep proguard file yourself.")
+            return
+        }
+        FileWriter manifestWriter = new FileWriter(multiDexKeepProguard, true)
+        try {
+            for (String line : lines) {
+                manifestWriter.write(line)
+            }
+        } finally {
+            manifestWriter.close()
         }
-        fr.close()
     }
 
 
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerPatchSchemaTask.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerPatchSchemaTask.groovy
index 8ae768d3..c9f11441 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerPatchSchemaTask.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerPatchSchemaTask.groovy
@@ -44,8 +44,6 @@ public class TinkerPatchSchemaTask extends DefaultTask {
 
     @TaskAction
     def tinkerPatch() {
-//        println configuration.toString()
-
         configuration.checkParameter()
         configuration.buildConfig.checkParameter()
         configuration.res.checkParameter()
@@ -55,7 +53,7 @@ public class TinkerPatchSchemaTask extends DefaultTask {
         InputParam.Builder builder = new InputParam.Builder()
         if (configuration.useSign) {
             if (signConfig == null) {
-                throw new GradleException("can't the get signConfig for ${taskName} build")
+                throw new GradleException("can't the get signConfig for this build")
             }
             builder.setSignFile(signConfig.storeFile)
                     .setKeypass(signConfig.keyPassword)
@@ -68,7 +66,6 @@ public class TinkerPatchSchemaTask extends DefaultTask {
                .setNewApk(buildApkPath)
                .setOutBuilder(outputFolder)
                .setIgnoreWarning(configuration.ignoreWarning)
-               .setUsePreGeneratedPatchDex(configuration.dex.usePreGeneratedPatchDex)
                .setDexFilePattern(configuration.dex.pattern)
                .setDexLoaderPattern(configuration.dex.loader)
                .setDexMode(configuration.dex.dexMode)
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerProguardConfigTask.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerProguardConfigTask.groovy
index 8528b265..e98a0935 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerProguardConfigTask.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerProguardConfigTask.groovy
@@ -16,7 +16,6 @@
 
 package com.tencent.tinker.build.gradle.task
 
-import com.tencent.tinker.build.auxiliaryclass.AuxiliaryClassInjector
 import com.tencent.tinker.build.gradle.TinkerPatchPlugin
 import com.tencent.tinker.build.util.FileOperation
 import org.gradle.api.DefaultTask
@@ -32,7 +31,6 @@ public class TinkerProguardConfigTask extends DefaultTask {
     static final String PROGUARD_CONFIG_SETTINGS =
             "-keepattributes *Annotation* \n" +
                     "-dontwarn com.tencent.tinker.anno.AnnotationProcessor \n" +
-                    "-dontwarn ${AuxiliaryClassInjector.NOT_EXISTS_CLASSNAME} \n" +
                     "-keep @com.tencent.tinker.anno.DefaultLifeCycle public class *\n" +
                     "-keep public class * extends android.app.Application {\n" +
                     "    *;\n" +
@@ -89,21 +87,6 @@ public class TinkerProguardConfigTask extends DefaultTask {
 
         fr.write(PROGUARD_CONFIG_SETTINGS)
 
-        // Write additional rules to keep <init> and <clinit>
-        if (project.tinkerPatch.dex.usePreGeneratedPatchDex) {
-            def additionalKeptRules =
-                            "-keep class ${AuxiliaryClassInjector.NOT_EXISTS_CLASSNAME} { \n" +
-                            '    *; \n' +
-                            '}\n' +
-                            '\n' +
-                            '-keepclassmembers class * { \n' +
-                            '    <init>(...); \n' +
-                            '    static void <clinit>(...); \n' +
-                            '}\n'
-            fr.write(additionalKeptRules)
-            fr.write('\n')
-        }
-
         fr.write("#your dex.loader patterns here\n")
         //they will removed when apply
         Iterable<String> loader = project.extensions.tinkerPatch.dex.loader
@@ -118,6 +101,7 @@ public class TinkerProguardConfigTask extends DefaultTask {
         // Add this proguard settings file to the list
         applicationVariant.getBuildType().buildType.proguardFiles(file)
         def files = applicationVariant.getBuildType().buildType.getProguardFiles()
+
         project.logger.error("now proguard files is ${files}")
     }
 }
\ No newline at end of file
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/transform/AuxiliaryInjectTransform.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/transform/AuxiliaryInjectTransform.groovy
deleted file mode 100644
index c1a929b0..00000000
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/transform/AuxiliaryInjectTransform.groovy
+++ /dev/null
@@ -1,344 +0,0 @@
-/*
- * Tencent is pleased to support the open source community by making Tinker available.
- *
- * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
- *
- * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- *
- * https://opensource.org/licenses/BSD-3-Clause
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is
- * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
- * either express or implied. See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.tencent.tinker.build.gradle.transform
-
-import com.android.build.api.transform.*
-import com.google.common.collect.ImmutableSet
-import com.google.common.io.Files
-import com.tencent.tinker.build.auxiliaryclass.AuxiliaryClassInjector
-import com.tencent.tinker.build.auxiliaryclass.AuxiliaryClassInjector.ProcessJarCallback
-import com.tencent.tinker.build.util.MD5
-import groovy.io.FileType
-import groovy.xml.Namespace
-import org.gradle.api.Project
-
-/**
- * Transform for calling AuxiliaryClassInjector.
- *
- * @author tangyinsheng
- */
-public class AuxiliaryInjectTransform extends Transform {
-    private static final String TRANSFORM_NAME = 'AuxiliaryInject'
-
-    private final Project project
-
-    private boolean isEnabled = false
-
-    def applicationVariants
-
-    /* ****** Variant related parameters start ****** */
-
-    boolean isInitialized = false
-    def manifestFile = null
-    def appClassName = ''
-    def appClassPathName = ''
-
-    /* ******  Variant related parameters end  ****** */
-
-    public AuxiliaryInjectTransform(Project project) {
-        this.project = project
-
-        project.afterEvaluate {
-            this.isEnabled = project.tinkerPatch.dex.usePreGeneratedPatchDex
-
-            this.applicationVariants = project.android.applicationVariants
-        }
-    }
-
-    @Override
-    String getName() {
-        return TRANSFORM_NAME
-    }
-
-    @Override
-    Set<QualifiedContent.ContentType> getInputTypes() {
-        return ImmutableSet.of(QualifiedContent.DefaultContentType.CLASSES)
-    }
-
-    @Override
-    Set<QualifiedContent.Scope> getScopes() {
-        return ImmutableSet.of(
-                QualifiedContent.Scope.PROJECT,
-                QualifiedContent.Scope.SUB_PROJECTS,
-                QualifiedContent.Scope.PROJECT_LOCAL_DEPS,
-                QualifiedContent.Scope.SUB_PROJECTS_LOCAL_DEPS,
-                QualifiedContent.Scope.EXTERNAL_LIBRARIES
-        )
-    }
-
-    @Override
-    boolean isIncremental() {
-        return true
-    }
-
-    private String getTaskNamePrefix(Transform transform) {
-        StringBuilder sb = new StringBuilder(100);
-        sb.append("transform");
-
-        Iterator<QualifiedContent.ContentType> iterator = transform.getInputTypes().iterator();
-        // there's always at least one
-        sb.append(iterator.next().name().toLowerCase(Locale.getDefault()).capitalize());
-        while (iterator.hasNext()) {
-            sb.append("And").append(
-                    iterator.next().name().toLowerCase(Locale.getDefault()).capitalize());
-        }
-
-        sb.append("With").append(transform.getName().capitalize()).append("For");
-
-        return sb.toString();
-    }
-
-    private String decapitalize(String src) {
-        char[] chars = src.toCharArray()
-        chars[0] += (char) 32
-        return new String(chars)
-    }
-
-    private void initVariantRelatedParamsIfNeeded(String variantName) {
-        if (this.isInitialized) {
-            return
-        }
-
-        // Get manifest file path.
-        this.applicationVariants.any { variant ->
-            if (variant.name.equals(variantName)) {
-                def variantOutput = variant.outputs.first()
-                this.manifestFile = variantOutput.processManifest.manifestOutputFile
-                return true  // break out.
-            }
-        }
-
-        // Get application classname from manifest file.
-        if (this.manifestFile != null) {
-            def parsedManifest = new XmlParser().parse(
-                    new InputStreamReader(new FileInputStream(this.manifestFile), "utf-8"))
-            def androidTag = new Namespace(
-                    'http://schemas.android.com/apk/res/android', 'android')
-            this.appClassName = parsedManifest.application[0].attribute(androidTag.name)
-
-            if (this.appClassName != null && this.appClassName.length() > 0) {
-                this.appClassPathName = this.appClassName.replace('.', '/') + '.class'
-            }
-        }
-
-        this.isInitialized = true
-    }
-
-    @Override
-    public void transform(TransformInvocation transformInvocation) throws TransformException, InterruptedException, IOException {
-        String variantName = decapitalize(transformInvocation.context.path.split(getTaskNamePrefix(this))[1])
-        initVariantRelatedParamsIfNeeded(variantName)
-
-        def dirInputs = new HashSet<>()
-        def jarInputs = new HashSet<>()
-
-        // Collecting inputs.
-        transformInvocation.inputs.each { input ->
-            input.directoryInputs.each { dirInput ->
-                dirInputs.add(dirInput)
-            }
-            input.jarInputs.each { jarInput ->
-                jarInputs.add(jarInput)
-            }
-        }
-
-        if (!this.isEnabled) {
-            printMsgLog("PreGeneratedPatchDex mode is disabled, skip transforming.")
-        }
-
-        if (!dirInputs.isEmpty() || !jarInputs.isEmpty()) {
-            File dirOutput = transformInvocation.outputProvider.getContentLocation(
-                    "classes", getOutputTypes(), getScopes(), Format.DIRECTORY)
-            if (!dirOutput.exists()) {
-                dirOutput.mkdirs()
-            }
-
-            if (!dirInputs.isEmpty()) {
-                dirInputs.each { dirInput ->
-                    if (transformInvocation.incremental) {
-                        dirInput.changedFiles.each { entry ->
-                            File fileInput = entry.getKey()
-                            File fileOutput = new File(fileInput.getAbsolutePath().replace(
-                                    dirInput.file.getAbsolutePath(), dirOutput.getAbsolutePath()))
-                            if (!fileOutput.exists()) {
-                                fileOutput.getParentFile().mkdirs()
-                            }
-                            final String relativeInputClassPath =
-                                    dirInput.file.toPath().relativize(fileInput.toPath())
-                                            .toString().replace('\\', '/')
-
-                            Status fileStatus = entry.getValue()
-                            switch(fileStatus) {
-                                case Status.ADDED:
-                                case Status.CHANGED:
-                                    if (fileInput.isDirectory()) {
-                                        return // continue.
-                                    }
-
-                                    // If disabled or not a class file, skip transforming them.
-                                    if (!this.isEnabled || !fileInput.getName().endsWith('.class')) {
-                                        Files.copy(fileInput, fileOutput)
-                                    } else {
-                                        // Skip application class.
-                                        if (relativeInputClassPath.equals(this.appClassPathName)) {
-                                            printWarnLog('Skipping Application class: %s',
-                                                    relativeInputClassPath)
-                                            Files.copy(fileInput, fileOutput)
-                                        } else {
-                                            printMsgLog('Processing %s file %s',
-                                                    fileStatus,
-                                                    relativeInputClassPath)
-                                            AuxiliaryClassInjector.processClass(fileInput, fileOutput)
-                                        }
-                                    }
-                                    break
-                                case Status.REMOVED:
-                                    // Print log if it's enabled only.
-                                    if (this.isEnabled) {
-                                        printMsgLog('Removing %s file %s from result.', fileStatus,
-                                                dirOutput.toPath().relativize(fileOutput.toPath()).toString())
-                                    }
-
-                                    if (fileOutput.exists()) {
-                                        if (fileOutput.isDirectory()) {
-                                            fileOutput.deleteDir()
-                                        } else {
-                                            fileOutput.delete()
-                                        }
-                                    }
-                                    break
-                            }
-                        }
-                    } else {
-                        if (dirOutput.exists()) {
-                            dirOutput.deleteDir()
-                        }
-
-                        dirInput.file.traverse(type: FileType.FILES) { fileInput ->
-                            File fileOutput = new File(fileInput.getAbsolutePath().replace(dirInput.file.getAbsolutePath(), dirOutput.getAbsolutePath()))
-                            if (!fileOutput.exists()) {
-                                fileOutput.getParentFile().mkdirs()
-                            }
-                            final String relativeInputClassPath =
-                                    dirInput.file.toPath().relativize(fileInput.toPath())
-                                            .toString().replace('\\', '/')
-
-                            // If disabled or not a class file, skip transforming them.
-                            if (!this.isEnabled || !fileInput.getName().endsWith('.class')) {
-                                Files.copy(fileInput, fileOutput)
-                            } else {
-                                // Skip application class.
-                                if (relativeInputClassPath.equals(this.appClassPathName)) {
-                                    printWarnLog('Skipping Application class: %s',
-                                            relativeInputClassPath)
-                                    Files.copy(fileInput, fileOutput)
-                                } else {
-                                    printMsgLog('Processing %s file %s',
-                                            Status.ADDED,
-                                            relativeInputClassPath)
-                                    AuxiliaryClassInjector.processClass(fileInput, fileOutput)
-                                }
-                            }
-                        }
-                    }
-                }
-            }
-
-            if (!jarInputs.isEmpty()) {
-                jarInputs.each { jarInput ->
-                    File jarInputFile = jarInput.file
-                    File jarOutputFile = transformInvocation.outputProvider.getContentLocation(
-                            getUniqueHashName(jarInputFile), getOutputTypes(), getScopes(), Format.JAR
-                    )
-                    if (!jarOutputFile.exists()) {
-                        jarOutputFile.getParentFile().mkdirs()
-                    }
-
-                    switch (jarInput.status) {
-                        case Status.NOTCHANGED:
-                            if (transformInvocation.incremental) {
-                                break
-                            }
-                        case Status.ADDED:
-                        case Status.CHANGED:
-                            // Print log if it's enabled only.
-                            if (this.isEnabled) {
-                                printMsgLog('Processing %s file %s',
-                                        transformInvocation.incremental ? jarInput.status : Status.ADDED,
-                                        jarInputFile)
-                            }
-
-                            AuxiliaryClassInjector.processJar(jarInputFile, jarOutputFile, new ProcessJarCallback() {
-                                @Override
-                                boolean onProcessClassEntry(String entryName) {
-                                    // If disabled or not a class file, skip transforming them.
-                                    if (!this.isEnabled || !entryName.endsWith('.class')) {
-                                        return false
-                                    } else {
-                                        // Skip application class.
-                                        if (entryName.equals(AuxiliaryInjectTransform.this.appClassPathName)) {
-                                            return false
-                                        } else {
-                                            return true;
-                                        }
-                                    }
-                                }
-                            })
-                            break
-                        case Status.REMOVED:
-                            // Print log if it's enabled only.
-                            if (this.isEnabled) {
-                                printMsgLog('Removing %s file %s from result.', fileStatus,
-                                        jarOutputFile)
-                            }
-
-                            if (jarOutputFile.exists()) {
-                                jarOutputFile.delete()
-                            }
-                            break
-                    }
-                }
-            }
-        }
-    }
-
-    private String getUniqueHashName(File fileInput) {
-        final String fileInputName = fileInput.getName()
-        if (fileInput.isDirectory()) {
-            return fileInputName
-        }
-        final String parentDirPath = fileInput.getParentFile().getAbsolutePath()
-        final String pathMD5 = MD5.getMessageDigest(parentDirPath.getBytes())
-        final int extSepPos = fileInputName.lastIndexOf('.')
-        final String fileInputNamePrefix =
-                (extSepPos >= 0 ? fileInputName.substring(0, extSepPos) : fileInputName)
-        return fileInputNamePrefix + '_' + pathMD5
-    }
-
-    private void printMsgLog(String fmt, Object... vals) {
-        final String title = TRANSFORM_NAME.capitalize()
-        this.project.logger.lifecycle("[{}] {}", title,
-                (vals == null || vals.length == 0 ? fmt : String.format(fmt, vals)))
-    }
-
-    private void printWarnLog(String fmt, Object... vals) {
-        final String title = TRANSFORM_NAME.capitalize()
-        this.project.logger.warn("[{}] {}", title,
-                (vals == null || vals.length == 0 ? fmt : String.format(fmt, vals)))
-    }
-}
-
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/transform/ImmutableDexTransform.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/transform/ImmutableDexTransform.groovy
new file mode 100644
index 00000000..92a80fcf
--- /dev/null
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/transform/ImmutableDexTransform.groovy
@@ -0,0 +1,510 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.build.gradle.transform
+
+import com.android.annotations.NonNull
+import com.android.build.api.transform.Format
+import com.android.build.api.transform.JarInput;
+import com.android.build.api.transform.QualifiedContent
+import com.android.build.api.transform.Transform;
+import com.android.build.api.transform.TransformException
+import com.android.build.api.transform.TransformInput
+import com.android.build.api.transform.TransformInvocation
+import com.android.build.api.transform.TransformOutputProvider
+import com.android.build.gradle.internal.pipeline.TransformTask
+import com.android.build.gradle.internal.transforms.DexTransform
+import com.google.common.base.Joiner
+import com.google.common.collect.Lists
+import com.tencent.tinker.android.dex.ClassDef
+import com.tencent.tinker.android.dex.Dex
+import com.tencent.tinker.build.gradle.TinkerPatchPlugin
+import com.tencent.tinker.build.immutable.ClassSimDef
+import com.tencent.tinker.build.immutable.DexRefData
+import com.tencent.tinker.build.util.FileOperation
+import com.tencent.tinker.build.util.Utils
+import org.gradle.api.GradleException
+import org.gradle.api.Project
+import org.gradle.api.Task
+import org.gradle.api.execution.TaskExecutionGraph
+import org.gradle.api.execution.TaskExecutionGraphListener
+import org.gradle.api.logging.Logging
+
+
+import java.lang.reflect.Field;
+import java.util.zip.ZipEntry
+import java.util.zip.ZipFile
+import java.util.zip.ZipOutputStream
+
+/**
+ * Created by wangzhi on 16/11/24.
+ */
+public class ImmutableDexTransform extends Transform {
+
+    public static final String TASK_WORK_DIR = "keep_dex"
+
+    private static final Joiner PATH_JOINER = Joiner.on(File.separatorChar);
+
+    Project project
+
+    String oldApkPath
+
+    File classPreDir
+
+    File baseDexDir
+
+    File dxOutDir
+
+    File mainDexListFile
+
+    String varName
+
+    String varDirName
+
+    def variant
+
+    DexTransform dexTransform
+
+
+    ImmutableDexTransform(Project project, def variant, DexTransform dexTransform) {
+        this.dexTransform = dexTransform
+        this.project = project
+        this.variant = variant
+        this.varName = variant.name.capitalize()
+        this.varDirName = variant.getDirName()
+        this.oldApkPath = project.tinkerPatch.oldApk
+        this.mainDexListFile = dexTransform.mainDexListFile
+    }
+
+    public void initFileEnv(TransformOutputProvider outputProvider) {
+        classPreDir = getDirInWorkDir("class_pre")
+        baseDexDir = getDirInWorkDir("base_dex")
+        dxOutDir = outputProvider.getContentLocation("main",
+                getOutputTypes(), getScopes(),
+                Format.DIRECTORY);
+
+        classPreDir.mkdirs()
+        baseDexDir.mkdirs()
+        dxOutDir.mkdirs()
+
+        FileOperation.cleanDir(classPreDir)
+        FileOperation.cleanDir(baseDexDir)
+        FileOperation.cleanDir(dxOutDir)
+    }
+
+    private File getDirInWorkDir(String name) {
+        return new File(PATH_JOINER.join(project.projectDir,
+                TinkerPatchPlugin.TINKER_INTERMEDIATES,
+                TASK_WORK_DIR,
+                name,
+                varDirName)
+        )
+    }
+
+
+    @NonNull
+    @Override
+    public Set<QualifiedContent.ContentType> getOutputTypes() {
+        return dexTransform.getOutputTypes();
+    }
+
+    @NonNull
+    @Override
+    public Collection<File> getSecondaryFileInputs() {
+        return dexTransform.getSecondaryFileInputs()
+    }
+
+    @NonNull
+    @Override
+    public Collection<File> getSecondaryDirectoryOutputs() {
+        return dexTransform.getSecondaryDirectoryOutputs()
+    }
+
+    @NonNull
+    @Override
+    public Map<String, Object> getParameterInputs() {
+       return dexTransform.getParameterInputs()
+    }
+
+    @Override
+    String getName() {
+        return dexTransform.getName()
+    }
+
+    @Override
+    Set<QualifiedContent.ContentType> getInputTypes() {
+        return dexTransform.getInputTypes()
+    }
+
+    @Override
+    Set<QualifiedContent.Scope> getScopes() {
+        return dexTransform.getScopes()
+    }
+
+    @Override
+    boolean isIncremental() {
+        return dexTransform.isIncremental()
+    }
+
+    @Override
+    void transform(TransformInvocation transformInvocation) throws TransformException, IOException, InterruptedException {
+
+        // because multi dex is enable,we only process jar file.
+        List<JarInput> jarInputs = Lists.newArrayList();
+        for (TransformInput input : transformInvocation.getInputs()) {
+            jarInputs.addAll(input.getJarInputs());
+        }
+        //because the multi-dex is turned on,so the jarInput.size()==1 in theory.
+        if (jarInputs.size() != 1) {
+            project.logger.error("jar input size is ${jarInputs.size()}, expected is 1. we will skip immutable dex!")
+            dexTransform.transform(transformInvocation)
+            return
+        }
+
+        //init
+        initFileEnv(transformInvocation.getOutputProvider());
+        //get all old dex
+        ArrayList<File> oldDexList = new ArrayList<>()
+        traversal(new ZipFile(oldApkPath), { ZipEntry zipEntry, byte[] bytes ->
+            if (zipEntry.name.startsWith("classes") && zipEntry.name.endsWith(".dex")) {
+                project.logger.info("find dex: ${zipEntry.name} in old apk. ")
+                File classDxFile = new File(baseDexDir, zipEntry.name)
+                classDxFile.withDataOutputStream { output ->
+                    output.write(bytes, 0, bytes.length)
+                    output.close()
+                }
+                oldDexList.add(classDxFile)
+            }
+        })
+
+        //hashmap:classPath <==> dexName
+        HashMap<String, String> pathDexMap = new HashMap<>()
+        project.logger.info("old dex list is : ${oldDexList}.")
+
+        //hashmap:classPath<=>dexName
+        oldDexList.each { dexFile ->
+            Dex dex = new Dex(dexFile)
+            dex.classDefs().each { ClassDef classDef ->
+                String classPath = dex.typeNames().get(classDef.typeIndex)
+                if (pathDexMap.get(classPath)) {
+                    throw new GradleException("double class: ${classPath} in dex: ${dexFile.name} ")
+                }
+                pathDexMap.put(classPath, dexFile.name - ".dex")
+            }
+        }
+        //the dex start index for orphan class
+        int newDexIndex = oldDexList.size()
+        //a hashset for maindexlist
+        HashSet<String> mainDexSets = initMainDexSet(mainDexListFile)
+        project.logger.info("mainDexSets is ${mainDexSets}.")
+        //zip file name <==> ZipOutputStream
+        HashMap<String, ZipOutputStream> osMap = new HashMap<>()
+        //zip file name <==> mtd count and filed count in the zip
+        HashMap<String, DexRefData> methodAndFieldsNum = new HashMap<>()
+        //orphan class's entry <==> orphan class's bytes
+        HashMap<ZipEntry, ByteArrayOutputStream> orphanMap = new HashMap()
+
+        //all class  in allClass.jar
+        HashSet<String> allClassSet = new HashSet<>()
+        //process all-classes.jar
+        processJar(jarInputs.get(0).file, allClassSet, pathDexMap, mainDexSets, methodAndFieldsNum, osMap, orphanMap)
+
+        Iterator<Map.Entry<ZipEntry, ByteArrayOutputStream>> iterator = orphanMap.entrySet().iterator()
+        Map.Entry<ZipEntry, ByteArrayOutputStream> leaveEntry = null
+        while (iterator.hasNext()) {
+            boolean writeResult = true
+            while (writeResult && iterator.hasNext()) {
+                if (leaveEntry != null) {
+                    String newDexName = dexIndexToName(newDexIndex, "")
+                    project.logger.info("write level orphan class: ${leaveEntry.key.name} to zip: ${newDexName}")
+                    writeResult = writeClassToZip(methodAndFieldsNum, osMap, newDexName, leaveEntry.value.toByteArray(), leaveEntry.key)
+                    if (!writeResult) {
+                        throw new GradleException("add one class to a new zip failed!\n" +
+                                "\t class:" + leaveEntry.key.name + "  zip: " + newDexName)
+                    }
+                }
+                Map.Entry<ZipEntry, ByteArrayOutputStream> entry = iterator.next()
+                leaveEntry = entry
+                String newDexName = dexIndexToName(newDexIndex, "")
+                project.logger.info("write orphan class: ${entry.key.name} to zip: ${newDexName}")
+                writeResult = writeClassToZip(methodAndFieldsNum, osMap, newDexName, entry.value.toByteArray(), entry.key)
+                if (writeResult) {
+                    leaveEntry = null
+                }
+            }
+            newDexIndex++
+        }
+
+        osMap.each { key, value ->
+            value.close()
+        }
+
+        //a list for all dex's path,use for checkClassConsistence mtd
+        ArrayList<String> dexPathList = new ArrayList<>()
+        classPreDir.eachFile { classZip ->
+            String classIndexName = classZip.name - ".jar"
+            String dexPath = "${dxOutDir.absolutePath}/${classIndexName}.dex"
+            dexPathList.add(dexPath)
+            doDex(classIndexName, classZip, project.android.getDexOptions())
+        }
+
+        checkClassConsistence(dexPathList, allClassSet)
+
+    }
+
+    private void processJar(File jarFile,
+                            HashSet<String> allClassSet, HashMap<String, String> pathDexMap, HashSet<String> mainDexSets, HashMap<String, DexRefData> methodAndFieldsNum, HashMap<String, ZipOutputStream> osMap, HashMap<ZipEntry, ByteArrayOutputStream> orphanMap) {
+
+
+        ZipFile zipFile = new ZipFile(jarFile)
+        //process class in maindexlist in first
+        traversal(zipFile, { ZipEntry zipEntry, byte[] bytes ->
+            if (zipEntry.name.endsWith(".class")) {
+                if (mainDexSets.contains(zipEntry.name)) {
+                    String classPath = rePathToClassPath(zipEntry.name)
+                    allClassSet.add(classPath)
+                    project.logger.info("process main dex list's class " + classPath)
+                    if (!writeClassToZip(methodAndFieldsNum, osMap, "classes", bytes, zipEntry)) {
+                        throw new GradleException("main dex is exceed the limit! reduce the class number on your main dex keep please.")
+                    }
+                }
+            }
+        })
+
+        traversal(zipFile, {
+            ZipEntry zipEntry,
+            byte[] bytes ->
+                if (zipEntry.name.endsWith(".class")) {
+                    String classPath = rePathToClassPath(zipEntry.name)
+                    if (!Utils.isBlank(classPath) && !allClassSet.contains(classPath)) {
+                        allClassSet.add(classPath)
+                        //get the old dex name which class be located
+                        String belongDex = belongTo(pathDexMap, classPath)
+                        //the class is new or method|fields exceeds limit
+                        if (Utils.isBlank(belongDex) ||
+                                !writeClassToZip(methodAndFieldsNum, osMap, belongDex, bytes, zipEntry)) {
+                            if (Utils.isBlank(belongDex)) {
+                                project.logger.warn("find new class: " + classPath)
+                            }
+                            saveOrphan(orphanMap, zipEntry, bytes)
+                        }
+                    } else {
+                        if (Utils.isBlank(classPath)) {
+                            project.logger.error("illegal zip entry: " + zipEntry.name)
+                        }
+                    }
+
+                }
+        })
+    }
+
+    public HashSet<String> initMainDexSet(File mainDexList) {
+        HashSet<String> mainDexSets = new HashSet<>()
+        BufferedReader reader = mainDexList.newReader()
+        List<String> lines = reader.readLines()
+        lines.each {
+            mainDexSets.add(it)
+        }
+        return mainDexSets
+    }
+
+    private String rePathToClassPath(String rePath) {
+        int eIndex = rePath.lastIndexOf(".class")
+        if (eIndex >= 0) {
+            return "L${rePath.substring(0, eIndex)};"
+        } else {
+            return ""
+        }
+    }
+
+
+    private void doDex(String classIndexName, File classZip, def dexOptions) {
+        ArrayList<String> execArgs = new ArrayList()
+        def dex = "${project.android.getSdkDirectory()}/build-tools/${project.android.buildToolsVersion}/dx"
+        execArgs.add(dex.toString())
+        execArgs.add("--dex")
+        if (dexOptions.getJumboMode()) {
+            execArgs.add("--force-jumbo");
+        }
+        if (dexOptions.getIncremental()) {
+            execArgs.add("--incremental");
+            execArgs.add("--no-strict");
+        }
+        execArgs.add("--output=${dxOutDir.absolutePath}/${classIndexName}.dex".toString())
+        execArgs.add(classZip.absolutePath)
+        project.logger.info(execArgs.toString())
+        Utils.exec(execArgs, null)
+    }
+
+    public static void inject(Project project, def variant) {
+        project.logger.info("prepare inject dex transform ")
+        if (!variant.apkVariantData.variantConfiguration.isMultiDexEnabled()) {
+            project.logger.warn("multidex is diable. we will not replace the dex transform.")
+            return
+        }
+        if (!FileOperation.isLegalFile(project.tinkerPatch.oldApk)) {
+            project.logger.warn("oldApk is illegal. we will not replace the dex transform.")
+            return
+        }
+
+        project.getGradle().getTaskGraph().addTaskExecutionGraphListener(new TaskExecutionGraphListener() {
+            @Override
+            public void graphPopulated(TaskExecutionGraph taskGraph) {
+                for (Task task : taskGraph.getAllTasks()) {
+                    if (task instanceof TransformTask && task.name.toLowerCase().contains(variant.name.toLowerCase())) {
+
+                        if (((TransformTask) task).getTransform() instanceof DexTransform && !(((TransformTask) task).getTransform() instanceof ImmutableDexTransform)) {
+                            project.logger.warn("find dex transform. transform class: " + task.transform.getClass() + " . task name: " + task.name)
+
+                            DexTransform dexTransform = task.transform
+                            ImmutableDexTransform hookDexTransform = new ImmutableDexTransform(project,
+                                    variant, dexTransform)
+                            project.logger.info("variant name: " + variant.name)
+
+                            Field field = TransformTask.class.getDeclaredField("transform")
+                            field.setAccessible(true)
+                            field.set(task, hookDexTransform)
+                            project.logger.warn("transform class after hook: " + task.transform.getClass())
+                            break;
+                        }
+                    }
+                }
+            }
+        });
+
+    }
+
+
+    void checkClassConsistence(ArrayList<String> dexPathList, HashSet<String> allClassSet) {
+        project.logger.info("start check class's consistence ..")
+        if (dexPathList == null || dexPathList.size() == 0) {
+            throw new GradleException("immutable dex list is null! ")
+        }
+        project.logger.info("check dex list: " + dexPathList)
+        HashSet<String> dexClassSet = new HashSet<>()
+        int classSize = 0
+        dexPathList.each { path ->
+            File dexFile = new File(path)
+            if (dexFile.isFile()) {
+                Dex dex = new Dex(dexFile)
+                classSize += dex.classDefs().size()
+                for (ClassDef item : dex.classDefs()) {
+                    int index = item.typeIndex
+                    dexClassSet.add(dex.typeNames().get(index))
+                }
+            } else {
+                throw new GradleException("dex: ${dexFile} is illegal!")
+            }
+        }
+
+        HashSet<String> hashSet1 = new HashSet<>(dexClassSet)
+        HashSet<String> hashSet2 = new HashSet<>(allClassSet)
+
+        hashSet1.removeAll(allClassSet)
+        hashSet2.removeAll(dexClassSet)
+
+        if (hashSet1.size() != 0 || hashSet2.size() != 0) {
+            throw new GradleException("class is inconsistent! " + "\n\t"
+                    + "allClassSet size is " + allClassSet.size()
+                    + ",dexClassSet size is " + dexClassSet.size() + "\n"
+                    + "allClassSet has extra class: " + hashSet2 + ",\n"
+                    + "dexClassSet has extra class: " + hashSet1 + ".\n"
+            )
+        } else {
+            project.logger.info("check class consistence successful! ")
+        }
+
+    }
+
+    boolean writeClassToZip(HashMap<String, DexRefData> methodAndFieldsNum,
+                            HashMap<String, ZipOutputStream> osMap,
+                            String belongDex,
+                            byte[] bytes,
+                            ZipEntry zipEntry) {
+        File jarFile = new File(classPreDir, belongDex + ".jar")
+        DexRefData mfData = methodAndFieldsNum.get(jarFile.name)
+        if (mfData == null) {
+            mfData = new DexRefData()
+            methodAndFieldsNum.put(jarFile.name, mfData)
+        }
+        ClassSimDef cf = new ClassSimDef(bytes, mfData.refFields, mfData.refMtds)
+        ZipOutputStream zos = osMap.get(belongDex)
+        if (zos == null) {
+            project.logger.info("jarFile is  ${jarFile}.")
+            zos = new ZipOutputStream(new FileOutputStream(jarFile))
+            osMap.put(belongDex, zos)
+        }
+        if (!writeClassToZipNoCheck(mfData, cf, zos, zipEntry, bytes)) {
+            project.logger.error("except limit! \n \tfind class ${zipEntry.name} method num: ${mfData.methodNum},field num: ${mfData.fieldNum},belong dex: ${belongDex} ")
+            return false
+        } else {
+            return true
+        }
+    }
+
+    boolean writeClassToZipNoCheck(DexRefData mfData, ClassSimDef cf, ZipOutputStream zos, ZipEntry zipEntry, byte[] bytes) {
+        /**
+         * In ClassSimDef, only the fields  which  methods referenced or in the class definition are scanned.
+         * But in fact, some fields may be referenced in annotation. So the statistics in ClassSimDef is not complete.
+         * The threshold is adjusted lower in order to avoid the troubles to calculate the fields referred by annotations.
+         */
+        if (mfData.methodNum + cf.methodCount >= 65536 || mfData.fieldNum + cf.fieldCount >= 64536) {
+            return false
+        } else {
+            mfData.methodNum += cf.methodCount
+            mfData.fieldNum += cf.fieldCount
+            zos.putNextEntry(zipEntry)
+            zos.write(bytes)
+            zos.closeEntry()
+            return true
+        }
+    }
+
+    void saveOrphan(HashMap<ZipEntry, ByteArrayOutputStream> orphanMap, ZipEntry zipEntry, byte[] bytes) {
+        ByteArrayOutputStream bos = new ByteArrayOutputStream(bytes.length)
+        bos.write(bytes, 0, bytes.length)
+        bos.flush()
+        orphanMap.put(zipEntry, bos)
+    }
+
+    public static String getNextClassName(int index) {
+        return "classes${index + 1}.dex"
+    }
+
+    public String dexIndexToName(int index, String suffix) {
+        return "classes" + (index == 1 ? "" : index) + suffix
+    }
+
+    public String belongTo(HashMap<String, String> pathDexMap, String classPath) {
+        return pathDexMap.get(classPath)
+    }
+
+    public static void traversal(ZipFile zipFile, Closure callback) {
+        try {
+            Enumeration<? extends ZipEntry> enumeration = zipFile.entries();
+            while (enumeration.hasMoreElements()) {
+                ZipEntry entry = enumeration.nextElement();
+                callback.call(entry, zipFile.getInputStream(entry).bytes)
+            }
+        } catch (IOException e) {
+            e.printStackTrace();
+            Utils.closeQuietly(zipFile);
+        }
+    }
+}
+
+
+
diff --git a/tinker-build/tinker-patch-lib/build.gradle b/tinker-build/tinker-patch-lib/build.gradle
index ddb4e9b4..669e3811 100644
--- a/tinker-build/tinker-patch-lib/build.gradle
+++ b/tinker-build/tinker-patch-lib/build.gradle
@@ -11,8 +11,7 @@ dependencies {
     compile project(':tinker-commons')
     compile group: 'com.tencent.mm', name: 'apk-parser-lib', version: '1.0.0'
     compile group: 'com.google.guava', name: 'guava', version: '11.0.2'
-    compile group: 'org.smali', name: 'dexlib2', version: '2.1.3'
-    compile group: 'org.ow2.asm', name: 'asm-all', version: '5.0.4'
+    compile group: 'org.ow2.asm', name: 'asm', version: '5.0.3'
 }
 
 sourceSets {
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptUtil.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptUtil.java
index 8e058f76..fd2e7220 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptUtil.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptUtil.java
@@ -105,8 +105,8 @@ public static void processXmlFilesForIds(String resourceDirectory, List<RDotTxtE
                 File xmlFile = new File(xmlFullFilename);
                 String parentFullFilename = xmlFile.getParent();
                 File parentFile = new File(parentFullFilename);
-                if (isAValuesDirectory(parentFile.getName())) {
-                    // Ignore files under values* directories.
+                if (isAValuesDirectory(parentFile.getName()) || parentFile.getName().startsWith("raw")) {
+                    // Ignore files under values* directories and raw*.
                     continue;
                 }
                 processXmlFile(xmlFullFilename, references, resourceCollector);
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/PatchUtil.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/PatchUtil.java
index af195a50..6af535ad 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/PatchUtil.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/PatchUtil.java
@@ -20,8 +20,8 @@
 import com.tencent.tinker.build.aapt.RDotTxtEntry.RType;
 
 import java.io.BufferedReader;
+import java.io.File;
 import java.io.FileInputStream;
-import java.io.FileOutputStream;
 import java.io.InputStreamReader;
 import java.io.PrintWriter;
 import java.util.Arrays;
@@ -102,8 +102,8 @@ public static void generatePublicResourceXml(AaptResourceCollector aaptResourceC
         try {
             FileUtil.createFile(outputIdsXmlFullFilename);
             FileUtil.createFile(outputPublicXmlFullFilename);
-            idsWriter = new PrintWriter(new FileOutputStream(outputIdsXmlFullFilename));
-            publicWriter = new PrintWriter(new FileOutputStream(outputPublicXmlFullFilename));
+            idsWriter = new PrintWriter(new File(outputIdsXmlFullFilename), "UTF-8");
+            publicWriter = new PrintWriter(new File(outputPublicXmlFullFilename), "UTF-8");
             idsWriter.println("<?xml version=\"1.0\" encoding=\"utf-8\"?>");
             publicWriter.println("<?xml version=\"1.0\" encoding=\"utf-8\"?>");
             idsWriter.println("<resources>");
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/auxiliaryclass/AuxiliaryClassInjectAdapter.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/auxiliaryclass/AuxiliaryClassInjectAdapter.java
deleted file mode 100644
index 6cd7200d..00000000
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/auxiliaryclass/AuxiliaryClassInjectAdapter.java
+++ /dev/null
@@ -1,150 +0,0 @@
-/*
- * Tencent is pleased to support the open source community by making Tinker available.
- *
- * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
- *
- * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- *
- * https://opensource.org/licenses/BSD-3-Clause
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is
- * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
- * either express or implied. See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.tencent.tinker.build.auxiliaryclass;
-
-import org.objectweb.asm.ClassVisitor;
-import org.objectweb.asm.ClassWriter;
-import org.objectweb.asm.Label;
-import org.objectweb.asm.MethodVisitor;
-import org.objectweb.asm.Opcodes;
-import org.objectweb.asm.Type;
-
-/**
- * Created by tangyinsheng on 2016/10/10.
- */
-
-public final class AuxiliaryClassInjectAdapter extends ClassVisitor {
-    private final String auxiliaryClassDesc;
-    private boolean isClInitExists;
-    private boolean isInitExists;
-    private boolean isTargetClass;
-    private boolean isInjected;
-
-    public AuxiliaryClassInjectAdapter(String auxiliaryClassName, ClassWriter cw) {
-        super(Opcodes.ASM5, cw);
-        this.auxiliaryClassDesc = fastClassNameToDesc(auxiliaryClassName);
-    }
-
-    private String fastClassNameToDesc(String className) {
-        if (className.startsWith("L") && className.endsWith(";")) {
-            return className;
-        }
-        if ("boolean".equals(className)) {
-            return "Z";
-        } else
-        if ("byte".equals(className)) {
-            return "B";
-        } else
-        if ("char".equals(className)) {
-            return "C";
-        } else
-        if ("short".equals(className)) {
-            return "S";
-        } else
-        if ("int".equals(className)) {
-            return "I";
-        } else
-        if ("long".equals(className)) {
-            return "J";
-        } else
-        if ("float".equals(className)) {
-            return "F";
-        } else
-        if ("double".equals(className)) {
-            return "D";
-        } else {
-            className = className.replace('.', '/');
-            return "L" + className + ";";
-        }
-    }
-
-    @Override
-    public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {
-        super.visit(version, access, name, signature, superName, interfaces);
-        this.isClInitExists = false;
-        this.isInitExists = false;
-        this.isTargetClass = ((access & Opcodes.ACC_INTERFACE) == 0);
-        this.isInjected = false;
-    }
-
-    @Override
-    public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {
-        MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);
-        if (mv != null && this.isTargetClass && !this.isInjected) {
-            if ("<clinit>".equals(name)) {
-                this.isClInitExists = true;
-                this.isInjected = true;
-                mv = new InjectImplMethodVisitor(mv);
-            } else
-            if ("<init>".equals(name)) {
-                this.isInitExists = true;
-                this.isInjected = true;
-                mv = new InjectImplMethodVisitor(mv);
-            }
-        }
-        return mv;
-    }
-
-    @Override
-    public void visitEnd() {
-        // If method <clinit> and <init> are not found, we should generate a <clinit>.
-        if (!this.isClInitExists && !this.isInitExists) {
-            MethodVisitor mv = super.visitMethod(Opcodes.ACC_STATIC, "<clinit>", "()V", null, null);
-            mv.visitCode();
-            mv.visitMethodInsn(Opcodes.INVOKESTATIC, "java/lang/System", "lineSeparator", "()Ljava/lang/String;", false);
-            Label lblSkipInvalidInsn = new Label();
-            mv.visitJumpInsn(Opcodes.IFNONNULL, lblSkipInvalidInsn);
-            mv.visitLdcInsn(Type.getType(this.auxiliaryClassDesc));
-            mv.visitVarInsn(Opcodes.ASTORE, 0);
-            mv.visitLabel(lblSkipInvalidInsn);
-            mv.visitInsn(Opcodes.RETURN);
-            mv.visitMaxs(1, 1);
-            mv.visitEnd();
-        }
-        super.visitEnd();
-    }
-
-    private class InjectImplMethodVisitor extends MethodVisitor {
-        InjectImplMethodVisitor(MethodVisitor mv) {
-            super(Opcodes.ASM5, mv);
-        }
-
-        @Override
-        public void visitInsn(int opcode) {
-            if (opcode == Opcodes.RETURN) {
-                super.visitMethodInsn(Opcodes.INVOKESTATIC, "java/lang/System", "lineSeparator", "()Ljava/lang/String;", false);
-                Label lblSkipInvalidInsn = new Label();
-                super.visitJumpInsn(Opcodes.IFNONNULL, lblSkipInvalidInsn);
-                super.visitLdcInsn(Type.getType(AuxiliaryClassInjectAdapter.this.auxiliaryClassDesc));
-                super.visitVarInsn(Opcodes.ASTORE, 0);
-                super.visitLabel(lblSkipInvalidInsn);
-            }
-            super.visitInsn(opcode);
-        }
-
-        @Override
-        public void visitMaxs(int maxStack, int maxLocals) {
-            if (maxStack < 1) {
-                maxStack = 1;
-            }
-            if (maxLocals < 1) {
-                maxLocals = 1;
-            }
-            super.visitMaxs(maxStack, maxLocals);
-        }
-    }
-}
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/auxiliaryclass/AuxiliaryClassInjector.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/auxiliaryclass/AuxiliaryClassInjector.java
deleted file mode 100644
index a74cfea6..00000000
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/auxiliaryclass/AuxiliaryClassInjector.java
+++ /dev/null
@@ -1,153 +0,0 @@
-/*
- * Tencent is pleased to support the open source community by making Tinker available.
- *
- * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
- *
- * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- *
- * https://opensource.org/licenses/BSD-3-Clause
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is
- * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
- * either express or implied. See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.tencent.tinker.build.auxiliaryclass;
-
-import com.tencent.tinker.commons.ziputil.Streams;
-
-import org.objectweb.asm.ClassReader;
-import org.objectweb.asm.ClassWriter;
-
-import java.io.BufferedInputStream;
-import java.io.BufferedOutputStream;
-import java.io.Closeable;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.nio.charset.Charset;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.zip.ZipEntry;
-import java.util.zip.ZipInputStream;
-import java.util.zip.ZipOutputStream;
-
-/**
- * Created by tangyinsheng on 2016/10/9.
- */
-
-public final class AuxiliaryClassInjector {
-    // The descriptor of this class is so strange so that we hope no one
-    // would happen to create a class named the same as it.
-    public static final String NOT_EXISTS_CLASSNAME
-            = "tInKEr.pReVEnT.PrEVErIfIEd.STuBCLaSS";
-
-    public interface ProcessJarCallback {
-        boolean onProcessClassEntry(String entryName);
-    }
-
-    public static void processClass(File classIn, File classOut) throws IOException {
-        InputStream is = null;
-        OutputStream os = null;
-        try {
-            is = new BufferedInputStream(new FileInputStream(classIn));
-            os = new BufferedOutputStream(new FileOutputStream(classOut));
-            processClass(is, os);
-        } finally {
-            closeQuietly(os);
-            closeQuietly(is);
-        }
-    }
-
-    public static void processJar(File jarIn, File jarOut, ProcessJarCallback cb) throws IOException {
-        try {
-            processJarHelper(jarIn, jarOut, cb, Charset.forName("UTF-8"), Charset.forName("UTF-8"));
-        } catch (IllegalArgumentException e) {
-            if ("MALFORMED".equals(e.getMessage())) {
-                processJarHelper(jarIn, jarOut, cb, Charset.forName("GBK"), Charset.forName("UTF-8"));
-            } else {
-                throw e;
-            }
-        }
-    }
-
-    @SuppressWarnings("NewApi")
-    private static void processJarHelper(File jarIn, File jarOut, ProcessJarCallback cb, Charset charsetIn, Charset charsetOut) throws IOException {
-        ZipInputStream zis = null;
-        ZipOutputStream zos = null;
-        try {
-            zis = new ZipInputStream(new BufferedInputStream(new FileInputStream(jarIn)), charsetIn);
-            zos = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(jarOut)), charsetOut);
-            ZipEntry entryIn = null;
-            Map<String, Integer> processedEntryNamesMap = new HashMap<>();
-            while ((entryIn = zis.getNextEntry()) != null) {
-                final String entryName = entryIn.getName();
-                ZipEntry entryOut = new ZipEntry(entryIn);
-                entryOut.setCompressedSize(-1);
-                if (!processedEntryNamesMap.containsKey(entryName)) {
-                    zos.putNextEntry(entryOut);
-                    if (!entryIn.isDirectory()) {
-                        if (entryName.endsWith(".class")) {
-                            if (cb == null || cb.onProcessClassEntry(entryName)) {
-                                processClass(zis, zos);
-                            } else {
-                                Streams.copy(zis, zos);
-                            }
-                        } else {
-                            Streams.copy(zis, zos);
-                        }
-                    }
-                    zos.closeEntry();
-                    processedEntryNamesMap.put(entryName, 1);
-                } else {
-                    int duplicateCount = processedEntryNamesMap.get(entryName);
-                    final String wrapperJarName
-                            = jarOut.getName().substring(0, jarOut.getName().lastIndexOf(".jar"))
-                            + "_dup_ew_" + duplicateCount + ".jar";
-                    File wrapperJarOut = new File(jarOut.getParentFile(), wrapperJarName);
-                    wrapEntryByJar(entryOut, zis, wrapperJarOut);
-                    processedEntryNamesMap.put(entryName, duplicateCount + 1);
-                }
-            }
-        } finally {
-            closeQuietly(zos);
-            closeQuietly(zis);
-        }
-    }
-
-    private static void wrapEntryByJar(ZipEntry ze, InputStream eData, File jarOut) throws IOException {
-        ZipOutputStream zos = null;
-        try {
-            zos = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(jarOut)));
-            zos.putNextEntry(ze);
-            Streams.copy(eData, zos);
-            zos.closeEntry();
-        } finally {
-            closeQuietly(zos);
-        }
-    }
-
-    private static void processClass(InputStream classIn, OutputStream classOut) throws IOException {
-        ClassReader cr = new ClassReader(classIn);
-        ClassWriter cw = new ClassWriter(0);
-        AuxiliaryClassInjectAdapter aia = new AuxiliaryClassInjectAdapter(NOT_EXISTS_CLASSNAME, cw);
-        cr.accept(aia, 0);
-        classOut.write(cw.toByteArray());
-        classOut.flush();
-    }
-
-    private static void closeQuietly(Closeable target) {
-        if (target != null) {
-            try {
-                target.close();
-            } catch (Exception e) {
-                // Ignored.
-            }
-        }
-    }
-}
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/builder/PatchBuilder.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/builder/PatchBuilder.java
index a607da74..7b2e0d3e 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/builder/PatchBuilder.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/builder/PatchBuilder.java
@@ -98,7 +98,7 @@ private String getSignatureAlgorithm() throws Exception {
             signatureAlgorithm = "SHA1withECDSA";
         } else {
             throw new RuntimeException("private key is not a DSA or "
-                + "RSA key");
+                    + "RSA key");
         }
         return signatureAlgorithm;
     }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ApkDecoder.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ApkDecoder.java
index 679f3e2f..d099a697 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ApkDecoder.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ApkDecoder.java
@@ -116,7 +116,7 @@ public boolean patch(File oldFile, File newFile) throws Exception {
         for (File duplicateRes : resDuplicateFiles) {
 //            resPatchDecoder.patch(duplicateRes, null);
             Logger.e("Warning: res file %s is also match at dex or library pattern, "
-                + "we treat it as unchanged in the new resource_out.zip", getRelativeStringByOldDir(duplicateRes));
+                + "we treat it as unchanged in the new resource_out.zip", getRelativePathStringToOldFile(duplicateRes));
         }
 
         soPatchDecoder.onAllPatchesEnd();
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/BaseDecoder.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/BaseDecoder.java
index d6550847..8ea4eb5e 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/BaseDecoder.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/BaseDecoder.java
@@ -58,20 +58,16 @@ public Path getOutputPath(File file) {
         return config.mTempResultDir.toPath().resolve(getRelativePath(file));
     }
 
-    public String getRelativeString(File file) {
-        return config.mTempUnzipNewDir.toPath().relativize(file.toPath()).toString().replace("\\", "/");
+    public String getRelativePathStringToOldFile(File oldFile) {
+        return config.mTempUnzipOldDir.toPath().relativize(oldFile.toPath()).toString().replace("\\", "/");
     }
 
-    public String getParentRelativeString(File file) {
-        return config.mTempUnzipNewDir.toPath().relativize(file.getParentFile().toPath()).toString().replace("\\", "/");
+    public String getRelativePathStringToNewFile(File newFile) {
+        return config.mTempUnzipNewDir.toPath().relativize(newFile.toPath()).toString().replace("\\", "/");
     }
 
-    public String getRelativeStringByOldDir(File file) {
-        return config.mTempUnzipOldDir.toPath().relativize(file.toPath()).toString().replace("\\", "/");
-    }
-
-    public String getParentRelativeStringByOldDir(File file) {
-        return config.mTempUnzipOldDir.toPath().relativize(file.getParentFile().toPath()).toString().replace("\\", "/");
+    public String getParentRelativePathStringToNewFile(File newFile) {
+        return config.mTempUnzipNewDir.toPath().relativize(newFile.getParentFile().toPath()).toString().replace("\\", "/");
     }
 
     /**
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/BsDiffDecoder.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/BsDiffDecoder.java
index 48e27930..a46b0d8b 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/BsDiffDecoder.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/BsDiffDecoder.java
@@ -118,8 +118,8 @@ protected void writeLogFiles(File newFile, File oldFile, File bsDiff, String new
         if (metaWriter == null && logWriter == null) {
             return;
         }
-        String parentRelative = getParentRelativeString(newFile);
-        String relative = getRelativeString(newFile);
+        String parentRelative = getParentRelativePathStringToNewFile(newFile);
+        String relative = getRelativePathStringToNewFile(newFile);
 
         if (metaWriter != null) {
             String fileName = newFile.getName();
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java
index 0a298879..2fce2357 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java
@@ -17,20 +17,14 @@
 package com.tencent.tinker.build.decoder;
 
 
-import com.google.common.io.Files;
-
 import com.tencent.tinker.android.dex.ClassDef;
 import com.tencent.tinker.android.dex.Dex;
 import com.tencent.tinker.android.dex.DexFormat;
-import com.tencent.tinker.android.dx.util.Hex;
 import com.tencent.tinker.build.dexpatcher.DexPatchGenerator;
-import com.tencent.tinker.build.dexpatcher.util.SmallDexClassInfoCollector;
-import com.tencent.tinker.build.dexpatcher.util.SmallDexPatchGenerator;
 import com.tencent.tinker.build.info.InfoWriter;
 import com.tencent.tinker.build.patch.Configuration;
 import com.tencent.tinker.build.util.DexClassesComparator;
 import com.tencent.tinker.build.util.DexClassesComparator.DexClassInfo;
-import com.tencent.tinker.build.util.DexClassesComparator.DexGroup;
 import com.tencent.tinker.build.util.ExcludedClassModifiedChecker;
 import com.tencent.tinker.build.util.FileOperation;
 import com.tencent.tinker.build.util.Logger;
@@ -40,18 +34,6 @@
 import com.tencent.tinker.build.util.Utils;
 import com.tencent.tinker.commons.dexpatcher.DexPatchApplier;
 import com.tencent.tinker.commons.dexpatcher.DexPatcherLogger.IDexPatcherLogger;
-import com.tencent.tinker.commons.dexpatcher.struct.SmallPatchedDexItemFile;
-
-import org.jf.dexlib2.Opcodes;
-import org.jf.dexlib2.builder.BuilderMutableMethodImplementation;
-import org.jf.dexlib2.dexbacked.DexBackedDexFile;
-import org.jf.dexlib2.iface.DexFile;
-import org.jf.dexlib2.iface.Field;
-import org.jf.dexlib2.iface.Method;
-import org.jf.dexlib2.writer.builder.BuilderField;
-import org.jf.dexlib2.writer.builder.BuilderMethod;
-import org.jf.dexlib2.writer.builder.DexBuilder;
-import org.jf.dexlib2.writer.io.FileDataStore;
 
 import java.io.File;
 import java.io.IOException;
@@ -71,7 +53,6 @@
  */
 public class DexDiffDecoder extends BaseDecoder {
     private static final String TEST_DEX_NAME = "test.dex";
-    private static final String PREGENERATED_PATCH_DEX_NAME = "changed_classes.dex";
 
     private final InfoWriter logWriter;
     private final InfoWriter metaWriter;
@@ -121,13 +102,21 @@ public void onAllPatchesStart() throws IOException, TinkerPatchException {
 
     }
 
+    /**
+     * Provide /oldFileRoot/dir/to/oldDex, /newFileRoot/dir/to/newDex,
+     * return dir/to/oldDex or dir/to/newDex if any one is not null.
+     */
+    protected String getRelativeDexName(File oldDexFile, File newDexFile) {
+        return oldDexFile != null ? getRelativePathStringToOldFile(oldDexFile) : getRelativePathStringToNewFile(newDexFile);
+    }
+
     @SuppressWarnings("NewApi")
     @Override
     public boolean patch(final File oldFile, final File newFile) throws IOException, TinkerPatchException {
+        final String dexName = getRelativeDexName(oldFile, newFile);
+
         // first of all, we should check input files if excluded classes were modified.
-        Logger.d("Check for loader classes in dex: %s",
-            (oldFile == null ? getRelativeString(newFile) : getRelativeString(oldFile))
-        );
+        Logger.d("Check for loader classes in dex: %s", dexName);
 
         try {
             excludedClassModifiedChecker.checkIfExcludedClassWasModifiedInNewDex(oldFile, newFile);
@@ -152,23 +141,21 @@ public boolean patch(final File oldFile, final File newFile) throws IOException,
 
         File dexDiffOut = getOutputPath(newFile).toFile();
 
-        final String newMd5 = MD5.getMD5(newFile);
+        final String newMd5 = getRawOrWrappedDexMD5(newFile);
 
         //new add file
         if (oldFile == null || !oldFile.exists() || oldFile.length() == 0) {
             hasDexChanged = true;
-            if (!config.mUsePreGeneratedPatchDex) {
-                copyNewDexAndMarkInMeta(newFile, newMd5, dexDiffOut);
-                return true;
-            }
+            copyNewDexAndLogToDexMeta(newFile, newMd5, dexDiffOut);
+            return true;
         }
 
-        final String oldMd5 = MD5.getMD5(oldFile);
+        final String oldMd5 = getRawOrWrappedDexMD5(oldFile);
 
         if ((oldMd5 != null && !oldMd5.equals(newMd5)) || (oldMd5 == null && newMd5 != null)) {
             hasDexChanged = true;
             if (oldMd5 != null) {
-                checkAddedOrDeletedClasses(oldFile, newFile);
+                collectAddedOrDeletedClasses(oldFile, newFile);
             }
         }
 
@@ -179,7 +166,6 @@ public boolean patch(final File oldFile, final File newFile) throws IOException,
         // collect current old dex file and corresponding new dex file for further processing.
         oldAndNewDexFilePairList.add(new AbstractMap.SimpleEntry<>(oldFile, newFile));
 
-        final String dexName = (oldFile != null ? oldFile.getName() : newFile.getName());
         dexNameToRelatedInfoMap.put(dexName, relatedInfo);
 
         return true;
@@ -192,189 +178,96 @@ public void onAllPatchesEnd() throws Exception {
             return;
         }
 
-        if (config.mUsePreGeneratedPatchDex) {
-            generateStubModePatchDex();
-        } else {
-            generatePatchInfoFile();
-        }
+        generatePatchInfoFile();
+
+        addTestDex();
     }
 
     @SuppressWarnings("NewApi")
-    private void generateStubModePatchDex() throws IOException {
-        List<File> oldDexList = new ArrayList<>();
-        List<File> newDexList = new ArrayList<>();
-        for (AbstractMap.SimpleEntry<File, File> oldAndNewDexFilePair : oldAndNewDexFilePairList) {
-            File oldDexFile = oldAndNewDexFilePair.getKey();
-            File newDexFile = oldAndNewDexFilePair.getValue();
-            if (oldDexFile != null) {
-                oldDexList.add(oldDexFile);
-            }
-            if (newDexFile != null) {
-                newDexList.add(newDexFile);
-            }
-        }
+    private void generatePatchInfoFile() throws IOException {
+        generatePatchedDexInfoFile();
 
-        DexGroup oldDexGroup = DexGroup.wrap(oldDexList);
-        DexGroup newDexGroup = DexGroup.wrap(newDexList);
+        // generateSmallPatchedDexInfoFile is blocked by issue we found in ART environment
+        // which indicates that if inline optimization is done on patched class, some error
+        // such as crash, ClassCastException, mistaken string fetching, etc. would happen.
+        //
+        // Instead, we will log all classN dexes as 'copy directly' in dex-meta, so that
+        // tinker patch applying procedure will copy them out and load them in ART environment.
 
-        SmallDexClassInfoCollector smallDexClassInfoCollector = new SmallDexClassInfoCollector();
-        smallDexClassInfoCollector.setLoaderClassPatterns(config.mDexLoaderPattern);
-        smallDexClassInfoCollector.setLogger(this.dexPatcherLoggerBridge);
+        //generateSmallPatchedDexInfoFile();
 
-        Set<DexClassInfo> classInfosInPatchedDex =
-                smallDexClassInfoCollector.doCollect(oldDexGroup, newDexGroup);
+        logDexesToDexMeta();
 
-        // So far we have got all infos of classes we need to include in stub mode patch dex.
-        // Now construct the stub mode patch dex.
-        final Set<String> classDescsInPatchedDex = new HashSet<>();
-        Set<Dex> newDexes = new HashSet<>();
+        checkCrossDexMovingClasses();
+    }
 
-        DexBuilder dexBuilder = DexBuilder.makeDexBuilder(Opcodes.forApi(15));
+    @SuppressWarnings("NewApi")
+    private void logDexesToDexMeta() throws IOException {
+        Map<String, File> dexNameToClassNOldDexFileMap = new HashMap<>();
+        Set<File> realClassNDexFiles = new HashSet<>();
 
-        for (DexClassInfo classInfo : classInfosInPatchedDex) {
-            classDescsInPatchedDex.add(classInfo.classDesc);
-            newDexes.add(classInfo.owner);
+        for (AbstractMap.SimpleEntry<File, File> oldAndNewDexFilePair : oldAndNewDexFilePairList) {
+            File oldFile = oldAndNewDexFilePair.getKey();
+            final String dexName = getRelativeDexName(oldFile, null);
+            if (isDexNameMatchesClassNPattern(dexName)) {
+                dexNameToClassNOldDexFileMap.put(dexName, oldFile);
+            }
         }
 
-        for (Dex newDex : newDexes) {
-            DexFile dexFile = new DexBackedDexFile(Opcodes.forApi(15), newDex.getBytes());
-            for (org.jf.dexlib2.iface.ClassDef parsedClassDef : dexFile.getClasses()) {
-                if (classDescsInPatchedDex.contains(parsedClassDef.getType())) {
-                    List<BuilderField> builderFields = new ArrayList<>();
-                    for (Field parsedField : parsedClassDef.getFields()) {
-                        BuilderField builderField = dexBuilder.internField(
-                                parsedField.getDefiningClass(),
-                                parsedField.getName(),
-                                parsedField.getType(),
-                                parsedField.getAccessFlags(),
-                                parsedField.getInitialValue(),
-                                parsedField.getAnnotations()
-                        );
-                        builderFields.add(builderField);
-                    }
-                    List<BuilderMethod> builderMethods = new ArrayList<>();
-                    for (Method parsedMethod : parsedClassDef.getMethods()) {
-                        BuilderMethod builderMethod = dexBuilder.internMethod(
-                                parsedMethod.getDefiningClass(),
-                                parsedMethod.getName(),
-                                parsedMethod.getParameters(),
-                                parsedMethod.getReturnType(),
-                                parsedMethod.getAccessFlags(),
-                                parsedMethod.getAnnotations(),
-                                new BuilderMutableMethodImplementation(
-                                        dexBuilder, parsedMethod.getImplementation()
-                                )
-                        );
-                        builderMethods.add(builderMethod);
-                    }
+        // If we meet a case like:
+        // classes.dex, classes2.dex, classes4.dex, classes5.dex
+        // Since classes3.dex is missing, according to the logic in AOSP, we should not treat
+        // rest dexes as part of class N dexes.
+        for (int i = 0; i < dexNameToClassNOldDexFileMap.size(); ++i) {
+            final String expectedDexName = (i == 0 ? DexFormat.DEX_IN_JAR_NAME : "classes" + (i + 1) + ".dex");
+            if (dexNameToClassNOldDexFileMap.containsKey(expectedDexName)) {
+                File oldDexFile = dexNameToClassNOldDexFileMap.get(expectedDexName);
+                realClassNDexFiles.add(oldDexFile);
+            } else {
+                break;
+            }
+        }
 
-                    dexBuilder.internClassDef(
-                            parsedClassDef.getType(),
-                            parsedClassDef.getAccessFlags(),
-                            parsedClassDef.getSuperclass(),
-                            parsedClassDef.getInterfaces(),
-                            parsedClassDef.getSourceFile(),
-                            parsedClassDef.getAnnotations(),
-                            builderFields,
-                            builderMethods
-                    );
+        for (AbstractMap.SimpleEntry<File, File> oldAndNewDexFilePair : oldAndNewDexFilePairList) {
+            final File oldDexFile = oldAndNewDexFilePair.getKey();
+            final File newDexFile = oldAndNewDexFilePair.getValue();
+            final String dexName = getRelativeDexName(oldDexFile, newDexFile);
+            final RelatedInfo relatedInfo = dexNameToRelatedInfoMap.get(dexName);
+            if (!relatedInfo.oldMd5.equals(relatedInfo.newMd5)) {
+                //logToDexMeta(newDexFile, oldDexFile, relatedInfo.dexDiffFile, relatedInfo.newOrFullPatchedMd5, relatedInfo.smallPatchedMd5, relatedInfo.dexDiffMd5);
+                logToDexMeta(newDexFile, oldDexFile, relatedInfo.dexDiffFile, relatedInfo.newOrFullPatchedMd5, relatedInfo.newOrFullPatchedMd5, relatedInfo.dexDiffMd5);
+            } else {
+                // For class N dexes, if new dex is the same as old dex, we should log it as 'copy directly'
+                // in dex meta to fix problems in Art environment.
+                if (realClassNDexFiles.contains(oldDexFile)) {
+                    //if (!"0".equals(relatedInfo.smallPatchedMd5)) {
+                    //    logToDexMeta(newDexFile, oldDexFile, null, "0", relatedInfo.smallPatchedMd5, "0");
+                    //}
+
+                    // Bugfix: However, if what we would copy directly is main dex, we should do an additional diff operation
+                    // so that patch applier would help us remove all loader classes of it in runtime.
+                    if (dexName.equals(DexFormat.DEX_IN_JAR_NAME)) {
+                        Logger.d("\nDo additional diff on main dex to remove loader classes in it.");
+                        diffDexPairAndFillRelatedInfo(oldDexFile, newDexFile, relatedInfo);
+                        logToDexMeta(newDexFile, oldDexFile, relatedInfo.dexDiffFile, relatedInfo.newOrFullPatchedMd5, relatedInfo.newOrFullPatchedMd5, relatedInfo.dexDiffMd5);
+                    } else {
+                        logToDexMeta(newDexFile, oldDexFile, null, "0", relatedInfo.oldMd5, "0");
+                    }
                 }
             }
         }
-
-        // Write constructed stub mode patch dex to file and record it in meta file.
-        final String dexMode = config.mDexRaw ? "raw" : "jar";
-        final File dest = new File(config.mTempResultDir + "/" + PREGENERATED_PATCH_DEX_NAME);
-
-        FileDataStore fileDataStore = new FileDataStore(dest);
-        dexBuilder.writeTo(fileDataStore);
-
-        final File tempPreGeneratedPatchDexPath = new File(config.mOutFolder + File.separator + TypedValue.DEX_TEMP_PATCH_DIR + File.separator + "pre-generated");
-        ensureDirectoryExist(tempPreGeneratedPatchDexPath);
-        Files.copy(dest, new File(tempPreGeneratedPatchDexPath, PREGENERATED_PATCH_DEX_NAME));
-
-        final String md5 = MD5.getMD5(dest);
-
-        String meta = PREGENERATED_PATCH_DEX_NAME + "," + "" + "," + md5 + "," + md5 + "," + 0
-                        + "," + 0 + "," + dexMode;
-
-        Logger.d("\nPre-generated patch dex: %s, size:%d", dest.getAbsolutePath(), dest.length());
-        Logger.d("DexDecoder:write pre-generated patch dex meta file data: %s", meta);
-
-        metaWriter.writeLineToInfoFile(meta);
-
-        addTestDex();
     }
 
     @SuppressWarnings("NewApi")
-    private void generatePatchInfoFile() throws IOException {
-        File tempFullPatchDexPath = new File(config.mOutFolder + File.separator + TypedValue.DEX_TEMP_PATCH_DIR + File.separator + "dalvik");
-        ensureDirectoryExist(tempFullPatchDexPath);
-        File tempSmallPatchDexPath = new File(config.mOutFolder + File.separator + TypedValue.DEX_TEMP_PATCH_DIR + File.separator + "art");
-        ensureDirectoryExist(tempSmallPatchDexPath);
-
+    private void generatePatchedDexInfoFile() {
         // Generate dex diff out and full patched dex if a pair of dex is different.
         for (AbstractMap.SimpleEntry<File, File> oldAndNewDexFilePair : oldAndNewDexFilePairList) {
             File oldFile = oldAndNewDexFilePair.getKey();
             File newFile = oldAndNewDexFilePair.getValue();
-            final String dexName = oldFile.getName();
+            final String dexName = getRelativeDexName(oldFile, newFile);
             RelatedInfo relatedInfo = dexNameToRelatedInfoMap.get(dexName);
-
             if (!relatedInfo.oldMd5.equals(relatedInfo.newMd5)) {
-                File dexDiffOut = getOutputPath(newFile).toFile();
-                ensureDirectoryExist(dexDiffOut.getParentFile());
-
-                try {
-                    DexPatchGenerator dexPatchGen = new DexPatchGenerator(oldFile, newFile);
-                    dexPatchGen.setAdditionalRemovingClassPatterns(config.mDexLoaderPattern);
-
-                    logWriter.writeLineToInfoFile(
-                            String.format(
-                                    "Start diff between [%s] as old and [%s] as new:",
-                                    getRelativeStringBy(oldFile, config.mTempUnzipOldDir),
-                                    getRelativeStringBy(newFile, config.mTempUnzipNewDir)
-                            )
-                    );
-
-                    dexPatchGen.executeAndSaveTo(dexDiffOut);
-                } catch (Exception e) {
-                    throw new TinkerPatchException(e);
-                }
-
-                if (!dexDiffOut.exists()) {
-                    throw new TinkerPatchException("can not find the diff file:" + dexDiffOut.getAbsolutePath());
-                }
-
-                relatedInfo.dexDiffFile = dexDiffOut;
-                relatedInfo.dexDiffMd5 = MD5.getMD5(dexDiffOut);
-                Logger.d("\nGen %s patch file:%s, size:%d, md5:%s", dexName, relatedInfo.dexDiffFile.getAbsolutePath(), relatedInfo.dexDiffFile.length(), relatedInfo.dexDiffMd5);
-
-                File tempFullPatchedDexFile = new File(tempFullPatchDexPath, dexName);
-
-                try {
-                    new DexPatchApplier(oldFile, dexDiffOut).executeAndSaveTo(tempFullPatchedDexFile);
-
-                    Logger.d(
-                            String.format("Verifying if patched new dex is logically the same as original new dex: %s ...", getRelativeStringBy(newFile, config.mTempUnzipNewDir))
-                    );
-
-                    Dex origNewDex = new Dex(newFile);
-                    Dex patchedNewDex = new Dex(tempFullPatchedDexFile);
-                    checkDexChange(origNewDex, patchedNewDex);
-
-                    relatedInfo.newOrFullPatchedFile = tempFullPatchedDexFile;
-                    relatedInfo.newOrFullPatchedMd5 = MD5.getMD5(tempFullPatchedDexFile);
-                } catch (Exception e) {
-                    e.printStackTrace();
-                    throw new TinkerPatchException(
-                            "Failed to generate temporary patched dex, which makes MD5 generating procedure of new dex failed, either.", e
-                    );
-                }
-
-                if (!tempFullPatchedDexFile.exists()) {
-                    throw new TinkerPatchException("can not find the temporary full patched dex file:" + tempFullPatchedDexFile.getAbsolutePath());
-                }
-                Logger.d("\nGen %s for dalvik full dex file:%s, size:%d, md5:%s", dexName, tempFullPatchedDexFile.getAbsolutePath(), tempFullPatchedDexFile.length(), relatedInfo.newOrFullPatchedMd5);
+                diffDexPairAndFillRelatedInfo(oldFile, newFile, relatedInfo);
             } else {
                 // In this case newDexFile is the same as oldDexFile, but we still
                 // need to treat it as patched dex file so that the SmallPatchGenerator
@@ -383,129 +276,93 @@ private void generatePatchInfoFile() throws IOException {
                 relatedInfo.newOrFullPatchedMd5 = relatedInfo.newMd5;
             }
         }
+    }
 
-        Set<File> classNOldDexFiles = new HashSet<>();
+    private void diffDexPairAndFillRelatedInfo(File oldDexFile, File newDexFile, RelatedInfo relatedInfo) {
+        File tempFullPatchDexPath = new File(config.mOutFolder + File.separator + TypedValue.DEX_TEMP_PATCH_DIR + File.separator + "full");
+        final String dexName = getRelativeDexName(oldDexFile, newDexFile);
 
-        for (AbstractMap.SimpleEntry<File, File> oldAndNewDexFilePair : oldAndNewDexFilePairList) {
-            File oldFile = oldAndNewDexFilePair.getKey();
-            final String dexName = oldFile.getName();
+        File dexDiffOut = getOutputPath(newDexFile).toFile();
+        ensureDirectoryExist(dexDiffOut.getParentFile());
 
-            if (isDexNameMatchesClassNPattern(dexName)) {
-                classNOldDexFiles.add(oldFile);
-            }
-        }
+        try {
+            DexPatchGenerator dexPatchGen = new DexPatchGenerator(oldDexFile, newDexFile);
+            dexPatchGen.setAdditionalRemovingClassPatterns(config.mDexLoaderPattern);
+
+            logWriter.writeLineToInfoFile(
+                    String.format(
+                            "Start diff between [%s] as old and [%s] as new:",
+                            getRelativeStringBy(oldDexFile, config.mTempUnzipOldDir),
+                            getRelativeStringBy(newDexFile, config.mTempUnzipNewDir)
+                    )
+            );
 
-        // If we meet a case like:
-        // classes.dex, classes2.dex, classes4.dex, classes5.dex
-        // Since classes3.dex is missing, according to the logic in AOSP, we should not treat
-        // rest dexes as part of class N dexes.
-        Map<String, File> dexNameToClassNOldDexFileMap = new HashMap<>();
-        for (File classNOldDex : classNOldDexFiles) {
-            dexNameToClassNOldDexFileMap.put(classNOldDex.getName(), classNOldDex);
+            dexPatchGen.executeAndSaveTo(dexDiffOut);
+        } catch (Exception e) {
+            throw new TinkerPatchException(e);
         }
 
-        boolean isRestDexNotInClassN = false;
-        for (int i = 0; i < classNOldDexFiles.size(); ++i) {
-            final String expectedDexName = (i == 0 ? DexFormat.DEX_IN_JAR_NAME : "classes" + (i + 1) + ".dex");
-            if (!dexNameToClassNOldDexFileMap.containsKey(expectedDexName)) {
-                isRestDexNotInClassN = true;
-            } else {
-                if (isRestDexNotInClassN) {
-                    File mistakenClassNOldDexFile = dexNameToClassNOldDexFileMap.get(expectedDexName);
-                    classNOldDexFiles.remove(mistakenClassNOldDexFile);
-                }
-            }
+        if (!dexDiffOut.exists()) {
+            throw new TinkerPatchException("can not find the diff file:" + dexDiffOut.getAbsolutePath());
         }
 
-        File tempSmallPatchInfoFile = new File(config.mTempResultDir, TypedValue.DEX_SMALLPATCH_INFO_FILE);
-        ensureDirectoryExist(tempSmallPatchInfoFile.getParentFile());
-
-        // So far we know whether a pair of dex is belong to class N dexes or other dexes.
-        // Then we collect class N dex pairs and other dex pairs by separate their old dex
-        // and full patched dex into different list.
-        SmallDexPatchGenerator smallDexPatchGenerator = new SmallDexPatchGenerator();
-        smallDexPatchGenerator.setLoaderClassPatterns(config.mDexLoaderPattern);
-        smallDexPatchGenerator.setLogger(dexPatcherLoggerBridge);
+        relatedInfo.dexDiffFile = dexDiffOut;
+        relatedInfo.dexDiffMd5 = MD5.getMD5(dexDiffOut);
+        Logger.d("\nGen %s patch file:%s, size:%d, md5:%s", dexName, relatedInfo.dexDiffFile.getAbsolutePath(), relatedInfo.dexDiffFile.length(), relatedInfo.dexDiffMd5);
 
-        logWriter.writeLineToInfoFile("\nStart collecting old dex and full patched dex...");
-
-        List<File> classNOldDexFileList = new ArrayList<>();
-        List<File> classNFullPatchedDexFileList = new ArrayList<>();
-        List<File> otherOldDexFileList = new ArrayList<>();
-        List<File> otherFullPatchedDexFileList = new ArrayList<>();
-        for (AbstractMap.SimpleEntry<File, File> oldAndNewDexFilePair : oldAndNewDexFilePairList) {
-            File oldFile = oldAndNewDexFilePair.getKey();
-            final String dexName = oldFile.getName();
-            File fullPatchedFile = dexNameToRelatedInfoMap.get(dexName).newOrFullPatchedFile;
-            if (classNOldDexFiles.contains(oldFile)) {
-                classNOldDexFileList.add(oldFile);
-                classNFullPatchedDexFileList.add(fullPatchedFile);
-            } else {
-                otherOldDexFileList.add(oldFile);
-                otherFullPatchedDexFileList.add(fullPatchedFile);
-            }
+        File tempFullPatchedDexFile = new File(tempFullPatchDexPath, dexName);
+        if (!tempFullPatchedDexFile.exists()) {
+            ensureDirectoryExist(tempFullPatchedDexFile.getParentFile());
         }
 
-        logWriter.writeLineToInfoFile(String.format("\nCollected class N old dexes: %s", classNOldDexFileList));
-        logWriter.writeLineToInfoFile(String.format("Collected class N full patched dexes: %s", classNFullPatchedDexFileList));
-        logWriter.writeLineToInfoFile(String.format("\nCollected other old dexes: %s", otherOldDexFileList));
-        logWriter.writeLineToInfoFile(String.format("Collected other full patched dexes: %s", otherFullPatchedDexFileList));
+        try {
+            new DexPatchApplier(oldDexFile, dexDiffOut).executeAndSaveTo(tempFullPatchedDexFile);
 
-        smallDexPatchGenerator.appendDexGroup(DexGroup.wrap(classNOldDexFileList), DexGroup.wrap(classNFullPatchedDexFileList));
+            Logger.d(
+                    String.format("Verifying if patched new dex is logically the same as original new dex: %s ...", getRelativeStringBy(newDexFile, config.mTempUnzipNewDir))
+            );
 
-        if (!otherOldDexFileList.isEmpty()) {
-            smallDexPatchGenerator.appendDexGroup(DexGroup.wrap(otherOldDexFileList), DexGroup.wrap(otherFullPatchedDexFileList));
-        }
+            Dex origNewDex = new Dex(newDexFile);
+            Dex patchedNewDex = new Dex(tempFullPatchedDexFile);
+            checkDexChange(origNewDex, patchedNewDex);
 
-        try {
-            Logger.d("Start generating small patch info file...");
-            smallDexPatchGenerator.executeAndSaveTo(tempSmallPatchInfoFile);
+            relatedInfo.newOrFullPatchedFile = tempFullPatchedDexFile;
+            relatedInfo.newOrFullPatchedMd5 = MD5.getMD5(tempFullPatchedDexFile);
         } catch (Exception e) {
-            throw new TinkerPatchException("\nFailed to generate small patch info file.", e);
+            e.printStackTrace();
+            throw new TinkerPatchException(
+                    "Failed to generate temporary patched dex, which makes MD5 generating procedure of new dex failed, either.", e
+            );
         }
-        if (!tempSmallPatchInfoFile.exists()) {
-            throw new TinkerPatchException("can not find the small patch info file:" + tempSmallPatchInfoFile.getAbsolutePath());
+
+        if (!tempFullPatchedDexFile.exists()) {
+            throw new TinkerPatchException("can not find the temporary full patched dex file:" + tempFullPatchedDexFile.getAbsolutePath());
         }
+        Logger.d("\nGen %s for dalvik full dex file:%s, size:%d, md5:%s", dexName, tempFullPatchedDexFile.getAbsolutePath(), tempFullPatchedDexFile.length(), relatedInfo.newOrFullPatchedMd5);
+    }
 
-        SmallPatchedDexItemFile smallPatchedDexItemFile = new SmallPatchedDexItemFile(tempSmallPatchInfoFile);
+    private void addTestDex() throws IOException {
+        //write test dex
+        String dexMode = "jar";
+        if (config.mDexRaw) {
+            dexMode = "raw";
+        }
 
-        // Generate small patched dex and write meta.
-        for (AbstractMap.SimpleEntry<File, File> oldAndNewDexFilePair : oldAndNewDexFilePairList) {
-            File oldFile = oldAndNewDexFilePair.getKey();
-            File newFile = oldAndNewDexFilePair.getValue();
-            final String dexName = oldFile.getName();
-            final String oldDexSignStr = Hex.toHexString(new Dex(oldFile).computeSignature(false));
-            File tempSmallPatchedFile = new File(tempSmallPatchDexPath, dexName);
-            RelatedInfo relatedInfo = dexNameToRelatedInfoMap.get(dexName);
-            File dexDiffFile = relatedInfo.dexDiffFile;
+        final InputStream is = DexDiffDecoder.class.getResourceAsStream("/" + TEST_DEX_NAME);
+        String md5 = MD5.getMD5(is, 1024);
+        is.close();
 
-            if (!smallPatchedDexItemFile.isSmallPatchedDexEmpty(oldDexSignStr)) {
-                try {
-                    new DexPatchApplier(oldFile, dexDiffFile, smallPatchedDexItemFile).executeAndSaveTo(tempSmallPatchedFile);
-                } catch (Exception e) {
-                    e.printStackTrace();
-                    throw new TinkerPatchException(
-                            "Failed to generate temporary small patched dex, which makes MD5 generating procedure of small patched dex failed, either.", e
-                    );
-                }
-                if (!tempSmallPatchedFile.exists()) {
-                    throw new TinkerPatchException("can not find the temporary small patched dex file:" + tempSmallPatchInfoFile.getAbsolutePath());
-                }
-                relatedInfo.smallPatchedMd5 = MD5.getMD5(tempSmallPatchedFile);
-                Logger.d("\nGen %s for art small dex file:%s, size:%d, md5:%s", dexName, tempSmallPatchedFile.getAbsolutePath(), tempSmallPatchedFile.length(), relatedInfo.smallPatchedMd5);
-
-                if (relatedInfo.oldMd5.equals(relatedInfo.newMd5)) {
-                    // Unmodified dex, which has no dexDiffFile, and is ignored in dvm environment.
-                    // So we pass zero string to destMd5InDvm and dexDiffMd5.
-                    writeLogFiles(newFile, oldFile, relatedInfo.dexDiffFile, "0", relatedInfo.smallPatchedMd5, "0");
-                } else {
-                    writeLogFiles(newFile, oldFile, relatedInfo.dexDiffFile, relatedInfo.newOrFullPatchedMd5, relatedInfo.smallPatchedMd5, relatedInfo.dexDiffMd5);
-                }
-            }
-        }
+        String meta = TEST_DEX_NAME + "," + "" + "," + md5 + "," + md5 + "," + 0 + "," + 0 + "," + dexMode;
 
-        addTestDex();
+        File dest = new File(config.mTempResultDir + "/" + TEST_DEX_NAME);
+        FileOperation.copyResourceUsingStream(TEST_DEX_NAME, dest);
+        Logger.d("\nAdd test install result dex: %s, size:%d", dest.getAbsolutePath(), dest.length());
+        Logger.d("DexDecoder:write test dex meta file data: %s", meta);
 
+        metaWriter.writeLineToInfoFile(meta);
+    }
+
+    private void checkCrossDexMovingClasses() {
         // Here we will check if any classes that were deleted in one dex
         // would be added to another dex. e.g. classA is deleted in dex0 and
         // added in dex1.
@@ -535,33 +392,11 @@ private void generatePatchInfoFile() throws IOException {
         }
     }
 
-    @Override
-    public void clean() {
-        metaWriter.close();
-        logWriter.close();
-    }
-
-    private void ensureDirectoryExist(File dir) {
-        if (!dir.exists()) {
-            if (!dir.mkdirs()) {
-                throw new TinkerPatchException("failed to create directory: " + dir);
-            }
-        }
-    }
-
-    private boolean isDexNameMatchesClassNPattern(String dexName) {
-        return (dexName.matches("^classes[0-9]*\\.dex$"));
-    }
-
-    private void copyNewDexAndMarkInMeta(File newFile, String newMd5, File output) throws IOException {
-        newMd5 = checkNewDexAndMd5(newMd5, newFile);
-        FileOperation.copyFileUsingStream(newFile, output);
-        writeLogFiles(newFile, null, null, newMd5, newMd5, "0");
-    }
-
-    private void checkAddedOrDeletedClasses(File oldFile, File newFile) throws IOException {
-        // Before starting real diff works, we collect added class descriptor
-        // and deleted class descriptor for further analysing.
+    /**
+     * Before starting real diff works, we collect added class descriptor
+     * and deleted class descriptor for further analysing in {@code checkCrossDexMovingClasses}.
+     */
+    private void collectAddedOrDeletedClasses(File oldFile, File newFile) throws IOException {
         Dex oldDex = new Dex(oldFile);
         Dex newDex = new Dex(newFile);
 
@@ -612,6 +447,15 @@ private void checkAddedOrDeletedClasses(File oldFile, File newFile) throws IOExc
         }
     }
 
+    private boolean isDexNameMatchesClassNPattern(String dexName) {
+        return (dexName.matches("^classes[0-9]*\\.dex$"));
+    }
+
+    private void copyNewDexAndLogToDexMeta(File newFile, String newMd5, File output) throws IOException {
+        FileOperation.copyFileUsingStream(newFile, output);
+        logToDexMeta(newFile, null, null, newMd5, newMd5, "0");
+    }
+
     private void checkDexChange(Dex originDex, Dex newDex) {
         DexClassesComparator classesCmptor = new DexClassesComparator("*");
         classesCmptor.setIgnoredRemovedClassDescPattern(config.mDexLoaderPattern);
@@ -652,59 +496,6 @@ private void checkDexChange(Dex originDex, Dex newDex) {
         }
     }
 
-    private void addTestDex() throws IOException {
-        //write test dex
-        String dexMode = "jar";
-        if (config.mDexRaw) {
-            dexMode = "raw";
-        }
-
-        final InputStream is = DexDiffDecoder.class.getResourceAsStream("/" + TEST_DEX_NAME);
-        String md5 = MD5.getMD5(is, 1024);
-        is.close();
-
-        String meta = TEST_DEX_NAME + "," + "" + "," + md5 + "," + md5 + "," + 0 + "," + 0 + "," + dexMode;
-
-        File dest = new File(config.mTempResultDir + "/" + TEST_DEX_NAME);
-        FileOperation.copyResourceUsingStream(TEST_DEX_NAME, dest);
-        Logger.d("\nAdd test install result dex: %s, size:%d", dest.getAbsolutePath(), dest.length());
-        Logger.d("DexDecoder:write test dex meta file data: %s", meta);
-
-        metaWriter.writeLineToInfoFile(meta);
-    }
-
-    private String checkNewDexAndMd5(String md5, File dexFile) {
-        String name = dexFile.getName();
-        if (name.endsWith(".dex")) {
-            return md5;
-        } else {
-            try {
-                final JarFile dexJar = new JarFile(dexFile);
-                ZipEntry classesDex = dexJar.getEntry(DexFormat.DEX_IN_JAR_NAME);
-                // no code
-                if (null == classesDex) {
-                    throw new TinkerPatchException(
-                        String.format("dex jar file %s do not contain 'classes.dex', it is not a correct dex jar file!", dexFile.getAbsolutePath())
-                    );
-                }
-
-                return MD5.getMD5(dexJar.getInputStream(classesDex), 1024 * 100);
-            } catch (IOException e) {
-                throw new TinkerPatchException(
-                    String.format("dex file %s is not end with '.dex', but it is not a correct dex jar file also!", dexFile.getAbsolutePath()), e
-                );
-            }
-        }
-    }
-
-    private String getRelativeStringBy(File file, File reference) {
-        File actualReference = reference.getParentFile();
-        if (actualReference == null) {
-            actualReference = reference;
-        }
-        return actualReference.toPath().relativize(file.toPath()).toString().replace("\\", "/");
-    }
-
     /**
      * Construct dex meta-info and write it to meta file and log.
      *
@@ -723,12 +514,12 @@ private String getRelativeStringBy(File file, File reference) {
      *
      * @throws IOException
      */
-    protected void writeLogFiles(File newOrFullPatchedFile, File oldFile, File dexDiffFile, String destMd5InDvm, String destMd5InArt, String dexDiffMd5) throws IOException {
+    protected void logToDexMeta(File newOrFullPatchedFile, File oldFile, File dexDiffFile, String destMd5InDvm, String destMd5InArt, String dexDiffMd5) throws IOException {
         if (metaWriter == null && logWriter == null) {
             return;
         }
-        String parentRelative = getParentRelativeString(newOrFullPatchedFile);
-        String relative = getRelativeString(newOrFullPatchedFile);
+        String parentRelative = getParentRelativePathStringToNewFile(newOrFullPatchedFile);
+        String relative = getRelativePathStringToNewFile(newOrFullPatchedFile);
 
         if (metaWriter != null) {
             String fileName = newOrFullPatchedFile.getName();
@@ -765,6 +556,60 @@ protected void writeLogFiles(File newOrFullPatchedFile, File oldFile, File dexDi
         }
     }
 
+    @Override
+    public void clean() {
+        metaWriter.close();
+        logWriter.close();
+    }
+
+    private String getRawOrWrappedDexMD5(File dexOrJarFile) {
+        final String name = dexOrJarFile.getName();
+        if (name.endsWith(".dex")) {
+            return MD5.getMD5(dexOrJarFile);
+        } else {
+            JarFile dexJar = null;
+            try {
+                dexJar = new JarFile(dexOrJarFile);
+                ZipEntry classesDex = dexJar.getEntry(DexFormat.DEX_IN_JAR_NAME);
+                // no code
+                if (classesDex == null) {
+                    throw new TinkerPatchException(
+                            String.format("Jar file %s do not contain 'classes.dex', it is not a correct dex jar file!", dexOrJarFile.getAbsolutePath())
+                    );
+                }
+                return MD5.getMD5(dexJar.getInputStream(classesDex), 1024 * 100);
+            } catch (IOException e) {
+                throw new TinkerPatchException(
+                        String.format("File %s is not end with '.dex', but it is not a correct dex jar file !", dexOrJarFile.getAbsolutePath()), e
+                );
+            } finally {
+                if (dexJar != null) {
+                    try {
+                        dexJar.close();
+                    } catch (Exception e) {
+                        // Ignored.
+                    }
+                }
+            }
+        }
+    }
+
+    private String getRelativeStringBy(File file, File reference) {
+        File actualReference = reference.getParentFile();
+        if (actualReference == null) {
+            actualReference = reference;
+        }
+        return actualReference.toPath().relativize(file.toPath()).toString().replace("\\", "/");
+    }
+
+    private void ensureDirectoryExist(File dir) {
+        if (!dir.exists()) {
+            if (!dir.mkdirs()) {
+                throw new TinkerPatchException("failed to create directory: " + dir);
+            }
+        }
+    }
+
     private final class RelatedInfo {
         File newOrFullPatchedFile = null;
         /**
@@ -781,39 +626,38 @@ protected void writeLogFiles(File newOrFullPatchedFile, File oldFile, File dexDi
          *  newDex md5, if new dex is marked to be copied directly;
          */
         String newOrFullPatchedMd5 = "0";
-        String smallPatchedMd5 = "0";
     }
 
     private final class DexPatcherLoggerBridge implements IDexPatcherLogger {
-        private final InfoWriter logWritter;
+        private final InfoWriter logWriter;
 
         DexPatcherLoggerBridge(InfoWriter logWritter) {
-            this.logWritter = logWritter;
+            this.logWriter = logWritter;
         }
 
         @Override
         public void v(String msg) {
-            this.logWritter.writeLineToInfoFile(msg);
+            this.logWriter.writeLineToInfoFile(msg);
         }
 
         @Override
         public void d(String msg) {
-            this.logWritter.writeLineToInfoFile(msg);
+            this.logWriter.writeLineToInfoFile(msg);
         }
 
         @Override
         public void i(String msg) {
-            this.logWritter.writeLineToInfoFile(msg);
+            this.logWriter.writeLineToInfoFile(msg);
         }
 
         @Override
         public void w(String msg) {
-            this.logWritter.writeLineToInfoFile(msg);
+            this.logWriter.writeLineToInfoFile(msg);
         }
 
         @Override
         public void e(String msg) {
-            this.logWritter.writeLineToInfoFile(msg);
+            this.logWriter.writeLineToInfoFile(msg);
         }
     }
 }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ResDiffDecoder.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ResDiffDecoder.java
index 01d3ce8c..d5c82b75 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ResDiffDecoder.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ResDiffDecoder.java
@@ -42,6 +42,8 @@
  * Created by zhangshaowen on 16/8/8.
  */
 public class ResDiffDecoder extends BaseDecoder {
+    private static final String TEST_RESOURCE_NAME        = "only_use_to_test_tinker_resource.txt";
+    private static final String TEST_RESOURCE_ASSETS_PATH = "assets/" + TEST_RESOURCE_NAME;
 
     private static final String TEMP_RES_ZIP  = "temp_res.zip";
     private static final String TEMP_RES_7ZIP = "temp_res_7ZIP.zip";
@@ -53,11 +55,6 @@
     private       HashMap<String, LargeModeInfo> largeModifiedMap;
     private ArrayList<String> deletedSet;
 
-    private boolean arscChanged;
-    private File oldArscFile;
-    private File newArscFile;
-
-
     public ResDiffDecoder(Configuration config, String metaPath, String logPath) throws IOException {
         super(config);
 
@@ -95,14 +92,11 @@ private boolean checkLargeModFile(File file) {
 
     @Override
     public boolean patch(File oldFile, File newFile) throws IOException, TinkerPatchException {
-        String name = getRelativeString(newFile);
-        if (name.equals(TypedValue.RES_ARSC)) {
-            oldArscFile = oldFile;
-            newArscFile = newFile;
-        }
+        String name = getRelativePathStringToNewFile(newFile);
+
         //actually, it won't go below
         if (newFile == null || !newFile.exists()) {
-            String relativeStringByOldDir = getRelativeStringByOldDir(oldFile);
+            String relativeStringByOldDir = getRelativePathStringToOldFile(oldFile);
             if (Utils.checkFileInPattern(config.mResIgnoreChangePattern, relativeStringByOldDir)) {
                 Logger.e("found delete resource: " + relativeStringByOldDir + " ,but it match ignore change pattern, just ignore!");
                 return false;
@@ -149,9 +143,6 @@ public boolean patch(File oldFile, File newFile) throws IOException, TinkerPatch
                 Logger.d("found modify resource: " + name + ", but it is logically the same as original new resources.arsc, just ignore!");
                 return false;
             }
-            //deal with resources.arsc later
-            arscChanged = true;
-            return true;
         }
         dealWithModeFile(name, newMd5, oldFile, newFile, outputFile);
         return true;
@@ -187,25 +178,25 @@ private void writeResLog(File newFile, File oldFile, int mode) throws IOExceptio
             String relative;
             switch (mode) {
                 case TypedValue.ADD:
-                    relative = getRelativeString(newFile);
+                    relative = getRelativePathStringToNewFile(newFile);
                     Logger.d("Found add resource: " + relative);
                     log = "add resource: " + relative + ", oldSize=" + FileOperation.getFileSizes(oldFile) + ", newSize="
                         + FileOperation.getFileSizes(newFile);
                     break;
                 case TypedValue.MOD:
-                    relative = getRelativeString(newFile);
+                    relative = getRelativePathStringToNewFile(newFile);
                     Logger.d("Found modify resource: " + relative);
                     log = "modify resource: " + relative + ", oldSize=" + FileOperation.getFileSizes(oldFile) + ", newSize="
                         + FileOperation.getFileSizes(newFile);
                     break;
                 case TypedValue.DEL:
-                    relative = getRelativeStringByOldDir(oldFile);
+                    relative = getRelativePathStringToOldFile(oldFile);
                     Logger.d("Found deleted resource: " + relative);
                     log = "deleted resource: " + relative + ", oldSize=" + FileOperation.getFileSizes(oldFile) + ", newSize="
                         + FileOperation.getFileSizes(newFile);
                     break;
                 case TypedValue.LARGE_MOD:
-                    relative = getRelativeString(newFile);
+                    relative = getRelativePathStringToNewFile(newFile);
                     Logger.d("Found large modify resource: " + relative + " size:" + newFile.length());
                     log = "large modify resource: " + relative + ", oldSize=" + FileOperation.getFileSizes(oldFile) + ", newSize="
                         + FileOperation.getFileSizes(newFile);
@@ -220,18 +211,20 @@ public void onAllPatchesStart() throws IOException, TinkerPatchException {
 
     }
 
-    private void modArscFileForTestResource() throws IOException {
-        File tempArscFile = new File(config.mOutFolder + File.separator + "edited_resources.arsc");
-        //there is resource changed, edit test resource string
-        AndroidParser.editResourceTableString(TypedValue.TEST_STRING_VALUE_A, TypedValue.TEST_STRING_VALUE_B, newArscFile, tempArscFile);
-        dealWithModeFile(TypedValue.RES_ARSC, MD5.getMD5(tempArscFile), oldArscFile, tempArscFile, getOutputPath(newArscFile).toFile());
-        Logger.d("Edit resources.arsc file for test resource change, final path: " + tempArscFile.getAbsolutePath());
+    private void addAssetsFileForTestResource() throws IOException {
+        File dest = new File(config.mTempResultDir + "/" + TEST_RESOURCE_ASSETS_PATH);
+        FileOperation.copyResourceUsingStream(TEST_RESOURCE_NAME, dest);
+        addedSet.add(TEST_RESOURCE_ASSETS_PATH);
+        Logger.d("Add Test resource file: " + TEST_RESOURCE_ASSETS_PATH);
+        String log = "add test resource: " + TEST_RESOURCE_ASSETS_PATH + ", oldSize=" + 0 + ", newSize="
+            + FileOperation.getFileSizes(dest);
+        logWriter.writeLineToInfoFile(log);
     }
 
     @Override
     public void onAllPatchesEnd() throws IOException, TinkerPatchException {
         //only there is only deleted set, we just ignore
-        if (addedSet.isEmpty() && modifiedSet.isEmpty() && largeModifiedSet.isEmpty() && !arscChanged) {
+        if (addedSet.isEmpty() && modifiedSet.isEmpty() && largeModifiedSet.isEmpty()) {
             return;
         }
 
@@ -242,12 +235,12 @@ public void onAllPatchesEnd() throws IOException, TinkerPatchException {
             throw new TinkerPatchException("resource must contain AndroidManifest.xml pattern");
         }
 
-        modArscFileForTestResource();
-
         //check gradle build
         if (config.mUsingGradle) {
             final boolean ignoreWarning = config.mIgnoreWarning;
-            if (arscChanged && !config.mUseApplyResource) {
+            final boolean resourceArscChanged = modifiedSet.contains(TypedValue.RES_ARSC)
+                || largeModifiedSet.contains(TypedValue.RES_ARSC);
+            if (resourceArscChanged && !config.mUseApplyResource) {
                 if (ignoreWarning) {
                     //ignoreWarning, just log
                     Logger.e("Warning:ignoreWarning is true, but resources.arsc is changed, you should use applyResourceMapping mode to build the new apk, otherwise, it may be crash at some times");
@@ -279,6 +272,9 @@ public void onAllPatchesEnd() throws IOException, TinkerPatchException {
         removeIgnoreChangeFile(addedSet);
         removeIgnoreChangeFile(largeModifiedSet);
 
+        // last add test res in assets for user cannot ignore it;
+        addAssetsFileForTestResource();
+
         File tempResZip = new File(config.mOutFolder + File.separator + TEMP_RES_ZIP);
         final File tempResFiles = config.mTempResultDir;
 
@@ -426,7 +422,7 @@ public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IO
             if (Utils.checkFileInPattern(config.mResFilePattern, patternKey)) {
                 //not contain in new path, is deleted
                 if (!newPath.toFile().exists()) {
-                    deletedFiles.add(relativePath.toString());
+                    deletedFiles.add(patternKey);
                     writeResLog(newPath.toFile(), file.toFile(), TypedValue.DEL);
                 }
                 return FileVisitResult.CONTINUE;
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/UniqueDexDiffDecoder.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/UniqueDexDiffDecoder.java
index 46a61f7c..88258320 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/UniqueDexDiffDecoder.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/UniqueDexDiffDecoder.java
@@ -48,4 +48,4 @@ public boolean patch(File oldFile, File newFile) throws IOException, TinkerPatch
         return added;
     }
 
-}
+}
\ No newline at end of file
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/immutable/ClassSimDef.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/immutable/ClassSimDef.java
new file mode 100644
index 00000000..7d968672
--- /dev/null
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/immutable/ClassSimDef.java
@@ -0,0 +1,103 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.build.immutable;
+
+import org.objectweb.asm.ClassReader;
+import org.objectweb.asm.ClassVisitor;
+import org.objectweb.asm.FieldVisitor;
+import org.objectweb.asm.MethodVisitor;
+import org.objectweb.asm.Opcodes;
+
+import java.util.HashSet;
+
+
+public class ClassSimDef {
+
+    int methodCount;
+    int fieldCount;
+    byte[] bytes;
+    HashSet<String> refFieldSet;
+    HashSet<String> refMtdSet;
+
+    public ClassSimDef(byte[] bytes, HashSet<String> refFieldSet, HashSet<String> refMtdSet) {
+        this.bytes = bytes;
+        this.refFieldSet = refFieldSet;
+        this.refMtdSet = refMtdSet;
+        init();
+    }
+
+    public void init() {
+        methodCount = 0;
+        fieldCount = 0;
+
+        ClassReader cr = new ClassReader(bytes);
+        ClassVisitor cv = new ClassVisitor(Opcodes.ASM4) {
+            String className;
+
+            @Override
+            public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {
+                className = name;
+                super.visit(version, access, name, signature, superName, interfaces);
+            }
+
+            @Override
+            public MethodVisitor visitMethod(int access, String mtdName, String mtdDesc, String mtdSig, String[] exceptions) {
+
+                String defMtd = className + ":" + mtdName + ":" + mtdDesc;
+                if (!refMtdSet.contains(defMtd)) {
+                    refMtdSet.add(defMtd);
+                    methodCount++;
+                }
+
+                MethodVisitor mv = super.visitMethod(access, mtdName, mtdDesc, mtdSig, exceptions);
+                mv = new MethodVisitor(Opcodes.ASM4, mv) {
+                    @Override
+                    public void visitFieldInsn(int opcode, String owner, String fName, String fDesc) {
+                        String invokeField = owner + ":" + fName + ":" + fDesc;
+                        if (!refFieldSet.contains(invokeField)) {
+                            refFieldSet.add(invokeField);
+                            fieldCount++;
+                        }
+                        super.visitFieldInsn(opcode, owner, fName, fDesc);
+                    }
+
+                    @Override
+                    public void visitMethodInsn(int opcode, String owner, String mName, String mDesc) {
+                        String invokeMtd = owner + ":" + mName + ":" + mDesc;
+                        if (!refMtdSet.contains(invokeMtd)) {
+                            refMtdSet.add(invokeMtd);
+                            methodCount++;
+                        }
+                        super.visitMethodInsn(opcode, owner, mName, mDesc);
+                    }
+                };
+                return mv;
+            }
+
+            @Override
+            public FieldVisitor visitField(int access, String name, String desc, String signature, Object value) {
+                String fieldDesc = className + ":" + name + ":" + desc;
+                if (!refFieldSet.contains(fieldDesc)) {
+                    refFieldSet.add(fieldDesc);
+                    fieldCount++;
+                }
+                return super.visitField(access, name, desc, signature, value);
+            }
+        };
+        cr.accept(cv, 0);
+    }
+}
\ No newline at end of file
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/immutable/DexRefData.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/immutable/DexRefData.java
new file mode 100644
index 00000000..a1e342eb
--- /dev/null
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/immutable/DexRefData.java
@@ -0,0 +1,38 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.build.immutable;
+
+import java.util.HashSet;
+import java.util.Set;
+
+public class DexRefData {
+    int methodNum;
+    int fieldNum;
+    public Set<String> refFields;
+    public Set<String> refMtds;
+
+    DexRefData() {
+        this(0, 0);
+    }
+
+    DexRefData(int methodNum, int fieldNum) {
+        this.methodNum = methodNum;
+        this.fieldNum = fieldNum;
+        refFields = new HashSet<>();
+        refMtds = new HashSet<>();
+    }
+}
\ No newline at end of file
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/Configuration.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/Configuration.java
index e1823c93..e61122ff 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/Configuration.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/Configuration.java
@@ -83,7 +83,7 @@
     public File             mOldApkFile;
     public File             mNewApkFile;
     public boolean          mIgnoreWarning;
-    public boolean          mUsePreGeneratedPatchDex;
+
     /**
      * lib config
      */
@@ -214,7 +214,6 @@ public Configuration(InputParam param) throws IOException, TinkerPatchException
         mOutFolder = param.outFolder;
 
         mIgnoreWarning = param.ignoreWarning;
-        mUsePreGeneratedPatchDex = param.usePreGeneratedPatchDex;
 
         mSevenZipPath = param.sevenZipPath;
         mPackageFields = param.configFields;
@@ -237,7 +236,6 @@ public String toString() {
         sb.append("newApk:" + mNewApkPath + "\n");
         sb.append("outputFolder:" + mOutFolder + "\n");
         sb.append("isIgnoreWarning:" + mIgnoreWarning + "\n");
-        sb.append("isInsertStubMode:" + mUsePreGeneratedPatchDex + "\n");
         sb.append("7-ZipPath:" + mSevenZipPath + "\n");
         sb.append("useSignAPk:" + mUseSignAPk + "\n");
 
@@ -303,7 +301,8 @@ private void createTempDirectory() throws TinkerPatchException {
 
         String tempNewName = newApkName.substring(0, newApkName.indexOf(TypedValue.FILE_APK));
 
-        if (tempNewName.equals(tempOldName)) {
+        // Bugfix: For windows user, filename is case-insensitive.
+        if (tempNewName.equalsIgnoreCase(tempOldName)) {
             tempOldName += "-old";
             tempNewName += "-new";
         }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/InputParam.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/InputParam.java
index 348f431a..e56d4eac 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/InputParam.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/InputParam.java
@@ -35,7 +35,6 @@
     public final String  storealias;
     public final String  storepass;
     public final boolean ignoreWarning;
-    public final boolean usePreGeneratedPatchDex;
     public final boolean useSign;
 
     /**
@@ -82,7 +81,6 @@ private InputParam(
         String storealias,
         String storepass,
         boolean ignoreWarning,
-        boolean usePreGeneratedPatchDex,
         boolean useSign,
 
         ArrayList<String> dexFilePattern,
@@ -105,7 +103,6 @@ private InputParam(
         this.storealias = storealias;
         this.storepass = storepass;
         this.ignoreWarning = ignoreWarning;
-        this.usePreGeneratedPatchDex = usePreGeneratedPatchDex;
         this.useSign = useSign;
 
         this.dexFilePattern = dexFilePattern;
@@ -135,7 +132,6 @@ private InputParam(
         private String  storealias;
         private String  storepass;
         private boolean ignoreWarning;
-        private boolean usePreGeneratedPatchDex;
         private boolean useSign;
 
         /**
@@ -247,11 +243,6 @@ public Builder setIgnoreWarning(boolean ignoreWarning) {
             return this;
         }
 
-        public Builder setUsePreGeneratedPatchDex(boolean usePreGeneratedPatchDex) {
-            this.usePreGeneratedPatchDex = usePreGeneratedPatchDex;
-            return this;
-        }
-
         public Builder setDexLoaderPattern(ArrayList<String> dexLoaderPattern) {
             this.dexLoaderPattern = dexLoaderPattern;
             return this;
@@ -287,7 +278,6 @@ public InputParam create() {
                     storealias,
                     storepass,
                     ignoreWarning,
-                    usePreGeneratedPatchDex,
                     useSign,
                     dexFilePattern,
                     dexLoaderPattern,
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/Logger.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/Logger.java
index 1f4d0b25..88a872ad 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/Logger.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/Logger.java
@@ -51,6 +51,7 @@ public static void d(final String format, final Object... obj) {
         }
         //add \n
         System.out.printf(log + "\n");
+        System.out.flush();
 
         logWriter.writeLineToInfoFile(log);
     }
@@ -66,10 +67,15 @@ public static void e(final String format, final Object... obj) {
         }
         //add \n
         System.err.printf(log + "\n");
+<<<<<<< HEAD
         if (logWriter != null) {
             logWriter.writeLineToInfoFile(log);
         }
+=======
+        System.err.flush();
+>>>>>>> Tencent/dev
 
+        logWriter.writeLineToInfoFile(log);
     }
 
 }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/Utils.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/Utils.java
index bcc20917..901f36c0 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/Utils.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/Utils.java
@@ -24,9 +24,12 @@
 import com.tencent.tinker.commons.ziputil.TinkerZipOutputStream;
 
 import java.io.BufferedOutputStream;
+import java.io.BufferedReader;
+import java.io.Closeable;
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
+import java.io.InputStreamReader;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Enumeration;
@@ -210,4 +213,33 @@ public static boolean checkBsDiffFileSize(File bsDiffFile, File newFile) {
         }
         return true;
     }
+
+    public static void closeQuietly(Closeable closeable) {
+        try {
+            if (closeable != null) {
+                closeable.close();
+            }
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static void exec(ArrayList<String> args, File path) throws RuntimeException, IOException, InterruptedException {
+        ProcessBuilder ps = new ProcessBuilder(args);
+        ps.redirectErrorStream(true);
+        if (path != null) {
+            ps.directory(path);
+        }
+        Process pr = ps.start();
+        BufferedReader ins = new BufferedReader(new InputStreamReader(pr.getInputStream()));
+        String line;
+        while ((line = ins.readLine()) != null) {
+            System.out.println(line);
+        }
+        if (pr.waitFor() != 0) {
+            throw new RuntimeException("exec cmd failed! args: " + args);
+        }
+        ins.close();
+    }
+
 }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/org/jf/dexlib2/builder/BuilderMutableMethodImplementation.java b/tinker-build/tinker-patch-lib/src/main/java/org/jf/dexlib2/builder/BuilderMutableMethodImplementation.java
deleted file mode 100644
index 620e5e43..00000000
--- a/tinker-build/tinker-patch-lib/src/main/java/org/jf/dexlib2/builder/BuilderMutableMethodImplementation.java
+++ /dev/null
@@ -1,1142 +0,0 @@
-/*
- * Copyright 2013, Google Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- *     * Redistributions of source code must retain the above copyright
- * notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above
- * copyright notice, this list of conditions and the following disclaimer
- * in the documentation and/or other materials provided with the
- * distribution.
- *     * Neither the name of Google Inc. nor the names of its
- * contributors may be used to endorse or promote products derived from
- * this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/**
- * *** This file is NOT a part of DexLib2 project. ***
- *
- * Tricky ways for converting MethodImplementation in DexFile into the corresponding
- * one in DexBuilder.
- *
- * If you pass null as DexBuilder, this class behavior the same as
- * what {@link org.jf.dexlib2.builder.MutableMethodImplementation} would do.
- */
-
-package org.jf.dexlib2.builder;
-
-import com.google.common.base.Function;
-import com.google.common.collect.Iterables;
-import com.google.common.collect.Lists;
-import com.google.common.collect.Sets;
-
-import org.jf.dexlib2.DebugItemType;
-import org.jf.dexlib2.Opcode;
-import org.jf.dexlib2.builder.debug.BuilderEndLocal;
-import org.jf.dexlib2.builder.debug.BuilderEpilogueBegin;
-import org.jf.dexlib2.builder.debug.BuilderLineNumber;
-import org.jf.dexlib2.builder.debug.BuilderPrologueEnd;
-import org.jf.dexlib2.builder.debug.BuilderRestartLocal;
-import org.jf.dexlib2.builder.debug.BuilderSetSourceFile;
-import org.jf.dexlib2.builder.debug.BuilderStartLocal;
-import org.jf.dexlib2.builder.instruction.BuilderArrayPayload;
-import org.jf.dexlib2.builder.instruction.BuilderInstruction10t;
-import org.jf.dexlib2.builder.instruction.BuilderInstruction10x;
-import org.jf.dexlib2.builder.instruction.BuilderInstruction11n;
-import org.jf.dexlib2.builder.instruction.BuilderInstruction11x;
-import org.jf.dexlib2.builder.instruction.BuilderInstruction12x;
-import org.jf.dexlib2.builder.instruction.BuilderInstruction20bc;
-import org.jf.dexlib2.builder.instruction.BuilderInstruction20t;
-import org.jf.dexlib2.builder.instruction.BuilderInstruction21c;
-import org.jf.dexlib2.builder.instruction.BuilderInstruction21ih;
-import org.jf.dexlib2.builder.instruction.BuilderInstruction21lh;
-import org.jf.dexlib2.builder.instruction.BuilderInstruction21s;
-import org.jf.dexlib2.builder.instruction.BuilderInstruction21t;
-import org.jf.dexlib2.builder.instruction.BuilderInstruction22b;
-import org.jf.dexlib2.builder.instruction.BuilderInstruction22c;
-import org.jf.dexlib2.builder.instruction.BuilderInstruction22s;
-import org.jf.dexlib2.builder.instruction.BuilderInstruction22t;
-import org.jf.dexlib2.builder.instruction.BuilderInstruction22x;
-import org.jf.dexlib2.builder.instruction.BuilderInstruction23x;
-import org.jf.dexlib2.builder.instruction.BuilderInstruction25x;
-import org.jf.dexlib2.builder.instruction.BuilderInstruction30t;
-import org.jf.dexlib2.builder.instruction.BuilderInstruction31c;
-import org.jf.dexlib2.builder.instruction.BuilderInstruction31i;
-import org.jf.dexlib2.builder.instruction.BuilderInstruction31t;
-import org.jf.dexlib2.builder.instruction.BuilderInstruction32x;
-import org.jf.dexlib2.builder.instruction.BuilderInstruction35c;
-import org.jf.dexlib2.builder.instruction.BuilderInstruction3rc;
-import org.jf.dexlib2.builder.instruction.BuilderInstruction51l;
-import org.jf.dexlib2.builder.instruction.BuilderPackedSwitchPayload;
-import org.jf.dexlib2.builder.instruction.BuilderSparseSwitchPayload;
-import org.jf.dexlib2.iface.ExceptionHandler;
-import org.jf.dexlib2.iface.MethodImplementation;
-import org.jf.dexlib2.iface.TryBlock;
-import org.jf.dexlib2.iface.debug.DebugItem;
-import org.jf.dexlib2.iface.debug.EndLocal;
-import org.jf.dexlib2.iface.debug.LineNumber;
-import org.jf.dexlib2.iface.debug.RestartLocal;
-import org.jf.dexlib2.iface.debug.SetSourceFile;
-import org.jf.dexlib2.iface.debug.StartLocal;
-import org.jf.dexlib2.iface.instruction.Instruction;
-import org.jf.dexlib2.iface.instruction.SwitchElement;
-import org.jf.dexlib2.iface.instruction.formats.ArrayPayload;
-import org.jf.dexlib2.iface.instruction.formats.Instruction10t;
-import org.jf.dexlib2.iface.instruction.formats.Instruction10x;
-import org.jf.dexlib2.iface.instruction.formats.Instruction11n;
-import org.jf.dexlib2.iface.instruction.formats.Instruction11x;
-import org.jf.dexlib2.iface.instruction.formats.Instruction12x;
-import org.jf.dexlib2.iface.instruction.formats.Instruction20bc;
-import org.jf.dexlib2.iface.instruction.formats.Instruction20t;
-import org.jf.dexlib2.iface.instruction.formats.Instruction21c;
-import org.jf.dexlib2.iface.instruction.formats.Instruction21ih;
-import org.jf.dexlib2.iface.instruction.formats.Instruction21lh;
-import org.jf.dexlib2.iface.instruction.formats.Instruction21s;
-import org.jf.dexlib2.iface.instruction.formats.Instruction21t;
-import org.jf.dexlib2.iface.instruction.formats.Instruction22b;
-import org.jf.dexlib2.iface.instruction.formats.Instruction22c;
-import org.jf.dexlib2.iface.instruction.formats.Instruction22s;
-import org.jf.dexlib2.iface.instruction.formats.Instruction22t;
-import org.jf.dexlib2.iface.instruction.formats.Instruction22x;
-import org.jf.dexlib2.iface.instruction.formats.Instruction23x;
-import org.jf.dexlib2.iface.instruction.formats.Instruction25x;
-import org.jf.dexlib2.iface.instruction.formats.Instruction30t;
-import org.jf.dexlib2.iface.instruction.formats.Instruction31c;
-import org.jf.dexlib2.iface.instruction.formats.Instruction31i;
-import org.jf.dexlib2.iface.instruction.formats.Instruction31t;
-import org.jf.dexlib2.iface.instruction.formats.Instruction32x;
-import org.jf.dexlib2.iface.instruction.formats.Instruction35c;
-import org.jf.dexlib2.iface.instruction.formats.Instruction3rc;
-import org.jf.dexlib2.iface.instruction.formats.Instruction51l;
-import org.jf.dexlib2.iface.instruction.formats.PackedSwitchPayload;
-import org.jf.dexlib2.iface.instruction.formats.SparseSwitchPayload;
-import org.jf.dexlib2.iface.reference.Reference;
-import org.jf.dexlib2.iface.reference.StringReference;
-import org.jf.dexlib2.iface.reference.TypeReference;
-import org.jf.dexlib2.writer.builder.DexBuilder;
-import org.jf.util.ExceptionWithContext;
-
-import java.util.AbstractList;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.HashSet;
-import java.util.List;
-
-import javax.annotation.Nonnull;
-import javax.annotation.Nullable;
-
-/**
- * Created by tangyinsheng on 2016/10/9.
- */
-public class BuilderMutableMethodImplementation implements MethodImplementation {
-    private final DexBuilder dexBuilder;
-    private final int registerCount;
-    private final ArrayList<MethodLocation> instructionList = Lists.newArrayList(new MethodLocation(null, 0, 0));
-    private final ArrayList<BuilderTryBlock> tryBlocks = Lists.newArrayList();
-    private boolean fixInstructions = true;
-
-    public BuilderMutableMethodImplementation(DexBuilder dexBuilder, @Nonnull MethodImplementation methodImplementation) {
-        this.dexBuilder = dexBuilder;
-
-        this.registerCount = methodImplementation.getRegisterCount();
-
-        int codeAddress = 0;
-        int index = 0;
-
-        for (Instruction instruction : methodImplementation.getInstructions()) {
-            codeAddress += instruction.getCodeUnits();
-            index++;
-
-            instructionList.add(new MethodLocation(null, codeAddress, index));
-        }
-
-        final int[] codeAddressToIndex = new int[codeAddress + 1];
-        Arrays.fill(codeAddressToIndex, -1);
-
-        for (int i = 0; i < instructionList.size(); i++) {
-            codeAddressToIndex[instructionList.get(i).codeAddress] = i;
-        }
-
-        List<Task> switchPayloadTasks = Lists.newArrayList();
-        index = 0;
-        for (final Instruction instruction : methodImplementation.getInstructions()) {
-            final MethodLocation location = instructionList.get(index);
-            final Opcode opcode = instruction.getOpcode();
-            if (opcode == Opcode.PACKED_SWITCH_PAYLOAD || opcode == Opcode.SPARSE_SWITCH_PAYLOAD) {
-                switchPayloadTasks.add(new Task() {
-                    @Override
-                    public void perform() {
-                        convertAndSetInstruction(location, codeAddressToIndex, instruction);
-                    }
-                });
-            } else {
-                convertAndSetInstruction(location, codeAddressToIndex, instruction);
-            }
-            index++;
-        }
-
-        // the switch payload instructions must be converted last, so that any switch statements that refer to them
-        // have created the referring labels that we look for
-        for (Task switchPayloadTask : switchPayloadTasks) {
-            switchPayloadTask.perform();
-        }
-
-        for (DebugItem debugItem : methodImplementation.getDebugItems()) {
-            int debugCodeAddress = debugItem.getCodeAddress();
-            int locationIndex = mapCodeAddressToIndex(codeAddressToIndex, debugCodeAddress);
-            MethodLocation debugLocation = instructionList.get(locationIndex);
-            BuilderDebugItem builderDebugItem = convertDebugItem(debugItem);
-            debugLocation.getDebugItems().add(builderDebugItem);
-            builderDebugItem.location = debugLocation;
-        }
-
-        for (TryBlock<? extends ExceptionHandler> tryBlock : methodImplementation.getTryBlocks()) {
-            Label startLabel = newLabel(codeAddressToIndex, tryBlock.getStartCodeAddress());
-            Label endLabel = newLabel(codeAddressToIndex, tryBlock.getStartCodeAddress() + tryBlock.getCodeUnitCount());
-
-            for (ExceptionHandler exceptionHandler : tryBlock.getExceptionHandlers()) {
-                tryBlocks.add(new BuilderTryBlock(startLabel, endLabel,
-                        (TypeReference) convertReference(exceptionHandler.getExceptionTypeReference()),
-                        newLabel(codeAddressToIndex, exceptionHandler.getHandlerCodeAddress())));
-            }
-        }
-    }
-
-    public BuilderMutableMethodImplementation(int registerCount) {
-        this.dexBuilder = null;
-        this.registerCount = registerCount;
-    }
-
-    @Override
-    public int getRegisterCount() {
-        return registerCount;
-    }
-
-    @Nonnull
-    public List<BuilderInstruction> getInstructions() {
-        if (fixInstructions) {
-            fixInstructions();
-        }
-
-        return new AbstractList<BuilderInstruction>() {
-            @Override
-            public BuilderInstruction get(int i) {
-                if (i >= size()) {
-                    throw new IndexOutOfBoundsException();
-                }
-                if (fixInstructions) {
-                    fixInstructions();
-                }
-                return instructionList.get(i).instruction;
-            }
-
-            @Override
-            public int size() {
-                if (fixInstructions) {
-                    fixInstructions();
-                }
-                // don't include the last MethodLocation, which always has a null instruction
-                return instructionList.size() - 1;
-            }
-        };
-    }
-
-    @Nonnull
-    @Override
-    public List<BuilderTryBlock> getTryBlocks() {
-        if (fixInstructions) {
-            fixInstructions();
-        }
-        return Collections.unmodifiableList(tryBlocks);
-    }
-
-    @Nonnull
-    @Override
-    public Iterable<? extends DebugItem> getDebugItems() {
-        if (fixInstructions) {
-            fixInstructions();
-        }
-        return Iterables.concat(
-                Iterables.transform(instructionList, new Function<MethodLocation, Iterable<? extends DebugItem>>() {
-                    @Nullable
-                    @Override
-                    public Iterable<? extends DebugItem> apply(@Nullable MethodLocation input) {
-                        assert input != null;
-                        if (fixInstructions) {
-                            throw new IllegalStateException("This iterator was invalidated by a change to"
-                                + " this MutableMethodImplementation.");
-                        }
-                        return input.getDebugItems();
-                    }
-                }));
-    }
-
-    public void addCatch(@Nullable TypeReference type, @Nonnull Label from,
-                         @Nonnull Label to, @Nonnull Label handler) {
-        tryBlocks.add(new BuilderTryBlock(from, to, type, handler));
-    }
-
-    public void addCatch(@Nullable String type, @Nonnull Label from, @Nonnull Label to,
-                         @Nonnull Label handler) {
-        tryBlocks.add(new BuilderTryBlock(from, to, type, handler));
-    }
-
-    public void addCatch(@Nonnull Label from, @Nonnull Label to, @Nonnull Label handler) {
-        tryBlocks.add(new BuilderTryBlock(from, to, handler));
-    }
-
-    public void addInstruction(int index, BuilderInstruction instruction) {
-        // the end check here is intentially >= rather than >, because the list always includes an "empty"
-        // (null instruction) MethodLocation at the end. To add an instruction to the end of the list, the user would
-        // provide the index of this empty item, which would be size() - 1.
-        if (index >= instructionList.size()) {
-            throw new IndexOutOfBoundsException();
-        }
-
-        if (index == instructionList.size() - 1) {
-            addInstruction(instruction);
-            return;
-        }
-        int codeAddress = instructionList.get(index).getCodeAddress();
-        MethodLocation newLoc = new MethodLocation(instruction, codeAddress, index);
-        instructionList.add(index, newLoc);
-        instruction.location = newLoc;
-
-        codeAddress += instruction.getCodeUnits();
-
-        for (int i = index + 1; i < instructionList.size(); i++) {
-            MethodLocation location = instructionList.get(i);
-            location.index++;
-            location.codeAddress = codeAddress;
-            if (location.instruction != null) {
-                codeAddress += location.instruction.getCodeUnits();
-            } else {
-                // only the last MethodLocation should have a null instruction
-                assert i == instructionList.size() - 1;
-            }
-        }
-
-        this.fixInstructions = true;
-    }
-
-    public void addInstruction(@Nonnull BuilderInstruction instruction) {
-        MethodLocation last = instructionList.get(instructionList.size() - 1);
-        last.instruction = instruction;
-        instruction.location = last;
-
-        int nextCodeAddress = last.codeAddress + instruction.getCodeUnits();
-        instructionList.add(new MethodLocation(null, nextCodeAddress, instructionList.size()));
-
-        this.fixInstructions = true;
-    }
-
-    public void replaceInstruction(int index, @Nonnull BuilderInstruction replacementInstruction) {
-        if (index >= instructionList.size() - 1) {
-            throw new IndexOutOfBoundsException();
-        }
-
-        MethodLocation replaceLocation = instructionList.get(index);
-        replacementInstruction.location = replaceLocation;
-        BuilderInstruction old = replaceLocation.instruction;
-        assert old != null;
-        old.location = null;
-        replaceLocation.instruction = replacementInstruction;
-
-        // TODO: factor out index/address fix up loop
-        int codeAddress = replaceLocation.codeAddress + replaceLocation.instruction.getCodeUnits();
-        for (int i = index + 1; i < instructionList.size(); i++) {
-            MethodLocation location = instructionList.get(i);
-            location.codeAddress = codeAddress;
-
-            Instruction instruction = location.getInstruction();
-            if (instruction != null) {
-                codeAddress += instruction.getCodeUnits();
-            } else {
-                assert i == instructionList.size() - 1;
-            }
-        }
-
-        this.fixInstructions = true;
-    }
-
-    public void removeInstruction(int index) {
-        if (index >= instructionList.size() - 1) {
-            throw new IndexOutOfBoundsException();
-        }
-
-        MethodLocation toRemove = instructionList.get(index);
-        toRemove.instruction = null;
-        MethodLocation next = instructionList.get(index + 1);
-        toRemove.mergeInto(next);
-
-        instructionList.remove(index);
-        int codeAddress = toRemove.codeAddress;
-        for (int i = index; i < instructionList.size(); i++) {
-            MethodLocation location = instructionList.get(i);
-            location.index = i;
-            location.codeAddress = codeAddress;
-
-            Instruction instruction = location.getInstruction();
-            if (instruction != null) {
-                codeAddress += instruction.getCodeUnits();
-            } else {
-                assert i == instructionList.size() - 1;
-            }
-        }
-
-        this.fixInstructions = true;
-    }
-
-    public void swapInstructions(int index1, int index2) {
-        if (index1 >= instructionList.size() - 1 || index2 >= instructionList.size() - 1) {
-            throw new IndexOutOfBoundsException();
-        }
-        MethodLocation first = instructionList.get(index1);
-        MethodLocation second = instructionList.get(index2);
-
-        // only the last MethodLocation may have a null instruction
-        assert first.instruction != null;
-        assert second.instruction != null;
-
-        first.instruction.location = second;
-        second.instruction.location = first;
-
-        {
-            BuilderInstruction tmp = second.instruction;
-            second.instruction = first.instruction;
-            first.instruction = tmp;
-        }
-
-        if (index2 < index1) {
-            int tmp = index2;
-            index2 = index1;
-            index1 = tmp;
-        }
-
-        int codeAddress = first.codeAddress + first.instruction.getCodeUnits();
-        for (int i = index1 + 1; i <= index2; i++) {
-            MethodLocation location = instructionList.get(i);
-            location.codeAddress = codeAddress;
-
-            Instruction instruction = location.instruction;
-            assert instruction != null;
-            codeAddress += location.instruction.getCodeUnits();
-        }
-
-        this.fixInstructions = true;
-    }
-
-    @Nullable
-    private BuilderInstruction getFirstNonNop(int startIndex) {
-
-        for (int i = startIndex; i < instructionList.size() - 1; i++) {
-            BuilderInstruction instruction = instructionList.get(i).instruction;
-            assert instruction != null;
-            if (instruction.getOpcode() != Opcode.NOP) {
-                return instruction;
-            }
-        }
-        return null;
-    }
-
-    private void fixInstructions() {
-        HashSet<MethodLocation> payloadLocations = Sets.newHashSet();
-
-        for (MethodLocation location : instructionList) {
-            BuilderInstruction instruction = location.instruction;
-            if (instruction != null) {
-                switch (instruction.getOpcode()) {
-                    case SPARSE_SWITCH:
-                    case PACKED_SWITCH: {
-                        MethodLocation targetLocation =
-                                ((BuilderOffsetInstruction) instruction).getTarget().getLocation();
-                        BuilderInstruction targetInstruction = targetLocation.instruction;
-                        if (targetInstruction == null) {
-                            throw new IllegalStateException(String.format("Switch instruction at address/index "
-                                + "0x%x/%d points to the end of the method.", location.codeAddress, location.index));
-                        }
-
-                        if (targetInstruction.getOpcode() == Opcode.NOP) {
-                            targetInstruction = getFirstNonNop(targetLocation.index + 1);
-                        }
-                        if (targetInstruction == null || !(targetInstruction instanceof BuilderSwitchPayload)) {
-                            throw new IllegalStateException(String.format("Switch instruction at address/index "
-                                + "0x%x/%d does not refer to a payload instruction.",
-                                    location.codeAddress, location.index));
-                        }
-                        if ((instruction.opcode == Opcode.PACKED_SWITCH
-                            && targetInstruction.getOpcode() != Opcode.PACKED_SWITCH_PAYLOAD)
-                            || (instruction.opcode == Opcode.SPARSE_SWITCH
-                            && targetInstruction.getOpcode() != Opcode.SPARSE_SWITCH_PAYLOAD)) {
-                            throw new IllegalStateException(String.format("Switch instruction at address/index "
-                                + "0x%x/%d refers to the wrong type of payload instruction.",
-                                    location.codeAddress, location.index));
-                        }
-
-                        if (!payloadLocations.add(targetLocation)) {
-                            throw new IllegalStateException("Multiple switch instructions refer to the same payload. "
-                                + "This is not currently supported. Please file a bug :)");
-                        }
-
-                        ((BuilderSwitchPayload) targetInstruction).referrer = location;
-                        break;
-                    }
-                }
-            }
-        }
-
-        boolean madeChanges;
-        do {
-            madeChanges = false;
-
-            for (int index = 0; index < instructionList.size(); index++) {
-                MethodLocation location = instructionList.get(index);
-                BuilderInstruction instruction = location.instruction;
-                if (instruction != null) {
-                    switch (instruction.getOpcode()) {
-                        case GOTO: {
-                            int offset = ((BuilderOffsetInstruction) instruction).internalGetCodeOffset();
-                            if (offset < Byte.MIN_VALUE || offset > Byte.MAX_VALUE) {
-                                BuilderOffsetInstruction replacement;
-                                if (offset < Short.MIN_VALUE || offset > Short.MAX_VALUE) {
-                                    replacement = new BuilderInstruction30t(Opcode.GOTO_32,
-                                            ((BuilderOffsetInstruction) instruction).getTarget());
-                                } else {
-                                    replacement = new BuilderInstruction20t(Opcode.GOTO_16,
-                                            ((BuilderOffsetInstruction) instruction).getTarget());
-                                }
-                                replaceInstruction(location.index, replacement);
-                                madeChanges = true;
-                            }
-                            break;
-                        }
-                        case GOTO_16: {
-                            int offset = ((BuilderOffsetInstruction) instruction).internalGetCodeOffset();
-                            if (offset < Short.MIN_VALUE || offset > Short.MAX_VALUE) {
-                                BuilderOffsetInstruction replacement = new BuilderInstruction30t(Opcode.GOTO_32,
-                                        ((BuilderOffsetInstruction) instruction).getTarget());
-                                replaceInstruction(location.index, replacement);
-                                madeChanges = true;
-                            }
-                            break;
-                        }
-                        case SPARSE_SWITCH_PAYLOAD:
-                        case PACKED_SWITCH_PAYLOAD:
-                            if (((BuilderSwitchPayload) instruction).referrer == null) {
-                                // if the switch payload isn't referenced, just remove it
-                                removeInstruction(index);
-                                index--;
-                                madeChanges = true;
-                                break;
-                            }
-                            // intentional fall-through
-                        case ARRAY_PAYLOAD: {
-                            if ((location.codeAddress & 0x01) != 0) {
-                                int previousIndex = location.index - 1;
-                                MethodLocation previousLocation = instructionList.get(previousIndex);
-                                Instruction previousInstruction = previousLocation.instruction;
-                                assert previousInstruction != null;
-                                if (previousInstruction.getOpcode() == Opcode.NOP) {
-                                    removeInstruction(previousIndex);
-                                    index--;
-                                } else {
-                                    addInstruction(location.index, new BuilderInstruction10x(Opcode.NOP));
-                                    index++;
-                                }
-                                madeChanges = true;
-                            }
-                            break;
-                        }
-                    }
-                }
-            }
-        } while (madeChanges);
-
-        fixInstructions = false;
-    }
-
-    private int mapCodeAddressToIndex(@Nonnull int[] codeAddressToIndex, int codeAddress) {
-        int index;
-        do {
-            index = codeAddressToIndex[codeAddress];
-            if (index < 0) {
-                codeAddress--;
-            } else {
-                return index;
-            }
-        } while (true);
-    }
-
-    private int mapCodeAddressToIndex(int codeAddress) {
-        float avgCodeUnitsPerInstruction = 1.9f;
-
-        int index = (int) (codeAddress / avgCodeUnitsPerInstruction);
-        if (index >= instructionList.size()) {
-            index = instructionList.size() - 1;
-        }
-
-        MethodLocation guessedLocation = instructionList.get(index);
-
-        if (guessedLocation.codeAddress == codeAddress) {
-            return index;
-        } else if (guessedLocation.codeAddress > codeAddress) {
-            do {
-                index--;
-            } while (instructionList.get(index).codeAddress > codeAddress);
-            return index;
-        } else {
-            do {
-                index++;
-            }
-            while (index < instructionList.size() && instructionList.get(index).codeAddress <= codeAddress);
-            return index - 1;
-        }
-    }
-
-    @Nonnull
-    public Label newLabelForAddress(int codeAddress) {
-        if (codeAddress < 0 || codeAddress > instructionList.get(instructionList.size() - 1).codeAddress) {
-            throw new IndexOutOfBoundsException(String.format("codeAddress %d out of bounds", codeAddress));
-        }
-        MethodLocation referent = instructionList.get(mapCodeAddressToIndex(codeAddress));
-        return referent.addNewLabel();
-    }
-
-    @Nonnull
-    public Label newLabelForIndex(int instructionIndex) {
-        if (instructionIndex < 0 || instructionIndex >= instructionList.size()) {
-            throw new IndexOutOfBoundsException(String.format("instruction index %d out of bounds", instructionIndex));
-        }
-        MethodLocation referent = instructionList.get(instructionIndex);
-        return referent.addNewLabel();
-    }
-
-    @Nonnull
-    private Label newLabel(@Nonnull int[] codeAddressToIndex, int codeAddress) {
-        MethodLocation referent = instructionList.get(mapCodeAddressToIndex(codeAddressToIndex, codeAddress));
-        return referent.addNewLabel();
-    }
-
-    @Nonnull
-    public Label newSwitchPayloadReferenceLabel(@Nonnull MethodLocation switchLocation,
-                                                @Nonnull int[] codeAddressToIndex, int codeAddress) {
-        MethodLocation referent = instructionList.get(mapCodeAddressToIndex(codeAddressToIndex, codeAddress));
-        SwitchPayloadReferenceLabel label = new SwitchPayloadReferenceLabel();
-        label.switchLocation = switchLocation;
-        referent.getLabels().add(label);
-        return label;
-    }
-
-    private void setInstruction(@Nonnull MethodLocation location, @Nonnull BuilderInstruction instruction) {
-        location.instruction = instruction;
-        instruction.location = location;
-    }
-
-    private void convertAndSetInstruction(@Nonnull MethodLocation location, int[] codeAddressToIndex,
-                                          @Nonnull Instruction instruction) {
-        switch (instruction.getOpcode().format) {
-            case Format10t:
-                setInstruction(location, newBuilderInstruction10t(location.codeAddress,
-                        codeAddressToIndex,
-                        (Instruction10t) instruction));
-                return;
-            case Format10x:
-                setInstruction(location, newBuilderInstruction10x((Instruction10x) instruction));
-                return;
-            case Format11n:
-                setInstruction(location, newBuilderInstruction11n((Instruction11n) instruction));
-                return;
-            case Format11x:
-                setInstruction(location, newBuilderInstruction11x((Instruction11x) instruction));
-                return;
-            case Format12x:
-                setInstruction(location, newBuilderInstruction12x((Instruction12x) instruction));
-                return;
-            case Format20bc:
-                setInstruction(location, newBuilderInstruction20bc((Instruction20bc) instruction));
-                return;
-            case Format20t:
-                setInstruction(location, newBuilderInstruction20t(location.codeAddress,
-                        codeAddressToIndex,
-                        (Instruction20t) instruction));
-                return;
-            case Format21c:
-                setInstruction(location, newBuilderInstruction21c((Instruction21c) instruction));
-                return;
-            case Format21ih:
-                setInstruction(location, newBuilderInstruction21ih((Instruction21ih) instruction));
-                return;
-            case Format21lh:
-                setInstruction(location, newBuilderInstruction21lh((Instruction21lh) instruction));
-                return;
-            case Format21s:
-                setInstruction(location, newBuilderInstruction21s((Instruction21s) instruction));
-                return;
-            case Format21t:
-                setInstruction(location, newBuilderInstruction21t(location.codeAddress,
-                        codeAddressToIndex,
-                        (Instruction21t) instruction));
-                return;
-            case Format22b:
-                setInstruction(location, newBuilderInstruction22b((Instruction22b) instruction));
-                return;
-            case Format22c:
-                setInstruction(location, newBuilderInstruction22c((Instruction22c) instruction));
-                return;
-            case Format22s:
-                setInstruction(location, newBuilderInstruction22s((Instruction22s) instruction));
-                return;
-            case Format22t:
-                setInstruction(location, newBuilderInstruction22t(location.codeAddress,
-                        codeAddressToIndex,
-                        (Instruction22t) instruction));
-                return;
-            case Format22x:
-                setInstruction(location, newBuilderInstruction22x((Instruction22x) instruction));
-                return;
-            case Format23x:
-                setInstruction(location, newBuilderInstruction23x((Instruction23x) instruction));
-                return;
-            case Format25x:
-                setInstruction(location, newBuilderInstruction25x((Instruction25x) instruction));
-                return;
-            case Format30t:
-                setInstruction(location, newBuilderInstruction30t(location.codeAddress,
-                        codeAddressToIndex,
-                        (Instruction30t) instruction));
-                return;
-            case Format31c:
-                setInstruction(location, newBuilderInstruction31c((Instruction31c) instruction));
-                return;
-            case Format31i:
-                setInstruction(location, newBuilderInstruction31i((Instruction31i) instruction));
-                return;
-            case Format31t:
-                setInstruction(location, newBuilderInstruction31t(location, codeAddressToIndex,
-                        (Instruction31t) instruction));
-                return;
-            case Format32x:
-                setInstruction(location, newBuilderInstruction32x((Instruction32x) instruction));
-                return;
-            case Format35c:
-                setInstruction(location, newBuilderInstruction35c((Instruction35c) instruction));
-                return;
-            case Format3rc:
-                setInstruction(location, newBuilderInstruction3rc((Instruction3rc) instruction));
-                return;
-            case Format51l:
-                setInstruction(location, newBuilderInstruction51l((Instruction51l) instruction));
-                return;
-            case PackedSwitchPayload:
-                setInstruction(location,
-                        newBuilderPackedSwitchPayload(location, codeAddressToIndex, (PackedSwitchPayload) instruction));
-                return;
-            case SparseSwitchPayload:
-                setInstruction(location,
-                        newBuilderSparseSwitchPayload(location, codeAddressToIndex, (SparseSwitchPayload) instruction));
-                return;
-            case ArrayPayload:
-                setInstruction(location, newBuilderArrayPayload((ArrayPayload) instruction));
-                return;
-            default:
-                throw new ExceptionWithContext("Instruction format %s not supported", instruction.getOpcode().format);
-        }
-    }
-
-    @Nonnull
-    private BuilderInstruction10t newBuilderInstruction10t(int codeAddress, int[] codeAddressToIndex,
-                                                           @Nonnull Instruction10t instruction) {
-        return new BuilderInstruction10t(
-                instruction.getOpcode(),
-                newLabel(codeAddressToIndex, codeAddress + instruction.getCodeOffset()));
-    }
-
-    @Nonnull
-    private BuilderInstruction10x newBuilderInstruction10x(@Nonnull Instruction10x instruction) {
-        return new BuilderInstruction10x(
-                instruction.getOpcode());
-    }
-
-    @Nonnull
-    private BuilderInstruction11n newBuilderInstruction11n(@Nonnull Instruction11n instruction) {
-        return new BuilderInstruction11n(
-                instruction.getOpcode(),
-                instruction.getRegisterA(),
-                instruction.getNarrowLiteral());
-    }
-
-    @Nonnull
-    private BuilderInstruction11x newBuilderInstruction11x(@Nonnull Instruction11x instruction) {
-        return new BuilderInstruction11x(
-                instruction.getOpcode(),
-                instruction.getRegisterA());
-    }
-
-    @Nonnull
-    private BuilderInstruction12x newBuilderInstruction12x(@Nonnull Instruction12x instruction) {
-        return new BuilderInstruction12x(
-                instruction.getOpcode(),
-                instruction.getRegisterA(),
-                instruction.getRegisterB());
-    }
-
-    @Nonnull
-    private BuilderInstruction20bc newBuilderInstruction20bc(@Nonnull Instruction20bc instruction) {
-        return new BuilderInstruction20bc(
-                instruction.getOpcode(),
-                instruction.getVerificationError(),
-                convertReference(instruction.getReference()));
-    }
-
-    @Nonnull
-    private BuilderInstruction20t newBuilderInstruction20t(int codeAddress, int[] codeAddressToIndex,
-                                                           @Nonnull Instruction20t instruction) {
-        return new BuilderInstruction20t(
-                instruction.getOpcode(),
-                newLabel(codeAddressToIndex, codeAddress + instruction.getCodeOffset()));
-    }
-
-    @Nonnull
-    private BuilderInstruction21c newBuilderInstruction21c(@Nonnull Instruction21c instruction) {
-        return new BuilderInstruction21c(
-                instruction.getOpcode(),
-                instruction.getRegisterA(),
-                convertReference(instruction.getReference()));
-    }
-
-    @Nonnull
-    private BuilderInstruction21ih newBuilderInstruction21ih(@Nonnull Instruction21ih instruction) {
-        return new BuilderInstruction21ih(
-                instruction.getOpcode(),
-                instruction.getRegisterA(),
-                instruction.getNarrowLiteral());
-    }
-
-    @Nonnull
-    private BuilderInstruction21lh newBuilderInstruction21lh(@Nonnull Instruction21lh instruction) {
-        return new BuilderInstruction21lh(
-                instruction.getOpcode(),
-                instruction.getRegisterA(),
-                instruction.getWideLiteral());
-    }
-
-    @Nonnull
-    private BuilderInstruction21s newBuilderInstruction21s(@Nonnull Instruction21s instruction) {
-        return new BuilderInstruction21s(
-                instruction.getOpcode(),
-                instruction.getRegisterA(),
-                instruction.getNarrowLiteral());
-    }
-
-    @Nonnull
-    private BuilderInstruction21t newBuilderInstruction21t(int codeAddress, int[] codeAddressToIndex,
-                                                           @Nonnull Instruction21t instruction) {
-        return new BuilderInstruction21t(
-                instruction.getOpcode(),
-                instruction.getRegisterA(),
-                newLabel(codeAddressToIndex, codeAddress + instruction.getCodeOffset()));
-    }
-
-    @Nonnull
-    private BuilderInstruction22b newBuilderInstruction22b(@Nonnull Instruction22b instruction) {
-        return new BuilderInstruction22b(
-                instruction.getOpcode(),
-                instruction.getRegisterA(),
-                instruction.getRegisterB(),
-                instruction.getNarrowLiteral());
-    }
-
-    @Nonnull
-    private BuilderInstruction22c newBuilderInstruction22c(@Nonnull Instruction22c instruction) {
-        return new BuilderInstruction22c(
-                instruction.getOpcode(),
-                instruction.getRegisterA(),
-                instruction.getRegisterB(),
-                convertReference(instruction.getReference()));
-    }
-
-    @Nonnull
-    private BuilderInstruction22s newBuilderInstruction22s(@Nonnull Instruction22s instruction) {
-        return new BuilderInstruction22s(
-                instruction.getOpcode(),
-                instruction.getRegisterA(),
-                instruction.getRegisterB(),
-                instruction.getNarrowLiteral());
-    }
-
-    @Nonnull
-    private BuilderInstruction22t newBuilderInstruction22t(int codeAddress, int[] codeAddressToIndex,
-                                                           @Nonnull Instruction22t instruction) {
-        return new BuilderInstruction22t(
-                instruction.getOpcode(),
-                instruction.getRegisterA(),
-                instruction.getRegisterB(),
-                newLabel(codeAddressToIndex, codeAddress + instruction.getCodeOffset()));
-    }
-
-    @Nonnull
-    private BuilderInstruction22x newBuilderInstruction22x(@Nonnull Instruction22x instruction) {
-        return new BuilderInstruction22x(
-                instruction.getOpcode(),
-                instruction.getRegisterA(),
-                instruction.getRegisterB());
-    }
-
-    @Nonnull
-    private BuilderInstruction23x newBuilderInstruction23x(@Nonnull Instruction23x instruction) {
-        return new BuilderInstruction23x(
-                instruction.getOpcode(),
-                instruction.getRegisterA(),
-                instruction.getRegisterB(),
-                instruction.getRegisterC());
-    }
-
-    @Nonnull
-    private BuilderInstruction30t newBuilderInstruction30t(int codeAddress, int[] codeAddressToIndex,
-                                                           @Nonnull Instruction30t instruction) {
-        return new BuilderInstruction30t(
-                instruction.getOpcode(),
-                newLabel(codeAddressToIndex, codeAddress + instruction.getCodeOffset()));
-    }
-
-    @Nonnull
-    private BuilderInstruction31c newBuilderInstruction31c(@Nonnull Instruction31c instruction) {
-        return new BuilderInstruction31c(
-                instruction.getOpcode(),
-                instruction.getRegisterA(),
-                convertReference(instruction.getReference()));
-    }
-
-    @Nonnull
-    private BuilderInstruction31i newBuilderInstruction31i(@Nonnull Instruction31i instruction) {
-        return new BuilderInstruction31i(
-                instruction.getOpcode(),
-                instruction.getRegisterA(),
-                instruction.getNarrowLiteral());
-    }
-
-    @Nonnull
-    private BuilderInstruction31t newBuilderInstruction31t(@Nonnull MethodLocation location, int[] codeAddressToIndex,
-                                                           @Nonnull Instruction31t instruction) {
-        int codeAddress = location.getCodeAddress();
-        Label newLabel;
-        if (instruction.getOpcode() != Opcode.FILL_ARRAY_DATA) {
-            // if it's a sparse switch or packed switch
-            newLabel = newSwitchPayloadReferenceLabel(location, codeAddressToIndex, codeAddress + instruction.getCodeOffset());
-        } else {
-            newLabel = newLabel(codeAddressToIndex, codeAddress + instruction.getCodeOffset());
-        }
-        return new BuilderInstruction31t(
-                instruction.getOpcode(),
-                instruction.getRegisterA(),
-                newLabel);
-    }
-
-    @Nonnull
-    private BuilderInstruction32x newBuilderInstruction32x(@Nonnull Instruction32x instruction) {
-        return new BuilderInstruction32x(
-                instruction.getOpcode(),
-                instruction.getRegisterA(),
-                instruction.getRegisterB());
-    }
-
-    @Nonnull
-    private BuilderInstruction35c newBuilderInstruction35c(@Nonnull Instruction35c instruction) {
-        return new BuilderInstruction35c(
-                instruction.getOpcode(),
-                instruction.getRegisterCount(),
-                instruction.getRegisterC(),
-                instruction.getRegisterD(),
-                instruction.getRegisterE(),
-                instruction.getRegisterF(),
-                instruction.getRegisterG(),
-                convertReference(instruction.getReference()));
-    }
-
-    @Nonnull
-    private BuilderInstruction25x newBuilderInstruction25x(@Nonnull Instruction25x instruction) {
-        return new BuilderInstruction25x(
-                instruction.getOpcode(),
-                instruction.getParameterRegisterCount(),
-                instruction.getRegisterFixedC(),
-                instruction.getRegisterParameterD(),
-                instruction.getRegisterParameterE(),
-                instruction.getRegisterParameterF(),
-                instruction.getRegisterParameterG());
-    }
-
-    @Nonnull
-    private BuilderInstruction3rc newBuilderInstruction3rc(@Nonnull Instruction3rc instruction) {
-        return new BuilderInstruction3rc(
-                instruction.getOpcode(),
-                instruction.getStartRegister(),
-                instruction.getRegisterCount(),
-                convertReference(instruction.getReference()));
-    }
-
-    @Nonnull
-    private BuilderInstruction51l newBuilderInstruction51l(@Nonnull Instruction51l instruction) {
-        return new BuilderInstruction51l(
-                instruction.getOpcode(),
-                instruction.getRegisterA(),
-                instruction.getWideLiteral());
-    }
-
-    @Nullable
-    private MethodLocation findSwitchForPayload(@Nonnull MethodLocation payloadLocation) {
-        MethodLocation location = payloadLocation;
-        MethodLocation switchLocation = null;
-        do {
-            for (Label label : location.getLabels()) {
-                if (label instanceof SwitchPayloadReferenceLabel) {
-                    if (switchLocation != null) {
-                        throw new IllegalStateException("Multiple switch instructions refer to the same payload. "
-                            + "This is not currently supported. Please file a bug :)");
-                    }
-                    switchLocation = ((SwitchPayloadReferenceLabel) label).switchLocation;
-                }
-            }
-
-            // A switch instruction can refer to the payload instruction itself, or to a nop before the payload
-            // instruction.
-            // We need to search for all occurrences of a switch reference, so we can detect when multiple switch
-            // statements refer to the same payload
-            // TODO: confirm that it could refer to the first NOP in a series of NOPs preceding the payload
-            if (location.index == 0) {
-                return switchLocation;
-            }
-            location = instructionList.get(location.index - 1);
-            if (location.instruction == null || location.instruction.getOpcode() != Opcode.NOP) {
-                return switchLocation;
-            }
-        } while (true);
-    }
-
-    @Nonnull
-    private BuilderPackedSwitchPayload newBuilderPackedSwitchPayload(@Nonnull MethodLocation location,
-                                                                     @Nonnull int[] codeAddressToIndex,
-                                                                     @Nonnull PackedSwitchPayload instruction) {
-        List<? extends SwitchElement> switchElements = instruction.getSwitchElements();
-        if (switchElements.size() == 0) {
-            return new BuilderPackedSwitchPayload(0, null);
-        }
-
-        MethodLocation switchLocation = findSwitchForPayload(location);
-        int baseAddress;
-        if (switchLocation == null) {
-            baseAddress = 0;
-        } else {
-            baseAddress = switchLocation.codeAddress;
-        }
-
-        List<Label> labels = Lists.newArrayList();
-        for (SwitchElement element : switchElements) {
-            labels.add(newLabel(codeAddressToIndex, element.getOffset() + baseAddress));
-        }
-
-        return new BuilderPackedSwitchPayload(switchElements.get(0).getKey(), labels);
-    }
-
-    @Nonnull
-    private BuilderSparseSwitchPayload newBuilderSparseSwitchPayload(@Nonnull MethodLocation location,
-                                                                     @Nonnull int[] codeAddressToIndex,
-                                                                     @Nonnull SparseSwitchPayload instruction) {
-        List<? extends SwitchElement> switchElements = instruction.getSwitchElements();
-        if (switchElements.size() == 0) {
-            return new BuilderSparseSwitchPayload(null);
-        }
-
-        MethodLocation switchLocation = findSwitchForPayload(location);
-        int baseAddress;
-        if (switchLocation == null) {
-            baseAddress = 0;
-        } else {
-            baseAddress = switchLocation.codeAddress;
-        }
-
-        List<SwitchLabelElement> labelElements = Lists.newArrayList();
-        for (SwitchElement element : switchElements) {
-            labelElements.add(new SwitchLabelElement(element.getKey(),
-                    newLabel(codeAddressToIndex, element.getOffset() + baseAddress)));
-        }
-
-        return new BuilderSparseSwitchPayload(labelElements);
-    }
-
-    @Nonnull
-    private BuilderArrayPayload newBuilderArrayPayload(@Nonnull ArrayPayload instruction) {
-        return new BuilderArrayPayload(instruction.getElementWidth(), instruction.getArrayElements());
-    }
-
-    private Reference convertReference(@Nonnull Reference reference) {
-        if (reference != null && this.dexBuilder != null) {
-            return this.dexBuilder.internReference(reference);
-        } else {
-            return reference;
-        }
-    }
-
-    @Nonnull
-    private BuilderDebugItem convertDebugItem(@Nonnull DebugItem debugItem) {
-        switch (debugItem.getDebugItemType()) {
-            case DebugItemType.START_LOCAL: {
-                StartLocal startLocal = (StartLocal) debugItem;
-                return new BuilderStartLocal(startLocal.getRegister(),
-                        (StringReference) convertReference(startLocal.getNameReference()),
-                        (TypeReference) convertReference(startLocal.getTypeReference()),
-                        (StringReference) convertReference(startLocal.getSignatureReference()));
-            }
-            case DebugItemType.END_LOCAL: {
-                EndLocal endLocal = (EndLocal) debugItem;
-                return new BuilderEndLocal(endLocal.getRegister());
-            }
-            case DebugItemType.RESTART_LOCAL: {
-                RestartLocal restartLocal = (RestartLocal) debugItem;
-                return new BuilderRestartLocal(restartLocal.getRegister());
-            }
-            case DebugItemType.PROLOGUE_END:
-                return new BuilderPrologueEnd();
-            case DebugItemType.EPILOGUE_BEGIN:
-                return new BuilderEpilogueBegin();
-            case DebugItemType.LINE_NUMBER: {
-                LineNumber lineNumber = (LineNumber) debugItem;
-                return new BuilderLineNumber(lineNumber.getLineNumber());
-            }
-            case DebugItemType.SET_SOURCE_FILE: {
-                SetSourceFile setSourceFile = (SetSourceFile) debugItem;
-                return new BuilderSetSourceFile(
-                        (StringReference) convertReference(setSourceFile.getSourceFileReference())
-                );
-            }
-            default:
-                throw new ExceptionWithContext("Invalid debug item type: " + debugItem.getDebugItemType());
-        }
-    }
-
-    private interface Task {
-        void perform();
-    }
-
-    private static class SwitchPayloadReferenceLabel extends Label {
-        @Nonnull
-        public MethodLocation switchLocation;
-    }
-}
-
diff --git a/tinker-build/tinker-patch-lib/src/main/resources/only_use_to_test_tinker_resource.txt b/tinker-build/tinker-patch-lib/src/main/resources/only_use_to_test_tinker_resource.txt
new file mode 100644
index 00000000..dc9c715f
--- /dev/null
+++ b/tinker-build/tinker-patch-lib/src/main/resources/only_use_to_test_tinker_resource.txt
@@ -0,0 +1 @@
+#tinker resource changed
\ No newline at end of file
diff --git a/tinker-commons/build.gradle b/tinker-commons/build.gradle
index c6025027..b7de68c6 100644
--- a/tinker-commons/build.gradle
+++ b/tinker-commons/build.gradle
@@ -12,7 +12,8 @@ dependencies {
     compile project(':third-party:bsdiff-util')
 }
 
-task buildSdk(type: Copy, dependsOn: [build]) {
+task buildTinkerSdk(type: Copy, dependsOn: [build]) {
+    group = "tinker"
     from('build/libs') {
         include '*.jar'
         exclude '*javadoc.jar'
diff --git a/tinker-sample-android/app/build.gradle b/tinker-sample-android/app/build.gradle
index bd93ed3e..10cdcf3a 100644
--- a/tinker-sample-android/app/build.gradle
+++ b/tinker-sample-android/app/build.gradle
@@ -8,7 +8,7 @@ dependencies {
     testCompile 'junit:junit:4.12'
     compile "com.android.support:appcompat-v7:23.1.1"
     compile("com.tencent.tinker:tinker-android-lib:${TINKER_VERSION}") { changing = true }
-    compile("com.tencent.tinker:tinker-android-anno:${TINKER_VERSION}") { changing = true }
+    provided("com.tencent.tinker:tinker-android-anno:${TINKER_VERSION}") { changing = true }
 
     compile "com.android.support:multidex:1.0.1"
 
@@ -130,12 +130,6 @@ android {
          * you can use multiDex and install it in your ApplicationLifeCycle implement
          */
         multiDexEnabled true
-        /**
-         * not like proguard, multiDexKeepProguard is not a list, so we can't just
-         * add for you in our task. you can copy tinker keep rules at
-         * build/intermediates/tinker_intermediates/tinker_multidexkeep.pro
-         */
-        multiDexKeepProguard file("keep_in_main_dex.txt")
         /**
          * buildConfig can change during patch!
          * we can use the newly value when patch
@@ -146,7 +140,7 @@ android {
          * client version would update with patch
          * so we can get the newly git version easily!
          */
-        buildConfigField "String", "CLIENTVERSION", "\"${getTinkerIdValue()}\""
+        buildConfigField "String", "TINKER_ID", "\"${getTinkerIdValue()}\""
         buildConfigField "String", "PLATFORM",  "\"all\""
     }
 
@@ -265,6 +259,12 @@ if (buildWithTinker()) {
          */
         useSign = true
 
+        /**
+         * optional，default 'true'
+         * whether use tinker to build
+         */
+        tinkerEnable = buildWithTinker()
+
         /**
          * Warning, applyMapping will affect the normal android build!
          */
@@ -291,6 +291,12 @@ if (buildWithTinker()) {
              * we will gen the tinkerId in your manifest automatic
              */
             tinkerId = getTinkerIdValue()
+
+            /**
+             * if keepDexApply is true, class in which dex refer to the old apk.
+             * open this can reduce the dex diff file size.
+             */
+            keepDexApply = false
         }
 
         dex {
@@ -302,20 +308,7 @@ if (buildWithTinker()) {
              * or you want to save rom or check quicker, you can use raw mode also
              */
             dexMode = "jar"
-            /**
-             * optional，default 'false'
-             * if usePreGeneratedPatchDex is true, tinker framework will generate auxiliary class
-             * and insert auxiliary instruction when compiling base package using
-             * assemble{Debug/Release} task to prevent class pre-verified issue in dvm.
-             * Besides, a real dex file contains necessary class will be generated and packed into
-             * patch package instead of any patch info files.
-             *
-             * Use this mode if you have to use any dex encryption solutions.
-             *
-             * Notice: If you change this value, please trigger clean task
-             * and regenerate base package.
-             */
-            usePreGeneratedPatchDex = false
+
             /**
              * necessary，default '[]'
              * what dexes in apk are expected to deal with tinkerPatch
@@ -332,9 +325,7 @@ if (buildWithTinker()) {
              * own tinkerLoader, and the classes you use in them
              *
              */
-            loader = ["com.tencent.tinker.loader.*",
-                      //warning, you must change it with your application
-                      "tinker.sample.android.app.SampleApplication",
+            loader = [
                       //use sample, let BaseBuildInfo unchangeable with tinker
                       "tinker.sample.android.app.BaseBuildInfo"
             ]
@@ -410,7 +401,7 @@ if (buildWithTinker()) {
              * optional，default '7za'
              * the 7zip artifact path, it will use the right 7za with your platform
              */
-            zipArtifact = "com.tencent.mm:SevenZip:1.1.10"
+           zipArtifact = "com.tencent.mm:SevenZip:1.1.10"
             /**
              * optional，default '7za'
              * you can specify the 7za path yourself, it will overwrite the zipArtifact value
diff --git a/tinker-sample-android/app/keep_in_main_dex.txt b/tinker-sample-android/app/keep_in_main_dex.txt
deleted file mode 100644
index 12c1dcf5..00000000
--- a/tinker-sample-android/app/keep_in_main_dex.txt
+++ /dev/null
@@ -1,26 +0,0 @@
-# you can copy the tinker keep rule at
-# build/intermediates/tinker_intermediates/tinker_multidexkeep.pro
-
--keep class com.tencent.tinker.loader.** {
-    *;
-}
-
--keep class tinker.sample.android.app.SampleApplication {
-    *;
-}
-
--keep public class * implements com.tencent.tinker.loader.app.ApplicationLifeCycle {
-    *;
-}
-
--keep public class * extends com.tencent.tinker.loader.TinkerLoader {
-    *;
-}
-
--keep public class * extends com.tencent.tinker.loader.app.TinkerApplication {
-    *;
-}
-
-# here, it is your own keep rules.
-# you must be careful that the class name you write won't be proguard
-# but the tinker class above is OK, we have already keep for you!
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/app/BaseBuildInfo.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/app/BaseBuildInfo.java
index 4ffa7d4d..eca15927 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/app/BaseBuildInfo.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/app/BaseBuildInfo.java
@@ -16,10 +16,13 @@
 
 package tinker.sample.android.app;
 
+import tinker.sample.android.BuildConfig;
+
 /**
  * Created by zhangshaowen on 16/6/30.
  * we add BaseBuildInfo to loader pattern, so it won't change with patch!
  */
 public class BaseBuildInfo {
     public static String TEST_MESSAGE = "I won't change with tinker patch!";
+    public static String BASE_TINKER_ID = BuildConfig.TINKER_ID;
 }
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/app/BuildInfo.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/app/BuildInfo.java
index 58ea3527..e1d73f52 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/app/BuildInfo.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/app/BuildInfo.java
@@ -31,7 +31,7 @@
     public static int     VERSION_CODE = BuildConfig.VERSION_CODE;
 
     public static String MESSAGE       = BuildConfig.MESSAGE;
-    public static String CLIENTVERSION = BuildConfig.CLIENTVERSION;
+    public static String TINKER_ID     = BuildConfig.TINKER_ID;
     public static String PLATFORM      = BuildConfig.PLATFORM;
 
 }
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/app/MainActivity.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/app/MainActivity.java
index c0f41b18..42de38ea 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/app/MainActivity.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/app/MainActivity.java
@@ -86,6 +86,7 @@ public void onClick(View v) {
         killSelfButton.setOnClickListener(new View.OnClickListener() {
             @Override
             public void onClick(View v) {
+                ShareTinkerInternals.killAllOtherProcess(getApplicationContext());
                 android.os.Process.killProcess(android.os.Process.myPid());
             }
         });
@@ -118,16 +119,19 @@ public boolean showInfo(Context context) {
         Tinker tinker = Tinker.with(getApplicationContext());
         if (tinker.isTinkerLoaded()) {
             sb.append(String.format("[patch is loaded] \n"));
-            sb.append(String.format("[buildConfig CLIENTVERSION] %s \n", BuildInfo.CLIENTVERSION));
+            sb.append(String.format("[buildConfig TINKER_ID] %s \n", BuildInfo.TINKER_ID));
+            sb.append(String.format("[buildConfig BASE_TINKER_ID] %s \n", BaseBuildInfo.BASE_TINKER_ID));
+
             sb.append(String.format("[buildConfig MESSSAGE] %s \n", BuildInfo.MESSAGE));
             sb.append(String.format("[TINKER_ID] %s \n", tinker.getTinkerLoadResultIfPresent().getPackageConfigByName(ShareConstants.TINKER_ID)));
-            sb.append(String.format("[REAL TINKER_ID] %s \n", tinker.getTinkerLoadResultIfPresent().getTinkerID()));
             sb.append(String.format("[packageConfig patchMessage] %s \n", tinker.getTinkerLoadResultIfPresent().getPackageConfigByName("patchMessage")));
             sb.append(String.format("[TINKER_ID Rom Space] %d k \n", tinker.getTinkerRomSpace()));
 
         } else {
             sb.append(String.format("[patch is not loaded] \n"));
-            sb.append(String.format("[buildConfig CLIENTVERSION] %s \n", BuildInfo.CLIENTVERSION));
+            sb.append(String.format("[buildConfig TINKER_ID] %s \n", BuildInfo.TINKER_ID));
+            sb.append(String.format("[buildConfig BASE_TINKER_ID] %s \n", BaseBuildInfo.BASE_TINKER_ID));
+
             sb.append(String.format("[buildConfig MESSSAGE] %s \n", BuildInfo.MESSAGE));
             sb.append(String.format("[TINKER_ID] %s \n", ShareTinkerInternals.getManifestTinkerID(getApplicationContext())));
         }
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/app/SampleApplicationLike.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/app/SampleApplicationLike.java
index b4f74e82..3752bb34 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/app/SampleApplicationLike.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/app/SampleApplicationLike.java
@@ -26,6 +26,7 @@
 import android.support.multidex.MultiDex;
 
 import com.tencent.tinker.anno.DefaultLifeCycle;
+import com.tencent.tinker.lib.tinker.Tinker;
 import com.tencent.tinker.lib.tinker.TinkerInstaller;
 import com.tencent.tinker.loader.app.ApplicationLifeCycle;
 import com.tencent.tinker.loader.app.DefaultApplicationLike;
@@ -89,6 +90,7 @@ public void onBaseContextAttached(Context base) {
         initPlugin();
 
         TinkerManager.setTinkerApplicationLike(this);
+
         TinkerManager.initFastCrashProtect();
         //should set before tinker is installed
         TinkerManager.setUpgradeRetryEnable(true);
@@ -99,6 +101,7 @@ public void onBaseContextAttached(Context base) {
         //installTinker after load multiDex
         //or you can put com.tencent.tinker.** to main dex
         TinkerManager.installTinker(this);
+        Tinker tinker = Tinker.with(getApplication());
     }
 
     private void initPlugin() {
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/crash/SampleUncaughtExceptionHandler.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/crash/SampleUncaughtExceptionHandler.java
index b98bbb4d..95bcfc82 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/crash/SampleUncaughtExceptionHandler.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/crash/SampleUncaughtExceptionHandler.java
@@ -19,7 +19,6 @@
 import android.content.Context;
 import android.content.SharedPreferences;
 import android.os.SystemClock;
-import android.widget.Toast;
 
 import com.tencent.tinker.lib.tinker.TinkerApplicationHelper;
 import com.tencent.tinker.lib.util.TinkerLog;
@@ -78,10 +77,8 @@ private void tinkerPreVerifiedCrashHandler(Throwable ex) {
             }
             boolean isCausedByXposed = false;
             //for art, we can't know the actually crash type
-            //art's xposed has not much people
-            if (ShareTinkerInternals.isVmArt()) {
-                isCausedByXposed = true;
-            } else if (ex instanceof IllegalAccessError && ex.getMessage().contains(DALVIK_XPOSED_CRASH)) {
+            //just ignore art
+            if (ex instanceof IllegalAccessError && ex.getMessage().contains(DALVIK_XPOSED_CRASH)) {
                 //for dalvik, we know the actual crash type
                 isCausedByXposed = true;
             }
@@ -94,9 +91,6 @@ private void tinkerPreVerifiedCrashHandler(Throwable ex) {
 
                 TinkerApplicationHelper.cleanPatch(applicationLike);
                 ShareTinkerInternals.setTinkerDisableWithSharedPreferences(applicationLike.getApplication());
-                //method 2
-                //or you can mention user to uninstall Xposed!
-                Toast.makeText(applicationLike.getApplication(), "please uninstall Xposed, illegal modify the app", Toast.LENGTH_LONG).show();
             }
         }
     }
@@ -123,14 +117,14 @@ private boolean tinkerFastCrashProtect() {
             }
 
             SharedPreferences sp = applicationLike.getApplication().getSharedPreferences(ShareConstants.TINKER_SHARE_PREFERENCE_CONFIG, Context.MODE_MULTI_PROCESS);
-            int fastCrashCount = sp.getInt(currentVersion, 0);
+            int fastCrashCount = sp.getInt(currentVersion, 0) + 1;
             if (fastCrashCount >= MAX_CRASH_COUNT) {
                 SampleTinkerReport.onFastCrashProtect();
                 TinkerApplicationHelper.cleanPatch(applicationLike);
                 TinkerLog.e(TAG, "tinker has fast crash more than %d, we just clean patch!", fastCrashCount);
                 return true;
             } else {
-                sp.edit().putInt(currentVersion, ++fastCrashCount).commit();
+                sp.edit().putInt(currentVersion, fastCrashCount).commit();
                 TinkerLog.e(TAG, "tinker has fast crash %d times", fastCrashCount);
             }
         }
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SampleLoadReporter.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SampleLoadReporter.java
index 138f7725..7b85a465 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SampleLoadReporter.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SampleLoadReporter.java
@@ -20,17 +20,13 @@
 import android.os.Handler;
 import android.os.Looper;
 import android.os.MessageQueue;
-import android.widget.Toast;
 
 import com.tencent.tinker.lib.reporter.DefaultLoadReporter;
-import com.tencent.tinker.lib.tinker.Tinker;
-import com.tencent.tinker.lib.tinker.TinkerInstaller;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
 
 import java.io.File;
 
 import tinker.sample.android.util.UpgradePatchRetry;
-import tinker.sample.android.util.Utils;
 
 /**
  * optional, you can just use DefaultLoadReporter
@@ -44,28 +40,8 @@ public SampleLoadReporter(Context context) {
     }
 
     @Override
-    public void onLoadPatchListenerReceiveFail(final File patchFile, int errorCode, final boolean isUpgrade) {
-        super.onLoadPatchListenerReceiveFail(patchFile, errorCode, isUpgrade);
-        switch (errorCode) {
-            case ShareConstants.ERROR_PATCH_NOTEXIST:
-                Toast.makeText(context, "patch file is not exist", Toast.LENGTH_LONG).show();
-                break;
-            case ShareConstants.ERROR_PATCH_RUNNING:
-                // try later
-                // only retry for upgrade patch
-                if (isUpgrade) {
-                    handler.postDelayed(new Runnable() {
-                        @Override
-                        public void run() {
-                            TinkerInstaller.onReceiveUpgradePatch(context, patchFile.getAbsolutePath());
-                        }
-                    }, 60 * 1000);
-                }
-                break;
-            case Utils.ERROR_PATCH_ROM_SPACE:
-                Toast.makeText(context, "rom space is not enough", Toast.LENGTH_LONG).show();
-                break;
-        }
+    public void onLoadPatchListenerReceiveFail(final File patchFile, int errorCode) {
+        super.onLoadPatchListenerReceiveFail(patchFile, errorCode);
         SampleTinkerReport.onTryApplyFail(errorCode);
     }
 
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SamplePatchListener.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SamplePatchListener.java
index 852ef447..17a63497 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SamplePatchListener.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SamplePatchListener.java
@@ -33,6 +33,7 @@
 
 import tinker.sample.android.app.BuildInfo;
 import tinker.sample.android.crash.SampleUncaughtExceptionHandler;
+import tinker.sample.android.util.UpgradePatchRetry;
 import tinker.sample.android.util.Utils;
 
 /**
@@ -45,7 +46,6 @@
     private static final String TAG = "Tinker.SamplePatchListener";
 
     protected static final long NEW_PATCH_RESTRICTION_SPACE_SIZE_MIN = 60 * 1024 * 1024;
-    protected static final long OLD_PATCH_RESTRICTION_SPACE_SIZE_MIN = 30 * 1024 * 1024;
 
     private final int maxMemory;
 
@@ -64,17 +64,13 @@ public SamplePatchListener(Context context) {
      * @return
      */
     @Override
-    public int patchCheck(String path, boolean isUpgrade) {
+    public int patchCheck(String path) {
         File patchFile = new File(path);
-        TinkerLog.i(TAG, "receive a patch file: %s, isUpgrade:%b, file size:%d", path, isUpgrade, SharePatchFileUtil.getFileOrDirectorySize(patchFile));
-        int returnCode = super.patchCheck(path, isUpgrade);
+        TinkerLog.i(TAG, "receive a patch file: %s, file size:%d", path, SharePatchFileUtil.getFileOrDirectorySize(patchFile));
+        int returnCode = super.patchCheck(path);
 
         if (returnCode == ShareConstants.ERROR_PATCH_OK) {
-            if (isUpgrade) {
-                returnCode = Utils.checkForPatchRecover(NEW_PATCH_RESTRICTION_SPACE_SIZE_MIN, maxMemory);
-            } else {
-                returnCode = Utils.checkForPatchRecover(OLD_PATCH_RESTRICTION_SPACE_SIZE_MIN, maxMemory);
-            }
+            returnCode = Utils.checkForPatchRecover(NEW_PATCH_RESTRICTION_SPACE_SIZE_MIN, maxMemory);
         }
 
         if (returnCode == ShareConstants.ERROR_PATCH_OK) {
@@ -99,6 +95,11 @@ public int patchCheck(String path, boolean isUpgrade) {
                     }
                 }
             }
+            //check whether retry so many times
+            if (returnCode == ShareConstants.ERROR_PATCH_OK) {
+                returnCode = UpgradePatchRetry.getInstance(context).onPatchListenerCheck(patchMd5)
+                    ? ShareConstants.ERROR_PATCH_OK : Utils.ERROR_PATCH_RETRY_COUNT_LIMIT;
+            }
         }
         // Warning, it is just a sample case, you don't need to copy all of these
         // Interception some of the request
@@ -116,7 +117,7 @@ public int patchCheck(String path, boolean isUpgrade) {
             }
         }
 
-        SampleTinkerReport.onTryApply(isUpgrade, returnCode == ShareConstants.ERROR_PATCH_OK);
+        SampleTinkerReport.onTryApply(returnCode == ShareConstants.ERROR_PATCH_OK);
         return returnCode;
     }
 }
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SamplePatchReporter.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SamplePatchReporter.java
index a3566d68..af0753f0 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SamplePatchReporter.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SamplePatchReporter.java
@@ -43,45 +43,45 @@ public void onPatchServiceStart(Intent intent) {
     }
 
     @Override
-    public void onPatchDexOptFail(File patchFile, File dexFile, String optDirectory, String dexName, Throwable t, boolean isUpgradePatch) {
-        super.onPatchDexOptFail(patchFile, dexFile, optDirectory, dexName, t, isUpgradePatch);
+    public void onPatchDexOptFail(File patchFile, File dexFile, String optDirectory, String dexName, Throwable t) {
+        super.onPatchDexOptFail(patchFile, dexFile, optDirectory, dexName, t);
         SampleTinkerReport.onApplyDexOptFail(t);
     }
 
     @Override
-    public void onPatchException(File patchFile, Throwable e, boolean isUpgradePatch) {
-        super.onPatchException(patchFile, e, isUpgradePatch);
+    public void onPatchException(File patchFile, Throwable e) {
+        super.onPatchException(patchFile, e);
         SampleTinkerReport.onApplyCrash(e);
     }
 
     @Override
-    public void onPatchInfoCorrupted(File patchFile, String oldVersion, String newVersion, boolean isUpgradePatch) {
-        super.onPatchInfoCorrupted(patchFile, oldVersion, newVersion, isUpgradePatch);
+    public void onPatchInfoCorrupted(File patchFile, String oldVersion, String newVersion) {
+        super.onPatchInfoCorrupted(patchFile, oldVersion, newVersion);
         SampleTinkerReport.onApplyInfoCorrupted();
     }
 
     @Override
-    public void onPatchPackageCheckFail(File patchFile, boolean isUpgradePatch, int errorCode) {
-        super.onPatchPackageCheckFail(patchFile, isUpgradePatch, errorCode);
+    public void onPatchPackageCheckFail(File patchFile, int errorCode) {
+        super.onPatchPackageCheckFail(patchFile, errorCode);
         SampleTinkerReport.onApplyPackageCheckFail(errorCode);
     }
 
     @Override
-    public void onPatchResult(File patchFile, boolean success, long cost, boolean isUpgradePatch) {
-        super.onPatchResult(patchFile, success, cost, isUpgradePatch);
-        SampleTinkerReport.onApplied(isUpgradePatch, cost, success);
-        UpgradePatchRetry.getInstance(context).onPatchServiceResult(isUpgradePatch);
+    public void onPatchResult(File patchFile, boolean success, long cost) {
+        super.onPatchResult(patchFile, success, cost);
+        SampleTinkerReport.onApplied(cost, success);
+        UpgradePatchRetry.getInstance(context).onPatchServiceResult();
     }
 
     @Override
-    public void onPatchTypeExtractFail(File patchFile, File extractTo, String filename, int fileType, boolean isUpgradePatch) {
-        super.onPatchTypeExtractFail(patchFile, extractTo, filename, fileType, isUpgradePatch);
+    public void onPatchTypeExtractFail(File patchFile, File extractTo, String filename, int fileType) {
+        super.onPatchTypeExtractFail(patchFile, extractTo, filename, fileType);
         SampleTinkerReport.onApplyExtractFail(fileType);
     }
 
     @Override
-    public void onPatchVersionCheckFail(File patchFile, SharePatchInfo oldPatchInfo, String patchFileVersion, boolean isUpgradePatch) {
-        super.onPatchVersionCheckFail(patchFile, oldPatchInfo, patchFileVersion, isUpgradePatch);
+    public void onPatchVersionCheckFail(File patchFile, SharePatchInfo oldPatchInfo, String patchFileVersion) {
+        super.onPatchVersionCheckFail(patchFile, oldPatchInfo, patchFileVersion);
         SampleTinkerReport.onApplyVersionCheckFail();
     }
 }
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SampleTinkerReport.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SampleTinkerReport.java
index 9ec92dd2..a2d5a74e 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SampleTinkerReport.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SampleTinkerReport.java
@@ -43,24 +43,21 @@
     public static final int KEY_APPLY_WITH_RETRY          = 10;
 
     //Key -- try apply detail
-    public static final int KEY_TRY_APPLY_REPAIR                  = 70;
-    public static final int KEY_TRY_APPLY_UPGRADE                 = 71;
-    public static final int KEY_TRY_APPLY_DISABLE                 = 72;
-    public static final int KEY_TRY_APPLY_RUNNING                 = 73;
-    public static final int KEY_TRY_APPLY_INSERVICE               = 74;
-    public static final int KEY_TRY_APPLY_NOT_EXIST               = 75;
-    public static final int KEY_TRY_APPLY_GOOGLEPLAY              = 76;
-    public static final int KEY_TRY_APPLY_ROM_SPACE               = 77;
-    public static final int KEY_TRY_APPLY_ALREADY_APPLY           = 78;
-    public static final int KEY_TRY_APPLY_MEMORY_LIMIT            = 79;
-    public static final int KEY_TRY_APPLY_CRASH_LIMIT             = 80;
-    public static final int KEY_TRY_APPLY_CONDITION_NOT_SATISFIED = 81;
+    public static final int KEY_TRY_APPLY_UPGRADE                 = 70;
+    public static final int KEY_TRY_APPLY_DISABLE                 = 71;
+    public static final int KEY_TRY_APPLY_RUNNING                 = 72;
+    public static final int KEY_TRY_APPLY_INSERVICE               = 73;
+    public static final int KEY_TRY_APPLY_NOT_EXIST               = 74;
+    public static final int KEY_TRY_APPLY_GOOGLEPLAY              = 75;
+    public static final int KEY_TRY_APPLY_ROM_SPACE               = 76;
+    public static final int KEY_TRY_APPLY_ALREADY_APPLY           = 77;
+    public static final int KEY_TRY_APPLY_MEMORY_LIMIT            = 78;
+    public static final int KEY_TRY_APPLY_CRASH_LIMIT             = 79;
+    public static final int KEY_TRY_APPLY_CONDITION_NOT_SATISFIED = 80;
 
     //Key -- apply detail
-    public static final int KEY_APPLIED_REPAIR       = 100;
-    public static final int KEY_APPLIED_UPGRADE      = 101;
-    public static final int KEY_APPLIED_REPAIR_FAIL  = 102;
-    public static final int KEY_APPLIED_UPGRADE_FAIL = 103;
+    public static final int KEY_APPLIED_UPGRADE      = 100;
+    public static final int KEY_APPLIED_UPGRADE_FAIL = 101;
 
     public static final int KEY_APPLIED_EXCEPTION                               = 120;
     public static final int KEY_APPLIED_DEXOPT                                  = 121;
@@ -81,12 +78,8 @@
     //extract error
     public static final int KEY_APPLIED_PATCH_FILE_EXTRACT                      = 181;
     public static final int KEY_APPLIED_DEX_EXTRACT                             = 182;
-    /**
-     * for art small dex
-     */
-    public static final int KEY_APPLIED_DEX_ART_EXTRACT                         = 183;
-    public static final int KEY_APPLIED_LIB_EXTRACT                             = 184;
-    public static final int KEY_APPLIED_RESOURCE_EXTRACT                        = 185;
+    public static final int KEY_APPLIED_LIB_EXTRACT                             = 183;
+    public static final int KEY_APPLIED_RESOURCE_EXTRACT                        = 184;
     //cost time
     public static final int KEY_APPLIED_SUCC_COST_5S_LESS                       = 200;
     public static final int KEY_APPLIED_SUCC_COST_10S_LESS                      = 201;
@@ -107,7 +100,7 @@
     public static final int KEY_LOADED_EXCEPTION_DEX            = 252;
     public static final int KEY_LOADED_EXCEPTION_DEX_CHECK      = 253;
     public static final int KEY_LOADED_EXCEPTION_RESOURCE       = 254;
-    public static final int KEY_LOADED_EXCEPTION_RESOURCE_CEHCK = 255;
+    public static final int KEY_LOADED_EXCEPTION_RESOURCE_CHECK = 255;
 
 
     public static final int KEY_LOADED_MISMATCH_DEX       = 300;
@@ -151,16 +144,14 @@ public void setReporter(Reporter reporter) {
         this.reporter = reporter;
     }
 
-    public static void onTryApply(boolean upgrade, boolean success) {
+    public static void onTryApply(boolean success) {
         if (reporter == null) {
             return;
         }
         reporter.onReport(KEY_TRY_APPLY);
-        if (upgrade) {
-            reporter.onReport(KEY_TRY_APPLY_UPGRADE);
-        } else {
-            reporter.onReport(KEY_TRY_APPLY_REPAIR);
-        }
+
+        reporter.onReport(KEY_TRY_APPLY_UPGRADE);
+
         if (success) {
             reporter.onReport(KEY_TRY_APPLY_SUCCESS);
         }
@@ -332,7 +323,7 @@ public static void onLoadException(Throwable throwable, int errorCode) {
                 break;
             case ShareConstants.ERROR_LOAD_EXCEPTION_RESOURCE:
                 if (throwable.getMessage().contains(ShareConstants.CHECK_RES_INSTALL_FAIL)) {
-                    reporter.onReport(KEY_LOADED_EXCEPTION_RESOURCE_CEHCK);
+                    reporter.onReport(KEY_LOADED_EXCEPTION_RESOURCE_CHECK);
                     isCheckFail = true;
                     TinkerLog.e(TAG, "tinker res check fail:" + throwable.getMessage());
                 } else {
@@ -390,9 +381,6 @@ public static void onApplyExtractFail(int fileType) {
             case ShareConstants.TYPE_DEX:
                 reporter.onReport(KEY_APPLIED_DEX_EXTRACT);
                 break;
-            case ShareConstants.TYPE_DEX_FOR_ART:
-                reporter.onReport(KEY_APPLIED_DEX_ART_EXTRACT);
-                break;
             case ShareConstants.TYPE_LIBRARY:
                 reporter.onReport(KEY_APPLIED_LIB_EXTRACT);
                 break;
@@ -405,7 +393,7 @@ public static void onApplyExtractFail(int fileType) {
         }
     }
 
-    public static void onApplied(boolean isUpgrade, long cost, boolean success) {
+    public static void onApplied(long cost, boolean success) {
         if (reporter == null) {
             return;
         }
@@ -413,19 +401,10 @@ public static void onApplied(boolean isUpgrade, long cost, boolean success) {
             reporter.onReport(KEY_APPLIED);
         }
 
-        if (isUpgrade) {
-            if (success) {
-                reporter.onReport(KEY_APPLIED_UPGRADE);
-            } else {
-                reporter.onReport(KEY_APPLIED_UPGRADE_FAIL);
-            }
-
+        if (success) {
+            reporter.onReport(KEY_APPLIED_UPGRADE);
         } else {
-            if (success) {
-                reporter.onReport(KEY_APPLIED_REPAIR);
-            } else {
-                reporter.onReport(KEY_APPLIED_REPAIR_FAIL);
-            }
+            reporter.onReport(KEY_APPLIED_UPGRADE_FAIL);
         }
 
         TinkerLog.i(TAG, "hp_report report apply cost = %d", cost);
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/service/SampleResultService.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/service/SampleResultService.java
index d98c3a50..d8860716 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/service/SampleResultService.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/service/SampleResultService.java
@@ -26,13 +26,11 @@
 
 import com.tencent.tinker.lib.service.DefaultTinkerResultService;
 import com.tencent.tinker.lib.service.PatchResult;
-import com.tencent.tinker.lib.tinker.Tinker;
 import com.tencent.tinker.lib.util.TinkerLog;
 import com.tencent.tinker.lib.util.TinkerServiceInternals;
 import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
 
 import java.io.File;
-import java.util.zip.ZipFile;
 
 import tinker.sample.android.util.Utils;
 
@@ -69,7 +67,7 @@ public void run() {
         });
         // is success and newPatch, it is nice to delete the raw file, and restart at once
         // for old patch, you can't delete the patch file
-        if (result.isSuccess && result.isUpgradePatch) {
+        if (result.isSuccess) {
             File rawFile = new File(result.rawPatchFilePath);
             if (rawFile.exists()) {
                 TinkerLog.i(TAG, "save delete raw patch file");
@@ -96,12 +94,6 @@ public void onScreenOff() {
                 TinkerLog.i(TAG, "I have already install the newly patch version!");
             }
         }
-
-        //repair current patch fail, just clean!
-        if (!result.isSuccess && !result.isUpgradePatch) {
-            //if you have not install tinker this moment, you can use TinkerApplicationHelper api
-            Tinker.with(getApplicationContext()).cleanPatch();
-        }
     }
 
     /**
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/util/TinkerManager.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/util/TinkerManager.java
index 4106eceb..d22e30f5 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/util/TinkerManager.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/util/TinkerManager.java
@@ -18,7 +18,6 @@
 
 import com.tencent.tinker.lib.listener.PatchListener;
 import com.tencent.tinker.lib.patch.AbstractPatch;
-import com.tencent.tinker.lib.patch.RepairPatch;
 import com.tencent.tinker.lib.patch.UpgradePatch;
 import com.tencent.tinker.lib.reporter.LoadReporter;
 import com.tencent.tinker.lib.reporter.PatchReporter;
@@ -94,12 +93,10 @@ public static void installTinker(ApplicationLike appLike) {
         PatchListener patchListener = new SamplePatchListener(appLike.getApplication());
         //you can set your own upgrade patch if you need
         AbstractPatch upgradePatchProcessor = new UpgradePatch();
-        //you can set your own repair patch if you need
-        AbstractPatch repairPatchProcessor = new RepairPatch();
 
         TinkerInstaller.install(appLike,
             loadReporter, patchReporter, patchListener,
-            SampleResultService.class, upgradePatchProcessor, repairPatchProcessor);
+            SampleResultService.class, upgradePatchProcessor);
 
         isInstalled = true;
     }
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/util/UpgradePatchRetry.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/util/UpgradePatchRetry.java
index 714749e6..e7a33595 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/util/UpgradePatchRetry.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/util/UpgradePatchRetry.java
@@ -49,7 +49,8 @@
 
     private static final String RETRY_FILE_MD5_PROPERTY = "md5";
     private static final String RETRY_COUNT_PROPERTY    = "times";
-    private static final int    RETRY_MAX_COUNT         = 2;
+    private static final int    RETRY_MAX_COUNT         = 4;
+
 
     private boolean isRetryEnable = false;
     private File    retryInfoFile = null;
@@ -65,8 +66,8 @@
      */
     public UpgradePatchRetry(Context context) {
         this.context = context;
-        retryInfoFile = new File(SharePatchFileUtil.getPatchDirectory(context), RETRY_INFO_NAME);
-        tempPatchFile = new File(SharePatchFileUtil.getPatchDirectory(context), TEMP_PATCH_NAME);
+        retryInfoFile = new File(SharePatchFileUtil.getPatchTempDirectory(context), RETRY_INFO_NAME);
+        tempPatchFile = new File(SharePatchFileUtil.getPatchTempDirectory(context), TEMP_PATCH_NAME);
     }
 
     public static UpgradePatchRetry getInstance(Context context) {
@@ -108,18 +109,6 @@ public void onPatchRetryLoad() {
         SampleTinkerReport.onReportRetryPatch();
     }
 
-    private void copyToTempFile(File patchFile) {
-        if (patchFile.getAbsolutePath().equals(tempPatchFile.getAbsolutePath())) {
-            return;
-        }
-        TinkerLog.w(TAG, "try copy file: %s to %s", patchFile.getAbsolutePath(), tempPatchFile.getAbsolutePath());
-
-        try {
-            SharePatchFileUtil.copyFileUsingStream(patchFile, tempPatchFile);
-        } catch (IOException e) {
-        }
-    }
-
     public void onPatchServiceStart(Intent intent) {
         if (!isRetryEnable) {
             TinkerLog.w(TAG, "onPatchServiceStart retry disabled, just return");
@@ -131,13 +120,6 @@ public void onPatchServiceStart(Intent intent) {
             return;
         }
 
-        boolean isUpgrade = TinkerPatchService.getPatchUpgradeExtra(intent);
-
-        if (!isUpgrade) {
-            TinkerLog.w(TAG, "onPatchServiceStart is not upgrade patch, just return");
-            return;
-        }
-
         String path = TinkerPatchService.getPatchPathExtra(intent);
 
         if (path == null) {
@@ -163,7 +145,6 @@ public void onPatchServiceStart(Intent intent) {
             } else {
                 int nowTimes = Integer.parseInt(retryInfo.times);
                 if (nowTimes >= RETRY_MAX_COUNT) {
-                    SharePatchFileUtil.safeDeleteFile(retryInfoFile);
                     SharePatchFileUtil.safeDeleteFile(tempPatchFile);
                     TinkerLog.w(TAG, "onPatchServiceStart retry more than max count, delete retry info file!");
                     return;
@@ -178,29 +159,41 @@ public void onPatchServiceStart(Intent intent) {
         }
 
         RetryInfo.writeRetryProperty(retryInfoFile, retryInfo);
-
     }
 
+    public boolean onPatchListenerCheck(String md5) {
+        if (!isRetryEnable) {
+            TinkerLog.w(TAG, "onPatchListenerCheck retry disabled, just return");
+            return true;
+        }
+        if (!retryInfoFile.exists()) {
+            TinkerLog.w(TAG, "onPatchListenerCheck retry file is not exist, just return");
+            return true;
+        }
+        if (md5 == null) {
+            TinkerLog.w(TAG, "onPatchListenerCheck md5 is null, just return");
+            return true;
+        }
+        RetryInfo retryInfo = RetryInfo.readRetryProperty(retryInfoFile);
+        if (md5.equals(retryInfo.md5)) {
+            int nowTimes = Integer.parseInt(retryInfo.times);
+            if (nowTimes >= RETRY_MAX_COUNT) {
+                TinkerLog.w(TAG, "onPatchListenerCheck, retry count %d must exceed than max retry count", nowTimes);
+                SharePatchFileUtil.safeDeleteFile(tempPatchFile);
+                return false;
+            }
+        }
+        return true;
+    }
     /**
      * if we receive any result, we can delete the temp retry info file
-     *
-     * @param isUpgradePatch
      */
-    public void onPatchServiceResult(boolean isUpgradePatch) {
+    public void onPatchServiceResult() {
         if (!isRetryEnable) {
             TinkerLog.w(TAG, "onPatchServiceResult retry disabled, just return");
             return;
         }
 
-        if (!isUpgradePatch) {
-            TinkerLog.w(TAG, "onPatchServiceResult is not upgrade patch, just return");
-            return;
-        }
-
-        //delete info file
-        if (retryInfoFile.exists()) {
-            SharePatchFileUtil.safeDeleteFile(retryInfoFile);
-        }
         //delete temp patch file
         if (tempPatchFile.exists()) {
             SharePatchFileUtil.safeDeleteFile(tempPatchFile);
@@ -211,6 +204,19 @@ public void setRetryEnable(boolean enable) {
         isRetryEnable = enable;
     }
 
+
+    private void copyToTempFile(File patchFile) {
+        if (patchFile.getAbsolutePath().equals(tempPatchFile.getAbsolutePath())) {
+            return;
+        }
+        TinkerLog.w(TAG, "try copy file: %s to %s", patchFile.getAbsolutePath(), tempPatchFile.getAbsolutePath());
+
+        try {
+            SharePatchFileUtil.copyFileUsingStream(patchFile, tempPatchFile);
+        } catch (IOException e) {
+        }
+    }
+
     static class RetryInfo {
         String md5;
         String times;
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/util/Utils.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/util/Utils.java
index d6f2b993..8767307d 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/util/Utils.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/util/Utils.java
@@ -40,7 +40,8 @@
     public static final int ERROR_PATCH_MEMORY_LIMIT            = -7;
     public static final int ERROR_PATCH_ALREADY_APPLY           = -8;
     public static final int ERROR_PATCH_CRASH_LIMIT             = -9;
-    public static final int ERROR_PATCH_CONDITION_NOT_SATISFIED = -10;
+    public static final int ERROR_PATCH_RETRY_COUNT_LIMIT       = -10;
+    public static final int ERROR_PATCH_CONDITION_NOT_SATISFIED = -11;
 
     public static final String PLATFORM = "platform";
 
diff --git a/tinker-sample-android/app/src/test/java/tinker/sample/android/ExampleUnitTest.java b/tinker-sample-android/app/src/test/java/tinker/sample/android/ExampleUnitTest.java
index 8bbca8ab..4f1c077c 100644
--- a/tinker-sample-android/app/src/test/java/tinker/sample/android/ExampleUnitTest.java
+++ b/tinker-sample-android/app/src/test/java/tinker/sample/android/ExampleUnitTest.java
@@ -18,7 +18,7 @@
 
 import org.junit.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
 
 /**
  * To work on unit tests, switch the Test Artifact in the Build Variants view.
diff --git a/tinker-sample-android/gradle.properties b/tinker-sample-android/gradle.properties
index a6a66d40..6b9e5667 100644
--- a/tinker-sample-android/gradle.properties
+++ b/tinker-sample-android/gradle.properties
@@ -17,4 +17,4 @@
 # http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
 # org.gradle.parallel=true
 
-TINKER_VERSION=1.8.0
+TINKER_VERSION=1.7.6
