diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/DefaultPatchListener.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/DefaultPatchListener.java
index 7d62104b..9ea09c19 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/DefaultPatchListener.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/DefaultPatchListener.java
@@ -21,6 +21,7 @@
 import com.tencent.tinker.lib.service.TinkerPatchService;
 import com.tencent.tinker.lib.tinker.Tinker;
 import com.tencent.tinker.lib.tinker.TinkerLoadResult;
+import com.tencent.tinker.lib.util.TinkerLog;
 import com.tencent.tinker.lib.util.TinkerServiceInternals;
 import com.tencent.tinker.lib.util.UpgradePatchRetry;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
@@ -33,6 +34,8 @@
  * Created by zhangshaowen on 16/3/14.
  */
 public class DefaultPatchListener implements PatchListener {
+    private static final String TAG = "Tinker.DefaultPatchListener";
+
     protected final Context context;
 
     public DefaultPatchListener(Context context) {
@@ -48,6 +51,7 @@ public DefaultPatchListener(Context context) {
      */
     @Override
     public int onPatchReceived(String path) {
+        TinkerLog.i(TAG, "onPatchReceived begin...");
         File patchFile = new File(path);
 
         int returnCode = patchCheck(path, SharePatchFileUtil.getMD5(patchFile));
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/BsDiffPatchInternal.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/BsDiffPatchInternal.java
index 8a0b8a31..e5d28f0b 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/BsDiffPatchInternal.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/BsDiffPatchInternal.java
@@ -44,7 +44,8 @@
 
     protected static boolean tryRecoverLibraryFiles(Tinker manager, ShareSecurityCheck checker, Context context,
                                                     String patchVersionDirectory, File patchFile) {
-
+        TinkerLog.e(TAG, "tryRecoverLibraryFiles begin...");
+        
         if (!manager.isEnabledForNativeLib()) {
             TinkerLog.w(TAG, "patch recover, library is not enabled");
             return true;
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java
index d106fb81..e36f6d37 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java
@@ -60,17 +60,19 @@
     protected static final String TAG = "Tinker.DexDiffPatchInternal";
 
     protected static final int WAIT_ASYN_OAT_TIME = 10 * 1000;
-    protected static final int MAX_WAIT_COUNT     = 120;
+    protected static final int MAX_WAIT_COUNT = 120;
 
 
-    private static ArrayList<File>                      optFiles      = new ArrayList<>();
-    private static ArrayList<ShareDexDiffPatchInfo>     patchList     = new ArrayList<>();
+    private static ArrayList<File> optFiles = new ArrayList<>();
+    private static ArrayList<ShareDexDiffPatchInfo> patchList = new ArrayList<>();
     private static HashMap<ShareDexDiffPatchInfo, File> classNDexInfo = new HashMap<>();
-    private static boolean                              isVmArt       = ShareTinkerInternals.isVmArt();
+    private static boolean isVmArt = ShareTinkerInternals.isVmArt();
 
 
     protected static boolean tryRecoverDexFiles(Tinker manager, ShareSecurityCheck checker, Context context,
                                                 String patchVersionDirectory, File patchFile) {
+        TinkerLog.e(TAG, "tryRecoverDexFiles begin...");
+
         if (!manager.isEnabledForDex()) {
             TinkerLog.w(TAG, "patch recover, dex is not enabled");
             return true;
@@ -121,7 +123,7 @@ protected static boolean waitAndCheckDexOptFile(File patchFile, Tinker manager)
         }
         if (!failDexFiles.isEmpty()) {
             manager.getPatchReporter().onPatchDexOptFail(patchFile, failDexFiles,
-                new TinkerRuntimeException(ShareConstants.CHECK_DEX_OAT_EXIST_FAIL));
+                    new TinkerRuntimeException(ShareConstants.CHECK_DEX_OAT_EXIST_FAIL));
             return false;
         }
         if (Build.VERSION.SDK_INT >= 21) {
@@ -153,11 +155,11 @@ protected static boolean waitAndCheckDexOptFile(File patchFile, Tinker manager)
             }
             if (!failDexFiles.isEmpty()) {
                 Throwable returnThrowable = lastThrowable == null
-                    ? new TinkerRuntimeException(ShareConstants.CHECK_DEX_OAT_FORMAT_FAIL)
-                    : new TinkerRuntimeException(ShareConstants.CHECK_DEX_OAT_FORMAT_FAIL, lastThrowable);
+                        ? new TinkerRuntimeException(ShareConstants.CHECK_DEX_OAT_FORMAT_FAIL)
+                        : new TinkerRuntimeException(ShareConstants.CHECK_DEX_OAT_FORMAT_FAIL, lastThrowable);
 
                 manager.getPatchReporter().onPatchDexOptFail(patchFile, failDexFiles,
-                    returnThrowable);
+                        returnThrowable);
                 return false;
             }
         }
@@ -180,10 +182,10 @@ private static boolean patchDexExtractViaDexDiff(Context context, String patchVe
             for (File file : files) {
                 final String fileName = file.getName();
                 if (file.isFile()
-                    &&  (fileName.endsWith(ShareConstants.DEX_SUFFIX)
-                      || fileName.endsWith(ShareConstants.JAR_SUFFIX)
-                      || fileName.endsWith(ShareConstants.PATCH_SUFFIX))
-                ) {
+                        && (fileName.endsWith(ShareConstants.DEX_SUFFIX)
+                        || fileName.endsWith(ShareConstants.JAR_SUFFIX)
+                        || fileName.endsWith(ShareConstants.PATCH_SUFFIX))
+                        ) {
                     legalFiles.add(file);
                 }
             }
@@ -197,7 +199,7 @@ private static boolean patchDexExtractViaDexDiff(Context context, String patchVe
     }
 
     private static boolean checkClassNDexFiles(final String dexFilePath) {
-       if (patchList.isEmpty() || !isVmArt) {
+        if (patchList.isEmpty() || !isVmArt) {
             return false;
         }
         ShareDexDiffPatchInfo testInfo = null;
@@ -312,7 +314,7 @@ private static boolean mergeClassNDexFiles(final Context context, final File pat
             Tinker.with(context).getPatchReporter().onPatchTypeExtractFail(patchFile, classNFile, classNFile.getName(), TYPE_CLASS_N_DEX);
         }
         TinkerLog.i(TAG, "merge classN dex file %s, result: %b, size: %d, use: %dms",
-            classNFile.getPath(), result, classNFile.length(), (System.currentTimeMillis() - start));
+                classNFile.getPath(), result, classNFile.length(), (System.currentTimeMillis() - start));
         return result;
     }
 
@@ -343,30 +345,30 @@ private static boolean dexOptimizeDexFiles(Context context, List<File> dexFiles,
             // try parallel dex optimizer
             TinkerDexOptimizer.optimizeAll(
                     dexFiles, optimizeDexDirectoryFile,
-                new TinkerDexOptimizer.ResultCallback() {
-                    long startTime;
+                    new TinkerDexOptimizer.ResultCallback() {
+                        long startTime;
 
-                    @Override
-                    public void onStart(File dexFile, File optimizedDir) {
-                        startTime = System.currentTimeMillis();
-                        TinkerLog.i(TAG, "start to parallel optimize dex %s, size: %d", dexFile.getPath(), dexFile.length());
-                    }
+                        @Override
+                        public void onStart(File dexFile, File optimizedDir) {
+                            startTime = System.currentTimeMillis();
+                            TinkerLog.i(TAG, "start to parallel optimize dex %s, size: %d", dexFile.getPath(), dexFile.length());
+                        }
 
-                    @Override
-                    public void onSuccess(File dexFile, File optimizedDir, File optimizedFile) {
-                        // Do nothing.
-                        TinkerLog.i(TAG, "success to parallel optimize dex %s, opt file:%s, opt file size: %d, use time %d",
-                            dexFile.getPath(), optimizedFile.getPath(), optimizedFile.length(), (System.currentTimeMillis() - startTime));
-                    }
+                        @Override
+                        public void onSuccess(File dexFile, File optimizedDir, File optimizedFile) {
+                            // Do nothing.
+                            TinkerLog.i(TAG, "success to parallel optimize dex %s, opt file:%s, opt file size: %d, use time %d",
+                                    dexFile.getPath(), optimizedFile.getPath(), optimizedFile.length(), (System.currentTimeMillis() - startTime));
+                        }
 
-                    @Override
-                    public void onFailed(File dexFile, File optimizedDir, Throwable thr) {
-                        TinkerLog.i(TAG, "fail to parallel optimize dex %s use time %d",
-                            dexFile.getPath(), (System.currentTimeMillis() - startTime));
-                        failOptDexFile.add(dexFile);
-                        throwable[0] = thr;
+                        @Override
+                        public void onFailed(File dexFile, File optimizedDir, Throwable thr) {
+                            TinkerLog.i(TAG, "fail to parallel optimize dex %s use time %d",
+                                    dexFile.getPath(), (System.currentTimeMillis() - startTime));
+                            failOptDexFile.add(dexFile);
+                            throwable[0] = thr;
+                        }
                     }
-                }
             );
 
             if (!failOptDexFile.isEmpty()) {
@@ -555,7 +557,7 @@ private static boolean extractDexDiffInternals(Context context, String dir, Stri
                     }
 
                     TinkerLog.w(TAG, "success recover dex file: %s, size: %d, use time: %d",
-                        extractedFile.getPath(), extractedFile.length(), (System.currentTimeMillis() - start));
+                            extractedFile.getPath(), extractedFile.length(), (System.currentTimeMillis() - start));
                 }
             }
             if (!mergeClassNDexFiles(context, patchFile, dir)) {
@@ -592,7 +594,7 @@ private static boolean extractDexToJar(ZipFile zipFile, ZipEntry entryFile, File
             TinkerLog.i(TAG, "try Extracting " + extractTo.getPath());
             try {
                 zos = new ZipOutputStream(new
-                    BufferedOutputStream(new FileOutputStream(extractTo)));
+                        BufferedOutputStream(new FileOutputStream(extractTo)));
                 bis = new BufferedInputStream(zipFile.getInputStream(entryFile));
 
                 byte[] buffer = new byte[ShareConstants.BUFFER_SIZE];
@@ -657,8 +659,8 @@ private static boolean extractDexFile(ZipFile zipFile, ZipEntry entryFile, File
      * @throws IOException
      */
     private static void patchDexFile(
-        ZipFile baseApk, ZipFile patchPkg, ZipEntry oldDexEntry, ZipEntry patchFileEntry,
-        ShareDexDiffPatchInfo patchInfo, File patchedDexFile) throws IOException {
+            ZipFile baseApk, ZipFile patchPkg, ZipEntry oldDexEntry, ZipEntry patchFileEntry,
+            ShareDexDiffPatchInfo patchInfo, File patchedDexFile) throws IOException {
         InputStream oldDexStream = null;
         InputStream patchFileStream = null;
         try {
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/ResDiffPatchInternal.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/ResDiffPatchInternal.java
index cfd9ebf9..13828ee6 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/ResDiffPatchInternal.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/ResDiffPatchInternal.java
@@ -52,6 +52,7 @@
 
     protected static boolean tryRecoverResourceFiles(Tinker manager, ShareSecurityCheck checker, Context context,
                                                 String patchVersionDirectory, File patchFile) {
+        TinkerLog.e(TAG, "tryRecoverResourceFiles begin...");
 
         if (!manager.isEnabledForResource()) {
             TinkerLog.w(TAG, "patch recover, resource is not enabled");
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/UpgradePatch.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/UpgradePatch.java
index f60425de..0690356c 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/UpgradePatch.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/UpgradePatch.java
@@ -41,6 +41,8 @@
 
     @Override
     public boolean tryPatch(Context context, String tempPatchPath, PatchResult patchResult) {
+        TinkerLog.e(TAG, "UpgradePatch tryPatch begin...");
+
         Tinker manager = Tinker.with(context);
 
         final File patchFile = new File(tempPatchPath);
@@ -100,7 +102,7 @@ public boolean tryPatch(Context context, String tempPatchPath, PatchResult patch
             }
             // if it is interpret now, use changing flag to wait main process
             final String finalOatDir = oldInfo.oatDir.equals(ShareConstants.INTERPRET_DEX_OPTIMIZE_PATH)
-                ? ShareConstants.CHANING_DEX_OPTIMIZE_PATH : oldInfo.oatDir;
+                    ? ShareConstants.CHANING_DEX_OPTIMIZE_PATH : oldInfo.oatDir;
             newInfo = new SharePatchInfo(oldInfo.oldVersion, patchMd5, false, Build.FINGERPRINT, finalOatDir);
         } else {
             newInfo = new SharePatchInfo("", patchMd5, false, Build.FINGERPRINT, ShareConstants.DEFAULT_DEX_OPTIMIZE_PATH);
@@ -123,7 +125,7 @@ public boolean tryPatch(Context context, String tempPatchPath, PatchResult patch
             if (!patchMd5.equals(SharePatchFileUtil.getMD5(destPatchFile))) {
                 SharePatchFileUtil.copyFileUsingStream(patchFile, destPatchFile);
                 TinkerLog.w(TAG, "UpgradePatch copy patch file, src file: %s size: %d, dest file: %s size:%d", patchFile.getAbsolutePath(), patchFile.length(),
-                    destPatchFile.getAbsolutePath(), destPatchFile.length());
+                        destPatchFile.getAbsolutePath(), destPatchFile.length());
             }
         } catch (IOException e) {
 //            e.printStackTrace();
@@ -161,6 +163,7 @@ public boolean tryPatch(Context context, String tempPatchPath, PatchResult patch
         }
 
         TinkerLog.w(TAG, "UpgradePatch tryPatch: done, it is ok");
+        TinkerLog.e(TAG, "UpgradePatch tryPatch end...");
         return true;
     }
 
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/TinkerPatchService.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/TinkerPatchService.java
index c2d3df66..f26fe826 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/TinkerPatchService.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/TinkerPatchService.java
@@ -23,6 +23,7 @@
 import android.os.Build;
 import android.os.IBinder;
 import android.os.SystemClock;
+import android.support.annotation.Nullable;
 
 import com.tencent.tinker.lib.patch.AbstractPatch;
 import com.tencent.tinker.lib.tinker.Tinker;
@@ -50,6 +51,18 @@
     private static int notificationId = ShareConstants.TINKER_PATCH_SERVICE_NOTIFICATION;
     private static Class<? extends AbstractResultService> resultServiceClass = null;
 
+    @Override
+    public void onCreate() {
+        super.onCreate();
+        TinkerLog.i(TAG, "TinkerPatchService onCreate...");
+    }
+
+    @Override
+    public int onStartCommand(@Nullable Intent intent, int flags, int startId) {
+        TinkerLog.i(TAG, "TinkerPatchService onStartCommand...");
+        return super.onStartCommand(intent, flags, startId);
+    }
+
     public static void runPatchService(final Context context, final String path) {
         TinkerLog.i(TAG, "run patch service...");
         Intent intent = new Intent(context, TinkerPatchService.class);
@@ -89,6 +102,7 @@ public static String getPatchResultExtra(Intent intent) {
 
     /**
      * set the tinker notification id you want
+     *
      * @param id
      */
     public static void setTinkerNotificationId(int id) {
@@ -101,7 +115,7 @@ public static void setTinkerNotificationId(int id) {
     private static void doApplyPatch(Context context, Intent intent) {
         // Since we may retry with IntentService, we should prevent
         // racing here again.
-        TinkerLog.w(TAG, "doApplyPatch.");
+        TinkerLog.w(TAG, "doApplyPatch begin...");
 
         if (!sIsPatchApplying.compareAndSet(false, true)) {
             TinkerLog.w(TAG, "TinkerPatchService doApplyPatch is running by another runner.");
@@ -141,7 +155,7 @@ private static void doApplyPatch(Context context, Intent intent) {
 
         cost = SystemClock.elapsedRealtime() - begin;
         tinker.getPatchReporter().
-            onPatchResult(patchFile, result, cost);
+                onPatchResult(patchFile, result, cost);
 
         patchResult.isSuccess = result;
         patchResult.rawPatchFilePath = path;
@@ -151,12 +165,15 @@ private static void doApplyPatch(Context context, Intent intent) {
         AbstractResultService.runResultService(context, patchResult, getPatchResultExtra(intent));
 
         sIsPatchApplying.set(false);
+        TinkerLog.w(TAG, "doApplyPatch end...");
     }
 
     @Override
     protected void onHandleWork(Intent intent) {
+        TinkerLog.e(TAG, "onHandleWork begin...");
         increasingPriority();
         doApplyPatch(this, intent);
+        TinkerLog.e(TAG, "onHandleWork end...");
     }
 
     private void increasingPriority() {
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerLoadResult.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerLoadResult.java
index 5828798b..1a170c7b 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerLoadResult.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerLoadResult.java
@@ -155,7 +155,6 @@ public boolean parseTinkerResult(Context context, Intent intentResult) {
             case ShareConstants.ERROR_LOAD_PATCH_INFO_NOT_EXIST:
                 TinkerLog.w(TAG, "can't find patch file, is ok, just return");
                 break;
-
             case ShareConstants.ERROR_LOAD_PATCH_INFO_CORRUPTED:
                 TinkerLog.e(TAG, "path info corrupted");
                 tinker.getLoadReporter().onLoadPatchInfoCorrupted(oldVersion, newVersion, patchInfoFile);
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/TinkerJobIntentService.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/TinkerJobIntentService.java
index eeba83b8..2562eada 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/TinkerJobIntentService.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/TinkerJobIntentService.java
@@ -46,26 +46,26 @@
 /**
  * This class is copied and renamed from JobIntentService in android support compat
  * library 28.0.0-alpha1. Some changes was made for adapting Tinker's specific usage.
- *
+ * <p>
  * Since We can't get rid of the resources dependencies that android support compat library
  * has to include with, instead of hacking into the gradle dependency mechanism We choose to
  * copy what we need directly. Copy with renaming is to avoid conflicting when developers
  * happen to include android support compat library which has the same class in their App.
- *
+ * <p>
  * Helper for processing work that has been enqueued for a job/service.  When running on
  * {@link android.os.Build.VERSION_CODES#O Android O} or later, the work will be dispatched
  * as a job via {@link android.app.job.JobScheduler#enqueue JobScheduler.enqueue}.  When running
  * on older versions of the platform, it will use
  * {@link android.content.Context#startService Context.startService}.
- *
+ * <p>
  * <p>You must publish your subclass in your manifest for the system to interact with.  This
  * should be published as a {@link android.app.job.JobService}, as described for that class,
  * since on O and later platforms it will be executed that way.</p>
- *
+ * <p>
  * <p>Use {@link #enqueueWork(Context, Class, int, Intent)} to enqueue new work to be
  * dispatched to and handled by your service.  It will be executed in
  * {@link #onHandleWork(Intent)}.</p>
- *
+ * <p>
  * <p>You do not need to use {@link android.support.v4.content.WakefulBroadcastReceiver}
  * when using this class.  When running on {@link android.os.Build.VERSION_CODES#O Android O},
  * the JobScheduler will take care of wake locks for you (holding a wake lock from the time
@@ -73,33 +73,33 @@
  * on previous versions of the platform, this wake lock handling is emulated in the class here
  * by directly calling the PowerManager; this means the application must request the
  * {@link android.Manifest.permission#WAKE_LOCK} permission.</p>
- *
+ * <p>
  * <p>There are a few important differences in behavior when running on
  * {@link android.os.Build.VERSION_CODES#O Android O} or later as a Job vs. pre-O:</p>
- *
+ * <p>
  * <ul>
- *     <li><p>When running as a pre-O service, the act of enqueueing work will generally start
- *     the service immediately, regardless of whether the device is dozing or in other
- *     conditions.  When running as a Job, it will be subject to standard JobScheduler
- *     policies for a Job with a {@link android.app.job.JobInfo.Builder#setOverrideDeadline(long)}
- *     of 0: the job will not run while the device is dozing, it may get delayed more than
- *     a service if the device is under strong memory pressure with lots of demand to run
- *     jobs.</p></li>
- *     <li><p>When running as a pre-O service, the normal service execution semantics apply:
- *     the service can run indefinitely, though the longer it runs the more likely the system
- *     will be to outright kill its process, and under memory pressure one should expect
- *     the process to be killed even of recently started services.  When running as a Job,
- *     the typical {@link android.app.job.JobService} execution time limit will apply, after
- *     which the job will be stopped (cleanly, not by killing the process) and rescheduled
- *     to continue its execution later.  Job are generally not killed when the system is
- *     under memory pressure, since the number of concurrent jobs is adjusted based on the
- *     memory state of the device.</p></li>
+ * <li><p>When running as a pre-O service, the act of enqueueing work will generally start
+ * the service immediately, regardless of whether the device is dozing or in other
+ * conditions.  When running as a Job, it will be subject to standard JobScheduler
+ * policies for a Job with a {@link android.app.job.JobInfo.Builder#setOverrideDeadline(long)}
+ * of 0: the job will not run while the device is dozing, it may get delayed more than
+ * a service if the device is under strong memory pressure with lots of demand to run
+ * jobs.</p></li>
+ * <li><p>When running as a pre-O service, the normal service execution semantics apply:
+ * the service can run indefinitely, though the longer it runs the more likely the system
+ * will be to outright kill its process, and under memory pressure one should expect
+ * the process to be killed even of recently started services.  When running as a Job,
+ * the typical {@link android.app.job.JobService} execution time limit will apply, after
+ * which the job will be stopped (cleanly, not by killing the process) and rescheduled
+ * to continue its execution later.  Job are generally not killed when the system is
+ * under memory pressure, since the number of concurrent jobs is adjusted based on the
+ * memory state of the device.</p></li>
  * </ul>
- *
+ * <p>
  * <p>Here is an example implementation of this class:</p>
- *
+ * <p>
  * {@sample frameworks/support/samples/Support4Demos/src/main/java/com/example/android/supportv4/app/SimpleJobIntentService.java
- *      complete}
+ * complete}
  */
 public abstract class TinkerJobIntentService extends Service {
     static final String TAG = "TinkerJobIntentService";
@@ -159,6 +159,7 @@ public void serviceProcessingFinished() {
      */
     interface CompatJobEngine {
         IBinder compatGetBinder();
+
         GenericWorkItem dequeueWork();
     }
 
@@ -194,7 +195,8 @@ public void serviceProcessingFinished() {
         void enqueueWork(Intent work) {
             Intent intent = new Intent(work);
             intent.setComponent(mComponentName);
-            if (DEBUG) Log.d(TAG, "Starting service for work result_extra:" + work.getSerializableExtra(AbstractResultService.RESULT_EXTRA));
+            if (DEBUG)
+                Log.d(TAG, "Starting service for work result_extra:" + work.getSerializableExtra(AbstractResultService.RESULT_EXTRA));
             if (mContext.startService(intent) != null) {
                 synchronized (this) {
                     if (!mLaunchingService) {
@@ -379,6 +381,7 @@ void enqueueWork(Intent work) {
      */
     interface GenericWorkItem {
         Intent getIntent();
+
         void complete();
     }
 
@@ -454,7 +457,7 @@ public TinkerJobIntentService() {
     @Override
     public void onCreate() {
         super.onCreate();
-        if (DEBUG) Log.d(TAG, "CREATING: " + this);
+        if (DEBUG) Log.d(TAG, "TinkerJobIntentService onCreate..." + this);
         if (Build.VERSION.SDK_INT >= 26) {
             mJobImpl = new JobServiceEngineImpl(this);
             mCompatWorkEnqueuer = null;
@@ -471,7 +474,9 @@ public void onCreate() {
      */
     @Override
     public int onStartCommand(@Nullable Intent intent, int flags, int startId) {
-        if (DEBUG) Log.d(TAG, "ONSTARTCOMMAND RESULT_EXTRA: " + intent.getSerializableExtra(AbstractResultService.RESULT_EXTRA));
+        if (DEBUG) {
+            Log.d(TAG, "TinkerJobIntentService onStartCommand..." + intent.getSerializableExtra(AbstractResultService.RESULT_EXTRA));
+        }
         if (mCompatQueue != null) {
             mCompatWorkEnqueuer.serviceStartReceived();
             if (DEBUG) Log.d(TAG, "Received compat start command #" + startId + ": " + intent);
@@ -521,11 +526,11 @@ public void onDestroy() {
      * appear at {@link #onHandleWork(Intent)}.
      *
      * @param context Context this is being called from.
-     * @param cls The concrete class the work should be dispatched to (this is the class that
-     * is published in your manifest).
-     * @param jobId A unique job ID for scheduling; must be the same value for all work
-     * enqueued for the same class.
-     * @param work The Intent of work to enqueue.
+     * @param cls     The concrete class the work should be dispatched to (this is the class that
+     *                is published in your manifest).
+     * @param jobId   A unique job ID for scheduling; must be the same value for all work
+     *                enqueued for the same class.
+     * @param work    The Intent of work to enqueue.
      */
     public static void enqueueWork(@NonNull Context context, @NonNull Class cls, int jobId,
                                    @NonNull Intent work) {
@@ -536,18 +541,19 @@ public static void enqueueWork(@NonNull Context context, @NonNull Class cls, int
      * Like {@link #enqueueWork(Context, Class, int, Intent)}, but supplies a ComponentName
      * for the service to interact with instead of its class.
      *
-     * @param context Context this is being called from.
+     * @param context   Context this is being called from.
      * @param component The published ComponentName of the class this work should be
-     * dispatched to.
-     * @param jobId A unique job ID for scheduling; must be the same value for all work
-     * enqueued for the same class.
-     * @param work The Intent of work to enqueue.
+     *                  dispatched to.
+     * @param jobId     A unique job ID for scheduling; must be the same value for all work
+     *                  enqueued for the same class.
+     * @param work      The Intent of work to enqueue.
      */
     public static void enqueueWork(@NonNull Context context, @NonNull ComponentName component,
                                    int jobId, @NonNull Intent work) {
         if (work == null) {
             throw new IllegalArgumentException("work must not be null");
         }
+        Log.e(TAG, "enqueueWork jobId : " + jobId);
         // TODO: 2019/3/5 获取补丁任务对象
         synchronized (sLock) {
             WorkEnqueuer we = getWorkEnqueuer(context, component, true, jobId);
@@ -579,7 +585,7 @@ static WorkEnqueuer getWorkEnqueuer(Context context, ComponentName cn, boolean h
      * here.  Upon returning, that work will be considered complete and either the next
      * pending work dispatched here or the overall service destroyed now that it has
      * nothing else to do.
-     *
+     * <p>
      * <p>Be aware that when running as a job, you are limited by the maximum job execution
      * time and any single or total sequential items of work that exceeds that limit will
      * cause the service to be stopped while in progress and later restarted with the
@@ -598,7 +604,7 @@ static WorkEnqueuer getWorkEnqueuer(Context context, ComponentName cn, boolean h
      * task.
      *
      * @param interruptIfStopped Set to true to allow the system to interrupt actively
-     * running work.
+     *                           running work.
      */
     public void setInterruptIfStopped(boolean interruptIfStopped) {
         mInterruptIfStopped = interruptIfStopped;
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/UpgradePatchRetry.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/UpgradePatchRetry.java
index 0c6c1cfd..ff2aa0e0 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/UpgradePatchRetry.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/UpgradePatchRetry.java
@@ -35,7 +35,7 @@
  * optional
  * tinker :patch process may killed by some reason, we can retry it to increase upgrade success rate
  * if patch file is at sdcard, copy it to dataDir first. because some software may delete it.
- *
+ * <p>
  * Created by zhangshaowen on 16/7/3.
  */
 public class UpgradePatchRetry {
@@ -45,12 +45,12 @@
     private static final String TEMP_PATCH_NAME = "temp.apk";
 
     private static final String RETRY_FILE_MD5_PROPERTY = "md5";
-    private static final String RETRY_COUNT_PROPERTY    = "times";
-    private static final int    RETRY_MAX_COUNT         = 55;//最大重复次数
+    private static final String RETRY_COUNT_PROPERTY = "times";
+    private static final int RETRY_MAX_COUNT = 55;//最大重复次数
     private static UpgradePatchRetry sInstance;
     private boolean isRetryEnable = true;
-    private File    retryInfoFile = null;
-    private File    tempPatchFile = null;
+    private File retryInfoFile = null;
+    private File tempPatchFile = null;
     private Context context = null;
     private int maxRetryCount = RETRY_MAX_COUNT;
 
@@ -85,6 +85,7 @@ public void setMaxRetryCount(int count) {
     }
 
     public boolean onPatchRetryLoad() {
+        TinkerLog.d(TAG, "onPatchRetryLoad begin...");
         if (!isRetryEnable) {
             TinkerLog.w(TAG, "onPatchRetryLoad retry disabled, just return");
             return false;
@@ -216,6 +217,7 @@ public boolean onPatchResetMaxCheck(String md5) {
         }
         return true;
     }
+
     /**
      * if we receive any result, we can delete the temp retry info file
      */
diff --git a/tinker-sample/build.gradle b/tinker-sample/build.gradle
index 43724ed5..df1a9206 100644
--- a/tinker-sample/build.gradle
+++ b/tinker-sample/build.gradle
@@ -131,14 +131,14 @@ ext {
 
     //for normal build
     //old apk file to build patch apk
-    tinkerOldApkPath = "${bakPath}/tinker-sample-debug-0308-17-13-33.apk"
+    tinkerOldApkPath = "${bakPath}/tinker-sample-debug-0311-18-03-22.apk"
     //proguard mapping file to build patch apk
-    tinkerApplyMappingPath = "${bakPath}/tinker-sample-debug-0308-17-13-33-mapping.txt"
+    tinkerApplyMappingPath = "${bakPath}/tinker-sample-debug-0311-18-03-22-mapping.txt"
     //resource R.txt to build patch apk, must input if there is resource changed
-    tinkerApplyResourcePath = "${bakPath}/tinker-sample-debug-0308-17-13-33-R.txt"
+    tinkerApplyResourcePath = "${bakPath}/tinker-sample-debug-0311-18-03-22-R.txt"
 
     //only use for build all flavor, if not, just ignore this field
-    tinkerBuildFlavorDirectory = "${bakPath}/tinker-sample-debug-0308-17-13-33"
+    tinkerBuildFlavorDirectory = "${bakPath}/tinker-sample-debug-0311-18-03-22"
 }
 
 
diff --git a/tinker-sample/src/main/java/tinker/sample/android/app/MyApplicationLike.java b/tinker-sample/src/main/java/tinker/sample/android/app/MyApplicationLike.java
index 8a72cb3e..745ace57 100644
--- a/tinker-sample/src/main/java/tinker/sample/android/app/MyApplicationLike.java
+++ b/tinker-sample/src/main/java/tinker/sample/android/app/MyApplicationLike.java
@@ -28,6 +28,7 @@
 import com.tencent.tinker.entry.DefaultApplicationLike;
 import com.tencent.tinker.lib.tinker.Tinker;
 import com.tencent.tinker.lib.tinker.TinkerInstaller;
+import com.tencent.tinker.lib.util.TinkerLog;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
 
 import tinker.sample.android.log.MyLogImp;
@@ -38,27 +39,27 @@
  * because you can not use any other class in your application, we need to
  * move your implement of Application to {@link ApplicationLifeCycle}
  * As Application, all its direct reference class should be in the main dex.
- *
+ * <p>
  * We use tinker-android-anno to make sure all your classes can be patched.
- *
+ * <p>
  * application: if it is start with '.', we will add SampleApplicationLifeCycle's package name
- *
+ * <p>
  * flags:
  * TINKER_ENABLE_ALL: support dex, lib and resource
  * TINKER_DEX_MASK: just support dex
  * TINKER_NATIVE_LIBRARY_MASK: just support lib
  * TINKER_RESOURCE_MASK: just support resource
- *
+ * <p>
  * loaderClass: define the tinker loader class, we can just use the default TinkerLoader
- *
+ * <p>
  * loadVerifyFlag: whether check files' md5 on the load time, defualt it is false.
- *
+ * <p>
  * Created by zhangshaowen on 16/3/17.
  */
 @SuppressWarnings("unused")
 @DefaultLifeCycle(application = "tinker.sample.android.app.SampleApplication",
-                  flags = ShareConstants.TINKER_ENABLE_ALL,
-                  loadVerifyFlag = false)
+        flags = ShareConstants.TINKER_ENABLE_ALL,
+        loadVerifyFlag = false)
 public class MyApplicationLike extends DefaultApplicationLike {
     private static final String TAG = "Tinker.SampleApplicationLike";
 
@@ -77,6 +78,7 @@ public MyApplicationLike(Application application, int tinkerFlags, boolean tinke
     @Override
     public void onBaseContextAttached(Context base) {
         super.onBaseContextAttached(base);
+        TinkerLog.d(TAG, "onBaseContextAttached begin...");
         //you must install multiDex whatever tinker is installed!
         MultiDex.install(base);
 
diff --git a/tinker-sample/src/main/java/tinker/sample/android/reporter/MyLoadReporter.java b/tinker-sample/src/main/java/tinker/sample/android/reporter/MyLoadReporter.java
index 738e01ad..807597ca 100644
--- a/tinker-sample/src/main/java/tinker/sample/android/reporter/MyLoadReporter.java
+++ b/tinker-sample/src/main/java/tinker/sample/android/reporter/MyLoadReporter.java
@@ -19,6 +19,7 @@
 import android.content.Context;
 import android.os.Looper;
 import android.os.MessageQueue;
+import android.widget.Toast;
 
 import com.tencent.tinker.lib.reporter.DefaultLoadReporter;
 import com.tencent.tinker.lib.util.UpgradePatchRetry;
@@ -42,6 +43,7 @@ public MyLoadReporter(Context context) {
     public void onLoadPatchListenerReceiveFail(final File patchFile, int errorCode) {
         super.onLoadPatchListenerReceiveFail(patchFile, errorCode);
         MyTinkerReport.onTryApplyFail(errorCode);
+        Toast.makeText(context, "errorCode " + errorCode, Toast.LENGTH_SHORT).show();
     }
 
     @Override
diff --git a/tinker-sample/src/main/java/tinker/sample/android/reporter/MyPatchListener.java b/tinker-sample/src/main/java/tinker/sample/android/reporter/MyPatchListener.java
index 9568363e..4acf96f1 100644
--- a/tinker-sample/src/main/java/tinker/sample/android/reporter/MyPatchListener.java
+++ b/tinker-sample/src/main/java/tinker/sample/android/reporter/MyPatchListener.java
@@ -62,6 +62,8 @@ public MyPatchListener(Context context) {
      */
     @Override
     public int patchCheck(String path, String patchMd5) {
+        TinkerLog.i(TAG, "patchCheck begin...");
+
         File patchFile = new File(path);
         TinkerLog.i(TAG, "receive a patch file: %s, file size:%d", path, SharePatchFileUtil.getFileOrDirectorySize(patchFile));
         int returnCode = super.patchCheck(path, patchMd5);
diff --git a/tinker-sample/src/main/java/tinker/sample/android/util/TinkerManager.java b/tinker-sample/src/main/java/tinker/sample/android/util/TinkerManager.java
index cc0cec45..677b5344 100644
--- a/tinker-sample/src/main/java/tinker/sample/android/util/TinkerManager.java
+++ b/tinker-sample/src/main/java/tinker/sample/android/util/TinkerManager.java
@@ -38,7 +38,7 @@
 public class TinkerManager {
     private static final String TAG = "Tinker.TinkerManager";
 
-    private static ApplicationLike                applicationLike;
+    private static ApplicationLike applicationLike;
     private static MyUncaughtExceptionHandler uncaughtExceptionHandler;
     private static boolean isInstalled = false;
 
@@ -87,17 +87,17 @@ public static void installTinker(ApplicationLike appLike) {
             return;
         }
         //or you can just use DefaultLoadReporter
-        LoadReporter loadReporter = new MyLoadReporter(appLike.getApplication());
+        LoadReporter loadReporter = new MyLoadReporter(appLike.getApplication());//Load记录者，负责记录加载补丁包过程的状态信息
         //or you can just use DefaultPatchReporter
-        PatchReporter patchReporter = new MyPatchReporter(appLike.getApplication());
+        PatchReporter patchReporter = new MyPatchReporter(appLike.getApplication());//Patch记录者，负责记录合成补丁过程的状态信息
         //or you can just use DefaultPatchListener
-        PatchListener patchListener = new MyPatchListener(appLike.getApplication());
+        PatchListener patchListener = new MyPatchListener(appLike.getApplication());//Patch监听者，负责执行获取到补丁包后的后续操作
         //you can set your own upgrade patch if you need
-        AbstractPatch upgradePatchProcessor = new UpgradePatch();
+        AbstractPatch upgradePatchProcessor = new UpgradePatch();//Patch执行者，负责执行补丁的合成
 
         TinkerInstaller.install(appLike,
-            loadReporter, patchReporter, patchListener,
-            MyResultService.class, upgradePatchProcessor);
+                loadReporter, patchReporter, patchListener,
+                MyResultService.class, upgradePatchProcessor);
 
         isInstalled = true;
     }
