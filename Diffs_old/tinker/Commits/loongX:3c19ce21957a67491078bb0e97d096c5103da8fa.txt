diff --git a/.github/ISSUE_TEMPLATE.md b/.github/ISSUE_TEMPLATE.md
new file mode 100644
index 00000000..bf067267
--- /dev/null
+++ b/.github/ISSUE_TEMPLATE.md
@@ -0,0 +1,27 @@
+## Issue/提问须知
+**在提交issue之前，我们应该先查询是否已经有相关的issue以及[常见问题](https://github.com/Tencent/tinker/wiki/Tinker-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98)。提交issue时，我们需要写明issue的原因，以及编译或运行过程的日志(加载进程以及Patch进程)。issue需要以下面的格式：**
+
+```
+异常类型：app运行时异常/编译异常
+
+手机型号：如:Nexus 5(如是编译异常，则可以不填)
+
+手机系统版本：如:Android 5.0 (如是编译异常，则可以不填)
+
+tinker版本：如:1.7.7
+
+gradle版本：如:2.10
+
+是否使用热更新SDK： 如 TinkerPatch SDK 或者 Bugly SDK
+
+系统：如:Mac
+
+堆栈/日志：
+1. 如是编译异常，请在执行gradle命令时，加上--stacktrace;
+2. 日志我们需要过滤"Tinker."关键字;
+3. 对于合成失败的情况，请给出:patch进程的日志,这里需要将Android Moniter右上角设为No Filter。
+```
+
+提问题时若使用`不能用/没效果/有问题/报错`此类模糊表达，但又没给出任何代码截图报错的，将绝对不会有任何反馈。这种issue也是一律直接关闭的,大家可以参阅[提问的智慧](https://github.com/tvvocold/How-To-Ask-Questions-The-Smart-Way)。
+
+Tinker是一个开源项目，希望大家遇到问题时要学会先思考，看看sample与Tinker的源码，更鼓励大家给我们提pr.
\ No newline at end of file
diff --git a/README.md b/README.md
index 27a8f89d..678310fb 100644
--- a/README.md
+++ b/README.md
@@ -1,8 +1,8 @@
 ## Tinker
 [![license](http://img.shields.io/badge/license-BSD3-brightgreen.svg?style=flat)](https://github.com/Tencent/tinker/blob/master/LICENSE)
-[![Release Version](https://img.shields.io/badge/release-1.7.7-red.svg)](https://github.com/Tencent/tinker/releases) 
+[![Release Version](https://img.shields.io/badge/release-1.8.1-red.svg)](https://github.com/Tencent/tinker/releases)
 [![PRs Welcome](https://img.shields.io/badge/PRs-welcome-brightgreen.svg)](https://github.com/Tencent/tinker/pulls)
-[![WeChat Approved](https://img.shields.io/badge/Wechat_Approved-1.7.7-red.svg)](https://github.com/Tencent/tinker/wiki)
+[![WeChat Approved](https://img.shields.io/badge/Wechat_Approved-1.8.0-red.svg)](https://github.com/Tencent/tinker/wiki)
 
 Tinker is a hot-fix solution library for Android, it supports dex, library and resources update without reinstalling apk.
 
@@ -14,7 +14,7 @@ Add tinker-gradle-plugin as a dependency in your main `build.gradle` in the root
 ```gradle
 buildscript {
     dependencies {
-        classpath ('com.tencent.tinker:tinker-patch-gradle-plugin:1.7.7')
+        classpath ('com.tencent.tinker:tinker-patch-gradle-plugin:1.8.1')
     }
 }
 ```
@@ -24,9 +24,9 @@ Then you need to "apply" the plugin and add dependencies by adding the following
 ```gradle
 dependencies {
     //optional, help to generate the final application 
-    provided('com.tencent.tinker:tinker-android-anno:1.7.7')
+    provided('com.tencent.tinker:tinker-android-anno:1.8.1')
     //tinker's main Android lib
-    compile('com.tencent.tinker:tinker-android-lib:1.7.7') 
+    compile('com.tencent.tinker:tinker-android-lib:1.8.1')
 }
 ...
 ...
diff --git a/gradle.properties b/gradle.properties
index 2691a69d..2d41e243 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -16,5 +16,5 @@
 # This option should only be used with decoupled projects. More details, visit
 # http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
 # org.gradle.parallel=true
-VERSION_NAME_PREFIX=1.7.7
+VERSION_NAME_PREFIX=1.8.1
 VERSION_NAME_SUFFIX=
\ No newline at end of file
diff --git a/third-party/bsdiff-util/src/main/java/com/tencent/tinker/bsdiff/BSPatch.java b/third-party/bsdiff-util/src/main/java/com/tencent/tinker/bsdiff/BSPatch.java
index 2e8d7269..e31e4fd6 100644
--- a/third-party/bsdiff-util/src/main/java/com/tencent/tinker/bsdiff/BSPatch.java
+++ b/third-party/bsdiff-util/src/main/java/com/tencent/tinker/bsdiff/BSPatch.java
@@ -110,10 +110,10 @@ public static int patchLessMemory(RandomAccessFile oldFile, int oldsize, byte[]
             return RETURN_DIFF_FILE_ERR;
         }
 
-        int commentLenPos = oldsize - extLen - 2;
-        if (commentLenPos <= 2) {
-            return RETURN_OLD_FILE_ERR;
-        }
+//        int commentLenPos = oldsize - extLen - 2;
+//        if (commentLenPos <= 2) {
+//            return RETURN_OLD_FILE_ERR;
+//        }
 
         DataInputStream diffIn = new DataInputStream(new ByteArrayInputStream(diffBuf, 0, diffSize));
 
@@ -167,10 +167,10 @@ public static int patchLessMemory(RandomAccessFile oldFile, int oldsize, byte[]
                     return RETURN_DIFF_FILE_ERR;
                 }
                 for (int i = 0; i < ctrl[0]; i++) {
-                    if (oldpos + i == commentLenPos) {
-                        oldBuffer[i] = 0;
-                        oldBuffer[i + 1] = 0;
-                    }
+//                    if (oldpos + i == commentLenPos) {
+//                        oldBuffer[i] = 0;
+//                        oldBuffer[i + 1] = 0;
+//                    }
 
                     if ((oldpos + i >= 0) && (oldpos + i < oldsize)) {
                         buffer[i] += oldBuffer[i];
diff --git a/tinker-android/tinker-android-anno/src/main/java/com/tencent/tinker/anno/DefaultLifeCycle.java b/tinker-android/tinker-android-anno/src/main/java/com/tencent/tinker/anno/DefaultLifeCycle.java
index ddd5db1b..275c0c90 100644
--- a/tinker-android/tinker-android-anno/src/main/java/com/tencent/tinker/anno/DefaultLifeCycle.java
+++ b/tinker-android/tinker-android-anno/src/main/java/com/tencent/tinker/anno/DefaultLifeCycle.java
@@ -39,6 +39,4 @@
     int flags();
 
     boolean loadVerifyFlag() default false;
-
-
 }
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/library/TinkerLoadLibrary.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/library/TinkerLoadLibrary.java
index 5fa176b2..26f7d4c2 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/library/TinkerLoadLibrary.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/library/TinkerLoadLibrary.java
@@ -170,12 +170,26 @@ private static void installNativeLibraryPath(ClassLoader classLoader, File folde
             TinkerLog.e(TAG, "installNativeLibraryPath, folder %s is illegal", folder);
             return;
         }
-        if (Build.VERSION.SDK_INT >= 23) {
+        // android o sdk_int 26
+        // for android o preview sdk_int 25
+        if ((Build.VERSION.SDK_INT == 25 && Build.VERSION.PREVIEW_SDK_INT != 0)
+            || Build.VERSION.SDK_INT > 25) {
+            try {
+                V25.install(classLoader, folder);
+                return;
+            } catch (Throwable throwable) {
+                // install fail, try to treat it as v23
+                // some preview N version may go here
+                TinkerLog.e(TAG, "installNativeLibraryPath, v25 fail, sdk: %d, error: %s, try to fallback to V23",
+                        Build.VERSION.SDK_INT, throwable.getMessage());
+                V23.install(classLoader, folder);
+            }
+        } else if (Build.VERSION.SDK_INT >= 23) {
             try {
                 V23.install(classLoader, folder);
             } catch (Throwable throwable) {
                 // install fail, try to treat it as v14
-                TinkerLog.e(TAG, "installNativeLibraryPath, v23 fail, sdk: %d, error: %s",
+                TinkerLog.e(TAG, "installNativeLibraryPath, v23 fail, sdk: %d, error: %s, try to fallback to V14",
                     Build.VERSION.SDK_INT, throwable.getMessage());
 
                 V14.install(classLoader, folder);
@@ -235,4 +249,26 @@ private static void install(ClassLoader classLoader, File folder)  throws Throwa
         }
     }
 
+    private static final class V25 {
+        private static void install(ClassLoader classLoader, File folder)  throws Throwable {
+            Field pathListField = ShareReflectUtil.findField(classLoader, "pathList");
+            Object dexPathList = pathListField.get(classLoader);
+
+            Field nativeLibraryDirectories = ShareReflectUtil.findField(dexPathList, "nativeLibraryDirectories");
+
+            List<File> libDirs = (List<File>) nativeLibraryDirectories.get(dexPathList);
+            libDirs.add(0, folder);
+            Field systemNativeLibraryDirectories =
+                    ShareReflectUtil.findField(dexPathList, "systemNativeLibraryDirectories");
+            List<File> systemLibDirs = (List<File>) systemNativeLibraryDirectories.get(dexPathList);
+            Method makePathElements =
+                    ShareReflectUtil.findMethod(dexPathList, "makePathElements", List.class);
+            libDirs.addAll(systemLibDirs);
+            Object[] elements = (Object[]) makePathElements.
+                    invoke(dexPathList, libDirs);
+            Field nativeLibraryPathElements = ShareReflectUtil.findField(dexPathList, "nativeLibraryPathElements");
+            nativeLibraryPathElements.setAccessible(true);
+            nativeLibraryPathElements.set(dexPathList, elements);
+        }
+    }
 }
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/DefaultPatchListener.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/DefaultPatchListener.java
index 52651e30..7feebcef 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/DefaultPatchListener.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/DefaultPatchListener.java
@@ -20,7 +20,9 @@
 
 import com.tencent.tinker.lib.service.TinkerPatchService;
 import com.tencent.tinker.lib.tinker.Tinker;
+import com.tencent.tinker.lib.tinker.TinkerLoadResult;
 import com.tencent.tinker.lib.util.TinkerServiceInternals;
+import com.tencent.tinker.lib.util.UpgradePatchRetry;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
 import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
 import com.tencent.tinker.loader.shareutil.ShareTinkerInternals;
@@ -46,8 +48,9 @@ public DefaultPatchListener(Context context) {
      */
     @Override
     public int onPatchReceived(String path) {
+        File patchFile = new File(path);
 
-        int returnCode = patchCheck(path);
+        int returnCode = patchCheck(path, SharePatchFileUtil.getMD5(patchFile));
 
         if (returnCode == ShareConstants.ERROR_PATCH_OK) {
             TinkerPatchService.runPatchService(context, path);
@@ -55,10 +58,9 @@ public int onPatchReceived(String path) {
             Tinker.with(context).getLoadReporter().onLoadPatchListenerReceiveFail(new File(path), returnCode);
         }
         return returnCode;
-
     }
 
-    protected int patchCheck(String path) {
+    protected int patchCheck(String path, String patchMd5) {
         Tinker manager = Tinker.with(context);
         //check SharePreferences also
         if (!manager.isTinkerEnabled() || !ShareTinkerInternals.isTinkerEnableWithSharedPreferences(context)) {
@@ -79,6 +81,26 @@ protected int patchCheck(String path) {
         if (TinkerServiceInternals.isTinkerPatchServiceRunning(context)) {
             return ShareConstants.ERROR_PATCH_RUNNING;
         }
+        if (ShareTinkerInternals.isVmJit()) {
+            return ShareConstants.ERROR_PATCH_JIT;
+        }
+
+        Tinker tinker = Tinker.with(context);
+
+        if (tinker.isTinkerLoaded()) {
+            TinkerLoadResult tinkerLoadResult = tinker.getTinkerLoadResultIfPresent();
+            if (tinkerLoadResult != null && !tinkerLoadResult.useInterpretMode) {
+                String currentVersion = tinkerLoadResult.currentVersion;
+                if (patchMd5.equals(currentVersion)) {
+                    return ShareConstants.ERROR_PATCH_ALREADY_APPLY;
+                }
+            }
+        }
+
+        if (!UpgradePatchRetry.getInstance(context).onPatchListenerCheck(patchMd5)) {
+            return ShareConstants.ERROR_PATCH_RETRY_COUNT_LIMIT;
+        }
+
         return ShareConstants.ERROR_PATCH_OK;
     }
 
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/BasePatchInternal.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/BasePatchInternal.java
index 732166f2..d67c063e 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/BasePatchInternal.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/BasePatchInternal.java
@@ -36,7 +36,7 @@
 
     protected static final String DEX_PATH             = ShareConstants.DEX_PATH;
     protected static final String SO_PATH              = ShareConstants.SO_PATH;
-    protected static final String DEX_OPTIMIZE_PATH    = ShareConstants.DEX_OPTIMIZE_PATH;
+    protected static final String DEX_OPTIMIZE_PATH    = ShareConstants.DEFAULT_DEX_OPTIMIZE_PATH;
     protected static final int    MAX_EXTRACT_ATTEMPTS = ShareConstants.MAX_EXTRACT_ATTEMPTS;
     protected static final String DEX_META_FILE        = ShareConstants.DEX_META_FILE;
     protected static final String SO_META_FILE         = ShareConstants.SO_META_FILE;
@@ -45,6 +45,8 @@
     protected static final int TYPE_DEX         = ShareConstants.TYPE_DEX;
     protected static final int TYPE_Library     = ShareConstants.TYPE_LIBRARY;
     protected static final int TYPE_RESOURCE    = ShareConstants.TYPE_RESOURCE;
+    protected static final int TYPE_CLASS_N_DEX = ShareConstants.TYPE_CLASS_N_DEX;
+
 
     public static boolean extract(ZipFile zipFile, ZipEntry entryFile, File extractTo, String targetMd5, boolean isDex) throws IOException {
         int numAttempts = 0;
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java
index fa72d59b..52544cb6 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java
@@ -18,15 +18,21 @@
 
 import android.content.Context;
 import android.content.pm.ApplicationInfo;
+import android.os.Build;
 import android.os.SystemClock;
 
 import com.tencent.tinker.commons.dexpatcher.DexPatchApplier;
+import com.tencent.tinker.commons.resutil.ResUtil;
+import com.tencent.tinker.commons.ziputil.TinkerZipEntry;
+import com.tencent.tinker.commons.ziputil.TinkerZipFile;
+import com.tencent.tinker.commons.ziputil.TinkerZipOutputStream;
 import com.tencent.tinker.lib.tinker.Tinker;
 import com.tencent.tinker.lib.util.TinkerLog;
-import com.tencent.tinker.loader.TinkerParallelDexOptimizer;
+import com.tencent.tinker.loader.TinkerDexOptimizer;
 import com.tencent.tinker.loader.TinkerRuntimeException;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
 import com.tencent.tinker.loader.shareutil.ShareDexDiffPatchInfo;
+import com.tencent.tinker.loader.shareutil.ShareElfFile;
 import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
 import com.tencent.tinker.loader.shareutil.ShareSecurityCheck;
 import com.tencent.tinker.loader.shareutil.ShareTinkerInternals;
@@ -38,6 +44,8 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
 import java.util.List;
 import java.util.Vector;
 import java.util.zip.ZipEntry;
@@ -45,19 +53,19 @@
 import java.util.zip.ZipInputStream;
 import java.util.zip.ZipOutputStream;
 
-import dalvik.system.DexFile;
-
 /**
  * Created by zhangshaowen on 16/4/12.
  */
 public class DexDiffPatchInternal extends BasePatchInternal {
     protected static final String TAG = "Tinker.DexDiffPatchInternal";
 
-    protected static final int WAIT_ASYN_OAT_TIME = 8 * 1000;
+    protected static final int WAIT_ASYN_OAT_TIME = 15 * 1000;
     protected static final int MAX_WAIT_COUNT     = 30;
 
-    private static ArrayList<File> optFiles = new ArrayList<>();
-    private static List<File> failOptDexFile = new Vector<>();
+    private static ArrayList<File>                      optFiles      = new ArrayList<>();
+    private static ArrayList<ShareDexDiffPatchInfo>     patchList     = new ArrayList<>();
+    private static HashMap<ShareDexDiffPatchInfo, File> classNDexInfo = new HashMap<>();
+    private static boolean                              isVmArt       = ShareTinkerInternals.isVmArt();
 
 
     protected static boolean tryRecoverDexFiles(Tinker manager, ShareSecurityCheck checker, Context context,
@@ -80,16 +88,16 @@ protected static boolean tryRecoverDexFiles(Tinker manager, ShareSecurityCheck c
         return result;
     }
 
-    protected static boolean waitDexOptFile() {
+    protected static boolean waitAndCheckDexOptFile(File patchFile, Tinker manager) {
         if (optFiles.isEmpty()) {
             return true;
         }
-
-        int size = optFiles.size() * 6;
+        // should use patch list size
+        int size = patchList.size() * 8;
         if (size > MAX_WAIT_COUNT) {
             size = MAX_WAIT_COUNT;
         }
-        TinkerLog.i(TAG, "dex count: %d, final wait time: %d", optFiles.size(), size);
+        TinkerLog.i(TAG, "raw dex count: %d, dex opt dex count: %d, final wait times: %d", patchList.size(), optFiles.size(), size);
 
         for (int i = 0; i < size; i++) {
             if (!checkAllDexOptFile(optFiles, i + 1)) {
@@ -100,19 +108,59 @@ protected static boolean waitDexOptFile() {
                 }
             }
         }
-
+        List<File> failDexFiles = new ArrayList<>();
         // check again, if still can be found, just return
         for (File file : optFiles) {
-            TinkerLog.i(TAG, "check dex optimizer file %s, size %d", file.getName(), file.length());
+            TinkerLog.i(TAG, "check dex optimizer file exist: %s, size %d", file.getPath(), file.length());
 
             if (!SharePatchFileUtil.isLegalFile(file)) {
                 TinkerLog.e(TAG, "final parallel dex optimizer file %s is not exist, return false", file.getName());
-                // don't report fail
-//                manager.getPatchReporter()
-//                    .onPatchDexOptFail(patchFile, file, file.getParentFile().getPath(),
-//                        file.getName(), new TinkerRuntimeException("dexOpt file:" + file.getName() + " is not exist"));
-                return false;
+                failDexFiles.add(file);
+            }
+        }
+        if (!failDexFiles.isEmpty()) {
+            manager.getPatchReporter().onPatchDexOptFail(patchFile, failDexFiles,
+                new TinkerRuntimeException(ShareConstants.CHECK_DEX_OAT_EXIST_FAIL));
+            return false;
+        }
+        if (Build.VERSION.SDK_INT >= 21) {
+            Throwable lastThrowable = null;
+            for (File file : optFiles) {
+                TinkerLog.i(TAG, "check dex optimizer file format: %s, size %d", file.getName(), file.length());
+                int returnType;
+                try {
+                    returnType = ShareElfFile.getFileTypeByMagic(file);
+                } catch (IOException e) {
+                    // read error just continue
+                    continue;
+                }
+                if (returnType == ShareElfFile.FILE_TYPE_ELF) {
+                    ShareElfFile elfFile = null;
+                    try {
+                        elfFile = new ShareElfFile(file);
+                    } catch (Throwable e) {
+                        TinkerLog.e(TAG, "final parallel dex optimizer file %s is not elf format, return false", file.getName());
+                        failDexFiles.add(file);
+                        lastThrowable = e;
+                    } finally {
+                        if (elfFile != null) {
+                            try {
+                                elfFile.close();
+                            } catch (IOException ignore) {
 
+                            }
+                        }
+                    }
+                }
+            }
+            if (!failDexFiles.isEmpty()) {
+                Throwable returnThrowable = lastThrowable == null
+                    ? new TinkerRuntimeException(ShareConstants.CHECK_DEX_OAT_FORMAT_FAIL)
+                    : new TinkerRuntimeException(ShareConstants.CHECK_DEX_OAT_FORMAT_FAIL, lastThrowable);
+
+                manager.getPatchReporter().onPatchDexOptFail(patchFile, failDexFiles,
+                    returnThrowable);
+                return false;
             }
         }
         return true;
@@ -126,14 +174,132 @@ private static boolean patchDexExtractViaDexDiff(Context context, String patchVe
             return false;
         }
 
-        final Tinker manager = Tinker.with(context);
-
         File dexFiles = new File(dir);
         File[] files = dexFiles.listFiles();
+        List<File> dexList = files != null ? Arrays.asList(files) : null;
+
+        final String optimizeDexDirectory = patchVersionDirectory + "/" + DEX_OPTIMIZE_PATH + "/";
+        return dexOptimizeDexFiles(context, dexList, optimizeDexDirectory, patchFile);
+
+    }
+
+    private static boolean checkClassNDexFiles(final String dexFilePath) {
+       if (patchList.isEmpty() || !isVmArt) {
+            return false;
+        }
+        ShareDexDiffPatchInfo testInfo = null;
+        File testFile = null;
+
+        for (ShareDexDiffPatchInfo info : patchList) {
+            File dexFile = new File(dexFilePath + info.realName);
+            String fileName = dexFile.getName();
+
+            if (ShareConstants.CLASS_N_PATTERN.matcher(fileName).matches()) {
+                classNDexInfo.put(info, dexFile);
+            }
+            if (info.rawName.startsWith(ShareConstants.TEST_DEX_NAME)) {
+                testInfo = info;
+                testFile = dexFile;
+            }
+        }
+        if (testInfo != null) {
+            classNDexInfo.put(ShareTinkerInternals.changeTestDexToClassN(testInfo, classNDexInfo.size() + 1), testFile);
+        }
+
+        File classNFile = new File(dexFilePath, ShareConstants.CLASS_N_APK_NAME);
+        boolean result = true;
+        if (classNFile.exists()) {
+            for (ShareDexDiffPatchInfo info : classNDexInfo.keySet()) {
+                if (!SharePatchFileUtil.verifyDexFileMd5(classNFile, info.rawName, info.destMd5InArt)) {
+                    TinkerLog.e(TAG, "verify dex file md5 error, entry name; %s, file len: %d", info.rawName, classNFile.length());
+                    result = false;
+                    break;
+                }
+            }
+            if (!result) {
+                SharePatchFileUtil.safeDeleteFile(classNFile);
+            }
+        } else {
+            result = false;
+        }
+
+
+        return result;
+    }
+
+    private static boolean mergeClassNDexFiles(final Context context, final File patchFile, final String dexFilePath) {
+        // only merge for art vm
+        if (patchList.isEmpty() || !isVmArt) {
+            return true;
+        }
+
+        File classNFile = new File(dexFilePath, ShareConstants.CLASS_N_APK_NAME);
+
+        // repack just more than one classN.dex
+        if (classNDexInfo.isEmpty()) {
+            TinkerLog.w(TAG, "classNDexInfo size: %d, no need to merge classN dex files", classNDexInfo.size());
+            return true;
+        }
+        long start = System.currentTimeMillis();
+        boolean result = true;
+        TinkerZipOutputStream out = null;
+        try {
+            out = new TinkerZipOutputStream(new BufferedOutputStream(new FileOutputStream(classNFile)));
+            for (ShareDexDiffPatchInfo info : classNDexInfo.keySet()) {
+                File dexFile = classNDexInfo.get(info);
+
+                if (info.isJarMode) {
+                    TinkerZipFile dexZipFile = new TinkerZipFile(dexFile);
+                    TinkerZipEntry rawDexZipEntry = dexZipFile.getEntry(ShareConstants.DEX_IN_JAR);
+                    TinkerZipEntry newDexZipEntry = new TinkerZipEntry(rawDexZipEntry, info.rawName);
+                    InputStream inputStream = dexZipFile.getInputStream(rawDexZipEntry);
+                    try {
+                        ResUtil.extractTinkerEntry(newDexZipEntry, inputStream, out);
+                    } finally {
+                        SharePatchFileUtil.closeQuietly(inputStream);
+                    }
+                } else {
+                    TinkerZipEntry dexZipEntry = new TinkerZipEntry(info.rawName);
+                    ResUtil.extractLargeModifyFile(dexZipEntry, dexFile, Long.parseLong(info.newDexCrC), out);
+                }
+
+            }
+        } catch (Throwable throwable) {
+            TinkerLog.printErrStackTrace(TAG, throwable, "merge classN file");
+            result = false;
+        } finally {
+            SharePatchFileUtil.closeQuietly(out);
+        }
+
+        if (result) {
+            for (ShareDexDiffPatchInfo info : classNDexInfo.keySet()) {
+                if (!SharePatchFileUtil.verifyDexFileMd5(classNFile, info.rawName, info.destMd5InArt)) {
+                    result = false;
+                    TinkerLog.e(TAG, "verify dex file md5 error, entry name; %s, file len: %d", info.rawName, classNFile.length());
+                    break;
+                }
+            }
+        }
+        if (result) {
+            for (File dexFile : classNDexInfo.values()) {
+                SharePatchFileUtil.safeDeleteFile(dexFile);
+            }
+        } else {
+            TinkerLog.e(TAG, "merge classN dex error, try delete temp file");
+            SharePatchFileUtil.safeDeleteFile(classNFile);
+            Tinker.with(context).getPatchReporter().onPatchTypeExtractFail(patchFile, classNFile, classNFile.getName(), TYPE_CLASS_N_DEX);
+        }
+        TinkerLog.i(TAG, "merge classN dex file %s, result: %b, size: %d, use: %dms",
+            classNFile.getPath(), result, classNFile.length(), (System.currentTimeMillis() - start));
+        return result;
+    }
+
+    private static boolean dexOptimizeDexFiles(Context context, List<File> dexFiles, String optimizeDexDirectory, final File patchFile) {
+        final Tinker manager = Tinker.with(context);
+
         optFiles.clear();
 
-        if (files != null) {
-            final String optimizeDexDirectory = patchVersionDirectory + "/" + DEX_OPTIMIZE_PATH + "/";
+        if (dexFiles != null) {
             File optimizeDexDirectoryFile = new File(optimizeDexDirectory);
 
             if (!optimizeDexDirectoryFile.exists() && !optimizeDexDirectoryFile.mkdirs()) {
@@ -141,80 +307,49 @@ private static boolean patchDexExtractViaDexDiff(Context context, String patchVe
                 return false;
             }
             // add opt files
-            for (File file : files) {
+            for (File file : dexFiles) {
                 String outputPathName = SharePatchFileUtil.optimizedPathFor(file, optimizeDexDirectoryFile);
                 optFiles.add(new File(outputPathName));
             }
 
-            TinkerLog.w(TAG, "patch recover, try to optimize dex file count:%d", files.length);
-
+            TinkerLog.i(TAG, "patch recover, try to optimize dex file count:%d, optimizeDexDirectory:%s", dexFiles.size(), optimizeDexDirectory);
             // only use parallel dex optimizer for art
-            if (ShareTinkerInternals.isVmArt()) {
-                failOptDexFile.clear();
-                // try parallel dex optimizer
-                TinkerParallelDexOptimizer.optimizeAll(
-                    files, optimizeDexDirectoryFile,
-                    new TinkerParallelDexOptimizer.ResultCallback() {
-                        long startTime;
-
-                        @Override
-                        public void onStart(File dexFile, File optimizedDir) {
-                            startTime = System.currentTimeMillis();
-                            TinkerLog.i(TAG, "start to parallel optimize dex %s, size: %d", dexFile.getPath(), dexFile.length());
-                        }
-
-                        @Override
-                        public void onSuccess(File dexFile, File optimizedDir, File optimizedFile) {
-                            // Do nothing.
-                            TinkerLog.i(TAG, "success to parallel optimize dex %s, opt file size: %d, use time %d",
-                                dexFile.getPath(), optimizedFile.length(), (System.currentTimeMillis() - startTime));
-                        }
-
-                        @Override
-                        public void onFailed(File dexFile, File optimizedDir, Throwable thr) {
-                            TinkerLog.i(TAG, "fail to parallel optimize dex %s use time %d",
-                                dexFile.getPath(), (System.currentTimeMillis() - startTime));
-                            failOptDexFile.add(dexFile);
-                        }
+            // for Android O version, it is very strange. If we use parallel dex optimizer, it won't work
+            final List<File> failOptDexFile = new Vector<>();
+            final Throwable[] throwable = new Throwable[1];
+
+            // try parallel dex optimizer
+            TinkerDexOptimizer.optimizeAll(
+                dexFiles, optimizeDexDirectoryFile,
+                new TinkerDexOptimizer.ResultCallback() {
+                    long startTime;
+
+                    @Override
+                    public void onStart(File dexFile, File optimizedDir) {
+                        startTime = System.currentTimeMillis();
+                        TinkerLog.i(TAG, "start to parallel optimize dex %s, size: %d", dexFile.getPath(), dexFile.length());
                     }
-                );
-                // try again
-                for (File retryDexFile : failOptDexFile) {
-                    try {
-                        String outputPathName = SharePatchFileUtil.optimizedPathFor(retryDexFile, optimizeDexDirectoryFile);
-
-                        if (!SharePatchFileUtil.isLegalFile(retryDexFile)) {
-                            manager.getPatchReporter().onPatchDexOptFail(patchFile, retryDexFile,
-                                optimizeDexDirectory, retryDexFile.getName(), new TinkerRuntimeException("retry dex optimize file is not exist, name: " + retryDexFile.getName()));
-                            return false;
-                        }
-                        TinkerLog.i(TAG, "try to retry dex optimize file, path: %s, size: %d", retryDexFile.getPath(), retryDexFile.length());
-                        long start = System.currentTimeMillis();
-                        DexFile.loadDex(retryDexFile.getAbsolutePath(), outputPathName, 0);
 
-                        TinkerLog.i(TAG, "success retry dex optimize file, path: %s, opt file size: %d, use time: %d",
-                            retryDexFile.getPath(), new File(outputPathName).length(), (System.currentTimeMillis() - start));
-                    } catch (Throwable e) {
-                        TinkerLog.e(TAG, "retry dex optimize or load failed, path:" + retryDexFile.getPath());
-                        manager.getPatchReporter().onPatchDexOptFail(patchFile, retryDexFile, optimizeDexDirectory, retryDexFile.getName(), e);
-                        return false;
+                    @Override
+                    public void onSuccess(File dexFile, File optimizedDir, File optimizedFile) {
+                        // Do nothing.
+                        TinkerLog.i(TAG, "success to parallel optimize dex %s, opt file:%s, opt file size: %d, use time %d",
+                            dexFile.getPath(), optimizedFile.getPath(), optimizedFile.length(), (System.currentTimeMillis() - startTime));
                     }
-                }
-            // for dalvik, machine hardware performance is much worse than art machine
-            } else {
-                for (File file : files) {
-                    try {
-                        String outputPathName = SharePatchFileUtil.optimizedPathFor(file, optimizeDexDirectoryFile);
-                        long start = System.currentTimeMillis();
-                        DexFile.loadDex(file.getAbsolutePath(), outputPathName, 0);
-                        TinkerLog.i(TAG, "success single dex optimize file, path: %s, opt file size: %d, use time: %d", file.getPath(), new File(outputPathName).length(),
-                            (System.currentTimeMillis() - start));
-                    } catch (Throwable e) {
-                        TinkerLog.e(TAG, "single dex optimize or load failed, path:" + file.getPath());
-                        manager.getPatchReporter().onPatchDexOptFail(patchFile, file, optimizeDexDirectory, file.getName(), e);
-                        return false;
+
+                    @Override
+                    public void onFailed(File dexFile, File optimizedDir, Throwable thr) {
+                        TinkerLog.i(TAG, "fail to parallel optimize dex %s use time %d",
+                            dexFile.getPath(), (System.currentTimeMillis() - startTime));
+                        failOptDexFile.add(dexFile);
+                        throwable[0] = thr;
                     }
                 }
+            );
+
+            if (!failOptDexFile.isEmpty()) {
+                manager.getPatchReporter().onPatchDexOptFail(patchFile, failOptDexFile, throwable[0]);
+                return false;
             }
         }
         return true;
@@ -223,6 +358,7 @@ public void onFailed(File dexFile, File optimizedDir, Throwable thr) {
     /**
      * for ViVo or some other rom, they would make dex2oat asynchronous
      * so we need to check whether oat file is actually generated.
+     *
      * @param files
      * @param count
      * @return
@@ -239,8 +375,7 @@ private static boolean checkAllDexOptFile(ArrayList<File> files, int count) {
 
     private static boolean extractDexDiffInternals(Context context, String dir, String meta, File patchFile, int type) {
         //parse
-        ArrayList<ShareDexDiffPatchInfo> patchList = new ArrayList<>();
-
+        patchList.clear();
         ShareDexDiffPatchInfo.parseDexDiffPatchInfo(meta, patchList);
 
         if (patchList.isEmpty()) {
@@ -263,10 +398,14 @@ private static boolean extractDexDiffInternals(Context context, String dir, Stri
                 TinkerLog.w(TAG, "applicationInfo == null!!!!");
                 return false;
             }
+
             String apkPath = applicationInfo.sourceDir;
             apk = new ZipFile(apkPath);
             patch = new ZipFile(patchFile);
-
+            if (checkClassNDexFiles(dir)) {
+                TinkerLog.w(TAG, "class n dex file %s is already exist, and md5 match, just continue", ShareConstants.CLASS_N_APK_NAME);
+                return true;
+            }
             for (ShareDexDiffPatchInfo info : patchList) {
                 long start = System.currentTimeMillis();
 
@@ -281,11 +420,11 @@ private static boolean extractDexDiffInternals(Context context, String dir, Stri
                 String dexDiffMd5 = info.dexDiffMd5;
                 String oldDexCrc = info.oldDexCrC;
 
-                if (!ShareTinkerInternals.isVmArt() && info.destMd5InDvm.equals("0")) {
+                if (!isVmArt && info.destMd5InDvm.equals("0")) {
                     TinkerLog.w(TAG, "patch dex %s is only for art, just continue", patchRealPath);
                     continue;
                 }
-                String extractedFileMd5 = ShareTinkerInternals.isVmArt() ? info.destMd5InArt : info.destMd5InDvm;
+                String extractedFileMd5 = isVmArt ? info.destMd5InArt : info.destMd5InDvm;
 
                 if (!SharePatchFileUtil.checkIfMd5Valid(extractedFileMd5)) {
                     TinkerLog.w(TAG, "meta file md5 invalid, type:%s, name: %s, md5: %s", ShareTinkerInternals.getTypeString(type), info.rawName, extractedFileMd5);
@@ -327,7 +466,7 @@ private static boolean extractDexDiffInternals(Context context, String dir, Stri
                     }
                 } else if (dexDiffMd5.equals("0")) {
                     // skip process old dex for real dalvik vm
-                    if (!ShareTinkerInternals.isVmArt()) {
+                    if (!isVmArt) {
                         continue;
                     }
 
@@ -391,9 +530,12 @@ private static boolean extractDexDiffInternals(Context context, String dir, Stri
                     }
 
                     TinkerLog.w(TAG, "success recover dex file: %s, size: %d, use time: %d",
-                            extractedFile.getPath(), extractedFile.length(), (System.currentTimeMillis() - start));
+                        extractedFile.getPath(), extractedFile.length(), (System.currentTimeMillis() - start));
                 }
             }
+            if (!mergeClassNDexFiles(context, patchFile, dir)) {
+                return false;
+            }
         } catch (Throwable e) {
             throw new TinkerRuntimeException("patch " + ShareTinkerInternals.getTypeString(type) + " extract failed (" + e.getMessage() + ").", e);
         } finally {
@@ -428,7 +570,7 @@ private static boolean extractDexToJar(ZipFile zipFile, ZipEntry entryFile, File
             TinkerLog.i(TAG, "try Extracting " + extractTo.getPath());
             try {
                 zos = new ZipOutputStream(new
-                        BufferedOutputStream(fos));
+                    BufferedOutputStream(fos));
                 bis = new BufferedInputStream(in);
 
                 byte[] buffer = new byte[ShareConstants.BUFFER_SIZE];
@@ -469,7 +611,7 @@ private static boolean extractDexToJar(ZipFile zipFile, ZipEntry entryFile, File
 //    }
 
     private static boolean extractDexFile(ZipFile zipFile, ZipEntry entryFile, File extractTo, ShareDexDiffPatchInfo dexInfo) throws IOException {
-        final String fileMd5 = ShareTinkerInternals.isVmArt() ? dexInfo.destMd5InArt : dexInfo.destMd5InDvm;
+        final String fileMd5 = isVmArt ? dexInfo.destMd5InArt : dexInfo.destMd5InDvm;
         final String rawName = dexInfo.rawName;
         final boolean isJarMode = dexInfo.isJarMode;
         //it is raw dex and we use jar mode, so we need to zip it!
@@ -481,26 +623,20 @@ private static boolean extractDexFile(ZipFile zipFile, ZipEntry entryFile, File
 
     /**
      * Generate patched dex file (May wrapped it by a jar if needed.)
-     * @param baseApk
-     *   OldApk.
-     * @param patchPkg
-     *   Patch package, it is also a zip file.
-     * @param oldDexEntry
-     *   ZipEntry of old dex.
-     * @param patchFileEntry
-     *   ZipEntry of patch file. (also ends with .dex) This could be null.
-     * @param patchInfo
-     *   Parsed patch info from package-meta.txt
-     * @param patchedDexFile
-     *   Patched dex file, may be a jar.
-     *
-     * <b>Notice: patchFileEntry and smallPatchInfoFile cannot both be null.</b>
      *
+     * @param baseApk        OldApk.
+     * @param patchPkg       Patch package, it is also a zip file.
+     * @param oldDexEntry    ZipEntry of old dex.
+     * @param patchFileEntry ZipEntry of patch file. (also ends with .dex) This could be null.
+     * @param patchInfo      Parsed patch info from package-meta.txt
+     * @param patchedDexFile Patched dex file, may be a jar.
+     *                       <p>
+     *                       <b>Notice: patchFileEntry and smallPatchInfoFile cannot both be null.</b>
      * @throws IOException
      */
     private static void patchDexFile(
-            ZipFile baseApk, ZipFile patchPkg, ZipEntry oldDexEntry, ZipEntry patchFileEntry,
-            ShareDexDiffPatchInfo patchInfo,  File patchedDexFile) throws IOException {
+        ZipFile baseApk, ZipFile patchPkg, ZipEntry oldDexEntry, ZipEntry patchFileEntry,
+        ShareDexDiffPatchInfo patchInfo, File patchedDexFile) throws IOException {
         InputStream oldDexStream = null;
         InputStream patchFileStream = null;
         try {
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/ResDiffPatchInternal.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/ResDiffPatchInternal.java
index 5bdbf310..ce7a5081 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/ResDiffPatchInternal.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/ResDiffPatchInternal.java
@@ -195,6 +195,8 @@ private static boolean extractResourceDiffInternals(Context context, String dir,
                     ResUtil.extractTinkerEntry(newApk, modZipEntry, out);
                     totalEntryCount++;
                 }
+                // set comment back
+                out.setComment(oldApk.getComment());
             } finally {
                 if (out != null) {
                     out.close();
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/UpgradePatch.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/UpgradePatch.java
index 72257dac..2ae8a1d3 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/UpgradePatch.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/UpgradePatch.java
@@ -64,23 +64,30 @@ public boolean tryPatch(Context context, String tempPatchPath, PatchResult patch
             return false;
         }
 
-        //it is a new patch, so we should not find a exist
-        SharePatchInfo oldInfo = manager.getTinkerLoadResultIfPresent().patchInfo;
         String patchMd5 = SharePatchFileUtil.getMD5(patchFile);
-
         if (patchMd5 == null) {
             TinkerLog.e(TAG, "UpgradePatch tryPatch:patch md5 is null, just return");
             return false;
         }
-
         //use md5 as version
         patchResult.patchVersion = patchMd5;
 
+        TinkerLog.i(TAG, "UpgradePatch tryPatch:patchMd5:%s", patchMd5);
+
+        //check ok, we can real recover a new patch
+        final String patchDirectory = manager.getPatchDirectory().getAbsolutePath();
+
+        File patchInfoLockFile = SharePatchFileUtil.getPatchInfoLockFile(patchDirectory);
+        File patchInfoFile = SharePatchFileUtil.getPatchInfoFile(patchDirectory);
+
+        SharePatchInfo oldInfo = SharePatchInfo.readAndCheckPropertyWithLock(patchInfoFile, patchInfoLockFile);
+
+        //it is a new patch, so we should not find a exist
         SharePatchInfo newInfo;
 
         //already have patch
         if (oldInfo != null) {
-            if (oldInfo.oldVersion == null || oldInfo.newVersion == null) {
+            if (oldInfo.oldVersion == null || oldInfo.newVersion == null || oldInfo.oatDir == null) {
                 TinkerLog.e(TAG, "UpgradePatch tryPatch:onPatchInfoCorrupted");
                 manager.getPatchReporter().onPatchInfoCorrupted(patchFile, oldInfo.oldVersion, oldInfo.newVersion);
                 return false;
@@ -91,26 +98,23 @@ public boolean tryPatch(Context context, String tempPatchPath, PatchResult patch
                 manager.getPatchReporter().onPatchVersionCheckFail(patchFile, oldInfo, patchMd5);
                 return false;
             }
-            newInfo = new SharePatchInfo(oldInfo.oldVersion, patchMd5, Build.FINGERPRINT);
+            // if it is interpret now, use changing flag to wait main process
+            final String finalOatDir = oldInfo.oatDir.equals(ShareConstants.INTERPRET_DEX_OPTIMIZE_PATH)
+                ? ShareConstants.CHANING_DEX_OPTIMIZE_PATH : oldInfo.oatDir;
+            newInfo = new SharePatchInfo(oldInfo.oldVersion, patchMd5, Build.FINGERPRINT, finalOatDir);
         } else {
-            newInfo = new SharePatchInfo("", patchMd5, Build.FINGERPRINT);
+            newInfo = new SharePatchInfo("", patchMd5, Build.FINGERPRINT, ShareConstants.DEFAULT_DEX_OPTIMIZE_PATH);
         }
 
-        //check ok, we can real recover a new patch
-        final String patchDirectory = manager.getPatchDirectory().getAbsolutePath();
-
-        TinkerLog.i(TAG, "UpgradePatch tryPatch:patchMd5:%s", patchMd5);
-
+        //it is a new patch, we first delete if there is any files
+        //don't delete dir for faster retry
+//        SharePatchFileUtil.deleteDir(patchVersionDirectory);
         final String patchName = SharePatchFileUtil.getPatchVersionDirectory(patchMd5);
 
         final String patchVersionDirectory = patchDirectory + "/" + patchName;
 
         TinkerLog.i(TAG, "UpgradePatch tryPatch:patchVersionDirectory:%s", patchVersionDirectory);
 
-        //it is a new patch, we first delete if there is any files
-        //don't delete dir for faster retry
-//        SharePatchFileUtil.deleteDir(patchVersionDirectory);
-
         //copy file
         File destPatchFile = new File(patchVersionDirectory + "/" + SharePatchFileUtil.getPatchVersionFile(patchMd5));
 
@@ -145,14 +149,12 @@ public boolean tryPatch(Context context, String tempPatchPath, PatchResult patch
         }
 
         // check dex opt file at last, some phone such as VIVO/OPPO like to change dex2oat to interpreted
-        // just warn
-        if (!DexDiffPatchInternal.waitDexOptFile()) {
+        if (!DexDiffPatchInternal.waitAndCheckDexOptFile(patchFile, manager)) {
             TinkerLog.e(TAG, "UpgradePatch tryPatch:new patch recover, check dex opt file failed");
+            return false;
         }
 
-        final File patchInfoFile = manager.getPatchInfoFile();
-
-        if (!SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile, newInfo, SharePatchFileUtil.getPatchInfoLockFile(patchDirectory))) {
+        if (!SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile, newInfo, patchInfoLockFile)) {
             TinkerLog.e(TAG, "UpgradePatch tryPatch:new patch recover, rewrite patch info failed");
             manager.getPatchReporter().onPatchInfoCorrupted(patchFile, newInfo.oldVersion, newInfo.newVersion);
             return false;
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultLoadReporter.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultLoadReporter.java
index a45555e9..f6f6b67c 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultLoadReporter.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultLoadReporter.java
@@ -21,8 +21,10 @@
 
 import com.tencent.tinker.lib.service.TinkerPatchService;
 import com.tencent.tinker.lib.tinker.Tinker;
+import com.tencent.tinker.lib.tinker.TinkerInstaller;
 import com.tencent.tinker.lib.tinker.TinkerLoadResult;
 import com.tencent.tinker.lib.util.TinkerLog;
+import com.tencent.tinker.lib.util.UpgradePatchRetry;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
 import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
 import com.tencent.tinker.loader.shareutil.SharePatchInfo;
@@ -58,7 +60,7 @@ public DefaultLoadReporter(Context context) {
      */
     @Override
     public void onLoadPatchListenerReceiveFail(File patchFile, int errorCode) {
-        TinkerLog.i(TAG, "patch loadReporter onLoadPatchListenerReceiveFail: patch receive fail:%s, code:%d",
+        TinkerLog.i(TAG, "patch loadReporter onLoadPatchListenerReceiveFail: patch receive fail: %s, code: %d",
             patchFile.getAbsolutePath(), errorCode);
     }
 
@@ -92,6 +94,8 @@ public void onLoadPatchVersionChanged(String oldVersion, String newVersion, File
         TinkerLog.i(TAG, "onLoadPatchVersionChanged, try kill all other process");
         //kill all other process to ensure that all process's code is the same.
         ShareTinkerInternals.killAllOtherProcess(context);
+        // reset retry count to 1, for interpret retry
+        UpgradePatchRetry.getInstance(context).onPatchResetMaxCheck(newVersion);
 
         //delete old patch files
         File[] files = patchDirectoryFile.listFiles();
@@ -105,6 +109,34 @@ public void onLoadPatchVersionChanged(String oldVersion, String newVersion, File
         }
     }
 
+    /**
+     * After system ota, we will try to load dex with interpret mode
+     *
+     * @param type type define as following
+     *             {@code ShareConstants.TYPE_INTERPRET_OK}                                    it is ok, using interpret mode
+     *             {@code ShareConstants.TYPE_INTERPRET_GET_INSTRUCTION_SET_ERROR}             get instruction set from exist oat file fail
+     *             {@code ShareConstants.TYPE_INTERPRET_COMMAND_ERROR}                         use command line to generate interpret oat file fail
+     * @param e
+     */
+    @Override
+    public void onLoadInterpret(int type, Throwable e) {
+        TinkerLog.i(TAG, "patch loadReporter onLoadInterpret: type: %d, throwable: %s",
+            type, e);
+        switch (type) {
+            case ShareConstants.TYPE_INTERPRET_GET_INSTRUCTION_SET_ERROR:
+                TinkerLog.e(TAG, "patch loadReporter onLoadInterpret fail, can get instruction set from existed oat file");
+                break;
+            case ShareConstants.TYPE_INTERPRET_COMMAND_ERROR:
+                TinkerLog.e(TAG, "patch loadReporter onLoadInterpret fail, command line to interpret return error");
+                break;
+            case ShareConstants.TYPE_INTERPRET_OK:
+                TinkerLog.i(TAG, "patch loadReporter onLoadInterpret ok");
+                break;
+        }
+
+        retryPatch();
+    }
+
     /**
      * some files is not found,
      * we'd like to recover the old patch with {@link TinkerPatchService} in OldPatchProcessor mode
@@ -117,15 +149,20 @@ public void onLoadPatchVersionChanged(String oldVersion, String newVersion, File
      *                    {@code ShareConstants.TYPE_DEX}         patch dex file or directory not found
      *                    {@code ShareConstants.TYPE_LIBRARY}     patch lib file or directory not found
      *                    {@code ShareConstants.TYPE_RESOURCE}    patch lib file or directory not found
-     *
      * @param isDirectory whether is directory for the file type
      */
     @Override
     public void onLoadFileNotFound(File file, int fileType, boolean isDirectory) {
-        TinkerLog.i(TAG, "patch loadReporter onLoadFileNotFound: patch file not found: %s, fileType:%d, isDirectory:%b",
+        TinkerLog.i(TAG, "patch loadReporter onLoadFileNotFound: patch file not found: %s, fileType: %d, isDirectory: %b",
             file.getAbsolutePath(), fileType, isDirectory);
 
-        checkAndCleanPatch();
+        // only try to recover opt file
+        // check dex opt file at last, some phone such as VIVO/OPPO like to change dex2oat to interpreted
+        if (fileType == ShareConstants.TYPE_DEX_OPT) {
+            retryPatch();
+        } else {
+            checkAndCleanPatch();
+        }
     }
 
     /**
@@ -142,7 +179,7 @@ public void onLoadFileNotFound(File file, int fileType, boolean isDirectory) {
      */
     @Override
     public void onLoadFileMd5Mismatch(File file, int fileType) {
-        TinkerLog.i(TAG, "patch load Reporter onLoadFileMd5Mismatch: patch file md5 mismatch file: %s, fileType:%d", file.getAbsolutePath(), fileType);
+        TinkerLog.i(TAG, "patch load Reporter onLoadFileMd5Mismatch: patch file md5 mismatch file: %s, fileType: %d", file.getAbsolutePath(), fileType);
         //clean patch for safety
         checkAndCleanPatch();
     }
@@ -174,7 +211,7 @@ public void onLoadPatchInfoCorrupted(String oldVersion, String newVersion, File
      */
     @Override
     public void onLoadResult(File patchDirectory, int loadCode, long cost) {
-        TinkerLog.i(TAG, "patch loadReporter onLoadResult: patch load result, path:%s, code:%d, cost:%d", patchDirectory.getAbsolutePath(), loadCode, cost);
+        TinkerLog.i(TAG, "patch loadReporter onLoadResult: patch load result, path:%s, code: %d, cost: %dms", patchDirectory.getAbsolutePath(), loadCode, cost);
         //you can just report the result here
     }
 
@@ -185,11 +222,11 @@ public void onLoadResult(File patchDirectory, int loadCode, long cost) {
      * you can disable patch as {@link DefaultLoadReporter#onLoadException(Throwable, int)}
      *
      * @param e
-     * @param errorCode    exception code
-     *                     {@code ShareConstants.ERROR_LOAD_EXCEPTION_UNKNOWN}        unknown exception
-     *                     {@code ShareConstants.ERROR_LOAD_EXCEPTION_DEX}            exception when load dex
-     *                     {@code ShareConstants.ERROR_LOAD_EXCEPTION_RESOURCE}       exception when load resource
-     *                     {@code ShareConstants.ERROR_LOAD_EXCEPTION_UNCAUGHT}       exception unCaught
+     * @param errorCode exception code
+     *                  {@code ShareConstants.ERROR_LOAD_EXCEPTION_UNKNOWN}        unknown exception
+     *                  {@code ShareConstants.ERROR_LOAD_EXCEPTION_DEX}            exception when load dex
+     *                  {@code ShareConstants.ERROR_LOAD_EXCEPTION_RESOURCE}       exception when load resource
+     *                  {@code ShareConstants.ERROR_LOAD_EXCEPTION_UNCAUGHT}       exception unCaught
      */
     @Override
     public void onLoadException(Throwable e, int errorCode) {
@@ -204,9 +241,6 @@ public void onLoadException(Throwable e, int errorCode) {
                 ShareTinkerInternals.setTinkerDisableWithSharedPreferences(context);
                 TinkerLog.i(TAG, "dex exception disable tinker forever with sp");
                 break;
-            case ShareConstants.ERROR_LOAD_EXCEPTION_DEX_OPT:
-                TinkerLog.i(TAG, "patch load parallel dex opt exception: %s", e);
-                break;
             case ShareConstants.ERROR_LOAD_EXCEPTION_RESOURCE:
                 if (e.getMessage().contains(ShareConstants.CHECK_RES_INSTALL_FAIL)) {
                     TinkerLog.e(TAG, "patch loadReporter onLoadException: tinker res check fail:" + e.getMessage());
@@ -220,6 +254,14 @@ public void onLoadException(Throwable e, int errorCode) {
                 TinkerLog.i(TAG, "patch loadReporter onLoadException: patch load unCatch exception: %s", e);
                 ShareTinkerInternals.setTinkerDisableWithSharedPreferences(context);
                 TinkerLog.i(TAG, "unCaught exception disable tinker forever with sp");
+
+                String uncaughtString = SharePatchFileUtil.checkTinkerLastUncaughtCrash(context);
+                if (!ShareTinkerInternals.isNullOrNil(uncaughtString)) {
+                    File laseCrashFile = SharePatchFileUtil.getPatchLastCrashFile(context);
+                    SharePatchFileUtil.safeDeleteFile(laseCrashFile);
+                    // found really crash reason
+                    TinkerLog.e(TAG, "tinker uncaught real exception:" + uncaughtString);
+                }
                 break;
             case ShareConstants.ERROR_LOAD_EXCEPTION_UNKNOWN:
                 TinkerLog.i(TAG, "patch loadReporter onLoadException: patch load unknown exception: %s", e);
@@ -251,7 +293,7 @@ public void onLoadException(Throwable e, int errorCode) {
     @Override
     public void onLoadPackageCheckFail(File patchFile, int errorCode) {
         TinkerLog.i(TAG, "patch loadReporter onLoadPackageCheckFail: "
-            + "load patch package check fail file path:%s, errorCode:%d", patchFile.getAbsolutePath(), errorCode);
+            + "load patch package check fail file path: %s, errorCode: %d", patchFile.getAbsolutePath(), errorCode);
         checkAndCleanPatch();
     }
 
@@ -274,9 +316,30 @@ public void checkAndCleanPatch() {
                     ShareTinkerInternals.killAllOtherProcess(context);
                 }
             }
-
         }
         tinker.cleanPatch();
 
     }
+
+    public boolean retryPatch() {
+        final Tinker tinker = Tinker.with(context);
+        if (!tinker.isMainProcess()) {
+            return false;
+        }
+
+        File patchVersionFile = tinker.getTinkerLoadResultIfPresent().patchVersionFile;
+        if (patchVersionFile != null) {
+            if (UpgradePatchRetry.getInstance(context).onPatchListenerCheck(SharePatchFileUtil.getMD5(patchVersionFile))) {
+                TinkerLog.i(TAG, "try to repair oat file on patch process");
+                TinkerInstaller.onReceiveUpgradePatch(context, patchVersionFile.getAbsolutePath());
+                return true;
+            }
+//          else {
+//                TinkerLog.i(TAG, "repair retry exceed must max time, just clean");
+//                checkAndCleanPatch();
+//            }
+        }
+
+        return false;
+    }
 }
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultPatchReporter.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultPatchReporter.java
index 9d1dca7e..cc43ae28 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultPatchReporter.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultPatchReporter.java
@@ -23,11 +23,14 @@
 import com.tencent.tinker.lib.service.DefaultTinkerResultService;
 import com.tencent.tinker.lib.tinker.Tinker;
 import com.tencent.tinker.lib.util.TinkerLog;
+import com.tencent.tinker.lib.util.UpgradePatchRetry;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
+import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
 import com.tencent.tinker.loader.shareutil.SharePatchInfo;
 import com.tencent.tinker.loader.shareutil.ShareTinkerInternals;
 
 import java.io.File;
+import java.util.List;
 
 /**
  * Created by zhangshaowen on 16/3/14.
@@ -37,6 +40,7 @@
  */
 public class DefaultPatchReporter implements PatchReporter {
     private static final String TAG = "Tinker.DefaultPatchReporter";
+    private static boolean shouldRetry = false;
     protected final Context context;
 
     public DefaultPatchReporter(Context context) {
@@ -53,6 +57,9 @@ public DefaultPatchReporter(Context context) {
     @Override
     public void onPatchServiceStart(Intent intent) {
         TinkerLog.i(TAG, "patchReporter onPatchServiceStart: patch service start");
+        shouldRetry = false;
+        UpgradePatchRetry.getInstance(context).onPatchServiceStart(intent);
+
     }
 
     /**
@@ -73,7 +80,7 @@ public void onPatchServiceStart(Intent intent) {
      */
     @Override
     public void onPatchPackageCheckFail(File patchFile, int errorCode) {
-        TinkerLog.i(TAG, "patchReporter onPatchPackageCheckFail: package check failed. path:%s, code:%d",
+        TinkerLog.i(TAG, "patchReporter onPatchPackageCheckFail: package check failed. path: %s, code: %d",
             patchFile.getAbsolutePath(), errorCode);
         //only meta corrupted, need to delete temp files. others is just in the check time!
         if (errorCode == ShareConstants.ERROR_PACKAGE_CHECK_DEX_META_CORRUPTED
@@ -94,7 +101,7 @@ public void onPatchPackageCheckFail(File patchFile, int errorCode) {
      */
     @Override
     public void onPatchVersionCheckFail(File patchFile, SharePatchInfo oldPatchInfo, String patchFileVersion) {
-        TinkerLog.i(TAG, "patchReporter onPatchVersionCheckFail: patch version exist. path:%s, version:%s",
+        TinkerLog.i(TAG, "patchReporter onPatchVersionCheckFail: patch version exist. path: %s, version: %s",
             patchFile.getAbsolutePath(), patchFileVersion);
         //no need to delete temp files, because it is only in the check time!
     }
@@ -114,7 +121,7 @@ public void onPatchVersionCheckFail(File patchFile, SharePatchInfo oldPatchInfo,
      */
     @Override
     public void onPatchTypeExtractFail(File patchFile, File extractTo, String filename, int fileType) {
-        TinkerLog.i(TAG, "patchReporter onPatchTypeExtractFail: file extract fail type:%s, path:%s, extractTo:%s, filename:%s",
+        TinkerLog.i(TAG, "patchReporter onPatchTypeExtractFail: file extract fail type: %s, path: %s, extractTo: %s, filename: %s",
             ShareTinkerInternals.getTypeString(fileType), patchFile.getPath(), extractTo.getPath(), filename);
         //delete temp files
         Tinker.with(context).cleanPatchByVersion(patchFile);
@@ -124,17 +131,24 @@ public void onPatchTypeExtractFail(File patchFile, File extractTo, String filena
      * dex opt failed
      *
      * @param patchFile      the input patch file to recover
-     * @param dexFile        the dex file
-     * @param optDirectory
-     * @param dexName        dexName try to dexOpt
+     * @param dexFiles       the dex files
+     * @param t
      */
     @Override
-    public void onPatchDexOptFail(File patchFile, File dexFile, String optDirectory, String dexName, Throwable t) {
-        TinkerLog.i(TAG, "patchReporter onPatchDexOptFail: dex opt fail path:%s, dexPath:%s, optDir:%s, dexName:%s",
-            patchFile.getAbsolutePath(), dexFile.getPath(), optDirectory, dexName);
+    public void onPatchDexOptFail(File patchFile, List<File> dexFiles, Throwable t) {
+        TinkerLog.i(TAG, "patchReporter onPatchDexOptFail: dex opt fail path: %s, dex size: %d",
+            patchFile.getAbsolutePath(), dexFiles.size());
         TinkerLog.printErrStackTrace(TAG, t, "onPatchDexOptFail:");
-        //delete temp files
-        Tinker.with(context).cleanPatchByVersion(patchFile);
+
+        // some phone such as VIVO/OPPO like to change dex2oat to interpreted may go here
+        // check oat file if it is elf format
+        if (t.getMessage().contains(ShareConstants.CHECK_DEX_OAT_EXIST_FAIL)
+            || t.getMessage().contains(ShareConstants.CHECK_DEX_OAT_FORMAT_FAIL)) {
+            shouldRetry = true;
+            deleteOptFiles(dexFiles);
+        } else {
+            Tinker.with(context).cleanPatchByVersion(patchFile);
+        }
     }
 
     /**
@@ -146,9 +160,12 @@ public void onPatchDexOptFail(File patchFile, File dexFile, String optDirectory,
      */
     @Override
     public void onPatchResult(File patchFile, boolean success, long cost) {
-        TinkerLog.i(TAG, "patchReporter onPatchResult: patch all result path:%s, success:%b, cost:%d",
+        TinkerLog.i(TAG, "patchReporter onPatchResult: patch all result path: %s, success: %b, cost: %d",
             patchFile.getAbsolutePath(), success, cost);
-        //you can just report the result here
+        // if should retry don't delete the temp file
+        if (!shouldRetry) {
+            UpgradePatchRetry.getInstance(context).onPatchServiceResult();
+        }
     }
 
     /**
@@ -161,7 +178,7 @@ public void onPatchResult(File patchFile, boolean success, long cost) {
      */
     @Override
     public void onPatchInfoCorrupted(File patchFile, String oldVersion, String newVersion) {
-        TinkerLog.i(TAG, "patchReporter onPatchInfoCorrupted: patch info is corrupted. old:%s, new:%s",
+        TinkerLog.i(TAG, "patchReporter onPatchInfoCorrupted: patch info is corrupted. old: %s, new: %s",
             oldVersion, newVersion);
         //patch.info is corrupted, just clean all patch
         Tinker.with(context).cleanPatch();
@@ -177,7 +194,7 @@ public void onPatchInfoCorrupted(File patchFile, String oldVersion, String newVe
      */
     @Override
     public void onPatchException(File patchFile, Throwable e) {
-        TinkerLog.i(TAG, "patchReporter onPatchException: patch exception path:%s, throwable:%s",
+        TinkerLog.i(TAG, "patchReporter onPatchException: patch exception path: %s, throwable: %s",
             patchFile.getAbsolutePath(), e.getMessage());
         TinkerLog.e(TAG, "tinker patch exception, welcome to submit issue to us: https://github.com/Tencent/tinker/issues");
 //        if (e.getMessage().contains(ShareConstants.CHECK_VM_PROPERTY_FAIL)) {
@@ -190,4 +207,11 @@ public void onPatchException(File patchFile, Throwable e) {
         ////delete temp files, I think we don't have to clean all patch
         Tinker.with(context).cleanPatchByVersion(patchFile);
     }
+
+    private void deleteOptFiles(List<File> dexFiles) {
+        for (File file : dexFiles) {
+            SharePatchFileUtil.safeDeleteFile(file);
+        }
+    }
+
 }
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/LoadReporter.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/LoadReporter.java
index 6ff69254..48818506 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/LoadReporter.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/LoadReporter.java
@@ -52,6 +52,15 @@
      */
     void onLoadPatchVersionChanged(String oldVersion, String newVersion, File patchDirectoryFile, String currentPatchName);
 
+    /**
+     * After system ota, we will try to load dex with interpret mode
+     * @param type type define as following
+     *             {@code ShareConstants.TYPE_INTERPRET_OK}                                    it is ok, using interpret mode
+     *             {@code ShareConstants.TYPE_INTERPRET_GET_INSTRUCTION_SET_ERROR}             get instruction set from exist oat file fail
+     *             {@code ShareConstants.TYPE_INTERPRET_COMMAND_ERROR}                         use command line to generate interpret oat file fail
+     * @param e
+     */
+    void onLoadInterpret(int type, Throwable e);
     /**
      * the load patch process is end, we can see the cost times and the return code
      * return codes are define in {@link com.tencent.tinker.loader.shareutil.ShareConstants}
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/PatchReporter.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/PatchReporter.java
index 7ba65da4..fee683bf 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/PatchReporter.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/PatchReporter.java
@@ -24,6 +24,7 @@
 import com.tencent.tinker.loader.shareutil.SharePatchInfo;
 
 import java.io.File;
+import java.util.List;
 
 /**
  * Created by zhangshaowen on 16/3/14.
@@ -89,12 +90,10 @@
      * dex opt failed
      *
      * @param patchFile      the input patch file to recover
-     * @param dexFile        the dex file
-     * @param optDirectory
-     * @param dexName        dexName try to dexOpt
+     * @param dexFiles       the dex file
      * @param t              throwable
      */
-    void onPatchDexOptFail(File patchFile, File dexFile, String optDirectory, String dexName, Throwable t);
+    void onPatchDexOptFail(File patchFile, List<File> dexFiles, Throwable t);
 
 
     /**
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/Tinker.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/Tinker.java
index 3cc8aa01..ce514be5 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/Tinker.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/Tinker.java
@@ -266,6 +266,21 @@ public void cleanPatch() {
         SharePatchFileUtil.deleteDir(patchDirectory);
     }
 
+    /**
+     * rollback patch should restart all process
+     */
+    public void rollbackPatch() {
+        if (!isTinkerLoaded()) {
+            TinkerLog.w(TAG, "rollbackPatch: tinker is not loaded, just return");
+            return;
+        }
+        // kill all other process
+        ShareTinkerInternals.killAllOtherProcess(context);
+        // clean patch
+        cleanPatch();
+        // kill itself
+        android.os.Process.killProcess(android.os.Process.myPid());
+    }
     /**
      * clean the patch version files, such as tinker/patch-641e634c
      *
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerLoadResult.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerLoadResult.java
index 3b5b06f2..e50fa87a 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerLoadResult.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerLoadResult.java
@@ -40,10 +40,14 @@
     public SharePatchInfo patchInfo;
     //@Nullable
     public String         currentVersion;
+    //@Nullable
+    public String         oatDir;
+
+    public boolean versionChanged;
 
-    public boolean                 versionChanged;
+    public boolean useInterpretMode;
 
-    public boolean                 systemOTA;
+    public boolean systemOTA;
 
     //@Nullable
     public File                    patchVersionDirectory;
@@ -74,8 +78,14 @@ public boolean parseTinkerResult(Context context, Intent intentResult) {
 
         costTime = ShareIntentUtil.getIntentPatchCostTime(intentResult);
         systemOTA = ShareIntentUtil.getBooleanExtra(intentResult, ShareIntentUtil.INTENT_PATCH_SYSTEM_OTA, false);
+        oatDir = ShareIntentUtil.getStringExtra(intentResult, ShareIntentUtil.INTENT_PATCH_OAT_DIR);
+        useInterpretMode = ShareConstants.INTERPRET_DEX_OPTIMIZE_PATH.equals(oatDir);
+
+        final boolean isMainProcess = tinker.isMainProcess();
+
+        TinkerLog.i(TAG, "parseTinkerResult loadCode:%d, process name:%s, main process:%b, systemOTA:%b, fingerPrint:%s, oatDir:%s, useInterpretMode:%b",
+            loadCode, ShareTinkerInternals.getProcessName(context), isMainProcess, systemOTA, Build.FINGERPRINT, oatDir, useInterpretMode);
 
-        TinkerLog.i(TAG, "parseTinkerResult loadCode:%d, systemOTA:%b", loadCode, systemOTA);
         //@Nullable
         final String oldVersion = ShareIntentUtil.getStringExtra(intentResult, ShareIntentUtil.INTENT_PATCH_OLD_VERSION);
         //@Nullable
@@ -84,9 +94,6 @@ public boolean parseTinkerResult(Context context, Intent intentResult) {
         final File patchDirectory = tinker.getPatchDirectory();
         final File patchInfoFile = tinker.getPatchInfoFile();
 
-        final boolean isMainProcess = tinker.isMainProcess();
-
-
         if (oldVersion != null && newVersion != null) {
             if (isMainProcess) {
                 currentVersion = newVersion;
@@ -106,7 +113,7 @@ public boolean parseTinkerResult(Context context, Intent intentResult) {
                 resourceDirectory = new File(patchVersionDirectory, ShareConstants.RES_PATH);
                 resourceFile = new File(resourceDirectory, ShareConstants.RES_NAME);
             }
-            patchInfo = new SharePatchInfo(oldVersion, newVersion, Build.FINGERPRINT);
+            patchInfo = new SharePatchInfo(oldVersion, newVersion, Build.FINGERPRINT, oatDir);
             versionChanged = !(oldVersion.equals(newVersion));
         }
 
@@ -122,9 +129,6 @@ public boolean parseTinkerResult(Context context, Intent intentResult) {
                 case ShareConstants.ERROR_LOAD_PATCH_VERSION_DEX_LOAD_EXCEPTION:
                     errorCode = ShareConstants.ERROR_LOAD_EXCEPTION_DEX;
                     break;
-                case ShareConstants.ERROR_LOAD_PATCH_VERSION_PARALLEL_DEX_OPT_EXCEPTION:
-                    errorCode = ShareConstants.ERROR_LOAD_EXCEPTION_DEX_OPT;
-                    break;
                 case ShareConstants.ERROR_LOAD_PATCH_VERSION_RESOURCE_LOAD_EXCEPTION:
                     errorCode = ShareConstants.ERROR_LOAD_EXCEPTION_RESOURCE;
                     break;
@@ -307,6 +311,12 @@ public boolean parseTinkerResult(Context context, Intent intentResult) {
                 tinker.getLoadReporter().onLoadFileMd5Mismatch(resourceFile,
                     ShareConstants.TYPE_RESOURCE);
                 break;
+            case ShareConstants.ERROR_LOAD_PATCH_GET_OTA_INSTRUCTION_SET_EXCEPTION:
+                tinker.getLoadReporter().onLoadInterpret(ShareConstants.TYPE_INTERPRET_GET_INSTRUCTION_SET_ERROR, ShareIntentUtil.getIntentInterpretException(intentResult));
+                break;
+            case ShareConstants.ERROR_LOAD_PATCH_OTA_INTERPRET_ONLY_EXCEPTION:
+                tinker.getLoadReporter().onLoadInterpret(ShareConstants.TYPE_INTERPRET_COMMAND_ERROR, ShareIntentUtil.getIntentInterpretException(intentResult));
+                break;
             case ShareConstants.ERROR_LOAD_OK:
                 TinkerLog.i(TAG, "oh yeah, tinker load all success");
                 tinker.setTinkerLoaded(true);
@@ -316,6 +326,9 @@ public boolean parseTinkerResult(Context context, Intent intentResult) {
 
                 packageConfig = ShareIntentUtil.getIntentPackageConfig(intentResult);
 
+                if (useInterpretMode) {
+                    tinker.getLoadReporter().onLoadInterpret(ShareConstants.TYPE_INTERPRET_OK, null);
+                }
                 if (isMainProcess && versionChanged) {
                     //change the old version to new
                     tinker.getLoadReporter().onLoadPatchVersionChanged(oldVersion, newVersion, patchDirectory, patchVersionDirectory.getName());
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/TinkerLog.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/TinkerLog.java
index cb677c5d..6a75ed36 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/TinkerLog.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/TinkerLog.java
@@ -26,39 +26,39 @@
     private static TinkerLogImp debugLog = new TinkerLogImp() {
 
         @Override
-        public void v(final String tag, final String msg, final Object... obj) {
-            String log = obj == null ? msg : String.format(msg, obj);
+        public void v(final String tag, final String format, final Object... params) {
+            String log = (params == null || params.length == 0) ? format : String.format(format, params);
             android.util.Log.v(tag, log);
         }
 
         @Override
-        public void i(final String tag, final String msg, final Object... obj) {
-            String log = obj == null ? msg : String.format(msg, obj);
+        public void i(final String tag, final String format, final Object... params) {
+            String log = (params == null || params.length == 0) ? format : String.format(format, params);
             android.util.Log.i(tag, log);
 
         }
 
         @Override
-        public void d(final String tag, final String msg, final Object... obj) {
-            String log = obj == null ? msg : String.format(msg, obj);
+        public void d(final String tag, final String format, final Object... params) {
+            String log = (params == null || params.length == 0) ? format : String.format(format, params);
             android.util.Log.d(tag, log);
         }
 
         @Override
-        public void w(final String tag, final String msg, final Object... obj) {
-            String log = obj == null ? msg : String.format(msg, obj);
+        public void w(final String tag, final String format, final Object... params) {
+            String log = (params == null || params.length == 0) ? format : String.format(format, params);
             android.util.Log.w(tag, log);
         }
 
         @Override
-        public void e(final String tag, final String msg, final Object... obj) {
-            String log = obj == null ? msg : String.format(msg, obj);
+        public void e(final String tag, final String format, final Object... params) {
+            String log = (params == null || params.length == 0) ? format : String.format(format, params);
             android.util.Log.e(tag, log);
         }
 
         @Override
-        public void printErrStackTrace(String tag, Throwable tr, String format, Object... obj) {
-            String log = obj == null ? format : String.format(format, obj);
+        public void printErrStackTrace(String tag, Throwable tr, String format, Object... params) {
+            String log = (params == null || params.length == 0) ? format : String.format(format, params);
             if (log == null) {
                 log = "";
             }
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/util/UpgradePatchRetry.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/UpgradePatchRetry.java
similarity index 86%
rename from tinker-sample-android/app/src/main/java/tinker/sample/android/util/UpgradePatchRetry.java
rename to tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/UpgradePatchRetry.java
index a714b94f..9272d6bc 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/util/UpgradePatchRetry.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/UpgradePatchRetry.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package tinker.sample.android.util;
+package com.tencent.tinker.lib.util;
 
 import android.content.Context;
 import android.content.Intent;
@@ -22,8 +22,6 @@
 import com.tencent.tinker.lib.service.TinkerPatchService;
 import com.tencent.tinker.lib.tinker.Tinker;
 import com.tencent.tinker.lib.tinker.TinkerInstaller;
-import com.tencent.tinker.lib.util.TinkerLog;
-import com.tencent.tinker.lib.util.TinkerServiceInternals;
 import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
 
 import java.io.File;
@@ -32,8 +30,6 @@
 import java.io.IOException;
 import java.util.Properties;
 
-import tinker.sample.android.reporter.SampleTinkerReport;
-
 /**
  * optional
  * tinker :patch process may killed by some reason, we can retry it to increase upgrade success rate
@@ -49,15 +45,13 @@
 
     private static final String RETRY_FILE_MD5_PROPERTY = "md5";
     private static final String RETRY_COUNT_PROPERTY    = "times";
-    private static final int    RETRY_MAX_COUNT         = 4;
-
-
-    private boolean isRetryEnable = false;
+    private static final int    RETRY_MAX_COUNT         = 5;
+    private static UpgradePatchRetry sInstance;
+    private boolean isRetryEnable = true;
     private File    retryInfoFile = null;
     private File    tempPatchFile = null;
-
     private Context context = null;
-    private static UpgradePatchRetry sInstance;
+    private int maxRetryCount = RETRY_MAX_COUNT;
 
     /**
      * you must set after tinker has installed
@@ -77,36 +71,48 @@ public static UpgradePatchRetry getInstance(Context context) {
         return sInstance;
     }
 
-    public void onPatchRetryLoad() {
+    public void setRetryEnable(boolean enable) {
+        isRetryEnable = enable;
+    }
+
+    public void setMaxRetryCount(int count) {
+        if (count <= 0) {
+            TinkerLog.e(TAG, "max count must large than 0");
+            return;
+        }
+        maxRetryCount = count;
+    }
+
+    public boolean onPatchRetryLoad() {
         if (!isRetryEnable) {
             TinkerLog.w(TAG, "onPatchRetryLoad retry disabled, just return");
-            return;
+            return false;
         }
         Tinker tinker = Tinker.with(context);
         //only retry on main process
         if (!tinker.isMainProcess()) {
             TinkerLog.w(TAG, "onPatchRetryLoad retry is not main process, just return");
-            return;
+            return false;
         }
 
         if (!retryInfoFile.exists()) {
             TinkerLog.w(TAG, "onPatchRetryLoad retry info not exist, just return");
-            return;
+            return false;
         }
 
         if (TinkerServiceInternals.isTinkerPatchServiceRunning(context)) {
             TinkerLog.w(TAG, "onPatchRetryLoad tinker service is running, just return");
-            return;
+            return false;
         }
         //must use temp file
         String path = tempPatchFile.getAbsolutePath();
         if (path == null || !new File(path).exists()) {
             TinkerLog.w(TAG, "onPatchRetryLoad patch file: %s is not exist, just return", path);
-            return;
+            return false;
         }
         TinkerLog.w(TAG, "onPatchRetryLoad patch file: %s is exist, retry to patch", path);
         TinkerInstaller.onReceiveUpgradePatch(context, path);
-        SampleTinkerReport.onReportRetryPatch();
+        return true;
     }
 
     public void onPatchServiceStart(Intent intent) {
@@ -144,7 +150,7 @@ public void onPatchServiceStart(Intent intent) {
                 retryInfo.times = "1";
             } else {
                 int nowTimes = Integer.parseInt(retryInfo.times);
-                if (nowTimes >= RETRY_MAX_COUNT) {
+                if (nowTimes >= maxRetryCount) {
                     SharePatchFileUtil.safeDeleteFile(tempPatchFile);
                     TinkerLog.w(TAG, "onPatchServiceStart retry more than max count, delete retry info file!");
                     return;
@@ -177,7 +183,7 @@ public boolean onPatchListenerCheck(String md5) {
         RetryInfo retryInfo = RetryInfo.readRetryProperty(retryInfoFile);
         if (md5.equals(retryInfo.md5)) {
             int nowTimes = Integer.parseInt(retryInfo.times);
-            if (nowTimes >= RETRY_MAX_COUNT) {
+            if (nowTimes >= maxRetryCount) {
                 TinkerLog.w(TAG, "onPatchListenerCheck, retry count %d must exceed than max retry count", nowTimes);
                 SharePatchFileUtil.safeDeleteFile(tempPatchFile);
                 return false;
@@ -185,6 +191,29 @@ public boolean onPatchListenerCheck(String md5) {
         }
         return true;
     }
+
+    public boolean onPatchResetMaxCheck(String md5) {
+        if (!isRetryEnable) {
+            TinkerLog.w(TAG, "onPatchResetMaxCheck retry disabled, just return");
+            return true;
+        }
+        if (!retryInfoFile.exists()) {
+            TinkerLog.w(TAG, "onPatchResetMaxCheck retry file is not exist, just return");
+            return true;
+        }
+        if (md5 == null) {
+            TinkerLog.w(TAG, "onPatchResetMaxCheck md5 is null, just return");
+            return true;
+        }
+        RetryInfo retryInfo = RetryInfo.readRetryProperty(retryInfoFile);
+
+        if (md5.equals(retryInfo.md5)) {
+            TinkerLog.i(TAG, "onPatchResetMaxCheck, reset max check to 1");
+            retryInfo.times = "1";
+            RetryInfo.writeRetryProperty(retryInfoFile, retryInfo);
+        }
+        return true;
+    }
     /**
      * if we receive any result, we can delete the temp retry info file
      */
@@ -198,13 +227,9 @@ public void onPatchServiceResult() {
         if (tempPatchFile.exists()) {
             SharePatchFileUtil.safeDeleteFile(tempPatchFile);
         }
-    }
 
-    public void setRetryEnable(boolean enable) {
-        isRetryEnable = enable;
     }
 
-
     private void copyToTempFile(File patchFile) {
         if (patchFile.getAbsolutePath().equals(tempPatchFile.getAbsolutePath())) {
             return;
diff --git a/tinker-android/tinker-android-loader/src/main/AndroidManifest.xml b/tinker-android/tinker-android-loader/src/main/AndroidManifest.xml
index 8b6db826..5a8b047a 100644
--- a/tinker-android/tinker-android-loader/src/main/AndroidManifest.xml
+++ b/tinker-android/tinker-android-loader/src/main/AndroidManifest.xml
@@ -1,8 +1,6 @@
-<manifest
-    package="com.tencent.tinker.loader">
-
+<manifest package="com.tencent.tinker.loader"
+          xmlns:android="http://schemas.android.com/apk/res/android">
     <application>
-
     </application>
 
 </manifest>
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AbstractTinkerLoader.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AbstractTinkerLoader.java
index 111e38c2..926977df 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AbstractTinkerLoader.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AbstractTinkerLoader.java
@@ -25,5 +25,5 @@
  * Created by zhangshaowen on 16/4/30.
  */
 public abstract class AbstractTinkerLoader {
-    abstract public Intent tryLoad(TinkerApplication app, int tinkerFlag, boolean tinkerLoadVerifyFlag);
+    abstract public Intent tryLoad(TinkerApplication app);
 }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AndroidNClassLoader.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AndroidNClassLoader.java
index 3fa21b51..aa156098 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AndroidNClassLoader.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AndroidNClassLoader.java
@@ -24,10 +24,8 @@
 import com.tencent.tinker.loader.shareutil.ShareReflectUtil;
 
 import java.io.File;
-import java.io.IOException;
+import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
-import java.lang.reflect.Method;
-import java.util.ArrayList;
 import java.util.List;
 
 import dalvik.system.DexFile;
@@ -38,42 +36,81 @@
  */
 @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
 class AndroidNClassLoader extends PathClassLoader {
-    static ArrayList<DexFile> oldDexFiles = new ArrayList<>();
-    PathClassLoader originClassLoader;
+    private static final String TAG = "Tinker.NClassLoader";
 
-    private AndroidNClassLoader(String dexPath, PathClassLoader parent) {
+    private final PathClassLoader originClassLoader;
+    private String applicationClassName;
+
+    private AndroidNClassLoader(String dexPath, PathClassLoader parent, Application application) {
         super(dexPath, parent.getParent());
         originClassLoader = parent;
+        String name = application.getClass().getName();
+        if (name != null && !name.equals("android.app.Application")) {
+            applicationClassName = name;
+        }
     }
 
-    private static AndroidNClassLoader createAndroidNClassLoader(PathClassLoader original) throws Exception {
-        //let all element ""
-        AndroidNClassLoader androidNClassLoader = new AndroidNClassLoader("",  original);
-        Field originPathList = ShareReflectUtil.findField(original, "pathList");
-        Object originPathListObject = originPathList.get(original);
-        //should reflect definingContext also
-        Field originClassloader = ShareReflectUtil.findField(originPathListObject, "definingContext");
-        originClassloader.set(originPathListObject, androidNClassLoader);
-        //copy pathList
-        Field pathListField = ShareReflectUtil.findField(androidNClassLoader, "pathList");
-        //just use PathClassloader's pathList
-        pathListField.set(androidNClassLoader, originPathListObject);
-
-        //we must recreate dexFile due to dexCache
-        List<File> additionalClassPathEntries = new ArrayList<>();
-        Field dexElement = ShareReflectUtil.findField(originPathListObject, "dexElements");
-        Object[] originDexElements = (Object[]) dexElement.get(originPathListObject);
-        for (Object element : originDexElements) {
-            DexFile dexFile = (DexFile) ShareReflectUtil.findField(element, "dexFile").get(element);
-            additionalClassPathEntries.add(new File(dexFile.getName()));
-            //protect for java.lang.AssertionError: Failed to close dex file in finalizer.
-            oldDexFiles.add(dexFile);
+    @SuppressWarnings("unchecked")
+    private static Object recreateDexPathList(Object originalDexPathList, ClassLoader newDefiningContext) throws Exception {
+        final Field dexElementsField = ShareReflectUtil.findField(originalDexPathList, "dexElements");
+        final Object[] dexElements = (Object[]) dexElementsField.get(originalDexPathList);
+        final Field nativeLibraryDirectoriesField = ShareReflectUtil.findField(originalDexPathList, "nativeLibraryDirectories");
+        final List<File> nativeLibraryDirectories = (List<File>) nativeLibraryDirectoriesField.get(originalDexPathList);
+
+        final StringBuilder dexPathBuilder = new StringBuilder();
+        final Field dexFileField = ShareReflectUtil.findField(dexElements.getClass().getComponentType(), "dexFile");
+
+        boolean isFirstItem = true;
+        for (Object dexElement : dexElements) {
+            final DexFile dexFile = (DexFile) dexFileField.get(dexElement);
+            if (dexFile == null) {
+                continue;
+            }
+            if (isFirstItem) {
+                isFirstItem = false;
+            } else {
+                dexPathBuilder.append(File.pathSeparator);
+            }
+            dexPathBuilder.append(dexFile.getName());
         }
-        Method makePathElements = ShareReflectUtil.findMethod(originPathListObject, "makePathElements", List.class, File.class,
-            List.class);
-        ArrayList<IOException> suppressedExceptions = new ArrayList<>();
-        Object[] newDexElements = (Object[]) makePathElements.invoke(originPathListObject, additionalClassPathEntries, null, suppressedExceptions);
-        dexElement.set(originPathListObject, newDexElements);
+
+        final String dexPath = dexPathBuilder.toString();
+
+        final StringBuilder libraryPathBuilder = new StringBuilder();
+        isFirstItem = true;
+        for (File libDir : nativeLibraryDirectories) {
+            if (libDir == null) {
+                continue;
+            }
+            if (isFirstItem) {
+                isFirstItem = false;
+            } else {
+                libraryPathBuilder.append(File.pathSeparator);
+            }
+            libraryPathBuilder.append(libDir.getAbsolutePath());
+        }
+
+        final String libraryPath = libraryPathBuilder.toString();
+
+        final Constructor<?> dexPathListConstructor = ShareReflectUtil.findConstructor(originalDexPathList, ClassLoader.class, String.class, String.class, File.class);
+        return dexPathListConstructor.newInstance(newDefiningContext, dexPath, libraryPath, null);
+    }
+
+    private static AndroidNClassLoader createAndroidNClassLoader(PathClassLoader originalClassLoader, Application application) throws Exception {
+        //let all element ""
+        final AndroidNClassLoader androidNClassLoader = new AndroidNClassLoader("",  originalClassLoader, application);
+        final Field pathListField = ShareReflectUtil.findField(originalClassLoader, "pathList");
+        final Object originPathList = pathListField.get(originalClassLoader);
+
+        // To avoid 'dex file register with multiple classloader' exception on Android O, we must keep old
+        // dexPathList in original classloader so that after the newly loaded base dex was bound to
+        // AndroidNClassLoader we can still load class in base dex from original classloader.
+
+        Object newPathList = recreateDexPathList(originPathList, androidNClassLoader);
+
+        // Update new classloader's pathList.
+        pathListField.set(androidNClassLoader, newPathList);
+
         return androidNClassLoader;
     }
 
@@ -90,7 +127,7 @@ private static void reflectPackageInfoClassloader(Application application, Class
     }
 
     public static AndroidNClassLoader inject(PathClassLoader originClassLoader, Application application) throws Exception {
-        AndroidNClassLoader classLoader = createAndroidNClassLoader(originClassLoader);
+        AndroidNClassLoader classLoader = createAndroidNClassLoader(originClassLoader, application);
         reflectPackageInfoClassloader(application, classLoader);
         return classLoader;
     }
@@ -107,7 +144,10 @@ public static AndroidNClassLoader inject(PathClassLoader originClassLoader, Appl
 
     public Class<?> findClass(String name) throws ClassNotFoundException {
         // loader class use default pathClassloader to load
-        if (name != null && name.startsWith("com.tencent.tinker.loader.") && !name.equals("com.tencent.tinker.loader.TinkerTestDexLoad")) {
+        if ((name != null
+                && name.startsWith("com.tencent.tinker.loader.")
+                && !name.equals(SystemClassLoaderAdder.CHECK_DEX_CLASS))
+                || (applicationClassName != null && applicationClassName.equals(name))) {
             return originClassLoader.loadClass(name);
         }
         return super.findClass(name);
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/SystemClassLoaderAdder.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/SystemClassLoaderAdder.java
index 6c8199fa..47566786 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/SystemClassLoaderAdder.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/SystemClassLoaderAdder.java
@@ -32,8 +32,12 @@
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.HashMap;
 import java.util.List;
 import java.util.ListIterator;
+import java.util.Map;
 import java.util.zip.ZipFile;
 
 import dalvik.system.DexFile;
@@ -43,20 +47,20 @@
  * Created by zhangshaowen on 16/3/18.
  */
 public class SystemClassLoaderAdder {
+    public static final String CHECK_DEX_CLASS = "com.tencent.tinker.loader.TinkerTestDexLoad";
+    public static final String CHECK_DEX_FIELD = "isPatch";
     private static final String TAG = "Tinker.ClassLoaderAdder";
-
-    private static final String CHECK_DEX_CLASS = "com.tencent.tinker.loader.TinkerTestDexLoad";
-    private static final String CHECK_DEX_FIELD = "isPatch";
-
     private static int sPatchDexCount = 0;
 
     @SuppressLint("NewApi")
     public static void installDexes(Application application, PathClassLoader loader, File dexOptDir, List<File> files)
         throws Throwable {
+        Log.i(TAG, "installDexes dexOptDir: " + dexOptDir.getAbsolutePath() + ", dex size:" + files.size());
 
         if (!files.isEmpty()) {
+            files = createSortedAdditionalPathEntries(files);
             ClassLoader classLoader = loader;
-            if (Build.VERSION.SDK_INT >= 24) {
+            if (Build.VERSION.SDK_INT >= 24 && !checkIsProtectedApp(files)) {
                 classLoader = AndroidNClassLoader.inject(loader, application);
             }
             //because in dalvik, if inner class is not the same classloader with it wrapper class.
@@ -109,6 +113,77 @@ private static boolean checkDexInstall(ClassLoader classLoader) throws ClassNotF
         return isPatch;
     }
 
+    private static boolean checkIsProtectedApp(List<File> files) {
+        if (!files.isEmpty()) {
+            for (File file : files) {
+                if (file == null) {
+                    continue;
+                }
+                if (file.getName().startsWith(ShareConstants.CHANGED_CLASSES_DEX_NAME)) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    private static List<File> createSortedAdditionalPathEntries(List<File> additionalPathEntries) {
+        final List<File> result = new ArrayList<>(additionalPathEntries);
+
+        final Map<String, Boolean> matchesClassNPatternMemo = new HashMap<>();
+        for (File file : result) {
+            final String name = file.getName();
+            matchesClassNPatternMemo.put(name, ShareConstants.CLASS_N_PATTERN.matcher(name).matches());
+        }
+        Collections.sort(result, new Comparator<File>() {
+            @Override
+            public int compare(File lhs, File rhs) {
+                if (lhs == null && rhs == null) {
+                    return 0;
+                }
+                if (lhs == null) {
+                    return -1;
+                }
+                if (rhs == null) {
+                    return 1;
+                }
+
+                final String lhsName = lhs.getName();
+                final String rhsName = rhs.getName();
+                if (lhsName.equals(rhsName)) {
+                    return 0;
+                }
+
+                final String testDexSuffix = ShareConstants.TEST_DEX_NAME;
+                // test.dex should always be at tail.
+                if (lhsName.startsWith(testDexSuffix)) {
+                    return 1;
+                }
+                if (rhsName.startsWith(testDexSuffix)) {
+                    return -1;
+                }
+
+                final boolean isLhsNameMatchClassN = matchesClassNPatternMemo.get(lhsName);
+                final boolean isRhsNameMatchClassN = matchesClassNPatternMemo.get(rhsName);
+                if (isLhsNameMatchClassN && isRhsNameMatchClassN) {
+                    final int lhsDotPos = lhsName.indexOf('.');
+                    final int rhsDotPos = rhsName.indexOf('.');
+                    final int lhsId = (lhsDotPos > 7 ? Integer.parseInt(lhsName.substring(7, lhsDotPos)) : 1);
+                    final int rhsId = (rhsDotPos > 7 ? Integer.parseInt(rhsName.substring(7, rhsDotPos)) : 1);
+                    return (lhsId == rhsId ? 0 : (lhsId < rhsId ? -1 : 1));
+                } else if (isLhsNameMatchClassN) {
+                    // Dex name that matches class N rules should always be at first.
+                    return -1;
+                } else if (isRhsNameMatchClassN) {
+                    return 1;
+                }
+                return lhsName.compareTo(rhsName);
+            }
+        });
+
+        return result;
+    }
+
     /**
      * Installer for platform versions 23.
      */
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerDexLoader.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerDexLoader.java
index 90ebc589..4d9cdad3 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerDexLoader.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerDexLoader.java
@@ -17,11 +17,11 @@
 package com.tencent.tinker.loader;
 
 import android.annotation.TargetApi;
-import android.app.Application;
 import android.content.Intent;
 import android.os.Build;
 import android.util.Log;
 
+import com.tencent.tinker.loader.app.TinkerApplication;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
 import com.tencent.tinker.loader.shareutil.ShareDexDiffPatchInfo;
 import com.tencent.tinker.loader.shareutil.ShareIntentUtil;
@@ -32,6 +32,7 @@
 import java.io.File;
 import java.util.ArrayList;
 import java.util.HashMap;
+import java.util.HashSet;
 
 import dalvik.system.PathClassLoader;
 
@@ -44,13 +45,18 @@
 
     private static final String TAG = "Tinker.TinkerDexLoader";
 
-    private static final String                           DEX_MEAT_FILE     = ShareConstants.DEX_META_FILE;
-    private static final String                           DEX_PATH          = ShareConstants.DEX_PATH;
-    private static final String                           DEX_OPTIMIZE_PATH = ShareConstants.DEX_OPTIMIZE_PATH;
-    private static final ArrayList<ShareDexDiffPatchInfo> dexList           = new ArrayList<>();
+    private static final String DEX_MEAT_FILE               = ShareConstants.DEX_META_FILE;
+    private static final String DEX_PATH                    = ShareConstants.DEX_PATH;
+    private static final String DEFAULT_DEX_OPTIMIZE_PATH   = ShareConstants.DEFAULT_DEX_OPTIMIZE_PATH;
+    private static final String INTERPRET_DEX_OPTIMIZE_PATH = ShareConstants.INTERPRET_DEX_OPTIMIZE_PATH;
 
-    private static boolean   parallelOTAResult;
-    private static Throwable parallelOTAThrowable;
+    private static final ArrayList<ShareDexDiffPatchInfo> loadDexList = new ArrayList<>();
+
+
+    //    private static File testOptDexFile;
+    private static HashSet<ShareDexDiffPatchInfo> classNDexInfo = new HashSet<>();
+
+    private static boolean isVmArt = ShareTinkerInternals.isVmArt();
 
     private TinkerDexLoader() {
     }
@@ -62,8 +68,8 @@ private TinkerDexLoader() {
      * @param application The application.
      */
     @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
-    public static boolean loadTinkerJars(Application application, boolean tinkerLoadVerifyFlag, String directory, Intent intentResult, boolean isSystemOTA) {
-        if (dexList.isEmpty()) {
+    public static boolean loadTinkerJars(final TinkerApplication application, String directory, String oatDir, Intent intentResult, boolean isSystemOTA) {
+        if (loadDexList.isEmpty() && classNDexInfo.isEmpty()) {
             Log.w(TAG, "there is no dex to load");
             return true;
         }
@@ -77,24 +83,21 @@ public static boolean loadTinkerJars(Application application, boolean tinkerLoad
             return false;
         }
         String dexPath = directory + "/" + DEX_PATH + "/";
-        File optimizeDir = new File(directory + "/" + DEX_OPTIMIZE_PATH);
-//        Log.i(TAG, "loadTinkerJars: dex path: " + dexPath);
-//        Log.i(TAG, "loadTinkerJars: opt path: " + optimizeDir.getAbsolutePath());
 
         ArrayList<File> legalFiles = new ArrayList<>();
 
-        final boolean isArtPlatForm = ShareTinkerInternals.isVmArt();
-        for (ShareDexDiffPatchInfo info : dexList) {
+        for (ShareDexDiffPatchInfo info : loadDexList) {
             //for dalvik, ignore art support dex
             if (isJustArtSupportDex(info)) {
                 continue;
             }
+
             String path = dexPath + info.realName;
             File file = new File(path);
 
-            if (tinkerLoadVerifyFlag) {
+            if (application.isTinkerLoadVerifyFlag()) {
                 long start = System.currentTimeMillis();
-                String checkMd5 = isArtPlatForm ? info.destMd5InArt : info.destMd5InDvm;
+                String checkMd5 = getInfoMd5(info);
                 if (!SharePatchFileUtil.verifyDexFileMd5(file, checkMd5)) {
                     //it is good to delete the mismatch file
                     ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_DEX_MD5_MISMATCH);
@@ -106,15 +109,56 @@ public static boolean loadTinkerJars(Application application, boolean tinkerLoad
             }
             legalFiles.add(file);
         }
+        // verify merge classN.apk
+        if (isVmArt && !classNDexInfo.isEmpty()) {
+            File classNFile = new File(dexPath + ShareConstants.CLASS_N_APK_NAME);
+            long start = System.currentTimeMillis();
+
+            if (application.isTinkerLoadVerifyFlag()) {
+                for (ShareDexDiffPatchInfo info : classNDexInfo) {
+                    if (!SharePatchFileUtil.verifyDexFileMd5(classNFile, info.rawName, info.destMd5InArt)) {
+                        ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_DEX_MD5_MISMATCH);
+                        intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_MISMATCH_DEX_PATH,
+                            classNFile.getAbsolutePath());
+                        return false;
+                    }
+                }
+            }
+            Log.i(TAG, "verify dex file:" + classNFile.getPath() + " md5, use time: " + (System.currentTimeMillis() - start));
+
+            legalFiles.add(classNFile);
+        }
+        File optimizeDir = new File(directory + "/" + oatDir);
 
         if (isSystemOTA) {
-            parallelOTAResult = true;
-            parallelOTAThrowable = null;
-            Log.w(TAG, "systemOTA, try parallel oat dexes!!!!!");
+            final boolean[] parallelOTAResult = {true};
+            final Throwable[] parallelOTAThrowable = new Throwable[1];
+            String targetISA;
+            try {
+                targetISA = ShareTinkerInternals.getCurrentInstructionSet();
+            } catch (Throwable throwable) {
+                Log.i(TAG, "getCurrentInstructionSet fail:" + throwable);
+//                try {
+//                    targetISA = ShareOatUtil.getOatFileInstructionSet(testOptDexFile);
+//                } catch (Throwable throwable) {
+                // don't ota on the front
+                deleteOutOfDateOATFile(directory);
+
+                intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_INTERPRET_EXCEPTION, throwable);
+                ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_GET_OTA_INSTRUCTION_SET_EXCEPTION);
+                return false;
+//                }
+            }
 
-            TinkerParallelDexOptimizer.optimizeAll(
-                legalFiles, optimizeDir,
-                new TinkerParallelDexOptimizer.ResultCallback() {
+            deleteOutOfDateOATFile(directory);
+
+            Log.w(TAG, "systemOTA, try parallel oat dexes, targetISA:" + targetISA);
+            // change dir
+            optimizeDir = new File(directory + "/" + INTERPRET_DEX_OPTIMIZE_PATH);
+
+            TinkerDexOptimizer.optimizeAll(
+                legalFiles, optimizeDir, true, targetISA,
+                new TinkerDexOptimizer.ResultCallback() {
                     long start;
 
                     @Override
@@ -126,20 +170,23 @@ public void onStart(File dexFile, File optimizedDir) {
                     @Override
                     public void onSuccess(File dexFile, File optimizedDir, File optimizedFile) {
                         // Do nothing.
-                        Log.i(TAG, "success to optimize dex " + dexFile.getPath() + "use time " + (System.currentTimeMillis() - start));
+                        Log.i(TAG, "success to optimize dex " + dexFile.getPath() + ", use time " + (System.currentTimeMillis() - start));
                     }
+
                     @Override
                     public void onFailed(File dexFile, File optimizedDir, Throwable thr) {
-                        parallelOTAResult = false;
-                        parallelOTAThrowable = thr;
-                        Log.i(TAG, "fail to optimize dex " + dexFile.getPath() + "use time " + (System.currentTimeMillis() - start));
+                        parallelOTAResult[0] = false;
+                        parallelOTAThrowable[0] = thr;
+                        Log.i(TAG, "fail to optimize dex " + dexFile.getPath() + ", use time " + (System.currentTimeMillis() - start));
                     }
                 }
             );
-            if (!parallelOTAResult) {
+
+
+            if (!parallelOTAResult[0]) {
                 Log.e(TAG, "parallel oat dexes failed");
-                intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_EXCEPTION, parallelOTAThrowable);
-                ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_PARALLEL_DEX_OPT_EXCEPTION);
+                intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_INTERPRET_EXCEPTION, parallelOTAThrowable[0]);
+                ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_OTA_INTERPRET_ONLY_EXCEPTION);
                 return false;
             }
         }
@@ -160,25 +207,29 @@ public void onFailed(File dexFile, File optimizedDir, Throwable thr) {
      * all the dex files in meta file exist?
      * fast check, only check whether exist
      *
-     * @param directory
      * @return boolean
      */
-    public static boolean checkComplete(String directory, ShareSecurityCheck securityCheck, Intent intentResult) {
+    public static boolean checkComplete(String directory, ShareSecurityCheck securityCheck, String oatDir, Intent intentResult) {
         String meta = securityCheck.getMetaContentMap().get(DEX_MEAT_FILE);
         //not found dex
         if (meta == null) {
             return true;
         }
-        dexList.clear();
-        ShareDexDiffPatchInfo.parseDexDiffPatchInfo(meta, dexList);
+        loadDexList.clear();
+        classNDexInfo.clear();
 
-        if (dexList.isEmpty()) {
+        ArrayList<ShareDexDiffPatchInfo> allDexInfo = new ArrayList<>();
+        ShareDexDiffPatchInfo.parseDexDiffPatchInfo(meta, allDexInfo);
+
+        if (allDexInfo.isEmpty()) {
             return true;
         }
 
         HashMap<String, String> dexes = new HashMap<>();
 
-        for (ShareDexDiffPatchInfo info : dexList) {
+        ShareDexDiffPatchInfo testInfo = null;
+
+        for (ShareDexDiffPatchInfo info : allDexInfo) {
             //for dalvik, ignore art support dex
             if (isJustArtSupportDex(info)) {
                 continue;
@@ -188,7 +239,22 @@ public static boolean checkComplete(String directory, ShareSecurityCheck securit
                 ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_PACKAGE_CHECK_FAIL);
                 return false;
             }
-            dexes.put(info.realName, info.destMd5InDvm);
+            if (isVmArt && info.rawName.startsWith(ShareConstants.TEST_DEX_NAME)) {
+                testInfo = info;
+            } else if (isVmArt && ShareConstants.CLASS_N_PATTERN.matcher(info.realName).matches()) {
+                classNDexInfo.add(info);
+            } else {
+                dexes.put(info.realName, getInfoMd5(info));
+                loadDexList.add(info);
+            }
+        }
+
+        if (isVmArt
+            && (testInfo != null || !classNDexInfo.isEmpty())) {
+            if (testInfo != null) {
+                classNDexInfo.add(ShareTinkerInternals.changeTestDexToClassN(testInfo, classNDexInfo.size() + 1));
+            }
+            dexes.put(ShareConstants.CLASS_N_APK_NAME, "");
         }
         //tinker/patch.info/patch-641e634c/dex
         String dexDirectory = directory + "/" + DEX_PATH + "/";
@@ -199,12 +265,13 @@ public static boolean checkComplete(String directory, ShareSecurityCheck securit
             ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_DEX_DIRECTORY_NOT_EXIST);
             return false;
         }
-        String optimizeDexDirectory = directory + "/" + DEX_OPTIMIZE_PATH + "/";
+        String optimizeDexDirectory = directory + "/" + oatDir + "/";
         File optimizeDexDirectoryFile = new File(optimizeDexDirectory);
 
         //fast check whether there is any dex files missing
         for (String name : dexes.keySet()) {
             File dexFile = new File(dexDirectory + name);
+
             if (!SharePatchFileUtil.isLegalFile(dexFile)) {
                 intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_MISSING_DEX_PATH, dexFile.getAbsolutePath());
                 ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_DEX_FILE_NOT_EXIST);
@@ -217,6 +284,10 @@ public static boolean checkComplete(String directory, ShareSecurityCheck securit
                 ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_DEX_OPT_FILE_NOT_EXIST);
                 return false;
             }
+//            // find test dex
+//            if (dexOptFile.getName().startsWith(ShareConstants.TEST_DEX_NAME)) {
+//                testOptDexFile = dexOptFile;
+//            }
         }
 
         //if is ok, add to result intent
@@ -224,8 +295,22 @@ public static boolean checkComplete(String directory, ShareSecurityCheck securit
         return true;
     }
 
+    private static String getInfoMd5(ShareDexDiffPatchInfo info) {
+        return isVmArt ? info.destMd5InArt : info.destMd5InDvm;
+    }
+
+    private static void deleteOutOfDateOATFile(String directory) {
+        String optimizeDexDirectory = directory + "/" + DEFAULT_DEX_OPTIMIZE_PATH + "/";
+        SharePatchFileUtil.deleteDir(optimizeDexDirectory);
+        // delete android o
+        if (ShareTinkerInternals.isAfterAndroidO()) {
+            String androidODexDirectory = directory + "/" + ShareConstants.ANDROID_O_DEX_OPTIMIZE_PATH + "/";
+            SharePatchFileUtil.deleteDir(androidODexDirectory);
+        }
+    }
+
     private static boolean isJustArtSupportDex(ShareDexDiffPatchInfo dexDiffPatchInfo) {
-        if (ShareTinkerInternals.isVmArt()) {
+        if (isVmArt) {
             return false;
         }
 
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerDexOptimizer.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerDexOptimizer.java
new file mode 100644
index 00000000..7ae3f185
--- /dev/null
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerDexOptimizer.java
@@ -0,0 +1,209 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.loader;
+
+import android.os.Build;
+import android.util.Log;
+
+import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.List;
+import java.util.concurrent.Executor;
+import java.util.concurrent.Executors;
+
+import dalvik.system.DexFile;
+
+/**
+ * Created by tangyinsheng on 2016/11/15.
+ */
+
+public final class TinkerDexOptimizer {
+    private static final String TAG = "Tinker.ParallelDex";
+
+    /**
+     * Optimize (trigger dexopt or dex2oat) dexes.
+     *
+     * @param dexFiles
+     * @param optimizedDir
+     * @param cb
+     * @return If all dexes are optimized successfully, return true. Otherwise return false.
+     */
+    public static boolean optimizeAll(Collection<File> dexFiles, File optimizedDir, ResultCallback cb) {
+        return optimizeAll(dexFiles, optimizedDir, false, null, cb);
+    }
+
+    public static boolean optimizeAll(Collection<File> dexFiles, File optimizedDir,
+                                                   boolean useInterpretMode, String targetISA, ResultCallback cb) {
+        ArrayList<File> sortList = new ArrayList<>(dexFiles);
+        // sort input dexFiles with its file length
+        Collections.sort(sortList, new Comparator<File>() {
+            @Override
+            public int compare(File lhs, File rhs) {
+                long diffSize = lhs.length() - rhs.length();
+                if (diffSize > 0) {
+                    return 1;
+                } else if (diffSize == 0) {
+                    return 0;
+                } else {
+                    return -1;
+                }
+            }
+        });
+        Collections.reverse(sortList);
+        for (File dexFile : sortList) {
+            OptimizeWorker worker = new OptimizeWorker(dexFile, optimizedDir, useInterpretMode, targetISA, cb);
+            if (!worker.run()) {
+                return false;
+            }
+        }
+        return true;
+
+
+    }
+
+    public interface ResultCallback {
+        void onStart(File dexFile, File optimizedDir);
+
+        void onSuccess(File dexFile, File optimizedDir, File optimizedFile);
+
+        void onFailed(File dexFile, File optimizedDir, Throwable thr);
+    }
+
+    private static class OptimizeWorker {
+        private static String targetISA = null;
+
+        private final File           dexFile;
+        private final File           optimizedDir;
+        private final boolean        useInterpretMode;
+        private final ResultCallback callback;
+
+        OptimizeWorker(File dexFile, File optimizedDir, boolean useInterpretMode, String targetISA, ResultCallback cb) {
+            this.dexFile = dexFile;
+            this.optimizedDir = optimizedDir;
+            this.useInterpretMode = useInterpretMode;
+            this.callback = cb;
+            this.targetISA = targetISA;
+        }
+
+        public boolean run() {
+            try {
+                if (!SharePatchFileUtil.isLegalFile(dexFile)) {
+                    if (callback != null) {
+                        callback.onFailed(dexFile, optimizedDir,
+                            new IOException("dex file " + dexFile.getAbsolutePath() + " is not exist!"));
+                        return false;
+                    }
+                }
+                if (callback != null) {
+                    callback.onStart(dexFile, optimizedDir);
+                }
+                String optimizedPath = SharePatchFileUtil.optimizedPathFor(this.dexFile, this.optimizedDir);
+                if (useInterpretMode) {
+                    interpretDex2Oat(dexFile.getAbsolutePath(), optimizedPath);
+                } else {
+                    DexFile.loadDex(dexFile.getAbsolutePath(), optimizedPath, 0);
+                }
+                if (callback != null) {
+                    callback.onSuccess(dexFile, optimizedDir, new File(optimizedPath));
+                }
+            } catch (final Throwable e) {
+                Log.e(TAG, "Failed to optimize dex: " + dexFile.getAbsolutePath(), e);
+                if (callback != null) {
+                    callback.onFailed(dexFile, optimizedDir, e);
+                    return false;
+                }
+            }
+            return true;
+        }
+
+        private void interpretDex2Oat(String dexFilePath, String oatFilePath) throws IOException {
+
+            final File oatFile = new File(oatFilePath);
+            if (!oatFile.exists()) {
+                oatFile.getParentFile().mkdirs();
+            }
+
+            final List<String> commandAndParams = new ArrayList<>();
+            commandAndParams.add("dex2oat");
+            // for 7.1.1, duplicate class fix
+            if (Build.VERSION.SDK_INT >= 24) {
+                commandAndParams.add("--runtime-arg");
+                commandAndParams.add("-classpath");
+                commandAndParams.add("--runtime-arg");
+                commandAndParams.add("&");
+            }
+            commandAndParams.add("--dex-file=" + dexFilePath);
+            commandAndParams.add("--oat-file=" + oatFilePath);
+            commandAndParams.add("--instruction-set=" + targetISA);
+            if (Build.VERSION.SDK_INT > 25) {
+                commandAndParams.add("--compiler-filter=quicken");
+            } else {
+                commandAndParams.add("--compiler-filter=interpret-only");
+            }
+
+            final ProcessBuilder pb = new ProcessBuilder(commandAndParams);
+            pb.redirectErrorStream(true);
+            final Process dex2oatProcess = pb.start();
+            StreamConsumer.consumeInputStream(dex2oatProcess.getInputStream());
+            StreamConsumer.consumeInputStream(dex2oatProcess.getErrorStream());
+            try {
+                final int ret = dex2oatProcess.waitFor();
+                if (ret != 0) {
+                    throw new IOException("dex2oat works unsuccessfully, exit code: " + ret);
+                }
+            } catch (InterruptedException e) {
+                throw new IOException("dex2oat is interrupted, msg: " + e.getMessage(), e);
+            }
+        }
+    }
+
+    private static class StreamConsumer {
+        static final Executor STREAM_CONSUMER = Executors.newSingleThreadExecutor();
+
+        static void consumeInputStream(final InputStream is) {
+            STREAM_CONSUMER.execute(new Runnable() {
+                @Override
+                public void run() {
+                    if (is == null) {
+                        return;
+                    }
+                    final byte[] buffer = new byte[256];
+                    try {
+                        while ((is.read(buffer)) > 0) {
+                            // To satisfy checkstyle rules.
+                        }
+                    } catch (IOException ignored) {
+                        // Ignored.
+                    } finally {
+                        try {
+                            is.close();
+                        } catch (Exception ignored) {
+                            // Ignored.
+                        }
+                    }
+                }
+            });
+        }
+    }
+}
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerLoader.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerLoader.java
index 2c517745..707c2228 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerLoader.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerLoader.java
@@ -19,6 +19,7 @@
 import android.content.Context;
 import android.content.Intent;
 import android.content.SharedPreferences;
+import android.os.Build;
 import android.os.SystemClock;
 import android.util.Log;
 
@@ -49,20 +50,29 @@
      * only main process can handle patch version change or incomplete
      */
     @Override
-    public Intent tryLoad(TinkerApplication app, int tinkerFlag, boolean tinkerLoadVerifyFlag) {
+    public Intent tryLoad(TinkerApplication app) {
         Intent resultIntent = new Intent();
 
         long begin = SystemClock.elapsedRealtime();
-        tryLoadPatchFilesInternal(app, tinkerFlag, tinkerLoadVerifyFlag, resultIntent);
+        tryLoadPatchFilesInternal(app, resultIntent);
         long cost = SystemClock.elapsedRealtime() - begin;
         ShareIntentUtil.setIntentPatchCostTime(resultIntent, cost);
         return resultIntent;
     }
 
-    private void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, boolean tinkerLoadVerifyFlag, Intent resultIntent) {
+    private void tryLoadPatchFilesInternal(TinkerApplication app, Intent resultIntent) {
+        final int tinkerFlag = app.getTinkerFlags();
+
         if (!ShareTinkerInternals.isTinkerEnabled(tinkerFlag)) {
+            Log.w(TAG, "tryLoadPatchFiles: tinker is disable, just return");
+            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_DISABLE);
+            return;
+        }
+        if (ShareTinkerInternals.isInPatchProcess(app)) {
+            Log.w(TAG, "tryLoadPatchFiles: we don't load patch with :patch process itself, just return");
             ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_DISABLE);
             return;
+
         }
         //tinker
         File patchDirectoryFile = SharePatchFileUtil.getPatchDirectory(app);
@@ -102,8 +112,9 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, bo
 
         String oldVersion = patchInfo.oldVersion;
         String newVersion = patchInfo.newVersion;
+        String oatDex = patchInfo.oatDir;
 
-        if (oldVersion == null || newVersion == null) {
+        if (oldVersion == null || newVersion == null || oatDex == null) {
             //it is nice to clean patch
             Log.w(TAG, "tryLoadPatchFiles:onPatchInfoCorrupted");
             ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_INFO_CORRUPTED);
@@ -115,8 +126,12 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, bo
 
         boolean mainProcess = ShareTinkerInternals.isInMainProcess(app);
         boolean versionChanged = !(oldVersion.equals(newVersion));
+        boolean oatModeChanged = oatDex.equals(ShareConstants.CHANING_DEX_OPTIMIZE_PATH) && mainProcess;
+        oatDex = ShareTinkerInternals.getCurrentOatMode(app, oatDex);
+        resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_OAT_DIR, oatDex);
 
         String version = oldVersion;
+
         if (versionChanged && mainProcess) {
             version = newVersion;
         }
@@ -136,6 +151,7 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, bo
         }
         //tinker/patch.info/patch-641e634c
         String patchVersionDirectory = patchDirectoryPath + "/" + patchName;
+
         File patchVersionDirectoryFile = new File(patchVersionDirectory);
 
         if (!patchVersionDirectoryFile.exists()) {
@@ -171,7 +187,7 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, bo
 
         if (isEnabledForDex) {
             //tinker/patch.info/patch-641e634c/dex
-            boolean dexCheck = TinkerDexLoader.checkComplete(patchVersionDirectory, securityCheck, resultIntent);
+            boolean dexCheck = TinkerDexLoader.checkComplete(patchVersionDirectory, securityCheck, oatDex, resultIntent);
             if (!dexCheck) {
                 //file not found, do not load patch
                 Log.w(TAG, "tryLoadPatchFiles:dex check fail");
@@ -202,20 +218,30 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, bo
                 return;
             }
         }
-        //only work for art platform oat
-        boolean isSystemOTA = ShareTinkerInternals.isVmArt() && ShareTinkerInternals.isSystemOTA(patchInfo.fingerPrint);
+        //only work for art platform oat，because of interpret, refuse 4.4 art oat
+        boolean isSystemOTA = ShareTinkerInternals.isVmArt()
+            && ShareTinkerInternals.isSystemOTA(patchInfo.fingerPrint)
+            && Build.VERSION.SDK_INT >= 21;
+
         resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_SYSTEM_OTA, isSystemOTA);
 
         //we should first try rewrite patch info file, if there is a error, we can't load jar
-        if (isSystemOTA
-            || (mainProcess && versionChanged)) {
+        if ((mainProcess && versionChanged)
+             || oatModeChanged) {
             patchInfo.oldVersion = version;
+            patchInfo.oatDir = oatDex;
+
             //update old version to new
             if (!SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile, patchInfo, patchInfoLockFile)) {
                 ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_REWRITE_PATCH_INFO_FAIL);
                 Log.w(TAG, "tryLoadPatchFiles:onReWritePatchInfoCorrupted");
                 return;
             }
+            if (oatModeChanged) {
+                // delete interpret odex
+                Log.i(TAG, "tryLoadPatchFiles:oatModeChanged, try to delete interpret optimize files");
+                SharePatchFileUtil.deleteDir(patchVersionDirectory + "/" + ShareConstants.INTERPRET_DEX_OPTIMIZE_PATH);
+            }
         }
         if (!checkSafeModeCount(app)) {
             resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_EXCEPTION, new TinkerRuntimeException("checkSafeModeCount fail"));
@@ -223,9 +249,26 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, bo
             Log.w(TAG, "tryLoadPatchFiles:checkSafeModeCount fail");
             return;
         }
+
         //now we can load patch jar
         if (isEnabledForDex) {
-            boolean loadTinkerJars = TinkerDexLoader.loadTinkerJars(app, tinkerLoadVerifyFlag, patchVersionDirectory, resultIntent, isSystemOTA);
+            boolean loadTinkerJars = TinkerDexLoader.loadTinkerJars(app, patchVersionDirectory, oatDex, resultIntent, isSystemOTA);
+
+            if (isSystemOTA) {
+                // update fingerprint after load success
+                patchInfo.fingerPrint = Build.FINGERPRINT;
+                patchInfo.oatDir = loadTinkerJars ? ShareConstants.INTERPRET_DEX_OPTIMIZE_PATH : ShareConstants.DEFAULT_DEX_OPTIMIZE_PATH;
+                // reset to false
+                oatModeChanged = false;
+
+                if (!SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile, patchInfo, patchInfoLockFile)) {
+                    ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_REWRITE_PATCH_INFO_FAIL);
+                    Log.w(TAG, "tryLoadPatchFiles:onReWritePatchInfoCorrupted");
+                    return;
+                }
+                // update oat dir
+                resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_OAT_DIR, patchInfo.oatDir);
+            }
             if (!loadTinkerJars) {
                 Log.w(TAG, "tryLoadPatchFiles:onPatchLoadDexesFail");
                 return;
@@ -234,12 +277,17 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, bo
 
         //now we can load patch resource
         if (isEnabledForResource) {
-            boolean loadTinkerResources = TinkerResourceLoader.loadTinkerResources(app, tinkerLoadVerifyFlag, patchVersionDirectory, resultIntent);
+            boolean loadTinkerResources = TinkerResourceLoader.loadTinkerResources(app, patchVersionDirectory, resultIntent);
             if (!loadTinkerResources) {
                 Log.w(TAG, "tryLoadPatchFiles:onPatchLoadResourcesFail");
                 return;
             }
         }
+        // kill all other process if oat mode change
+        if (oatModeChanged) {
+            ShareTinkerInternals.killAllOtherProcess(app);
+            Log.i(TAG, "tryLoadPatchFiles:oatModeChanged, try to kill all other process");
+        }
         //all is ok!
         ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_OK);
         Log.i(TAG, "tryLoadPatchFiles: load end, ok!");
@@ -261,6 +309,4 @@ private boolean checkSafeModeCount(TinkerApplication application) {
         sp.edit().putInt(ShareConstants.TINKER_SAFE_MODE_COUNT, count).commit();
         return true;
     }
-
-
 }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerParallelDexOptimizer.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerParallelDexOptimizer.java
deleted file mode 100644
index e2481a05..00000000
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerParallelDexOptimizer.java
+++ /dev/null
@@ -1,146 +0,0 @@
-/*
- * Tencent is pleased to support the open source community by making Tinker available.
- *
- * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
- *
- * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- *
- * https://opensource.org/licenses/BSD-3-Clause
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is
- * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
- * either express or implied. See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.tencent.tinker.loader;
-
-import android.util.Log;
-
-import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
-
-import dalvik.system.DexFile;
-
-import java.io.File;
-import java.io.IOException;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.atomic.AtomicInteger;
-
-/**
- * Created by tangyinsheng on 2016/11/15.
- */
-
-public final class TinkerParallelDexOptimizer {
-    private static final String TAG = "Tinker.ParallelDex";
-
-    /**
-     * Optimize (trigger dexopt or dex2oat) dexes.
-     *
-     * @param dexFiles
-     * @param optimizedDir
-     * @param cb
-     *
-     * @return
-     *  If all dexes are optimized successfully, return true. Otherwise return false.
-     */
-    public synchronized static boolean optimizeAll(File[] dexFiles, File optimizedDir, ResultCallback cb) {
-        final AtomicInteger successCount = new AtomicInteger(0);
-        return optimizeAllLocked(Arrays.asList(dexFiles), optimizedDir, successCount, cb);
-    }
-
-    /**
-     * Optimize (trigger dexopt or dex2oat) dexes.
-     *
-     * @param dexFiles
-     * @param optimizedDir
-     * @param cb
-     *
-     * @return
-     *  If all dexes are optimized successfully, return true. Otherwise return false.
-     */
-    public synchronized static boolean optimizeAll(Collection<File> dexFiles, File optimizedDir, ResultCallback cb) {
-        final AtomicInteger successCount = new AtomicInteger(0);
-        return optimizeAllLocked(dexFiles, optimizedDir, successCount, cb);
-    }
-
-    private static boolean optimizeAllLocked(Collection<File> dexFiles, File optimizedDir, AtomicInteger successCount, ResultCallback cb) {
-        final CountDownLatch lauch = new CountDownLatch(dexFiles.size());
-        final ExecutorService threadPool = Executors.newCachedThreadPool();
-        long startTick = System.nanoTime();
-        for (File dexFile : dexFiles) {
-            OptimizeWorker worker = new OptimizeWorker(dexFile, optimizedDir, successCount, lauch, cb);
-            threadPool.submit(worker);
-        }
-        try {
-            lauch.await();
-            long timeCost = (System.nanoTime() - startTick) / 1000000;
-            if (successCount.get() == dexFiles.size()) {
-                Log.i(TAG, "All dexes are optimized successfully, cost: " + timeCost + " ms.");
-                return true;
-            } else {
-                Log.e(TAG, "Dexes optimizing failed, some dexes are not optimized.");
-                return false;
-            }
-        } catch (InterruptedException e) {
-            Log.w(TAG, "Dex optimizing was interrupted.", e);
-            return false;
-        } finally {
-            threadPool.shutdown();
-        }
-    }
-
-    public interface ResultCallback {
-        void onStart(File dexFile, File optimizedDir);
-        void onSuccess(File dexFile, File optimizedDir, File optimizedFile);
-        void onFailed(File dexFile, File optimizedDir, Throwable thr);
-    }
-
-    private static class OptimizeWorker implements Runnable {
-        private final File dexFile;
-        private final File optimizedDir;
-        private final AtomicInteger successCount;
-        private final CountDownLatch waitingLauch;
-        private final ResultCallback callback;
-
-        OptimizeWorker(File dexFile, File optimizedDir, AtomicInteger successCount, CountDownLatch lauch, ResultCallback cb) {
-            this.dexFile = dexFile;
-            this.optimizedDir = optimizedDir;
-            this.successCount = successCount;
-            this.waitingLauch = lauch;
-            this.callback = cb;
-        }
-
-        @Override
-        public void run() {
-            try {
-                if (!SharePatchFileUtil.isLegalFile(dexFile)) {
-                    if (callback != null) {
-                        callback.onFailed(dexFile, optimizedDir,
-                            new IOException("dex file " + dexFile.getAbsolutePath() + " is not exist!"));
-                    }
-                }
-                if (callback != null) {
-                    callback.onStart(dexFile, optimizedDir);
-                }
-                String optimizedPath = SharePatchFileUtil.optimizedPathFor(this.dexFile, this.optimizedDir);
-                DexFile.loadDex(dexFile.getAbsolutePath(), optimizedPath, 0);
-                successCount.incrementAndGet();
-                if (callback != null) {
-                    callback.onSuccess(dexFile, optimizedDir, new File(optimizedPath));
-                }
-            } catch (final Throwable e) {
-                Log.e(TAG, "Failed to optimize dex: " + dexFile.getAbsolutePath(), e);
-                if (callback != null) {
-                    callback.onFailed(dexFile, optimizedDir, e);
-                }
-            } finally {
-                this.waitingLauch.countDown();
-            }
-        }
-    }
-}
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourceLoader.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourceLoader.java
index 167231b3..82a72983 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourceLoader.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourceLoader.java
@@ -20,6 +20,7 @@
 import android.content.Intent;
 import android.util.Log;
 
+import com.tencent.tinker.loader.app.TinkerApplication;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
 import com.tencent.tinker.loader.shareutil.ShareIntentUtil;
 import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
@@ -44,7 +45,7 @@ private TinkerResourceLoader() {
     /**
      * Load tinker resources
      */
-    public static boolean loadTinkerResources(Context context, boolean tinkerLoadVerifyFlag, String directory, Intent intentResult) {
+    public static boolean loadTinkerResources(TinkerApplication application, String directory, Intent intentResult) {
         if (resPatchInfo == null || resPatchInfo.resArscMd5 == null) {
             return true;
         }
@@ -52,7 +53,7 @@ public static boolean loadTinkerResources(Context context, boolean tinkerLoadVer
         File resourceFile = new File(resourceString);
         long start = System.currentTimeMillis();
 
-        if (tinkerLoadVerifyFlag) {
+        if (application.isTinkerLoadVerifyFlag()) {
             if (!SharePatchFileUtil.checkResourceArscMd5(resourceFile, resPatchInfo.resArscMd5)) {
                 Log.e(TAG, "Failed to load resource file, path: " + resourceFile.getPath() + ", expect md5: " + resPatchInfo.resArscMd5);
                 ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_RESOURCE_MD5_MISMATCH);
@@ -61,13 +62,13 @@ public static boolean loadTinkerResources(Context context, boolean tinkerLoadVer
             Log.i(TAG, "verify resource file:" + resourceFile.getPath() + " md5, use time: " + (System.currentTimeMillis() - start));
         }
         try {
-            TinkerResourcePatcher.monkeyPatchExistingResources(context, resourceString);
+            TinkerResourcePatcher.monkeyPatchExistingResources(application, resourceString);
             Log.i(TAG, "monkeyPatchExistingResources resource file:" + resourceString + ", use time: " + (System.currentTimeMillis() - start));
         } catch (Throwable e) {
             Log.e(TAG, "install resources failed");
             //remove patch dex if resource is installed failed
             try {
-                SystemClassLoaderAdder.uninstallPatchDex(context.getClassLoader());
+                SystemClassLoaderAdder.uninstallPatchDex(application.getClassLoader());
             } catch (Throwable throwable) {
                 Log.e(TAG, "uninstallPatchDex failed", e);
             }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java
index 975c4e17..351d703b 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java
@@ -17,8 +17,10 @@
 package com.tencent.tinker.loader;
 
 import android.content.Context;
+import android.content.pm.ApplicationInfo;
 import android.content.res.AssetManager;
 import android.content.res.Resources;
+import android.os.Build;
 import android.util.ArrayMap;
 import android.util.Log;
 
@@ -41,19 +43,19 @@
  * Thanks for Android Fragmentation
  */
 class TinkerResourcePatcher {
-    private static final String TAG                     = "Tinker.ResourcePatcher";
-    private static final String TEST_ASSETS_VALUE       = "only_use_to_test_tinker_resource.txt";
+    private static final String TAG               = "Tinker.ResourcePatcher";
+    private static final String TEST_ASSETS_VALUE = "only_use_to_test_tinker_resource.txt";
 //    private static final String MIUI_RESOURCE_CLASSNAME = "android.content.res.MiuiResources";
 
     // original object
-    private static Collection<WeakReference<Resources>>  references               = null;
-    private static Object                                currentActivityThread    = null;
-    private static AssetManager                          newAssetManager          = null;
+    private static Collection<WeakReference<Resources>> references            = null;
+    private static Object                               currentActivityThread = null;
+    private static AssetManager                         newAssetManager       = null;
     //    private static ArrayMap<?, WeakReference<?>>         resourceImpls            = null;
 
     // method
-    private static Method                                addAssetPathMethod       = null;
-    private static Method                                ensureStringBlocksMethod = null;
+    private static Method addAssetPathMethod       = null;
+    private static Method ensureStringBlocksMethod = null;
 
     // field
     private static Field assetsFiled           = null;
@@ -61,7 +63,7 @@
     private static Field resDir                = null;
     private static Field packagesFiled         = null;
     private static Field resourcePackagesFiled = null;
-//    private static Field        publicSourceDirField     = null;
+    private static Field publicSourceDirField  = null;
 
 //    private static boolean isMiuiSystem = false;
 
@@ -127,8 +129,6 @@ public static void isResourceCanPatch(Context context) throws Throwable {
                 // N moved the resources to mResourceReferences
                 Field mResourceReferences = resourcesManagerClass.getDeclaredField("mResourceReferences");
                 mResourceReferences.setAccessible(true);
-//                resourceImpls = (ArrayMap<?, WeakReference<?>>) mResourceReferences.get("mResourceImpls");
-
                 references = (Collection<WeakReference<Resources>>) mResourceReferences.get(resourcesManager);
             }
         } else {
@@ -142,23 +142,29 @@ public static void isResourceCanPatch(Context context) throws Throwable {
         if (references == null) {
             throw new IllegalStateException("resource references is null");
         }
-        try {
+        // fix jianGuo pro has private field 'mAssets' with Resource
+        // try use mResourcesImpl first
+        if (SDK_INT >= 24) {
+            try {
+                // N moved the mAssets inside an mResourcesImpl field
+                resourcesImplFiled = Resources.class.getDeclaredField("mResourcesImpl");
+                resourcesImplFiled.setAccessible(true);
+            } catch (Throwable ignore) {
+                // for safety
+                assetsFiled = Resources.class.getDeclaredField("mAssets");
+                assetsFiled.setAccessible(true);
+            }
+        } else {
             assetsFiled = Resources.class.getDeclaredField("mAssets");
             assetsFiled.setAccessible(true);
-        } catch (Throwable ignore) {
-            // N moved the mAssets inside an mResourcesImpl field
-            resourcesImplFiled = Resources.class.getDeclaredField("mResourcesImpl");
-            resourcesImplFiled.setAccessible(true);
         }
-
 //        final Resources resources = context.getResources();
 //        isMiuiSystem = resources != null && MIUI_RESOURCE_CLASSNAME.equals(resources.getClass().getName());
 
-//        try {
-//            publicSourceDirField = ShareReflectUtil.findField(ApplicationInfo.class, "publicSourceDir");
-//        } catch (NoSuchFieldException e) {
-//            throw new IllegalStateException("cannot find 'mInstrumentation' field");
-//        }
+        try {
+            publicSourceDirField = ShareReflectUtil.findField(ApplicationInfo.class, "publicSourceDir");
+        } catch (NoSuchFieldException ignore) {
+        }
     }
 
     /**
@@ -219,7 +225,15 @@ public static void monkeyPatchExistingResources(Context context, String external
         // Handle issues caused by WebView on Android N.
         // Issue: On Android N, if an activity contains a webview, when screen rotates
         // our resource patch may lost effects.
-//        publicSourceDirField.set(context.getApplicationInfo(), externalResourceFile);
+        // for 5.x/6.x, we found Couldn't expand RemoteView for StatusBarNotification Exception
+        if (Build.VERSION.SDK_INT >= 24) {
+            try {
+                if (publicSourceDirField != null) {
+                    publicSourceDirField.set(context.getApplicationInfo(), externalResourceFile);
+                }
+            } catch (Throwable ignore) {
+            }
+        }
 
         if (!checkResUpdate(context)) {
             throw new TinkerRuntimeException(ShareConstants.CHECK_RES_INSTALL_FAIL);
@@ -237,7 +251,6 @@ private static void clearPreloadTypedArrayIssue(Resources resources) {
 //        if (!isMiuiSystem) {
 //            return;
 //        }
-
         Log.w(TAG, "try to clear typedArray cache!");
         // Clear typedArray cache.
         try {
@@ -259,12 +272,12 @@ private static void clearPreloadTypedArrayIssue(Resources resources) {
 
     private static boolean checkResUpdate(Context context) {
         try {
-            Log.e(TAG, "checkResUpdate success, found test resource assets file " + TEST_ASSETS_VALUE);
             context.getAssets().open(TEST_ASSETS_VALUE);
         } catch (Throwable e) {
             Log.e(TAG, "checkResUpdate failed, can't find test resource assets file " + TEST_ASSETS_VALUE + " e:" + e.getMessage());
             return false;
         }
+        Log.i(TAG, "checkResUpdate success, found test resource assets file " + TEST_ASSETS_VALUE);
         return true;
     }
 }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerTestAndroidNClassLoader.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerTestAndroidNClassLoader.java
new file mode 100644
index 00000000..44c90d3e
--- /dev/null
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerTestAndroidNClassLoader.java
@@ -0,0 +1,39 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.loader;
+
+/**
+ * Created by tangyinsheng on 17/3/15.
+ *
+ * This class is used to test if our AndroidNClassLoader can load classes in base.apk
+ * after its pathList is updated.
+ *
+ * <b> DO NOT touch this class in any places !! </b>
+ *
+ * <b>
+ *     If you change name of this class, you should also make such change in these places:
+ *      TinkerProguardConfigTask.groovy
+ *      TinkerMultidexConfigTask.groovy
+ *      AndroidNClassLoader.java
+ * </b>
+ */
+public final class TinkerTestAndroidNClassLoader {
+
+    private TinkerTestAndroidNClassLoader() {
+        throw new UnsupportedOperationException();
+    }
+}
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerUncaughtHandler.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerUncaughtHandler.java
index 8471914c..79b85ed9 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerUncaughtHandler.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerUncaughtHandler.java
@@ -47,7 +47,7 @@ public TinkerUncaughtHandler(Context context) {
 
     @Override
     public void uncaughtException(Thread thread, Throwable ex) {
-        Log.e(TAG, "catch exception when loading tinker:" + Log.getStackTraceString(ex));
+        Log.e(TAG, "TinkerUncaughtHandler catch exception:" + Log.getStackTraceString(ex));
         ueh.uncaughtException(thread, ex);
 
         if (crashFile != null) {
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/ApplicationLike.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/ApplicationLike.java
index ca0a9059..4278e3f1 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/ApplicationLike.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/ApplicationLike.java
@@ -114,5 +114,9 @@ public AssetManager getAssets(AssetManager assetManager) {
     public Object getSystemService(String name, Object service) {
         return service;
     }
+
+    public Context getBaseContext(Context base) {
+        return base;
+    }
 }
 
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/TinkerApplication.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/TinkerApplication.java
index bcdab701..22d22799 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/TinkerApplication.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/TinkerApplication.java
@@ -64,6 +64,7 @@
     private final boolean tinkerLoadVerifyFlag;
     private final String  delegateClassName;
     private final String  loaderClassName;
+
     /**
      * if we have load patch, we should use safe mode
      */
@@ -92,7 +93,6 @@ protected TinkerApplication(int tinkerFlags, String delegateClassName,
         this.delegateClassName = delegateClassName;
         this.loaderClassName = loaderClassName;
         this.tinkerLoadVerifyFlag = tinkerLoadVerifyFlag;
-
     }
 
     protected TinkerApplication(int tinkerFlags, String delegateClassName) {
@@ -156,9 +156,9 @@ private void loadTinker() {
             //reflect tinker loader, because loaderClass may be define by user!
             Class<?> tinkerLoadClass = Class.forName(loaderClassName, false, getClassLoader());
 
-            Method loadMethod = tinkerLoadClass.getMethod(TINKER_LOADER_METHOD, TinkerApplication.class, int.class, boolean.class);
+            Method loadMethod = tinkerLoadClass.getMethod(TINKER_LOADER_METHOD, TinkerApplication.class);
             Constructor<?> constructor = tinkerLoadClass.getConstructor();
-            tinkerResultIntent = (Intent) loadMethod.invoke(constructor.newInstance(), this, tinkerFlags, tinkerLoadVerifyFlag);
+            tinkerResultIntent = (Intent) loadMethod.invoke(constructor.newInstance(), this);
         } catch (Throwable e) {
             //has exception, put exception error code
             ShareIntentUtil.setIntentReturnCode(tinkerResultIntent, ShareConstants.ERROR_LOAD_PATCH_UNKNOWN_EXCEPTION);
@@ -242,7 +242,24 @@ public Object getSystemService(String name) {
         return service;
     }
 
+    @Override
+    public Context getBaseContext() {
+        Context base = super.getBaseContext();
+        if (applicationLike != null) {
+            return applicationLike.getBaseContext(base);
+        }
+        return base;
+    }
+
     public void setUseSafeMode(boolean useSafeMode) {
         this.useSafeMode = useSafeMode;
     }
+
+    public boolean isTinkerLoadVerifyFlag() {
+        return tinkerLoadVerifyFlag;
+    }
+
+    public int getTinkerFlags() {
+        return tinkerFlags;
+    }
 }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareConstants.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareConstants.java
index 9d485d78..771c8917 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareConstants.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareConstants.java
@@ -16,11 +16,13 @@
 
 package com.tencent.tinker.loader.shareutil;
 
+import java.util.regex.Pattern;
+
 /**
  * Created by zhangshaowen on 16/3/24.
  */
 public class ShareConstants {
-    public static final String TINKER_VERSION = "1.7.7";
+    public static final String TINKER_VERSION = "1.8.1";
 
     public static final int BUFFER_SIZE         = 16384;
     public static final int MD5_LENGTH          = 32;
@@ -42,14 +44,31 @@
     public static final String SO_PATH      = "lib";
 
 
-    public static final String DEX_META_FILE     = "assets/dex_meta.txt";
-    public static final String DEX_PATH          = "dex";
-    public static final String DEX_OPTIMIZE_PATH = "odex";
-    public static final String DEX_SUFFIX        = ".dex";
-    public static final String JAR_SUFFIX        = ".jar";
+    public static final String DEX_META_FILE               = "assets/dex_meta.txt";
+    public static final String DEX_PATH                    = "dex";
+    public static final String DEFAULT_DEX_OPTIMIZE_PATH   = "odex";
+    public static final String ANDROID_O_DEX_OPTIMIZE_PATH = "oat";
+
+    public static final String INTERPRET_DEX_OPTIMIZE_PATH = "interpet";
+    public static final String CHANING_DEX_OPTIMIZE_PATH   = "changing";
+
+    public static final Pattern CLASS_N_PATTERN = Pattern.compile("classes(?:[2-9]{0,1}|[1-9][0-9]+)\\.dex(\\.jar)?");
+
+
+    public static final String DEX_SUFFIX  = ".dex";
+    public static final String JAR_SUFFIX  = ".jar";
+    public static final String ODEX_SUFFIX = ".odex";
+
+    public static final String TEST_DEX_NAME            = "test.dex";
+    public static final String CHANGED_CLASSES_DEX_NAME = "changed_classes.dex";
+    public static final String CLASS_N_APK_NAME         = "tinker_classN.apk";
 
     public static final String CHECK_DEX_INSTALL_FAIL = "checkDexInstall failed";
     public static final String CHECK_RES_INSTALL_FAIL = "checkResInstall failed";
+
+    public static final String CHECK_DEX_OAT_EXIST_FAIL  = "checkDexOptExist failed";
+    public static final String CHECK_DEX_OAT_FORMAT_FAIL = "checkDexOptFormat failed";
+
 //    public static final String CHECK_VM_PROPERTY_FAIL = "checkVmArtProperty failed";
 
 
@@ -104,9 +123,10 @@
     public static final int TYPE_PATCH_INFO = 2;
     public static final int TYPE_DEX        = 3;
 
-    public static final int TYPE_DEX_OPT  = 4;
-    public static final int TYPE_LIBRARY  = 5;
-    public static final int TYPE_RESOURCE = 6;
+    public static final int TYPE_DEX_OPT     = 4;
+    public static final int TYPE_LIBRARY     = 5;
+    public static final int TYPE_RESOURCE    = 6;
+    public static final int TYPE_CLASS_N_DEX = 7;
 
 
     public static final int TINKER_DISABLE             = 0x00;
@@ -117,33 +137,34 @@
     public static final int TINKER_ENABLE_ALL          = TINKER_DEX_MASK | TINKER_NATIVE_LIBRARY_MASK | TINKER_RESOURCE_MASK;
 
     //load error code
-    public static final int ERROR_LOAD_OK                                       = 0;
-    public static final int ERROR_LOAD_DISABLE                                  = -1;
-    public static final int ERROR_LOAD_PATCH_DIRECTORY_NOT_EXIST                = -2;
-    public static final int ERROR_LOAD_PATCH_INFO_NOT_EXIST                     = -3;
-    public static final int ERROR_LOAD_PATCH_INFO_CORRUPTED                     = -4;
-    public static final int ERROR_LOAD_PATCH_INFO_BLANK                         = -5;
-    public static final int ERROR_LOAD_PATCH_VERSION_DIRECTORY_NOT_EXIST        = -6;
-    public static final int ERROR_LOAD_PATCH_VERSION_FILE_NOT_EXIST             = -7;
-    public static final int ERROR_LOAD_PATCH_PACKAGE_CHECK_FAIL                 = -8;
-    public static final int ERROR_LOAD_PATCH_VERSION_DEX_DIRECTORY_NOT_EXIST    = -9;
-    public static final int ERROR_LOAD_PATCH_VERSION_DEX_FILE_NOT_EXIST         = -10;
-    public static final int ERROR_LOAD_PATCH_VERSION_DEX_OPT_FILE_NOT_EXIST     = -11;
-    public static final int ERROR_LOAD_PATCH_VERSION_DEX_CLASSLOADER_NULL       = -12;
-    public static final int ERROR_LOAD_PATCH_VERSION_DEX_MD5_MISMATCH           = -13;
-    public static final int ERROR_LOAD_PATCH_VERSION_DEX_LOAD_EXCEPTION         = -14;
-    public static final int ERROR_LOAD_PATCH_VERSION_PARALLEL_DEX_OPT_EXCEPTION = -15;
-
-    public static final int ERROR_LOAD_PATCH_VERSION_LIB_DIRECTORY_NOT_EXIST      = -16;
-    public static final int ERROR_LOAD_PATCH_VERSION_LIB_FILE_NOT_EXIST           = -17;
-    public static final int ERROR_LOAD_PATCH_REWRITE_PATCH_INFO_FAIL              = -18;
-    public static final int ERROR_LOAD_PATCH_UNKNOWN_EXCEPTION                    = -19;
+    public static final int ERROR_LOAD_OK                                      = 0;
+    public static final int ERROR_LOAD_DISABLE                                 = -1;
+    public static final int ERROR_LOAD_PATCH_DIRECTORY_NOT_EXIST               = -2;
+    public static final int ERROR_LOAD_PATCH_INFO_NOT_EXIST                    = -3;
+    public static final int ERROR_LOAD_PATCH_INFO_CORRUPTED                    = -4;
+    public static final int ERROR_LOAD_PATCH_INFO_BLANK                        = -5;
+    public static final int ERROR_LOAD_PATCH_VERSION_DIRECTORY_NOT_EXIST       = -6;
+    public static final int ERROR_LOAD_PATCH_VERSION_FILE_NOT_EXIST            = -7;
+    public static final int ERROR_LOAD_PATCH_PACKAGE_CHECK_FAIL                = -8;
+    public static final int ERROR_LOAD_PATCH_VERSION_DEX_DIRECTORY_NOT_EXIST   = -9;
+    public static final int ERROR_LOAD_PATCH_VERSION_DEX_FILE_NOT_EXIST        = -10;
+    public static final int ERROR_LOAD_PATCH_VERSION_DEX_OPT_FILE_NOT_EXIST    = -11;
+    public static final int ERROR_LOAD_PATCH_VERSION_DEX_CLASSLOADER_NULL      = -12;
+    public static final int ERROR_LOAD_PATCH_VERSION_DEX_MD5_MISMATCH          = -13;
+    public static final int ERROR_LOAD_PATCH_VERSION_DEX_LOAD_EXCEPTION        = -14;
+    public static final int ERROR_LOAD_PATCH_GET_OTA_INSTRUCTION_SET_EXCEPTION = -15;
+    public static final int ERROR_LOAD_PATCH_OTA_INTERPRET_ONLY_EXCEPTION      = -16;
+
+    public static final int ERROR_LOAD_PATCH_VERSION_LIB_DIRECTORY_NOT_EXIST      = -17;
+    public static final int ERROR_LOAD_PATCH_VERSION_LIB_FILE_NOT_EXIST           = -18;
+    public static final int ERROR_LOAD_PATCH_REWRITE_PATCH_INFO_FAIL              = -19;
+    public static final int ERROR_LOAD_PATCH_UNKNOWN_EXCEPTION                    = -20;
     //resource
-    public static final int ERROR_LOAD_PATCH_VERSION_RESOURCE_DIRECTORY_NOT_EXIST = -20;
-    public static final int ERROR_LOAD_PATCH_VERSION_RESOURCE_FILE_NOT_EXIST      = -21;
-    public static final int ERROR_LOAD_PATCH_VERSION_RESOURCE_LOAD_EXCEPTION      = -22;
-    public static final int ERROR_LOAD_PATCH_VERSION_RESOURCE_MD5_MISMATCH        = -23;
-    public static final int ERROR_LOAD_PATCH_UNCAUGHT_EXCEPTION                   = -24;
+    public static final int ERROR_LOAD_PATCH_VERSION_RESOURCE_DIRECTORY_NOT_EXIST = -21;
+    public static final int ERROR_LOAD_PATCH_VERSION_RESOURCE_FILE_NOT_EXIST      = -22;
+    public static final int ERROR_LOAD_PATCH_VERSION_RESOURCE_LOAD_EXCEPTION      = -23;
+    public static final int ERROR_LOAD_PATCH_VERSION_RESOURCE_MD5_MISMATCH        = -24;
+    public static final int ERROR_LOAD_PATCH_UNCAUGHT_EXCEPTION                   = -25;
 
     public static final int ERROR_LOAD_GET_INTENT_FAIL = -10000;
 
@@ -153,15 +174,17 @@
     public static final int ERROR_LOAD_EXCEPTION_DEX      = -2;
     public static final int ERROR_LOAD_EXCEPTION_RESOURCE = -3;
     public static final int ERROR_LOAD_EXCEPTION_UNCAUGHT = -4;
-    public static final int ERROR_LOAD_EXCEPTION_DEX_OPT  = -5;
-
 
     //patch listener error code
-    public static final int ERROR_PATCH_OK        = 0;
-    public static final int ERROR_PATCH_DISABLE   = -1;
-    public static final int ERROR_PATCH_NOTEXIST  = -2;
-    public static final int ERROR_PATCH_RUNNING   = -3;
-    public static final int ERROR_PATCH_INSERVICE = -4;
+    public static final int ERROR_PATCH_OK                = 0;
+    public static final int ERROR_PATCH_DISABLE           = -1;
+    public static final int ERROR_PATCH_NOTEXIST          = -2;
+    public static final int ERROR_PATCH_RUNNING           = -3;
+    public static final int ERROR_PATCH_INSERVICE         = -4;
+    public static final int ERROR_PATCH_JIT               = -5;
+    public static final int ERROR_PATCH_ALREADY_APPLY     = -6;
+    public static final int ERROR_PATCH_RETRY_COUNT_LIMIT = -7;
+
 
     //package check error code
     public static final int ERROR_PACKAGE_CHECK_OK                        = 0;
@@ -174,4 +197,11 @@
     public static final int ERROR_PACKAGE_CHECK_TINKER_ID_NOT_EQUAL       = -7;
     public static final int ERROR_PACKAGE_CHECK_RESOURCE_META_CORRUPTED   = -8;
     public static final int ERROR_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT    = -9;
+
+    // interpret error type
+    public static final int TYPE_INTERPRET_OK                        = 0;
+    public static final int TYPE_INTERPRET_GET_INSTRUCTION_SET_ERROR = 1;
+    public static final int TYPE_INTERPRET_COMMAND_ERROR             = 2;
+
+
 }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareDexDiffPatchInfo.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareDexDiffPatchInfo.java
index a623f195..80b1d88f 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareDexDiffPatchInfo.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareDexDiffPatchInfo.java
@@ -28,6 +28,8 @@
     public final String destMd5InDvm;
     public final String destMd5InArt;
     public final String oldDexCrC;
+    public final String newDexCrC;
+
     public final String dexDiffMd5;
 
     public final String path;
@@ -42,7 +44,8 @@
     public final String realName;
 
 
-    public ShareDexDiffPatchInfo(String name, String path, String destMd5InDvm, String destMd5InArt, String dexDiffMd5, String oldDexCrc, String dexMode) {
+    public ShareDexDiffPatchInfo(String name, String path, String destMd5InDvm, String destMd5InArt,
+                                 String dexDiffMd5, String oldDexCrc, String newDexCrC, String dexMode) {
         // TODO Auto-generated constructor stub
         this.rawName = name;
         this.path = path;
@@ -50,6 +53,7 @@ public ShareDexDiffPatchInfo(String name, String path, String destMd5InDvm, Stri
         this.destMd5InArt = destMd5InArt;
         this.dexDiffMd5 = dexDiffMd5;
         this.oldDexCrC = oldDexCrc;
+        this.newDexCrC = newDexCrC;
         this.dexMode = dexMode;
         if (dexMode.equals(ShareConstants.DEXMODE_JAR)) {
             this.isJarMode = true;
@@ -75,8 +79,8 @@ public static void parseDexDiffPatchInfo(String meta, ArrayList<ShareDexDiffPatc
             if (line == null || line.length() <= 0) {
                 continue;
             }
-            final String[] kv = line.split(",", 7);
-            if (kv == null || kv.length < 7) {
+            final String[] kv = line.split(",", 8);
+            if (kv == null || kv.length < 8) {
                 continue;
             }
 
@@ -87,9 +91,12 @@ public static void parseDexDiffPatchInfo(String meta, ArrayList<ShareDexDiffPatc
             final String destMd5InArt = kv[3].trim();
             final String dexDiffMd5 = kv[4].trim();
             final String oldDexCrc = kv[5].trim();
-            final String dexMode = kv[6].trim();
+            final String newDexCrc = kv[6].trim();
+
+            final String dexMode = kv[7].trim();
 
-            ShareDexDiffPatchInfo dexInfo = new ShareDexDiffPatchInfo(name, path, destMd5InDvm, destMd5InArt, dexDiffMd5, oldDexCrc, dexMode);
+            ShareDexDiffPatchInfo dexInfo = new ShareDexDiffPatchInfo(name, path, destMd5InDvm, destMd5InArt,
+                dexDiffMd5, oldDexCrc, newDexCrc, dexMode);
             dexList.add(dexInfo);
         }
 
@@ -120,6 +127,8 @@ public String toString() {
         sb.append(",");
         sb.append(oldDexCrC);
         sb.append(",");
+        sb.append(newDexCrC);
+        sb.append(",");
         sb.append(dexDiffMd5);
         sb.append(",");
         sb.append(dexMode);
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareElfFile.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareElfFile.java
new file mode 100755
index 00000000..54f36ed1
--- /dev/null
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareElfFile.java
@@ -0,0 +1,385 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.loader.shareutil;
+
+import java.io.Closeable;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.nio.channels.FileChannel;
+import java.nio.charset.Charset;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Created by tangyinsheng on 2017/3/13.
+ */
+
+public class ShareElfFile implements Closeable {
+    public static final int FILE_TYPE_OTHERS = -1;
+    public static final int FILE_TYPE_ODEX = 0;
+    public static final int FILE_TYPE_ELF = 1;
+
+    private final FileInputStream fis;
+    private final Map<String, SectionHeader> sectionNameToHeaderMap = new HashMap<>();
+    public ElfHeader elfHeader = null;
+    public ProgramHeader[] programHeaders = null;
+    public SectionHeader[] sectionHeaders = null;
+
+    public ShareElfFile(File file) throws IOException {
+        fis = new FileInputStream(file);
+        final FileChannel channel = fis.getChannel();
+
+        elfHeader = new ElfHeader(channel);
+
+        final ByteBuffer headerBuffer = ByteBuffer.allocate(128);
+
+        headerBuffer.limit(elfHeader.ePhEntSize);
+        headerBuffer.order(elfHeader.eIndent[ElfHeader.EI_DATA] == ElfHeader.ELFDATA2LSB ? ByteOrder.LITTLE_ENDIAN : ByteOrder.BIG_ENDIAN);
+        channel.position(elfHeader.ePhOff);
+        programHeaders = new ProgramHeader[elfHeader.ePhNum];
+        for (int i = 0; i < programHeaders.length; ++i) {
+            readUntilLimit(channel, headerBuffer, "failed to read phdr.");
+            programHeaders[i] = new ProgramHeader(headerBuffer, elfHeader.eIndent[ElfHeader.EI_CLASS]);
+        }
+
+        channel.position(elfHeader.eShOff);
+        headerBuffer.limit(elfHeader.eShEntSize);
+        sectionHeaders = new SectionHeader[elfHeader.eShNum];
+        for (int i = 0; i < sectionHeaders.length; ++i) {
+            readUntilLimit(channel, headerBuffer, "failed to read shdr.");
+            sectionHeaders[i] = new SectionHeader(headerBuffer, elfHeader.eIndent[ElfHeader.EI_CLASS]);
+        }
+
+        if (elfHeader.eShStrNdx > 0) {
+            final SectionHeader shStrTabSectionHeader = sectionHeaders[elfHeader.eShStrNdx];
+            final ByteBuffer shStrTab = getSection(shStrTabSectionHeader);
+            for (SectionHeader shdr : sectionHeaders) {
+                shStrTab.position(shdr.shName);
+                shdr.shNameStr = readCString(shStrTab);
+                sectionNameToHeaderMap.put(shdr.shNameStr, shdr);
+            }
+        }
+    }
+
+    private static void assertInRange(int b, int lb, int ub, String errMsg) throws IOException {
+        if (b < lb || b > ub) {
+            throw new IOException(errMsg);
+        }
+    }
+
+    public static int getFileTypeByMagic(File file) throws IOException {
+        InputStream is = null;
+        try {
+            final byte[] magicBuf = new byte[4];
+            is = new FileInputStream(file);
+            is.read(magicBuf);
+            if (magicBuf[0] == 'd' && magicBuf[1] == 'e' && magicBuf[2] == 'y' && magicBuf[3] == '\n') {
+                return FILE_TYPE_ODEX;
+            } else if (magicBuf[0] == 0x7F && magicBuf[1] == 'E' && magicBuf[2] == 'L' && magicBuf[3] == 'F') {
+                return FILE_TYPE_ELF;
+            } else {
+                return FILE_TYPE_OTHERS;
+            }
+        } finally {
+            if (is != null) {
+                try {
+                    is.close();
+                } catch (Throwable thr) {
+                    // Ignored.
+                }
+            }
+        }
+    }
+
+    public static void readUntilLimit(FileChannel channel, ByteBuffer bufferOut, String errMsg) throws IOException {
+        bufferOut.rewind();
+        int bytesRead = channel.read(bufferOut);
+        if (bytesRead != bufferOut.limit()) {
+            throw new IOException(errMsg + " Rest bytes insufficient, expect to read "
+                    + bufferOut.limit() + " bytes but only "
+                    + bytesRead + " bytes were read.");
+        }
+        bufferOut.flip();
+    }
+
+    public static String readCString(ByteBuffer buffer) {
+        final byte[] rawBuffer = buffer.array();
+        int begin = buffer.position();
+        while (buffer.hasRemaining() && rawBuffer[buffer.position()] != 0) {
+            buffer.position(buffer.position() + 1);
+        }
+        // Move to the start of next cstring.
+        buffer.position(buffer.position() + 1);
+        return new String(rawBuffer, begin, buffer.position() - begin - 1, Charset.forName("ASCII"));
+    }
+
+    public FileChannel getChannel() {
+        return fis.getChannel();
+    }
+
+    public boolean is32BitElf() {
+        return (elfHeader.eIndent[ElfHeader.EI_CLASS] == ElfHeader.ELFCLASS32);
+    }
+
+    public ByteOrder getDataOrder() {
+        return (elfHeader.eIndent[ElfHeader.EI_DATA] == ElfHeader.ELFDATA2LSB ? ByteOrder.LITTLE_ENDIAN : ByteOrder.BIG_ENDIAN);
+    }
+
+    public SectionHeader getSectionHeaderByName(String name) {
+        return sectionNameToHeaderMap.get(name);
+    }
+
+    public ByteBuffer getSection(SectionHeader sectionHeader) throws IOException {
+        final ByteBuffer result = ByteBuffer.allocate((int) sectionHeader.shSize);
+        fis.getChannel().position(sectionHeader.shOffset);
+        readUntilLimit(fis.getChannel(), result, "failed to read section: " + sectionHeader.shNameStr);
+        return result;
+    }
+
+    public ByteBuffer getSegment(ProgramHeader programHeader) throws IOException {
+        final ByteBuffer result = ByteBuffer.allocate((int) programHeader.pFileSize);
+        fis.getChannel().position(programHeader.pOffset);
+        readUntilLimit(fis.getChannel(), result, "failed to read segment (type: " + programHeader.pType + ").");
+        return result;
+    }
+
+    @Override
+    public void close() throws IOException {
+        fis.close();
+        sectionNameToHeaderMap.clear();
+        programHeaders = null;
+        sectionHeaders = null;
+    }
+
+    public static class ElfHeader {
+        // Elf indent field index.
+        public static final int EI_CLASS = 4;
+        public static final int EI_DATA = 5;
+        public static final int EI_VERSION = 6;
+        // Elf classes.
+        public static final int ELFCLASS32 = 1;
+        public static final int ELFCLASS64 = 2;
+        // Elf data encoding.
+        public static final int ELFDATA2LSB = 1;
+        public static final int ELFDATA2MSB = 2;
+        // Elf types.
+        public static final int ET_NONE = 0;
+        public static final int ET_REL = 1;
+        public static final int ET_EXEC = 2;
+        public static final int ET_DYN = 3;
+        public static final int ET_CORE = 4;
+        public static final int ET_LOPROC = 0xff00;
+        public static final int ET_HIPROC = 0xffff;
+        // Elf indent version.
+        public static final int EV_CURRENT = 1;
+        private static final int EI_NINDENT = 16;
+        public final byte[] eIndent = new byte[EI_NINDENT];
+        public final short eType;
+        public final short eMachine;
+        public final int eVersion;
+        public final long eEntry;
+        public final long ePhOff;
+        public final long eShOff;
+        public final int eFlags;
+        public final short eEhSize;
+        public final short ePhEntSize;
+        public final short ePhNum;
+        public final short eShEntSize;
+        public final short eShNum;
+        public final short eShStrNdx;
+
+        private ElfHeader(FileChannel channel) throws IOException {
+            channel.position(0);
+            channel.read(ByteBuffer.wrap(eIndent));
+            if (eIndent[0] != 0x7F || eIndent[1] != 'E' || eIndent[2] != 'L' || eIndent[3] != 'F') {
+                throw new IOException(String.format("bad elf magic: %x %x %x %x.", eIndent[0], eIndent[1], eIndent[2], eIndent[3]));
+            }
+
+            assertInRange(eIndent[EI_CLASS], ELFCLASS32, ELFCLASS64, "bad elf class: " + eIndent[EI_CLASS]);
+            assertInRange(eIndent[EI_DATA], ELFDATA2LSB, ELFDATA2MSB, "bad elf data encoding: " + eIndent[EI_DATA]);
+
+            final ByteBuffer restBuffer = ByteBuffer.allocate(eIndent[EI_CLASS] == ELFCLASS32 ? 36 : 48);
+            restBuffer.order(eIndent[EI_DATA] == ELFDATA2LSB ? ByteOrder.LITTLE_ENDIAN : ByteOrder.BIG_ENDIAN);
+            readUntilLimit(channel, restBuffer, "failed to read rest part of ehdr.");
+
+            eType = restBuffer.getShort();
+            eMachine = restBuffer.getShort();
+
+            eVersion = restBuffer.getInt();
+            assertInRange(eVersion, EV_CURRENT, EV_CURRENT, "bad elf version: " + eVersion);
+
+            switch (eIndent[EI_CLASS]) {
+                case ELFCLASS32:
+                    eEntry = restBuffer.getInt();
+                    ePhOff = restBuffer.getInt();
+                    eShOff = restBuffer.getInt();
+                    break;
+                case ELFCLASS64:
+                    eEntry = restBuffer.getLong();
+                    ePhOff = restBuffer.getLong();
+                    eShOff = restBuffer.getLong();
+                    break;
+                default:
+                    throw new IOException("Unexpected elf class: " + eIndent[EI_CLASS]);
+            }
+            eFlags = restBuffer.getInt();
+            eEhSize = restBuffer.getShort();
+            ePhEntSize = restBuffer.getShort();
+            ePhNum = restBuffer.getShort();
+            eShEntSize = restBuffer.getShort();
+            eShNum = restBuffer.getShort();
+            eShStrNdx = restBuffer.getShort();
+        }
+    }
+
+    public static class ProgramHeader {
+        // Segment types.
+        public static final int PT_NULL = 0;
+        public static final int PT_LOAD = 1;
+        public static final int PT_DYNAMIC = 2;
+        public static final int PT_INTERP = 3;
+        public static final int PT_NOTE = 4;
+        public static final int PT_SHLIB = 5;
+        public static final int PT_PHDR = 6;
+        public static final int PT_LOPROC = 0x70000000;
+        public static final int PT_HIPROC = 0x7fffffff;
+
+        // Segment flags.
+        public static final int PF_R = 0x04;
+        public static final int PF_W = 0x02;
+        public static final int PF_X = 0x01;
+
+        public final int pType;
+        public final int pFlags;
+        public final long pOffset;
+        public final long pVddr;
+        public final long pPddr;
+        public final long pFileSize;
+        public final long pMemSize;
+        public final long pAlign;
+
+        private ProgramHeader(ByteBuffer buffer, int elfClass) throws IOException {
+            switch (elfClass) {
+                case ElfHeader.ELFCLASS32:
+                    pType = buffer.getInt();
+                    pOffset = buffer.getInt();
+                    pVddr = buffer.getInt();
+                    pPddr = buffer.getInt();
+                    pFileSize = buffer.getInt();
+                    pMemSize = buffer.getInt();
+                    pFlags = buffer.getInt();
+                    pAlign = buffer.getInt();
+                    break;
+                case ElfHeader.ELFCLASS64:
+                    pType = buffer.getInt();
+                    pFlags = buffer.getInt();
+                    pOffset = buffer.getLong();
+                    pVddr = buffer.getLong();
+                    pPddr = buffer.getLong();
+                    pFileSize = buffer.getLong();
+                    pMemSize = buffer.getLong();
+                    pAlign = buffer.getLong();
+                    break;
+                default:
+                    throw new IOException("Unexpected elf class: " + elfClass);
+            }
+        }
+    }
+
+    public static class SectionHeader {
+        // Special section indexes.
+        public static final int SHN_UNDEF = 0;
+        public static final int SHN_LORESERVE = 0xff00;
+        public static final int SHN_LOPROC = 0xff00;
+        public static final int SHN_HIPROC = 0xff1f;
+        public static final int SHN_ABS = 0xfff1;
+        public static final int SHN_COMMON = 0xfff2;
+        public static final int SHN_HIRESERVE = 0xffff;
+
+        // Section types.
+        public static final int SHT_NULL = 0;
+        public static final int SHT_PROGBITS = 1;
+        public static final int SHT_SYMTAB = 2;
+        public static final int SHT_STRTAB = 3;
+        public static final int SHT_RELA = 4;
+        public static final int SHT_HASH = 5;
+        public static final int SHT_DYNAMIC = 6;
+        public static final int SHT_NOTE = 7;
+        public static final int SHT_NOBITS = 8;
+        public static final int SHT_REL = 9;
+        public static final int SHT_SHLIB = 10;
+        public static final int SHT_DYNSYM = 11;
+        public static final int SHT_LOPROC = 0x70000000;
+        public static final int SHT_HIPROC = 0x7fffffff;
+        public static final int SHT_LOUSER = 0x80000000;
+        public static final int SHT_HIUSER = 0xffffffff;
+
+        // Section flags.
+        public static final int SHF_WRITE = 0x1;
+        public static final int SHF_ALLOC = 0x2;
+        public static final int SHF_EXECINSTR = 0x4;
+        public static final int SHF_MASKPROC = 0xf0000000;
+
+        public final int shName;
+        public final int shType;
+        public final long shFlags;
+        public final long shAddr;
+        public final long shOffset;
+        public final long shSize;
+        public final int shLink;
+        public final int shInfo;
+        public final long shAddrAlign;
+        public final long shEntSize;
+        public String shNameStr;
+
+        private SectionHeader(ByteBuffer buffer, int elfClass) throws IOException {
+            switch (elfClass) {
+                case ElfHeader.ELFCLASS32:
+                    shName = buffer.getInt();
+                    shType = buffer.getInt();
+                    shFlags = buffer.getInt();
+                    shAddr = buffer.getInt();
+                    shOffset = buffer.getInt();
+                    shSize = buffer.getInt();
+                    shLink = buffer.getInt();
+                    shInfo = buffer.getInt();
+                    shAddrAlign = buffer.getInt();
+                    shEntSize = buffer.getInt();
+                    break;
+                case ElfHeader.ELFCLASS64:
+                    shName = buffer.getInt();
+                    shType = buffer.getInt();
+                    shFlags = buffer.getLong();
+                    shAddr = buffer.getLong();
+                    shOffset = buffer.getLong();
+                    shSize = buffer.getLong();
+                    shLink = buffer.getInt();
+                    shInfo = buffer.getInt();
+                    shAddrAlign = buffer.getLong();
+                    shEntSize = buffer.getLong();
+                    break;
+                default:
+                    throw new IOException("Unexpected elf class: " + elfClass);
+            }
+            shNameStr = null;
+        }
+    }
+}
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareIntentUtil.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareIntentUtil.java
index 7cf48852..19a0280a 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareIntentUtil.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareIntentUtil.java
@@ -42,6 +42,9 @@
     public static final  String INTENT_PATCH_PACKAGE_PATCH_CHECK = "intent_patch_package_patch_check";
     public static final  String INTENT_PATCH_PACKAGE_CONFIG      = "intent_patch_package_config";
     public static final  String INTENT_PATCH_SYSTEM_OTA          = "intent_patch_system_ota";
+    public static final  String INTENT_PATCH_OAT_DIR             = "intent_patch_oat_dir";
+    public static final  String INTENT_PATCH_INTERPRET_EXCEPTION = "intent_patch_interpret_exception";
+
 
     private static final String TAG                              = "ShareIntentUtil";
 
@@ -61,10 +64,18 @@ public static long getIntentPatchCostTime(Intent intent) {
         return intent.getLongExtra(INTENT_PATCH_COST_TIME, 0);
     }
 
-    public static Exception getIntentPatchException(Intent intent) {
+    public static Throwable getIntentPatchException(Intent intent) {
         Serializable serializable = getSerializableExtra(intent, INTENT_PATCH_EXCEPTION);
         if (serializable != null) {
-            return (Exception) serializable;
+            return (Throwable) serializable;
+        }
+        return null;
+    }
+
+    public static Throwable getIntentInterpretException(Intent intent) {
+        Serializable serializable = getSerializableExtra(intent, INTENT_PATCH_INTERPRET_EXCEPTION);
+        if (serializable != null) {
+            return (Throwable) serializable;
         }
         return null;
     }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareOatUtil.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareOatUtil.java
new file mode 100755
index 00000000..d77c1af7
--- /dev/null
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareOatUtil.java
@@ -0,0 +1,151 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.loader.shareutil;
+
+import java.io.File;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.channels.FileChannel;
+import java.nio.charset.Charset;
+
+/**
+ * Created by tangyinsheng on 2017/3/14.
+ */
+
+public final class ShareOatUtil {
+    private static final String TAG = "Tinker.OatUtil";
+
+    private ShareOatUtil() {
+        throw new UnsupportedOperationException();
+    }
+
+    /**
+     * Get instruction set used to generate {@code oatFile}.
+     *
+     * @param oatFile
+     *  the oat file.
+     * @return
+     *  the instruction used to generate this oat file, if the oat file does not
+     *  contain this value, an empty string will be returned.
+     *
+     * @throws IOException
+     *  If anything wrong when parsing the elf format or locating target field in oat header.
+     */
+    public static String getOatFileInstructionSet(File oatFile) throws Throwable {
+        ShareElfFile elfFile = null;
+        String result = "";
+        try {
+            elfFile = new ShareElfFile(oatFile);
+            final ShareElfFile.SectionHeader roDataHdr = elfFile.getSectionHeaderByName(".rodata");
+            if (roDataHdr == null) {
+                throw new IOException("Unable to find .rodata section.");
+            }
+
+            final FileChannel channel = elfFile.getChannel();
+            channel.position(roDataHdr.shOffset);
+
+            final byte[] oatMagicAndVersion = new byte[8];
+            ShareElfFile.readUntilLimit(channel, ByteBuffer.wrap(oatMagicAndVersion), "Failed to read oat magic and version.");
+
+            if (oatMagicAndVersion[0] != 'o'
+                    || oatMagicAndVersion[1] != 'a'
+                    || oatMagicAndVersion[2] != 't'
+                    || oatMagicAndVersion[3] != '\n') {
+                throw new IOException(
+                        String.format("Bad oat magic: %x %x %x %x",
+                                oatMagicAndVersion[0],
+                                oatMagicAndVersion[1],
+                                oatMagicAndVersion[2],
+                                oatMagicAndVersion[3])
+                );
+            }
+
+            final int versionOffsetFromOatBegin = 4;
+            final int versionBytes = 3;
+
+            final String oatVersion = new String(oatMagicAndVersion,
+                    versionOffsetFromOatBegin, versionBytes, Charset.forName("ASCII"));
+            try {
+                Integer.parseInt(oatVersion);
+            } catch (NumberFormatException e) {
+                throw new IOException("Bad oat version: " + oatVersion);
+            }
+
+            ByteBuffer buffer = ByteBuffer.allocate(128);
+            buffer.order(elfFile.getDataOrder());
+            // TODO This is a risk point, since each oat version may use a different offset.
+            // So far it's ok. Perhaps we should use oatVersionNum to judge the right offset in
+            // the future.
+            final int isaNumOffsetFromOatBegin = 12;
+            channel.position(roDataHdr.shOffset + isaNumOffsetFromOatBegin);
+            buffer.limit(4);
+            ShareElfFile.readUntilLimit(channel, buffer, "Failed to read isa num.");
+
+            int isaNum = buffer.getInt();
+            if (isaNum < 0 || isaNum >= InstructionSet.values().length) {
+                throw new IOException("Bad isa num: " + isaNum);
+            }
+
+            switch (InstructionSet.values()[isaNum]) {
+                case kArm:
+                case kThumb2:
+                    result = "arm";
+                    break;
+                case kArm64:
+                    result = "arm64";
+                    break;
+                case kX86:
+                    result = "x86";
+                    break;
+                case kX86_64:
+                    result = "x86_64";
+                    break;
+                case kMips:
+                    result = "mips";
+                    break;
+                case kMips64:
+                    result = "mips64";
+                    break;
+                case kNone:
+                    result = "none";
+                    break;
+                default:
+                    throw new IOException("Should not reach here.");
+            }
+        } finally {
+            if (elfFile != null) {
+                try {
+                    elfFile.close();
+                } catch (Exception ignored) {
+                    // Ignored.
+                }
+            }
+        }
+        return result;
+    }
+
+    private enum InstructionSet {
+        kNone,
+        kArm,
+        kArm64,
+        kThumb2,
+        kX86,
+        kX86_64,
+        kMips,
+        kMips64
+    }
+}
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchFileUtil.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchFileUtil.java
index 419efd88..14cba2eb 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchFileUtil.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchFileUtil.java
@@ -20,6 +20,8 @@
 import android.content.pm.ApplicationInfo;
 import android.util.Log;
 
+import com.tencent.tinker.loader.TinkerRuntimeException;
+
 import java.io.BufferedInputStream;
 import java.io.BufferedReader;
 import java.io.Closeable;
@@ -39,6 +41,8 @@
 public class SharePatchFileUtil {
     private static final String TAG = "Tinker.PatchFileUtil";
 
+    private static char[] hexDigits = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};
+
     /**
      * data dir, such as /data/data/tinker.sample.android/tinker
      * @param context
@@ -129,7 +133,7 @@ public static String checkTinkerLastUncaughtCrash(Context context) {
     }
 
     public static final boolean isLegalFile(File file) {
-        return file != null && file.exists() && file.isFile() && file.length() > 0;
+        return file != null && file.exists() && file.canRead() && file.isFile() && file.length() > 0;
     }
 
     /**
@@ -232,7 +236,11 @@ public static boolean isRawDexFile(String fileName) {
      * dex may wrap with jar
      */
     public static boolean verifyDexFileMd5(File file, String md5) {
-        if (file == null || md5 == null) {
+        return verifyDexFileMd5(file, ShareConstants.DEX_IN_JAR, md5);
+    }
+
+    public static boolean verifyDexFileMd5(File file, String entryName, String md5) {
+        if (file == null || md5 == null || entryName == null) {
             return false;
         }
         //if it is not the raw dex, we check the stream instead
@@ -244,7 +252,7 @@ public static boolean verifyDexFileMd5(File file, String md5) {
             ZipFile dexJar = null;
             try {
                 dexJar = new ZipFile(file);
-                ZipEntry classesDex = dexJar.getEntry(ShareConstants.DEX_IN_JAR);
+                ZipEntry classesDex = dexJar.getEntry(entryName);
                 // no code
                 if (null == classesDex) {
                     Log.e(TAG, "There's no entry named: " + ShareConstants.DEX_IN_JAR + " in " + file.getAbsolutePath());
@@ -353,6 +361,25 @@ public final static String getMD5(final InputStream is) {
         }
     }
 
+    public static String getMD5(byte[] buffer) {
+        try {
+            MessageDigest mdTemp = MessageDigest.getInstance("MD5");
+            mdTemp.update(buffer);
+            byte[] md = mdTemp.digest();
+            int j = md.length;
+            char[] str = new char[j * 2];
+            int k = 0;
+            for (int i = 0; i < j; i++) {
+                byte byte0 = md[i];
+                str[k++] = hexDigits[byte0 >>> 4 & 0xf];
+                str[k++] = hexDigits[byte0 & 0xf];
+            }
+            return new String(str);
+        } catch (Exception e) {
+            return null;
+        }
+    }
+
     /**
      * Get the md5 for the file. call getMD5(FileInputStream is, int bufLen) inside.
      *
@@ -367,31 +394,46 @@ public static String getMD5(final File file) {
         try {
             fin = new FileInputStream(file);
             String md5 = getMD5(fin);
-            fin.close();
             return md5;
-
         } catch (Exception e) {
             return null;
-
         } finally {
-            try {
-                if (fin != null) {
-                    fin.close();
-                }
-            } catch (IOException e) {
-
-            }
+            closeQuietly(fin);
         }
     }
 
     /**
      * change the jar file path as the makeDexElements do
+     * Android O change its path
      *
      * @param path
      * @param optimizedDirectory
      * @return
      */
     public static String optimizedPathFor(File path, File optimizedDirectory) {
+        if (ShareTinkerInternals.isAfterAndroidO()) {
+            // dex_location = /foo/bar/baz.jar
+            // odex_location = /foo/bar/oat/<isa>/baz.odex
+
+            String currentInstructionSet;
+            try {
+                currentInstructionSet = ShareTinkerInternals.getCurrentInstructionSet();
+            } catch (Exception e) {
+                throw new TinkerRuntimeException("getCurrentInstructionSet fail:", e);
+            }
+
+            File parentFile = path.getParentFile();
+            String fileName = path.getName();
+            int index = fileName.lastIndexOf('.');
+            if (index > 0) {
+                fileName = fileName.substring(0, index);
+            }
+
+            String result = parentFile.getAbsolutePath() + "/oat/"
+                + currentInstructionSet + "/" + fileName + ShareConstants.ODEX_SUFFIX;
+            return result;
+        }
+
         String fileName = path.getName();
         if (!fileName.endsWith(ShareConstants.DEX_SUFFIX)) {
             int lastDot = fileName.lastIndexOf(".");
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchInfo.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchInfo.java
index 71a96450..be6dc661 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchInfo.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchInfo.java
@@ -35,16 +35,20 @@
     public static final String OLD_VERSION          = ShareConstants.OLD_VERSION;
     public static final String NEW_VERSION          = ShareConstants.NEW_VERSION;
     public static final String FINGER_PRINT         = "print";
-    private static final String TAG = "PatchInfo";
+    public static final String OAT_DIR              = "dir";
+    public static final String DEFAULT_DIR   = ShareConstants.DEFAULT_DEX_OPTIMIZE_PATH;
+    private static final String TAG = "Tinker.PatchInfo";
     public String oldVersion;
     public String newVersion;
     public String fingerPrint;
+    public String oatDir;
 
-    public SharePatchInfo(String oldVer, String newVew, String finger) {
+    public SharePatchInfo(String oldVer, String newVew, String finger, String oatDir) {
         // TODO Auto-generated constructor stub
         this.oldVersion = oldVer;
         this.newVersion = newVew;
         this.fingerPrint = finger;
+        this.oatDir = oatDir;
     }
 
     public static SharePatchInfo readAndCheckPropertyWithLock(File pathInfoFile, File lockFile) {
@@ -69,7 +73,7 @@ public static SharePatchInfo readAndCheckPropertyWithLock(File pathInfoFile, Fil
                     fileLock.close();
                 }
             } catch (IOException e) {
-                Log.i(TAG, "releaseInfoLock error", e);
+                Log.w(TAG, "releaseInfoLock error", e);
             }
         }
 
@@ -110,6 +114,7 @@ private static SharePatchInfo readAndCheckProperty(File pathInfoFile) {
         String oldVer = null;
         String newVer = null;
         String lastFingerPrint = null;
+        String oatDIr = null;
 
         while (numAttempts < MAX_EXTRACT_ATTEMPTS && !isReadPatchSuccessful) {
             numAttempts++;
@@ -121,9 +126,10 @@ private static SharePatchInfo readAndCheckProperty(File pathInfoFile) {
                 oldVer = properties.getProperty(OLD_VERSION);
                 newVer = properties.getProperty(NEW_VERSION);
                 lastFingerPrint = properties.getProperty(FINGER_PRINT);
+                oatDIr = properties.getProperty(OAT_DIR);
             } catch (IOException e) {
 //                e.printStackTrace();
-                Log.e(TAG, "read property failed, e:" + e);
+                Log.w(TAG, "read property failed, e:" + e);
             } finally {
                 SharePatchFileUtil.closeQuietly(inputStream);
             }
@@ -142,7 +148,7 @@ private static SharePatchInfo readAndCheckProperty(File pathInfoFile) {
         }
 
         if (isReadPatchSuccessful) {
-            return new SharePatchInfo(oldVer, newVer, lastFingerPrint);
+            return new SharePatchInfo(oldVer, newVer, lastFingerPrint, oatDIr);
         }
 
         return null;
@@ -152,12 +158,23 @@ private static boolean rewritePatchInfoFile(File pathInfoFile, SharePatchInfo in
         if (pathInfoFile == null || info == null) {
             return false;
         }
+        // write fingerprint if it is null or nil
+        if (ShareTinkerInternals.isNullOrNil(info.fingerPrint)) {
+            info.fingerPrint = Build.FINGERPRINT;
+        }
+        if (ShareTinkerInternals.isNullOrNil(info.oatDir)) {
+            info.oatDir = DEFAULT_DIR;
+        }
         Log.i(TAG, "rewritePatchInfoFile file path:"
             + pathInfoFile.getAbsolutePath()
             + " , oldVer:"
             + info.oldVersion
             + ", newVer:"
-            + info.newVersion);
+            + info.newVersion
+            + ", fingerprint:"
+            + info.fingerPrint
+            + ", oatDir:"
+            + info.oatDir);
 
         boolean isWritePatchSuccessful = false;
         int numAttempts = 0;
@@ -173,7 +190,8 @@ private static boolean rewritePatchInfoFile(File pathInfoFile, SharePatchInfo in
             Properties newProperties = new Properties();
             newProperties.put(OLD_VERSION, info.oldVersion);
             newProperties.put(NEW_VERSION, info.newVersion);
-            newProperties.put(FINGER_PRINT, Build.FINGERPRINT);
+            newProperties.put(FINGER_PRINT, info.fingerPrint);
+            newProperties.put(OAT_DIR, info.oatDir);
 
             FileOutputStream outputStream = null;
             try {
@@ -181,7 +199,8 @@ private static boolean rewritePatchInfoFile(File pathInfoFile, SharePatchInfo in
                 String comment = "from old version:" + info.oldVersion + " to new version:" + info.newVersion;
                 newProperties.store(outputStream, comment);
             } catch (Exception e) {
-                e.printStackTrace();
+//                e.printStackTrace();
+                Log.w(TAG, "write property failed, e:" + e);
             } finally {
                 SharePatchFileUtil.closeQuietly(outputStream);
             }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareReflectUtil.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareReflectUtil.java
index 7ebc1dbd..72b88059 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareReflectUtil.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareReflectUtil.java
@@ -19,6 +19,7 @@
 import android.content.Context;
 
 import java.lang.reflect.Array;
+import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
 import java.lang.reflect.Method;
 import java.util.Arrays;
@@ -104,6 +105,36 @@ public static Method findMethod(Object instance, String name, Class<?>... parame
             + " not found in " + instance.getClass());
     }
 
+    /**
+     * Locates a given constructor anywhere in the class inheritance hierarchy.
+     *
+     * @param instance       an object to search the constructor into.
+     * @param parameterTypes constructor parameter types
+     * @return a constructor object
+     * @throws NoSuchMethodException if the constructor cannot be located
+     */
+    public static Constructor<?> findConstructor(Object instance, Class<?>... parameterTypes)
+            throws NoSuchMethodException {
+        for (Class<?> clazz = instance.getClass(); clazz != null; clazz = clazz.getSuperclass()) {
+            try {
+                Constructor<?> ctor = clazz.getDeclaredConstructor(parameterTypes);
+
+                if (!ctor.isAccessible()) {
+                    ctor.setAccessible(true);
+                }
+
+                return ctor;
+            } catch (NoSuchMethodException e) {
+                // ignore and search next
+            }
+        }
+
+        throw new NoSuchMethodException("Constructor"
+                + " with parameters "
+                + Arrays.asList(parameterTypes)
+                + " not found in " + instance.getClass());
+    }
+
     /**
      * Replace the value of a field containing a non null array, by a new array containing the
      * elements of the original array plus the elements of extraElements.
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareSecurityCheck.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareSecurityCheck.java
index 921984cb..ca75d93b 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareSecurityCheck.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareSecurityCheck.java
@@ -27,10 +27,7 @@
 import java.io.ByteArrayInputStream;
 import java.io.File;
 import java.io.IOException;
-import java.security.PublicKey;
 import java.security.cert.Certificate;
-import java.security.cert.CertificateFactory;
-import java.security.cert.X509Certificate;
 import java.util.Enumeration;
 import java.util.HashMap;
 import java.util.jar.JarEntry;
@@ -40,22 +37,22 @@
  * Created by zhangshaowen on 16/3/10.
  */
 public class ShareSecurityCheck {
-    private static final String    TAG        = "ShareSecurityCheck";
+    private static final String TAG           = "Tinker.SecurityCheck";
     /**
      * static to faster
      * public key
      */
-    private static       PublicKey mPublicKey = null;
+    private static       String mPublicKeyMd5 = null;
 
     private final Context                 mContext;
     private final HashMap<String, String> metaContentMap;
-    private       HashMap<String, String> packageProperties;
+    private final HashMap<String, String> packageProperties;
 
     public ShareSecurityCheck(Context context) {
         mContext = context;
         metaContentMap = new HashMap<>();
-
-        if (mPublicKey == null) {
+        packageProperties = new HashMap<>();
+        if (mPublicKeyMd5 == null) {
             init(mContext);
         }
     }
@@ -70,7 +67,7 @@ public ShareSecurityCheck(Context context) {
      * @return HashMap<String, String>
      */
     public HashMap<String, String> getPackagePropertiesIfPresent() {
-        if (packageProperties != null) {
+        if (!packageProperties.isEmpty()) {
             return packageProperties;
         }
 
@@ -93,9 +90,7 @@ public ShareSecurityCheck(Context context) {
             if (kv == null || kv.length < 2) {
                 continue;
             }
-            if (packageProperties == null) {
-                packageProperties = new HashMap<>();
-            }
+
             packageProperties.put(kv[0].trim(), kv[1].trim());
         }
         return packageProperties;
@@ -121,16 +116,14 @@ public boolean verifyPatchMetaSignature(File path) {
                     continue;
                 }
                 //for faster, only check the meta.txt files
-                //we will check other files's mad5 written in meta files
+                //we will check other files's md5 written in meta files
                 if (!name.endsWith(ShareConstants.META_SUFFIX)) {
                     continue;
                 }
                 metaContentMap.put(name, SharePatchFileUtil.loadDigestes(jarFile, jarEntry));
                 Certificate[] certs = jarEntry.getCertificates();
-                if (certs == null) {
-                    return false;
-                }
-                if (!check(path, certs)) {
+
+                if (certs == null || !check(path, certs)) {
                     return false;
                 }
             }
@@ -155,8 +148,9 @@ private boolean check(File path, Certificate[] certs) {
         if (certs.length > 0) {
             for (int i = certs.length - 1; i >= 0; i--) {
                 try {
-                    certs[i].verify(mPublicKey);
-                    return true;
+                    if (mPublicKeyMd5.equals(SharePatchFileUtil.getMD5(certs[i].getEncoded()))) {
+                        return true;
+                    }
                 } catch (Exception e) {
                     Log.e(TAG, path.getAbsolutePath(), e);
                 }
@@ -172,10 +166,10 @@ private void init(Context context) {
             PackageManager pm = context.getPackageManager();
             String packageName = context.getPackageName();
             PackageInfo packageInfo = pm.getPackageInfo(packageName, PackageManager.GET_SIGNATURES);
-            CertificateFactory certFactory = CertificateFactory.getInstance("X.509");
-            stream = new ByteArrayInputStream(packageInfo.signatures[0].toByteArray());
-            X509Certificate cert = (X509Certificate) certFactory.generateCertificate(stream);
-            mPublicKey = cert.getPublicKey();
+            mPublicKeyMd5 = SharePatchFileUtil.getMD5(packageInfo.signatures[0].toByteArray());
+            if (mPublicKeyMd5 == null) {
+                throw new TinkerRuntimeException("get public key md5 is null");
+            }
         } catch (Exception e) {
             throw new TinkerRuntimeException("ShareSecurityCheck init public key fail", e);
         } finally {
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java
index 6024ba9c..2db4a411 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java
@@ -30,7 +30,9 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.PrintStream;
+import java.lang.reflect.Method;
 import java.util.HashMap;
+import java.util.List;
 import java.util.Properties;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
@@ -41,18 +43,43 @@
  * Created by zhangshaowen on 16/3/10.
  */
 public class ShareTinkerInternals {
-    private static final String TAG = "Tinker.TinkerInternals";
+    private static final String  TAG       = "Tinker.TinkerInternals";
     private static final boolean VM_IS_ART = isVmArt(System.getProperty("java.vm.version"));
+    private static final boolean VM_IS_JIT = isVmJitInternal();
+
+    private static final String  PATCH_PROCESS_NAME    = ":patch";
+    private static       Boolean isPatchProcess        = null;
     /**
      * or you may just hardcode them in your app
      */
-    private static String processName = null;
-    private static String tinkerID = null;
+    private static       String  processName           = null;
+    private static       String  tinkerID              = null;
+    private static       String  currentInstructionSet = null;
 
     public static boolean isVmArt() {
         return VM_IS_ART || Build.VERSION.SDK_INT >= 21;
     }
 
+    public static boolean isVmJit() {
+        return VM_IS_JIT && Build.VERSION.SDK_INT < 24;
+    }
+
+    public static boolean isAfterAndroidO() {
+        return Build.VERSION.SDK_INT > 25;
+    }
+
+    public static String getCurrentInstructionSet() throws Exception {
+        if (currentInstructionSet != null) {
+            return currentInstructionSet;
+        }
+        Class<?> clazz = Class.forName("dalvik.system.VMRuntime");
+        Method currentGet = clazz.getDeclaredMethod("getCurrentInstructionSet");
+
+        currentInstructionSet = (String) currentGet.invoke(null);
+        Log.d(TAG, "getCurrentInstructionSet:" + currentInstructionSet);
+        return currentInstructionSet;
+    }
+
     public static boolean isSystemOTA(String lastFingerPrint) {
         String currentFingerprint = Build.FINGERPRINT;
         if (lastFingerPrint == null
@@ -72,6 +99,21 @@ public static boolean isSystemOTA(String lastFingerPrint) {
         }
     }
 
+    public static ShareDexDiffPatchInfo changeTestDexToClassN(ShareDexDiffPatchInfo rawDexInfo, int index) {
+        if (rawDexInfo.rawName.startsWith(ShareConstants.TEST_DEX_NAME)) {
+            String newName;
+            if (index != 1) {
+                newName = "classes" + index + ".dex";
+            } else {
+                newName = "classes.dex";
+            }
+            return new ShareDexDiffPatchInfo(newName, rawDexInfo.path, rawDexInfo.destMd5InDvm, rawDexInfo.destMd5InArt,
+                rawDexInfo.dexDiffMd5, rawDexInfo.oldDexCrC, rawDexInfo.newDexCrC, rawDexInfo.dexMode);
+        }
+
+        return null;
+    }
+
     public static boolean isNullOrNil(final String object) {
         if ((object == null) || (object.length() <= 0)) {
             return true;
@@ -81,6 +123,7 @@ public static boolean isNullOrNil(final String object) {
 
     /**
      * thinker package check
+     *
      * @param context
      * @param tinkerFlag
      * @param patchFile
@@ -94,6 +137,7 @@ public static int checkTinkerPackage(Context context, int tinkerFlag, File patch
         }
         return returnCode;
     }
+
     /**
      * check patch file signature and TINKER_ID
      *
@@ -157,6 +201,7 @@ public static int checkPackageAndTinkerFlag(ShareSecurityCheck securityCheck, in
     /**
      * not like {@cod ShareSecurityCheck.getPackagePropertiesIfPresent}
      * we don't check Signatures or other files, we just get the package meta's properties directly
+     *
      * @param patchFile
      * @return
      */
@@ -246,6 +291,7 @@ public static String getTypeString(int type) {
 
     /**
      * you can set Tinker disable in runtime at some times!
+     *
      * @param context
      */
     public static void setTinkerDisableWithSharedPreferences(Context context) {
@@ -255,6 +301,7 @@ public static void setTinkerDisableWithSharedPreferences(Context context) {
 
     /**
      * can't load or receive any patch!
+     *
      * @param context
      * @return
      */
@@ -288,14 +335,40 @@ public static boolean isInMainProcess(Context context) {
         return pkgName.equals(processName);
     }
 
+    public static boolean isInPatchProcess(Context context) {
+        if (isPatchProcess != null) {
+            return isPatchProcess;
+        }
+
+        isPatchProcess = getProcessName(context).endsWith(PATCH_PROCESS_NAME);
+        return isPatchProcess;
+    }
+
+    public static String getCurrentOatMode(Context context, String current) {
+        if (current.equals(ShareConstants.CHANING_DEX_OPTIMIZE_PATH)) {
+            if (isInMainProcess(context)) {
+                current = ShareConstants.DEFAULT_DEX_OPTIMIZE_PATH;
+            } else {
+                current = ShareConstants.INTERPRET_DEX_OPTIMIZE_PATH;
+            }
+        }
+        return current;
+    }
+
     public static void killAllOtherProcess(Context context) {
         final ActivityManager am = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
         if (am == null) {
             return;
         }
+        List<ActivityManager.RunningAppProcessInfo> appProcessList = am
+            .getRunningAppProcesses();
+
+        if (appProcessList == null) {
+            return;
+        }
         // NOTE: getRunningAppProcess() ONLY GIVE YOU THE PROCESS OF YOUR OWN PACKAGE IN ANDROID M
         // BUT THAT'S ENOUGH HERE
-        for (ActivityManager.RunningAppProcessInfo ai : am.getRunningAppProcesses()) {
+        for (ActivityManager.RunningAppProcessInfo ai : appProcessList) {
             // KILL OTHER PROCESS OF MINE
             if (ai.uid == android.os.Process.myUid() && ai.pid != android.os.Process.myPid()) {
                 android.os.Process.killProcess(ai.pid);
@@ -331,19 +404,26 @@ private static String getProcessNameInternal(final Context context) {
         ActivityManager activityManager =
             (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
 
-        try {
-            for (ActivityManager.RunningAppProcessInfo process : activityManager.getRunningAppProcesses()) {
-                if (process.pid == myPid) {
-                    myProcess = process;
-                    break;
+        if (activityManager != null) {
+            List<ActivityManager.RunningAppProcessInfo> appProcessList = activityManager
+                .getRunningAppProcesses();
+
+            if (appProcessList != null) {
+                try {
+                    for (ActivityManager.RunningAppProcessInfo process : appProcessList) {
+                        if (process.pid == myPid) {
+                            myProcess = process;
+                            break;
+                        }
+                    }
+                } catch (Exception e) {
+                    Log.e(TAG, "getProcessNameInternal exception:" + e.getMessage());
                 }
-            }
-        } catch (Exception e) {
-            Log.e(TAG, "getProcessNameInternal exception:" + e.getMessage());
-        }
 
-        if (myProcess != null) {
-            return myProcess.processName;
+                if (myProcess != null) {
+                    return myProcess.processName;
+                }
+            }
         }
 
         byte[] b = new byte[128];
@@ -362,7 +442,7 @@ private static String getProcessNameInternal(final Context context) {
             }
 
         } catch (Exception e) {
-            e.printStackTrace();
+            Log.e(TAG, "getProcessNameInternal exception:" + e.getMessage());
         } finally {
             try {
                 if (in != null) {
@@ -377,6 +457,7 @@ private static String getProcessNameInternal(final Context context) {
 
     /**
      * vm whether it is art
+     *
      * @return
      */
     private static boolean isVmArt(String versionString) {
@@ -398,6 +479,24 @@ private static boolean isVmArt(String versionString) {
         return isArt;
     }
 
+    private static boolean isVmJitInternal() {
+        try {
+            Class<?> clazz = Class.forName("android.os.SystemProperties");
+            Method mthGet = clazz.getDeclaredMethod("get", String.class);
+
+            String jit = (String) mthGet.invoke(null, "dalvik.vm.usejit");
+            String jitProfile = (String) mthGet.invoke(null, "dalvik.vm.usejitprofiles");
+
+            //usejit is true and usejitprofiles is null
+            if (!isNullOrNil(jit) && isNullOrNil(jitProfile) && jit.equals("true")) {
+                return true;
+            }
+        } catch (Throwable e) {
+            Log.e(TAG, "isVmJitInternal ex:" + e);
+        }
+        return false;
+    }
+
     public static String getExceptionCauseString(final Throwable ex) {
         final ByteArrayOutputStream bos = new ByteArrayOutputStream();
         final PrintStream ps = new PrintStream(bos);
diff --git a/tinker-build/tinker-patch-cli/tool_output/merge_mapping.py b/tinker-build/tinker-patch-cli/tool_output/merge_mapping.py
index 3dc8577a..a60fda39 100644
--- a/tinker-build/tinker-patch-cli/tool_output/merge_mapping.py
+++ b/tinker-build/tinker-patch-cli/tool_output/merge_mapping.py
@@ -1,7 +1,7 @@
 #!/usr/bin/python
 # coding: utf-8
 """
-当工程使用了aplymapping之后，会遇到这样的问题
+当工程使用了applymapping之后，会遇到这样的问题
     1.类和方法上个版本被keep住了，这个版本不keep
     2.类和方法上个版本没有被keep住，这个版本又keep住了
 这两个问题会导致proguard报warning，官方建议是手动解决冲突
@@ -97,16 +97,16 @@ def do_merge(self):
                 current_data = self.current_classes[key]
                 # 如果当前的类没有被混淆，则保留，否则用之前的mapping里面的内容覆盖
                 # ___.___ -> ___.___:
-                if current_data.raw_line.split("->")[0] == current_data.raw_line.split("->")[1][:-1]:
+                if current_data.raw_line.split("->")[0] != current_data.raw_line.split("->")[1][:-1]:
                     current_data.raw_line = data.raw_line
                 new_method_list = []
                 # 处理方法
-                for line in current_data.filed_methods:
+                for line in current_data.field_methods:
                     result, new_line = self.find_same_methods(line, data)
                     # 只有找到才写入
                     if result:
                         new_method_list.append(new_line)
-                current_data.filed_methods = new_method_list
+                current_data.field_methods = new_method_list
             # 新的混淆不在旧的里面，则删除
             else:
                 del self.current_classes[key]
@@ -116,7 +116,7 @@ def find_same_methods(self, line, data):
         # 这里是特殊情况，如果在当前mapping发现查找的这个并没有混淆，就不打算保留在mapping文件中
         if search_name == search_new_name:
             return False, ""
-        for method_line in data.filed_methods:
+        for method_line in data.field_methods:
             target_name, target_complete_name, target_new_name = self.get_name_and_complete_name_and_new_name(method_line)
             # 这里必须要用最完整的信息来进行比较，避免重载的影响
             if search_complete_name == target_complete_name:
@@ -157,7 +157,7 @@ def print_new_mapping(self):
                 if key in self.current_classes:
                     data = self.current_classes[key]
                     fw.write(data.raw_line)
-                    for line in data.filed_methods:
+                    for line in data.field_methods:
                         fw.write(line)
 
 
diff --git a/tinker-build/tinker-patch-cli/tool_output/tinker_config.xml b/tinker-build/tinker-patch-cli/tool_output/tinker_config.xml
index de0c6c99..12d0920c 100644
--- a/tinker-build/tinker-patch-cli/tool_output/tinker_config.xml
+++ b/tinker-build/tinker-patch-cli/tool_output/tinker_config.xml
@@ -24,6 +24,11 @@
 
         <!--if you don't set sevenZip path, we just use 7za to try-->
         <sevenZipPath value="/usr/local/bin/7za"/>
+        <!--Whether tinker should treat the base apk as the one being protected by app-->
+        <!--protection tools.-->
+        <!--If this attribute is true, the generated patch package will contain a-->
+        <!--dex including all changed classes instead of any dexdiff patch-info files.-->
+        <isProtectedApp value="false"/>
     </issue>
 
     <issue id="dex">
@@ -52,7 +57,7 @@
         <!--it support * or ? pattern.-->
         <!--for library in assets, we would just recover them in the patch directory-->
         <!--you can get them in TinkerLoadResult with Tinker-->
-        <pattern value="lib/armeabi/*.so"/>
+        <pattern value="lib/*/*.so"/>
     </issue>
 
     <issue id="resource">
diff --git a/tinker-build/tinker-patch-cli/tool_output/tinker_multidexkeep.pro b/tinker-build/tinker-patch-cli/tool_output/tinker_multidexkeep.pro
index 263db733..5c9f4c5b 100644
--- a/tinker-build/tinker-patch-cli/tool_output/tinker_multidexkeep.pro
+++ b/tinker-build/tinker-patch-cli/tool_output/tinker_multidexkeep.pro
@@ -1,21 +1,27 @@
+#tinker multidex keep patterns:
 -keep public class * implements com.tencent.tinker.loader.app.ApplicationLifeCycle {
-    *;
+    <init>();
+    void onBaseContextAttached(android.content.Context);
 }
 
 -keep public class * extends com.tencent.tinker.loader.TinkerLoader {
-    *;
+    <init>();
 }
 
 -keep public class * extends android.app.Application {
-    *;
+     <init>();
+     void attachBaseContext(android.content.Context);
 }
 
-#your dex.loader pattern here
--keep class com.tencent.tinker.loader.** {
-    *;
+-keep class com.tencent.tinker.loader.TinkerTestAndroidNClassLoader {
+    <init>();
 }
 
+#your dex.loader patterns here
 -keep class tinker.sample.android.app.SampleApplication {
-    *;
+    <init>();
 }
 
+-keep class com.tencent.tinker.loader.** {
+    <init>();
+}
\ No newline at end of file
diff --git a/tinker-build/tinker-patch-cli/tool_output/tinker_proguard.pro b/tinker-build/tinker-patch-cli/tool_output/tinker_proguard.pro
index e4ef8030..85e96b50 100644
--- a/tinker-build/tinker-patch-cli/tool_output/tinker_proguard.pro
+++ b/tinker-build/tinker-patch-cli/tool_output/tinker_proguard.pro
@@ -25,7 +25,16 @@
     *;
 }
 
+-keep public class com.tencent.tinker.loader.TinkerTestAndroidNClassLoader {
+    *;
+}
+
+#for command line version, we must keep all the loader class to avoid proguard mapping conflict
 #your dex.loader pattern here
--keep class com.tencent.tinker.loader.**
--keep class tinker.sample.android.app.SampleApplication
+-keep public class com.tencent.tinker.loader.** {
+    *;
+}
 
+-keep class tinker.sample.android.app.SampleApplication {
+    *;
+}
\ No newline at end of file
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/TinkerPatchPlugin.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/TinkerPatchPlugin.groovy
index 9fe162e9..a3c6e0bc 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/TinkerPatchPlugin.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/TinkerPatchPlugin.groovy
@@ -20,6 +20,7 @@ import com.tencent.tinker.build.gradle.extension.*
 import com.tencent.tinker.build.gradle.task.*
 import com.tencent.tinker.build.util.FileOperation
 import com.tencent.tinker.build.util.TypedValue
+import com.tencent.tinker.build.util.Utils
 import org.gradle.api.GradleException
 import org.gradle.api.Plugin
 import org.gradle.api.Project
@@ -57,6 +58,18 @@ class TinkerPatchPlugin implements Plugin<Project> {
             throw new GradleException('generateTinkerApk: Android Application plugin required')
         }
 
+        def android = project.extensions.android
+
+        //open jumboMode
+        android.dexOptions.jumboMode = true
+
+        //close preDexLibraries
+        try {
+            android.dexOptions.preDexLibraries = false
+        } catch (Throwable e) {
+            //no preDexLibraries field, just continue
+        }
+
         project.afterEvaluate {
             def configuration = project.tinkerPatch
 
@@ -65,18 +78,6 @@ class TinkerPatchPlugin implements Plugin<Project> {
                 return
             }
 
-            def android = project.extensions.android
-
-            //open jumboMode
-            android.dexOptions.jumboMode = true
-
-            //close preDexLibraries
-            try {
-                android.dexOptions.preDexLibraries = false
-            } catch (Throwable e) {
-                //no preDexLibraries field, just continue
-            }
-
             project.logger.error("----------------------tinker build warning ------------------------------------")
             project.logger.error("tinker auto operation: ")
             project.logger.error("excluding annotation processor and source template from app packaging. Enable dx jumboMode to reduce package size.")
@@ -126,14 +127,12 @@ class TinkerPatchPlugin implements Plugin<Project> {
                 }
 
                 TinkerPatchSchemaTask tinkerPatchBuildTask = project.tasks.create("tinkerPatch${variantName}", TinkerPatchSchemaTask)
-                tinkerPatchBuildTask.dependsOn variant.assemble
 
                 tinkerPatchBuildTask.signConfig = variant.apkVariantData.variantConfiguration.signingConfig
 
                 variant.outputs.each { output ->
-                    tinkerPatchBuildTask.buildApkPath = output.outputFile
-                    File parentFile = output.outputFile
-                    tinkerPatchBuildTask.outputFolder = "${parentFile.getParentFile().getParentFile().getAbsolutePath()}/" + TypedValue.PATH_DEFAULT_OUTPUT + "/" + variant.dirName
+                    setPatchNewApkPath(configuration, output, variant, tinkerPatchBuildTask)
+                    setPatchOutputFolder(configuration, output, variant, tinkerPatchBuildTask)
                 }
 
                 // Create a task to add a build TINKER_ID to AndroidManifest.xml
@@ -194,6 +193,49 @@ class TinkerPatchPlugin implements Plugin<Project> {
         }
     }
 
+    /**
+     * Specify the output folder of tinker patch result.
+     *
+     * @param configuration the tinker configuration 'tinkerPatch'
+     * @param output the output of assemble result
+     * @param variant the variant
+     * @param tinkerPatchBuildTask the task that tinker patch uses
+     */
+    void setPatchOutputFolder(configuration, output, variant, tinkerPatchBuildTask) {
+        File parentFile = output.outputFile
+        String outputFolder = "${configuration.outputFolder}";
+        if (!Utils.isNullOrNil(outputFolder)) {
+            outputFolder = "${outputFolder}/${TypedValue.PATH_DEFAULT_OUTPUT}/${variant.dirName}"
+        } else {
+            outputFolder =
+                    "${parentFile.getParentFile().getParentFile().getAbsolutePath()}/${TypedValue.PATH_DEFAULT_OUTPUT}/${variant.dirName}"
+        }
+        tinkerPatchBuildTask.outputFolder = outputFolder
+    }
+
+    /**
+     * Specify the new apk path. If the new apk file is specified by {@code tinkerPatch.buildConfig.newApk},
+     * just use it as the new apk input for tinker patch, otherwise use the assemble output.
+     *
+     * @param project the project which applies this plugin
+     * @param configuration the tinker configuration 'tinkerPatch'
+     * @param output the output of assemble result
+     * @param variant the variant
+     * @param tinkerPatchBuildTask the task that tinker patch uses
+     */
+    void setPatchNewApkPath(configuration, output, variant, tinkerPatchBuildTask) {
+        def newApkPath = configuration.newApk;
+        if (!Utils.isNullOrNil(newApkPath)) {
+            if (FileOperation.isLegalFile(newApkPath)) {
+                tinkerPatchBuildTask.buildApkPath = newApkPath
+                return
+            }
+        }
+
+        tinkerPatchBuildTask.buildApkPath = output.outputFile
+        tinkerPatchBuildTask.dependsOn variant.assemble
+    }
+
     Task getMultiDexTask(Project project, String variantName) {
         String multiDexTaskName = "transformClassesWithMultidexlistFor${variantName}"
         return project.tasks.findByName(multiDexTaskName)
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerBuildConfigExtension.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerBuildConfigExtension.groovy
index 7d109793..490eb48e 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerBuildConfigExtension.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerBuildConfigExtension.groovy
@@ -45,6 +45,15 @@ public class TinkerBuildConfigExtension {
      */
     String tinkerId
 
+    /**
+     * Whether tinker should treat the base apk as the one being protected by app
+     * protection tools.
+     * If this attribute is true, the generated patch package will contain a
+     * dex including all changed classes instead of any dexdiff patch-info files.
+     * default: false
+     */
+    boolean isProtectedApp
+
     private Project project
 
     boolean usingResourceMapping
@@ -62,6 +71,7 @@ public class TinkerBuildConfigExtension {
         tinkerId = null
         usingResourceMapping = false
         keepDexApply = false
+        isProtectedApp = false
     }
 
     void checkParameter() {
@@ -75,6 +85,7 @@ public class TinkerBuildConfigExtension {
     public String toString() {
         """| applyMapping = ${applyMapping}
            | applyResourceMapping = ${applyResourceMapping}
+           | isProtectedApp = ${isProtectedApp}
            | keepDexApply = ${keepDexApply}
            | tinkerId = ${tinkerId}
         """.stripMargin()
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerDexExtension.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerDexExtension.groovy
index f600b499..e2429f03 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerDexExtension.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerDexExtension.groovy
@@ -44,6 +44,7 @@ public class TinkerDexExtension {
      */
     Iterable<String> loader;
 
+    Iterable<String> ignoreWarningLoader;
 
     private Project project;
 
@@ -51,6 +52,7 @@ public class TinkerDexExtension {
         dexMode = "jar"
         pattern = []
         loader = []
+        ignoreWarningLoader = []
         this.project = project
     }
 
@@ -65,6 +67,7 @@ public class TinkerDexExtension {
         """| dexMode = ${dexMode}
            | pattern = ${pattern}
            | loader = ${loader}
+           | ignoreWarningLoader = ${ignoreWarningLoader}
         """.stripMargin()
     }
 }
\ No newline at end of file
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerPatchExtension.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerPatchExtension.groovy
index c3b86141..3b99a728 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerPatchExtension.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerPatchExtension.groovy
@@ -30,6 +30,16 @@ public class TinkerPatchExtension {
      */
     String oldApk
 
+    /**
+     * Specify a folder for the outputs where place the tinker patch results.
+     */
+    String outputFolder
+
+    /**
+     * Specify the new apk path instead of running assemble task again.
+     */
+    String newApk;
+
     /**
      * If there is loader class changes,
      * or Activity, Service, Receiver, Provider change, it will terminal
@@ -52,6 +62,8 @@ public class TinkerPatchExtension {
 
     public TinkerPatchExtension() {
         oldApk = ""
+        outputFolder = ""
+        newApk = ""
         ignoreWarning = false
         useSign = true
         tinkerEnable = true
@@ -73,6 +85,8 @@ public class TinkerPatchExtension {
     @Override
     public String toString() {
         """| oldApk = ${oldApk}
+           | outputFolder = ${outputFolder}
+           | newApk = ${newApk}
            | ignoreWarning = ${ignoreWarning}
            | tinkerEnable = ${tinkerEnable}
            | useSign = ${useSign}
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerMultidexConfigTask.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerMultidexConfigTask.groovy
index 0476e862..2b148947 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerMultidexConfigTask.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerMultidexConfigTask.groovy
@@ -29,15 +29,17 @@ public class TinkerMultidexConfigTask extends DefaultTask {
     static final String MULTIDEX_CONFIG_PATH = TinkerPatchPlugin.TINKER_INTERMEDIATES + "tinker_multidexkeep.pro"
     static final String MULTIDEX_CONFIG_SETTINGS =
             "-keep public class * implements com.tencent.tinker.loader.app.ApplicationLifeCycle {\n" +
-                    "    *;\n" +
+                    "    <init>(...);\n" +
+                    "    void onBaseContextAttached(android.content.Context);\n" +
                     "}\n" +
                     "\n" +
                     "-keep public class * extends com.tencent.tinker.loader.TinkerLoader {\n" +
-                    "    *;\n" +
+                    "    <init>(...);\n" +
                     "}\n" +
                     "\n" +
                     "-keep public class * extends android.app.Application {\n" +
-                    "    *;\n" +
+                    "     <init>();\n" +
+                    "     void attachBaseContext(android.content.Context);\n" +
                     "}\n"
 
 
@@ -60,7 +62,15 @@ public class TinkerMultidexConfigTask extends DefaultTask {
              .append("#tinker multidex keep patterns:\n")
              .append(MULTIDEX_CONFIG_SETTINGS)
              .append("\n")
-             .append("#your dex.loader patterns here\n")
+
+        // This class must be placed in main dex so that we can use it to check if new pathList
+        // in AndroidNClassLoader is fine when under the protected app (whose main dex is always encrypted).
+        lines.append("-keep class com.tencent.tinker.loader.TinkerTestAndroidNClassLoader {\n" +
+                "    <init>(...);\n" +
+                "}\n")
+             .append("\n")
+
+        lines.append("#your dex.loader patterns here\n")
 
         Iterable<String> loader = project.extensions.tinkerPatch.dex.loader
         for (String pattern : loader) {
@@ -70,11 +80,13 @@ public class TinkerMultidexConfigTask extends DefaultTask {
                 }
             }
             lines.append("-keep class " + pattern + " {\n" +
-                    "    *;\n" +
+                    "    <init>(...);\n" +
                     "}\n")
                     .append("\n")
         }
 
+
+
         // Write our recommended proguard settings to this file
         FileWriter fr = new FileWriter(file.path)
         try {
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerPatchSchemaTask.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerPatchSchemaTask.groovy
index 87d674ad..f1ef7453 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerPatchSchemaTask.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerPatchSchemaTask.groovy
@@ -67,7 +67,9 @@ public class TinkerPatchSchemaTask extends DefaultTask {
                .setOutBuilder(outputFolder)
                .setIgnoreWarning(configuration.ignoreWarning)
                .setDexFilePattern(new ArrayList<String>(configuration.dex.pattern))
+               .setIsProtectedApp(configuration.buildConfig.isProtectedApp)
                .setDexLoaderPattern(new ArrayList<String>(configuration.dex.loader))
+               .setDexIgnoreWarningLoaderPattern(new ArrayList<String>(configuration.dex.ignoreWarningLoader))
                .setDexMode(configuration.dex.dexMode)
                .setSoFilePattern(new ArrayList<String>(configuration.lib.pattern))
                .setResourceFilePattern(new ArrayList<String>(configuration.res.pattern))
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerProguardConfigTask.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerProguardConfigTask.groovy
index e98a0935..23230b52 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerProguardConfigTask.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerProguardConfigTask.groovy
@@ -52,6 +52,9 @@ public class TinkerProguardConfigTask extends DefaultTask {
                     "-keep public class com.tencent.tinker.loader.TinkerTestDexLoad {\n" +
                     "    *;\n" +
                     "}\n" +
+                    "-keep public class com.tencent.tinker.loader.TinkerTestAndroidNClassLoader {\n" +
+                    "    *;\n" +
+                    "}\n" +
                     "\n"
 
 
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/transform/ImmutableDexTransform.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/transform/ImmutableDexTransform.groovy
index 92a80fcf..f0611a2f 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/transform/ImmutableDexTransform.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/transform/ImmutableDexTransform.groovy
@@ -36,13 +36,14 @@ import com.tencent.tinker.build.immutable.ClassSimDef
 import com.tencent.tinker.build.immutable.DexRefData
 import com.tencent.tinker.build.util.FileOperation
 import com.tencent.tinker.build.util.Utils
+import org.gradle.api.Action
 import org.gradle.api.GradleException
 import org.gradle.api.Project
 import org.gradle.api.Task
 import org.gradle.api.execution.TaskExecutionGraph
 import org.gradle.api.execution.TaskExecutionGraphListener
 import org.gradle.api.logging.Logging
-
+import org.gradle.api.tasks.JavaExec
 
 import java.lang.reflect.Field;
 import java.util.zip.ZipEntry
@@ -332,21 +333,29 @@ public class ImmutableDexTransform extends Transform {
 
 
     private void doDex(String classIndexName, File classZip, def dexOptions) {
-        ArrayList<String> execArgs = new ArrayList()
-        def dex = "${project.android.getSdkDirectory()}/build-tools/${project.android.buildToolsVersion}/dx"
-        execArgs.add(dex.toString())
-        execArgs.add("--dex")
-        if (dexOptions.getJumboMode()) {
-            execArgs.add("--force-jumbo");
-        }
-        if (dexOptions.getIncremental()) {
-            execArgs.add("--incremental");
-            execArgs.add("--no-strict");
-        }
-        execArgs.add("--output=${dxOutDir.absolutePath}/${classIndexName}.dex".toString())
-        execArgs.add(classZip.absolutePath)
-        project.logger.info(execArgs.toString())
-        Utils.exec(execArgs, null)
+
+        def dexJar = "${project.android.getSdkDirectory()}/build-tools/${project.android.buildToolsVersion}/lib/dx.jar"
+        def task = project.tasks.create("dx" + classIndexName + varName, JavaExec.class, new Action<JavaExec>() {
+            @Override
+            void execute(JavaExec javaExec) {
+                ArrayList<String> execArgs = new ArrayList()
+                execArgs.add("--dex")
+                if (dexOptions.getJumboMode()) {
+                    execArgs.add("--force-jumbo");
+                }
+                if (dexOptions.getIncremental()) {
+                    execArgs.add("--incremental");
+                    execArgs.add("--no-strict");
+                }
+                execArgs.add("--output=${dxOutDir.absolutePath}/${classIndexName}.dex".toString())
+                execArgs.add(classZip.absolutePath)
+                project.logger.info(execArgs.toString())
+                javaExec.setClasspath(project.files(dexJar))
+                javaExec.setMain("com.android.dx.command.Main")
+                javaExec.setArgs(execArgs)
+            }
+        })
+        task.execute()
     }
 
     public static void inject(Project project, def variant) {
diff --git a/tinker-build/tinker-patch-lib/build.gradle b/tinker-build/tinker-patch-lib/build.gradle
index 669e3811..b8dcfc72 100644
--- a/tinker-build/tinker-patch-lib/build.gradle
+++ b/tinker-build/tinker-patch-lib/build.gradle
@@ -9,9 +9,10 @@ group rootProject.ext.GROUP
 dependencies {
     compile fileTree(dir: 'libs', include: ['*.jar'])
     compile project(':tinker-commons')
-    compile group: 'com.tencent.mm', name: 'apk-parser-lib', version: '1.0.0'
+    compile group: 'com.tencent.mm', name: 'apk-parser-lib', version: '1.2.1'
     compile group: 'com.google.guava', name: 'guava', version: '11.0.2'
     compile group: 'org.ow2.asm', name: 'asm', version: '5.0.3'
+    compile group: 'org.smali', name: 'dexlib2', version: '2.1.3'
 }
 
 sourceSets {
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptUtil.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptUtil.java
index 29de1521..6dcc2646 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptUtil.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptUtil.java
@@ -304,7 +304,7 @@ private static void addToResourceCollector(AaptResourceCollector resourceCollect
                 resourceCollector.addResource(RType.STYLEABLE, IdType.INT, String.format("%s_%s", resourceName, attrName), Integer.toString(count++));
 
                 if (!rawAttrName.startsWith("android:")) {
-                    resourceCollector.addIntResourceIfNotPresent(RType.ATTR, attrName);
+                    resourceCollector.addIntResourceIfNotPresent(RType.ATTR, rawAttrName);
                     resourceCollector.addRTypeResourceName(RType.ATTR, rawAttrName, nodeToString(attrNode, true), resourceDirectory);
                 }
             }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/apkparser/AndroidParser.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/apkparser/AndroidParser.java
index b417847d..cea56771 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/apkparser/AndroidParser.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/apkparser/AndroidParser.java
@@ -18,13 +18,6 @@
 
 import com.tencent.tinker.build.patch.Configuration;
 
-import net.dongliu.apk.parser.ApkParser;
-import net.dongliu.apk.parser.bean.ApkMeta;
-import net.dongliu.apk.parser.exception.ParserException;
-import net.dongliu.apk.parser.struct.StringPool;
-import net.dongliu.apk.parser.struct.resource.ResourceTable;
-import net.dongliu.apk.parser.utils.ParseUtils;
-
 import org.w3c.dom.Document;
 import org.w3c.dom.NamedNodeMap;
 import org.w3c.dom.Node;
@@ -43,6 +36,13 @@
 import javax.xml.parsers.DocumentBuilder;
 import javax.xml.parsers.DocumentBuilderFactory;
 
+import tinker.net.dongliu.apk.parser.ApkParser;
+import tinker.net.dongliu.apk.parser.bean.ApkMeta;
+import tinker.net.dongliu.apk.parser.exception.ParserException;
+import tinker.net.dongliu.apk.parser.struct.StringPool;
+import tinker.net.dongliu.apk.parser.struct.resource.ResourceTable;
+import tinker.net.dongliu.apk.parser.utils.ParseUtils;
+
 /**
  * Created by zhangshaowen on 16/5/5.
  */
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/builder/PatchBuilder.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/builder/PatchBuilder.java
index 7b2e0d3e..8cfc6091 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/builder/PatchBuilder.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/builder/PatchBuilder.java
@@ -157,7 +157,7 @@ private void generateUnsignedApk(File output) throws IOException {
             throw new IOException(String.format(
                 "Missing patch unzip files, path=%s\n", tempOutDir.getAbsolutePath()));
         }
-        FileOperation.zipInputDir(tempOutDir, output);
+        FileOperation.zipInputDir(tempOutDir, output, null);
 
         if (!output.exists()) {
             throw new IOException(String.format(
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java
index 77d4e980..8c78db62 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java
@@ -21,10 +21,12 @@
 import com.tencent.tinker.android.dex.Dex;
 import com.tencent.tinker.android.dex.DexFormat;
 import com.tencent.tinker.build.dexpatcher.DexPatchGenerator;
+import com.tencent.tinker.build.dexpatcher.util.ChangedClassesDexClassInfoCollector;
 import com.tencent.tinker.build.info.InfoWriter;
 import com.tencent.tinker.build.patch.Configuration;
 import com.tencent.tinker.build.util.DexClassesComparator;
 import com.tencent.tinker.build.util.DexClassesComparator.DexClassInfo;
+import com.tencent.tinker.build.util.DexClassesComparator.DexGroup;
 import com.tencent.tinker.build.util.ExcludedClassModifiedChecker;
 import com.tencent.tinker.build.util.FileOperation;
 import com.tencent.tinker.build.util.Logger;
@@ -35,6 +37,17 @@
 import com.tencent.tinker.commons.dexpatcher.DexPatchApplier;
 import com.tencent.tinker.commons.dexpatcher.DexPatcherLogger.IDexPatcherLogger;
 
+import org.jf.dexlib2.builder.BuilderMutableMethodImplementation;
+import org.jf.dexlib2.dexbacked.DexBackedDexFile;
+import org.jf.dexlib2.iface.DexFile;
+import org.jf.dexlib2.iface.Field;
+import org.jf.dexlib2.iface.Method;
+import org.jf.dexlib2.iface.MethodImplementation;
+import org.jf.dexlib2.writer.builder.BuilderField;
+import org.jf.dexlib2.writer.builder.BuilderMethod;
+import org.jf.dexlib2.writer.builder.DexBuilder;
+import org.jf.dexlib2.writer.io.FileDataStore;
+
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
@@ -53,6 +66,7 @@
  */
 public class DexDiffDecoder extends BaseDecoder {
     private static final String TEST_DEX_NAME = "test.dex";
+    private static final String CHANGED_CLASSES_DEX_NAME = "changed_classes.dex";
 
     private final InfoWriter logWriter;
     private final InfoWriter metaWriter;
@@ -178,11 +192,125 @@ public void onAllPatchesEnd() throws Exception {
             return;
         }
 
-        generatePatchInfoFile();
+        if (config.mIsProtectedApp) {
+            generateChangedClassesDexFile();
+        } else {
+            generatePatchInfoFile();
+        }
 
         addTestDex();
     }
 
+    @SuppressWarnings("NewApi")
+    private void generateChangedClassesDexFile() throws IOException {
+        final String dexMode = config.mDexRaw ? "raw" : "jar";
+        final File dest = new File(config.mTempResultDir + "/" + CHANGED_CLASSES_DEX_NAME);
+
+        Logger.d("\nBuilding changed classes dex: %s, size: %d\n", dest.getAbsolutePath(), dest.length());
+
+        List<File> oldDexList = new ArrayList<>();
+        List<File> newDexList = new ArrayList<>();
+        for (AbstractMap.SimpleEntry<File, File> oldAndNewDexFilePair : oldAndNewDexFilePairList) {
+            File oldDexFile = oldAndNewDexFilePair.getKey();
+            File newDexFile = oldAndNewDexFilePair.getValue();
+            if (oldDexFile != null) {
+                oldDexList.add(oldDexFile);
+            }
+            if (newDexFile != null) {
+                newDexList.add(newDexFile);
+            }
+        }
+
+        DexGroup oldDexGroup = DexGroup.wrap(oldDexList);
+        DexGroup newDexGroup = DexGroup.wrap(newDexList);
+
+        ChangedClassesDexClassInfoCollector collector = new ChangedClassesDexClassInfoCollector();
+        collector.setExcludedClassPatterns(config.mDexLoaderPattern);
+        collector.setLogger(dexPatcherLoggerBridge);
+        collector.setIncludeRefererToRefererAffectedClasses(true);
+
+        Set<DexClassInfo> classInfosInChangedClassesDex = collector.doCollect(oldDexGroup, newDexGroup);
+
+        Set<Dex> owners = new HashSet<>();
+        Map<Dex, Set<String>> ownerToDescOfChangedClassesMap = new HashMap<>();
+        for (DexClassInfo classInfo : classInfosInChangedClassesDex) {
+            owners.add(classInfo.owner);
+            Set<String> descOfChangedClasses = ownerToDescOfChangedClassesMap.get(classInfo.owner);
+            if (descOfChangedClasses == null) {
+                descOfChangedClasses = new HashSet<>();
+                ownerToDescOfChangedClassesMap.put(classInfo.owner, descOfChangedClasses);
+            }
+            descOfChangedClasses.add(classInfo.classDesc);
+        }
+
+        DexBuilder dexBuilder = DexBuilder.makeDexBuilder();
+        for (Dex dex : owners) {
+            Set<String> descOfChangedClassesInCurrDex = ownerToDescOfChangedClassesMap.get(dex);
+            DexFile dexFile = new DexBackedDexFile(org.jf.dexlib2.Opcodes.forApi(20), dex.getBytes());
+            for (org.jf.dexlib2.iface.ClassDef classDef : dexFile.getClasses()) {
+                if (!descOfChangedClassesInCurrDex.contains(classDef.getType())) {
+                    continue;
+                }
+
+                Logger.d("Class %s will be added into changed classes dex ...", classDef.getType());
+
+                List<BuilderField> builderFields = new ArrayList<>();
+                for (Field field : classDef.getFields()) {
+                    final BuilderField builderField = dexBuilder.internField(
+                            field.getDefiningClass(),
+                            field.getName(),
+                            field.getType(),
+                            field.getAccessFlags(),
+                            field.getInitialValue(),
+                            field.getAnnotations()
+                    );
+                    builderFields.add(builderField);
+                }
+                List<BuilderMethod> builderMethods = new ArrayList<>();
+
+                for (Method method : classDef.getMethods()) {
+                    MethodImplementation methodImpl = method.getImplementation();
+                    if (methodImpl != null) {
+                        methodImpl = new BuilderMutableMethodImplementation(dexBuilder, methodImpl);
+                    }
+                    BuilderMethod builderMethod = dexBuilder.internMethod(
+                            method.getDefiningClass(),
+                            method.getName(),
+                            method.getParameters(),
+                            method.getReturnType(),
+                            method.getAccessFlags(),
+                            method.getAnnotations(),
+                            methodImpl
+                    );
+                    builderMethods.add(builderMethod);
+                }
+                dexBuilder.internClassDef(
+                        classDef.getType(),
+                        classDef.getAccessFlags(),
+                        classDef.getSuperclass(),
+                        classDef.getInterfaces(),
+                        classDef.getSourceFile(),
+                        classDef.getAnnotations(),
+                        builderFields,
+                        builderMethods
+                );
+            }
+        }
+
+        // Write constructed changed classes dex to file and record it in meta file.
+        FileDataStore fileDataStore = new FileDataStore(dest);
+        dexBuilder.writeTo(fileDataStore);
+
+        final String md5 = MD5.getMD5(dest);
+
+        String meta = CHANGED_CLASSES_DEX_NAME + "," + "" + "," + md5 + "," + md5 + "," + 0
+                + "," + 0 + "," + 0 + "," + dexMode;
+
+        Logger.d("\nDexDecoder:write changed classes dex meta file data: %s", meta);
+
+        metaWriter.writeLineToInfoFile(meta);
+    }
+
     @SuppressWarnings("NewApi")
     private void generatePatchInfoFile() throws IOException {
         generatePatchedDexInfoFile();
@@ -234,16 +362,11 @@ private void logDexesToDexMeta() throws IOException {
             final String dexName = getRelativeDexName(oldDexFile, newDexFile);
             final RelatedInfo relatedInfo = dexNameToRelatedInfoMap.get(dexName);
             if (!relatedInfo.oldMd5.equals(relatedInfo.newMd5)) {
-                //logToDexMeta(newDexFile, oldDexFile, relatedInfo.dexDiffFile, relatedInfo.newOrFullPatchedMd5, relatedInfo.smallPatchedMd5, relatedInfo.dexDiffMd5);
                 logToDexMeta(newDexFile, oldDexFile, relatedInfo.dexDiffFile, relatedInfo.newOrFullPatchedMd5, relatedInfo.newOrFullPatchedMd5, relatedInfo.dexDiffMd5);
             } else {
                 // For class N dexes, if new dex is the same as old dex, we should log it as 'copy directly'
                 // in dex meta to fix problems in Art environment.
                 if (realClassNDexFiles.contains(oldDexFile)) {
-                    //if (!"0".equals(relatedInfo.smallPatchedMd5)) {
-                    //    logToDexMeta(newDexFile, oldDexFile, null, "0", relatedInfo.smallPatchedMd5, "0");
-                    //}
-
                     // Bugfix: However, if what we would copy directly is main dex, we should do an additional diff operation
                     // so that patch applier would help us remove all loader classes of it in runtime.
                     if (dexName.equals(DexFormat.DEX_IN_JAR_NAME)) {
@@ -352,7 +475,7 @@ private void addTestDex() throws IOException {
         String md5 = MD5.getMD5(is, 1024);
         is.close();
 
-        String meta = TEST_DEX_NAME + "," + "" + "," + md5 + "," + md5 + "," + 0 + "," + 0 + "," + dexMode;
+        String meta = TEST_DEX_NAME + "," + "" + "," + md5 + "," + md5 + "," + 0 + "," + 0 + "," + 0 + "," + dexMode;
 
         File dest = new File(config.mTempResultDir + "/" + TEST_DEX_NAME);
         FileOperation.copyResourceUsingStream(TEST_DEX_NAME, dest);
@@ -542,7 +665,9 @@ protected void logToDexMeta(File newOrFullPatchedFile, File oldFile, File dexDif
                 }
             }
 
-            String meta = fileName + "," + parentRelative + "," + destMd5InDvm + "," + destMd5InArt + "," + dexDiffMd5 + "," + oldCrc + "," + dexMode;
+            String newCrc = FileOperation.getZipEntryCrc(config.mNewApkFile, relative);
+            String meta = fileName + "," + parentRelative + "," + destMd5InDvm + ","
+                + destMd5InArt + "," + dexDiffMd5 + "," + oldCrc + "," + newCrc + "," + dexMode;
 
             Logger.d("DexDecoder:write meta file data: %s", meta);
             metaWriter.writeLineToInfoFile(meta);
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ResDiffDecoder.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ResDiffDecoder.java
index d5c82b75..5abce200 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ResDiffDecoder.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ResDiffDecoder.java
@@ -279,7 +279,7 @@ public void onAllPatchesEnd() throws IOException, TinkerPatchException {
         final File tempResFiles = config.mTempResultDir;
 
         //gen zip resources_out.zip
-        FileOperation.zipInputDir(tempResFiles, tempResZip);
+        FileOperation.zipInputDir(tempResFiles, tempResZip, null);
         File extractToZip = new File(config.mOutFolder + File.separator + TypedValue.RES_OUT);
 
         String resZipMd5 = Utils.genResOutputFile(extractToZip, tempResZip, config,
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/ChangedClassesDexClassInfoCollector.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/ChangedClassesDexClassInfoCollector.java
new file mode 100644
index 00000000..6fb11914
--- /dev/null
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/ChangedClassesDexClassInfoCollector.java
@@ -0,0 +1,252 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.build.dexpatcher.util;
+
+import com.tencent.tinker.android.dex.ClassData;
+import com.tencent.tinker.android.dex.ClassDef;
+import com.tencent.tinker.android.dex.Code;
+import com.tencent.tinker.android.dex.Dex;
+import com.tencent.tinker.android.dex.FieldId;
+import com.tencent.tinker.android.dex.MethodId;
+import com.tencent.tinker.android.dex.ProtoId;
+import com.tencent.tinker.android.dx.instruction.InstructionCodec;
+import com.tencent.tinker.android.dx.instruction.InstructionReader;
+import com.tencent.tinker.android.dx.instruction.InstructionVisitor;
+import com.tencent.tinker.android.dx.instruction.ShortArrayCodeInput;
+import com.tencent.tinker.build.util.DexClassesComparator;
+import com.tencent.tinker.commons.dexpatcher.DexPatcherLogger;
+
+import java.io.EOFException;
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.Set;
+
+import static com.tencent.tinker.build.util.DexClassesComparator.DexClassInfo;
+import static com.tencent.tinker.build.util.DexClassesComparator.DexGroup;
+
+/**
+ * Created by tangyinsheng on 2017/2/26.
+ */
+
+public class ChangedClassesDexClassInfoCollector {
+    private static final String TAG = "ChangedClassesDexClassInfoCollector";
+
+    private static final DexPatcherLogger logger = new DexPatcherLogger();
+    private final Set<String> excludedClassPatterns = new HashSet<>();
+    private boolean includeRefererToRefererAffectedClasses = false;
+
+    public ChangedClassesDexClassInfoCollector setExcludedClassPatterns(Collection<String> loaderClassPatterns) {
+        this.excludedClassPatterns.clear();
+        this.excludedClassPatterns.addAll(loaderClassPatterns);
+        return this;
+    }
+
+    public ChangedClassesDexClassInfoCollector clearExcludedClassPatterns() {
+        this.excludedClassPatterns.clear();
+        return this;
+    }
+
+    public ChangedClassesDexClassInfoCollector setLogger(DexPatcherLogger.IDexPatcherLogger loggerImpl) {
+        logger.setLoggerImpl(loggerImpl);
+        return this;
+    }
+
+    public ChangedClassesDexClassInfoCollector setIncludeRefererToRefererAffectedClasses(boolean enabled) {
+        this.includeRefererToRefererAffectedClasses = enabled;
+        return this;
+    }
+
+    public Set<DexClassInfo> doCollect(DexGroup oldDexGroup, DexGroup newDexGroup) {
+        final Set<String> classDescsInResult = new HashSet<>();
+        final Set<DexClassInfo> result = new HashSet<>();
+
+        DexClassesComparator dexClassCmptor = new DexClassesComparator("*");
+        dexClassCmptor.setCompareMode(DexClassesComparator.COMPARE_MODE_NORMAL);
+        dexClassCmptor.setIgnoredRemovedClassDescPattern(excludedClassPatterns);
+        dexClassCmptor.setLogger(logger.getLoggerImpl());
+        dexClassCmptor.startCheck(oldDexGroup, newDexGroup);
+
+        // So far we collected infos of all added, changed, and deleted classes.
+        result.addAll(dexClassCmptor.getAddedClassInfos());
+
+        final Collection<DexClassInfo[]> changedClassInfos = dexClassCmptor.getChangedClassDescToInfosMap().values();
+
+        for (DexClassInfo[] oldAndNewInfoPair : changedClassInfos) {
+            final DexClassInfo newClassInfo = oldAndNewInfoPair[1];
+
+            logger.i(TAG, "Add class %s to changed classes dex.", newClassInfo.classDesc);
+            result.add(newClassInfo);
+        }
+
+        for (DexClassInfo classInfo : result) {
+            classDescsInResult.add(classInfo.classDesc);
+        }
+
+        if (includeRefererToRefererAffectedClasses) {
+            // Then we also need to add classes who refer to classes with referrer
+            // affected changes to the result. (referrer affected change means the changes
+            // that may cause referrer refer to wrong target.)
+            dexClassCmptor.setCompareMode(DexClassesComparator.COMPARE_MODE_REFERRER_AFFECTED_CHANGE_ONLY);
+            dexClassCmptor.startCheck(oldDexGroup, newDexGroup);
+
+            Set<String> referrerAffectedChangedClassDescs = dexClassCmptor.getChangedClassDescToInfosMap().keySet();
+            Set<DexClassInfo> oldClassInfos = oldDexGroup.getClassInfosInDexesWithDuplicateCheck();
+
+            for (DexClassInfo oldClassInfo : oldClassInfos) {
+                if (!classDescsInResult.contains(oldClassInfo.classDesc)
+                        && isClassReferToAnyClasses(oldClassInfo, referrerAffectedChangedClassDescs)) {
+                    logger.i(TAG, "Add class %s in old dex to changed classes dex since it is affected by modified referee.", oldClassInfo.classDesc);
+                    result.add(oldClassInfo);
+                }
+            }
+        }
+
+        return result;
+    }
+
+    private boolean isClassReferToAnyClasses(DexClassInfo classInfo, Set<String> refereeClassDescs) {
+        if (classInfo.classDef.classDataOffset == ClassDef.NO_OFFSET) {
+            return false;
+        }
+        ClassData classData = classInfo.owner.readClassData(classInfo.classDef);
+        for (ClassData.Method method : classData.directMethods) {
+            if (isMethodReferToAnyClasses(classInfo, method, refereeClassDescs)) {
+                return true;
+            }
+        }
+        for (ClassData.Method method : classData.virtualMethods) {
+            if (isMethodReferToAnyClasses(classInfo, method, refereeClassDescs)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private boolean isMethodReferToAnyClasses(DexClassInfo classInfo, ClassData.Method method, Set<String> refereeClassDescs) {
+        if (method.codeOffset == ClassDef.NO_OFFSET) {
+            return false;
+        }
+        Code methodCode = classInfo.owner.readCode(method);
+        InstructionReader ir = new InstructionReader(new ShortArrayCodeInput(methodCode.instructions));
+        ReferToClassesCheckVisitor rtcv = new ReferToClassesCheckVisitor(classInfo.owner, method, refereeClassDescs);
+        try {
+            ir.accept(rtcv);
+        } catch (EOFException e) {
+            // Should not be here.
+        }
+        return rtcv.isReferToAnyRefereeClasses;
+    }
+
+    private static class ReferToClassesCheckVisitor extends InstructionVisitor {
+        private final Dex owner;
+        private final ClassData.Method method;
+        private final Collection<String> refereeClassDescs;
+
+        private boolean isReferToAnyRefereeClasses = false;
+
+        ReferToClassesCheckVisitor(Dex owner, ClassData.Method method, Collection<String> refereeClassDescs) {
+            super(null);
+            this.owner = owner;
+            this.method = method;
+            this.refereeClassDescs = refereeClassDescs;
+        }
+
+        @Override
+        public void visitZeroRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal) {
+            processIndexByType(index, indexType);
+        }
+
+        @Override
+        public void visitOneRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a) {
+            processIndexByType(index, indexType);
+        }
+
+        @Override
+        public void visitTwoRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int b) {
+            processIndexByType(index, indexType);
+        }
+
+        @Override
+        public void visitThreeRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int b, int c) {
+            processIndexByType(index, indexType);
+        }
+
+        @Override
+        public void visitFourRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int b, int c, int d) {
+            processIndexByType(index, indexType);
+        }
+
+        @Override
+        public void visitFiveRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int b, int c, int d, int e) {
+            processIndexByType(index, indexType);
+        }
+
+        @Override
+        public void visitRegisterRangeInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int registerCount) {
+            processIndexByType(index, indexType);
+        }
+
+        private void processIndexByType(int index, int indexType) {
+            String typeName = null;
+            String refInfoInLog = null;
+            switch (indexType) {
+                case InstructionCodec.INDEX_TYPE_TYPE_REF: {
+                    typeName = owner.typeNames().get(index);
+                    refInfoInLog = "init referrer-affected class";
+                    break;
+                }
+                case InstructionCodec.INDEX_TYPE_FIELD_REF: {
+                    final FieldId fieldId = owner.fieldIds().get(index);
+                    typeName = owner.typeNames().get(fieldId.declaringClassIndex);
+                    refInfoInLog = "referencing to field: " + owner.strings().get(fieldId.nameIndex);
+                    break;
+                }
+                case InstructionCodec.INDEX_TYPE_METHOD_REF: {
+                    final MethodId methodId = owner.methodIds().get(index);
+                    typeName = owner.typeNames().get(methodId.declaringClassIndex);
+                    refInfoInLog = "invoking method: " + getMethodProtoTypeStr(methodId);
+                    break;
+                }
+            }
+            if (typeName != null && refereeClassDescs.contains(typeName)) {
+                MethodId methodId = owner.methodIds().get(method.methodIndex);
+                logger.i(
+                        TAG,
+                        "Method %s in class %s referenced referrer-affected class %s by %s",
+                        getMethodProtoTypeStr(methodId),
+                        owner.typeNames().get(methodId.declaringClassIndex),
+                        typeName,
+                        refInfoInLog
+                );
+                isReferToAnyRefereeClasses = true;
+            }
+        }
+
+        private String getMethodProtoTypeStr(MethodId methodId) {
+            StringBuilder strBuilder = new StringBuilder();
+            strBuilder.append(owner.strings().get(methodId.nameIndex));
+            ProtoId protoId = owner.protoIds().get(methodId.protoIndex);
+            strBuilder.append('(');
+            short[] paramTypeIds = owner.parameterTypeIndicesFromMethodId(methodId);
+            for (short typeId : paramTypeIds) {
+                strBuilder.append(owner.typeNames().get(typeId));
+            }
+            strBuilder.append(')').append(owner.typeNames().get(protoId.returnTypeIndex));
+            return strBuilder.toString();
+        }
+    }
+}
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/Configuration.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/Configuration.java
index e61122ff..ef88dfc2 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/Configuration.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/Configuration.java
@@ -59,13 +59,14 @@
     protected static final String ATTR_VALUE = "value";
     protected static final String ATTR_NAME  = "name";
 
-    protected static final String ATTR_IGNORE_WARNING    = "ignoreWarning";
-    protected static final String ATTR_USE_SIGN          = "useSign";
-    protected static final String ATTR_SEVEN_ZIP_PATH    = "sevenZipPath";
-    protected static final String ATTR_DEX_MODE          = "dexMode";
-    protected static final String ATTR_PATTERN           = "pattern";
-    protected static final String ATTR_RES_IGNORE_CHANGE = "ignoreChange";
-    protected static final String ATTR_RES_LARGE_MOD     = "largeModSize";
+    protected static final String ATTR_IGNORE_WARNING   = "ignoreWarning";
+    protected static final String ATTR_IS_PROTECTED_APP = "isProtectedApp";
+    protected static final String ATTR_USE_SIGN         = "useSign";
+    protected static final String ATTR_SEVEN_ZIP_PATH   = "sevenZipPath";
+    protected static final String ATTR_DEX_MODE         = "dexMode";
+    protected static final String ATTR_PATTERN          = "pattern";
+    protected static final String ATTR_IGNORE_CHANGE    = "ignoreChange";
+    protected static final String ATTR_RES_LARGE_MOD    = "largeModSize";
 
     protected static final String ATTR_LOADER       = "loader";
     protected static final String ATTR_CONFIG_FIELD = "configField";
@@ -77,12 +78,13 @@
     /**
      * base config data
      */
-    public String           mOldApkPath;
-    public String           mNewApkPath;
-    public String           mOutFolder;
-    public File             mOldApkFile;
-    public File             mNewApkFile;
-    public boolean          mIgnoreWarning;
+    public String  mOldApkPath;
+    public String  mNewApkPath;
+    public String  mOutFolder;
+    public File    mOldApkFile;
+    public File    mNewApkFile;
+    public boolean mIgnoreWarning;
+    public boolean mIsProtectedApp;
 
     /**
      * lib config
@@ -93,6 +95,8 @@
      */
     public HashSet<Pattern> mDexFilePattern;
     public HashSet<String>  mDexLoaderPattern;
+    public HashSet<String>  mDexIgnoreWarningLoaderPattern;
+
     public boolean          mDexRaw;
     /**
      * resource config
@@ -142,6 +146,7 @@ public Configuration(File config, File outputFile, File oldApkFile, File newApkF
         mSoFilePattern = new HashSet<>();
         mDexFilePattern = new HashSet<>();
         mDexLoaderPattern = new HashSet<>();
+        mDexIgnoreWarningLoaderPattern = new HashSet<>();
 
         mResFilePattern = new HashSet<>();
         mResRawPattern = new HashSet<>();
@@ -171,6 +176,7 @@ public Configuration(InputParam param) throws IOException, TinkerPatchException
         mSoFilePattern = new HashSet<>();
         mDexFilePattern = new HashSet<>();
         mDexLoaderPattern = new HashSet<>();
+        mDexIgnoreWarningLoaderPattern = new HashSet<>();
 
         mResFilePattern = new HashSet<>();
         mResRawPattern = new HashSet<>();
@@ -199,7 +205,7 @@ public Configuration(InputParam param) throws IOException, TinkerPatchException
         mUseApplyResource = param.useApplyResource;
 
         mDexLoaderPattern.addAll(param.dexLoaderPattern);
-
+        mDexIgnoreWarningLoaderPattern.addAll(param.dexIgnoreWarningLoaderPattern);
         //can be only raw or jar
         if (param.dexMode.equals("raw")) {
             mDexRaw = true;
@@ -215,6 +221,8 @@ public Configuration(InputParam param) throws IOException, TinkerPatchException
 
         mIgnoreWarning = param.ignoreWarning;
 
+        mIsProtectedApp = param.isProtectedApp;
+
         mSevenZipPath = param.sevenZipPath;
         mPackageFields = param.configFields;
 
@@ -236,6 +244,7 @@ public String toString() {
         sb.append("newApk:" + mNewApkPath + "\n");
         sb.append("outputFolder:" + mOutFolder + "\n");
         sb.append("isIgnoreWarning:" + mIgnoreWarning + "\n");
+        sb.append("isProtectedApp:" + mIsProtectedApp + "\n");
         sb.append("7-ZipPath:" + mSevenZipPath + "\n");
         sb.append("useSignAPk:" + mUseSignAPk + "\n");
 
@@ -257,6 +266,9 @@ public String toString() {
         for (String name : mDexLoaderPattern) {
             sb.append("dex loader:" + name + "\n");
         }
+        for (String name : mDexIgnoreWarningLoaderPattern) {
+            sb.append("dex ignore warning loader:" + name.toString() + "\n");
+        }
 
         sb.append("lib configs: \n");
         for (Pattern name : mSoFilePattern) {
@@ -409,6 +421,8 @@ private void readPropertyFromXml(Node node) throws IOException {
                     }
                     if (tagName.equals(ATTR_IGNORE_WARNING)) {
                         mIgnoreWarning = value.equals("true");
+                    } else if (tagName.equals(ATTR_IS_PROTECTED_APP)) {
+                        mIsProtectedApp = value.equals("true");
                     } else if (tagName.equals(ATTR_USE_SIGN)) {
                         mUseSignAPk = value.equals("true");
                     } else if (tagName.equals(ATTR_SEVEN_ZIP_PATH)) {
@@ -489,6 +503,8 @@ private void readDexPatternsFromXml(Node node) throws IOException {
                         addToPatterns(value, mDexFilePattern);
                     } else if (tagName.equals(ATTR_LOADER)) {
                         mDexLoaderPattern.add(value);
+                    } else if (tagName.equals(ATTR_IGNORE_CHANGE)) {
+                        mDexIgnoreWarningLoaderPattern.add(value);
                     } else {
                         System.err.println("unknown dex tag " + tagName);
                     }
@@ -530,7 +546,7 @@ private void readResPatternsFromXml(Node node) throws IOException {
                     if (tagName.equals(ATTR_PATTERN)) {
                         mResRawPattern.add(value);
                         addToPatterns(value, mResFilePattern);
-                    } else if (tagName.equals(ATTR_RES_IGNORE_CHANGE)) {
+                    } else if (tagName.equals(ATTR_IGNORE_CHANGE)) {
                         addToPatterns(value, mResIgnoreChangePattern);
                     } else if (tagName.equals(ATTR_RES_LARGE_MOD)) {
                         mLargeModSize = Integer.valueOf(value);
@@ -575,5 +591,4 @@ private void addToPatterns(String value, HashSet<Pattern> patterns) throws IOExc
         patterns.add(pattern);
     }
 
-}
-
+}
\ No newline at end of file
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/InputParam.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/InputParam.java
index e56d4eac..6bc9e9e0 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/InputParam.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/InputParam.java
@@ -35,13 +35,16 @@
     public final String  storealias;
     public final String  storepass;
     public final boolean ignoreWarning;
+    public final boolean isProtectedApp;
     public final boolean useSign;
 
     /**
      * tinkerPatch.dex
      */
-    public final ArrayList<String>       dexFilePattern;
-    public final ArrayList<String>       dexLoaderPattern;
+    public final ArrayList<String> dexFilePattern;
+    public final ArrayList<String> dexLoaderPattern;
+    public final ArrayList<String> dexIgnoreWarningLoaderPattern;
+
     public final String                  dexMode;
     /**
      * tinkerPatch.lib
@@ -81,10 +84,13 @@ private InputParam(
         String storealias,
         String storepass,
         boolean ignoreWarning,
+        boolean isProtectedApp,
         boolean useSign,
 
         ArrayList<String> dexFilePattern,
         ArrayList<String> dexLoaderPattern,
+        ArrayList<String> dexIgnoreChangeLoaderPattern,
+
         String dexMode,
         ArrayList<String> soFilePattern,
         ArrayList<String> resourceFilePattern,
@@ -103,10 +109,12 @@ private InputParam(
         this.storealias = storealias;
         this.storepass = storepass;
         this.ignoreWarning = ignoreWarning;
+        this.isProtectedApp = isProtectedApp;
         this.useSign = useSign;
 
         this.dexFilePattern = dexFilePattern;
         this.dexLoaderPattern = dexLoaderPattern;
+        this.dexIgnoreWarningLoaderPattern = dexIgnoreChangeLoaderPattern;
         this.dexMode = dexMode;
 
         this.soFilePattern = soFilePattern;
@@ -132,13 +140,16 @@ private InputParam(
         private String  storealias;
         private String  storepass;
         private boolean ignoreWarning;
+        private boolean isProtectedApp;
         private boolean useSign;
 
         /**
          * tinkerPatch.dex
          */
-        private ArrayList<String>       dexFilePattern;
-        private ArrayList<String>       dexLoaderPattern;
+        private ArrayList<String> dexFilePattern;
+        private ArrayList<String> dexLoaderPattern;
+        private ArrayList<String> dexIgnoreWarningLoaderPattern;
+
         private String                  dexMode;
         /**
          * tinkerPatch.lib
@@ -243,11 +254,21 @@ public Builder setIgnoreWarning(boolean ignoreWarning) {
             return this;
         }
 
+        public Builder setIsProtectedApp(boolean isProtectedApp) {
+            this.isProtectedApp = isProtectedApp;
+            return this;
+        }
+
         public Builder setDexLoaderPattern(ArrayList<String> dexLoaderPattern) {
             this.dexLoaderPattern = dexLoaderPattern;
             return this;
         }
 
+        public Builder setDexIgnoreWarningLoaderPattern(ArrayList<String> loader) {
+            this.dexIgnoreWarningLoaderPattern = loader;
+            return this;
+        }
+
         public Builder setDexMode(String dexMode) {
             this.dexMode = dexMode;
             return this;
@@ -278,9 +299,11 @@ public InputParam create() {
                     storealias,
                     storepass,
                     ignoreWarning,
+                    isProtectedApp,
                     useSign,
                     dexFilePattern,
                     dexLoaderPattern,
+                    dexIgnoreWarningLoaderPattern,
                     dexMode,
                     soFilePattern,
                     resourceFilePattern,
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/DexClassesComparator.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/DexClassesComparator.java
index d0c99383..5c2eb055 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/DexClassesComparator.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/DexClassesComparator.java
@@ -57,12 +57,16 @@
  * Created by tangyinsheng on 2016/4/14.
  */
 public final class DexClassesComparator {
-    public static final int COMPARE_MODE_NORMAL = 0;
-    public static final int COMPARE_MODE_CAUSE_REF_CHANGE_ONLY = 1;
     private static final String TAG = "DexClassesComparator";
+
+    public static final int COMPARE_MODE_NORMAL = 0;
+    public static final int COMPARE_MODE_REFERRER_AFFECTED_CHANGE_ONLY = 1;
+
     private static final int DBG_FIRST_SPECIAL = 0x0A;  // the smallest special opcode
     private static final int DBG_LINE_BASE   = -4;      // the smallest line number increment
     private static final int DBG_LINE_RANGE  = 15;      // the number of line increments represented
+
+    private int compareMode = COMPARE_MODE_NORMAL;
     private final List<DexClassInfo> addedClassInfoList = new ArrayList<>();
     private final List<DexClassInfo> deletedClassInfoList = new ArrayList<>();
     // classDesc => [oldClassInfo, newClassInfo]
@@ -73,17 +77,17 @@
     private final Set<String> newDescriptorOfClassesToCheck = new HashSet<>();
     private final Map<String, DexClassInfo> oldClassDescriptorToClassInfoMap = new HashMap<>();
     private final Map<String, DexClassInfo> newClassDescriptorToClassInfoMap = new HashMap<>();
+
     // Record class descriptors whose references key (index or offset) of methods and fields
     // are changed.
     private final Set<String> refAffectedClassDescs = new HashSet<>();
     private final DexPatcherLogger logger = new DexPatcherLogger();
-    private int compareMode = COMPARE_MODE_NORMAL;
 
     public DexClassesComparator(String patternStringOfClassDescToCheck) {
         patternsOfClassDescToCheck.add(
-            Pattern.compile(
-                PatternUtils.dotClassNamePatternToDescriptorRegEx(patternStringOfClassDescToCheck)
-            )
+                Pattern.compile(
+                        PatternUtils.dotClassNamePatternToDescriptorRegEx(patternStringOfClassDescToCheck)
+                )
         );
     }
 
@@ -100,9 +104,9 @@ public DexClassesComparator(String... patternStringsOfClassDescToCheck) {
     public DexClassesComparator(Collection<String> patternStringsOfClassDescToCheck) {
         for (String patternStr : patternStringsOfClassDescToCheck) {
             patternsOfClassDescToCheck.add(
-                Pattern.compile(
-                    PatternUtils.dotClassNamePatternToDescriptorRegEx(patternStr)
-                )
+                    Pattern.compile(
+                            PatternUtils.dotClassNamePatternToDescriptorRegEx(patternStr)
+                    )
             );
         }
     }
@@ -122,15 +126,15 @@ public void setIgnoredRemovedClassDescPattern(Collection<String> patternStringsO
         patternsOfIgnoredRemovedClassDesc.clear();
         for (String patternStr : patternStringsOfLoaderClassDesc) {
             patternsOfIgnoredRemovedClassDesc.add(
-                Pattern.compile(
-                    PatternUtils.dotClassNamePatternToDescriptorRegEx(patternStr)
-                )
+                    Pattern.compile(
+                            PatternUtils.dotClassNamePatternToDescriptorRegEx(patternStr)
+                    )
             );
         }
     }
 
     public void setCompareMode(int mode) {
-        if (mode == COMPARE_MODE_NORMAL || mode == COMPARE_MODE_CAUSE_REF_CHANGE_ONLY) {
+        if (mode == COMPARE_MODE_NORMAL || mode == COMPARE_MODE_REFERRER_AFFECTED_CHANGE_ONLY) {
             this.compareMode = mode;
         } else {
             throw new IllegalArgumentException("bad compare mode: " + mode);
@@ -224,19 +228,22 @@ public void startCheck(DexGroup oldDexGroup, DexGroup newDexGroup) {
             // from result.
             if (Utils.isStringMatchesPatterns(desc, patternsOfIgnoredRemovedClassDesc)) {
                 logger.i(TAG, "Ignored deleted class: %s", desc);
-                continue;
             } else {
                 logger.i(TAG, "Deleted class: %s", desc);
+                deletedClassInfoList.add(oldClassDescriptorToClassInfoMap.get(desc));
             }
-            deletedClassInfoList.add(oldClassDescriptorToClassInfoMap.get(desc));
         }
 
         Set<String> addedClassDescs = new HashSet<>(newDescriptorOfClassesToCheck);
         addedClassDescs.removeAll(oldDescriptorOfClassesToCheck);
 
         for (String desc : addedClassDescs) {
-            logger.i(TAG, "Added class: %s", desc);
-            addedClassInfoList.add(newClassDescriptorToClassInfoMap.get(desc));
+            if (Utils.isStringMatchesPatterns(desc, patternsOfIgnoredRemovedClassDesc)) {
+                logger.i(TAG, "Ignored added class: %s", desc);
+            } else {
+                logger.i(TAG, "Added class: %s", desc);
+                addedClassInfoList.add(newClassDescriptorToClassInfoMap.get(desc));
+            }
         }
 
         Set<String> mayBeChangedClassDescs = new HashSet<>(oldDescriptorOfClassesToCheck);
@@ -253,24 +260,32 @@ public void startCheck(DexGroup oldDexGroup, DexGroup newDexGroup) {
                             oldClassInfo.classDef,
                             newClassInfo.classDef
                     )) {
-                        logger.i(TAG, "Changed class: %s", desc);
-                        changedClassDescToClassInfosMap.put(
-                                desc, new DexClassInfo[]{oldClassInfo, newClassInfo}
-                        );
+                        if (Utils.isStringMatchesPatterns(desc, patternsOfIgnoredRemovedClassDesc)) {
+                            logger.i(TAG, "Ignored changed class: %s", desc);
+                        } else {
+                            logger.i(TAG, "Changed class: %s", desc);
+                            changedClassDescToClassInfosMap.put(
+                                    desc, new DexClassInfo[]{oldClassInfo, newClassInfo}
+                            );
+                        }
                     }
                     break;
                 }
-                case COMPARE_MODE_CAUSE_REF_CHANGE_ONLY: {
-                    if (isClassChangeAffectedToRef(
+                case COMPARE_MODE_REFERRER_AFFECTED_CHANGE_ONLY: {
+                    if (isClassChangeAffectedToReferrer(
                             oldClassInfo.owner,
                             newClassInfo.owner,
                             oldClassInfo.classDef,
                             newClassInfo.classDef
                     )) {
-                        logger.i(TAG, "Ref-changed class: %s", desc);
-                        changedClassDescToClassInfosMap.put(
-                                desc, new DexClassInfo[]{oldClassInfo, newClassInfo}
-                        );
+                        if (Utils.isStringMatchesPatterns(desc, patternsOfIgnoredRemovedClassDesc)) {
+                            logger.i(TAG, "Ignored referrer-affected changed class: %s", desc);
+                        } else {
+                            logger.i(TAG, "Referrer-affected change class: %s", desc);
+                            changedClassDescToClassInfosMap.put(
+                                    desc, new DexClassInfo[]{oldClassInfo, newClassInfo}
+                            );
+                        }
                     }
                     break;
                 }
@@ -278,7 +293,7 @@ public void startCheck(DexGroup oldDexGroup, DexGroup newDexGroup) {
         }
     }
 
-    private boolean isClassChangeAffectedToRef(
+    private boolean isClassChangeAffectedToReferrer(
             Dex oldDex,
             Dex newDex,
             ClassDef oldClassDef,
@@ -295,7 +310,7 @@ private boolean isClassChangeAffectedToRef(
             }
 
             // Any changes on superclass could affect refs of members in current class.
-            if (isTypeChangeAffectedToRef(
+            if (isTypeChangeAffectedToReferrer(
                     oldDex, newDex, oldClassDef.supertypeIndex, newClassDef.supertypeIndex
             )) {
                 result = true;
@@ -306,7 +321,7 @@ private boolean isClassChangeAffectedToRef(
             // of members in current class.
             short[] oldInterfaceTypeIds = oldDex.interfaceTypeIndicesFromClassDef(oldClassDef);
             short[] newInterfaceTypeIds = newDex.interfaceTypeIndicesFromClassDef(newClassDef);
-            if (isTypeIdsChangeAffectedToRef(
+            if (isTypeIdsChangeAffectedToReferrer(
                     oldDex, newDex, oldInterfaceTypeIds, newInterfaceTypeIds, false
             )) {
                 result = true;
@@ -319,7 +334,7 @@ private boolean isClassChangeAffectedToRef(
                     (oldClassDef.classDataOffset != 0 ? oldDex.readClassData(oldClassDef) : null);
             ClassData newClassData =
                     (newClassDef.classDataOffset != 0 ? newDex.readClassData(newClassDef) : null);
-            if (isClassDataChangeAffectedToRef(
+            if (isClassDataChangeAffectedToReferrer(
                     oldDex, newDex, oldClassData, newClassData
             )) {
                 result = true;
@@ -334,7 +349,7 @@ private boolean isClassChangeAffectedToRef(
         return result;
     }
 
-    private boolean isTypeChangeAffectedToRef(
+    private boolean isTypeChangeAffectedToReferrer(
             Dex oldDex, Dex newDex, int oldTypeId, int newTypeId
     ) {
         if (oldTypeId != ClassDef.NO_INDEX && newTypeId != ClassDef.NO_INDEX) {
@@ -349,7 +364,7 @@ private boolean isTypeChangeAffectedToRef(
             ClassDef oldClassDef = (oldClassInfo != null ? oldClassInfo.classDef : null);
             ClassDef newClassDef = (newClassInfo != null ? newClassInfo.classDef : null);
             if (oldClassDef != null && newClassDef != null) {
-                return isClassChangeAffectedToRef(oldClassInfo.owner, newClassInfo.owner, oldClassDef, newClassDef);
+                return isClassChangeAffectedToReferrer(oldClassInfo.owner, newClassInfo.owner, oldClassDef, newClassDef);
             } else
             if (oldClassDef == null && newClassDef == null) {
                 return false;
@@ -366,7 +381,7 @@ private boolean isTypeChangeAffectedToRef(
         return false;
     }
 
-    private boolean isTypeIdsChangeAffectedToRef(
+    private boolean isTypeIdsChangeAffectedToReferrer(
             Dex oldDex,
             Dex newDex,
             short[] oldTypeIds,
@@ -386,7 +401,7 @@ private boolean isTypeIdsChangeAffectedToRef(
                     return true;
                 }
             } else {
-                if (isTypeChangeAffectedToRef(oldDex, newDex, oldTypeIds[i], newTypeIds[i])) {
+                if (isTypeChangeAffectedToReferrer(oldDex, newDex, oldTypeIds[i], newTypeIds[i])) {
                     return true;
                 }
             }
@@ -395,32 +410,32 @@ private boolean isTypeIdsChangeAffectedToRef(
         return false;
     }
 
-    private boolean isClassDataChangeAffectedToRef(
+    private boolean isClassDataChangeAffectedToReferrer(
             Dex oldDex,
             Dex newDex,
             ClassData oldClassData,
             ClassData newClassData
     ) {
         if (oldClassData != null && newClassData != null) {
-            if (isFieldsChangeAffectedToRef(
+            if (isFieldsChangeAffectedToReferrer(
                     oldDex, newDex, oldClassData.instanceFields, newClassData.instanceFields
             )) {
                 return true;
             }
 
-            if (isFieldsChangeAffectedToRef(
+            if (isFieldsChangeAffectedToReferrer(
                     oldDex, newDex, oldClassData.staticFields, newClassData.staticFields
             )) {
                 return true;
             }
 
-            if (isMethodsChangeAffectedToRef(
+            if (isMethodsChangeAffectedToReferrer(
                     oldDex, newDex, oldClassData.directMethods, newClassData.directMethods
             )) {
                 return true;
             }
 
-            if (isMethodsChangeAffectedToRef(
+            if (isMethodsChangeAffectedToReferrer(
                     oldDex, newDex, oldClassData.virtualMethods, newClassData.virtualMethods
             )) {
                 return true;
@@ -433,7 +448,7 @@ private boolean isClassDataChangeAffectedToRef(
         return false;
     }
 
-    private boolean isFieldsChangeAffectedToRef(
+    private boolean isFieldsChangeAffectedToReferrer(
             Dex oldDex,
             Dex newDex,
             Field[] oldFields,
@@ -471,7 +486,7 @@ private boolean isFieldsChangeAffectedToRef(
         return false;
     }
 
-    private boolean isMethodsChangeAffectedToRef(
+    private boolean isMethodsChangeAffectedToReferrer(
             Dex oldDex,
             Dex newDex,
             Method[] oldMethods,
@@ -516,7 +531,7 @@ private boolean isMethodsChangeAffectedToRef(
 
             short[] oldParameterIds = oldDex.parameterTypeIndicesFromMethodId(oldMethodId);
             short[] newParameterIds = newDex.parameterTypeIndicesFromMethodId(newMethodId);
-            if (isTypeIdsChangeAffectedToRef(
+            if (isTypeIdsChangeAffectedToReferrer(
                     oldDex, newDex, oldParameterIds, newParameterIds, true
             )) {
                 return true;
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/ExcludedClassModifiedChecker.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/ExcludedClassModifiedChecker.java
index e87132ff..1ed5a31c 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/ExcludedClassModifiedChecker.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/ExcludedClassModifiedChecker.java
@@ -26,6 +26,8 @@
 import java.io.File;
 import java.io.IOException;
 import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
@@ -45,19 +47,25 @@
     private static final int STMCODE_ERROR_LOADER_CLASS_FOUND_IN_SECONDARY_NEW_DEX = 0x06;
     private static final int STMCODE_ERROR_LOADER_CLASS_CHANGED                    = 0x07;
     private static final int STMCODE_END                                           = 0x08;
-    private final Configuration config;
+    private final Configuration        config;
     private final DexClassesComparator dexCmptor;
-    private Dex oldDex = null;
-    private Dex newDex = null;
-    private List<DexClassInfo> deletedClassInfos = null;
-    private List<DexClassInfo> addedClassInfos = null;
-    private Map<String, DexClassInfo[]> changedClassInfosMap = null;
-    private Set<String> oldClassesDescToCheck = new HashSet<>();
-    private Set<String> newClassesDescToCheck = new HashSet<>();
+    private Dex                         oldDex                = null;
+    private Dex                         newDex                = null;
+    private List<DexClassInfo>          deletedClassInfos     = null;
+    private List<DexClassInfo>          addedClassInfos       = null;
+    private Map<String, DexClassInfo[]> changedClassInfosMap  = null;
+    private Set<String>                 oldClassesDescToCheck = new HashSet<>();
+    private Set<String>                 newClassesDescToCheck = new HashSet<>();
+    private HashSet<Pattern>            ignoreChangeWarning   = new HashSet<>();
 
     public ExcludedClassModifiedChecker(Configuration config) {
         this.config = config;
         this.dexCmptor = new DexClassesComparator(config.mDexLoaderPattern);
+        for (String classname : config.mDexIgnoreWarningLoaderPattern) {
+            ignoreChangeWarning.add(Pattern.compile(
+                PatternUtils.dotClassNamePatternToDescriptorRegEx(classname)
+            ));
+        }
     }
 
     public void checkIfExcludedClassWasModifiedInNewDex(File oldFile, File newFile) throws IOException, TinkerPatchException {
@@ -98,7 +106,7 @@ public void checkIfExcludedClassWasModifiedInNewDex(File oldFile, File newFile)
                             dexCmptor.startCheck(oldDex, newDex);
                             deletedClassInfos = dexCmptor.getDeletedClassInfos();
                             addedClassInfos = dexCmptor.getAddedClassInfos();
-                            changedClassInfosMap = dexCmptor.getChangedClassDescToInfosMap();
+                            changedClassInfosMap = new HashMap<>(dexCmptor.getChangedClassDescToInfosMap());
 
                             // All loader classes are in new dex, while none of them in old one.
                             if (deletedClassInfos.isEmpty() && changedClassInfosMap.isEmpty() && !addedClassInfos.isEmpty()) {
@@ -106,6 +114,14 @@ public void checkIfExcludedClassWasModifiedInNewDex(File oldFile, File newFile)
                             } else {
                                 if (deletedClassInfos.isEmpty() && addedClassInfos.isEmpty()) {
                                     // class descriptor is completely matches, see if any contents changes.
+                                    ArrayList<String> removeClasses = new ArrayList<>();
+                                    for (String classname : changedClassInfosMap.keySet()) {
+                                        if (Utils.checkFileInPattern(ignoreChangeWarning, classname)) {
+                                            Logger.e("loader class pattern: " + classname + " has changed, but it match ignore change pattern, just ignore!");
+                                            removeClasses.add(classname);
+                                        }
+                                    }
+                                    changedClassInfosMap.keySet().removeAll(removeClasses);
                                     if (changedClassInfosMap.isEmpty()) {
                                         stmCode = STMCODE_END;
                                     } else {
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/FileOperation.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/FileOperation.java
index 62fa8630..2f38f6b9 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/FileOperation.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/FileOperation.java
@@ -247,13 +247,16 @@ public static void unZipAPk(String fileName, String filePath) throws IOException
      * @param zipFile     output zip file
      * @throws IOException
      */
-    public static void zipFiles(Collection<File> resFileList, File zipFile) throws IOException {
+    public static void zipFiles(Collection<File> resFileList, File zipFile, String comment) throws IOException {
         ZipOutputStream zipout = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(zipFile), TypedValue.BUFFER_SIZE));
         for (File resFile : resFileList) {
             if (resFile.exists()) {
                 zipFile(resFile, zipout, "");
             }
         }
+        if (comment != null) {
+            zipout.setComment(comment);
+        }
         zipout.close();
     }
 
@@ -364,14 +367,14 @@ public static String getZipEntryMd5(File file, String entryName) {
         return null;
     }
 
-    public static void zipInputDir(File inputDir, File outputFile) throws IOException {
+    public static void zipInputDir(File inputDir, File outputFile, String comment) throws IOException {
         File[] unzipFiles = inputDir.listFiles();
         List<File> collectFiles = new ArrayList<>();
         for (File f : unzipFiles) {
             collectFiles.add(f);
         }
 
-        FileOperation.zipFiles(collectFiles, outputFile);
+        FileOperation.zipFiles(collectFiles, outputFile, comment);
     }
 
     public static boolean sevenZipInputDir(File inputDir, File outputFile, Configuration config) {
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/TypedValue.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/TypedValue.java
index 13120a8d..3d5822cb 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/TypedValue.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/TypedValue.java
@@ -24,19 +24,18 @@
 
     public static final int K_BYTES = 1024;
 
-    public static final String FILE_TXT                 = ".txt";
-    public static final String FILE_XML                 = ".xml";
-    public static final String FILE_APK                 = ".apk";
-    public static final String FILE_CONFIG              = "config.xml";
-    public static final String FILE_LOG                 = "log.txt";
-    public static final String SO_LOG_FILE              = "so_log.txt";
-    public static final String SO_META_FILE             = "so_meta.txt";
-    public static final String DEX_LOG_FILE             = "dex_log.txt";
-    public static final String DEX_META_FILE            = "dex_meta.txt";
-    public static final String DEX_TEMP_PATCH_DIR       = "tempPatchedDexes";
-    public static final String DEX_SMALLPATCH_INFO_FILE = "smallpatch_info.ddextra";
-    public static final String RES_LOG_FILE             = "res_log.txt";
-    public static final String RES_META_TXT             = "res_meta.txt";
+    public static final String FILE_TXT           = ".txt";
+    public static final String FILE_XML           = ".xml";
+    public static final String FILE_APK           = ".apk";
+    public static final String FILE_CONFIG        = "config.xml";
+    public static final String FILE_LOG           = "log.txt";
+    public static final String SO_LOG_FILE        = "so_log.txt";
+    public static final String SO_META_FILE       = "so_meta.txt";
+    public static final String DEX_LOG_FILE       = "dex_log.txt";
+    public static final String DEX_META_FILE      = "dex_meta.txt";
+    public static final String DEX_TEMP_PATCH_DIR = "tempPatchedDexes";
+    public static final String RES_LOG_FILE       = "res_log.txt";
+    public static final String RES_META_TXT       = "res_meta.txt";
 
     public static final String FILE_ASSETS = "assets";
 
@@ -55,10 +54,10 @@
     public static final double DEX_JAR_PATCH_MAX_RATIO = 1.0;
     public static final double BSDIFF_PATCH_MAX_RATIO  = 0.8;
 
-    public static final String RES_ARSC        = "resources.arsc";
-    public static final String RES_MANIFEST    = "AndroidManifest.xml";
-    public static final String RES_OUT         = "resources_out.zip";
-    public static final String RES_OUT_7ZIP    = "resources_out_7z.zip";
+    public static final String RES_ARSC     = "resources.arsc";
+    public static final String RES_MANIFEST = "AndroidManifest.xml";
+    public static final String RES_OUT      = "resources_out.zip";
+    public static final String RES_OUT_7ZIP = "resources_out_7z.zip";
 
     public static final int ADD       = 1;
     public static final int MOD       = 2;
@@ -70,8 +69,4 @@
     public static final String LARGE_MOD_TITLE = "large modify:";
     public static final String DEL_TITLE       = "delete:";
     public static final String PATTERN_TITLE   = "pattern:";
-
-    public static final String TEST_STRING_VALUE_A = "only use for test tinker resource: a";
-    public static final String TEST_STRING_VALUE_B = "only use for test tinker resource: b";
-
 }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/Utils.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/Utils.java
index fabadf31..400bc9b0 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/Utils.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/Utils.java
@@ -74,6 +74,10 @@ public static String convertToPatternString(String input) {
         return input;
     }
 
+    public static boolean isNullOrNil(final String object) {
+        return (object == null) || (object.length() <= 0);
+    }
+
     public static boolean isStringMatchesPatterns(String str, Collection<Pattern> patterns) {
         for (Pattern pattern : patterns) {
             if (pattern.matcher(str).matches()) {
diff --git a/tinker-build/tinker-patch-lib/src/main/java/org/jf/dexlib2/builder/BuilderMutableMethodImplementation.java b/tinker-build/tinker-patch-lib/src/main/java/org/jf/dexlib2/builder/BuilderMutableMethodImplementation.java
new file mode 100644
index 00000000..71e6168d
--- /dev/null
+++ b/tinker-build/tinker-patch-lib/src/main/java/org/jf/dexlib2/builder/BuilderMutableMethodImplementation.java
@@ -0,0 +1,1141 @@
+/*
+ * Copyright 2013, Google Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ * copyright notice, this list of conditions and the following disclaimer
+ * in the documentation and/or other materials provided with the
+ * distribution.
+ *     * Neither the name of Google Inc. nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ * *** This file is NOT a part of DexLib2 project. ***
+ *
+ * Tricky ways for converting MethodImplementation in DexFile into the corresponding
+ * one in DexBuilder.
+ *
+ * If you pass null as DexBuilder, this class behavior the same as
+ * what {@link org.jf.dexlib2.builder.MutableMethodImplementation} would do.
+ */
+
+package org.jf.dexlib2.builder;
+
+import com.google.common.base.Function;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Sets;
+
+import org.jf.dexlib2.DebugItemType;
+import org.jf.dexlib2.Opcode;
+import org.jf.dexlib2.builder.debug.BuilderEndLocal;
+import org.jf.dexlib2.builder.debug.BuilderEpilogueBegin;
+import org.jf.dexlib2.builder.debug.BuilderLineNumber;
+import org.jf.dexlib2.builder.debug.BuilderPrologueEnd;
+import org.jf.dexlib2.builder.debug.BuilderRestartLocal;
+import org.jf.dexlib2.builder.debug.BuilderSetSourceFile;
+import org.jf.dexlib2.builder.debug.BuilderStartLocal;
+import org.jf.dexlib2.builder.instruction.BuilderArrayPayload;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction10t;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction10x;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction11n;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction11x;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction12x;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction20bc;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction20t;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction21c;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction21ih;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction21lh;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction21s;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction21t;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction22b;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction22c;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction22s;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction22t;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction22x;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction23x;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction25x;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction30t;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction31c;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction31i;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction31t;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction32x;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction35c;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction3rc;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction51l;
+import org.jf.dexlib2.builder.instruction.BuilderPackedSwitchPayload;
+import org.jf.dexlib2.builder.instruction.BuilderSparseSwitchPayload;
+import org.jf.dexlib2.iface.ExceptionHandler;
+import org.jf.dexlib2.iface.MethodImplementation;
+import org.jf.dexlib2.iface.TryBlock;
+import org.jf.dexlib2.iface.debug.DebugItem;
+import org.jf.dexlib2.iface.debug.EndLocal;
+import org.jf.dexlib2.iface.debug.LineNumber;
+import org.jf.dexlib2.iface.debug.RestartLocal;
+import org.jf.dexlib2.iface.debug.SetSourceFile;
+import org.jf.dexlib2.iface.debug.StartLocal;
+import org.jf.dexlib2.iface.instruction.Instruction;
+import org.jf.dexlib2.iface.instruction.SwitchElement;
+import org.jf.dexlib2.iface.instruction.formats.ArrayPayload;
+import org.jf.dexlib2.iface.instruction.formats.Instruction10t;
+import org.jf.dexlib2.iface.instruction.formats.Instruction10x;
+import org.jf.dexlib2.iface.instruction.formats.Instruction11n;
+import org.jf.dexlib2.iface.instruction.formats.Instruction11x;
+import org.jf.dexlib2.iface.instruction.formats.Instruction12x;
+import org.jf.dexlib2.iface.instruction.formats.Instruction20bc;
+import org.jf.dexlib2.iface.instruction.formats.Instruction20t;
+import org.jf.dexlib2.iface.instruction.formats.Instruction21c;
+import org.jf.dexlib2.iface.instruction.formats.Instruction21ih;
+import org.jf.dexlib2.iface.instruction.formats.Instruction21lh;
+import org.jf.dexlib2.iface.instruction.formats.Instruction21s;
+import org.jf.dexlib2.iface.instruction.formats.Instruction21t;
+import org.jf.dexlib2.iface.instruction.formats.Instruction22b;
+import org.jf.dexlib2.iface.instruction.formats.Instruction22c;
+import org.jf.dexlib2.iface.instruction.formats.Instruction22s;
+import org.jf.dexlib2.iface.instruction.formats.Instruction22t;
+import org.jf.dexlib2.iface.instruction.formats.Instruction22x;
+import org.jf.dexlib2.iface.instruction.formats.Instruction23x;
+import org.jf.dexlib2.iface.instruction.formats.Instruction25x;
+import org.jf.dexlib2.iface.instruction.formats.Instruction30t;
+import org.jf.dexlib2.iface.instruction.formats.Instruction31c;
+import org.jf.dexlib2.iface.instruction.formats.Instruction31i;
+import org.jf.dexlib2.iface.instruction.formats.Instruction31t;
+import org.jf.dexlib2.iface.instruction.formats.Instruction32x;
+import org.jf.dexlib2.iface.instruction.formats.Instruction35c;
+import org.jf.dexlib2.iface.instruction.formats.Instruction3rc;
+import org.jf.dexlib2.iface.instruction.formats.Instruction51l;
+import org.jf.dexlib2.iface.instruction.formats.PackedSwitchPayload;
+import org.jf.dexlib2.iface.instruction.formats.SparseSwitchPayload;
+import org.jf.dexlib2.iface.reference.Reference;
+import org.jf.dexlib2.iface.reference.StringReference;
+import org.jf.dexlib2.iface.reference.TypeReference;
+import org.jf.dexlib2.writer.builder.DexBuilder;
+import org.jf.util.ExceptionWithContext;
+
+import java.util.AbstractList;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
+
+/**
+ * Created by tangyinsheng on 2017/02/16.
+ */
+public class BuilderMutableMethodImplementation implements MethodImplementation {
+    private final DexBuilder dexBuilder;
+    private final int registerCount;
+    private final ArrayList<MethodLocation> instructionList = Lists.newArrayList(new MethodLocation(null, 0, 0));
+    private final ArrayList<BuilderTryBlock> tryBlocks = Lists.newArrayList();
+    private boolean fixInstructions = true;
+
+    public BuilderMutableMethodImplementation(DexBuilder dexBuilder, @Nonnull MethodImplementation methodImplementation) {
+        this.dexBuilder = dexBuilder;
+
+        this.registerCount = methodImplementation.getRegisterCount();
+
+        int codeAddress = 0;
+        int index = 0;
+
+        for (Instruction instruction : methodImplementation.getInstructions()) {
+            codeAddress += instruction.getCodeUnits();
+            index++;
+
+            instructionList.add(new MethodLocation(null, codeAddress, index));
+        }
+
+        final int[] codeAddressToIndex = new int[codeAddress + 1];
+        Arrays.fill(codeAddressToIndex, -1);
+
+        for (int i = 0; i < instructionList.size(); i++) {
+            codeAddressToIndex[instructionList.get(i).codeAddress] = i;
+        }
+
+        List<Task> switchPayloadTasks = Lists.newArrayList();
+        index = 0;
+        for (final Instruction instruction : methodImplementation.getInstructions()) {
+            final MethodLocation location = instructionList.get(index);
+            final Opcode opcode = instruction.getOpcode();
+            if (opcode == Opcode.PACKED_SWITCH_PAYLOAD || opcode == Opcode.SPARSE_SWITCH_PAYLOAD) {
+                switchPayloadTasks.add(new Task() {
+                    @Override
+                    public void perform() {
+                        convertAndSetInstruction(location, codeAddressToIndex, instruction);
+                    }
+                });
+            } else {
+                convertAndSetInstruction(location, codeAddressToIndex, instruction);
+            }
+            index++;
+        }
+
+        // the switch payload instructions must be converted last, so that any switch statements that refer to them
+        // have created the referring labels that we look for
+        for (Task switchPayloadTask : switchPayloadTasks) {
+            switchPayloadTask.perform();
+        }
+
+        for (DebugItem debugItem : methodImplementation.getDebugItems()) {
+            int debugCodeAddress = debugItem.getCodeAddress();
+            int locationIndex = mapCodeAddressToIndex(codeAddressToIndex, debugCodeAddress);
+            MethodLocation debugLocation = instructionList.get(locationIndex);
+            BuilderDebugItem builderDebugItem = convertDebugItem(debugItem);
+            debugLocation.getDebugItems().add(builderDebugItem);
+            builderDebugItem.location = debugLocation;
+        }
+
+        for (TryBlock<? extends ExceptionHandler> tryBlock : methodImplementation.getTryBlocks()) {
+            Label startLabel = newLabel(codeAddressToIndex, tryBlock.getStartCodeAddress());
+            Label endLabel = newLabel(codeAddressToIndex, tryBlock.getStartCodeAddress() + tryBlock.getCodeUnitCount());
+
+            for (ExceptionHandler exceptionHandler : tryBlock.getExceptionHandlers()) {
+                tryBlocks.add(new BuilderTryBlock(startLabel, endLabel,
+                        (TypeReference) convertReference(exceptionHandler.getExceptionTypeReference()),
+                        newLabel(codeAddressToIndex, exceptionHandler.getHandlerCodeAddress())));
+            }
+        }
+    }
+
+    private interface Task {
+        void perform();
+    }
+
+    public BuilderMutableMethodImplementation(DexBuilder dexBuilder, int registerCount) {
+        this.dexBuilder = dexBuilder;
+        this.registerCount = registerCount;
+    }
+
+    @Override
+    public int getRegisterCount() {
+        return registerCount;
+    }
+
+    @Nonnull
+    public List<BuilderInstruction> getInstructions() {
+        if (fixInstructions) {
+            fixInstructions();
+        }
+
+        return new AbstractList<BuilderInstruction>() {
+            @Override
+            public BuilderInstruction get(int i) {
+                if (i >= size()) {
+                    throw new IndexOutOfBoundsException();
+                }
+                if (fixInstructions) {
+                    fixInstructions();
+                }
+                return instructionList.get(i).instruction;
+            }
+
+            @Override
+            public int size() {
+                if (fixInstructions) {
+                    fixInstructions();
+                }
+                // don't include the last MethodLocation, which always has a null instruction
+                return instructionList.size() - 1;
+            }
+        };
+    }
+
+    @Nonnull
+    @Override
+    public List<BuilderTryBlock> getTryBlocks() {
+        if (fixInstructions) {
+            fixInstructions();
+        }
+        return Collections.unmodifiableList(tryBlocks);
+    }
+
+    @Nonnull
+    @Override
+    public Iterable<? extends DebugItem> getDebugItems() {
+        if (fixInstructions) {
+            fixInstructions();
+        }
+        return Iterables.concat(
+                Iterables.transform(instructionList, new Function<MethodLocation, Iterable<? extends DebugItem>>() {
+                    @Nullable
+                    @Override
+                    public Iterable<? extends DebugItem> apply(@Nullable MethodLocation input) {
+                        assert input != null;
+                        if (fixInstructions) {
+                            throw new IllegalStateException("This iterator was invalidated by a change to"
+                                    + " this MutableMethodImplementation.");
+                        }
+                        return input.getDebugItems();
+                    }
+                }));
+    }
+
+    public void addCatch(@Nullable TypeReference type, @Nonnull Label from,
+                         @Nonnull Label to, @Nonnull Label handler) {
+        tryBlocks.add(new BuilderTryBlock(from, to, type, handler));
+    }
+
+    public void addCatch(@Nullable String type, @Nonnull Label from, @Nonnull Label to,
+                         @Nonnull Label handler) {
+        tryBlocks.add(new BuilderTryBlock(from, to, type, handler));
+    }
+
+    public void addCatch(@Nonnull Label from, @Nonnull Label to, @Nonnull Label handler) {
+        tryBlocks.add(new BuilderTryBlock(from, to, handler));
+    }
+
+    public void addInstruction(int index, BuilderInstruction instruction) {
+        // the end check here is intentially >= rather than >, because the list always includes an "empty"
+        // (null instruction) MethodLocation at the end. To add an instruction to the end of the list, the user would
+        // provide the index of this empty item, which would be size() - 1.
+        if (index >= instructionList.size()) {
+            throw new IndexOutOfBoundsException();
+        }
+
+        if (index == instructionList.size() - 1) {
+            addInstruction(instruction);
+            return;
+        }
+        int codeAddress = instructionList.get(index).getCodeAddress();
+        MethodLocation newLoc = new MethodLocation(instruction, codeAddress, index);
+        instructionList.add(index, newLoc);
+        instruction.location = newLoc;
+
+        codeAddress += instruction.getCodeUnits();
+
+        for (int i = index + 1; i < instructionList.size(); i++) {
+            MethodLocation location = instructionList.get(i);
+            location.index++;
+            location.codeAddress = codeAddress;
+            if (location.instruction != null) {
+                codeAddress += location.instruction.getCodeUnits();
+            } else {
+                // only the last MethodLocation should have a null instruction
+                assert i == instructionList.size() - 1;
+            }
+        }
+
+        this.fixInstructions = true;
+    }
+
+    public void addInstruction(@Nonnull BuilderInstruction instruction) {
+        MethodLocation last = instructionList.get(instructionList.size() - 1);
+        last.instruction = instruction;
+        instruction.location = last;
+
+        int nextCodeAddress = last.codeAddress + instruction.getCodeUnits();
+        instructionList.add(new MethodLocation(null, nextCodeAddress, instructionList.size()));
+
+        this.fixInstructions = true;
+    }
+
+    public void replaceInstruction(int index, @Nonnull BuilderInstruction replacementInstruction) {
+        if (index >= instructionList.size() - 1) {
+            throw new IndexOutOfBoundsException();
+        }
+
+        MethodLocation replaceLocation = instructionList.get(index);
+        replacementInstruction.location = replaceLocation;
+        BuilderInstruction old = replaceLocation.instruction;
+        assert old != null;
+        old.location = null;
+        replaceLocation.instruction = replacementInstruction;
+
+        // TODO: factor out index/address fix up loop
+        int codeAddress = replaceLocation.codeAddress + replaceLocation.instruction.getCodeUnits();
+        for (int i = index + 1; i < instructionList.size(); i++) {
+            MethodLocation location = instructionList.get(i);
+            location.codeAddress = codeAddress;
+
+            Instruction instruction = location.getInstruction();
+            if (instruction != null) {
+                codeAddress += instruction.getCodeUnits();
+            } else {
+                assert i == instructionList.size() - 1;
+            }
+        }
+
+        this.fixInstructions = true;
+    }
+
+    public void removeInstruction(int index) {
+        if (index >= instructionList.size() - 1) {
+            throw new IndexOutOfBoundsException();
+        }
+
+        MethodLocation toRemove = instructionList.get(index);
+        toRemove.instruction = null;
+        MethodLocation next = instructionList.get(index + 1);
+        toRemove.mergeInto(next);
+
+        instructionList.remove(index);
+        int codeAddress = toRemove.codeAddress;
+        for (int i = index; i < instructionList.size(); i++) {
+            MethodLocation location = instructionList.get(i);
+            location.index = i;
+            location.codeAddress = codeAddress;
+
+            Instruction instruction = location.getInstruction();
+            if (instruction != null) {
+                codeAddress += instruction.getCodeUnits();
+            } else {
+                assert i == instructionList.size() - 1;
+            }
+        }
+
+        this.fixInstructions = true;
+    }
+
+    public void swapInstructions(int index1, int index2) {
+        if (index1 >= instructionList.size() - 1 || index2 >= instructionList.size() - 1) {
+            throw new IndexOutOfBoundsException();
+        }
+        MethodLocation first = instructionList.get(index1);
+        MethodLocation second = instructionList.get(index2);
+
+        // only the last MethodLocation may have a null instruction
+        assert first.instruction != null;
+        assert second.instruction != null;
+
+        first.instruction.location = second;
+        second.instruction.location = first;
+
+        {
+            BuilderInstruction tmp = second.instruction;
+            second.instruction = first.instruction;
+            first.instruction = tmp;
+        }
+
+        if (index2 < index1) {
+            int tmp = index2;
+            index2 = index1;
+            index1 = tmp;
+        }
+
+        int codeAddress = first.codeAddress + first.instruction.getCodeUnits();
+        for (int i = index1 + 1; i <= index2; i++) {
+            MethodLocation location = instructionList.get(i);
+            location.codeAddress = codeAddress;
+
+            Instruction instruction = location.instruction;
+            assert instruction != null;
+            codeAddress += location.instruction.getCodeUnits();
+        }
+
+        this.fixInstructions = true;
+    }
+
+    @Nullable
+    private BuilderInstruction getFirstNonNop(int startIndex) {
+
+        for (int i = startIndex; i < instructionList.size() - 1; i++) {
+            BuilderInstruction instruction = instructionList.get(i).instruction;
+            assert instruction != null;
+            if (instruction.getOpcode() != Opcode.NOP) {
+                return instruction;
+            }
+        }
+        return null;
+    }
+
+    private void fixInstructions() {
+        HashSet<MethodLocation> payloadLocations = Sets.newHashSet();
+
+        for (MethodLocation location : instructionList) {
+            BuilderInstruction instruction = location.instruction;
+            if (instruction != null) {
+                switch (instruction.getOpcode()) {
+                    case SPARSE_SWITCH:
+                    case PACKED_SWITCH: {
+                        MethodLocation targetLocation =
+                                ((BuilderOffsetInstruction) instruction).getTarget().getLocation();
+                        BuilderInstruction targetInstruction = targetLocation.instruction;
+                        if (targetInstruction == null) {
+                            throw new IllegalStateException(String.format("Switch instruction at address/index "
+                                    + "0x%x/%d points to the end of the method.", location.codeAddress, location.index));
+                        }
+
+                        if (targetInstruction.getOpcode() == Opcode.NOP) {
+                            targetInstruction = getFirstNonNop(targetLocation.index + 1);
+                        }
+                        if (targetInstruction == null || !(targetInstruction instanceof BuilderSwitchPayload)) {
+                            throw new IllegalStateException(String.format("Switch instruction at address/index "
+                                            + "0x%x/%d does not refer to a payload instruction.",
+                                    location.codeAddress, location.index));
+                        }
+                        if ((instruction.opcode == Opcode.PACKED_SWITCH
+                                && targetInstruction.getOpcode() != Opcode.PACKED_SWITCH_PAYLOAD)
+                                || (instruction.opcode == Opcode.SPARSE_SWITCH
+                                        && targetInstruction.getOpcode() != Opcode.SPARSE_SWITCH_PAYLOAD)) {
+                            throw new IllegalStateException(String.format("Switch instruction at address/index "
+                                            + "0x%x/%d refers to the wrong type of payload instruction.",
+                                    location.codeAddress, location.index));
+                        }
+
+                        if (!payloadLocations.add(targetLocation)) {
+                            throw new IllegalStateException("Multiple switch instructions refer to the same payload. "
+                                    + "This is not currently supported. Please file a bug :)");
+                        }
+
+                        ((BuilderSwitchPayload) targetInstruction).referrer = location;
+                        break;
+                    }
+                }
+            }
+        }
+
+        boolean madeChanges;
+        do {
+            madeChanges = false;
+
+            for (int index = 0; index < instructionList.size(); index++) {
+                MethodLocation location = instructionList.get(index);
+                BuilderInstruction instruction = location.instruction;
+                if (instruction != null) {
+                    switch (instruction.getOpcode()) {
+                        case GOTO: {
+                            int offset = ((BuilderOffsetInstruction) instruction).internalGetCodeOffset();
+                            if (offset < Byte.MIN_VALUE || offset > Byte.MAX_VALUE) {
+                                BuilderOffsetInstruction replacement;
+                                if (offset < Short.MIN_VALUE || offset > Short.MAX_VALUE) {
+                                    replacement = new BuilderInstruction30t(Opcode.GOTO_32,
+                                            ((BuilderOffsetInstruction) instruction).getTarget());
+                                } else {
+                                    replacement = new BuilderInstruction20t(Opcode.GOTO_16,
+                                            ((BuilderOffsetInstruction) instruction).getTarget());
+                                }
+                                replaceInstruction(location.index, replacement);
+                                madeChanges = true;
+                            }
+                            break;
+                        }
+                        case GOTO_16: {
+                            int offset = ((BuilderOffsetInstruction) instruction).internalGetCodeOffset();
+                            if (offset < Short.MIN_VALUE || offset > Short.MAX_VALUE) {
+                                BuilderOffsetInstruction replacement = new BuilderInstruction30t(Opcode.GOTO_32,
+                                        ((BuilderOffsetInstruction) instruction).getTarget());
+                                replaceInstruction(location.index, replacement);
+                                madeChanges = true;
+                            }
+                            break;
+                        }
+                        case SPARSE_SWITCH_PAYLOAD:
+                        case PACKED_SWITCH_PAYLOAD:
+                            if (((BuilderSwitchPayload) instruction).referrer == null) {
+                                // if the switch payload isn't referenced, just remove it
+                                removeInstruction(index);
+                                index--;
+                                madeChanges = true;
+                                break;
+                            }
+                            // intentional fall-through
+                        case ARRAY_PAYLOAD: {
+                            if ((location.codeAddress & 0x01) != 0) {
+                                int previousIndex = location.index - 1;
+                                MethodLocation previousLocation = instructionList.get(previousIndex);
+                                Instruction previousInstruction = previousLocation.instruction;
+                                assert previousInstruction != null;
+                                if (previousInstruction.getOpcode() == Opcode.NOP) {
+                                    removeInstruction(previousIndex);
+                                    index--;
+                                } else {
+                                    addInstruction(location.index, new BuilderInstruction10x(Opcode.NOP));
+                                    index++;
+                                }
+                                madeChanges = true;
+                            }
+                            break;
+                        }
+                    }
+                }
+            }
+        } while (madeChanges);
+
+        fixInstructions = false;
+    }
+
+    private int mapCodeAddressToIndex(@Nonnull int[] codeAddressToIndex, int codeAddress) {
+        int index;
+        do {
+            index = codeAddressToIndex[codeAddress];
+            if (index < 0) {
+                codeAddress--;
+            } else {
+                return index;
+            }
+        } while (true);
+    }
+
+    private int mapCodeAddressToIndex(int codeAddress) {
+        float avgCodeUnitsPerInstruction = 1.9f;
+
+        int index = (int) (codeAddress / avgCodeUnitsPerInstruction);
+        if (index >= instructionList.size()) {
+            index = instructionList.size() - 1;
+        }
+
+        MethodLocation guessedLocation = instructionList.get(index);
+
+        if (guessedLocation.codeAddress == codeAddress) {
+            return index;
+        } else if (guessedLocation.codeAddress > codeAddress) {
+            do {
+                index--;
+            } while (instructionList.get(index).codeAddress > codeAddress);
+            return index;
+        } else {
+            do {
+                index++;
+            }
+            while (index < instructionList.size() && instructionList.get(index).codeAddress <= codeAddress);
+            return index - 1;
+        }
+    }
+
+    @Nonnull
+    public Label newLabelForAddress(int codeAddress) {
+        if (codeAddress < 0 || codeAddress > instructionList.get(instructionList.size() - 1).codeAddress) {
+            throw new IndexOutOfBoundsException(String.format("codeAddress %d out of bounds", codeAddress));
+        }
+        MethodLocation referent = instructionList.get(mapCodeAddressToIndex(codeAddress));
+        return referent.addNewLabel();
+    }
+
+    @Nonnull
+    public Label newLabelForIndex(int instructionIndex) {
+        if (instructionIndex < 0 || instructionIndex >= instructionList.size()) {
+            throw new IndexOutOfBoundsException(String.format("instruction index %d out of bounds", instructionIndex));
+        }
+        MethodLocation referent = instructionList.get(instructionIndex);
+        return referent.addNewLabel();
+    }
+
+    @Nonnull
+    private Label newLabel(@Nonnull int[] codeAddressToIndex, int codeAddress) {
+        MethodLocation referent = instructionList.get(mapCodeAddressToIndex(codeAddressToIndex, codeAddress));
+        return referent.addNewLabel();
+    }
+
+    private static class SwitchPayloadReferenceLabel extends Label {
+        @Nonnull
+        public MethodLocation switchLocation;
+    }
+
+    @Nonnull
+    public Label newSwitchPayloadReferenceLabel(@Nonnull MethodLocation switchLocation,
+                                                @Nonnull int[] codeAddressToIndex, int codeAddress) {
+        MethodLocation referent = instructionList.get(mapCodeAddressToIndex(codeAddressToIndex, codeAddress));
+        SwitchPayloadReferenceLabel label = new SwitchPayloadReferenceLabel();
+        label.switchLocation = switchLocation;
+        referent.getLabels().add(label);
+        return label;
+    }
+
+    private void setInstruction(@Nonnull MethodLocation location, @Nonnull BuilderInstruction instruction) {
+        location.instruction = instruction;
+        instruction.location = location;
+    }
+
+    private void convertAndSetInstruction(@Nonnull MethodLocation location, int[] codeAddressToIndex,
+                                          @Nonnull Instruction instruction) {
+        switch (instruction.getOpcode().format) {
+            case Format10t:
+                setInstruction(location, newBuilderInstruction10t(location.codeAddress,
+                        codeAddressToIndex,
+                        (Instruction10t) instruction));
+                return;
+            case Format10x:
+                setInstruction(location, newBuilderInstruction10x((Instruction10x) instruction));
+                return;
+            case Format11n:
+                setInstruction(location, newBuilderInstruction11n((Instruction11n) instruction));
+                return;
+            case Format11x:
+                setInstruction(location, newBuilderInstruction11x((Instruction11x) instruction));
+                return;
+            case Format12x:
+                setInstruction(location, newBuilderInstruction12x((Instruction12x) instruction));
+                return;
+            case Format20bc:
+                setInstruction(location, newBuilderInstruction20bc((Instruction20bc) instruction));
+                return;
+            case Format20t:
+                setInstruction(location, newBuilderInstruction20t(location.codeAddress,
+                        codeAddressToIndex,
+                        (Instruction20t) instruction));
+                return;
+            case Format21c:
+                setInstruction(location, newBuilderInstruction21c((Instruction21c) instruction));
+                return;
+            case Format21ih:
+                setInstruction(location, newBuilderInstruction21ih((Instruction21ih) instruction));
+                return;
+            case Format21lh:
+                setInstruction(location, newBuilderInstruction21lh((Instruction21lh) instruction));
+                return;
+            case Format21s:
+                setInstruction(location, newBuilderInstruction21s((Instruction21s) instruction));
+                return;
+            case Format21t:
+                setInstruction(location, newBuilderInstruction21t(location.codeAddress,
+                        codeAddressToIndex,
+                        (Instruction21t) instruction));
+                return;
+            case Format22b:
+                setInstruction(location, newBuilderInstruction22b((Instruction22b) instruction));
+                return;
+            case Format22c:
+                setInstruction(location, newBuilderInstruction22c((Instruction22c) instruction));
+                return;
+            case Format22s:
+                setInstruction(location, newBuilderInstruction22s((Instruction22s) instruction));
+                return;
+            case Format22t:
+                setInstruction(location, newBuilderInstruction22t(location.codeAddress,
+                        codeAddressToIndex,
+                        (Instruction22t) instruction));
+                return;
+            case Format22x:
+                setInstruction(location, newBuilderInstruction22x((Instruction22x) instruction));
+                return;
+            case Format23x:
+                setInstruction(location, newBuilderInstruction23x((Instruction23x) instruction));
+                return;
+            case Format25x:
+                setInstruction(location, newBuilderInstruction25x((Instruction25x) instruction));
+                return;
+            case Format30t:
+                setInstruction(location, newBuilderInstruction30t(location.codeAddress,
+                        codeAddressToIndex,
+                        (Instruction30t) instruction));
+                return;
+            case Format31c:
+                setInstruction(location, newBuilderInstruction31c((Instruction31c) instruction));
+                return;
+            case Format31i:
+                setInstruction(location, newBuilderInstruction31i((Instruction31i) instruction));
+                return;
+            case Format31t:
+                setInstruction(location, newBuilderInstruction31t(location, codeAddressToIndex,
+                        (Instruction31t) instruction));
+                return;
+            case Format32x:
+                setInstruction(location, newBuilderInstruction32x((Instruction32x) instruction));
+                return;
+            case Format35c:
+                setInstruction(location, newBuilderInstruction35c((Instruction35c) instruction));
+                return;
+            case Format3rc:
+                setInstruction(location, newBuilderInstruction3rc((Instruction3rc) instruction));
+                return;
+            case Format51l:
+                setInstruction(location, newBuilderInstruction51l((Instruction51l) instruction));
+                return;
+            case PackedSwitchPayload:
+                setInstruction(location,
+                        newBuilderPackedSwitchPayload(location, codeAddressToIndex, (PackedSwitchPayload) instruction));
+                return;
+            case SparseSwitchPayload:
+                setInstruction(location,
+                        newBuilderSparseSwitchPayload(location, codeAddressToIndex, (SparseSwitchPayload) instruction));
+                return;
+            case ArrayPayload:
+                setInstruction(location, newBuilderArrayPayload((ArrayPayload) instruction));
+                return;
+            default:
+                throw new ExceptionWithContext("Instruction format %s not supported", instruction.getOpcode().format);
+        }
+    }
+
+    @Nonnull
+    private BuilderInstruction10t newBuilderInstruction10t(int codeAddress, int[] codeAddressToIndex,
+                                                           @Nonnull Instruction10t instruction) {
+        return new BuilderInstruction10t(
+                instruction.getOpcode(),
+                newLabel(codeAddressToIndex, codeAddress + instruction.getCodeOffset()));
+    }
+
+    @Nonnull
+    private BuilderInstruction10x newBuilderInstruction10x(@Nonnull Instruction10x instruction) {
+        return new BuilderInstruction10x(
+                instruction.getOpcode());
+    }
+
+    @Nonnull
+    private BuilderInstruction11n newBuilderInstruction11n(@Nonnull Instruction11n instruction) {
+        return new BuilderInstruction11n(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getNarrowLiteral());
+    }
+
+    @Nonnull
+    private BuilderInstruction11x newBuilderInstruction11x(@Nonnull Instruction11x instruction) {
+        return new BuilderInstruction11x(
+                instruction.getOpcode(),
+                instruction.getRegisterA());
+    }
+
+    @Nonnull
+    private BuilderInstruction12x newBuilderInstruction12x(@Nonnull Instruction12x instruction) {
+        return new BuilderInstruction12x(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getRegisterB());
+    }
+
+    @Nonnull
+    private BuilderInstruction20bc newBuilderInstruction20bc(@Nonnull Instruction20bc instruction) {
+        return new BuilderInstruction20bc(
+                instruction.getOpcode(),
+                instruction.getVerificationError(),
+                convertReference(instruction.getReference()));
+    }
+
+    @Nonnull
+    private BuilderInstruction20t newBuilderInstruction20t(int codeAddress, int[] codeAddressToIndex,
+                                                           @Nonnull Instruction20t instruction) {
+        return new BuilderInstruction20t(
+                instruction.getOpcode(),
+                newLabel(codeAddressToIndex, codeAddress + instruction.getCodeOffset()));
+    }
+
+    @Nonnull
+    private BuilderInstruction21c newBuilderInstruction21c(@Nonnull Instruction21c instruction) {
+        return new BuilderInstruction21c(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                convertReference(instruction.getReference()));
+    }
+
+    @Nonnull
+    private BuilderInstruction21ih newBuilderInstruction21ih(@Nonnull Instruction21ih instruction) {
+        return new BuilderInstruction21ih(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getNarrowLiteral());
+    }
+
+    @Nonnull
+    private BuilderInstruction21lh newBuilderInstruction21lh(@Nonnull Instruction21lh instruction) {
+        return new BuilderInstruction21lh(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getWideLiteral());
+    }
+
+    @Nonnull
+    private BuilderInstruction21s newBuilderInstruction21s(@Nonnull Instruction21s instruction) {
+        return new BuilderInstruction21s(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getNarrowLiteral());
+    }
+
+    @Nonnull
+    private BuilderInstruction21t newBuilderInstruction21t(int codeAddress, int[] codeAddressToIndex,
+                                                           @Nonnull Instruction21t instruction) {
+        return new BuilderInstruction21t(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                newLabel(codeAddressToIndex, codeAddress + instruction.getCodeOffset()));
+    }
+
+    @Nonnull
+    private BuilderInstruction22b newBuilderInstruction22b(@Nonnull Instruction22b instruction) {
+        return new BuilderInstruction22b(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getRegisterB(),
+                instruction.getNarrowLiteral());
+    }
+
+    @Nonnull
+    private BuilderInstruction22c newBuilderInstruction22c(@Nonnull Instruction22c instruction) {
+        return new BuilderInstruction22c(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getRegisterB(),
+                convertReference(instruction.getReference()));
+    }
+
+    @Nonnull
+    private BuilderInstruction22s newBuilderInstruction22s(@Nonnull Instruction22s instruction) {
+        return new BuilderInstruction22s(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getRegisterB(),
+                instruction.getNarrowLiteral());
+    }
+
+    @Nonnull
+    private BuilderInstruction22t newBuilderInstruction22t(int codeAddress, int[] codeAddressToIndex,
+                                                           @Nonnull Instruction22t instruction) {
+        return new BuilderInstruction22t(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getRegisterB(),
+                newLabel(codeAddressToIndex, codeAddress + instruction.getCodeOffset()));
+    }
+
+    @Nonnull
+    private BuilderInstruction22x newBuilderInstruction22x(@Nonnull Instruction22x instruction) {
+        return new BuilderInstruction22x(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getRegisterB());
+    }
+
+    @Nonnull
+    private BuilderInstruction23x newBuilderInstruction23x(@Nonnull Instruction23x instruction) {
+        return new BuilderInstruction23x(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getRegisterB(),
+                instruction.getRegisterC());
+    }
+
+    @Nonnull
+    private BuilderInstruction30t newBuilderInstruction30t(int codeAddress, int[] codeAddressToIndex,
+                                                           @Nonnull Instruction30t instruction) {
+        return new BuilderInstruction30t(
+                instruction.getOpcode(),
+                newLabel(codeAddressToIndex, codeAddress + instruction.getCodeOffset()));
+    }
+
+    @Nonnull
+    private BuilderInstruction31c newBuilderInstruction31c(@Nonnull Instruction31c instruction) {
+        return new BuilderInstruction31c(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                convertReference(instruction.getReference()));
+    }
+
+    @Nonnull
+    private BuilderInstruction31i newBuilderInstruction31i(@Nonnull Instruction31i instruction) {
+        return new BuilderInstruction31i(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getNarrowLiteral());
+    }
+
+    @Nonnull
+    private BuilderInstruction31t newBuilderInstruction31t(@Nonnull MethodLocation location, int[] codeAddressToIndex,
+                                                           @Nonnull Instruction31t instruction) {
+        int codeAddress = location.getCodeAddress();
+        Label newLabel;
+        if (instruction.getOpcode() != Opcode.FILL_ARRAY_DATA) {
+            // if it's a sparse switch or packed switch
+            newLabel = newSwitchPayloadReferenceLabel(location, codeAddressToIndex, codeAddress + instruction.getCodeOffset());
+        } else {
+            newLabel = newLabel(codeAddressToIndex, codeAddress + instruction.getCodeOffset());
+        }
+        return new BuilderInstruction31t(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                newLabel);
+    }
+
+    @Nonnull
+    private BuilderInstruction32x newBuilderInstruction32x(@Nonnull Instruction32x instruction) {
+        return new BuilderInstruction32x(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getRegisterB());
+    }
+
+    @Nonnull
+    private BuilderInstruction35c newBuilderInstruction35c(@Nonnull Instruction35c instruction) {
+        return new BuilderInstruction35c(
+                instruction.getOpcode(),
+                instruction.getRegisterCount(),
+                instruction.getRegisterC(),
+                instruction.getRegisterD(),
+                instruction.getRegisterE(),
+                instruction.getRegisterF(),
+                instruction.getRegisterG(),
+                convertReference(instruction.getReference()));
+    }
+
+    @Nonnull
+    private BuilderInstruction25x newBuilderInstruction25x(@Nonnull Instruction25x instruction) {
+        return new BuilderInstruction25x(
+                instruction.getOpcode(),
+                instruction.getParameterRegisterCount(),
+                instruction.getRegisterFixedC(),
+                instruction.getRegisterParameterD(),
+                instruction.getRegisterParameterE(),
+                instruction.getRegisterParameterF(),
+                instruction.getRegisterParameterG());
+    }
+
+    @Nonnull
+    private BuilderInstruction3rc newBuilderInstruction3rc(@Nonnull Instruction3rc instruction) {
+        return new BuilderInstruction3rc(
+                instruction.getOpcode(),
+                instruction.getStartRegister(),
+                instruction.getRegisterCount(),
+                convertReference(instruction.getReference()));
+    }
+
+    @Nonnull
+    private BuilderInstruction51l newBuilderInstruction51l(@Nonnull Instruction51l instruction) {
+        return new BuilderInstruction51l(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getWideLiteral());
+    }
+
+    @Nullable
+    private MethodLocation findSwitchForPayload(@Nonnull MethodLocation payloadLocation) {
+        MethodLocation location = payloadLocation;
+        MethodLocation switchLocation = null;
+        do {
+            for (Label label : location.getLabels()) {
+                if (label instanceof SwitchPayloadReferenceLabel) {
+                    if (switchLocation != null) {
+                        throw new IllegalStateException("Multiple switch instructions refer to the same payload. "
+                                + "This is not currently supported. Please file a bug :)");
+                    }
+                    switchLocation = ((SwitchPayloadReferenceLabel) label).switchLocation;
+                }
+            }
+
+            // A switch instruction can refer to the payload instruction itself, or to a nop before the payload
+            // instruction.
+            // We need to search for all occurrences of a switch reference, so we can detect when multiple switch
+            // statements refer to the same payload
+            // TODO: confirm that it could refer to the first NOP in a series of NOPs preceding the payload
+            if (location.index == 0) {
+                return switchLocation;
+            }
+            location = instructionList.get(location.index - 1);
+            if (location.instruction == null || location.instruction.getOpcode() != Opcode.NOP) {
+                return switchLocation;
+            }
+        } while (true);
+    }
+
+    @Nonnull
+    private BuilderPackedSwitchPayload newBuilderPackedSwitchPayload(@Nonnull MethodLocation location,
+                                                                     @Nonnull int[] codeAddressToIndex,
+                                                                     @Nonnull PackedSwitchPayload instruction) {
+        List<? extends SwitchElement> switchElements = instruction.getSwitchElements();
+        if (switchElements.size() == 0) {
+            return new BuilderPackedSwitchPayload(0, null);
+        }
+
+        MethodLocation switchLocation = findSwitchForPayload(location);
+        int baseAddress;
+        if (switchLocation == null) {
+            baseAddress = 0;
+        } else {
+            baseAddress = switchLocation.codeAddress;
+        }
+
+        List<Label> labels = Lists.newArrayList();
+        for (SwitchElement element : switchElements) {
+            labels.add(newLabel(codeAddressToIndex, element.getOffset() + baseAddress));
+        }
+
+        return new BuilderPackedSwitchPayload(switchElements.get(0).getKey(), labels);
+    }
+
+    @Nonnull
+    private BuilderSparseSwitchPayload newBuilderSparseSwitchPayload(@Nonnull MethodLocation location,
+                                                                     @Nonnull int[] codeAddressToIndex,
+                                                                     @Nonnull SparseSwitchPayload instruction) {
+        List<? extends SwitchElement> switchElements = instruction.getSwitchElements();
+        if (switchElements.size() == 0) {
+            return new BuilderSparseSwitchPayload(null);
+        }
+
+        MethodLocation switchLocation = findSwitchForPayload(location);
+        int baseAddress;
+        if (switchLocation == null) {
+            baseAddress = 0;
+        } else {
+            baseAddress = switchLocation.codeAddress;
+        }
+
+        List<SwitchLabelElement> labelElements = Lists.newArrayList();
+        for (SwitchElement element : switchElements) {
+            labelElements.add(new SwitchLabelElement(element.getKey(),
+                    newLabel(codeAddressToIndex, element.getOffset() + baseAddress)));
+        }
+
+        return new BuilderSparseSwitchPayload(labelElements);
+    }
+
+    @Nonnull
+    private BuilderArrayPayload newBuilderArrayPayload(@Nonnull ArrayPayload instruction) {
+        return new BuilderArrayPayload(instruction.getElementWidth(), instruction.getArrayElements());
+    }
+
+    private Reference convertReference(@Nonnull Reference reference) {
+        if (reference != null && this.dexBuilder != null) {
+            return this.dexBuilder.internReference(reference);
+        } else {
+            return reference;
+        }
+    }
+
+    @Nonnull
+    private BuilderDebugItem convertDebugItem(@Nonnull DebugItem debugItem) {
+        switch (debugItem.getDebugItemType()) {
+            case DebugItemType.START_LOCAL: {
+                StartLocal startLocal = (StartLocal) debugItem;
+                return new BuilderStartLocal(startLocal.getRegister(),
+                        (StringReference) convertReference(startLocal.getNameReference()),
+                        (TypeReference) convertReference(startLocal.getTypeReference()),
+                        (StringReference) convertReference(startLocal.getSignatureReference()));
+            }
+            case DebugItemType.END_LOCAL: {
+                EndLocal endLocal = (EndLocal) debugItem;
+                return new BuilderEndLocal(endLocal.getRegister());
+            }
+            case DebugItemType.RESTART_LOCAL: {
+                RestartLocal restartLocal = (RestartLocal) debugItem;
+                return new BuilderRestartLocal(restartLocal.getRegister());
+            }
+            case DebugItemType.PROLOGUE_END:
+                return new BuilderPrologueEnd();
+            case DebugItemType.EPILOGUE_BEGIN:
+                return new BuilderEpilogueBegin();
+            case DebugItemType.LINE_NUMBER: {
+                LineNumber lineNumber = (LineNumber) debugItem;
+                return new BuilderLineNumber(lineNumber.getLineNumber());
+            }
+            case DebugItemType.SET_SOURCE_FILE: {
+                SetSourceFile setSourceFile = (SetSourceFile) debugItem;
+                return new BuilderSetSourceFile(
+                        (StringReference) convertReference(setSourceFile.getSourceFileReference())
+                );
+            }
+            default:
+                throw new ExceptionWithContext("Invalid debug item type: " + debugItem.getDebugItemType());
+        }
+    }
+}
\ No newline at end of file
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/resutil/ResUtil.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/resutil/ResUtil.java
index b9780090..16c55853 100644
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/resutil/ResUtil.java
+++ b/tinker-commons/src/main/java/com/tencent/tinker/commons/resutil/ResUtil.java
@@ -20,6 +20,7 @@
 import com.tencent.tinker.commons.ziputil.TinkerZipFile;
 import com.tencent.tinker.commons.ziputil.TinkerZipOutputStream;
 
+import java.io.BufferedInputStream;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.IOException;
@@ -49,6 +50,16 @@ public static void extractTinkerEntry(TinkerZipFile apk, TinkerZipEntry zipEntry
         }
     }
 
+    public static void extractTinkerEntry(TinkerZipEntry zipEntry, InputStream inputStream, TinkerZipOutputStream outputStream) throws IOException {
+        outputStream.putNextEntry(zipEntry);
+        byte[] buffer = new byte[BUFFER_SIZE];
+
+        for (int length = inputStream.read(buffer); length != -1; length = inputStream.read(buffer)) {
+            outputStream.write(buffer, 0, length);
+        }
+        outputStream.closeEntry();
+    }
+
     public static void extractLargeModifyFile(TinkerZipEntry sourceArscEntry, File newFile, long newFileCrc, TinkerZipOutputStream outputStream) throws IOException {
         TinkerZipEntry newArscZipEntry = new TinkerZipEntry(sourceArscEntry);
 
@@ -56,9 +67,9 @@ public static void extractLargeModifyFile(TinkerZipEntry sourceArscEntry, File n
         newArscZipEntry.setSize(newFile.length());
         newArscZipEntry.setCompressedSize(newFile.length());
         newArscZipEntry.setCrc(newFileCrc);
-        FileInputStream in = null;
+        BufferedInputStream in = null;
         try {
-            in = new FileInputStream(newFile);
+            in = new BufferedInputStream(new FileInputStream(newFile));
             outputStream.putNextEntry(new TinkerZipEntry(newArscZipEntry));
             byte[] buffer = new byte[BUFFER_SIZE];
 
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/ziputil/TinkerZipEntry.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/ziputil/TinkerZipEntry.java
index 54510611..0e5696e8 100644
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/ziputil/TinkerZipEntry.java
+++ b/tinker-commons/src/main/java/com/tencent/tinker/commons/ziputil/TinkerZipEntry.java
@@ -107,6 +107,20 @@ public TinkerZipEntry(TinkerZipEntry ze) {
         localHeaderRelOffset = ze.localHeaderRelOffset;
         dataOffset = ze.dataOffset;
     }
+
+    public TinkerZipEntry(TinkerZipEntry ze, String name) {
+        this.name = name;
+        comment = ze.comment;
+        time = ze.time;
+        size = ze.size;
+        compressedSize = ze.compressedSize;
+        crc = ze.crc;
+        compressionMethod = ze.compressionMethod;
+        modDate = ze.modDate;
+        extra = ze.extra;
+        localHeaderRelOffset = ze.localHeaderRelOffset;
+        dataOffset = ze.dataOffset;
+    }
     /*
      * Internal constructor.  Creates a new ZipEntry by reading the
      * Central Directory Entry (CDE) from "in", which must be positioned
diff --git a/tinker-sample-android/app/build.gradle b/tinker-sample-android/app/build.gradle
index 269372f3..6da2043c 100644
--- a/tinker-sample-android/app/build.gradle
+++ b/tinker-sample-android/app/build.gradle
@@ -38,8 +38,8 @@ def gitSha() {
 def javaVersion = JavaVersion.VERSION_1_7
 
 android {
-    compileSdkVersion 23
-    buildToolsVersion "23.0.2"
+    compileSdkVersion 25
+    buildToolsVersion "25.0.2"
 
     compileOptions {
         sourceCompatibility javaVersion
@@ -69,7 +69,7 @@ android {
 
     defaultConfig {
         applicationId "tinker.sample.android"
-        minSdkVersion 10
+        minSdkVersion 14
         targetSdkVersion 22
         versionCode 1
         versionName "1.0.0"
@@ -246,6 +246,15 @@ if (buildWithTinker()) {
              * open this can reduce the dex diff file size.
              */
             keepDexApply = false
+
+            /**
+             * optional, default 'false'
+             * Whether tinker should treat the base apk as the one being protected by app
+             * protection tools.
+             * If this attribute is true, the generated patch package will contain a
+             * dex including all changed classes instead of any dexdiff patch-info files.
+             */
+            isProtectedApp = false
         }
 
         dex {
@@ -364,6 +373,8 @@ if (buildWithTinker()) {
         flavors.add(flavor.name)
     }
     boolean hasFlavors = flavors.size() > 0
+    def date = new Date().format("MMdd-HH-mm-ss")
+
     /**
     * bak apk and mapping
     */
@@ -372,7 +383,6 @@ if (buildWithTinker()) {
          * task type, you want to bak
          */
         def taskName = variant.name
-        def date = new Date().format("MMdd-HH-mm-ss")
 
         tasks.all {
             if ("assemble${taskName.capitalize()}".equalsIgnoreCase(it.name)) {
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/app/SampleApplicationLike.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/app/SampleApplicationLike.java
index 9233951e..5aef75a3 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/app/SampleApplicationLike.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/app/SampleApplicationLike.java
@@ -26,10 +26,13 @@
 import com.tencent.tinker.anno.DefaultLifeCycle;
 import com.tencent.tinker.lib.tinker.Tinker;
 import com.tencent.tinker.lib.tinker.TinkerInstaller;
+import com.tencent.tinker.lib.util.TinkerLog;
 import com.tencent.tinker.loader.app.ApplicationLifeCycle;
 import com.tencent.tinker.loader.app.DefaultApplicationLike;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
 
+import java.util.regex.Pattern;
+
 import tinker.sample.android.Log.MyLogImp;
 import tinker.sample.android.util.SampleApplicationContext;
 import tinker.sample.android.util.TinkerManager;
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/crash/SampleUncaughtExceptionHandler.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/crash/SampleUncaughtExceptionHandler.java
index a4c6c184..90dcd767 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/crash/SampleUncaughtExceptionHandler.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/crash/SampleUncaughtExceptionHandler.java
@@ -65,22 +65,26 @@ public void uncaughtException(Thread thread, Throwable ex) {
      * If it use Xposed, we can just clean patch or mention user to uninstall it.
      */
     private void tinkerPreVerifiedCrashHandler(Throwable ex) {
+        ApplicationLike applicationLike = TinkerManager.getTinkerApplicationLike();
+        if (applicationLike == null || applicationLike.getApplication() == null) {
+            TinkerLog.w(TAG, "applicationlike is null");
+            return;
+        }
+
+        if (!TinkerApplicationHelper.isTinkerLoadSuccess(applicationLike)) {
+            TinkerLog.w(TAG, "tinker is not loaded");
+            return;
+        }
+
         Throwable throwable = ex;
         boolean isXposed = false;
         while (throwable != null) {
             if (!isXposed) {
                 isXposed = Utils.isXposedExists(throwable);
             }
-            if (isXposed) {
-                //method 1
-                ApplicationLike applicationLike = TinkerManager.getTinkerApplicationLike();
-                if (applicationLike == null || applicationLike.getApplication() == null) {
-                    return;
-                }
 
-                if (!TinkerApplicationHelper.isTinkerLoadSuccess(applicationLike)) {
-                    return;
-                }
+            // xposed?
+            if (isXposed) {
                 boolean isCausedByXposed = false;
                 //for art, we can't know the actually crash type
                 //just ignore art
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SampleLoadReporter.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SampleLoadReporter.java
index bc2acd22..05dd146e 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SampleLoadReporter.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SampleLoadReporter.java
@@ -21,16 +21,11 @@
 import android.os.MessageQueue;
 
 import com.tencent.tinker.lib.reporter.DefaultLoadReporter;
-import com.tencent.tinker.lib.tinker.Tinker;
-import com.tencent.tinker.lib.tinker.TinkerInstaller;
-import com.tencent.tinker.lib.util.TinkerLog;
+import com.tencent.tinker.lib.util.UpgradePatchRetry;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
-import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
-import com.tencent.tinker.loader.shareutil.ShareTinkerInternals;
 
 import java.io.File;
 
-import tinker.sample.android.util.UpgradePatchRetry;
 
 /**
  * optional, you can just use DefaultLoadReporter
@@ -58,26 +53,19 @@ public void onLoadResult(File patchDirectory, int loadCode, long cost) {
                 break;
         }
         Looper.getMainLooper().myQueue().addIdleHandler(new MessageQueue.IdleHandler() {
-            @Override public boolean queueIdle() {
-                UpgradePatchRetry.getInstance(context).onPatchRetryLoad();
+            @Override
+            public boolean queueIdle() {
+                if (UpgradePatchRetry.getInstance(context).onPatchRetryLoad()) {
+                    SampleTinkerReport.onReportRetryPatch();
+                }
                 return false;
             }
         });
     }
+
     @Override
     public void onLoadException(Throwable e, int errorCode) {
         super.onLoadException(e, errorCode);
-        switch (errorCode) {
-            case ShareConstants.ERROR_LOAD_EXCEPTION_UNCAUGHT:
-                String uncaughtString = SharePatchFileUtil.checkTinkerLastUncaughtCrash(context);
-                if (!ShareTinkerInternals.isNullOrNil(uncaughtString)) {
-                    File laseCrashFile = SharePatchFileUtil.getPatchLastCrashFile(context);
-                    SharePatchFileUtil.safeDeleteFile(laseCrashFile);
-                    // found really crash reason
-                    TinkerLog.e(TAG, "tinker uncaught real exception:" + uncaughtString);
-                }
-                break;
-        }
         SampleTinkerReport.onLoadException(e, errorCode);
     }
 
@@ -89,35 +77,14 @@ public void onLoadFileMd5Mismatch(File file, int fileType) {
 
     /**
      * try to recover patch oat file
+     *
      * @param file
      * @param fileType
      * @param isDirectory
      */
     @Override
     public void onLoadFileNotFound(File file, int fileType, boolean isDirectory) {
-        TinkerLog.i(TAG, "patch loadReporter onLoadFileNotFound: patch file not found: %s, fileType:%d, isDirectory:%b",
-            file.getAbsolutePath(), fileType, isDirectory);
-
-        // only try to recover opt file
-        // check dex opt file at last, some phone such as VIVO/OPPO like to change dex2oat to interpreted
-        if (fileType == ShareConstants.TYPE_DEX_OPT) {
-            Tinker tinker = Tinker.with(context);
-            //we can recover at any process except recover process
-            if (tinker.isMainProcess()) {
-                File patchVersionFile = tinker.getTinkerLoadResultIfPresent().patchVersionFile;
-                if (patchVersionFile != null) {
-                    if (UpgradePatchRetry.getInstance(context).onPatchListenerCheck(SharePatchFileUtil.getMD5(patchVersionFile))) {
-                        TinkerLog.i(TAG, "try to repair oat file on patch process");
-                        TinkerInstaller.onReceiveUpgradePatch(context, patchVersionFile.getAbsolutePath());
-                    } else {
-                        TinkerLog.i(TAG, "repair retry exceed must max time, just clean");
-                        checkAndCleanPatch();
-                    }
-                }
-            }
-        } else {
-            checkAndCleanPatch();
-        }
+        super.onLoadFileNotFound(file, fileType, isDirectory);
         SampleTinkerReport.onLoadFileNotFound(fileType);
     }
 
@@ -133,6 +100,12 @@ public void onLoadPatchInfoCorrupted(String oldVersion, String newVersion, File
         SampleTinkerReport.onLoadInfoCorrupted();
     }
 
+    @Override
+    public void onLoadInterpret(int type, Throwable e) {
+        super.onLoadInterpret(type, e);
+        SampleTinkerReport.onLoadInterpretReport(type, e);
+    }
+
     @Override
     public void onLoadPatchVersionChanged(String oldVersion, String newVersion, File patchDirectoryFile, String currentPatchName) {
         super.onLoadPatchVersionChanged(oldVersion, newVersion, patchDirectoryFile, currentPatchName);
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SamplePatchListener.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SamplePatchListener.java
index 17a63497..1407c8a7 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SamplePatchListener.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SamplePatchListener.java
@@ -21,8 +21,6 @@
 import android.content.SharedPreferences;
 
 import com.tencent.tinker.lib.listener.DefaultPatchListener;
-import com.tencent.tinker.lib.tinker.Tinker;
-import com.tencent.tinker.lib.tinker.TinkerLoadResult;
 import com.tencent.tinker.lib.util.TinkerLog;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
 import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
@@ -33,7 +31,6 @@
 
 import tinker.sample.android.app.BuildInfo;
 import tinker.sample.android.crash.SampleUncaughtExceptionHandler;
-import tinker.sample.android.util.UpgradePatchRetry;
 import tinker.sample.android.util.Utils;
 
 /**
@@ -64,41 +61,21 @@ public SamplePatchListener(Context context) {
      * @return
      */
     @Override
-    public int patchCheck(String path) {
+    public int patchCheck(String path, String patchMd5) {
         File patchFile = new File(path);
         TinkerLog.i(TAG, "receive a patch file: %s, file size:%d", path, SharePatchFileUtil.getFileOrDirectorySize(patchFile));
-        int returnCode = super.patchCheck(path);
+        int returnCode = super.patchCheck(path, patchMd5);
 
         if (returnCode == ShareConstants.ERROR_PATCH_OK) {
             returnCode = Utils.checkForPatchRecover(NEW_PATCH_RESTRICTION_SPACE_SIZE_MIN, maxMemory);
         }
 
         if (returnCode == ShareConstants.ERROR_PATCH_OK) {
-            String patchMd5 = SharePatchFileUtil.getMD5(patchFile);
             SharedPreferences sp = context.getSharedPreferences(ShareConstants.TINKER_SHARE_PREFERENCE_CONFIG, Context.MODE_MULTI_PROCESS);
             //optional, only disable this patch file with md5
             int fastCrashCount = sp.getInt(patchMd5, 0);
             if (fastCrashCount >= SampleUncaughtExceptionHandler.MAX_CRASH_COUNT) {
                 returnCode = Utils.ERROR_PATCH_CRASH_LIMIT;
-            } else {
-                //for upgrade patch, version must be not the same
-                //for repair patch, we won't has the tinker load flag
-                Tinker tinker = Tinker.with(context);
-
-                if (tinker.isTinkerLoaded()) {
-                    TinkerLoadResult tinkerLoadResult = tinker.getTinkerLoadResultIfPresent();
-                    if (tinkerLoadResult != null) {
-                        String currentVersion = tinkerLoadResult.currentVersion;
-                        if (patchMd5.equals(currentVersion)) {
-                            returnCode = Utils.ERROR_PATCH_ALREADY_APPLY;
-                        }
-                    }
-                }
-            }
-            //check whether retry so many times
-            if (returnCode == ShareConstants.ERROR_PATCH_OK) {
-                returnCode = UpgradePatchRetry.getInstance(context).onPatchListenerCheck(patchMd5)
-                    ? ShareConstants.ERROR_PATCH_OK : Utils.ERROR_PATCH_RETRY_COUNT_LIMIT;
             }
         }
         // Warning, it is just a sample case, you don't need to copy all of these
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SamplePatchReporter.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SamplePatchReporter.java
index af0753f0..9099bb4c 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SamplePatchReporter.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SamplePatchReporter.java
@@ -23,14 +23,14 @@
 import com.tencent.tinker.loader.shareutil.SharePatchInfo;
 
 import java.io.File;
-
-import tinker.sample.android.util.UpgradePatchRetry;
+import java.util.List;
 
 /**
  * optional, you can just use DefaultPatchReporter
  * Created by zhangshaowen on 16/4/8.
  */
 public class SamplePatchReporter extends DefaultPatchReporter {
+    private final static String TAG = "Tinker.SamplePatchReporter";
     public SamplePatchReporter(Context context) {
         super(context);
     }
@@ -39,12 +39,11 @@ public SamplePatchReporter(Context context) {
     public void onPatchServiceStart(Intent intent) {
         super.onPatchServiceStart(intent);
         SampleTinkerReport.onApplyPatchServiceStart();
-        UpgradePatchRetry.getInstance(context).onPatchServiceStart(intent);
     }
 
     @Override
-    public void onPatchDexOptFail(File patchFile, File dexFile, String optDirectory, String dexName, Throwable t) {
-        super.onPatchDexOptFail(patchFile, dexFile, optDirectory, dexName, t);
+    public void onPatchDexOptFail(File patchFile, List<File> dexFiles, Throwable t) {
+        super.onPatchDexOptFail(patchFile, dexFiles, t);
         SampleTinkerReport.onApplyDexOptFail(t);
     }
 
@@ -70,7 +69,6 @@ public void onPatchPackageCheckFail(File patchFile, int errorCode) {
     public void onPatchResult(File patchFile, boolean success, long cost) {
         super.onPatchResult(patchFile, success, cost);
         SampleTinkerReport.onApplied(cost, success);
-        UpgradePatchRetry.getInstance(context).onPatchServiceResult();
     }
 
     @Override
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SampleTinkerReport.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SampleTinkerReport.java
index a2d5a74e..b0fa2309 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SampleTinkerReport.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SampleTinkerReport.java
@@ -54,14 +54,17 @@
     public static final int KEY_TRY_APPLY_MEMORY_LIMIT            = 78;
     public static final int KEY_TRY_APPLY_CRASH_LIMIT             = 79;
     public static final int KEY_TRY_APPLY_CONDITION_NOT_SATISFIED = 80;
+    public static final int KEY_TRY_APPLY_JIT                     = 81;
 
     //Key -- apply detail
     public static final int KEY_APPLIED_UPGRADE      = 100;
     public static final int KEY_APPLIED_UPGRADE_FAIL = 101;
 
     public static final int KEY_APPLIED_EXCEPTION                               = 120;
-    public static final int KEY_APPLIED_DEXOPT                                  = 121;
-    public static final int KEY_APPLIED_INFO_CORRUPTED                          = 122;
+    public static final int KEY_APPLIED_DEXOPT_OTHER                            = 121;
+    public static final int KEY_APPLIED_DEXOPT_EXIST                            = 122;
+    public static final int KEY_APPLIED_DEXOPT_FORMAT                           = 123;
+    public static final int KEY_APPLIED_INFO_CORRUPTED                          = 124;
     //package check
     public static final int KEY_APPLIED_PACKAGE_CHECK_SIGNATURE                 = 150;
     public static final int KEY_APPLIED_PACKAGE_CHECK_DEX_META                  = 151;
@@ -74,18 +77,18 @@
     public static final int KEY_APPLIED_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT    = 158;
 
     //version check
-    public static final int KEY_APPLIED_VERSION_CHECK                           = 180;
+    public static final int KEY_APPLIED_VERSION_CHECK      = 180;
     //extract error
-    public static final int KEY_APPLIED_PATCH_FILE_EXTRACT                      = 181;
-    public static final int KEY_APPLIED_DEX_EXTRACT                             = 182;
-    public static final int KEY_APPLIED_LIB_EXTRACT                             = 183;
-    public static final int KEY_APPLIED_RESOURCE_EXTRACT                        = 184;
+    public static final int KEY_APPLIED_PATCH_FILE_EXTRACT = 181;
+    public static final int KEY_APPLIED_DEX_EXTRACT        = 182;
+    public static final int KEY_APPLIED_LIB_EXTRACT        = 183;
+    public static final int KEY_APPLIED_RESOURCE_EXTRACT   = 184;
     //cost time
-    public static final int KEY_APPLIED_SUCC_COST_5S_LESS                       = 200;
-    public static final int KEY_APPLIED_SUCC_COST_10S_LESS                      = 201;
-    public static final int KEY_APPLIED_SUCC_COST_30S_LESS                      = 202;
-    public static final int KEY_APPLIED_SUCC_COST_60S_LESS                      = 203;
-    public static final int KEY_APPLIED_SUCC_COST_OTHER                         = 204;
+    public static final int KEY_APPLIED_SUCC_COST_5S_LESS  = 200;
+    public static final int KEY_APPLIED_SUCC_COST_10S_LESS = 201;
+    public static final int KEY_APPLIED_SUCC_COST_30S_LESS = 202;
+    public static final int KEY_APPLIED_SUCC_COST_60S_LESS = 203;
+    public static final int KEY_APPLIED_SUCC_COST_OTHER    = 204;
 
     public static final int KEY_APPLIED_FAIL_COST_5S_LESS  = 205;
     public static final int KEY_APPLIED_FAIL_COST_10S_LESS = 206;
@@ -132,6 +135,11 @@
     public static final int KEY_LOADED_SUCC_COST_5000_LESS = 403;
     public static final int KEY_LOADED_SUCC_COST_OTHER     = 404;
 
+    public static final int KEY_LOADED_INTERPRET_GET_INSTRUCTION_SET_ERROR = 450;
+    public static final int KEY_LOADED_INTERPRET_INTERPRET_COMMAND_ERROR   = 451;
+    public static final int KEY_LOADED_INTERPRET_TYPE_INTERPRET_OK         = 452;
+
+
     interface Reporter {
         void onReport(int key);
 
@@ -174,13 +182,16 @@ public static void onTryApplyFail(int errorCode) {
             case ShareConstants.ERROR_PATCH_RUNNING:
                 reporter.onReport(KEY_TRY_APPLY_RUNNING);
                 break;
+            case ShareConstants.ERROR_PATCH_JIT:
+                reporter.onReport(KEY_TRY_APPLY_JIT);
+                break;
             case Utils.ERROR_PATCH_ROM_SPACE:
                 reporter.onReport(KEY_TRY_APPLY_ROM_SPACE);
                 break;
             case Utils.ERROR_PATCH_GOOGLEPLAY_CHANNEL:
                 reporter.onReport(KEY_TRY_APPLY_GOOGLEPLAY);
                 break;
-            case Utils.ERROR_PATCH_ALREADY_APPLY:
+            case ShareConstants.ERROR_PATCH_ALREADY_APPLY:
                 reporter.onReport(KEY_TRY_APPLY_ALREADY_APPLY);
                 break;
             case Utils.ERROR_PATCH_CRASH_LIMIT:
@@ -192,6 +203,7 @@ public static void onTryApplyFail(int errorCode) {
             case Utils.ERROR_PATCH_CONDITION_NOT_SATISFIED:
                 reporter.onReport(KEY_TRY_APPLY_CONDITION_NOT_SATISFIED);
                 break;
+
         }
     }
 
@@ -288,6 +300,25 @@ public static void onLoadFileNotFound(int fileType) {
         }
     }
 
+    public static void onLoadInterpretReport(int type, Throwable e) {
+        if (reporter == null) {
+            return;
+        }
+        switch (type) {
+            case ShareConstants.TYPE_INTERPRET_GET_INSTRUCTION_SET_ERROR:
+                reporter.onReport(KEY_LOADED_INTERPRET_GET_INSTRUCTION_SET_ERROR);
+                reporter.onReport("Tinker Exception:interpret occur exception " + Utils.getExceptionCauseString(e));
+                break;
+            case ShareConstants.TYPE_INTERPRET_COMMAND_ERROR:
+                reporter.onReport(KEY_LOADED_INTERPRET_INTERPRET_COMMAND_ERROR);
+                reporter.onReport("Tinker Exception:interpret occur exception " + Utils.getExceptionCauseString(e));
+                break;
+            case ShareConstants.TYPE_INTERPRET_OK:
+                reporter.onReport(KEY_LOADED_INTERPRET_TYPE_INTERPRET_OK);
+                break;
+        }
+    }
+
     public static void onLoadFileMisMatch(int fileType) {
         if (reporter == null) {
             return;
@@ -355,8 +386,14 @@ public static void onApplyDexOptFail(Throwable throwable) {
         if (reporter == null) {
             return;
         }
-        reporter.onReport(KEY_APPLIED_DEXOPT);
-        reporter.onReport("Tinker Exception:apply tinker occur exception " + Utils.getExceptionCauseString(throwable));
+        if (throwable.getMessage().contains(ShareConstants.CHECK_DEX_OAT_EXIST_FAIL)) {
+            reporter.onReport(KEY_APPLIED_DEXOPT_EXIST);
+        } else if (throwable.getMessage().contains(ShareConstants.CHECK_DEX_OAT_FORMAT_FAIL)) {
+            reporter.onReport(KEY_APPLIED_DEXOPT_FORMAT);
+        } else {
+            reporter.onReport(KEY_APPLIED_DEXOPT_OTHER);
+            reporter.onReport("Tinker Exception:apply tinker occur exception " + Utils.getExceptionCauseString(throwable));
+        }
     }
 
     public static void onApplyInfoCorrupted() {
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/service/SampleResultService.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/service/SampleResultService.java
index 3b62551f..34550ba8 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/service/SampleResultService.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/service/SampleResultService.java
@@ -16,10 +16,6 @@
 
 package tinker.sample.android.service;
 
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.Intent;
-import android.content.IntentFilter;
 import android.os.Handler;
 import android.os.Looper;
 import android.widget.Toast;
@@ -28,7 +24,6 @@
 import com.tencent.tinker.lib.service.PatchResult;
 import com.tencent.tinker.lib.util.TinkerLog;
 import com.tencent.tinker.lib.util.TinkerServiceInternals;
-import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
 
 import java.io.File;
 
@@ -80,7 +75,7 @@ public void run() {
                     //we can wait process at background, such as onAppBackground
                     //or we can restart when the screen off
                     TinkerLog.i(TAG, "tinker wait screen to restart process");
-                    new ScreenState(getApplicationContext(), new ScreenState.IOnScreenOff() {
+                    new Utils.ScreenState(getApplicationContext(), new Utils.ScreenState.IOnScreenOff() {
                         @Override
                         public void onScreenOff() {
                             restartProcess();
@@ -102,31 +97,4 @@ private void restartProcess() {
         android.os.Process.killProcess(android.os.Process.myPid());
     }
 
-    static class ScreenState {
-        interface IOnScreenOff {
-            void onScreenOff();
-        }
-
-        ScreenState(Context context, final IOnScreenOff onScreenOffInterface) {
-            IntentFilter filter = new IntentFilter();
-            filter.addAction(Intent.ACTION_SCREEN_OFF);
-            context.registerReceiver(new BroadcastReceiver() {
-
-                @Override
-                public void onReceive(Context context, Intent in) {
-                    String action = in == null ? "" : in.getAction();
-                    TinkerLog.i(TAG, "ScreenReceiver action [%s] ", action);
-                    if (Intent.ACTION_SCREEN_OFF.equals(action)) {
-
-                        context.unregisterReceiver(this);
-
-                        if (onScreenOffInterface != null) {
-                            onScreenOffInterface.onScreenOff();
-                        }
-                    }
-                }
-            }, filter);
-        }
-    }
-
 }
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/util/TinkerManager.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/util/TinkerManager.java
index d22e30f5..e3af535f 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/util/TinkerManager.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/util/TinkerManager.java
@@ -23,6 +23,7 @@
 import com.tencent.tinker.lib.reporter.PatchReporter;
 import com.tencent.tinker.lib.tinker.TinkerInstaller;
 import com.tencent.tinker.lib.util.TinkerLog;
+import com.tencent.tinker.lib.util.UpgradePatchRetry;
 import com.tencent.tinker.loader.app.ApplicationLike;
 
 import tinker.sample.android.crash.SampleUncaughtExceptionHandler;
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/util/Utils.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/util/Utils.java
index 8767307d..7c19509b 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/util/Utils.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/util/Utils.java
@@ -16,9 +16,14 @@
 
 package tinker.sample.android.util;
 
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
 import android.os.Environment;
 import android.os.StatFs;
 
+import com.tencent.tinker.lib.util.TinkerLog;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
 
 import java.io.ByteArrayOutputStream;
@@ -30,18 +35,17 @@
  * Created by zhangshaowen on 16/4/7.
  */
 public class Utils {
+    private static final String TAG = "Tinker.Utils";
 
     /**
      * the error code define by myself
      * should after {@code ShareConstants.ERROR_PATCH_INSERVICE
      */
-    public static final int ERROR_PATCH_GOOGLEPLAY_CHANNEL      = -5;
-    public static final int ERROR_PATCH_ROM_SPACE               = -6;
-    public static final int ERROR_PATCH_MEMORY_LIMIT            = -7;
-    public static final int ERROR_PATCH_ALREADY_APPLY           = -8;
-    public static final int ERROR_PATCH_CRASH_LIMIT             = -9;
-    public static final int ERROR_PATCH_RETRY_COUNT_LIMIT       = -10;
-    public static final int ERROR_PATCH_CONDITION_NOT_SATISFIED = -11;
+    public static final int ERROR_PATCH_GOOGLEPLAY_CHANNEL      = -20;
+    public static final int ERROR_PATCH_ROM_SPACE               = -21;
+    public static final int ERROR_PATCH_MEMORY_LIMIT            = -22;
+    public static final int ERROR_PATCH_CRASH_LIMIT             = -23;
+    public static final int ERROR_PATCH_CONDITION_NOT_SATISFIED = -24;
 
     public static final String PLATFORM = "platform";
 
@@ -154,4 +158,30 @@ private static String toVisualString(String src) {
             return src;
         }
     }
+
+    public static class ScreenState {
+        public interface IOnScreenOff {
+            void onScreenOff();
+        }
+
+        public ScreenState(final Context context, final IOnScreenOff onScreenOffInterface) {
+            IntentFilter filter = new IntentFilter();
+            filter.addAction(Intent.ACTION_SCREEN_OFF);
+
+            context.registerReceiver(new BroadcastReceiver() {
+
+                @Override
+                public void onReceive(Context context, Intent in) {
+                    String action = in == null ? "" : in.getAction();
+                    TinkerLog.i(TAG, "ScreenReceiver action [%s] ", action);
+                    if (Intent.ACTION_SCREEN_OFF.equals(action)) {
+                        if (onScreenOffInterface != null) {
+                            onScreenOffInterface.onScreenOff();
+                        }
+                    }
+                    context.unregisterReceiver(this);
+                }
+            }, filter);
+        }
+    }
 }
diff --git a/tinker-sample-android/gradle.properties b/tinker-sample-android/gradle.properties
index 25a8de5a..a6a66d40 100644
--- a/tinker-sample-android/gradle.properties
+++ b/tinker-sample-android/gradle.properties
@@ -17,4 +17,4 @@
 # http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
 # org.gradle.parallel=true
 
-TINKER_VERSION=1.7.7
+TINKER_VERSION=1.8.0
diff --git a/tinker-sample-android/updateTinkerLib.sh b/tinker-sample-android/updateTinkerLib.sh
index 30ae62b1..8511ab5f 100755
--- a/tinker-sample-android/updateTinkerLib.sh
+++ b/tinker-sample-android/updateTinkerLib.sh
@@ -2,4 +2,4 @@
 rm -rf ~/.gradle/caches/modules-2/metadata-2.16/descriptors/com.tencent.tinker
 
 #rm -rf ~/.m2/repository/com/tencent/tinker
-#adb push ./app/build/outputs/tinkerPatch/debug/patch_signed_7zip.apk /storage/sdcard0/
\ No newline at end of file
+#adb push ./app/build/outputs/tinkerPatch/debug/patch_signed_7zip.apk /sdcard/
\ No newline at end of file
