diff --git a/README.md b/README.md
index cea57bd8..48b74f87 100644
--- a/README.md
+++ b/README.md
@@ -1,6 +1,6 @@
 ## Tinker
 [![license](http://img.shields.io/badge/license-BSD3-brightgreen.svg?style=flat)](https://github.com/Tencent/tinker/blob/master/LICENSE)
-[![Release Version](https://img.shields.io/badge/release-1.7.0-red.svg)](https://github.com/Tencent/tinker/releases) 
+[![Release Version](https://img.shields.io/badge/release-1.7.3-red.svg)](https://github.com/Tencent/tinker/releases) 
 [![PRs Welcome](https://img.shields.io/badge/PRs-welcome-brightgreen.svg)](https://github.com/Tencent/tinker/pulls)
 [![WeChat Approved](https://img.shields.io/badge/Wechat_Approved-1.6.2-red.svg)](https://github.com/Tencent/tinker/wiki)
 
@@ -14,7 +14,7 @@ Add tinker-gradle-plugin as a dependency in your main `build.gradle` in the root
 ```gradle
 buildscript {
     dependencies {
-        classpath ('com.tencent.tinker:tinker-patch-gradle-plugin:1.7.0')
+        classpath ('com.tencent.tinker:tinker-patch-gradle-plugin:1.7.3')
     }
 }
 ```
@@ -24,9 +24,9 @@ Then you need to "apply" the plugin and add dependencies by adding the following
 ```gradle
 dependencies {
     //optional, help to generate the final application 
-    compile('com.tencent.tinker:tinker-android-anno:1.7.0')
+    provided('com.tencent.tinker:tinker-android-anno:1.7.3')
     //tinker's main Android lib
-    compile('com.tencent.tinker:tinker-android-lib:1.7.0') 
+    compile('com.tencent.tinker:tinker-android-lib:1.7.3') 
 }
 ...
 ...
diff --git a/gradle.properties b/gradle.properties
index 10b53050..89e660e7 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -16,5 +16,5 @@
 # This option should only be used with decoupled projects. More details, visit
 # http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
 # org.gradle.parallel=true
-VERSION_NAME_PREFIX=1.7.0
+VERSION_NAME_PREFIX=1.7.3
 VERSION_NAME_SUFFIX=
\ No newline at end of file
diff --git a/gradle/android-artifacts.gradle b/gradle/android-artifacts.gradle
index 47735f09..1d14ded6 100644
--- a/gradle/android-artifacts.gradle
+++ b/gradle/android-artifacts.gradle
@@ -87,6 +87,8 @@ publishing {
     }
 }
 
-task buildAndPublishLocalMaven(dependsOn: ['build', 'publishTinkerPatchPublicationToMavenLocal']) {}
+task buildAndPublishTinkerToLocalMaven(dependsOn: ['build', 'publishTinkerPatchPublicationToMavenLocal']) {
+    group = 'tinker'
+}
 //depend checkstyle
 project.tasks.getByName("check").dependsOn tasks.getByName("checkstyle")
diff --git a/gradle/java-artifacts.gradle b/gradle/java-artifacts.gradle
index 9b8b6e3b..8f498a2e 100644
--- a/gradle/java-artifacts.gradle
+++ b/gradle/java-artifacts.gradle
@@ -39,7 +39,9 @@ publishing {
     }
 }
 
-task buildAndPublishLocalMaven(dependsOn: ['build', 'publishTinkerPatchPublicationToMavenLocal']) {}
+task buildAndPublishTinkerToLocalMaven(dependsOn: ['build', 'publishTinkerPatchPublicationToMavenLocal']) {
+    group = 'tinker'
+}
 
 //depend checkstyle
 project.tasks.getByName("check").dependsOn tasks.getByName("checkstyle")
\ No newline at end of file
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/DefaultPatchListener.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/DefaultPatchListener.java
index f0f3055f..b4cf11d0 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/DefaultPatchListener.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/DefaultPatchListener.java
@@ -60,7 +60,7 @@ public int onPatchReceived(String path, boolean isUpgrade) {
 
     protected int patchCheck(String path, boolean isUpgrade) {
         Tinker manager = Tinker.with(context);
-        //check SharePrefenences also
+        //check SharePreferences also
         if (!manager.isTinkerEnabled() || !ShareTinkerInternals.isTinkerEnableWithSharedPreferences(context)) {
             return ShareConstants.ERROR_PATCH_DISABLE;
         }
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java
index 03ba6974..2ab8a3de 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java
@@ -18,6 +18,7 @@
 
 import android.content.Context;
 import android.content.pm.ApplicationInfo;
+import android.os.Build;
 import android.os.SystemClock;
 
 import com.tencent.tinker.commons.dexpatcher.DexPatchApplier;
@@ -53,7 +54,6 @@
 
     protected static boolean tryRecoverDexFiles(Tinker manager, ShareSecurityCheck checker, Context context,
                                                 String patchVersionDirectory, File patchFile, boolean isUpgradePatch) {
-
         if (!manager.isEnabledForDex()) {
             TinkerLog.w(TAG, "patch recover, dex is not enabled");
             return true;
@@ -73,6 +73,8 @@ protected static boolean tryRecoverDexFiles(Tinker manager, ShareSecurityCheck c
     }
 
     private static boolean patchDexExtractViaDexDiff(Context context, String patchVersionDirectory, String meta, File patchFile, boolean isUpgradePatch) {
+        checkVmArtProperty();
+
         String dir = patchVersionDirectory + "/" + DEX_PATH + "/";
 
         int dexType = ShareTinkerInternals.isVmArt() ? TYPE_DEX_FOR_ART : TYPE_DEX;
@@ -180,6 +182,10 @@ private static boolean extractDexDiffInternals(Context context, String dir, Stri
                 String dexDiffMd5 = info.dexDiffMd5;
                 String oldDexCrc = info.oldDexCrC;
 
+                if (!ShareTinkerInternals.isVmArt() && info.destMd5InDvm.equals("0")) {
+                    TinkerLog.w(TAG, "patch dex %s is only for art, just continue", patchRealPath);
+                    continue;
+                }
                 String extractedFileMd5 = ShareTinkerInternals.isVmArt() ? info.destMd5InArt : info.destMd5InDvm;
 
                 if (!SharePatchFileUtil.checkIfMd5Valid(extractedFileMd5)) {
@@ -403,6 +409,16 @@ private static boolean extractDexToJar(ZipFile zipFile, ZipEntry entryFile, File
         return isExtractionSuccessful;
     }
 
+    /**
+     * reject dalvik vm, but sdk version is larger than 21
+     */
+    private static void checkVmArtProperty() {
+        boolean art = ShareTinkerInternals.isVmArt();
+        if (!art && Build.VERSION.SDK_INT >= 21) {
+            throw new TinkerRuntimeException("it is dalvik vm, but sdk version " + Build.VERSION.SDK_INT + " is larger than 21!");
+        }
+    }
+
     private static boolean extractDexFile(ZipFile zipFile, ZipEntry entryFile, File extractTo, ShareDexDiffPatchInfo dexInfo) throws IOException {
         final String fileMd5 = ShareTinkerInternals.isVmArt() ? dexInfo.destMd5InArt : dexInfo.destMd5InDvm;
         final String rawName = dexInfo.rawName;
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/RepairPatch.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/RepairPatch.java
index f9910f82..48a7395b 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/RepairPatch.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/RepairPatch.java
@@ -59,7 +59,7 @@ public boolean tryPatch(Context context, String tempPatchPath, PatchResult patch
         ShareSecurityCheck signatureCheck = new ShareSecurityCheck(context);
 
 
-        int returnCode = ShareTinkerInternals.checkSignatureAndTinkerID(context, patchFile, signatureCheck);
+        int returnCode = ShareTinkerInternals.checkTinkerPackage(context, manager.getTinkerFlags(), patchFile, signatureCheck);
         if (returnCode != ShareConstants.ERROR_PACKAGE_CHECK_OK) {
             TinkerLog.e(TAG, "RepairPatch tryPatch:onPatchPackageCheckFail");
             manager.getPatchReporter().onPatchPackageCheckFail(patchFile, false, returnCode);
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/UpgradePatch.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/UpgradePatch.java
index 3a91e09f..bde1e228 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/UpgradePatch.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/UpgradePatch.java
@@ -56,7 +56,7 @@ public boolean tryPatch(Context context, String tempPatchPath, PatchResult patch
         //check the signature, we should create a new checker
         ShareSecurityCheck signatureCheck = new ShareSecurityCheck(context);
 
-        int returnCode = ShareTinkerInternals.checkSignatureAndTinkerID(context, patchFile, signatureCheck);
+        int returnCode = ShareTinkerInternals.checkTinkerPackage(context, manager.getTinkerFlags(), patchFile, signatureCheck);
         if (returnCode != ShareConstants.ERROR_PACKAGE_CHECK_OK) {
             TinkerLog.e(TAG, "UpgradePatch tryPatch:onPatchPackageCheckFail");
             manager.getPatchReporter().onPatchPackageCheckFail(patchFile, true, returnCode);
@@ -101,7 +101,7 @@ public boolean tryPatch(Context context, String tempPatchPath, PatchResult patch
         //check ok, we can real recover a new patch
         final String patchDirectory = manager.getPatchDirectory().getAbsolutePath();
 
-        TinkerLog.i(TAG, "UpgradePatch tryPatch:dexDiffMd5:%s", patchMd5);
+        TinkerLog.i(TAG, "UpgradePatch tryPatch:patchMd5:%s", patchMd5);
 
         final String patchName = SharePatchFileUtil.getPatchVersionDirectory(patchMd5);
 
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultLoadReporter.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultLoadReporter.java
index ec5a6b23..7fe4c3e1 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultLoadReporter.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultLoadReporter.java
@@ -234,6 +234,7 @@ public void onLoadException(Throwable e, int errorCode) {
                 //exception can be caught, it is no need to disable Tinker with sharedPreference
                 break;
         }
+        TinkerLog.e(TAG, "tinker load exception, welcome to submit issue to us: https://github.com/Tencent/tinker/issues");
         TinkerLog.printErrStackTrace(TAG, e, "tinker load exception");
 
         Tinker.with(context).setTinkerDisable();
@@ -253,6 +254,7 @@ public void onLoadException(Throwable e, int errorCode) {
      *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_PATCH_TINKER_ID_NOT_FOUND}       can't find TINKER_PATCH in patch meta file
      *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_TINKER_ID_NOT_EQUAL}             apk and patch's TINKER_PATCH value is not equal
      *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_RESOURCE_META_CORRUPTED}         resource meta file's format check fail
+     *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT}          some patch file type is not supported for current tinkerFlag
      */
     @Override
     public void onLoadPackageCheckFail(File patchFile, int errorCode) {
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultPatchReporter.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultPatchReporter.java
index c1717c41..f0e813f3 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultPatchReporter.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultPatchReporter.java
@@ -69,6 +69,7 @@ public void onPatchServiceStart(Intent intent) {
      *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_PATCH_TINKER_ID_NOT_FOUND}       can't find TINKER_PATCH in patch meta file
      *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_TINKER_ID_NOT_EQUAL}             apk and patch's TINKER_PATCH value is not equal
      *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_RESOURCE_META_CORRUPTED}         resource meta file's format check fail
+     *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT}          some patch file type is not supported for current tinkerFlag
      */
     @Override
     public void onPatchPackageCheckFail(File patchFile, boolean isUpgradePatch, int errorCode) {
@@ -179,6 +180,7 @@ public void onPatchInfoCorrupted(File patchFile, String oldVersion, String newVe
     @Override
     public void onPatchException(File patchFile, Throwable e, boolean isUpgradePatch) {
         TinkerLog.i(TAG, "patchReporter: patch exception path:%s, throwable:%s, isUpgrade:%b", patchFile.getAbsolutePath(), e.getMessage(), isUpgradePatch);
+        TinkerLog.e(TAG, "tinker patch exception, welcome to submit issue to us: https://github.com/Tencent/tinker/issues");
         TinkerLog.printErrStackTrace(TAG, e, "tinker patch exception");
         //don't accept request any more!
         Tinker.with(context).setTinkerDisable();
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/LoadReporter.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/LoadReporter.java
index 67f4c7aa..5ca258a9 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/LoadReporter.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/LoadReporter.java
@@ -134,6 +134,7 @@
      *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_PATCH_TINKER_ID_NOT_FOUND}       can't find TINKER_PATCH in patch meta file
      *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_TINKER_ID_NOT_EQUAL}             apk and patch's TINKER_PATCH value is not equal
      *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_RESOURCE_META_CORRUPTED}         resource meta file's format check fail
+     *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT}          some patch file type is not supported for current tinkerFlag
      */
     void onLoadPackageCheckFail(File patchFile, int errorCode);
 
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/PatchReporter.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/PatchReporter.java
index dbc5860c..e9ac07d2 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/PatchReporter.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/PatchReporter.java
@@ -59,6 +59,7 @@
      *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_PATCH_TINKER_ID_NOT_FOUND}       can't find TINKER_PATCH in patch meta file
      *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_TINKER_ID_NOT_EQUAL}             apk and patch's TINKER_PATCH value is not equal
      *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_RESOURCE_META_CORRUPTED}         resource meta file's format check fail
+     *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT}          some patch file type is not supported for current tinkerFlag
      */
     void onPatchPackageCheckFail(File patchFile, boolean isUpgradePatch, int errorCode);
 
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/TinkerPatchService.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/TinkerPatchService.java
index 75f254af..5afbdf35 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/TinkerPatchService.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/TinkerPatchService.java
@@ -149,14 +149,22 @@ protected void onHandleIntent(Intent intent) {
     }
 
     private void increasingPriority() {
+        if (Build.VERSION.SDK_INT > 24) {
+            TinkerLog.i(TAG, "for Android 7.1, we just ignore increasingPriority job");
+            return;
+        }
         TinkerLog.i(TAG, "try to increase patch process priority");
-        Notification notification = new Notification();
-        if (Build.VERSION.SDK_INT < 18) {
-            startForeground(notificationId, notification);
-        } else {
-            startForeground(notificationId, notification);
-            // start InnerService
-            startService(new Intent(this, InnerService.class));
+        try {
+            Notification notification = new Notification();
+            if (Build.VERSION.SDK_INT < 18) {
+                startForeground(notificationId, notification);
+            } else {
+                startForeground(notificationId, notification);
+                // start InnerService
+                startService(new Intent(this, InnerService.class));
+            }
+        } catch (Throwable e) {
+            TinkerLog.i(TAG, "try to increase patch process priority error:" + e);
         }
     }
 
@@ -170,7 +178,7 @@ public void onCreate() {
             super.onCreate();
             try {
                 startForeground(notificationId, new Notification());
-            } catch (NullPointerException e) {
+            } catch (Throwable e) {
                 TinkerLog.e(TAG, "InnerService set service for push exception:%s.", e);
             }
             // kill
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/Tinker.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/Tinker.java
index 137c5fc0..8e46e2e7 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/Tinker.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/Tinker.java
@@ -64,6 +64,7 @@
      * same with {@code TinkerApplication.tinkerLoadVerifyFlag}
      */
     final boolean       tinkerLoadVerifyFlag;
+
     /**
      * same with {@code TinkerApplication.tinkerFlags}
      */
@@ -245,6 +246,11 @@ public PatchListener getPatchListener() {
         return listener;
     }
 
+
+    public int getTinkerFlags() {
+        return tinkerFlags;
+    }
+
     /**
      * clean all patch files
      */
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/SystemClassLoaderAdder.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/SystemClassLoaderAdder.java
index 5c20b80f..6678afa3 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/SystemClassLoaderAdder.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/SystemClassLoaderAdder.java
@@ -70,11 +70,14 @@ public static void installDexes(Application application, PathClassLoader loader,
             } else {
                 V4.install(classLoader, files, dexOptDir);
             }
+            //install done
+            sPatchDexCount = files.size();
 
             if (!checkDexInstall(classLoader)) {
+                //reset patch dex
+                SystemClassLoaderAdder.uninstallPatchDex(classLoader);
                 throw new TinkerRuntimeException(ShareConstants.CHECK_DEX_INSTALL_FAIL);
             }
-            sPatchDexCount = files.size();
         }
     }
 
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerLoader.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerLoader.java
index b6f5776a..adfb88f7 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerLoader.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerLoader.java
@@ -152,9 +152,9 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, bo
 
         ShareSecurityCheck securityCheck = new ShareSecurityCheck(app);
 
-        int returnCode = ShareTinkerInternals.checkSignatureAndTinkerID(app, patchVersionFile, securityCheck);
-        if (returnCode != 0) {
-            Log.w(TAG, "tryLoadPatchFiles:checkSignatureAndTinkerID");
+        int returnCode = ShareTinkerInternals.checkTinkerPackage(app, tinkerFlag, patchVersionFile, securityCheck);
+        if (returnCode != ShareConstants.ERROR_PACKAGE_CHECK_OK) {
+            Log.w(TAG, "tryLoadPatchFiles:checkTinkerPackage");
             resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_PACKAGE_PATCH_CHECK, returnCode);
             ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_PACKAGE_CHECK_FAIL);
             return;
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java
index c21c327e..56f1c0f8 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java
@@ -23,29 +23,56 @@
 import android.util.Log;
 
 import com.tencent.tinker.loader.shareutil.ShareConstants;
+import com.tencent.tinker.loader.shareutil.ShareReflectUtil;
 
 import java.lang.ref.WeakReference;
 import java.lang.reflect.Field;
 import java.lang.reflect.Method;
 import java.util.Collection;
 import java.util.HashMap;
+import java.util.Map;
 
 import static android.os.Build.VERSION.SDK_INT;
 import static android.os.Build.VERSION_CODES.KITKAT;
 
 class TinkerResourcePatcher {
-    private static final String TAG = "Tinker.ResourcePatcher";
-    private static final String TEST_STRING_NAME  = "tinker_test_resource";
-    private static final String TEST_STRING_VALUE = "only use for test tinker resource: b";
+    private static final String TAG               = "Tinker.ResourcePatcher";
+    private static final String TEST_ASSETS_VALUE = "only_use_to_test_tinker_resource.txt";
+
     // original value
     private static Collection<WeakReference<Resources>> references;
     private static AssetManager newAssetManager          = null;
     private static Method       addAssetPathMethod       = null;
     private static Method       ensureStringBlocksMethod = null;
     private static Field        assetsFiled              = null;
-    private static Field        resourcesImplFiled      = null;
+    private static Field        resourcesImplFiled       = null;
+    private static Field        resDir                   = null;
+    private static Field        packagesFiled            = null;
+    private static Field        resourcePackagesFiled    = null;
 
     public static void isResourceCanPatch(Context context) throws Throwable {
+        //   - Replace mResDir to point to the external resource file instead of the .apk. This is
+        //     used as the asset path for new Resources objects.
+        //   - Set Application#mLoadedApk to the found LoadedApk instance
+
+        // Find the ActivityThread instance for the current thread
+        Class<?> activityThread = Class.forName("android.app.ActivityThread");
+        // API version 8 has PackageInfo, 10 has LoadedApk. 9, I don't know.
+        Class<?> loadedApkClass;
+        try {
+            loadedApkClass = Class.forName("android.app.LoadedApk");
+        } catch (ClassNotFoundException e) {
+            loadedApkClass = Class.forName("android.app.ActivityThread$PackageInfo");
+        }
+        Field mApplication = loadedApkClass.getDeclaredField("mApplication");
+        mApplication.setAccessible(true);
+        resDir = loadedApkClass.getDeclaredField("mResDir");
+        resDir.setAccessible(true);
+        packagesFiled = activityThread.getDeclaredField("mPackages");
+        packagesFiled.setAccessible(true);
+
+        resourcePackagesFiled = activityThread.getDeclaredField("mResourcePackages");
+        resourcePackagesFiled.setAccessible(true);
         /*
         (Note: the resource directory is *also* inserted into the loadedApk in
         monkeyPatchApplication)
@@ -79,7 +106,15 @@ public static void isResourceCanPatch(Context context) throws Throwable {
         */
         // Create a new AssetManager instance and point it to the resources installed under
         // /sdcard
-        newAssetManager = AssetManager.class.getConstructor().newInstance();
+        AssetManager assets = context.getAssets();
+        // Baidu os
+        if (assets.getClass().getName().equals("android.content.res.BaiduAssetManager")) {
+            Class baiduAssetManager = Class.forName("android.content.res.BaiduAssetManager");
+            newAssetManager = (AssetManager) baiduAssetManager.getConstructor().newInstance();
+        } else {
+            newAssetManager = AssetManager.class.getConstructor().newInstance();
+        }
+
         addAssetPathMethod = AssetManager.class.getDeclaredMethod("addAssetPath", String.class);
         addAssetPathMethod.setAccessible(true);
 
@@ -110,7 +145,6 @@ public static void isResourceCanPatch(Context context) throws Throwable {
                 references = (Collection<WeakReference<Resources>>) mResourceReferences.get(resourcesManager);
             }
         } else {
-            Class<?> activityThread = Class.forName("android.app.ActivityThread");
             Field fMActiveResources = activityThread.getDeclaredField("mActiveResources");
             fMActiveResources.setAccessible(true);
             Object thread = getActivityThread(context, activityThread);
@@ -137,10 +171,26 @@ public static void monkeyPatchExistingResources(Context context, String external
         if (externalResourceFile == null) {
             return;
         }
+        // Find the ActivityThread instance for the current thread
+        Class<?> activityThread = Class.forName("android.app.ActivityThread");
+        Object currentActivityThread = getActivityThread(context, activityThread);
+
+        for (Field field : new Field[]{packagesFiled, resourcePackagesFiled}) {
+            Object value = field.get(currentActivityThread);
 
+            for (Map.Entry<String, WeakReference<?>> entry
+                : ((Map<String, WeakReference<?>>) value).entrySet()) {
+                Object loadedApk = entry.getValue().get();
+                if (loadedApk == null) {
+                    continue;
+                }
+                if (externalResourceFile != null) {
+                    resDir.set(loadedApk, externalResourceFile);
+                }
+            }
+        }
         // Create a new AssetManager instance and point it to the resources installed under
         // /sdcard
-
         if (((Integer) addAssetPathMethod.invoke(newAssetManager, externalResourceFile)) == 0) {
             throw new IllegalStateException("Could not create new AssetManager");
         }
@@ -157,9 +207,10 @@ public static void monkeyPatchExistingResources(Context context, String external
                 try {
                     assetsFiled.set(resources, newAssetManager);
                 } catch (Throwable ignore) {
-                    //N
+                    // N
                     Object resourceImpl = resourcesImplFiled.get(resources);
-                    Field implAssets = resourceImpl.getClass().getDeclaredField("mAssets");
+                    // for Huawei HwResourcesImpl
+                    Field implAssets = ShareReflectUtil.findField(resourceImpl, "mAssets");
                     implAssets.setAccessible(true);
                     implAssets.set(resourceImpl, newAssetManager);
                 }
@@ -174,19 +225,16 @@ public static void monkeyPatchExistingResources(Context context, String external
     }
 
     private static boolean checkResUpdate(Context context) {
-        int testStringID = context.getResources().getIdentifier(TEST_STRING_NAME, "string", context.getPackageName());
-        if (testStringID > 0) {
-            String value = context.getString(testStringID);
-            Log.w(TAG, "checkResUpdate resource value:" + value);
-
-            if (!value.equals(TEST_STRING_VALUE)) {
-                return false;
-            }
-        } else  {
-            Log.e(TAG, "checkResUpdate resource id < 0 " + testStringID);
+        try {
+            Log.e(TAG, "checkResUpdate success, found test resource assets file " + TEST_ASSETS_VALUE);
+            context.getAssets().open(TEST_ASSETS_VALUE);
+        } catch (Throwable e) {
+            Log.e(TAG, "checkResUpdate failed, can't find test resource assets file " + TEST_ASSETS_VALUE + " e:" + e.getMessage());
+            return false;
         }
         return true;
     }
+
     private static Object getActivityThread(Context context,
                                             Class<?> activityThread) {
         try {
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareConstants.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareConstants.java
index aaa487cf..e3db652f 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareConstants.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareConstants.java
@@ -168,5 +168,5 @@
     public static final int ERROR_PACKAGE_CHECK_PATCH_TINKER_ID_NOT_FOUND = -6;
     public static final int ERROR_PACKAGE_CHECK_TINKER_ID_NOT_EQUAL       = -7;
     public static final int ERROR_PACKAGE_CHECK_RESOURCE_META_CORRUPTED   = -8;
-
+    public static final int ERROR_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT    = -9;
 }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java
index 3bbfec48..aba789cc 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java
@@ -57,6 +57,21 @@ public static boolean isNullOrNil(final String object) {
         return false;
     }
 
+    /**
+     * thinker package check
+     * @param context
+     * @param tinkerFlag
+     * @param patchFile
+     * @param securityCheck
+     * @return
+     */
+    public static int checkTinkerPackage(Context context, int tinkerFlag, File patchFile, ShareSecurityCheck securityCheck) {
+        int returnCode = checkSignatureAndTinkerID(context, patchFile, securityCheck);
+        if (returnCode == ShareConstants.ERROR_PACKAGE_CHECK_OK) {
+            returnCode = checkPackageAndTinkerFlag(securityCheck, tinkerFlag);
+        }
+        return returnCode;
+    }
     /**
      * check patch file signature and TINKER_ID
      *
@@ -93,6 +108,25 @@ public static int checkSignatureAndTinkerID(Context context, File patchFile, Sha
 
 
     public static int checkPackageAndTinkerFlag(ShareSecurityCheck securityCheck, int tinkerFlag) {
+        if (isTinkerEnabledAll(tinkerFlag)) {
+            return ShareConstants.ERROR_PACKAGE_CHECK_OK;
+        }
+        HashMap<String, String> metaContentMap = securityCheck.getMetaContentMap();
+        //check dex
+        boolean dexEnable = isTinkerEnabledForDex(tinkerFlag);
+        if (!dexEnable && metaContentMap.containsKey(ShareConstants.DEX_META_FILE)) {
+            return ShareConstants.ERROR_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT;
+        }
+        //check native library
+        boolean nativeEnable = isTinkerEnabledForNativeLib(tinkerFlag);
+        if (!nativeEnable && metaContentMap.containsKey(ShareConstants.SO_META_FILE)) {
+            return ShareConstants.ERROR_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT;
+        }
+        //check resource
+        boolean resEnable = isTinkerEnabledForResource(tinkerFlag);
+        if (!resEnable && metaContentMap.containsKey(ShareConstants.RES_META_FILE)) {
+            return ShareConstants.ERROR_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT;
+        }
 
         return ShareConstants.ERROR_PACKAGE_CHECK_OK;
     }
diff --git a/tinker-android/tinker-android-loader/src/main/res/values/strings.xml b/tinker-android/tinker-android-loader/src/main/res/values/strings.xml
deleted file mode 100644
index 4c563702..00000000
--- a/tinker-android/tinker-android-loader/src/main/res/values/strings.xml
+++ /dev/null
@@ -1,3 +0,0 @@
-<resources>
-    <string name="tinker_test_resource">only use for test tinker resource: a</string>
-</resources>
diff --git a/tinker-build/tinker-patch-cli/tool_output/tinker_config.xml b/tinker-build/tinker-patch-cli/tool_output/tinker_config.xml
index f62489f0..de0c6c99 100644
--- a/tinker-build/tinker-patch-cli/tool_output/tinker_config.xml
+++ b/tinker-build/tinker-patch-cli/tool_output/tinker_config.xml
@@ -82,6 +82,12 @@
         <!--or TinkerLoadResult.getPackageConfigByName-->
         <!--you must add TINKER_ID with the old apk manifest's meta TINKER_ID value-->
         <!--other config files (such as patchMessage below)is not necessary-->
+
+        <!--For sample project or any projects that copy SamplePatchListener directory,-->
+        <!--platform config field is necessary, or an error code ERROR_PATCH_CONDITION_NOT_SATISFIED(-10)-->
+        <!--will be thrown.-->
+        <configField name="platform" value="all"/>
+
         <configField name="patchMessage" value="classes.dex"/>
     </issue>
 
diff --git a/tinker-build/tinker-patch-cli/tool_output/tinker_proguard.pro b/tinker-build/tinker-patch-cli/tool_output/tinker_proguard.pro
index 23c74455..e4ef8030 100644
--- a/tinker-build/tinker-patch-cli/tool_output/tinker_proguard.pro
+++ b/tinker-build/tinker-patch-cli/tool_output/tinker_proguard.pro
@@ -26,6 +26,6 @@
 }
 
 #your dex.loader pattern here
--keep class com.tencent.tinker.loader.*
+-keep class com.tencent.tinker.loader.**
 -keep class tinker.sample.android.app.SampleApplication
 
diff --git a/tinker-build/tinker-patch-gradle-plugin/build.gradle b/tinker-build/tinker-patch-gradle-plugin/build.gradle
index c027fdaa..fa4fb4e2 100644
--- a/tinker-build/tinker-patch-gradle-plugin/build.gradle
+++ b/tinker-build/tinker-patch-gradle-plugin/build.gradle
@@ -10,7 +10,7 @@ dependencies {
 //    compile fileTree(dir: 'libs', include: ['*.jar'])
     compile project(':tinker-build:tinker-patch-lib')
     compile 'com.google.gradle:osdetector-gradle-plugin:1.2.1'
-    compile 'com.android.tools.build:gradle-api:2.2.0'
+    compile 'com.android.tools.build:gradle:2.1.0'
 }
 
 repositories {
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/TinkerPatchPlugin.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/TinkerPatchPlugin.groovy
index 7df0a589..8f539a16 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/TinkerPatchPlugin.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/TinkerPatchPlugin.groovy
@@ -24,6 +24,8 @@ import com.tencent.tinker.build.util.TypedValue
 import org.gradle.api.GradleException
 import org.gradle.api.Plugin
 import org.gradle.api.Project
+import org.gradle.api.UnknownTaskException
+
 /**
  * Registers the plugin's tasks.
  *
@@ -62,6 +64,12 @@ class TinkerPatchPlugin implements Plugin<Project> {
             android.packagingOptions.exclude("TinkerAnnoApplication.tmpl")
             //open jumboMode
             android.dexOptions.jumboMode = true
+            //close preDexLibraries
+            try {
+                android.dexOptions.preDexLibraries = false
+            } catch (Throwable e) {
+                //no preDexLibraries field, just continue
+            }
 
             project.logger.error("----------------------tinker build warning ------------------------------------")
             project.logger.error("tinker will change your build configs:")
@@ -97,6 +105,19 @@ class TinkerPatchPlugin implements Plugin<Project> {
                 def variantOutput = variant.outputs.first()
                 def variantName = variant.name.capitalize()
 
+                try {
+                    def instantRunTask = project.tasks.getByName("transformClassesWithInstantRunFor${variantName}")
+                    if (instantRunTask) {
+                        throw new GradleException(
+                                "Tinker does not support instant run mode, please trigger build"
+                                        + " by assemble${variantName} or disable instant run"
+                                        + " in 'File->Settings...'."
+                        )
+                    }
+                } catch (UnknownTaskException e) {
+                    // Not in instant run mode, continue.
+                }
+
                 TinkerPatchSchemaTask tinkerPatchBuildTask = project.tasks.create("tinkerPatch${variantName}", TinkerPatchSchemaTask)
                 tinkerPatchBuildTask.dependsOn variant.assemble
 
@@ -117,6 +138,14 @@ class TinkerPatchPlugin implements Plugin<Project> {
 
                 variantOutput.processResources.dependsOn manifestTask
 
+                //resource id
+                TinkerResourceIdTask applyResourceTask = project.tasks.create("tinkerProcess${variantName}ResourceId", TinkerResourceIdTask)
+                applyResourceTask.resDir = variantOutput.processResources.resDir
+                //let applyResourceTask run after manifestTask
+                applyResourceTask.mustRunAfter manifestTask
+
+                variantOutput.processResources.dependsOn applyResourceTask
+
                 // Add this proguard settings file to the list
                 boolean proguardEnable = variant.getBuildType().buildType.minifyEnabled
 
@@ -134,14 +163,7 @@ class TinkerPatchPlugin implements Plugin<Project> {
                     multidexConfigTask.applicationVariant = variant
                     variantOutput.packageApplication.dependsOn multidexConfigTask
                 }
-//                if (tempResourceFile != null && tempResourceFile.exists() && tempResourceFile.isFile()) {
-                    TinkerResourceIdTask applyResourceTask = project.tasks.create("tinkerProcess${variantName}ResourceId", TinkerResourceIdTask)
-                    applyResourceTask.resDir = variantOutput.processResources.resDir
-                    variantOutput.processResources.dependsOn applyResourceTask
-//                }
-//                else {
-//                    project.logger.error("apply resource mapping file ${resourceMappingFile} is not exist, just ignore")
-//                }
+
             }
         }
 
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerManifestTask.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerManifestTask.groovy
index 0b60c831..50af6687 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerManifestTask.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerManifestTask.groovy
@@ -46,7 +46,8 @@ public class TinkerManifestTask extends DefaultTask {
         project.logger.error("tinker add ${tinkerValue} to your AndroidManifest.xml ${manifestPath}")
 
         def ns = new Namespace("http://schemas.android.com/apk/res/android", "android")
-        def xml = new XmlParser().parse(manifestPath)
+
+        def xml = new XmlParser().parse(new InputStreamReader(new FileInputStream(manifestPath), "utf-8"))
 
         def application = xml.application[0]
         if (application) {
@@ -63,8 +64,7 @@ public class TinkerManifestTask extends DefaultTask {
             application.appendNode('meta-data', [(ns.name): TINKER_ID, (ns.value): tinkerValue])
 
             // Write the manifest file
-            def writer = new FileWriter(manifestPath)
-            def printer = new XmlNodePrinter(new PrintWriter(writer))
+            def printer = new XmlNodePrinter(new PrintWriter(manifestPath, "utf-8"))
             printer.preserveWhitespace = true
             printer.print(xml)
         }
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerMultidexConfigTask.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerMultidexConfigTask.groovy
index c52447dd..edc22e81 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerMultidexConfigTask.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerMultidexConfigTask.groovy
@@ -63,16 +63,6 @@ public class TinkerMultidexConfigTask extends DefaultTask {
         fr.write(MULTIDEX_CONFIG_SETTINGS)
         fr.write("\n")
 
-        // Write additional rules to keep auxiliary class in primary dex.
-        if (project.tinkerPatch.dex.usePreGeneratedPatchDex) {
-            final String additionalRules =
-                    "-keep class ${AuxiliaryClassInjector.AUXILIARY_CLASSNAME} {\n" +
-                            '    *;\n' +
-                            '}\n'
-            fr.write(additionalRules)
-            fr.write('\n')
-        }
-
         //unlike proguard, if loader endwith *, we must change to **
         fr.write("#your dex.loader patterns here\n")
         Iterable<String> loader = project.extensions.tinkerPatch.dex.loader
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerProguardConfigTask.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerProguardConfigTask.groovy
index 4283b7b3..8528b265 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerProguardConfigTask.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerProguardConfigTask.groovy
@@ -32,6 +32,7 @@ public class TinkerProguardConfigTask extends DefaultTask {
     static final String PROGUARD_CONFIG_SETTINGS =
             "-keepattributes *Annotation* \n" +
                     "-dontwarn com.tencent.tinker.anno.AnnotationProcessor \n" +
+                    "-dontwarn ${AuxiliaryClassInjector.NOT_EXISTS_CLASSNAME} \n" +
                     "-keep @com.tencent.tinker.anno.DefaultLifeCycle public class *\n" +
                     "-keep public class * extends android.app.Application {\n" +
                     "    *;\n" +
@@ -88,16 +89,16 @@ public class TinkerProguardConfigTask extends DefaultTask {
 
         fr.write(PROGUARD_CONFIG_SETTINGS)
 
-        // Write additional rules to keep auxiliary class, <init> and <clinit>
+        // Write additional rules to keep <init> and <clinit>
         if (project.tinkerPatch.dex.usePreGeneratedPatchDex) {
             def additionalKeptRules =
-                    "-dontwarn ${AuxiliaryClassInjector.AUXILIARY_CLASSNAME} \n" +
+                            "-keep class ${AuxiliaryClassInjector.NOT_EXISTS_CLASSNAME} { \n" +
+                            '    *; \n' +
+                            '}\n' +
+                            '\n' +
                             '-keepclassmembers class * { \n' +
                             '    <init>(...); \n' +
                             '    static void <clinit>(...); \n' +
-                            '}\n' +
-                            "-keep class ${AuxiliaryClassInjector.AUXILIARY_CLASSNAME} {\n" +
-                            '    *;\n' +
                             '}\n'
             fr.write(additionalKeptRules)
             fr.write('\n')
@@ -107,6 +108,9 @@ public class TinkerProguardConfigTask extends DefaultTask {
         //they will removed when apply
         Iterable<String> loader = project.extensions.tinkerPatch.dex.loader
         for (String pattern : loader) {
+            if (pattern.endsWith("*") && !pattern.endsWith("**")) {
+                pattern += "*"
+            }
             fr.write("-keep class " + pattern)
             fr.write("\n")
         }
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerResourceIdTask.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerResourceIdTask.groovy
index 30a12c12..ba6c2c75 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerResourceIdTask.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerResourceIdTask.groovy
@@ -23,7 +23,6 @@ import com.tencent.tinker.build.aapt.RDotTxtEntry
 import com.tencent.tinker.build.gradle.TinkerPatchPlugin
 import com.tencent.tinker.build.util.FileOperation
 import org.gradle.api.DefaultTask
-import org.gradle.api.Project
 import org.gradle.api.tasks.TaskAction
 
 /**
@@ -43,25 +42,24 @@ public class TinkerResourceIdTask extends DefaultTask {
 
     @TaskAction
     def applyResourceId() {
+        String resourceMappingFile = project.extensions.tinkerPatch.buildConfig.applyResourceMapping
+
         // Parse the public.xml and ids.xml
+        if (!FileOperation.isLegalFile(resourceMappingFile)) {
+            project.logger.error("apply resource mapping file ${resourceMappingFile} is illegal, just ignore")
+            return
+        }
         String idsXml = resDir + "/values/ids.xml";
         String publicXml = resDir + "/values/public.xml";
         FileOperation.deleteFile(idsXml);
         FileOperation.deleteFile(publicXml);
         List<String> resourceDirectoryList = new ArrayList<String>()
         resourceDirectoryList.add(resDir)
-        Map<RDotTxtEntry.RType, Set<RDotTxtEntry>> rTypeResourceMap = null
 
-        String resourceMappingFile = project.extensions.tinkerPatch.buildConfig.applyResourceMapping
+        project.logger.error("we build ${project.getName()} apk with apply resource mapping file ${resourceMappingFile}")
+        project.extensions.tinkerPatch.buildConfig.usingResourceMapping = true
+        Map<RDotTxtEntry.RType, Set<RDotTxtEntry>> rTypeResourceMap = PatchUtil.readRTxt(resourceMappingFile)
 
-        if (FileOperation.isLegalFile(resourceMappingFile)) {
-            project.logger.error("we build ${project.getName()} apk with apply resource mapping file ${resourceMappingFile}")
-            project.extensions.tinkerPatch.buildConfig.usingResourceMapping = true
-            rTypeResourceMap = PatchUtil.readRTxt(resourceMappingFile);
-        } else {
-            project.logger.error("apply resource mapping file ${resourceMappingFile} is illegal, just ignore")
-            return
-        }
         AaptResourceCollector aaptResourceCollector = AaptUtil.collectResource(resourceDirectoryList, rTypeResourceMap)
         PatchUtil.generatePublicResourceXml(aaptResourceCollector, idsXml, publicXml)
         File publicFile = new File(publicXml)
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/transform/AuxiliaryInjectTransform.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/transform/AuxiliaryInjectTransform.groovy
index 8507e4e1..c1a929b0 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/transform/AuxiliaryInjectTransform.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/transform/AuxiliaryInjectTransform.groovy
@@ -19,21 +19,15 @@ package com.tencent.tinker.build.gradle.transform
 import com.android.build.api.transform.*
 import com.google.common.collect.ImmutableSet
 import com.google.common.io.Files
-import com.tencent.tinker.build.auxiliaryclass.AuxiliaryClassGenerator
 import com.tencent.tinker.build.auxiliaryclass.AuxiliaryClassInjector
 import com.tencent.tinker.build.auxiliaryclass.AuxiliaryClassInjector.ProcessJarCallback
 import com.tencent.tinker.build.util.MD5
-import com.tencent.tinker.commons.ziputil.Streams
 import groovy.io.FileType
+import groovy.xml.Namespace
 import org.gradle.api.Project
 
-import java.lang.reflect.Constructor
-import java.util.zip.ZipEntry
-import java.util.zip.ZipInputStream
-import java.util.zip.ZipOutputStream
-
 /**
- * Transform for calling AuxiliaryClassGenerator and AuxiliaryClassInjector.
+ * Transform for calling AuxiliaryClassInjector.
  *
  * @author tangyinsheng
  */
@@ -41,7 +35,6 @@ public class AuxiliaryInjectTransform extends Transform {
     private static final String TRANSFORM_NAME = 'AuxiliaryInject'
 
     private final Project project
-    private final String auxiliaryClassPathName
 
     private boolean isEnabled = false
 
@@ -50,16 +43,14 @@ public class AuxiliaryInjectTransform extends Transform {
     /* ****** Variant related parameters start ****** */
 
     boolean isInitialized = false
-    def manifestFile
-    def appClassName
-    def appClassPathName
+    def manifestFile = null
+    def appClassName = ''
+    def appClassPathName = ''
 
     /* ******  Variant related parameters end  ****** */
 
     public AuxiliaryInjectTransform(Project project) {
         this.project = project
-        this.auxiliaryClassPathName =
-                AuxiliaryClassInjector.AUXILIARY_CLASSNAME.replace('.', '/') + '.class'
 
         project.afterEvaluate {
             this.isEnabled = project.tinkerPatch.dex.usePreGeneratedPatchDex
@@ -82,8 +73,8 @@ public class AuxiliaryInjectTransform extends Transform {
     Set<QualifiedContent.Scope> getScopes() {
         return ImmutableSet.of(
                 QualifiedContent.Scope.PROJECT,
-                QualifiedContent.Scope.PROJECT_LOCAL_DEPS,
                 QualifiedContent.Scope.SUB_PROJECTS,
+                QualifiedContent.Scope.PROJECT_LOCAL_DEPS,
                 QualifiedContent.Scope.SUB_PROJECTS_LOCAL_DEPS,
                 QualifiedContent.Scope.EXTERNAL_LIBRARIES
         )
@@ -132,11 +123,17 @@ public class AuxiliaryInjectTransform extends Transform {
         }
 
         // Get application classname from manifest file.
-        def parsedManifest = new XmlParser().parse(this.manifestFile)
-        def androidTag = new groovy.xml.Namespace(
-                "http://schemas.android.com/apk/res/android", 'android')
-        this.appClassName = parsedManifest.application[0].attribute(androidTag.name)
-        this.appClassPathName = this.appClassName.replace('.', '/') + '.class'
+        if (this.manifestFile != null) {
+            def parsedManifest = new XmlParser().parse(
+                    new InputStreamReader(new FileInputStream(this.manifestFile), "utf-8"))
+            def androidTag = new Namespace(
+                    'http://schemas.android.com/apk/res/android', 'android')
+            this.appClassName = parsedManifest.application[0].attribute(androidTag.name)
+
+            if (this.appClassName != null && this.appClassName.length() > 0) {
+                this.appClassPathName = this.appClassName.replace('.', '/') + '.class'
+            }
+        }
 
         this.isInitialized = true
     }
@@ -163,9 +160,6 @@ public class AuxiliaryInjectTransform extends Transform {
             printMsgLog("PreGeneratedPatchDex mode is disabled, skip transforming.")
         }
 
-        // Auxiliary class may be exist if user create it manually in his project.
-        boolean isAuxiliaryClassExists = false
-
         if (!dirInputs.isEmpty() || !jarInputs.isEmpty()) {
             File dirOutput = transformInvocation.outputProvider.getContentLocation(
                     "classes", getOutputTypes(), getScopes(), Format.DIRECTORY)
@@ -195,8 +189,8 @@ public class AuxiliaryInjectTransform extends Transform {
                                         return // continue.
                                     }
 
-                                    // If disabled, skip all classes.
-                                    if (!this.isEnabled) {
+                                    // If disabled or not a class file, skip transforming them.
+                                    if (!this.isEnabled || !fileInput.getName().endsWith('.class')) {
                                         Files.copy(fileInput, fileOutput)
                                     } else {
                                         // Skip application class.
@@ -204,11 +198,6 @@ public class AuxiliaryInjectTransform extends Transform {
                                             printWarnLog('Skipping Application class: %s',
                                                     relativeInputClassPath)
                                             Files.copy(fileInput, fileOutput)
-                                        } else
-                                        // Skip and mark auxiliary class.
-                                        if (relativeInputClassPath.equals(this.auxiliaryClassPathName)) {
-                                            isAuxiliaryClassExists = true
-                                            Files.copy(fileInput, fileOutput)
                                         } else {
                                             printMsgLog('Processing %s file %s',
                                                     fileStatus,
@@ -239,7 +228,7 @@ public class AuxiliaryInjectTransform extends Transform {
                             dirOutput.deleteDir()
                         }
 
-                        dirInput.file.traverse(type: FileType.FILES, nameFilter: ~/.*\.class$/) { fileInput ->
+                        dirInput.file.traverse(type: FileType.FILES) { fileInput ->
                             File fileOutput = new File(fileInput.getAbsolutePath().replace(dirInput.file.getAbsolutePath(), dirOutput.getAbsolutePath()))
                             if (!fileOutput.exists()) {
                                 fileOutput.getParentFile().mkdirs()
@@ -248,8 +237,8 @@ public class AuxiliaryInjectTransform extends Transform {
                                     dirInput.file.toPath().relativize(fileInput.toPath())
                                             .toString().replace('\\', '/')
 
-                            // If disabled, skip all classes.
-                            if (!this.isEnabled) {
+                            // If disabled or not a class file, skip transforming them.
+                            if (!this.isEnabled || !fileInput.getName().endsWith('.class')) {
                                 Files.copy(fileInput, fileOutput)
                             } else {
                                 // Skip application class.
@@ -257,11 +246,6 @@ public class AuxiliaryInjectTransform extends Transform {
                                     printWarnLog('Skipping Application class: %s',
                                             relativeInputClassPath)
                                     Files.copy(fileInput, fileOutput)
-                                } else
-                                // Skip and mark auxiliary class.
-                                if (relativeInputClassPath.equals(this.auxiliaryClassPathName)) {
-                                    isAuxiliaryClassExists = true
-                                    Files.copy(fileInput, fileOutput)
                                 } else {
                                     printMsgLog('Processing %s file %s',
                                             Status.ADDED,
@@ -275,26 +259,13 @@ public class AuxiliaryInjectTransform extends Transform {
             }
 
             if (!jarInputs.isEmpty()) {
-                File jarOutput = transformInvocation.outputProvider.getContentLocation(
-                        "combined", getOutputTypes(), getScopes(), Format.JAR
-                )
-                if (!jarOutput.exists()) {
-                    jarOutput.getParentFile().mkdirs()
-                }
-
-                File tempJarOutputDir = new File(transformInvocation.context.temporaryDir, "combined-jars")
-                if (!tempJarOutputDir.exists()) {
-                    tempJarOutputDir.mkdirs()
-                }
-
-                List<File> jarsToMerge = new ArrayList<>()
-
                 jarInputs.each { jarInput ->
-                    File fileInput = jarInput.file
-                    File fileOutput = new File(tempJarOutputDir,
-                            getUniqueHashName(fileInput))
-                    if (!fileOutput.exists()) {
-                        fileOutput.getParentFile().mkdirs()
+                    File jarInputFile = jarInput.file
+                    File jarOutputFile = transformInvocation.outputProvider.getContentLocation(
+                            getUniqueHashName(jarInputFile), getOutputTypes(), getScopes(), Format.JAR
+                    )
+                    if (!jarOutputFile.exists()) {
+                        jarOutputFile.getParentFile().mkdirs()
                     }
 
                     switch (jarInput.status) {
@@ -308,60 +279,39 @@ public class AuxiliaryInjectTransform extends Transform {
                             if (this.isEnabled) {
                                 printMsgLog('Processing %s file %s',
                                         transformInvocation.incremental ? jarInput.status : Status.ADDED,
-                                        tempJarOutputDir.toPath().relativize(fileOutput.toPath()).toString())
+                                        jarInputFile)
                             }
 
-                            AuxiliaryClassInjector.processJar(fileInput, fileOutput, new ProcessJarCallback() {
+                            AuxiliaryClassInjector.processJar(jarInputFile, jarOutputFile, new ProcessJarCallback() {
                                 @Override
                                 boolean onProcessClassEntry(String entryName) {
-                                    // If disabled, skip all classes.
-                                    if (!this.isEnabled) {
+                                    // If disabled or not a class file, skip transforming them.
+                                    if (!this.isEnabled || !entryName.endsWith('.class')) {
                                         return false
                                     } else {
                                         // Skip application class.
                                         if (entryName.equals(AuxiliaryInjectTransform.this.appClassPathName)) {
                                             return false
-                                        } else
-                                        // Skip and mark auxiliary class.
-                                        if (entryName.equals(AuxiliaryInjectTransform.this.auxiliaryClassPathName)) {
-                                            isAuxiliaryClassExists = true
-                                            return false
                                         } else {
                                             return true;
                                         }
                                     }
                                 }
                             })
-                            jarsToMerge.add(fileOutput)
                             break
                         case Status.REMOVED:
                             // Print log if it's enabled only.
                             if (this.isEnabled) {
                                 printMsgLog('Removing %s file %s from result.', fileStatus,
-                                        tempJarOutputDir.toPath().relativize(fileOutput.toPath()).toString())
+                                        jarOutputFile)
                             }
 
-                            if (fileOutput.exists()) {
-                                fileOutput.delete()
+                            if (jarOutputFile.exists()) {
+                                jarOutputFile.delete()
                             }
                             break
                     }
                 }
-
-                mergeJars(jarsToMerge, jarOutput)
-            }
-
-            if (this.isEnabled) {
-                if (!isAuxiliaryClassExists) {
-                    printMsgLog('Generating auxiliary class %s.', this.auxiliaryClassPathName)
-                    AuxiliaryClassGenerator.generateAuxiliaryClass(
-                            dirOutput, AuxiliaryClassInjector.AUXILIARY_CLASSNAME)
-                } else {
-                    printWarnLog(
-                            'Found auxiliary class %s in your source codes, skip generating.',
-                            this.auxiliaryClassPathName
-                    )
-                }
             }
         }
     }
@@ -376,44 +326,7 @@ public class AuxiliaryInjectTransform extends Transform {
         final int extSepPos = fileInputName.lastIndexOf('.')
         final String fileInputNamePrefix =
                 (extSepPos >= 0 ? fileInputName.substring(0, extSepPos) : fileInputName)
-        final String fileInputNameSurfix =
-                (extSepPos >= 0 ? fileInputName.substring(extSepPos) : '')
-        return fileInputNamePrefix + '_' + pathMD5 + fileInputNameSurfix
-    }
-
-    private void mergeJars(Collection<File> jarsToMerge, File jarOutput) {
-        if (jarsToMerge == null || jarsToMerge.size() == 0) {
-            return
-        }
-
-        Set<String> addedEntries = new HashSet<>()
-        ZipOutputStream zos = null
-        try {
-            zos = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(jarOutput)))
-            jarsToMerge.each { jarInput ->
-                ZipInputStream zis = null
-                try {
-                    zis = new ZipInputStream(new BufferedInputStream(new FileInputStream(jarInput)))
-                    ZipEntry entryIn = null
-                    while ((entryIn = zis.getNextEntry()) != null) {
-                        final String entryName = entryIn.getName()
-                        if (!addedEntries.contains(entryName)) {
-                            addedEntries.add(entryName)
-                            ZipEntry entryOut = new ZipEntry(entryIn.getName())
-                            zos.putNextEntry(entryOut)
-                            if (!entryIn.isDirectory()) {
-                                Streams.copy(zis, zos)
-                            }
-                            zos.closeEntry()
-                        }
-                    }
-                } finally {
-                    closeQuietly(zis)
-                }
-            }
-        } finally {
-            closeQuietly(zos)
-        }
+        return fileInputNamePrefix + '_' + pathMD5
     }
 
     private void printMsgLog(String fmt, Object... vals) {
@@ -427,15 +340,5 @@ public class AuxiliaryInjectTransform extends Transform {
         this.project.logger.warn("[{}] {}", title,
                 (vals == null || vals.length == 0 ? fmt : String.format(fmt, vals)))
     }
-
-    private void closeQuietly(Closeable target) {
-        if (target != null) {
-            try {
-                target.close()
-            } catch (Exception e) {
-                // Ignored.
-            }
-        }
-    }
 }
 
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptResourceCollector.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptResourceCollector.java
index 97bc68c4..2682965c 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptResourceCollector.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptResourceCollector.java
@@ -38,7 +38,7 @@
     private final Map<RType, Set<RDotTxtEntry>>                   rTypeResourceMap;
     private final Map<RType, Set<RDotTxtEntry>>                   rTypeIncreaseResourceMap;
     private final Map<String, Set<String>>                        duplicateResourceMap;
-    private final Map<String, String>                             sanitizeNameMap;
+    private final Map<RType, HashMap<String, String>>             sanitizeTypeMap;
     private final Set<String>                                     ignoreIdSet;
     private       int                                             currentTypeId;
 
@@ -50,7 +50,7 @@ public AaptResourceCollector() {
         this.rTypeResourceMap = new HashMap<RType, Set<RDotTxtEntry>>();
         this.rTypeIncreaseResourceMap = new HashMap<RType, Set<RDotTxtEntry>>();
         this.duplicateResourceMap = new HashMap<String, Set<String>>();
-        this.sanitizeNameMap = new HashMap<String, String>();
+        this.sanitizeTypeMap = new HashMap<RType, HashMap<String, String>>();
         this.originalResourceMap = new HashMap<RDotTxtEntry, RDotTxtEntry>();
         this.ignoreIdSet = new HashSet<String>();
         //attr type must 1
@@ -260,9 +260,16 @@ void addRTypeResourceName(RType rType, String resourceName, String resourceValue
         }
     }
 
-    void putSanitizeName(String sanitizeName, String rawName) {
-        if (!this.sanitizeNameMap.containsKey(sanitizeName)) {
-            this.sanitizeNameMap.put(sanitizeName, rawName);
+    void putSanitizeName(RType rType, String sanitizeName, String rawName) {
+        HashMap<String, String> sanitizeNameMap;
+        if (!sanitizeTypeMap.containsKey(rType)) {
+            sanitizeNameMap = new HashMap<>();
+            sanitizeTypeMap.put(rType, sanitizeNameMap);
+        } else {
+            sanitizeNameMap = sanitizeTypeMap.get(rType);
+        }
+        if (!sanitizeNameMap.containsKey(sanitizeName)) {
+            sanitizeNameMap.put(sanitizeName, rawName);
         }
     }
 
@@ -272,8 +279,11 @@ void putSanitizeName(String sanitizeName, String rawName) {
      * @param sanitizeName
      * @return String
      */
-    public String getRawName(String sanitizeName) {
-        return this.sanitizeNameMap.get(sanitizeName);
+    public String getRawName(RType rType, String sanitizeName) {
+        if (!sanitizeTypeMap.containsKey(rType)) {
+            return null;
+        }
+        return this.sanitizeTypeMap.get(rType).get(sanitizeName);
     }
 
     /**
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptUtil.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptUtil.java
index 9dec2aaa..8e058f76 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptUtil.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptUtil.java
@@ -284,12 +284,12 @@ public static void processXmlFile(String xmlFullFilename, List<RDotTxtEntry> ref
 //if(!resourceCollector.isContainResource(rType, IdType.INT, sanitizeName(resourceCollector, name))){
 //throw new AaptUtilException("Not found reference '" + resourceName + "' in '" + xmlFullFilename + "'");
 //}
-            references.add(new FakeRDotTxtEntry(IdType.INT, rType, sanitizeName(resourceCollector, name)));
+            references.add(new FakeRDotTxtEntry(IdType.INT, rType, sanitizeName(rType, resourceCollector, name)));
         }
     }
 
-    private static void addToResourceCollector(AaptResourceCollector resourceCollector, com.tencent.tinker.build.aapt.ResourceDirectory resourceDirectory, Node node, RType rType, String resourceValue) {
-        String resourceName = sanitizeName(resourceCollector, extractNameAttribute(node));
+    private static void addToResourceCollector(AaptResourceCollector resourceCollector, ResourceDirectory resourceDirectory, Node node, RType rType, String resourceValue) {
+        String resourceName = sanitizeName(rType, resourceCollector, extractNameAttribute(node));
         resourceCollector.addRTypeResourceName(rType, resourceName, resourceValue, resourceDirectory);
         if (rType.equals(RType.STYLEABLE)) {
 
@@ -300,7 +300,7 @@ private static void addToResourceCollector(AaptResourceCollector resourceCollect
                 }
 
                 String rawAttrName = extractNameAttribute(attrNode);
-                String attrName = sanitizeName(resourceCollector, rawAttrName);
+                String attrName = sanitizeName(rType, resourceCollector, rawAttrName);
                 resourceCollector.addResource(RType.STYLEABLE, IdType.INT, String.format("%s_%s", resourceName, attrName), Integer.toString(count++));
 
                 if (!rawAttrName.startsWith("android:")) {
@@ -315,9 +315,9 @@ private static void addToResourceCollector(AaptResourceCollector resourceCollect
         }
     }
 
-    private static String sanitizeName(AaptResourceCollector resourceCollector, String rawName) {
+    private static String sanitizeName(RType rType, AaptResourceCollector resourceCollector, String rawName) {
         String sanitizeName = rawName.replaceAll("[.:]", "_");
-        resourceCollector.putSanitizeName(sanitizeName, rawName);
+        resourceCollector.putSanitizeName(rType, sanitizeName, rawName);
         return sanitizeName;
     }
 
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/PatchUtil.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/PatchUtil.java
index 6f4a0cc1..af195a50 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/PatchUtil.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/PatchUtil.java
@@ -117,7 +117,7 @@ public static void generatePublicResourceXml(AaptResourceCollector aaptResourceC
                     Set<RDotTxtEntry> set = entry.getValue();
                     for (RDotTxtEntry rDotTxtEntry : set) {
 //                        if (rType.equals(RType.STYLE)) {
-                            String rawName = aaptResourceCollector.getRawName(rDotTxtEntry.name);
+                            String rawName = aaptResourceCollector.getRawName(rType, rDotTxtEntry.name);
                             if (StringUtil.isBlank(rawName)) {
 //                                System.err.println("Blank?" + rDotTxtEntry.name);
                                 rawName = rDotTxtEntry.name;
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/apkparser/AndroidParser.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/apkparser/AndroidParser.java
index af9f0010..b417847d 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/apkparser/AndroidParser.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/apkparser/AndroidParser.java
@@ -80,6 +80,10 @@ public static void editResourceTableString(String from, String to, File originFi
         if (from == null || to == null) {
             return;
         }
+        if (!originFile.exists()) {
+            throw new RuntimeException("origin resources.arsc is not exist, path:" + originFile.getPath());
+        }
+
         if (from.length() != to.length()) {
             throw new RuntimeException("only support the same string length now!");
         }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/auxiliaryclass/AuxiliaryClassGenerator.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/auxiliaryclass/AuxiliaryClassGenerator.java
deleted file mode 100644
index f19c2c69..00000000
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/auxiliaryclass/AuxiliaryClassGenerator.java
+++ /dev/null
@@ -1,130 +0,0 @@
-/*
- * Tencent is pleased to support the open source community by making Tinker available.
- *
- * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
- *
- * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- *
- * https://opensource.org/licenses/BSD-3-Clause
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is
- * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
- * either express or implied. See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.tencent.tinker.build.auxiliaryclass;
-
-import org.objectweb.asm.ClassWriter;
-import org.objectweb.asm.MethodVisitor;
-import org.objectweb.asm.Opcodes;
-
-import java.io.BufferedOutputStream;
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.OutputStream;
-import java.util.regex.Pattern;
-
-/**
- * Created by tangyinsheng on 2016/10/13.
- */
-
-public final class AuxiliaryClassGenerator {
-    private static final String JAVA_IDENTIFIER_PATTERN_STR =
-            "(?:\\p{javaJavaIdentifierStart}\\p{javaJavaIdentifierPart}*)";
-
-    private static final String JAVA_FULL_CLASSNAME_PATTERN_STR =
-            String.format("(%s(?:\\.%s)*)", JAVA_IDENTIFIER_PATTERN_STR,
-                    JAVA_IDENTIFIER_PATTERN_STR);
-
-    private static final Pattern JAVA_FULL_CLASSNAME_PATTERN =
-            Pattern.compile(JAVA_FULL_CLASSNAME_PATTERN_STR);
-
-    public static void generateAuxiliaryClass(File dirOutput, String dotClassName) throws IOException {
-        if (!JAVA_FULL_CLASSNAME_PATTERN.matcher(dotClassName).matches()) {
-            throw new IllegalArgumentException("Bad dotClassName: " + dotClassName);
-        }
-        if (isPrimitiveClass(dotClassName)) {
-            throw new UnsupportedOperationException("Cannot generate primitive class.");
-        }
-        if (isArrayClass(dotClassName)) {
-            throw new UnsupportedOperationException("Cannot generate array class.");
-        }
-
-        final int lastDotSepPos = dotClassName.lastIndexOf('.');
-        final String classPkgPart =
-                (lastDotSepPos >= 0 ? dotClassName.substring(0, lastDotSepPos) : "");
-        final String classNamePart = dotClassName.substring(lastDotSepPos + 1);
-
-        final File realDirOutput = new File(dirOutput, classPkgPart.replace('.', '/'));
-        if (!realDirOutput.exists()) {
-            realDirOutput.mkdirs();
-        }
-        final File fileOut = new File(realDirOutput, classNamePart + ".class");
-
-        generateClass(dotClassName, fileOut);
-    }
-
-    private static void generateClass(String dotClassName, File fileOut) throws IOException {
-        final String classDesc = dotClassName.replace('.', '/');
-        ClassWriter cw = new ClassWriter(0);
-        cw.visit(
-                Opcodes.V1_7,
-                Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER,
-                classDesc,
-                null,
-                "java/lang/Object",
-                null
-        );
-        cw.visitSource(fileOut.getName(), null);
-        {
-            MethodVisitor mv = cw.visitMethod(
-                    Opcodes.ACC_PUBLIC, "<init>", "()V", null, null
-            );
-            mv.visitVarInsn(Opcodes.ALOAD, 0);
-            mv.visitMethodInsn(Opcodes.INVOKESPECIAL,
-                    "java/lang/Object",
-                    "<init>",
-                    "()V",
-                    false
-            );
-            mv.visitInsn(Opcodes.RETURN);
-            mv.visitMaxs(1, 1);
-            mv.visitEnd();
-        }
-        cw.visitEnd();
-        byte[] classBytes = cw.toByteArray();
-
-        OutputStream os = null;
-        try {
-            os = new BufferedOutputStream(new FileOutputStream(fileOut));
-            os.write(classBytes);
-        } finally {
-            if (os != null) {
-                try {
-                    os.close();
-                } catch (Exception e) {
-                    // Ignored.
-                }
-            }
-        }
-    }
-
-    private static boolean isPrimitiveClass(String className) {
-        try {
-            return Class.forName(className).isPrimitive();
-        } catch (ClassNotFoundException e) {
-            return false;
-        }
-    }
-
-    private static boolean isArrayClass(String className) {
-        try {
-            return Class.forName(className).isArray();
-        } catch (ClassNotFoundException e) {
-            return false;
-        }
-    }
-}
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/auxiliaryclass/AuxiliaryClassInjectAdapter.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/auxiliaryclass/AuxiliaryClassInjectAdapter.java
index a840654a..6cd7200d 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/auxiliaryclass/AuxiliaryClassInjectAdapter.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/auxiliaryclass/AuxiliaryClassInjectAdapter.java
@@ -18,6 +18,7 @@
 
 import org.objectweb.asm.ClassVisitor;
 import org.objectweb.asm.ClassWriter;
+import org.objectweb.asm.Label;
 import org.objectweb.asm.MethodVisitor;
 import org.objectweb.asm.Opcodes;
 import org.objectweb.asm.Type;
@@ -104,8 +105,12 @@ public void visitEnd() {
         if (!this.isClInitExists && !this.isInitExists) {
             MethodVisitor mv = super.visitMethod(Opcodes.ACC_STATIC, "<clinit>", "()V", null, null);
             mv.visitCode();
-            mv.visitLdcInsn(Type.getType(AuxiliaryClassInjectAdapter.this.auxiliaryClassDesc));
+            mv.visitMethodInsn(Opcodes.INVOKESTATIC, "java/lang/System", "lineSeparator", "()Ljava/lang/String;", false);
+            Label lblSkipInvalidInsn = new Label();
+            mv.visitJumpInsn(Opcodes.IFNONNULL, lblSkipInvalidInsn);
+            mv.visitLdcInsn(Type.getType(this.auxiliaryClassDesc));
             mv.visitVarInsn(Opcodes.ASTORE, 0);
+            mv.visitLabel(lblSkipInvalidInsn);
             mv.visitInsn(Opcodes.RETURN);
             mv.visitMaxs(1, 1);
             mv.visitEnd();
@@ -121,8 +126,12 @@ public void visitEnd() {
         @Override
         public void visitInsn(int opcode) {
             if (opcode == Opcodes.RETURN) {
+                super.visitMethodInsn(Opcodes.INVOKESTATIC, "java/lang/System", "lineSeparator", "()Ljava/lang/String;", false);
+                Label lblSkipInvalidInsn = new Label();
+                super.visitJumpInsn(Opcodes.IFNONNULL, lblSkipInvalidInsn);
                 super.visitLdcInsn(Type.getType(AuxiliaryClassInjectAdapter.this.auxiliaryClassDesc));
                 super.visitVarInsn(Opcodes.ASTORE, 0);
+                super.visitLabel(lblSkipInvalidInsn);
             }
             super.visitInsn(opcode);
         }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/auxiliaryclass/AuxiliaryClassInjector.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/auxiliaryclass/AuxiliaryClassInjector.java
index 88979366..a74cfea6 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/auxiliaryclass/AuxiliaryClassInjector.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/auxiliaryclass/AuxiliaryClassInjector.java
@@ -31,6 +31,8 @@
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.nio.charset.Charset;
+import java.util.HashMap;
+import java.util.Map;
 import java.util.zip.ZipEntry;
 import java.util.zip.ZipInputStream;
 import java.util.zip.ZipOutputStream;
@@ -40,7 +42,10 @@
  */
 
 public final class AuxiliaryClassInjector {
-    public static final String AUXILIARY_CLASSNAME = "dalvik.system.PathClassLoader";
+    // The descriptor of this class is so strange so that we hope no one
+    // would happen to create a class named the same as it.
+    public static final String NOT_EXISTS_CLASSNAME
+            = "tInKEr.pReVEnT.PrEVErIfIEd.STuBCLaSS";
 
     public interface ProcessJarCallback {
         boolean onProcessClassEntry(String entryName);
@@ -79,22 +84,35 @@ private static void processJarHelper(File jarIn, File jarOut, ProcessJarCallback
             zis = new ZipInputStream(new BufferedInputStream(new FileInputStream(jarIn)), charsetIn);
             zos = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(jarOut)), charsetOut);
             ZipEntry entryIn = null;
+            Map<String, Integer> processedEntryNamesMap = new HashMap<>();
             while ((entryIn = zis.getNextEntry()) != null) {
                 final String entryName = entryIn.getName();
-                ZipEntry entryOut = new ZipEntry(entryName);
-                zos.putNextEntry(entryOut);
-                if (!entryIn.isDirectory()) {
-                    if (entryName.endsWith(".class")) {
-                        if (cb == null || cb.onProcessClassEntry(entryName)) {
-                            processClass(zis, zos);
+                ZipEntry entryOut = new ZipEntry(entryIn);
+                entryOut.setCompressedSize(-1);
+                if (!processedEntryNamesMap.containsKey(entryName)) {
+                    zos.putNextEntry(entryOut);
+                    if (!entryIn.isDirectory()) {
+                        if (entryName.endsWith(".class")) {
+                            if (cb == null || cb.onProcessClassEntry(entryName)) {
+                                processClass(zis, zos);
+                            } else {
+                                Streams.copy(zis, zos);
+                            }
                         } else {
                             Streams.copy(zis, zos);
                         }
-                    } else {
-                        Streams.copy(zis, zos);
                     }
+                    zos.closeEntry();
+                    processedEntryNamesMap.put(entryName, 1);
+                } else {
+                    int duplicateCount = processedEntryNamesMap.get(entryName);
+                    final String wrapperJarName
+                            = jarOut.getName().substring(0, jarOut.getName().lastIndexOf(".jar"))
+                            + "_dup_ew_" + duplicateCount + ".jar";
+                    File wrapperJarOut = new File(jarOut.getParentFile(), wrapperJarName);
+                    wrapEntryByJar(entryOut, zis, wrapperJarOut);
+                    processedEntryNamesMap.put(entryName, duplicateCount + 1);
                 }
-                zos.closeEntry();
             }
         } finally {
             closeQuietly(zos);
@@ -102,10 +120,22 @@ private static void processJarHelper(File jarIn, File jarOut, ProcessJarCallback
         }
     }
 
+    private static void wrapEntryByJar(ZipEntry ze, InputStream eData, File jarOut) throws IOException {
+        ZipOutputStream zos = null;
+        try {
+            zos = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(jarOut)));
+            zos.putNextEntry(ze);
+            Streams.copy(eData, zos);
+            zos.closeEntry();
+        } finally {
+            closeQuietly(zos);
+        }
+    }
+
     private static void processClass(InputStream classIn, OutputStream classOut) throws IOException {
         ClassReader cr = new ClassReader(classIn);
         ClassWriter cw = new ClassWriter(0);
-        AuxiliaryClassInjectAdapter aia = new AuxiliaryClassInjectAdapter(AUXILIARY_CLASSNAME, cw);
+        AuxiliaryClassInjectAdapter aia = new AuxiliaryClassInjectAdapter(NOT_EXISTS_CLASSNAME, cw);
         cr.accept(aia, 0);
         classOut.write(cw.toByteArray());
         classOut.flush();
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/builder/PatchBuilder.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/builder/PatchBuilder.java
index 998ebd62..7b2e0d3e 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/builder/PatchBuilder.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/builder/PatchBuilder.java
@@ -23,7 +23,10 @@
 import com.tencent.tinker.build.util.TypedValue;
 
 import java.io.File;
+import java.io.FileInputStream;
 import java.io.IOException;
+import java.security.Key;
+import java.security.KeyStore;
 import java.util.ArrayList;
 
 /**
@@ -45,7 +48,7 @@ public PatchBuilder(Configuration config) {
         this.sevenZipOutPutDir = new File(config.mOutFolder, TypedValue.OUT_7ZIP_FILE_PATH);
     }
 
-    public void buildPatch() throws IOException, InterruptedException {
+    public void buildPatch() throws Exception {
         final File resultDir = config.mTempResultDir;
         if (!resultDir.exists()) {
             throw new IOException(String.format(
@@ -80,26 +83,47 @@ public void buildPatch() throws IOException, InterruptedException {
 
     }
 
+    private String getSignatureAlgorithm() throws Exception {
+        FileInputStream fileIn = new FileInputStream(config.mSignatureFile);
+        KeyStore keyStore = KeyStore.getInstance("JKS");
+        keyStore.load(fileIn, config.mStorePass.toCharArray());
+        Key key = keyStore.getKey(config.mStoreAlias, config.mKeyPass.toCharArray());
+        String keyAlgorithm = key.getAlgorithm();
+        String signatureAlgorithm;
+        if (keyAlgorithm.equalsIgnoreCase("DSA")) {
+            signatureAlgorithm = "SHA1withDSA";
+        } else if (keyAlgorithm.equalsIgnoreCase("RSA")) {
+            signatureAlgorithm = "SHA1withRSA";
+        } else if (keyAlgorithm.equalsIgnoreCase("EC")) {
+            signatureAlgorithm = "SHA1withECDSA";
+        } else {
+            throw new RuntimeException("private key is not a DSA or "
+                    + "RSA key");
+        }
+        return signatureAlgorithm;
+    }
+
     /**
      * @param input  unsigned file input
      * @param output signed file output
      * @throws IOException
      * @throws InterruptedException
      */
-    private void signApk(File input, File output) throws IOException, InterruptedException {
+    private void signApk(File input, File output) throws Exception {
         //sign apk
         if (config.mUseSignAPk) {
             Logger.d("Signing apk: %s", output.getName());
+            String signatureAlgorithm = getSignatureAlgorithm();
+            Logger.d("Signing key algorithm is %s", signatureAlgorithm);
+
             if (output.exists()) {
                 output.delete();
             }
             ArrayList<String> command = new ArrayList<>();
             command.add("jarsigner");
-            // -sigalg algorithm: If this option is not specified, then SHA1withDSA, SHA256withRSA,
-            // or SHA256withECDSA are used depending on the type of private key.
             // issue https://github.com/Tencent/tinker/issues/118
-//            command.add("-sigalg");
-//            command.add("MD5withRSA");
+            command.add("-sigalg");
+            command.add(signatureAlgorithm);
             command.add("-digestalg");
             command.add("SHA1");
             command.add("-keystore");
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java
index fa32385f..0a298879 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java
@@ -308,9 +308,9 @@ private void generateStubModePatchDex() throws IOException {
 
     @SuppressWarnings("NewApi")
     private void generatePatchInfoFile() throws IOException {
-        File tempFullPatchDexPath = new File(config.mOutFolder + File.separator + TypedValue.DEX_TEMP_PATCH_DIR + File.separator + "full");
+        File tempFullPatchDexPath = new File(config.mOutFolder + File.separator + TypedValue.DEX_TEMP_PATCH_DIR + File.separator + "dalvik");
         ensureDirectoryExist(tempFullPatchDexPath);
-        File tempSmallPatchDexPath = new File(config.mOutFolder + File.separator + TypedValue.DEX_TEMP_PATCH_DIR + File.separator + "small");
+        File tempSmallPatchDexPath = new File(config.mOutFolder + File.separator + TypedValue.DEX_TEMP_PATCH_DIR + File.separator + "art");
         ensureDirectoryExist(tempSmallPatchDexPath);
 
         // Generate dex diff out and full patched dex if a pair of dex is different.
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ManifestDecoder.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ManifestDecoder.java
index 59e6e400..642b4482 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ManifestDecoder.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ManifestDecoder.java
@@ -51,12 +51,12 @@ public boolean patch(File oldFile, File newFile) throws IOException, TinkerPatch
                 if (config.mDexRaw) {
                     if (ignoreWarning) {
                         //ignoreWarning, just log
-                        Logger.e("Warning:ignoreWarning is true, but your old apk's minSdkVersion %d is below 14, you should set the dexMode to 'jar', otherwise, it will be crash at some times", minSdkVersion);
+                        Logger.e("Warning:ignoreWarning is true, but your old apk's minSdkVersion %d is below 14, you should set the dexMode to 'jar', otherwise, it will crash at some time", minSdkVersion);
                     } else {
-                        Logger.e("Warning:ignoreWarning is false, but your old apk's minSdkVersion %d is below 14, you should set the dexMode to 'jar', otherwise, it will be crash at some times", minSdkVersion);
+                        Logger.e("Warning:ignoreWarning is false, but your old apk's minSdkVersion %d is below 14, you should set the dexMode to 'jar', otherwise, it will crash at some time", minSdkVersion);
 
                         throw new TinkerPatchException(
-                            String.format("ignoreWarning is false, but your old apk's minSdkVersion %d is below 14, you should set the dexMode to 'jar', otherwise, it will be crash at some times", minSdkVersion)
+                            String.format("ignoreWarning is false, but your old apk's minSdkVersion %d is below 14, you should set the dexMode to 'jar', otherwise, it will crash at some time", minSdkVersion)
                         );
                     }
                 }
@@ -76,11 +76,11 @@ public boolean patch(File oldFile, File newFile) throws IOException, TinkerPatch
                 }
                 if (!found) {
                     if (ignoreWarning) {
-                        Logger.e("Warning:ignoreWarning is true, but we found a new AndroidComponent %s, it will be crash at some times", newComponentName);
+                        Logger.e("Warning:ignoreWarning is true, but we found a new AndroidComponent %s, it will crash at some time", newComponentName);
                     } else {
-                        Logger.e("Warning:ignoreWarning is false, but we found a new AndroidComponent %s, it will be crash at some times", newComponentName);
+                        Logger.e("Warning:ignoreWarning is false, but we found a new AndroidComponent %s, it will crash at some time", newComponentName);
                         throw new TinkerPatchException(
-                            String.format("ignoreWarning is false, but we found a new AndroidComponent %s, it will be crash at some times", newComponentName)
+                            String.format("ignoreWarning is false, but we found a new AndroidComponent %s, it will crash at some time", newComponentName)
                         );
                     }
                 }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ResDiffDecoder.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ResDiffDecoder.java
index 4c5b1222..9ec77664 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ResDiffDecoder.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ResDiffDecoder.java
@@ -42,6 +42,8 @@
  * Created by zhangshaowen on 16/8/8.
  */
 public class ResDiffDecoder extends BaseDecoder {
+    private static final String TEST_RESOURCE_NAME        = "only_use_to_test_tinker_resource.txt";
+    private static final String TEST_RESOURCE_ASSETS_PATH = "assets/" + TEST_RESOURCE_NAME;
 
     private static final String TEMP_RES_ZIP  = "temp_res.zip";
     private static final String TEMP_RES_7ZIP = "temp_res_7ZIP.zip";
@@ -53,11 +55,6 @@
     private       HashMap<String, LargeModeInfo> largeModifiedMap;
     private ArrayList<String> deletedSet;
 
-    private boolean arscChanged;
-    private File oldArscFile;
-    private File newArscFile;
-
-
     public ResDiffDecoder(Configuration config, String metaPath, String logPath) throws IOException {
         super(config);
 
@@ -95,14 +92,16 @@ private boolean checkLargeModFile(File file) {
 
     @Override
     public boolean patch(File oldFile, File newFile) throws IOException, TinkerPatchException {
+        String name = getRelativeString(newFile);
+
         //actually, it won't go below
         if (newFile == null || !newFile.exists()) {
-            String name = getRelativeStringByOldDir(oldFile);
-            if (Utils.checkFileInPattern(config.mResIgnoreChangePattern, name)) {
-                Logger.e("found delete resource: " + name + " ,but it match ignore change pattern, just ignore!");
+            String relativeStringByOldDir = getRelativeStringByOldDir(oldFile);
+            if (Utils.checkFileInPattern(config.mResIgnoreChangePattern, relativeStringByOldDir)) {
+                Logger.e("found delete resource: " + relativeStringByOldDir + " ,but it match ignore change pattern, just ignore!");
                 return false;
             }
-            deletedSet.add(name);
+            deletedSet.add(relativeStringByOldDir);
             writeResLog(newFile, oldFile, TypedValue.DEL);
             return true;
         }
@@ -110,7 +109,6 @@ public boolean patch(File oldFile, File newFile) throws IOException, TinkerPatch
         File outputFile = getOutputPath(newFile).toFile();
 
         if (oldFile == null || !oldFile.exists()) {
-            String name = getRelativeString(newFile);
             if (Utils.checkFileInPattern(config.mResIgnoreChangePattern, name)) {
                 Logger.e("found add resource: " + name + " ,but it match ignore change pattern, just ignore!");
                 return false;
@@ -132,7 +130,6 @@ public boolean patch(File oldFile, File newFile) throws IOException, TinkerPatch
         if (oldMd5 != null && oldMd5.equals(newMd5)) {
             return false;
         }
-        String name = getRelativeString(newFile);
         if (Utils.checkFileInPattern(config.mResIgnoreChangePattern, name)) {
             Logger.d("found modify resource: " + name + ", but it match ignore change pattern, just ignore!");
             return false;
@@ -146,11 +143,6 @@ public boolean patch(File oldFile, File newFile) throws IOException, TinkerPatch
                 Logger.d("found modify resource: " + name + ", but it is logically the same as original new resources.arsc, just ignore!");
                 return false;
             }
-            //deal with resources.arsc later
-            arscChanged = true;
-            oldArscFile = oldFile;
-            newArscFile = newFile;
-            return true;
         }
         dealWithModeFile(name, newMd5, oldFile, newFile, outputFile);
         return true;
@@ -219,18 +211,20 @@ public void onAllPatchesStart() throws IOException, TinkerPatchException {
 
     }
 
-    private void modArscFileForTestResource() throws IOException {
-        File tempArscFile = new File(config.mOutFolder + File.separator + "edited_resources.arsc");
-        //there is resource changed, edit test resource string
-        AndroidParser.editResourceTableString(TypedValue.TEST_STRING_VALUE_A, TypedValue.TEST_STRING_VALUE_B, newArscFile, tempArscFile);
-        dealWithModeFile(TypedValue.RES_ARSC, MD5.getMD5(tempArscFile), oldArscFile, tempArscFile, getOutputPath(newArscFile).toFile());
-        Logger.d("Edit resources.arsc file for test resource change, final path: " + tempArscFile.getAbsolutePath());
+    private void addAssetsFileForTestResource() throws IOException {
+        File dest = new File(config.mTempResultDir + "/" + TEST_RESOURCE_ASSETS_PATH);
+        FileOperation.copyResourceUsingStream(TEST_RESOURCE_NAME, dest);
+        addedSet.add(TEST_RESOURCE_ASSETS_PATH);
+        Logger.d("Add Test resource file: " + TEST_RESOURCE_ASSETS_PATH);
+        String log = "add test resource: " + TEST_RESOURCE_ASSETS_PATH + ", oldSize=" + 0 + ", newSize="
+            + FileOperation.getFileSizes(dest);
+        logWriter.writeLineToInfoFile(log);
     }
 
     @Override
     public void onAllPatchesEnd() throws IOException, TinkerPatchException {
         //only there is only deleted set, we just ignore
-        if (addedSet.isEmpty() && modifiedSet.isEmpty() && largeModifiedSet.isEmpty() && !arscChanged) {
+        if (addedSet.isEmpty() && modifiedSet.isEmpty() && largeModifiedSet.isEmpty()) {
             return;
         }
 
@@ -241,12 +235,14 @@ public void onAllPatchesEnd() throws IOException, TinkerPatchException {
             throw new TinkerPatchException("resource must contain AndroidManifest.xml pattern");
         }
 
-        modArscFileForTestResource();
+        addAssetsFileForTestResource();
 
         //check gradle build
         if (config.mUsingGradle) {
             final boolean ignoreWarning = config.mIgnoreWarning;
-            if (arscChanged && !config.mUseApplyResource) {
+            final boolean resourceArscChanged = modifiedSet.contains(TypedValue.RES_ARSC)
+                || largeModifiedSet.contains(TypedValue.RES_ARSC);
+            if (resourceArscChanged && !config.mUseApplyResource) {
                 if (ignoreWarning) {
                     //ignoreWarning, just log
                     Logger.e("Warning:ignoreWarning is true, but resources.arsc is changed, you should use applyResourceMapping mode to build the new apk, otherwise, it may be crash at some times");
@@ -288,9 +284,9 @@ public void onAllPatchesEnd() throws IOException, TinkerPatchException {
         String resZipMd5 = Utils.genResOutputFile(extractToZip, tempResZip, config,
             addedSet, modifiedSet, deletedSet, largeModifiedSet, largeModifiedMap);
 
-        Logger.e("final normal zip resource: %s, size=%d, md5=%s", extractToZip.getName(), extractToZip.length(), resZipMd5);
+        Logger.e("Final normal zip resource: %s, size=%d, md5=%s", extractToZip.getName(), extractToZip.length(), resZipMd5);
         logWriter.writeLineToInfoFile(
-            String.format("final normal zip resource: %s, size=%d, md5=%s", extractToZip.getName(), extractToZip.length(), resZipMd5)
+            String.format("Final normal zip resource: %s, size=%d, md5=%s", extractToZip.getName(), extractToZip.length(), resZipMd5)
         );
         //delete temp file
         FileOperation.deleteFile(tempResZip);
@@ -308,9 +304,9 @@ public void onAllPatchesEnd() throws IOException, TinkerPatchException {
                     addedSet, modifiedSet, deletedSet, largeModifiedSet, largeModifiedMap);
                 //delete temp file
                 FileOperation.deleteFile(tempRes7Zip);
-                Logger.e("final 7zip resource: %s, size=%d, md5=%s", extractTo7Zip.getName(), extractTo7Zip.length(), res7zipMd5);
+                Logger.e("Final 7zip resource: %s, size=%d, md5=%s", extractTo7Zip.getName(), extractTo7Zip.length(), res7zipMd5);
                 logWriter.writeLineToInfoFile(
-                    String.format("final 7zip resource: %s, size=%d, md5=%s", extractTo7Zip.getName(), extractTo7Zip.length(), res7zipMd5)
+                    String.format("Final 7zip resource: %s, size=%d, md5=%s", extractTo7Zip.getName(), extractTo7Zip.length(), res7zipMd5)
                 );
             }
         }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/RefToRefAffectedClassInsnVisitor.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/ClassReferringInsnVisitor.java
similarity index 86%
rename from tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/RefToRefAffectedClassInsnVisitor.java
rename to tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/ClassReferringInsnVisitor.java
index 8158746a..af443b81 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/RefToRefAffectedClassInsnVisitor.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/ClassReferringInsnVisitor.java
@@ -31,23 +31,23 @@
  * Created by tangyinsheng on 2016/10/8.
  */
 
-public class RefToRefAffectedClassInsnVisitor extends InstructionVisitor {
-    private static final String TAG = "RefToRefAffectedClassInsnVisitor";
+public class ClassReferringInsnVisitor extends InstructionVisitor {
+    private static final String TAG = "ClassReferringInsnVisitor";
 
     private final Dex methodOwner;
     private final ClassData.Method method;
-    private final Collection<String> refAffectedClassDefs;
+    private final Collection<String> classDescsToCheck;
     private final DexPatcherLogger logger;
 
-    public boolean isMethodReferencedToRefAffectedClass;
+    public boolean isMethodReferencedToAnyProvidedClasses;
 
-    RefToRefAffectedClassInsnVisitor(Dex methodOwner, ClassData.Method method, Collection<String> refAffectedClassDefs, DexPatcherLogger logger) {
+    ClassReferringInsnVisitor(Dex methodOwner, ClassData.Method method, Collection<String> classDescsToCheck, DexPatcherLogger logger) {
         super(null);
         this.methodOwner = methodOwner;
         this.method = method;
-        this.refAffectedClassDefs = refAffectedClassDefs;
+        this.classDescsToCheck = classDescsToCheck;
         this.logger = logger;
-        this.isMethodReferencedToRefAffectedClass = false;
+        this.isMethodReferencedToAnyProvidedClasses = false;
     }
 
     @Override
@@ -91,7 +91,7 @@ private void processIndexByType(int index, int indexType) {
         switch (indexType) {
             case InstructionCodec.INDEX_TYPE_TYPE_REF: {
                 typeName = methodOwner.typeNames().get(index);
-                refInfoInLog = "init ref-changed class";
+                refInfoInLog = "init class";
                 break;
             }
             case InstructionCodec.INDEX_TYPE_FIELD_REF: {
@@ -107,17 +107,17 @@ private void processIndexByType(int index, int indexType) {
                 break;
             }
         }
-        if (typeName != null && refAffectedClassDefs.contains(typeName)) {
+        if (typeName != null && classDescsToCheck.contains(typeName)) {
             MethodId methodId = methodOwner.methodIds().get(method.methodIndex);
             logger.i(
                     TAG,
-                    "Method %s in class %s referenced ref-changed class %s by %s",
+                    "Method %s in class %s referenced class %s by %s",
                     getMethodProtoTypeStr(methodId),
                     methodOwner.typeNames().get(methodId.declaringClassIndex),
                     typeName,
                     refInfoInLog
             );
-            isMethodReferencedToRefAffectedClass = true;
+            isMethodReferencedToAnyProvidedClasses = true;
         }
     }
 
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/SmallDexClassInfoCollector.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/SmallDexClassInfoCollector.java
index f9be6337..3a3a3428 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/SmallDexClassInfoCollector.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/SmallDexClassInfoCollector.java
@@ -17,6 +17,7 @@
 package com.tencent.tinker.build.dexpatcher.util;
 
 import com.tencent.tinker.android.dex.ClassData;
+import com.tencent.tinker.android.dex.ClassDef;
 import com.tencent.tinker.android.dex.Code;
 import com.tencent.tinker.android.dex.Dex;
 import com.tencent.tinker.android.dx.instruction.InstructionReader;
@@ -62,79 +63,135 @@ public SmallDexClassInfoCollector setLogger(DexPatcherLogger.IDexPatcherLogger l
         return this;
     }
 
+    // Collect target:
+    //  Added classes;
+    //  Changed classes;
+    //  Subclasses of referrer-affected changed classes;
+    //  Classes which refer to changed classes.
     public Set<DexClassInfo> doCollect(DexGroup oldDexGroup, DexGroup newDexGroup) {
+        Set<DexClassInfo> classInfosInSmallDex = new HashSet<>();
+
         DexClassesComparator dexClassesCmp = new DexClassesComparator("*");
-        dexClassesCmp.setCompareMode(DexClassesComparator.COMPARE_MODE_CAUSE_REF_CHANGE_ONLY);
         dexClassesCmp.setIgnoredRemovedClassDescPattern(this.loaderClassPatterns);
+
+        dexClassesCmp.setCompareMode(DexClassesComparator.COMPARE_MODE_CAUSE_REF_CHANGE_ONLY);
         dexClassesCmp.startCheck(oldDexGroup, newDexGroup);
 
-        Set<String> refAffectedClassDescs
+        Set<String> referrerAffectedChangedClassDescs
                 = dexClassesCmp.getChangedClassDescToInfosMap().keySet();
 
+        Set<String> referrerAffectedChangedClassesChainSet = new HashSet<>();
+        referrerAffectedChangedClassesChainSet.addAll(referrerAffectedChangedClassDescs);
+
+        // Add added classes to small patched dex.
+        Collection<DexClassInfo> addedClassInfos = dexClassesCmp.getAddedClassInfos();
+        for (DexClassInfo addClassInfo : addedClassInfos) {
+            logger.i(TAG, "Add class %s to small dex.", addClassInfo.classDesc);
+            classInfosInSmallDex.add(addClassInfo);
+        }
+
+        // Use normal mode to compare again, then we get all changed class infos.
+        dexClassesCmp.setCompareMode(DexClassesComparator.COMPARE_MODE_NORMAL);
+        dexClassesCmp.startCheck(oldDexGroup, newDexGroup);
+
+        Collection<DexClassInfo[]> changedOldNewClassInfos =
+                dexClassesCmp.getChangedClassDescToInfosMap().values();
+
+        // Add changed classes to small patched dex.
+        // changedOldNewClassInfo[1] means changedNewClassInfo
+        for (DexClassInfo[] changedOldNewClassInfo : changedOldNewClassInfos) {
+            logger.i(TAG, "Add class %s to small dex.", changedOldNewClassInfo[1].classDesc);
+            classInfosInSmallDex.add(changedOldNewClassInfo[1]);
+        }
+
         Set<DexClassInfo> classInfosInNewDexGroup
                 = newDexGroup.getClassInfosInDexesWithDuplicateCheck();
 
-        Set<DexClassInfo> classInfosOfSmallDex = new HashSet<>();
+        Set<String> changedClassDescs = dexClassesCmp.getChangedClassDescToInfosMap().keySet();
 
+        // Add subclasses of referrer-affected changed classes to small patched dex.
+        // By the way, collect all subclasses to form referrer-affected changed classes chain.
         for (DexClassInfo patchedClassInfo : classInfosInNewDexGroup) {
-            if (patchedClassInfo.classDef.classDataOffset == 0) {
-                continue;
-            }
+            final String superClassDesc
+                    = patchedClassInfo.classDef.supertypeIndex == ClassDef.NO_INDEX
+                    ? ""
+                    : patchedClassInfo.owner.typeNames().get(patchedClassInfo.classDef.supertypeIndex);
 
-            ClassData patchedClassData
-                    = patchedClassInfo.owner.readClassData(patchedClassInfo.classDef);
+            if (referrerAffectedChangedClassesChainSet.contains(superClassDesc)) {
+                referrerAffectedChangedClassesChainSet.add(patchedClassInfo.classDesc);
+                logger.i(TAG, "Class %s is subclass of referrer-affected changed class %s.",
+                        patchedClassInfo.classDesc, superClassDesc);
 
-            boolean shouldAdd = isClassMethodReferenceToRefAffectedClass(
-                    patchedClassInfo.owner,
-                    patchedClassData.directMethods,
-                    refAffectedClassDescs
-            );
+                logger.i(TAG, "Add class %s to small dex.", patchedClassInfo.classDesc);
 
-            if (!shouldAdd) {
-                shouldAdd = isClassMethodReferenceToRefAffectedClass(
-                        patchedClassInfo.owner,
-                        patchedClassData.virtualMethods,
-                        refAffectedClassDescs
-                );
+                classInfosInSmallDex.add(patchedClassInfo);
             }
+        }
 
-            if (shouldAdd) {
-                logger.i(TAG, "Add class %s to small dex.", patchedClassInfo.classDesc);
-                classInfosOfSmallDex.add(patchedClassInfo);
+        Set<String> classesToCheckReference = new HashSet<>();
+        classesToCheckReference.addAll(changedClassDescs);
+        classesToCheckReference.addAll(referrerAffectedChangedClassesChainSet);
+
+        Set<String> addedClassDescs = new HashSet<>();
+        for (DexClassInfo addedClassInfo : addedClassInfos) {
+            addedClassDescs.add(addedClassInfo.classDesc);
+        }
+
+        // Add classes which refer to changed classes and referrer-affected
+        // changed classes chain to small patched dex.
+        for (DexClassInfo patchedClassInfo : classInfosInNewDexGroup) {
+            if (!addedClassDescs.contains(patchedClassInfo.classDesc)
+             && !changedClassDescs.contains(patchedClassInfo.classDesc)) {
+                processMethodReference(
+                        patchedClassInfo,
+                        classesToCheckReference,
+                        classInfosInSmallDex
+                );
             }
         }
 
-        // So far we get descriptors of classes we need to add additionally,
-        // while we still need to do a fully compare to collect added classes
-        // and replaced classes since they may use items in their owner dex which
-        // is not modified.
-        dexClassesCmp.setCompareMode(DexClassesComparator.COMPARE_MODE_NORMAL);
-        dexClassesCmp.startCheck(oldDexGroup, newDexGroup);
+        return classInfosInSmallDex;
+    }
 
-        Collection<DexClassInfo> addedClassInfos = dexClassesCmp.getAddedClassInfos();
-        for (DexClassInfo addClassInfo : addedClassInfos) {
-            logger.i(TAG, "Add class %s to small dex.", addClassInfo.classDesc);
-            classInfosOfSmallDex.add(addClassInfo);
+    private void processMethodReference(
+            DexClassInfo patchedClassInfo,
+            Set<String> classDescsToCheck,
+            Set<DexClassInfo> result
+    ) {
+        final ClassDef classDef = patchedClassInfo.classDef;
+        if (classDef.classDataOffset == ClassDef.NO_OFFSET) {
+            return;
         }
 
-        Collection<DexClassInfo[]> changedOldPatchedClassInfos =
-                dexClassesCmp.getChangedClassDescToInfosMap().values();
+        ClassData patchedClassData
+                = patchedClassInfo.owner.readClassData(classDef);
+
+        boolean shouldAdd = isClassMethodReferenceToClasses(
+                patchedClassInfo.owner,
+                patchedClassData.directMethods,
+                classDescsToCheck
+        );
 
-        // changedOldPatchedClassInfo[1] means changedPatchedClassInfo
-        for (DexClassInfo[] changedOldPatchedClassInfo : changedOldPatchedClassInfos) {
-            logger.i(TAG, "Add class %s to small dex.", changedOldPatchedClassInfo[1].classDesc);
-            classInfosOfSmallDex.add(changedOldPatchedClassInfo[1]);
+        if (!shouldAdd) {
+            shouldAdd = isClassMethodReferenceToClasses(
+                    patchedClassInfo.owner,
+                    patchedClassData.virtualMethods,
+                    classDescsToCheck
+            );
         }
 
-        return classInfosOfSmallDex;
+        if (shouldAdd) {
+            logger.i(TAG, "Add class %s to small dex.", patchedClassInfo.classDesc);
+            result.add(patchedClassInfo);
+        }
     }
 
-    private boolean isClassMethodReferenceToRefAffectedClass(
+    private boolean isClassMethodReferenceToClasses(
             Dex owner,
             ClassData.Method[] methods,
-            Collection<String> affectedClassDescs
+            Collection<String> referredClassDescs
     ) {
-        if (affectedClassDescs.isEmpty() || methods == null || methods.length == 0) {
+        if (referredClassDescs.isEmpty() || methods == null || methods.length == 0) {
             return false;
         }
 
@@ -143,13 +200,13 @@ private boolean isClassMethodReferenceToRefAffectedClass(
                 continue;
             }
             Code code = owner.readCode(method);
-            RefToRefAffectedClassInsnVisitor refInsnVisitor =
-                    new RefToRefAffectedClassInsnVisitor(owner, method, affectedClassDescs, logger);
+            ClassReferringInsnVisitor refInsnVisitor =
+                    new ClassReferringInsnVisitor(owner, method, referredClassDescs, logger);
             InstructionReader insnReader =
                     new InstructionReader(new ShortArrayCodeInput(code.instructions));
             try {
                 insnReader.accept(refInsnVisitor);
-                if (refInsnVisitor.isMethodReferencedToRefAffectedClass) {
+                if (refInsnVisitor.isMethodReferencedToAnyProvidedClasses) {
                     return true;
                 }
             } catch (EOFException e) {
diff --git a/tinker-build/tinker-patch-lib/src/main/java/org/jf/dexlib2/builder/BuilderMutableMethodImplementation.java b/tinker-build/tinker-patch-lib/src/main/java/org/jf/dexlib2/builder/BuilderMutableMethodImplementation.java
index 50d89e3e..620e5e43 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/org/jf/dexlib2/builder/BuilderMutableMethodImplementation.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/org/jf/dexlib2/builder/BuilderMutableMethodImplementation.java
@@ -213,7 +213,7 @@ public void perform() {
 
             for (ExceptionHandler exceptionHandler : tryBlock.getExceptionHandlers()) {
                 tryBlocks.add(new BuilderTryBlock(startLabel, endLabel,
-                        exceptionHandler.getExceptionTypeReference(),
+                        (TypeReference) convertReference(exceptionHandler.getExceptionTypeReference()),
                         newLabel(codeAddressToIndex, exceptionHandler.getHandlerCodeAddress())));
             }
         }
diff --git a/tinker-build/tinker-patch-lib/src/main/resources/only_use_to_test_tinker_resource.txt b/tinker-build/tinker-patch-lib/src/main/resources/only_use_to_test_tinker_resource.txt
new file mode 100644
index 00000000..dc9c715f
--- /dev/null
+++ b/tinker-build/tinker-patch-lib/src/main/resources/only_use_to_test_tinker_resource.txt
@@ -0,0 +1 @@
+#tinker resource changed
\ No newline at end of file
diff --git a/tinker-sample-android/app/build.gradle b/tinker-sample-android/app/build.gradle
index 7c5494af..516f6b4e 100644
--- a/tinker-sample-android/app/build.gradle
+++ b/tinker-sample-android/app/build.gradle
@@ -7,7 +7,8 @@ dependencies {
     testCompile 'junit:junit:4.12'
     compile "com.android.support:appcompat-v7:23.1.1"
     compile("com.tencent.tinker:tinker-android-lib:${TINKER_VERSION}") { changing = true }
-    compile("com.tencent.tinker:tinker-android-anno:${TINKER_VERSION}") { changing = true }
+    provided("com.tencent.tinker:tinker-android-anno:${TINKER_VERSION}") { changing = true }
+
     compile "com.android.support:multidex:1.0.1"
 
     //use to test multiDex
@@ -24,7 +25,7 @@ dependencies {
 
 def gitSha() {
     try {
-        String gitRev = 'git rev-parse --short HEAD'.execute().text.trim()
+        String gitRev = 'git rev-parse --short HEAD'.execute(null, project.rootDir).text.trim()
         if (gitRev == null) {
             throw new GradleException("can't get git rev, you should add git to system path or just input test value, such as 'testTinkerId'")
         }
@@ -95,6 +96,11 @@ android {
         buildConfigField "String", "CLIENTVERSION", "\"${getTinkerIdValue()}\""
         buildConfigField "String", "PLATFORM",  "\"all\""
     }
+
+//    aaptOptions{
+//        cruncherEnabled false
+//    }
+
 //    //use to test flavors support
 //    productFlavors {
 //        flavor1 {
@@ -138,14 +144,14 @@ ext {
 
     //for normal build
     //old apk file to build patch apk
-    tinkerOldApkPath = "${bakPath}/app-armeabi-debug.apk.apk"
+    tinkerOldApkPath = "${bakPath}/app-debug-1018-17-32-47.apk"
     //proguard mapping file to build patch apk
-    tinkerApplyMappingPath = "${bakPath}/"
+    tinkerApplyMappingPath = "${bakPath}/app-debug-1018-17-32-47-mapping.txt"
     //resource R.txt to build patch apk, must input if there is resource changed
-    tinkerApplyResourcePath = "${bakPath}/"
+    tinkerApplyResourcePath = "${bakPath}/app-debug-1018-17-32-47-R.txt"
 
-    //use for build all flavor, just fill this field
-    tinkerBuildFlavorDirectory = "${bakPath}/app-1014-13-35-12"
+    //only use for build all flavor, if not, just ignore this field
+    tinkerBuildFlavorDirectory = "${bakPath}/app-1018-17-32-47"
 }
 
 
@@ -277,7 +283,7 @@ if (buildWithTinker()) {
              */
             loader = ["com.tencent.tinker.loader.*",
                       //warning, you must change it with your application
-                      "tinker.sample.android.SampleApplication",
+                      "tinker.sample.android.app.SampleApplication",
                       //use sample, let BaseBuildInfo unchangeable with tinker
                       "tinker.sample.android.app.BaseBuildInfo"
             ]
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SampleTinkerReport.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SampleTinkerReport.java
index 782c52ab..9ec92dd2 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SampleTinkerReport.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SampleTinkerReport.java
@@ -74,6 +74,8 @@
     public static final int KEY_APPLIED_PACKAGE_CHECK_META_NOT_FOUND            = 155;
     public static final int KEY_APPLIED_PACKAGE_CHECK_TINKER_ID_NOT_EQUAL       = 156;
     public static final int KEY_APPLIED_PACKAGE_CHECK_RES_META                  = 157;
+    public static final int KEY_APPLIED_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT    = 158;
+
     //version check
     public static final int KEY_APPLIED_VERSION_CHECK                           = 180;
     //extract error
@@ -128,6 +130,8 @@
     public static final int KEY_LOADED_PACKAGE_CHECK_TINKER_ID_NOT_EQUAL       = 355;
     public static final int KEY_LOADED_PACKAGE_CHECK_PACKAGE_META_NOT_FOUND    = 356;
     public static final int KEY_LOADED_PACKAGE_CHECK_RES_META                  = 357;
+    public static final int KEY_LOADED_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT    = 358;
+
 
     public static final int KEY_LOADED_SUCC_COST_500_LESS  = 400;
     public static final int KEY_LOADED_SUCC_COST_1000_LESS = 401;
@@ -230,6 +234,9 @@ public static void onLoadPackageCheckFail(int errorCode) {
             case ShareConstants.ERROR_PACKAGE_CHECK_RESOURCE_META_CORRUPTED:
                 reporter.onReport(KEY_LOADED_PACKAGE_CHECK_RES_META);
                 break;
+            case ShareConstants.ERROR_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT:
+                reporter.onReport(KEY_LOADED_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT);
+                break;
         }
     }
 
@@ -492,6 +499,9 @@ public static void onApplyPackageCheckFail(int errorCode) {
             case ShareConstants.ERROR_PACKAGE_CHECK_RESOURCE_META_CORRUPTED:
                 reporter.onReport(KEY_APPLIED_PACKAGE_CHECK_RES_META);
                 break;
+            case ShareConstants.ERROR_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT:
+                reporter.onReport(KEY_APPLIED_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT);
+                break;
         }
     }
 
diff --git a/tinker-sample-android/gradle.properties b/tinker-sample-android/gradle.properties
index c9e94d4f..eda0fddb 100644
--- a/tinker-sample-android/gradle.properties
+++ b/tinker-sample-android/gradle.properties
@@ -17,4 +17,4 @@
 # http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
 # org.gradle.parallel=true
 
-TINKER_VERSION=1.7.0
+TINKER_VERSION=1.7.3
