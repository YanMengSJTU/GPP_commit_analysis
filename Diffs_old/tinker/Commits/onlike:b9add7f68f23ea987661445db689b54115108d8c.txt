diff --git a/README.md b/README.md
index 80dc518e..be8131b7 100644
--- a/README.md
+++ b/README.md
@@ -1,6 +1,6 @@
 ## Tinker
 [![license](http://img.shields.io/badge/license-BSD3-brightgreen.svg?style=flat)](https://github.com/Tencent/tinker/blob/master/LICENSE)
-[![Release Version](https://img.shields.io/badge/release-1.7.9-red.svg)](https://github.com/Tencent/tinker/releases) 
+[![Release Version](https://img.shields.io/badge/release-1.7.11-red.svg)](https://github.com/Tencent/tinker/releases) 
 [![PRs Welcome](https://img.shields.io/badge/PRs-welcome-brightgreen.svg)](https://github.com/Tencent/tinker/pulls)
 [![WeChat Approved](https://img.shields.io/badge/Wechat_Approved-1.7.9-red.svg)](https://github.com/Tencent/tinker/wiki)
 
@@ -14,7 +14,7 @@ Add tinker-gradle-plugin as a dependency in your main `build.gradle` in the root
 ```gradle
 buildscript {
     dependencies {
-        classpath ('com.tencent.tinker:tinker-patch-gradle-plugin:1.7.9')
+        classpath ('com.tencent.tinker:tinker-patch-gradle-plugin:1.7.11')
     }
 }
 ```
@@ -24,9 +24,9 @@ Then you need to "apply" the plugin and add dependencies by adding the following
 ```gradle
 dependencies {
     //optional, help to generate the final application 
-    provided('com.tencent.tinker:tinker-android-anno:1.7.9')
+    provided('com.tencent.tinker:tinker-android-anno:1.7.11')
     //tinker's main Android lib
-    compile('com.tencent.tinker:tinker-android-lib:1.7.9') 
+    compile('com.tencent.tinker:tinker-android-lib:1.7.11') 
 }
 ...
 ...
diff --git a/gradle.properties b/gradle.properties
index 50eefed3..0cddaacf 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -16,5 +16,5 @@
 # This option should only be used with decoupled projects. More details, visit
 # http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
 # org.gradle.parallel=true
-VERSION_NAME_PREFIX=1.7.9
+VERSION_NAME_PREFIX=1.7.11
 VERSION_NAME_SUFFIX=
\ No newline at end of file
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/library/TinkerLoadLibrary.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/library/TinkerLoadLibrary.java
index 5fa176b2..26f7d4c2 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/library/TinkerLoadLibrary.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/library/TinkerLoadLibrary.java
@@ -170,12 +170,26 @@ private static void installNativeLibraryPath(ClassLoader classLoader, File folde
             TinkerLog.e(TAG, "installNativeLibraryPath, folder %s is illegal", folder);
             return;
         }
-        if (Build.VERSION.SDK_INT >= 23) {
+        // android o sdk_int 26
+        // for android o preview sdk_int 25
+        if ((Build.VERSION.SDK_INT == 25 && Build.VERSION.PREVIEW_SDK_INT != 0)
+            || Build.VERSION.SDK_INT > 25) {
+            try {
+                V25.install(classLoader, folder);
+                return;
+            } catch (Throwable throwable) {
+                // install fail, try to treat it as v23
+                // some preview N version may go here
+                TinkerLog.e(TAG, "installNativeLibraryPath, v25 fail, sdk: %d, error: %s, try to fallback to V23",
+                        Build.VERSION.SDK_INT, throwable.getMessage());
+                V23.install(classLoader, folder);
+            }
+        } else if (Build.VERSION.SDK_INT >= 23) {
             try {
                 V23.install(classLoader, folder);
             } catch (Throwable throwable) {
                 // install fail, try to treat it as v14
-                TinkerLog.e(TAG, "installNativeLibraryPath, v23 fail, sdk: %d, error: %s",
+                TinkerLog.e(TAG, "installNativeLibraryPath, v23 fail, sdk: %d, error: %s, try to fallback to V14",
                     Build.VERSION.SDK_INT, throwable.getMessage());
 
                 V14.install(classLoader, folder);
@@ -235,4 +249,26 @@ private static void install(ClassLoader classLoader, File folder)  throws Throwa
         }
     }
 
+    private static final class V25 {
+        private static void install(ClassLoader classLoader, File folder)  throws Throwable {
+            Field pathListField = ShareReflectUtil.findField(classLoader, "pathList");
+            Object dexPathList = pathListField.get(classLoader);
+
+            Field nativeLibraryDirectories = ShareReflectUtil.findField(dexPathList, "nativeLibraryDirectories");
+
+            List<File> libDirs = (List<File>) nativeLibraryDirectories.get(dexPathList);
+            libDirs.add(0, folder);
+            Field systemNativeLibraryDirectories =
+                    ShareReflectUtil.findField(dexPathList, "systemNativeLibraryDirectories");
+            List<File> systemLibDirs = (List<File>) systemNativeLibraryDirectories.get(dexPathList);
+            Method makePathElements =
+                    ShareReflectUtil.findMethod(dexPathList, "makePathElements", List.class);
+            libDirs.addAll(systemLibDirs);
+            Object[] elements = (Object[]) makePathElements.
+                    invoke(dexPathList, libDirs);
+            Field nativeLibraryPathElements = ShareReflectUtil.findField(dexPathList, "nativeLibraryPathElements");
+            nativeLibraryPathElements.setAccessible(true);
+            nativeLibraryPathElements.set(dexPathList, elements);
+        }
+    }
 }
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/Tinker.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/Tinker.java
index 3cc8aa01..ce514be5 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/Tinker.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/Tinker.java
@@ -266,6 +266,21 @@ public void cleanPatch() {
         SharePatchFileUtil.deleteDir(patchDirectory);
     }
 
+    /**
+     * rollback patch should restart all process
+     */
+    public void rollbackPatch() {
+        if (!isTinkerLoaded()) {
+            TinkerLog.w(TAG, "rollbackPatch: tinker is not loaded, just return");
+            return;
+        }
+        // kill all other process
+        ShareTinkerInternals.killAllOtherProcess(context);
+        // clean patch
+        cleanPatch();
+        // kill itself
+        android.os.Process.killProcess(android.os.Process.myPid());
+    }
     /**
      * clean the patch version files, such as tinker/patch-641e634c
      *
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/UpgradePatchRetry.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/UpgradePatchRetry.java
index 865be416..a34b4c9c 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/UpgradePatchRetry.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/UpgradePatchRetry.java
@@ -45,7 +45,7 @@
 
     private static final String RETRY_FILE_MD5_PROPERTY = "md5";
     private static final String RETRY_COUNT_PROPERTY    = "times";
-    private static final int    RETRY_MAX_COUNT         = 4;
+    private static final int    RETRY_MAX_COUNT         = 3;
     private static UpgradePatchRetry sInstance;
     private boolean isRetryEnable = true;
     private File    retryInfoFile = null;
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AndroidNClassLoader.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AndroidNClassLoader.java
index 1d964b6c..aa156098 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AndroidNClassLoader.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AndroidNClassLoader.java
@@ -20,16 +20,12 @@
 import android.app.Application;
 import android.content.Context;
 import android.os.Build;
-import android.text.TextUtils;
-import android.util.Log;
 
 import com.tencent.tinker.loader.shareutil.ShareReflectUtil;
 
 import java.io.File;
-import java.io.IOException;
+import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
-import java.lang.reflect.Method;
-import java.util.ArrayList;
 import java.util.List;
 
 import dalvik.system.DexFile;
@@ -42,9 +38,6 @@
 class AndroidNClassLoader extends PathClassLoader {
     private static final String TAG = "Tinker.NClassLoader";
 
-    private static final String CHECK_CLASSLOADER_CLASS = "com.tencent.tinker.loader.TinkerTestAndroidNClassLoader";
-
-    private static ArrayList<DexFile> oldDexFiles = new ArrayList<>();
     private final PathClassLoader originClassLoader;
     private String applicationClassName;
 
@@ -57,45 +50,67 @@ private AndroidNClassLoader(String dexPath, PathClassLoader parent, Application
         }
     }
 
-    private static AndroidNClassLoader createAndroidNClassLoader(PathClassLoader original, Application application) throws Exception {
-        //let all element ""
-        AndroidNClassLoader androidNClassLoader = new AndroidNClassLoader("",  original, application);
-        Field originPathList = ShareReflectUtil.findField(original, "pathList");
-        Object originPathListObject = originPathList.get(original);
-        //should reflect definingContext also
-        Field originClassloader = ShareReflectUtil.findField(originPathListObject, "definingContext");
-        originClassloader.set(originPathListObject, androidNClassLoader);
-        //copy pathList
-        Field pathListField = ShareReflectUtil.findField(androidNClassLoader, "pathList");
-        //just use PathClassloader's pathList
-        pathListField.set(androidNClassLoader, originPathListObject);
-
-        //we must recreate dexFile due to dexCache
-        List<File> additionalClassPathEntries = new ArrayList<>();
-        Field dexElement = ShareReflectUtil.findField(originPathListObject, "dexElements");
-        Object[] originDexElements = (Object[]) dexElement.get(originPathListObject);
-        for (Object element : originDexElements) {
-            DexFile dexFile = (DexFile) ShareReflectUtil.findField(element, "dexFile").get(element);
+    @SuppressWarnings("unchecked")
+    private static Object recreateDexPathList(Object originalDexPathList, ClassLoader newDefiningContext) throws Exception {
+        final Field dexElementsField = ShareReflectUtil.findField(originalDexPathList, "dexElements");
+        final Object[] dexElements = (Object[]) dexElementsField.get(originalDexPathList);
+        final Field nativeLibraryDirectoriesField = ShareReflectUtil.findField(originalDexPathList, "nativeLibraryDirectories");
+        final List<File> nativeLibraryDirectories = (List<File>) nativeLibraryDirectoriesField.get(originalDexPathList);
+
+        final StringBuilder dexPathBuilder = new StringBuilder();
+        final Field dexFileField = ShareReflectUtil.findField(dexElements.getClass().getComponentType(), "dexFile");
+
+        boolean isFirstItem = true;
+        for (Object dexElement : dexElements) {
+            final DexFile dexFile = (DexFile) dexFileField.get(dexElement);
             if (dexFile == null) {
                 continue;
             }
-            additionalClassPathEntries.add(new File(dexFile.getName()));
-            //protect for java.lang.AssertionError: Failed to close dex file in finalizer.
-            oldDexFiles.add(dexFile);
+            if (isFirstItem) {
+                isFirstItem = false;
+            } else {
+                dexPathBuilder.append(File.pathSeparator);
+            }
+            dexPathBuilder.append(dexFile.getName());
         }
-        Method makePathElements = ShareReflectUtil.findMethod(originPathListObject, "makePathElements", List.class, File.class,
-            List.class);
-        ArrayList<IOException> suppressedExceptions = new ArrayList<>();
-        Object[] newDexElements = (Object[]) makePathElements.invoke(originPathListObject, additionalClassPathEntries, null, suppressedExceptions);
-        dexElement.set(originPathListObject, newDexElements);
-
-        try {
-            Class.forName(CHECK_CLASSLOADER_CLASS, true, androidNClassLoader);
-        } catch (Throwable thr) {
-            Log.e(TAG, "load TinkerTestAndroidNClassLoader fail, try to fixDexElementsForProtectedApp");
-            fixDexElementsForProtectedApp(application, newDexElements);
+
+        final String dexPath = dexPathBuilder.toString();
+
+        final StringBuilder libraryPathBuilder = new StringBuilder();
+        isFirstItem = true;
+        for (File libDir : nativeLibraryDirectories) {
+            if (libDir == null) {
+                continue;
+            }
+            if (isFirstItem) {
+                isFirstItem = false;
+            } else {
+                libraryPathBuilder.append(File.pathSeparator);
+            }
+            libraryPathBuilder.append(libDir.getAbsolutePath());
         }
 
+        final String libraryPath = libraryPathBuilder.toString();
+
+        final Constructor<?> dexPathListConstructor = ShareReflectUtil.findConstructor(originalDexPathList, ClassLoader.class, String.class, String.class, File.class);
+        return dexPathListConstructor.newInstance(newDefiningContext, dexPath, libraryPath, null);
+    }
+
+    private static AndroidNClassLoader createAndroidNClassLoader(PathClassLoader originalClassLoader, Application application) throws Exception {
+        //let all element ""
+        final AndroidNClassLoader androidNClassLoader = new AndroidNClassLoader("",  originalClassLoader, application);
+        final Field pathListField = ShareReflectUtil.findField(originalClassLoader, "pathList");
+        final Object originPathList = pathListField.get(originalClassLoader);
+
+        // To avoid 'dex file register with multiple classloader' exception on Android O, we must keep old
+        // dexPathList in original classloader so that after the newly loaded base dex was bound to
+        // AndroidNClassLoader we can still load class in base dex from original classloader.
+
+        Object newPathList = recreateDexPathList(originPathList, androidNClassLoader);
+
+        // Update new classloader's pathList.
+        pathListField.set(androidNClassLoader, newPathList);
+
         return androidNClassLoader;
     }
 
@@ -117,47 +132,6 @@ public static AndroidNClassLoader inject(PathClassLoader originClassLoader, Appl
         return classLoader;
     }
 
-    // Basically this method would use base.apk to create a dummy DexFile object,
-    // then set its fileName, cookie, internalCookie field to the value
-    // comes from original DexFile object so that the encrypted dex would be taking effect.
-    private static void fixDexElementsForProtectedApp(Application application, Object[] newDexElements) throws Exception {
-        Field zipField = null;
-        Field dexFileField = null;
-        final Field mFileNameField = ShareReflectUtil.findField(DexFile.class, "mFileName");
-        final Field mCookieField = ShareReflectUtil.findField(DexFile.class, "mCookie");
-        final Field mInternalCookieField = ShareReflectUtil.findField(DexFile.class, "mInternalCookie");
-
-        // Always ignore the last element since it should always be the base.apk.
-        for (int i = 0; i < newDexElements.length - 1; ++i) {
-            final Object newElement = newDexElements[i];
-
-            if (zipField == null && dexFileField == null) {
-                zipField = ShareReflectUtil.findField(newElement, "zip");
-                dexFileField = ShareReflectUtil.findField(newElement, "dexFile");
-            }
-
-            final DexFile origDexFile = oldDexFiles.get(i);
-            final String origFileName = (String) mFileNameField.get(origDexFile);
-            final Object origCookie = mCookieField.get(origDexFile);
-            final Object origInternalCookie = mInternalCookieField.get(origDexFile);
-
-            final DexFile dupOrigDexFile = DexFile.loadDex(application.getApplicationInfo().sourceDir, null, 0);
-            mFileNameField.set(dupOrigDexFile, origFileName);
-            mCookieField.set(dupOrigDexFile, origCookie);
-            mInternalCookieField.set(dupOrigDexFile, origInternalCookie);
-
-            dexFileField.set(newElement, dupOrigDexFile);
-
-            // Just for better looking when dump new classloader.
-            // Avoid such output like this: DexPathList{zip file: /xx/yy/zz/uu.odex}
-            final File newZip = (File) zipField.get(newElement);
-            final String newZipPath = (newZip != null ? newZip.getAbsolutePath() : null);
-            if (newZipPath != null && !newZipPath.endsWith(".zip") && !newZipPath.endsWith(".jar") && !newZipPath.endsWith(".apk")) {
-                zipField.set(newElement, null);
-            }
-        }
-    }
-
 //    public static String getLdLibraryPath(ClassLoader loader) throws Exception {
 //        String nativeLibraryPath;
 //
@@ -172,9 +146,8 @@ private static void fixDexElementsForProtectedApp(Application application, Objec
         // loader class use default pathClassloader to load
         if ((name != null
                 && name.startsWith("com.tencent.tinker.loader.")
-                && !name.equals(SystemClassLoaderAdder.CHECK_DEX_CLASS)
-                && !name.equals(CHECK_CLASSLOADER_CLASS))
-                || (applicationClassName != null && TextUtils.equals(applicationClassName, name))) {
+                && !name.equals(SystemClassLoaderAdder.CHECK_DEX_CLASS))
+                || (applicationClassName != null && applicationClassName.equals(name))) {
             return originClassLoader.loadClass(name);
         }
         return super.findClass(name);
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/SystemClassLoaderAdder.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/SystemClassLoaderAdder.java
index eef10d6f..bc32fad6 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/SystemClassLoaderAdder.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/SystemClassLoaderAdder.java
@@ -32,8 +32,13 @@
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.HashMap;
 import java.util.List;
 import java.util.ListIterator;
+import java.util.Map;
+import java.util.regex.Pattern;
 import java.util.zip.ZipFile;
 
 import dalvik.system.DexFile;
@@ -54,8 +59,9 @@ public static void installDexes(Application application, PathClassLoader loader,
         Log.i(TAG, "installDexes dexOptDir: " + dexOptDir.getAbsolutePath() + ", dex size:" + files.size());
 
         if (!files.isEmpty()) {
+            files = createSortedAdditionalPathEntries(files);
             ClassLoader classLoader = loader;
-            if (Build.VERSION.SDK_INT >= 24) {
+            if (Build.VERSION.SDK_INT >= 24 && !checkIsProtectedApp(files)) {
                 classLoader = AndroidNClassLoader.inject(loader, application);
             }
             //because in dalvik, if inner class is not the same classloader with it wrapper class.
@@ -108,6 +114,78 @@ private static boolean checkDexInstall(ClassLoader classLoader) throws ClassNotF
         return isPatch;
     }
 
+    private static boolean checkIsProtectedApp(List<File> files) {
+        if (!files.isEmpty()) {
+            for (File file : files) {
+                if (file == null) {
+                    continue;
+                }
+                if (file.getName().startsWith(ShareConstants.CHANGED_CLASSES_DEX_NAME)) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    private static List<File> createSortedAdditionalPathEntries(List<File> additionalPathEntries) {
+        final List<File> result = new ArrayList<>(additionalPathEntries);
+
+        final Pattern classNPattern = Pattern.compile("classes(?:[2-9]{0,1}|[1-9][0-9]+)\\.dex");
+        final Map<String, Boolean> matchesClassNPatternMemo = new HashMap<>();
+        for (File file : result) {
+            final String name = file.getName();
+            matchesClassNPatternMemo.put(name, classNPattern.matcher(name).matches());
+        }
+        Collections.sort(result, new Comparator<File>() {
+            @Override
+            public int compare(File lhs, File rhs) {
+                if (lhs == null && rhs == null) {
+                    return 0;
+                }
+                if (lhs == null) {
+                    return -1;
+                }
+                if (rhs == null) {
+                    return 1;
+                }
+
+                final String lhsName = lhs.getName();
+                final String rhsName = rhs.getName();
+                if (lhsName.equals(rhsName)) {
+                    return 0;
+                }
+
+                final String testDexSuffix = ShareConstants.TEST_DEX_NAME;
+                // test.dex should always be at tail.
+                if (lhsName.startsWith(testDexSuffix)) {
+                    return 1;
+                }
+                if (rhsName.startsWith(testDexSuffix)) {
+                    return -1;
+                }
+
+                final boolean isLhsNameMatchClassN = matchesClassNPatternMemo.get(lhsName);
+                final boolean isRhsNameMatchClassN = matchesClassNPatternMemo.get(rhsName);
+                if (isLhsNameMatchClassN && isRhsNameMatchClassN) {
+                    final int lhsDotPos = lhsName.lastIndexOf('.');
+                    final int rhsDotPos = rhsName.lastIndexOf('.');
+                    final int lhsId = (lhsDotPos > 7 ? Integer.parseInt(lhsName.substring(7, lhsDotPos)) : 1);
+                    final int rhsId = (rhsDotPos > 7 ? Integer.parseInt(rhsName.substring(7, rhsDotPos)) : 1);
+                    return (lhsId == rhsId ? 0 : (lhsId < rhsId ? -1 : 1));
+                } else if (isLhsNameMatchClassN) {
+                    // Dex name that matches class N rules should always be at first.
+                    return -1;
+                } else if (isRhsNameMatchClassN) {
+                    return 1;
+                }
+                return lhsName.compareTo(rhsName);
+            }
+        });
+
+        return result;
+    }
+
     /**
      * Installer for platform versions 23.
      */
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerDexLoader.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerDexLoader.java
index 2e5493f7..aed836fd 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerDexLoader.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerDexLoader.java
@@ -53,7 +53,6 @@
     private static final ArrayList<ShareDexDiffPatchInfo> dexList = new ArrayList<>();
 
 
-
     private static File testOptDexFile;
 
     private TinkerDexLoader() {
@@ -183,7 +182,6 @@ public void onFailed(File dexFile, File optimizedDir, Throwable thr) {
      * all the dex files in meta file exist?
      * fast check, only check whether exist
      *
-     * @param directory
      * @return boolean
      */
     public static boolean checkComplete(String directory, ShareSecurityCheck securityCheck, String oatDir, Intent intentResult) {
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java
index cf2e9f29..351d703b 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java
@@ -142,15 +142,22 @@ public static void isResourceCanPatch(Context context) throws Throwable {
         if (references == null) {
             throw new IllegalStateException("resource references is null");
         }
-        try {
+        // fix jianGuo pro has private field 'mAssets' with Resource
+        // try use mResourcesImpl first
+        if (SDK_INT >= 24) {
+            try {
+                // N moved the mAssets inside an mResourcesImpl field
+                resourcesImplFiled = Resources.class.getDeclaredField("mResourcesImpl");
+                resourcesImplFiled.setAccessible(true);
+            } catch (Throwable ignore) {
+                // for safety
+                assetsFiled = Resources.class.getDeclaredField("mAssets");
+                assetsFiled.setAccessible(true);
+            }
+        } else {
             assetsFiled = Resources.class.getDeclaredField("mAssets");
             assetsFiled.setAccessible(true);
-        } catch (Throwable ignore) {
-            // N moved the mAssets inside an mResourcesImpl field
-            resourcesImplFiled = Resources.class.getDeclaredField("mResourcesImpl");
-            resourcesImplFiled.setAccessible(true);
         }
-
 //        final Resources resources = context.getResources();
 //        isMiuiSystem = resources != null && MIUI_RESOURCE_CLASSNAME.equals(resources.getClass().getName());
 
@@ -265,12 +272,12 @@ private static void clearPreloadTypedArrayIssue(Resources resources) {
 
     private static boolean checkResUpdate(Context context) {
         try {
-            Log.e(TAG, "checkResUpdate success, found test resource assets file " + TEST_ASSETS_VALUE);
             context.getAssets().open(TEST_ASSETS_VALUE);
         } catch (Throwable e) {
             Log.e(TAG, "checkResUpdate failed, can't find test resource assets file " + TEST_ASSETS_VALUE + " e:" + e.getMessage());
             return false;
         }
+        Log.i(TAG, "checkResUpdate success, found test resource assets file " + TEST_ASSETS_VALUE);
         return true;
     }
 }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareConstants.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareConstants.java
index 83a2310c..1cb0d61f 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareConstants.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareConstants.java
@@ -20,7 +20,7 @@
  * Created by zhangshaowen on 16/3/24.
  */
 public class ShareConstants {
-    public static final String TINKER_VERSION = "1.7.8";
+    public static final String TINKER_VERSION = "1.7.11";
 
     public static final int BUFFER_SIZE         = 16384;
     public static final int MD5_LENGTH          = 32;
@@ -53,6 +53,8 @@
     public static final String JAR_SUFFIX = ".jar";
 
     public static final String TEST_DEX_NAME = "test.dex";
+    public static final String CHANGED_CLASSES_DEX_NAME = "changed_classes.dex";
+
 
     public static final String CHECK_DEX_INSTALL_FAIL = "checkDexInstall failed";
     public static final String CHECK_RES_INSTALL_FAIL = "checkResInstall failed";
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchFileUtil.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchFileUtil.java
index 1d4b03de..4b6f77e1 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchFileUtil.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchFileUtil.java
@@ -367,20 +367,11 @@ public static String getMD5(final File file) {
         try {
             fin = new FileInputStream(file);
             String md5 = getMD5(fin);
-            fin.close();
             return md5;
-
         } catch (Exception e) {
             return null;
-
         } finally {
-            try {
-                if (fin != null) {
-                    fin.close();
-                }
-            } catch (IOException e) {
-
-            }
+            closeQuietly(fin);
         }
     }
 
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchInfo.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchInfo.java
index 53d46932..be6dc661 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchInfo.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchInfo.java
@@ -37,7 +37,7 @@
     public static final String FINGER_PRINT         = "print";
     public static final String OAT_DIR              = "dir";
     public static final String DEFAULT_DIR   = ShareConstants.DEFAULT_DEX_OPTIMIZE_PATH;
-    private static final String TAG = "PatchInfo";
+    private static final String TAG = "Tinker.PatchInfo";
     public String oldVersion;
     public String newVersion;
     public String fingerPrint;
@@ -73,7 +73,7 @@ public static SharePatchInfo readAndCheckPropertyWithLock(File pathInfoFile, Fil
                     fileLock.close();
                 }
             } catch (IOException e) {
-                Log.i(TAG, "releaseInfoLock error", e);
+                Log.w(TAG, "releaseInfoLock error", e);
             }
         }
 
@@ -129,7 +129,7 @@ private static SharePatchInfo readAndCheckProperty(File pathInfoFile) {
                 oatDIr = properties.getProperty(OAT_DIR);
             } catch (IOException e) {
 //                e.printStackTrace();
-                Log.e(TAG, "read property failed, e:" + e);
+                Log.w(TAG, "read property failed, e:" + e);
             } finally {
                 SharePatchFileUtil.closeQuietly(inputStream);
             }
@@ -199,7 +199,8 @@ private static boolean rewritePatchInfoFile(File pathInfoFile, SharePatchInfo in
                 String comment = "from old version:" + info.oldVersion + " to new version:" + info.newVersion;
                 newProperties.store(outputStream, comment);
             } catch (Exception e) {
-                e.printStackTrace();
+//                e.printStackTrace();
+                Log.w(TAG, "write property failed, e:" + e);
             } finally {
                 SharePatchFileUtil.closeQuietly(outputStream);
             }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareReflectUtil.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareReflectUtil.java
index 7ebc1dbd..72b88059 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareReflectUtil.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareReflectUtil.java
@@ -19,6 +19,7 @@
 import android.content.Context;
 
 import java.lang.reflect.Array;
+import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
 import java.lang.reflect.Method;
 import java.util.Arrays;
@@ -104,6 +105,36 @@ public static Method findMethod(Object instance, String name, Class<?>... parame
             + " not found in " + instance.getClass());
     }
 
+    /**
+     * Locates a given constructor anywhere in the class inheritance hierarchy.
+     *
+     * @param instance       an object to search the constructor into.
+     * @param parameterTypes constructor parameter types
+     * @return a constructor object
+     * @throws NoSuchMethodException if the constructor cannot be located
+     */
+    public static Constructor<?> findConstructor(Object instance, Class<?>... parameterTypes)
+            throws NoSuchMethodException {
+        for (Class<?> clazz = instance.getClass(); clazz != null; clazz = clazz.getSuperclass()) {
+            try {
+                Constructor<?> ctor = clazz.getDeclaredConstructor(parameterTypes);
+
+                if (!ctor.isAccessible()) {
+                    ctor.setAccessible(true);
+                }
+
+                return ctor;
+            } catch (NoSuchMethodException e) {
+                // ignore and search next
+            }
+        }
+
+        throw new NoSuchMethodException("Constructor"
+                + " with parameters "
+                + Arrays.asList(parameterTypes)
+                + " not found in " + instance.getClass());
+    }
+
     /**
      * Replace the value of a field containing a non null array, by a new array containing the
      * elements of the original array plus the elements of extraElements.
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java
index e930f691..416fccbe 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java
@@ -372,23 +372,25 @@ private static String getProcessNameInternal(final Context context) {
         ActivityManager activityManager =
             (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
 
-        List<ActivityManager.RunningAppProcessInfo> appProcessList = activityManager
-            .getRunningAppProcesses();
+        if (activityManager != null) {
+            List<ActivityManager.RunningAppProcessInfo> appProcessList = activityManager
+                .getRunningAppProcesses();
 
-        if (appProcessList != null) {
-            try {
-                for (ActivityManager.RunningAppProcessInfo process : appProcessList) {
-                    if (process.pid == myPid) {
-                        myProcess = process;
-                        break;
+            if (appProcessList != null) {
+                try {
+                    for (ActivityManager.RunningAppProcessInfo process : appProcessList) {
+                        if (process.pid == myPid) {
+                            myProcess = process;
+                            break;
+                        }
                     }
+                } catch (Exception e) {
+                    Log.e(TAG, "getProcessNameInternal exception:" + e.getMessage());
                 }
-            } catch (Exception e) {
-                Log.e(TAG, "getProcessNameInternal exception:" + e.getMessage());
-            }
 
-            if (myProcess != null) {
-                return myProcess.processName;
+                if (myProcess != null) {
+                    return myProcess.processName;
+                }
             }
         }
 
diff --git a/tinker-build/tinker-patch-cli/tool_output/merge_mapping.py b/tinker-build/tinker-patch-cli/tool_output/merge_mapping.py
index 74ef14c6..a60fda39 100644
--- a/tinker-build/tinker-patch-cli/tool_output/merge_mapping.py
+++ b/tinker-build/tinker-patch-cli/tool_output/merge_mapping.py
@@ -97,7 +97,7 @@ def do_merge(self):
                 current_data = self.current_classes[key]
                 # 如果当前的类没有被混淆，则保留，否则用之前的mapping里面的内容覆盖
                 # ___.___ -> ___.___:
-                if current_data.raw_line.split("->")[0] == current_data.raw_line.split("->")[1][:-1]:
+                if current_data.raw_line.split("->")[0] != current_data.raw_line.split("->")[1][:-1]:
                     current_data.raw_line = data.raw_line
                 new_method_list = []
                 # 处理方法
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/TinkerPatchPlugin.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/TinkerPatchPlugin.groovy
index 9fe162e9..a3c6e0bc 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/TinkerPatchPlugin.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/TinkerPatchPlugin.groovy
@@ -20,6 +20,7 @@ import com.tencent.tinker.build.gradle.extension.*
 import com.tencent.tinker.build.gradle.task.*
 import com.tencent.tinker.build.util.FileOperation
 import com.tencent.tinker.build.util.TypedValue
+import com.tencent.tinker.build.util.Utils
 import org.gradle.api.GradleException
 import org.gradle.api.Plugin
 import org.gradle.api.Project
@@ -57,6 +58,18 @@ class TinkerPatchPlugin implements Plugin<Project> {
             throw new GradleException('generateTinkerApk: Android Application plugin required')
         }
 
+        def android = project.extensions.android
+
+        //open jumboMode
+        android.dexOptions.jumboMode = true
+
+        //close preDexLibraries
+        try {
+            android.dexOptions.preDexLibraries = false
+        } catch (Throwable e) {
+            //no preDexLibraries field, just continue
+        }
+
         project.afterEvaluate {
             def configuration = project.tinkerPatch
 
@@ -65,18 +78,6 @@ class TinkerPatchPlugin implements Plugin<Project> {
                 return
             }
 
-            def android = project.extensions.android
-
-            //open jumboMode
-            android.dexOptions.jumboMode = true
-
-            //close preDexLibraries
-            try {
-                android.dexOptions.preDexLibraries = false
-            } catch (Throwable e) {
-                //no preDexLibraries field, just continue
-            }
-
             project.logger.error("----------------------tinker build warning ------------------------------------")
             project.logger.error("tinker auto operation: ")
             project.logger.error("excluding annotation processor and source template from app packaging. Enable dx jumboMode to reduce package size.")
@@ -126,14 +127,12 @@ class TinkerPatchPlugin implements Plugin<Project> {
                 }
 
                 TinkerPatchSchemaTask tinkerPatchBuildTask = project.tasks.create("tinkerPatch${variantName}", TinkerPatchSchemaTask)
-                tinkerPatchBuildTask.dependsOn variant.assemble
 
                 tinkerPatchBuildTask.signConfig = variant.apkVariantData.variantConfiguration.signingConfig
 
                 variant.outputs.each { output ->
-                    tinkerPatchBuildTask.buildApkPath = output.outputFile
-                    File parentFile = output.outputFile
-                    tinkerPatchBuildTask.outputFolder = "${parentFile.getParentFile().getParentFile().getAbsolutePath()}/" + TypedValue.PATH_DEFAULT_OUTPUT + "/" + variant.dirName
+                    setPatchNewApkPath(configuration, output, variant, tinkerPatchBuildTask)
+                    setPatchOutputFolder(configuration, output, variant, tinkerPatchBuildTask)
                 }
 
                 // Create a task to add a build TINKER_ID to AndroidManifest.xml
@@ -194,6 +193,49 @@ class TinkerPatchPlugin implements Plugin<Project> {
         }
     }
 
+    /**
+     * Specify the output folder of tinker patch result.
+     *
+     * @param configuration the tinker configuration 'tinkerPatch'
+     * @param output the output of assemble result
+     * @param variant the variant
+     * @param tinkerPatchBuildTask the task that tinker patch uses
+     */
+    void setPatchOutputFolder(configuration, output, variant, tinkerPatchBuildTask) {
+        File parentFile = output.outputFile
+        String outputFolder = "${configuration.outputFolder}";
+        if (!Utils.isNullOrNil(outputFolder)) {
+            outputFolder = "${outputFolder}/${TypedValue.PATH_DEFAULT_OUTPUT}/${variant.dirName}"
+        } else {
+            outputFolder =
+                    "${parentFile.getParentFile().getParentFile().getAbsolutePath()}/${TypedValue.PATH_DEFAULT_OUTPUT}/${variant.dirName}"
+        }
+        tinkerPatchBuildTask.outputFolder = outputFolder
+    }
+
+    /**
+     * Specify the new apk path. If the new apk file is specified by {@code tinkerPatch.buildConfig.newApk},
+     * just use it as the new apk input for tinker patch, otherwise use the assemble output.
+     *
+     * @param project the project which applies this plugin
+     * @param configuration the tinker configuration 'tinkerPatch'
+     * @param output the output of assemble result
+     * @param variant the variant
+     * @param tinkerPatchBuildTask the task that tinker patch uses
+     */
+    void setPatchNewApkPath(configuration, output, variant, tinkerPatchBuildTask) {
+        def newApkPath = configuration.newApk;
+        if (!Utils.isNullOrNil(newApkPath)) {
+            if (FileOperation.isLegalFile(newApkPath)) {
+                tinkerPatchBuildTask.buildApkPath = newApkPath
+                return
+            }
+        }
+
+        tinkerPatchBuildTask.buildApkPath = output.outputFile
+        tinkerPatchBuildTask.dependsOn variant.assemble
+    }
+
     Task getMultiDexTask(Project project, String variantName) {
         String multiDexTaskName = "transformClassesWithMultidexlistFor${variantName}"
         return project.tasks.findByName(multiDexTaskName)
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerPatchExtension.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerPatchExtension.groovy
index c3b86141..3b99a728 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerPatchExtension.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerPatchExtension.groovy
@@ -30,6 +30,16 @@ public class TinkerPatchExtension {
      */
     String oldApk
 
+    /**
+     * Specify a folder for the outputs where place the tinker patch results.
+     */
+    String outputFolder
+
+    /**
+     * Specify the new apk path instead of running assemble task again.
+     */
+    String newApk;
+
     /**
      * If there is loader class changes,
      * or Activity, Service, Receiver, Provider change, it will terminal
@@ -52,6 +62,8 @@ public class TinkerPatchExtension {
 
     public TinkerPatchExtension() {
         oldApk = ""
+        outputFolder = ""
+        newApk = ""
         ignoreWarning = false
         useSign = true
         tinkerEnable = true
@@ -73,6 +85,8 @@ public class TinkerPatchExtension {
     @Override
     public String toString() {
         """| oldApk = ${oldApk}
+           | outputFolder = ${outputFolder}
+           | newApk = ${newApk}
            | ignoreWarning = ${ignoreWarning}
            | tinkerEnable = ${tinkerEnable}
            | useSign = ${useSign}
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerMultidexConfigTask.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerMultidexConfigTask.groovy
index bfd18ce4..2b148947 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerMultidexConfigTask.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerMultidexConfigTask.groovy
@@ -29,12 +29,12 @@ public class TinkerMultidexConfigTask extends DefaultTask {
     static final String MULTIDEX_CONFIG_PATH = TinkerPatchPlugin.TINKER_INTERMEDIATES + "tinker_multidexkeep.pro"
     static final String MULTIDEX_CONFIG_SETTINGS =
             "-keep public class * implements com.tencent.tinker.loader.app.ApplicationLifeCycle {\n" +
-                    "    <init>();\n" +
+                    "    <init>(...);\n" +
                     "    void onBaseContextAttached(android.content.Context);\n" +
                     "}\n" +
                     "\n" +
                     "-keep public class * extends com.tencent.tinker.loader.TinkerLoader {\n" +
-                    "    <init>();\n" +
+                    "    <init>(...);\n" +
                     "}\n" +
                     "\n" +
                     "-keep public class * extends android.app.Application {\n" +
@@ -66,7 +66,7 @@ public class TinkerMultidexConfigTask extends DefaultTask {
         // This class must be placed in main dex so that we can use it to check if new pathList
         // in AndroidNClassLoader is fine when under the protected app (whose main dex is always encrypted).
         lines.append("-keep class com.tencent.tinker.loader.TinkerTestAndroidNClassLoader {\n" +
-                "    <init>();\n" +
+                "    <init>(...);\n" +
                 "}\n")
              .append("\n")
 
@@ -80,7 +80,7 @@ public class TinkerMultidexConfigTask extends DefaultTask {
                 }
             }
             lines.append("-keep class " + pattern + " {\n" +
-                    "    <init>();\n" +
+                    "    <init>(...);\n" +
                     "}\n")
                     .append("\n")
         }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java
index 94b961d1..ee541a1f 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java
@@ -42,6 +42,7 @@
 import org.jf.dexlib2.iface.DexFile;
 import org.jf.dexlib2.iface.Field;
 import org.jf.dexlib2.iface.Method;
+import org.jf.dexlib2.iface.MethodImplementation;
 import org.jf.dexlib2.writer.builder.BuilderField;
 import org.jf.dexlib2.writer.builder.BuilderMethod;
 import org.jf.dexlib2.writer.builder.DexBuilder;
@@ -230,18 +231,24 @@ private void generateChangedClassesDexFile() throws IOException {
 
         Set<DexClassInfo> classInfosInChangedClassesDex = collector.doCollect(oldDexGroup, newDexGroup);
 
-        Set<String> descsOfClassInChangedClassesDex = new HashSet<>();
         Set<Dex> owners = new HashSet<>();
+        Map<Dex, Set<String>> ownerToDescOfChangedClassesMap = new HashMap<>();
         for (DexClassInfo classInfo : classInfosInChangedClassesDex) {
-            descsOfClassInChangedClassesDex.add(classInfo.classDesc);
             owners.add(classInfo.owner);
+            Set<String> descOfChangedClasses = ownerToDescOfChangedClassesMap.get(classInfo.owner);
+            if (descOfChangedClasses == null) {
+                descOfChangedClasses = new HashSet<>();
+                ownerToDescOfChangedClassesMap.put(classInfo.owner, descOfChangedClasses);
+            }
+            descOfChangedClasses.add(classInfo.classDesc);
         }
 
         DexBuilder dexBuilder = DexBuilder.makeDexBuilder();
         for (Dex dex : owners) {
+            Set<String> descOfChangedClassesInCurrDex = ownerToDescOfChangedClassesMap.get(dex);
             DexFile dexFile = new DexBackedDexFile(org.jf.dexlib2.Opcodes.forApi(20), dex.getBytes());
             for (org.jf.dexlib2.iface.ClassDef classDef : dexFile.getClasses()) {
-                if (!descsOfClassInChangedClassesDex.contains(classDef.getType())) {
+                if (!descOfChangedClassesInCurrDex.contains(classDef.getType())) {
                     continue;
                 }
 
@@ -262,6 +269,10 @@ private void generateChangedClassesDexFile() throws IOException {
                 List<BuilderMethod> builderMethods = new ArrayList<>();
 
                 for (Method method : classDef.getMethods()) {
+                    MethodImplementation methodImpl = method.getImplementation();
+                    if (methodImpl != null) {
+                        methodImpl = new BuilderMutableMethodImplementation(dexBuilder, methodImpl);
+                    }
                     BuilderMethod builderMethod = dexBuilder.internMethod(
                             method.getDefiningClass(),
                             method.getName(),
@@ -269,7 +280,7 @@ private void generateChangedClassesDexFile() throws IOException {
                             method.getReturnType(),
                             method.getAccessFlags(),
                             method.getAnnotations(),
-                            new BuilderMutableMethodImplementation(dexBuilder, method.getImplementation())
+                            methodImpl
                     );
                     builderMethods.add(builderMethod);
                 }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/ChangedClassesDexClassInfoCollector.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/ChangedClassesDexClassInfoCollector.java
index c560106d..6fb11914 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/ChangedClassesDexClassInfoCollector.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/ChangedClassesDexClassInfoCollector.java
@@ -61,7 +61,7 @@ public ChangedClassesDexClassInfoCollector clearExcludedClassPatterns() {
     }
 
     public ChangedClassesDexClassInfoCollector setLogger(DexPatcherLogger.IDexPatcherLogger loggerImpl) {
-        this.logger.setLoggerImpl(loggerImpl);
+        logger.setLoggerImpl(loggerImpl);
         return this;
     }
 
@@ -71,11 +71,13 @@ public ChangedClassesDexClassInfoCollector setIncludeRefererToRefererAffectedCla
     }
 
     public Set<DexClassInfo> doCollect(DexGroup oldDexGroup, DexGroup newDexGroup) {
+        final Set<String> classDescsInResult = new HashSet<>();
         final Set<DexClassInfo> result = new HashSet<>();
 
         DexClassesComparator dexClassCmptor = new DexClassesComparator("*");
         dexClassCmptor.setCompareMode(DexClassesComparator.COMPARE_MODE_NORMAL);
         dexClassCmptor.setIgnoredRemovedClassDescPattern(excludedClassPatterns);
+        dexClassCmptor.setLogger(logger.getLoggerImpl());
         dexClassCmptor.startCheck(oldDexGroup, newDexGroup);
 
         // So far we collected infos of all added, changed, and deleted classes.
@@ -90,6 +92,10 @@ public ChangedClassesDexClassInfoCollector setIncludeRefererToRefererAffectedCla
             result.add(newClassInfo);
         }
 
+        for (DexClassInfo classInfo : result) {
+            classDescsInResult.add(classInfo.classDesc);
+        }
+
         if (includeRefererToRefererAffectedClasses) {
             // Then we also need to add classes who refer to classes with referrer
             // affected changes to the result. (referrer affected change means the changes
@@ -101,7 +107,8 @@ public ChangedClassesDexClassInfoCollector setIncludeRefererToRefererAffectedCla
             Set<DexClassInfo> oldClassInfos = oldDexGroup.getClassInfosInDexesWithDuplicateCheck();
 
             for (DexClassInfo oldClassInfo : oldClassInfos) {
-                if (isClassReferToAnyClasses(oldClassInfo, referrerAffectedChangedClassDescs)) {
+                if (!classDescsInResult.contains(oldClassInfo.classDesc)
+                        && isClassReferToAnyClasses(oldClassInfo, referrerAffectedChangedClassDescs)) {
                     logger.i(TAG, "Add class %s in old dex to changed classes dex since it is affected by modified referee.", oldClassInfo.classDesc);
                     result.add(oldClassInfo);
                 }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/DexClassesComparator.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/DexClassesComparator.java
index 796c0102..5c2eb055 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/DexClassesComparator.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/DexClassesComparator.java
@@ -228,19 +228,22 @@ public void startCheck(DexGroup oldDexGroup, DexGroup newDexGroup) {
             // from result.
             if (Utils.isStringMatchesPatterns(desc, patternsOfIgnoredRemovedClassDesc)) {
                 logger.i(TAG, "Ignored deleted class: %s", desc);
-                continue;
             } else {
                 logger.i(TAG, "Deleted class: %s", desc);
+                deletedClassInfoList.add(oldClassDescriptorToClassInfoMap.get(desc));
             }
-            deletedClassInfoList.add(oldClassDescriptorToClassInfoMap.get(desc));
         }
 
         Set<String> addedClassDescs = new HashSet<>(newDescriptorOfClassesToCheck);
         addedClassDescs.removeAll(oldDescriptorOfClassesToCheck);
 
         for (String desc : addedClassDescs) {
-            logger.i(TAG, "Added class: %s", desc);
-            addedClassInfoList.add(newClassDescriptorToClassInfoMap.get(desc));
+            if (Utils.isStringMatchesPatterns(desc, patternsOfIgnoredRemovedClassDesc)) {
+                logger.i(TAG, "Ignored added class: %s", desc);
+            } else {
+                logger.i(TAG, "Added class: %s", desc);
+                addedClassInfoList.add(newClassDescriptorToClassInfoMap.get(desc));
+            }
         }
 
         Set<String> mayBeChangedClassDescs = new HashSet<>(oldDescriptorOfClassesToCheck);
@@ -257,10 +260,14 @@ public void startCheck(DexGroup oldDexGroup, DexGroup newDexGroup) {
                             oldClassInfo.classDef,
                             newClassInfo.classDef
                     )) {
-                        logger.i(TAG, "Changed class: %s", desc);
-                        changedClassDescToClassInfosMap.put(
-                                desc, new DexClassInfo[]{oldClassInfo, newClassInfo}
-                        );
+                        if (Utils.isStringMatchesPatterns(desc, patternsOfIgnoredRemovedClassDesc)) {
+                            logger.i(TAG, "Ignored changed class: %s", desc);
+                        } else {
+                            logger.i(TAG, "Changed class: %s", desc);
+                            changedClassDescToClassInfosMap.put(
+                                    desc, new DexClassInfo[]{oldClassInfo, newClassInfo}
+                            );
+                        }
                     }
                     break;
                 }
@@ -271,10 +278,14 @@ public void startCheck(DexGroup oldDexGroup, DexGroup newDexGroup) {
                             oldClassInfo.classDef,
                             newClassInfo.classDef
                     )) {
-                        logger.i(TAG, "Ref-changed class: %s", desc);
-                        changedClassDescToClassInfosMap.put(
-                                desc, new DexClassInfo[]{oldClassInfo, newClassInfo}
-                        );
+                        if (Utils.isStringMatchesPatterns(desc, patternsOfIgnoredRemovedClassDesc)) {
+                            logger.i(TAG, "Ignored referrer-affected changed class: %s", desc);
+                        } else {
+                            logger.i(TAG, "Referrer-affected change class: %s", desc);
+                            changedClassDescToClassInfosMap.put(
+                                    desc, new DexClassInfo[]{oldClassInfo, newClassInfo}
+                            );
+                        }
                     }
                     break;
                 }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/Utils.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/Utils.java
index fabadf31..400bc9b0 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/Utils.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/Utils.java
@@ -74,6 +74,10 @@ public static String convertToPatternString(String input) {
         return input;
     }
 
+    public static boolean isNullOrNil(final String object) {
+        return (object == null) || (object.length() <= 0);
+    }
+
     public static boolean isStringMatchesPatterns(String str, Collection<Pattern> patterns) {
         for (Pattern pattern : patterns) {
             if (pattern.matcher(str).matches()) {
diff --git a/tinker-sample-android/gradle.properties b/tinker-sample-android/gradle.properties
index 3151f762..8d774e53 100644
--- a/tinker-sample-android/gradle.properties
+++ b/tinker-sample-android/gradle.properties
@@ -17,4 +17,4 @@
 # http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
 # org.gradle.parallel=true
 
-TINKER_VERSION=1.7.9
+TINKER_VERSION=1.7.11
