diff --git a/.github/ISSUE_TEMPLATE.md b/.github/ISSUE_TEMPLATE.md
new file mode 100644
index 00000000..bf067267
--- /dev/null
+++ b/.github/ISSUE_TEMPLATE.md
@@ -0,0 +1,27 @@
+## Issue/提问须知
+**在提交issue之前，我们应该先查询是否已经有相关的issue以及[常见问题](https://github.com/Tencent/tinker/wiki/Tinker-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98)。提交issue时，我们需要写明issue的原因，以及编译或运行过程的日志(加载进程以及Patch进程)。issue需要以下面的格式：**
+
+```
+异常类型：app运行时异常/编译异常
+
+手机型号：如:Nexus 5(如是编译异常，则可以不填)
+
+手机系统版本：如:Android 5.0 (如是编译异常，则可以不填)
+
+tinker版本：如:1.7.7
+
+gradle版本：如:2.10
+
+是否使用热更新SDK： 如 TinkerPatch SDK 或者 Bugly SDK
+
+系统：如:Mac
+
+堆栈/日志：
+1. 如是编译异常，请在执行gradle命令时，加上--stacktrace;
+2. 日志我们需要过滤"Tinker."关键字;
+3. 对于合成失败的情况，请给出:patch进程的日志,这里需要将Android Moniter右上角设为No Filter。
+```
+
+提问题时若使用`不能用/没效果/有问题/报错`此类模糊表达，但又没给出任何代码截图报错的，将绝对不会有任何反馈。这种issue也是一律直接关闭的,大家可以参阅[提问的智慧](https://github.com/tvvocold/How-To-Ask-Questions-The-Smart-Way)。
+
+Tinker是一个开源项目，希望大家遇到问题时要学会先思考，看看sample与Tinker的源码，更鼓励大家给我们提pr.
\ No newline at end of file
diff --git a/README.md b/README.md
index 48b74f87..be8131b7 100644
--- a/README.md
+++ b/README.md
@@ -1,8 +1,8 @@
 ## Tinker
 [![license](http://img.shields.io/badge/license-BSD3-brightgreen.svg?style=flat)](https://github.com/Tencent/tinker/blob/master/LICENSE)
-[![Release Version](https://img.shields.io/badge/release-1.7.3-red.svg)](https://github.com/Tencent/tinker/releases) 
+[![Release Version](https://img.shields.io/badge/release-1.7.11-red.svg)](https://github.com/Tencent/tinker/releases) 
 [![PRs Welcome](https://img.shields.io/badge/PRs-welcome-brightgreen.svg)](https://github.com/Tencent/tinker/pulls)
-[![WeChat Approved](https://img.shields.io/badge/Wechat_Approved-1.6.2-red.svg)](https://github.com/Tencent/tinker/wiki)
+[![WeChat Approved](https://img.shields.io/badge/Wechat_Approved-1.7.9-red.svg)](https://github.com/Tencent/tinker/wiki)
 
 Tinker is a hot-fix solution library for Android, it supports dex, library and resources update without reinstalling apk.
 
@@ -14,7 +14,7 @@ Add tinker-gradle-plugin as a dependency in your main `build.gradle` in the root
 ```gradle
 buildscript {
     dependencies {
-        classpath ('com.tencent.tinker:tinker-patch-gradle-plugin:1.7.3')
+        classpath ('com.tencent.tinker:tinker-patch-gradle-plugin:1.7.11')
     }
 }
 ```
@@ -24,9 +24,9 @@ Then you need to "apply" the plugin and add dependencies by adding the following
 ```gradle
 dependencies {
     //optional, help to generate the final application 
-    provided('com.tencent.tinker:tinker-android-anno:1.7.3')
+    provided('com.tencent.tinker:tinker-android-anno:1.7.11')
     //tinker's main Android lib
-    compile('com.tencent.tinker:tinker-android-lib:1.7.3') 
+    compile('com.tencent.tinker:tinker-android-lib:1.7.11') 
 }
 ...
 ...
diff --git a/build.gradle b/build.gradle
index 143ac207..41297d17 100644
--- a/build.gradle
+++ b/build.gradle
@@ -21,21 +21,6 @@ allprojects {
         enabled = false
         options.setEncoding('UTF-8')
     }
-
-    apply plugin: 'checkstyle'
-
-    checkstyle {
-        configFile rootProject.file('checkstyle.xml')
-        toolVersion '6.19'
-        ignoreFailures false
-        showViolations true
-    }
-
-    task('checkstyle', type: Checkstyle) {
-        source 'src/main/java'
-        include '**/*.java'
-        classpath = files()
-    }
 }
 
 ext {
diff --git a/findbugs-exclude.xml b/findbugs-exclude.xml
new file mode 100644
index 00000000..e3c7c348
--- /dev/null
+++ b/findbugs-exclude.xml
@@ -0,0 +1,9 @@
+<FindBugsFilter>
+
+    <Match>
+        <Class name="~.*R\$.*" />
+    </Match>
+    <Match>
+        <Class name="~.*Manifest\$.*" />
+    </Match>
+</FindBugsFilter>
\ No newline at end of file
diff --git a/gradle.properties b/gradle.properties
index 89e660e7..0cddaacf 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -16,5 +16,5 @@
 # This option should only be used with decoupled projects. More details, visit
 # http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
 # org.gradle.parallel=true
-VERSION_NAME_PREFIX=1.7.3
+VERSION_NAME_PREFIX=1.7.11
 VERSION_NAME_SUFFIX=
\ No newline at end of file
diff --git a/gradle/android-artifacts.gradle b/gradle/android-artifacts.gradle
index 1d14ded6..cd4ded81 100644
--- a/gradle/android-artifacts.gradle
+++ b/gradle/android-artifacts.gradle
@@ -90,5 +90,5 @@ publishing {
 task buildAndPublishTinkerToLocalMaven(dependsOn: ['build', 'publishTinkerPatchPublicationToMavenLocal']) {
     group = 'tinker'
 }
-//depend checkstyle
-project.tasks.getByName("check").dependsOn tasks.getByName("checkstyle")
+
+apply from: rootProject.file('gradle/check.gradle')
\ No newline at end of file
diff --git a/gradle/check.gradle b/gradle/check.gradle
new file mode 100644
index 00000000..4205d8b1
--- /dev/null
+++ b/gradle/check.gradle
@@ -0,0 +1,74 @@
+apply plugin: 'checkstyle'
+
+
+checkstyle {
+    configFile rootProject.file('checkstyle.xml')
+    toolVersion '6.19'
+    ignoreFailures false
+    showViolations true
+}
+
+task('checkstyle', type: Checkstyle) {
+    source 'src/main/java'
+    include '**/*.java'
+    classpath = files()
+}
+
+check.dependsOn('checkstyle')
+
+
+//apply plugin: 'pmd'
+//
+//pmd {
+//    toolVersion '5.4.0'
+//}
+//
+//task pmd(type: Pmd) {
+//    targetJdk = TargetJdk.VERSION_1_7
+//
+//    description 'Run pmd'
+//    group 'verification'
+//
+//    // If ruleSets is not empty, it seems to contain some
+//    // defaults which override rules in the ruleset file...
+//    ruleSets = []
+//    ruleSetFiles = rootProject.files('pmd-ruleset.xml')
+//    source = fileTree('src/main/java')
+//    ignoreFailures = false
+//
+//    reports {
+//        xml.enabled = false
+//        html.enabled = true
+//    }
+//}
+//
+//check.dependsOn('pmd')
+
+//apply plugin: 'findbugs'
+//
+//def classTree = 'build/intermediates/classes/debug'
+//
+//if (project.plugins.hasPlugin('java')) {
+//    classTree = 'build/classes'
+//}
+//task findbugs(type: FindBugs) {
+//
+//    description 'Run findbugs'
+//    group 'verification'
+//
+//    classes = fileTree(classTree)
+//    source = fileTree('src/main/java/')
+//    classpath = files()
+//
+//    effort = 'default'
+//
+//    excludeFilter = rootProject.file("findbugs-exclude.xml")
+//
+//    reports {
+//        xml.enabled = false
+//        html.enabled = true
+//    }
+//    ignoreFailures = true
+//}
+
+//check.dependsOn('findbugs')
\ No newline at end of file
diff --git a/gradle/gradle-mvn-push.gradle b/gradle/gradle-mvn-push.gradle
index 9e795143..66196e32 100644
--- a/gradle/gradle-mvn-push.gradle
+++ b/gradle/gradle-mvn-push.gradle
@@ -125,14 +125,10 @@ task buildAndPublishRepo(dependsOn: ['build', 'uploadArchives']) {
     }
 }
 
-//depend checkstyle
-tasks.getByName("uploadArchives").dependsOn tasks.getByName("checkstyle")
-tasks.getByName("bintrayUpload").dependsOn tasks.getByName("checkstyle")
-
 tasks.getByName("bintrayUpload") {
     it.doFirst {
         if (!isReleaseBuild()) {
             throw new GradleException("bintrayUpload only support release version")
         }
     }
-}
\ No newline at end of file
+}
diff --git a/gradle/java-artifacts.gradle b/gradle/java-artifacts.gradle
index 8f498a2e..9b204192 100644
--- a/gradle/java-artifacts.gradle
+++ b/gradle/java-artifacts.gradle
@@ -43,5 +43,4 @@ task buildAndPublishTinkerToLocalMaven(dependsOn: ['build', 'publishTinkerPatchP
     group = 'tinker'
 }
 
-//depend checkstyle
-project.tasks.getByName("check").dependsOn tasks.getByName("checkstyle")
\ No newline at end of file
+apply from: rootProject.file('gradle/check.gradle')
\ No newline at end of file
diff --git a/pmd-ruleset.xml b/pmd-ruleset.xml
new file mode 100644
index 00000000..ca65331c
--- /dev/null
+++ b/pmd-ruleset.xml
@@ -0,0 +1,44 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
+<ruleset name="PMD.rul" xmlns="http://pmd.sourceforge.net/ruleset/2.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://pmd.sourceforge.net/ruleset/2.0.0 http://pmd.sourceforge.net/ruleset_2_0_0.xsd">
+
+    <description>This ruleset was created from PMD.rul</description>
+
+    <rule ref="rulesets/java/basic.xml">
+        <exclude name="AvoidBranchingStatementAsLastInLoop"/>
+    </rule>
+    <rule ref="rulesets/java/braces.xml"/>
+    <rule ref="rulesets/java/strings.xml">
+        <!-- TODO: This warns about annotations, apparently fixed in a later version. -->
+        <exclude name="AvoidDuplicateLiterals"/>
+    </rule>
+    <rule ref="rulesets/java/unusedcode.xml"/>
+
+    <rule ref="rulesets/java/design.xml">
+        <exclude name="ConfusingTernary"/>
+        <exclude name="EmptyMethodInAbstractClassShouldBeAbstract"/>
+        <exclude name="AvoidSynchronizedAtMethodLevel"/>
+
+        <!-- This check breaks on double checked locking which is safe in Java 6/7 -->
+        <exclude name="NonThreadSafeSingleton"/>
+        <!-- This check breaks the builder pattern, I didn't find the solution-->
+        <exclude name="AccessorClassGeneration"/>
+        <!-- TODO: Fix these -->
+        <exclude name="AvoidReassigningParameters"/>
+        <exclude name="GodClass"/>
+
+    </rule>
+
+    <rule ref="rulesets/java/design.xml/AvoidDeeplyNestedIfStmts">
+        <properties>
+            <property name="problemDepth" value="5"/>
+        </properties>
+    </rule>
+
+    <rule message="Commented blocks are ok" ref="rulesets/java/empty.xml/EmptyCatchBlock">
+        <properties>
+            <property name="allowCommentedBlocks" value="true"/>
+        </properties>
+    </rule>
+</ruleset>
\ No newline at end of file
diff --git a/third-party/aosp-dexutils/build.gradle b/third-party/aosp-dexutils/build.gradle
index 4153cea7..1844d317 100644
--- a/third-party/aosp-dexutils/build.gradle
+++ b/third-party/aosp-dexutils/build.gradle
@@ -5,7 +5,8 @@ apply plugin: 'java'
 version rootProject.ext.VERSION_NAME
 group rootProject.ext.GROUP
 
-task buildSdk(type: Copy, dependsOn: [build]) {
+task buildTinkerSdk(type: Copy, dependsOn: [build]) {
+    group = "tinker"
     from('build/libs') {
         include '*.jar'
         exclude '*javadoc.jar'
diff --git a/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/io/DexDataBuffer.java b/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/io/DexDataBuffer.java
index f2e16ed6..93c9da09 100644
--- a/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/io/DexDataBuffer.java
+++ b/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/io/DexDataBuffer.java
@@ -51,6 +51,8 @@
     public static final int DEFAULT_BUFFER_SIZE = 512;
 
     private static final short[] EMPTY_SHORT_ARRAY = new short[0];
+    private static final Code.Try[] EMPTY_TRY_ARRAY = new Code.Try[0];
+    private static final Code.CatchHandler[] EMPTY_CATCHHANDLER_ARRAY = new Code.CatchHandler[0];
 
     private ByteBuffer data;
     private int dataBound;
@@ -235,8 +237,8 @@ public Code readCode() {
         Code.Try[] tries;
         Code.CatchHandler[] catchHandlers;
         if (triesSize > 0) {
-            if (instructions.length % 2 == 1) {
-                readShort(); // padding
+            if ((instructions.length & 1) == 1) {
+                skip(2); // padding
             }
 
             /*
@@ -252,8 +254,8 @@ public Code readCode() {
             tries = readTries(triesSize, catchHandlers);
             data.position(posAfterCatchHandlers);
         } else {
-            tries = new Code.Try[0];
-            catchHandlers = new Code.CatchHandler[0];
+            tries = EMPTY_TRY_ARRAY;
+            catchHandlers = EMPTY_CATCHHANDLER_ARRAY;
         }
         return new Code(off, registersSize, insSize, outsSize, debugInfoOffset, instructions,
                 tries, catchHandlers);
diff --git a/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/utils/SparseBoolArray.java b/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/utils/SparseBoolArray.java
new file mode 100644
index 00000000..1e43ce9b
--- /dev/null
+++ b/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/utils/SparseBoolArray.java
@@ -0,0 +1,355 @@
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.android.utils;
+
+/**
+ * SparseBoolArrays map integers to booleans.  Unlike a normal array of booleans,
+ * there can be gaps in the indices.  It is intended to be more memory efficient
+ * than using a HashMap to map Integers to Booleans, both because it avoids
+ * auto-boxing keys and values and its data structure doesn't rely on an extra entry object
+ * for each mapping.
+ *
+ * <p>Note that this container keeps its mappings in an array data structure,
+ * using a binary search to find keys.  The implementation is not intended to be appropriate for
+ * data structures
+ * that may contain large numbers of items.  It is generally slower than a traditional
+ * HashMap, since lookups require a binary search and adds and removes require inserting
+ * and deleting entries in the array.  For containers holding up to hundreds of items,
+ * the performance difference is not significant, less than 50%.</p>
+ *
+ * <p>It is possible to iterate over the items in this container using
+ * {@link #keyAt(int)} and {@link #valueAt(int)}. Iterating over the keys using
+ * <code>keyAt(int)</code> with ascending values of the index will return the
+ * keys in ascending order, or the values corresponding to the keys in ascending
+ * order in the case of <code>valueAt(int)</code>.</p>
+ */
+public class SparseBoolArray implements Cloneable {
+    private static final int[] EMPTY_INT_ARRAY = new int[0];
+    private static final boolean[] EMPTY_BOOL_ARRAY = new boolean[0];
+    private int[] mKeys;
+    private boolean[] mValues;
+    private int   mSize;
+
+    public static class KeyNotFoundException extends Exception {
+        public KeyNotFoundException() {
+            super();
+        }
+
+        public KeyNotFoundException(String msg) {
+            super(msg);
+        }
+    }
+
+    /**
+     * Creates a new SparseIntArray containing no mappings.
+     */
+    public SparseBoolArray() {
+        this(10);
+    }
+
+    /**
+     * Creates a new SparseIntArray containing no mappings that will not
+     * require any additional memory allocation to store the specified
+     * number of mappings.  If you supply an initial capacity of 0, the
+     * sparse array will be initialized with a light-weight representation
+     * not requiring any additional array allocations.
+     */
+    public SparseBoolArray(int initialCapacity) {
+        if (initialCapacity == 0) {
+            mKeys = SparseBoolArray.EMPTY_INT_ARRAY;
+            mValues = SparseBoolArray.EMPTY_BOOL_ARRAY;
+        } else {
+            mKeys = new int[initialCapacity];
+            mValues = new boolean[initialCapacity];
+        }
+        mSize = 0;
+    }
+
+    /**
+     * Given the current size of an array, returns an ideal size to which the array should grow.
+     * This is typically double the given size, but should not be relied upon to do so in the
+     * future.
+     */
+    private static int growSize(int currentSize) {
+        return currentSize <= 4 ? 8 : currentSize + (currentSize >> 1);
+    }
+
+    @Override
+    public SparseBoolArray clone() {
+        SparseBoolArray clone = null;
+        try {
+            clone = (SparseBoolArray) super.clone();
+            clone.mKeys = mKeys.clone();
+            clone.mValues = mValues.clone();
+        } catch (CloneNotSupportedException cnse) {
+            /* ignore */
+        }
+        return clone;
+    }
+
+    /**
+     * Gets the int mapped from the specified key, or a {@code KeyNotFoundException} is thrown
+     * if no such mapping has been made.
+     */
+    public boolean get(int key) throws KeyNotFoundException {
+        int i = binarySearch(mKeys, mSize, key);
+
+        if (i < 0) {
+            throw new KeyNotFoundException("" + key);
+        } else {
+            return mValues[i];
+        }
+    }
+
+    /**
+     * Removes the mapping from the specified key, if there was any.
+     */
+    public void delete(int key) {
+        int i = binarySearch(mKeys, mSize, key);
+
+        if (i >= 0) {
+            removeAt(i);
+        }
+    }
+
+    /**
+     * Removes the mapping at the given index.
+     */
+    public void removeAt(int index) {
+        System.arraycopy(mKeys, index + 1, mKeys, index, mSize - (index + 1));
+        System.arraycopy(mValues, index + 1, mValues, index, mSize - (index + 1));
+        --mSize;
+    }
+
+    /**
+     * Adds a mapping from the specified key to the specified value,
+     * replacing the previous mapping from the specified key if there
+     * was one.
+     */
+    public void put(int key, boolean value) {
+        int i = binarySearch(mKeys, mSize, key);
+
+        if (i >= 0) {
+            mValues[i] = value;
+        } else {
+            i = ~i;
+            mKeys = insertElementIntoIntArray(mKeys, mSize, i, key);
+            mValues = insertElementIntoBoolArray(mValues, mSize, i, value);
+            ++mSize;
+        }
+    }
+
+    /**
+     * Returns the number of key-value mappings that this SparseIntArray
+     * currently stores.
+     */
+    public int size() {
+        return mSize;
+    }
+
+    /**
+     * Given an index in the range <code>0...size()-1</code>, returns
+     * the key from the <code>index</code>th key-value mapping that this
+     * SparseIntArray stores.
+     *
+     * <p>The keys corresponding to indices in ascending order are guaranteed to
+     * be in ascending order, e.g., <code>keyAt(0)</code> will return the
+     * smallest key and <code>keyAt(size()-1)</code> will return the largest
+     * key.</p>
+     */
+    public int keyAt(int index) {
+        return mKeys[index];
+    }
+
+    /**
+     * Given an index in the range <code>0...size()-1</code>, returns
+     * the value from the <code>index</code>th key-value mapping that this
+     * SparseIntArray stores.
+     *
+     * <p>The values corresponding to indices in ascending order are guaranteed
+     * to be associated with keys in ascending order, e.g.,
+     * <code>valueAt(0)</code> will return the value associated with the
+     * smallest key and <code>valueAt(size()-1)</code> will return the value
+     * associated with the largest key.</p>
+     */
+    public boolean valueAt(int index) {
+        return mValues[index];
+    }
+
+    /**
+     * Returns the index for which {@link #keyAt} would return the
+     * specified key, or a negative number if the specified
+     * key is not mapped.
+     */
+    public int indexOfKey(int key) {
+        return binarySearch(mKeys, mSize, key);
+    }
+
+    /**
+     * Returns whether the {@code key} is exists.
+     */
+    public boolean containsKey(int key) {
+        return indexOfKey(key) >= 0;
+    }
+
+    /**
+     * Returns an index for which {@link #valueAt} would return the
+     * specified key, or a negative number if no keys map to the
+     * specified value.
+     * Beware that this is a linear search, unlike lookups by key,
+     * and that multiple keys can map to the same value and this will
+     * find only one of them.
+     */
+    public int indexOfValue(boolean value) {
+        for (int i = 0; i < mSize; ++i) {
+            if (mValues[i] == value) {
+                return i;
+            }
+        }
+        return -1;
+    }
+
+    /**
+     * Removes all key-value mappings from this SparseIntArray.
+     */
+    public void clear() {
+        mSize = 0;
+    }
+
+    /**
+     * Puts a key/value pair into the array, optimizing for the case where
+     * the key is greater than all existing keys in the array.
+     */
+    public void append(int key, boolean value) {
+        if (mSize != 0 && key <= mKeys[mSize - 1]) {
+            put(key, value);
+            return;
+        }
+
+        mKeys = appendElementIntoIntArray(mKeys, mSize, key);
+        mValues = appendElementIntoBoolArray(mValues, mSize, value);
+        mSize++;
+    }
+
+    private int binarySearch(int[] array, int size, int value) {
+        int lo = 0;
+        int hi = size - 1;
+
+        while (lo <= hi) {
+            int mid = (lo + hi) >>> 1;
+            int midVal = array[mid];
+
+            if (midVal < value) {
+                lo = mid + 1;
+            } else if (midVal > value) {
+                hi = mid - 1;
+            } else {
+                return mid;  // value found
+            }
+        }
+        return ~lo;  // value not present
+    }
+
+    private int[] appendElementIntoIntArray(int[] array, int currentSize, int element) {
+        if (currentSize > array.length) {
+            throw new IllegalArgumentException("Bad currentSize, originalSize: " + array.length + " currentSize: " + currentSize);
+        }
+        if (currentSize + 1 > array.length) {
+            int[] newArray = new int[SparseBoolArray.growSize(currentSize)];
+            System.arraycopy(array, 0, newArray, 0, currentSize);
+            array = newArray;
+        }
+        array[currentSize] = element;
+        return array;
+    }
+
+    private boolean[] appendElementIntoBoolArray(boolean[] array, int currentSize, boolean element) {
+        if (currentSize > array.length) {
+            throw new IllegalArgumentException("Bad currentSize, originalSize: " + array.length + " currentSize: " + currentSize);
+        }
+        if (currentSize + 1 > array.length) {
+            boolean[] newArray = new boolean[SparseBoolArray.growSize(currentSize)];
+            System.arraycopy(array, 0, newArray, 0, currentSize);
+            array = newArray;
+        }
+        array[currentSize] = element;
+        return array;
+    }
+
+    private int[] insertElementIntoIntArray(int[] array, int currentSize, int index, int element) {
+        if (currentSize > array.length) {
+            throw new IllegalArgumentException("Bad currentSize, originalSize: " + array.length + " currentSize: " + currentSize);
+        }
+
+        if (currentSize + 1 <= array.length) {
+            System.arraycopy(array, index, array, index + 1, currentSize - index);
+            array[index] = element;
+            return array;
+        }
+
+        int[] newArray = new int[SparseBoolArray.growSize(currentSize)];
+        System.arraycopy(array, 0, newArray, 0, index);
+        newArray[index] = element;
+        System.arraycopy(array, index, newArray, index + 1, array.length - index);
+        return newArray;
+    }
+
+    private boolean[] insertElementIntoBoolArray(boolean[] array, int currentSize, int index, boolean element) {
+        if (currentSize > array.length) {
+            throw new IllegalArgumentException("Bad currentSize, originalSize: " + array.length + " currentSize: " + currentSize);
+        }
+
+        if (currentSize + 1 <= array.length) {
+            System.arraycopy(array, index, array, index + 1, currentSize - index);
+            array[index] = element;
+            return array;
+        }
+
+        boolean[] newArray = new boolean[SparseBoolArray.growSize(currentSize)];
+        System.arraycopy(array, 0, newArray, 0, index);
+        newArray[index] = element;
+        System.arraycopy(array, index, newArray, index + 1, array.length - index);
+        return newArray;
+    }
+
+    /**
+     * {@inheritDoc}
+     *
+     * <p>This implementation composes a string by iterating over its mappings.
+     */
+    @Override
+    public String toString() {
+        if (size() <= 0) {
+            return "{}";
+        }
+
+        StringBuilder buffer = new StringBuilder(mSize * 28);
+        buffer.append('{');
+        for (int i = 0; i < mSize; i++) {
+            if (i > 0) {
+                buffer.append(", ");
+            }
+            int key = keyAt(i);
+            buffer.append(key);
+            buffer.append('=');
+            boolean value = valueAt(i);
+            buffer.append(value);
+        }
+        buffer.append('}');
+        return buffer.toString();
+    }
+}
diff --git a/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/utils/SparseIntArray.java b/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/utils/SparseIntArray.java
index 20bfbf4e..8634a6ac 100644
--- a/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/utils/SparseIntArray.java
+++ b/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/utils/SparseIntArray.java
@@ -196,6 +196,13 @@ public int indexOfKey(int key) {
         return binarySearch(mKeys, mSize, key);
     }
 
+    /**
+     * Returns whether the {@code key} is exists.
+     */
+    public boolean containsKey(int key) {
+        return indexOfKey(key) >= 0;
+    }
+
     /**
      * Returns an index for which {@link #valueAt} would return the
      * specified key, or a negative number if no keys map to the
diff --git a/third-party/bsdiff-util/build.gradle b/third-party/bsdiff-util/build.gradle
index 4153cea7..1844d317 100644
--- a/third-party/bsdiff-util/build.gradle
+++ b/third-party/bsdiff-util/build.gradle
@@ -5,7 +5,8 @@ apply plugin: 'java'
 version rootProject.ext.VERSION_NAME
 group rootProject.ext.GROUP
 
-task buildSdk(type: Copy, dependsOn: [build]) {
+task buildTinkerSdk(type: Copy, dependsOn: [build]) {
+    group = "tinker"
     from('build/libs') {
         include '*.jar'
         exclude '*javadoc.jar'
diff --git a/third-party/bsdiff-util/src/main/java/com/tencent/tinker/bsdiff/BSPatch.java b/third-party/bsdiff-util/src/main/java/com/tencent/tinker/bsdiff/BSPatch.java
index 2e8d7269..e31e4fd6 100644
--- a/third-party/bsdiff-util/src/main/java/com/tencent/tinker/bsdiff/BSPatch.java
+++ b/third-party/bsdiff-util/src/main/java/com/tencent/tinker/bsdiff/BSPatch.java
@@ -110,10 +110,10 @@ public static int patchLessMemory(RandomAccessFile oldFile, int oldsize, byte[]
             return RETURN_DIFF_FILE_ERR;
         }
 
-        int commentLenPos = oldsize - extLen - 2;
-        if (commentLenPos <= 2) {
-            return RETURN_OLD_FILE_ERR;
-        }
+//        int commentLenPos = oldsize - extLen - 2;
+//        if (commentLenPos <= 2) {
+//            return RETURN_OLD_FILE_ERR;
+//        }
 
         DataInputStream diffIn = new DataInputStream(new ByteArrayInputStream(diffBuf, 0, diffSize));
 
@@ -167,10 +167,10 @@ public static int patchLessMemory(RandomAccessFile oldFile, int oldsize, byte[]
                     return RETURN_DIFF_FILE_ERR;
                 }
                 for (int i = 0; i < ctrl[0]; i++) {
-                    if (oldpos + i == commentLenPos) {
-                        oldBuffer[i] = 0;
-                        oldBuffer[i + 1] = 0;
-                    }
+//                    if (oldpos + i == commentLenPos) {
+//                        oldBuffer[i] = 0;
+//                        oldBuffer[i + 1] = 0;
+//                    }
 
                     if ((oldpos + i >= 0) && (oldpos + i < oldsize)) {
                         buffer[i] += oldBuffer[i];
diff --git a/tinker-android/tinker-android-anno/build.gradle b/tinker-android/tinker-android-anno/build.gradle
index d74f33c2..263ca599 100644
--- a/tinker-android/tinker-android-anno/build.gradle
+++ b/tinker-android/tinker-android-anno/build.gradle
@@ -21,7 +21,8 @@ sourceSets {
     }
 }
 
-task buildSdk(type: Copy, dependsOn: [build]) {
+task buildTinkerSdk(type: Copy, dependsOn: [build]) {
+    group = "tinker"
     from('build/libs') {
         include '*.jar'
         exclude '*javadoc.jar'
diff --git a/tinker-android/tinker-android-anno/src/main/java/com/tencent/tinker/anno/DefaultLifeCycle.java b/tinker-android/tinker-android-anno/src/main/java/com/tencent/tinker/anno/DefaultLifeCycle.java
index ddd5db1b..275c0c90 100644
--- a/tinker-android/tinker-android-anno/src/main/java/com/tencent/tinker/anno/DefaultLifeCycle.java
+++ b/tinker-android/tinker-android-anno/src/main/java/com/tencent/tinker/anno/DefaultLifeCycle.java
@@ -39,6 +39,4 @@
     int flags();
 
     boolean loadVerifyFlag() default false;
-
-
 }
diff --git a/tinker-android/tinker-android-lib/build.gradle b/tinker-android/tinker-android-lib/build.gradle
index 7f9c60b2..bcc8b83f 100644
--- a/tinker-android/tinker-android-lib/build.gradle
+++ b/tinker-android/tinker-android-lib/build.gradle
@@ -20,7 +20,8 @@ dependencies {
     compile project(':tinker-android:tinker-android-loader')
 }
 
-task buildSdk(type: Copy, dependsOn: [build]) {
+task buildTinkerSdk(type: Copy, dependsOn: [build]) {
+    group = "tinker"
     from("$buildDir/outputs/aar/") {
         include "${project.getName()}-release.aar"
     }
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/library/TinkerLoadLibrary.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/library/TinkerLoadLibrary.java
new file mode 100644
index 00000000..26f7d4c2
--- /dev/null
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/library/TinkerLoadLibrary.java
@@ -0,0 +1,274 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.lib.library;
+
+import android.content.Context;
+import android.os.Build;
+
+import com.tencent.tinker.lib.tinker.Tinker;
+import com.tencent.tinker.lib.tinker.TinkerLoadResult;
+import com.tencent.tinker.lib.util.TinkerLog;
+import com.tencent.tinker.loader.TinkerRuntimeException;
+import com.tencent.tinker.loader.shareutil.ShareConstants;
+import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
+import com.tencent.tinker.loader.shareutil.ShareReflectUtil;
+
+import java.io.File;
+import java.io.IOException;
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Created by zhangshaowen on 17/1/5.
+ * Thanks for Android Fragmentation
+ */
+
+public class TinkerLoadLibrary {
+    private static final String TAG = "Tinker.LoadLibrary";
+
+    /**
+     * you can use TinkerInstaller.loadLibrary replace your System.loadLibrary for auto update library!
+     * only support auto load lib/armeabi library from patch.
+     * for other library in lib/* or assets,
+     * you can load through {@code TinkerInstaller#loadLibraryFromTinker}
+     */
+    public static void loadArmLibrary(Context context, String libName) {
+        if (libName == null || libName.isEmpty() || context == null) {
+            throw new TinkerRuntimeException("libName or context is null!");
+        }
+
+        Tinker tinker = Tinker.with(context);
+        if (tinker.isEnabledForNativeLib()) {
+            if (TinkerLoadLibrary.loadLibraryFromTinker(context, "lib/armeabi", libName)) {
+                return;
+            }
+
+        }
+        System.loadLibrary(libName);
+    }
+
+    /**
+     * you can use TinkerInstaller.loadArmV7Library replace your System.loadLibrary for auto update library!
+     * only support auto load lib/armeabi-v7a library from patch.
+     * for other library in lib/* or assets,
+     * you can load through {@code TinkerInstaller#loadLibraryFromTinker}
+     */
+    public static void loadArmV7Library(Context context, String libName) {
+        if (libName == null || libName.isEmpty() || context == null) {
+            throw new TinkerRuntimeException("libName or context is null!");
+        }
+
+        Tinker tinker = Tinker.with(context);
+        if (tinker.isEnabledForNativeLib()) {
+            if (TinkerLoadLibrary.loadLibraryFromTinker(context, "lib/armeabi-v7a", libName)) {
+                return;
+            }
+
+        }
+        System.loadLibrary(libName);
+    }
+
+    /**
+     * sample usage for native library
+     *
+     * @param context
+     * @param relativePath such as lib/armeabi
+     * @param libName      for the lib libTest.so, you can pass Test or libTest, or libTest.so
+     * @return boolean
+     * @throws UnsatisfiedLinkError
+     */
+    public static boolean loadLibraryFromTinker(Context context, String relativePath, String libName) throws UnsatisfiedLinkError {
+        final Tinker tinker = Tinker.with(context);
+
+        libName = libName.startsWith("lib") ? libName : "lib" + libName;
+        libName = libName.endsWith(".so") ? libName : libName + ".so";
+        String relativeLibPath = relativePath + "/" + libName;
+
+        //TODO we should add cpu abi, and the real path later
+        if (tinker.isEnabledForNativeLib() && tinker.isTinkerLoaded()) {
+            TinkerLoadResult loadResult = tinker.getTinkerLoadResultIfPresent();
+            if (loadResult.libs != null) {
+                for (String name : loadResult.libs.keySet()) {
+                    if (name.equals(relativeLibPath)) {
+                        String patchLibraryPath = loadResult.libraryDirectory + "/" + name;
+                        File library = new File(patchLibraryPath);
+                        if (library.exists()) {
+                            //whether we check md5 when load
+                            boolean verifyMd5 = tinker.isTinkerLoadVerify();
+                            if (verifyMd5 && !SharePatchFileUtil.verifyFileMd5(library, loadResult.libs.get(name))) {
+                                tinker.getLoadReporter().onLoadFileMd5Mismatch(library, ShareConstants.TYPE_LIBRARY);
+                            } else {
+                                System.load(patchLibraryPath);
+                                TinkerLog.i(TAG, "loadLibraryFromTinker success:" + patchLibraryPath);
+                                return true;
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+        return false;
+    }
+
+    /**
+     * you can reflect your current abi to classloader library path
+     * as you don't need to use load*Library method above
+     * @param context
+     * @param currentABI
+     */
+    public static void installNavitveLibraryABI(Context context, String currentABI) {
+        Tinker tinker = Tinker.with(context);
+        if (!tinker.isTinkerLoaded()) {
+            TinkerLog.i(TAG, "tinker is not loaded, just return");
+            return;
+        }
+        TinkerLoadResult loadResult = tinker.getTinkerLoadResultIfPresent();
+        if (loadResult.libs == null) {
+            TinkerLog.i(TAG, "tinker libs is null, just return");
+            return;
+        }
+        File soDir = new File(loadResult.libraryDirectory, "lib/" + currentABI);
+        if (!soDir.exists()) {
+            TinkerLog.e(TAG, "current libraryABI folder is not exist, path: %s", soDir.getPath());
+            return;
+        }
+        ClassLoader classLoader = context.getClassLoader();
+        if (classLoader == null) {
+            TinkerLog.e(TAG, "classloader is null");
+            return;
+        }
+        TinkerLog.i(TAG, "before hack classloader:" + classLoader.toString());
+
+        try {
+            installNativeLibraryPath(classLoader, soDir);
+        } catch (Throwable throwable) {
+            TinkerLog.e(TAG, "installNativeLibraryPath fail:" + throwable);
+        }
+        TinkerLog.i(TAG, "after hack classloader:" + classLoader.toString());
+    }
+
+    private static void installNativeLibraryPath(ClassLoader classLoader, File folder)
+        throws Throwable {
+        if (folder == null || !folder.exists()) {
+            TinkerLog.e(TAG, "installNativeLibraryPath, folder %s is illegal", folder);
+            return;
+        }
+        // android o sdk_int 26
+        // for android o preview sdk_int 25
+        if ((Build.VERSION.SDK_INT == 25 && Build.VERSION.PREVIEW_SDK_INT != 0)
+            || Build.VERSION.SDK_INT > 25) {
+            try {
+                V25.install(classLoader, folder);
+                return;
+            } catch (Throwable throwable) {
+                // install fail, try to treat it as v23
+                // some preview N version may go here
+                TinkerLog.e(TAG, "installNativeLibraryPath, v25 fail, sdk: %d, error: %s, try to fallback to V23",
+                        Build.VERSION.SDK_INT, throwable.getMessage());
+                V23.install(classLoader, folder);
+            }
+        } else if (Build.VERSION.SDK_INT >= 23) {
+            try {
+                V23.install(classLoader, folder);
+            } catch (Throwable throwable) {
+                // install fail, try to treat it as v14
+                TinkerLog.e(TAG, "installNativeLibraryPath, v23 fail, sdk: %d, error: %s, try to fallback to V14",
+                    Build.VERSION.SDK_INT, throwable.getMessage());
+
+                V14.install(classLoader, folder);
+            }
+        } else if (Build.VERSION.SDK_INT >= 14) {
+            V14.install(classLoader, folder);
+        } else {
+            V4.install(classLoader, folder);
+        }
+    }
+
+    private static final class V4 {
+        private static void install(ClassLoader classLoader, File folder)  throws Throwable {
+            String addPath = folder.getPath();
+            Field pathField = ShareReflectUtil.findField(classLoader, "libPath");
+            StringBuilder libPath = new StringBuilder((String) pathField.get(classLoader));
+            libPath.append(':').append(addPath);
+            pathField.set(classLoader, libPath.toString());
+
+            Field libraryPathElementsFiled = ShareReflectUtil.findField(classLoader, "libraryPathElements");
+            List<String> libraryPathElements = (List<String>) libraryPathElementsFiled.get(classLoader);
+            libraryPathElements.add(0, addPath);
+            libraryPathElementsFiled.set(classLoader, libraryPathElements);
+        }
+    }
+
+    private static final class V14 {
+        private static void install(ClassLoader classLoader, File folder)  throws Throwable {
+            Field pathListField = ShareReflectUtil.findField(classLoader, "pathList");
+            Object dexPathList = pathListField.get(classLoader);
+
+            ShareReflectUtil.expandFieldArray(dexPathList, "nativeLibraryDirectories", new File[]{folder});
+        }
+    }
+
+    private static final class V23 {
+        private static void install(ClassLoader classLoader, File folder)  throws Throwable {
+            Field pathListField = ShareReflectUtil.findField(classLoader, "pathList");
+            Object dexPathList = pathListField.get(classLoader);
+
+            Field nativeLibraryDirectories = ShareReflectUtil.findField(dexPathList, "nativeLibraryDirectories");
+
+            List<File> libDirs = (List<File>) nativeLibraryDirectories.get(dexPathList);
+            libDirs.add(0, folder);
+            Field systemNativeLibraryDirectories =
+                ShareReflectUtil.findField(dexPathList, "systemNativeLibraryDirectories");
+            List<File> systemLibDirs = (List<File>) systemNativeLibraryDirectories.get(dexPathList);
+            Method makePathElements =
+                ShareReflectUtil.findMethod(dexPathList, "makePathElements", List.class, File.class, List.class);
+            ArrayList<IOException> suppressedExceptions = new ArrayList<>();
+            libDirs.addAll(systemLibDirs);
+            Object[] elements = (Object[]) makePathElements.
+                invoke(dexPathList, libDirs, null, suppressedExceptions);
+            Field nativeLibraryPathElements = ShareReflectUtil.findField(dexPathList, "nativeLibraryPathElements");
+            nativeLibraryPathElements.setAccessible(true);
+            nativeLibraryPathElements.set(dexPathList, elements);
+        }
+    }
+
+    private static final class V25 {
+        private static void install(ClassLoader classLoader, File folder)  throws Throwable {
+            Field pathListField = ShareReflectUtil.findField(classLoader, "pathList");
+            Object dexPathList = pathListField.get(classLoader);
+
+            Field nativeLibraryDirectories = ShareReflectUtil.findField(dexPathList, "nativeLibraryDirectories");
+
+            List<File> libDirs = (List<File>) nativeLibraryDirectories.get(dexPathList);
+            libDirs.add(0, folder);
+            Field systemNativeLibraryDirectories =
+                    ShareReflectUtil.findField(dexPathList, "systemNativeLibraryDirectories");
+            List<File> systemLibDirs = (List<File>) systemNativeLibraryDirectories.get(dexPathList);
+            Method makePathElements =
+                    ShareReflectUtil.findMethod(dexPathList, "makePathElements", List.class);
+            libDirs.addAll(systemLibDirs);
+            Object[] elements = (Object[]) makePathElements.
+                    invoke(dexPathList, libDirs);
+            Field nativeLibraryPathElements = ShareReflectUtil.findField(dexPathList, "nativeLibraryPathElements");
+            nativeLibraryPathElements.setAccessible(true);
+            nativeLibraryPathElements.set(dexPathList, elements);
+        }
+    }
+}
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/DefaultPatchListener.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/DefaultPatchListener.java
index b4cf11d0..9f5f4f64 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/DefaultPatchListener.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/DefaultPatchListener.java
@@ -22,6 +22,7 @@
 import com.tencent.tinker.lib.tinker.Tinker;
 import com.tencent.tinker.lib.util.TinkerServiceInternals;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
+import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
 import com.tencent.tinker.loader.shareutil.ShareTinkerInternals;
 
 import java.io.File;
@@ -41,24 +42,22 @@ public DefaultPatchListener(Context context) {
      * you can overwrite it
      *
      * @param path
-     * @param isUpgrade
      * @return
      */
     @Override
-    public int onPatchReceived(String path, boolean isUpgrade) {
+    public int onPatchReceived(String path) {
 
-        int returnCode = patchCheck(path, isUpgrade);
+        int returnCode = patchCheck(path);
 
         if (returnCode == ShareConstants.ERROR_PATCH_OK) {
-            TinkerPatchService.runPatchService(context, path, isUpgrade);
+            TinkerPatchService.runPatchService(context, path);
         } else {
-            Tinker.with(context).getLoadReporter().onLoadPatchListenerReceiveFail(new File(path), returnCode, isUpgrade);
+            Tinker.with(context).getLoadReporter().onLoadPatchListenerReceiveFail(new File(path), returnCode);
         }
         return returnCode;
-
     }
 
-    protected int patchCheck(String path, boolean isUpgrade) {
+    protected int patchCheck(String path) {
         Tinker manager = Tinker.with(context);
         //check SharePreferences also
         if (!manager.isTinkerEnabled() || !ShareTinkerInternals.isTinkerEnableWithSharedPreferences(context)) {
@@ -66,7 +65,7 @@ protected int patchCheck(String path, boolean isUpgrade) {
         }
         File file = new File(path);
 
-        if (!file.isFile() || !file.exists() || file.length() == 0) {
+        if (!SharePatchFileUtil.isLegalFile(file)) {
             return ShareConstants.ERROR_PATCH_NOTEXIST;
         }
 
@@ -79,6 +78,9 @@ protected int patchCheck(String path, boolean isUpgrade) {
         if (TinkerServiceInternals.isTinkerPatchServiceRunning(context)) {
             return ShareConstants.ERROR_PATCH_RUNNING;
         }
+        if (ShareTinkerInternals.isVmJit()) {
+            return ShareConstants.ERROR_PATCH_JIT;
+        }
         return ShareConstants.ERROR_PATCH_OK;
     }
 
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/PatchListener.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/PatchListener.java
index 7d65c555..1f18c491 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/PatchListener.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/PatchListener.java
@@ -20,5 +20,5 @@
  * Created by zhangshaowen on 16/3/14.
  */
 public interface PatchListener {
-    int onPatchReceived(String path, boolean isUpgrade);
+    int onPatchReceived(String path);
 }
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/BasePatchInternal.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/BasePatchInternal.java
index 5ef3d88d..df6a740f 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/BasePatchInternal.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/BasePatchInternal.java
@@ -36,14 +36,13 @@
 
     protected static final String DEX_PATH             = ShareConstants.DEX_PATH;
     protected static final String SO_PATH              = ShareConstants.SO_PATH;
-    protected static final String DEX_OPTIMIZE_PATH    = ShareConstants.DEX_OPTIMIZE_PATH;
+    protected static final String DEX_OPTIMIZE_PATH    = ShareConstants.DEFAULT_DEX_OPTIMIZE_PATH;
     protected static final int    MAX_EXTRACT_ATTEMPTS = ShareConstants.MAX_EXTRACT_ATTEMPTS;
     protected static final String DEX_META_FILE        = ShareConstants.DEX_META_FILE;
     protected static final String SO_META_FILE         = ShareConstants.SO_META_FILE;
     protected static final String RES_META_FILE        = ShareConstants.RES_META_FILE;
 
     protected static final int TYPE_DEX         = ShareConstants.TYPE_DEX;
-    protected static final int TYPE_DEX_FOR_ART = ShareConstants.TYPE_DEX_FOR_ART;
     protected static final int TYPE_Library     = ShareConstants.TYPE_LIBRARY;
     protected static final int TYPE_RESOURCE    = ShareConstants.TYPE_RESOURCE;
 
@@ -89,7 +88,7 @@ public static boolean extract(ZipFile zipFile, ZipEntry entryFile, File extractT
     }
 
     public static int getMetaCorruptedCode(int type) {
-        if (type == TYPE_DEX || type == TYPE_DEX_FOR_ART) {
+        if (type == TYPE_DEX) {
             return ShareConstants.ERROR_PACKAGE_CHECK_DEX_META_CORRUPTED;
         } else if (type == TYPE_Library) {
             return ShareConstants.ERROR_PACKAGE_CHECK_LIB_META_CORRUPTED;
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/BsDiffPatchInternal.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/BsDiffPatchInternal.java
index 45e241b2..7414b007 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/BsDiffPatchInternal.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/BsDiffPatchInternal.java
@@ -42,7 +42,7 @@
     private static final String TAG = "Tinker.BsDiffPatchInternal";
 
     protected static boolean tryRecoverLibraryFiles(Tinker manager, ShareSecurityCheck checker, Context context,
-                                                    String patchVersionDirectory, File patchFile, boolean isUpgradePatch) {
+                                                    String patchVersionDirectory, File patchFile) {
 
         if (!manager.isEnabledForNativeLib()) {
             TinkerLog.w(TAG, "patch recover, library is not enabled");
@@ -55,19 +55,19 @@ protected static boolean tryRecoverLibraryFiles(Tinker manager, ShareSecurityChe
             return true;
         }
         long begin = SystemClock.elapsedRealtime();
-        boolean result = patchLibraryExtractViaBsDiff(context, patchVersionDirectory, libMeta, patchFile, isUpgradePatch);
+        boolean result = patchLibraryExtractViaBsDiff(context, patchVersionDirectory, libMeta, patchFile);
         long cost = SystemClock.elapsedRealtime() - begin;
-        TinkerLog.i(TAG, "recover lib result:%b, cost:%d, isUpgradePatch:%b", result, cost, isUpgradePatch);
+        TinkerLog.i(TAG, "recover lib result:%b, cost:%d", result, cost);
         return result;
     }
 
 
-    private static boolean patchLibraryExtractViaBsDiff(Context context, String patchVersionDirectory, String meta, File patchFile, boolean isUpgradePatch) {
+    private static boolean patchLibraryExtractViaBsDiff(Context context, String patchVersionDirectory, String meta, File patchFile) {
         String dir = patchVersionDirectory + "/" + SO_PATH + "/";
-        return extractBsDiffInternals(context, dir, meta, patchFile, TYPE_Library, isUpgradePatch);
+        return extractBsDiffInternals(context, dir, meta, patchFile, TYPE_Library);
     }
 
-    private static boolean extractBsDiffInternals(Context context, String dir, String meta, File patchFile, int type, boolean isUpgradePatch) {
+    private static boolean extractBsDiffInternals(Context context, String dir, String meta, File patchFile, int type) {
         //parse
         ArrayList<ShareBsDiffPatchInfo> patchList = new ArrayList<>();
 
@@ -110,7 +110,7 @@ private static boolean extractBsDiffInternals(Context context, String dir, Strin
                 final String fileMd5 = info.md5;
                 if (!SharePatchFileUtil.checkIfMd5Valid(fileMd5)) {
                     TinkerLog.w(TAG, "meta file md5 mismatch, type:%s, name: %s, md5: %s", ShareTinkerInternals.getTypeString(type), info.name, info.md5);
-                    manager.getPatchReporter().onPatchPackageCheckFail(patchFile, isUpgradePatch, BasePatchInternal.getMetaCorruptedCode(type));
+                    manager.getPatchReporter().onPatchPackageCheckFail(patchFile, BasePatchInternal.getMetaCorruptedCode(type));
                     return false;
                 }
                 String middle;
@@ -140,21 +140,21 @@ private static boolean extractBsDiffInternals(Context context, String dir, Strin
 
                 if (patchFileEntry == null) {
                     TinkerLog.w(TAG, "patch entry is null. path:" + patchRealPath);
-                    manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.name, type, isUpgradePatch);
+                    manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.name, type);
                     return false;
                 }
 
                 if (patchFileMd5.equals("0")) {
                     if (!extract(patch, patchFileEntry, extractedFile, fileMd5, false)) {
                         TinkerLog.w(TAG, "Failed to extract file " + extractedFile.getPath());
-                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.name, type, isUpgradePatch);
+                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.name, type);
                         return false;
                     }
                 } else {
                     //we do not check the intermediate files' md5 to save time, use check whether it is 32 length
                     if (!SharePatchFileUtil.checkIfMd5Valid(patchFileMd5)) {
                         TinkerLog.w(TAG, "meta file md5 mismatch, type:%s, name: %s, md5: %s", ShareTinkerInternals.getTypeString(type), info.name, patchFileMd5);
-                        manager.getPatchReporter().onPatchPackageCheckFail(patchFile, isUpgradePatch, BasePatchInternal.getMetaCorruptedCode(type));
+                        manager.getPatchReporter().onPatchPackageCheckFail(patchFile, BasePatchInternal.getMetaCorruptedCode(type));
                         return false;
                     }
 
@@ -162,7 +162,7 @@ private static boolean extractBsDiffInternals(Context context, String dir, Strin
 
                     if (rawApkFileEntry == null) {
                         TinkerLog.w(TAG, "apk entry is null. path:" + patchRealPath);
-                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.name, type, isUpgradePatch);
+                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.name, type);
                         return false;
                     }
 
@@ -172,7 +172,7 @@ private static boolean extractBsDiffInternals(Context context, String dir, Strin
                     String rawEntryCrc = String.valueOf(rawApkFileEntry.getCrc());
                     if (!rawEntryCrc.equals(rawApkCrc)) {
                         TinkerLog.e(TAG, "apk entry %s crc is not equal, expect crc: %s, got crc: %s", patchRealPath, rawApkCrc, rawEntryCrc);
-                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.name, type, isUpgradePatch);
+                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.name, type);
                         return false;
                     }
                     InputStream oldStream = null;
@@ -189,7 +189,7 @@ private static boolean extractBsDiffInternals(Context context, String dir, Strin
                     //go go go bsdiff get the
                     if (!SharePatchFileUtil.verifyFileMd5(extractedFile, fileMd5)) {
                         TinkerLog.w(TAG, "Failed to recover diff file " + extractedFile.getPath());
-                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.name, type, isUpgradePatch);
+                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.name, type);
                         SharePatchFileUtil.safeDeleteFile(extractedFile);
                         return false;
                     }
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java
index 2ab8a3de..b30765c2 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java
@@ -22,18 +22,17 @@
 import android.os.SystemClock;
 
 import com.tencent.tinker.commons.dexpatcher.DexPatchApplier;
-import com.tencent.tinker.commons.dexpatcher.struct.SmallPatchedDexItemFile;
 import com.tencent.tinker.lib.tinker.Tinker;
 import com.tencent.tinker.lib.util.TinkerLog;
+import com.tencent.tinker.loader.TinkerParallelDexOptimizer;
 import com.tencent.tinker.loader.TinkerRuntimeException;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
 import com.tencent.tinker.loader.shareutil.ShareDexDiffPatchInfo;
+import com.tencent.tinker.loader.shareutil.ShareElfFile;
 import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
 import com.tencent.tinker.loader.shareutil.ShareSecurityCheck;
 import com.tencent.tinker.loader.shareutil.ShareTinkerInternals;
 
-import dalvik.system.DexFile;
-
 import java.io.BufferedInputStream;
 import java.io.BufferedOutputStream;
 import java.io.File;
@@ -41,19 +40,30 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Vector;
 import java.util.zip.ZipEntry;
 import java.util.zip.ZipFile;
 import java.util.zip.ZipInputStream;
 import java.util.zip.ZipOutputStream;
 
+import dalvik.system.DexFile;
+
 /**
  * Created by zhangshaowen on 16/4/12.
  */
 public class DexDiffPatchInternal extends BasePatchInternal {
     protected static final String TAG = "Tinker.DexDiffPatchInternal";
 
+    protected static final int WAIT_ASYN_OAT_TIME = 10 * 1000;
+    protected static final int MAX_WAIT_COUNT     = 30;
+
+    private static ArrayList<File> optFiles = new ArrayList<>();
+
+
     protected static boolean tryRecoverDexFiles(Tinker manager, ShareSecurityCheck checker, Context context,
-                                                String patchVersionDirectory, File patchFile, boolean isUpgradePatch) {
+                                                String patchVersionDirectory, File patchFile) {
         if (!manager.isEnabledForDex()) {
             TinkerLog.w(TAG, "patch recover, dex is not enabled");
             return true;
@@ -66,57 +76,197 @@ protected static boolean tryRecoverDexFiles(Tinker manager, ShareSecurityCheck c
         }
 
         long begin = SystemClock.elapsedRealtime();
-        boolean result = patchDexExtractViaDexDiff(context, patchVersionDirectory, dexMeta, patchFile, isUpgradePatch);
+        boolean result = patchDexExtractViaDexDiff(context, patchVersionDirectory, dexMeta, patchFile);
         long cost = SystemClock.elapsedRealtime() - begin;
-        TinkerLog.i(TAG, "recover dex result:%b, cost:%d, isUpgradePatch:%b", result, cost, isUpgradePatch);
+        TinkerLog.i(TAG, "recover dex result:%b, cost:%d", result, cost);
         return result;
     }
 
-    private static boolean patchDexExtractViaDexDiff(Context context, String patchVersionDirectory, String meta, File patchFile, boolean isUpgradePatch) {
-        checkVmArtProperty();
+    protected static boolean waitAndCheckDexOptFile(File patchFile, Tinker manager) {
+        if (optFiles.isEmpty()) {
+            return true;
+        }
+
+        int size = optFiles.size() * 6;
+        if (size > MAX_WAIT_COUNT) {
+            size = MAX_WAIT_COUNT;
+        }
+        TinkerLog.i(TAG, "dex count: %d, final wait time: %d", optFiles.size(), size);
+
+        for (int i = 0; i < size; i++) {
+            if (!checkAllDexOptFile(optFiles, i + 1)) {
+                try {
+                    Thread.sleep(WAIT_ASYN_OAT_TIME);
+                } catch (InterruptedException e) {
+                    TinkerLog.e(TAG, "thread sleep InterruptedException e:" + e);
+                }
+            }
+        }
+        List<File> failDexFiles = new ArrayList<>();
+        // check again, if still can be found, just return
+        for (File file : optFiles) {
+            TinkerLog.i(TAG, "check dex optimizer file exist: %s, size %d", file.getName(), file.length());
+
+            if (!SharePatchFileUtil.isLegalFile(file)) {
+                TinkerLog.e(TAG, "final parallel dex optimizer file %s is not exist, return false", file.getName());
+                failDexFiles.add(file);
+            }
+        }
+        if (!failDexFiles.isEmpty()) {
+            manager.getPatchReporter().onPatchDexOptFail(patchFile, failDexFiles,
+                        new TinkerRuntimeException(ShareConstants.CHECK_DEX_OAT_EXIST_FAIL));
+            return false;
+        }
+        if (Build.VERSION.SDK_INT >= 21) {
+            Throwable lastThrowable = null;
+            for (File file : optFiles) {
+                TinkerLog.i(TAG, "check dex optimizer file format: %s, size %d", file.getName(), file.length());
+                int returnType;
+                try {
+                    returnType = ShareElfFile.getFileTypeByMagic(file);
+                } catch (IOException e) {
+                    // read error just continue
+                   continue;
+                }
+                if (returnType == ShareElfFile.FILE_TYPE_ELF) {
+                    ShareElfFile elfFile = null;
+                    try {
+                        elfFile = new ShareElfFile(file);
+                    } catch (Throwable e) {
+                        TinkerLog.e(TAG, "final parallel dex optimizer file %s is not elf format, return false", file.getName());
+                        failDexFiles.add(file);
+                        lastThrowable = e;
+                    } finally {
+                        if (elfFile != null) {
+                            try {
+                                elfFile.close();
+                            } catch (IOException ignore) {
+
+                            }
+                        }
+                    }
+                }
+            }
+            if (!failDexFiles.isEmpty()) {
+                Throwable returnThrowable = lastThrowable == null
+                    ? new TinkerRuntimeException(ShareConstants.CHECK_DEX_OAT_FORMAT_FAIL)
+                    : new TinkerRuntimeException(ShareConstants.CHECK_DEX_OAT_FORMAT_FAIL, lastThrowable);
+
+                manager.getPatchReporter().onPatchDexOptFail(patchFile, failDexFiles,
+                    returnThrowable);
+                return false;
+            }
+        }
+        return true;
+    }
 
+    private static boolean patchDexExtractViaDexDiff(Context context, String patchVersionDirectory, String meta, final File patchFile) {
         String dir = patchVersionDirectory + "/" + DEX_PATH + "/";
 
-        int dexType = ShareTinkerInternals.isVmArt() ? TYPE_DEX_FOR_ART : TYPE_DEX;
-        if (!extractDexDiffInternals(context, dir, meta, patchFile, dexType, isUpgradePatch)) {
+        if (!extractDexDiffInternals(context, dir, meta, patchFile, TYPE_DEX)) {
             TinkerLog.w(TAG, "patch recover, extractDiffInternals fail");
             return false;
         }
 
-        Tinker manager = Tinker.with(context);
+        final Tinker manager = Tinker.with(context);
 
         File dexFiles = new File(dir);
         File[] files = dexFiles.listFiles();
+        optFiles.clear();
 
         if (files != null) {
-            String optimizeDexDirectory = patchVersionDirectory + "/" + DEX_OPTIMIZE_PATH + "/";
+            final String optimizeDexDirectory = patchVersionDirectory + "/" + DEX_OPTIMIZE_PATH + "/";
             File optimizeDexDirectoryFile = new File(optimizeDexDirectory);
 
-            if (!optimizeDexDirectoryFile.exists()) {
-                optimizeDexDirectoryFile.mkdirs();
+            if (!optimizeDexDirectoryFile.exists() && !optimizeDexDirectoryFile.mkdirs()) {
+                TinkerLog.w(TAG, "patch recover, make optimizeDexDirectoryFile fail");
+                return false;
             }
-
+            // add opt files
             for (File file : files) {
-                try {
-                    String outputPathName = SharePatchFileUtil.optimizedPathFor(file, optimizeDexDirectoryFile);
-                    long start = System.currentTimeMillis();
-                    DexFile.loadDex(file.getAbsolutePath(), outputPathName, 0);
-                    TinkerLog.i(TAG, "success dex optimize file, path: %s, use time: %d", file.getPath(), (System.currentTimeMillis() - start));
-                } catch (Throwable e) {
-                    TinkerLog.e(TAG, "dex optimize or load failed, path:" + file.getPath());
-                    //delete file
-                    SharePatchFileUtil.safeDeleteFile(file);
-                    manager.getPatchReporter().onPatchDexOptFail(patchFile, file, optimizeDexDirectory, file.getName(), e, isUpgradePatch);
+                String outputPathName = SharePatchFileUtil.optimizedPathFor(file, optimizeDexDirectoryFile);
+                optFiles.add(new File(outputPathName));
+            }
+
+            TinkerLog.i(TAG, "patch recover, try to optimize dex file count:%d, optimizeDexDirectory:%s", files.length, optimizeDexDirectory);
+            // only use parallel dex optimizer for art
+            if (ShareTinkerInternals.isVmArt()) {
+                final List<File> failOptDexFile = new Vector<>();
+                final Throwable[] throwable = new Throwable[1];
+
+                // try parallel dex optimizer
+                TinkerParallelDexOptimizer.optimizeAll(
+                    Arrays.asList(files), optimizeDexDirectoryFile,
+                    new TinkerParallelDexOptimizer.ResultCallback() {
+                        long startTime;
+
+                        @Override
+                        public void onStart(File dexFile, File optimizedDir) {
+                            startTime = System.currentTimeMillis();
+                            TinkerLog.i(TAG, "start to parallel optimize dex %s, size: %d", dexFile.getPath(), dexFile.length());
+                        }
+
+                        @Override
+                        public void onSuccess(File dexFile, File optimizedDir, File optimizedFile) {
+                            // Do nothing.
+                            TinkerLog.i(TAG, "success to parallel optimize dex %s, opt file size: %d, use time %d",
+                                dexFile.getPath(), optimizedFile.length(), (System.currentTimeMillis() - startTime));
+                        }
+
+                        @Override
+                        public void onFailed(File dexFile, File optimizedDir, Throwable thr) {
+                            TinkerLog.i(TAG, "fail to parallel optimize dex %s use time %d",
+                                dexFile.getPath(), (System.currentTimeMillis() - startTime));
+                            failOptDexFile.add(dexFile);
+                            throwable[0] = thr;
+                        }
+                    }
+                );
+
+                if (!failOptDexFile.isEmpty()) {
+                    manager.getPatchReporter().onPatchDexOptFail(patchFile, failOptDexFile, throwable[0]);
                     return false;
                 }
+            // for dalvik, machine hardware performance is much worse than art machine
+            } else {
+                for (File file : files) {
+                    try {
+                        String outputPathName = SharePatchFileUtil.optimizedPathFor(file, optimizeDexDirectoryFile);
+                        long start = System.currentTimeMillis();
+                        DexFile.loadDex(file.getAbsolutePath(), outputPathName, 0);
+                        TinkerLog.i(TAG, "success single dex optimize file, path: %s, opt file size: %d, use time: %d", file.getPath(), new File(outputPathName).length(),
+                            (System.currentTimeMillis() - start));
+                    } catch (Throwable e) {
+                        TinkerLog.e(TAG, "single dex optimize or load failed, path:" + file.getPath());
+                        List<File> failedList = new ArrayList<>();
+                        failedList.add(file);
+                        manager.getPatchReporter().onPatchDexOptFail(patchFile, failedList, e);
+                        return false;
+                    }
+                }
             }
         }
-
         return true;
     }
 
+    /**
+     * for ViVo or some other rom, they would make dex2oat asynchronous
+     * so we need to check whether oat file is actually generated.
+     * @param files
+     * @param count
+     * @return
+     */
+    private static boolean checkAllDexOptFile(ArrayList<File> files, int count) {
+        for (File file : files) {
+            if (!SharePatchFileUtil.isLegalFile(file)) {
+                TinkerLog.e(TAG, "parallel dex optimizer file %s is not exist, just wait %d times", file.getName(), count);
+                return false;
+            }
+        }
+        return true;
+    }
 
-    private static boolean extractDexDiffInternals(Context context, String dir, String meta, File patchFile, int type, boolean isUpgradePatch) {
+    private static boolean extractDexDiffInternals(Context context, String dir, String meta, File patchFile, int type) {
         //parse
         ArrayList<ShareDexDiffPatchInfo> patchList = new ArrayList<>();
 
@@ -146,28 +296,6 @@ private static boolean extractDexDiffInternals(Context context, String dir, Stri
             apk = new ZipFile(apkPath);
             patch = new ZipFile(patchFile);
 
-            SmallPatchedDexItemFile smallPatchInfoFile = null;
-
-            if (ShareTinkerInternals.isVmArt()) {
-                File extractedFile = new File(dir + ShareConstants.DEX_SMALLPATCH_INFO_FILE);
-                ZipEntry smallPatchInfoEntry = patch.getEntry(ShareConstants.DEX_SMALLPATCH_INFO_FILE);
-                if (smallPatchInfoEntry != null) {
-                    InputStream smallPatchInfoIs = null;
-                    try {
-                        smallPatchInfoIs = patch.getInputStream(smallPatchInfoEntry);
-                        smallPatchInfoFile = new SmallPatchedDexItemFile(smallPatchInfoIs);
-                    } catch (Throwable e) {
-                        TinkerLog.w(TAG, "failed to read small patched info. reason: " + e.getMessage());
-                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, ShareConstants.DEX_SMALLPATCH_INFO_FILE, type, isUpgradePatch);
-                        return false;
-                    } finally {
-                        SharePatchFileUtil.closeQuietly(smallPatchInfoIs);
-                    }
-                } else {
-                    TinkerLog.w(TAG, "small patch info is not exists, it's ok now.");
-                }
-            }
-
             for (ShareDexDiffPatchInfo info : patchList) {
                 long start = System.currentTimeMillis();
 
@@ -190,7 +318,7 @@ private static boolean extractDexDiffInternals(Context context, String dir, Stri
 
                 if (!SharePatchFileUtil.checkIfMd5Valid(extractedFileMd5)) {
                     TinkerLog.w(TAG, "meta file md5 invalid, type:%s, name: %s, md5: %s", ShareTinkerInternals.getTypeString(type), info.rawName, extractedFileMd5);
-                    manager.getPatchReporter().onPatchPackageCheckFail(patchFile, isUpgradePatch, BasePatchInternal.getMetaCorruptedCode(type));
+                    manager.getPatchReporter().onPatchPackageCheckFail(patchFile, BasePatchInternal.getMetaCorruptedCode(type));
                     return false;
                 }
 
@@ -216,25 +344,25 @@ private static boolean extractDexDiffInternals(Context context, String dir, Stri
                 if (oldDexCrc.equals("0")) {
                     if (patchFileEntry == null) {
                         TinkerLog.w(TAG, "patch entry is null. path:" + patchRealPath);
-                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type, isUpgradePatch);
+                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type);
                         return false;
                     }
 
                     //it is a new file, but maybe we need to repack the dex file
                     if (!extractDexFile(patch, patchFileEntry, extractedFile, info)) {
                         TinkerLog.w(TAG, "Failed to extract raw patch file " + extractedFile.getPath());
-                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type, isUpgradePatch);
+                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type);
                         return false;
                     }
                 } else if (dexDiffMd5.equals("0")) {
-                    // skip process old dex for dalvik vm
+                    // skip process old dex for real dalvik vm
                     if (!ShareTinkerInternals.isVmArt()) {
                         continue;
                     }
 
                     if (rawApkFileEntry == null) {
                         TinkerLog.w(TAG, "apk entry is null. path:" + patchRealPath);
-                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type, isUpgradePatch);
+                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type);
                         return false;
                     }
 
@@ -242,110 +370,60 @@ private static boolean extractDexDiffInternals(Context context, String dir, Stri
                     String rawEntryCrc = String.valueOf(rawApkFileEntry.getCrc());
                     if (!rawEntryCrc.equals(oldDexCrc)) {
                         TinkerLog.e(TAG, "apk entry %s crc is not equal, expect crc: %s, got crc: %s", patchRealPath, oldDexCrc, rawEntryCrc);
-                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type, isUpgradePatch);
+                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type);
                         return false;
                     }
 
-                    InputStream oldDexIs = null;
-                    try {
-                        oldDexIs = apk.getInputStream(rawApkFileEntry);
-                        new DexPatchApplier(oldDexIs, (int) rawApkFileEntry.getSize(), null, smallPatchInfoFile).executeAndSaveTo(extractedFile);
-                    } catch (Throwable e) {
-                        TinkerLog.w(TAG, "Failed to recover dex file " + extractedFile.getPath());
-                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type, isUpgradePatch);
-                        SharePatchFileUtil.safeDeleteFile(extractedFile);
-                        return false;
-                    } finally {
-                        SharePatchFileUtil.closeQuietly(oldDexIs);
-                    }
+                    // Small patched dex generating strategy was disabled, we copy full original dex directly now.
+                    //patchDexFile(apk, patch, rawApkFileEntry, null, info, smallPatchInfoFile, extractedFile);
+                    extractDexFile(apk, rawApkFileEntry, extractedFile, info);
 
                     if (!SharePatchFileUtil.verifyDexFileMd5(extractedFile, extractedFileMd5)) {
-                        TinkerLog.w(TAG, "Failed to recover dex file " + extractedFile.getPath());
-                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type, isUpgradePatch);
+                        TinkerLog.w(TAG, "Failed to recover dex file when verify patched dex: " + extractedFile.getPath());
+                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type);
                         SharePatchFileUtil.safeDeleteFile(extractedFile);
                         return false;
                     }
                 } else {
                     if (patchFileEntry == null) {
                         TinkerLog.w(TAG, "patch entry is null. path:" + patchRealPath);
-                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type, isUpgradePatch);
+                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type);
                         return false;
                     }
 
                     if (!SharePatchFileUtil.checkIfMd5Valid(dexDiffMd5)) {
                         TinkerLog.w(TAG, "meta file md5 invalid, type:%s, name: %s, md5: %s", ShareTinkerInternals.getTypeString(type), info.rawName, dexDiffMd5);
-                        manager.getPatchReporter().onPatchPackageCheckFail(patchFile, isUpgradePatch, BasePatchInternal.getMetaCorruptedCode(type));
+                        manager.getPatchReporter().onPatchPackageCheckFail(patchFile, BasePatchInternal.getMetaCorruptedCode(type));
                         return false;
                     }
 
                     if (rawApkFileEntry == null) {
                         TinkerLog.w(TAG, "apk entry is null. path:" + patchRealPath);
-                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type, isUpgradePatch);
+                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type);
                         return false;
                     }
                     //check source crc instead of md5 for faster
                     String rawEntryCrc = String.valueOf(rawApkFileEntry.getCrc());
                     if (!rawEntryCrc.equals(oldDexCrc)) {
                         TinkerLog.e(TAG, "apk entry %s crc is not equal, expect crc: %s, got crc: %s", patchRealPath, oldDexCrc, rawEntryCrc);
-                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type, isUpgradePatch);
+                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type);
                         return false;
                     }
 
-                    final boolean isRawDexFile = SharePatchFileUtil.isRawDexFile(info.rawName);
-                    InputStream oldInputStream = apk.getInputStream(rawApkFileEntry);
-                    InputStream newInputStream = patch.getInputStream(patchFileEntry);
-                    //if it is not the dex file or we are using jar mode, we should repack the output dex to jar
-                    try {
-                        if (!isRawDexFile || info.isJarMode) {
-                            FileOutputStream fos = new FileOutputStream(extractedFile);
-                            ZipOutputStream zos = new ZipOutputStream(new
-                                BufferedOutputStream(fos));
-
-                            try {
-                                zos.putNextEntry(new ZipEntry(ShareConstants.DEX_IN_JAR));
-                                //it is not a raw dex file, we do not want to any temp files
-                                int oldDexSize;
-                                if (!isRawDexFile) {
-                                    ZipEntry entry;
-                                    ZipInputStream zis = new ZipInputStream(oldInputStream);
-                                    while ((entry = zis.getNextEntry()) != null) {
-                                        if (ShareConstants.DEX_IN_JAR.equals(entry.getName())) break;
-                                    }
-                                    if (entry == null) {
-                                        throw new TinkerRuntimeException("can't recognize zip dex format file:" + extractedFile.getAbsolutePath());
-                                    }
-                                    oldInputStream = zis;
-                                    oldDexSize = (int) entry.getSize();
-                                } else {
-                                    oldDexSize = (int) rawApkFileEntry.getSize();
-                                }
-                                new DexPatchApplier(oldInputStream, oldDexSize, newInputStream, smallPatchInfoFile).executeAndSaveTo(zos);
-                                zos.closeEntry();
-                            } finally {
-                                SharePatchFileUtil.closeQuietly(zos);
-                            }
-
-                        } else {
-                            new DexPatchApplier(oldInputStream, (int) rawApkFileEntry.getSize(), newInputStream, smallPatchInfoFile).executeAndSaveTo(extractedFile);
-                        }
-                    } finally {
-                        SharePatchFileUtil.closeQuietly(oldInputStream);
-                        SharePatchFileUtil.closeQuietly(newInputStream);
-                    }
+                    patchDexFile(apk, patch, rawApkFileEntry, patchFileEntry, info, extractedFile);
 
                     if (!SharePatchFileUtil.verifyDexFileMd5(extractedFile, extractedFileMd5)) {
-                        TinkerLog.w(TAG, "Failed to recover dex file " + extractedFile.getPath());
-                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type, isUpgradePatch);
+                        TinkerLog.w(TAG, "Failed to recover dex file when verify patched dex: " + extractedFile.getPath());
+                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type);
                         SharePatchFileUtil.safeDeleteFile(extractedFile);
                         return false;
                     }
-                    TinkerLog.w(TAG, "success recover dex file: %s, use time: %d",
-                        extractedFile.getPath(), (System.currentTimeMillis() - start));
+
+                    TinkerLog.w(TAG, "success recover dex file: %s, size: %d, use time: %d",
+                            extractedFile.getPath(), extractedFile.length(), (System.currentTimeMillis() - start));
                 }
             }
-
         } catch (Throwable e) {
-//            e.printStackTrace();
             throw new TinkerRuntimeException("patch " + ShareTinkerInternals.getTypeString(type) + " extract failed (" + e.getMessage() + ").", e);
         } finally {
             SharePatchFileUtil.closeZip(apk);
@@ -379,7 +457,7 @@ private static boolean extractDexToJar(ZipFile zipFile, ZipEntry entryFile, File
             TinkerLog.i(TAG, "try Extracting " + extractTo.getPath());
             try {
                 zos = new ZipOutputStream(new
-                    BufferedOutputStream(fos));
+                        BufferedOutputStream(fos));
                 bis = new BufferedInputStream(in);
 
                 byte[] buffer = new byte[ShareConstants.BUFFER_SIZE];
@@ -409,15 +487,15 @@ private static boolean extractDexToJar(ZipFile zipFile, ZipEntry entryFile, File
         return isExtractionSuccessful;
     }
 
-    /**
-     * reject dalvik vm, but sdk version is larger than 21
-     */
-    private static void checkVmArtProperty() {
-        boolean art = ShareTinkerInternals.isVmArt();
-        if (!art && Build.VERSION.SDK_INT >= 21) {
-            throw new TinkerRuntimeException("it is dalvik vm, but sdk version " + Build.VERSION.SDK_INT + " is larger than 21!");
-        }
-    }
+//    /**
+//     * reject dalvik vm, but sdk version is larger than 21
+//     */
+//    private static void checkVmArtProperty() {
+//        boolean art = ShareTinkerInternals.isVmArt();
+//        if (!art && Build.VERSION.SDK_INT >= 21) {
+//            throw new TinkerRuntimeException(ShareConstants.CHECK_VM_PROPERTY_FAIL + ", it is dalvik vm, but sdk version " + Build.VERSION.SDK_INT + " is larger than 21!");
+//        }
+//    }
 
     private static boolean extractDexFile(ZipFile zipFile, ZipEntry entryFile, File extractTo, ShareDexDiffPatchInfo dexInfo) throws IOException {
         final String fileMd5 = ShareTinkerInternals.isVmArt() ? dexInfo.destMd5InArt : dexInfo.destMd5InDvm;
@@ -430,4 +508,70 @@ private static boolean extractDexFile(ZipFile zipFile, ZipEntry entryFile, File
         return extract(zipFile, entryFile, extractTo, fileMd5, true);
     }
 
+    /**
+     * Generate patched dex file (May wrapped it by a jar if needed.)
+     * @param baseApk
+     *   OldApk.
+     * @param patchPkg
+     *   Patch package, it is also a zip file.
+     * @param oldDexEntry
+     *   ZipEntry of old dex.
+     * @param patchFileEntry
+     *   ZipEntry of patch file. (also ends with .dex) This could be null.
+     * @param patchInfo
+     *   Parsed patch info from package-meta.txt
+     * @param patchedDexFile
+     *   Patched dex file, may be a jar.
+     *
+     * <b>Notice: patchFileEntry and smallPatchInfoFile cannot both be null.</b>
+     *
+     * @throws IOException
+     */
+    private static void patchDexFile(
+            ZipFile baseApk, ZipFile patchPkg, ZipEntry oldDexEntry, ZipEntry patchFileEntry,
+            ShareDexDiffPatchInfo patchInfo,  File patchedDexFile) throws IOException {
+        InputStream oldDexStream = null;
+        InputStream patchFileStream = null;
+        try {
+            oldDexStream = new BufferedInputStream(baseApk.getInputStream(oldDexEntry));
+            patchFileStream = (patchFileEntry != null ? new BufferedInputStream(patchPkg.getInputStream(patchFileEntry)) : null);
+
+            final boolean isRawDexFile = SharePatchFileUtil.isRawDexFile(patchInfo.rawName);
+            if (!isRawDexFile || patchInfo.isJarMode) {
+                ZipOutputStream zos = null;
+                try {
+                    zos = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(patchedDexFile)));
+                    zos.putNextEntry(new ZipEntry(ShareConstants.DEX_IN_JAR));
+                    // Old dex is not a raw dex file.
+                    if (!isRawDexFile) {
+                        ZipInputStream zis = null;
+                        try {
+                            zis = new ZipInputStream(oldDexStream);
+                            ZipEntry entry;
+                            while ((entry = zis.getNextEntry()) != null) {
+                                if (ShareConstants.DEX_IN_JAR.equals(entry.getName())) break;
+                            }
+                            if (entry == null) {
+                                throw new TinkerRuntimeException("can't recognize zip dex format file:" + patchedDexFile.getAbsolutePath());
+                            }
+                            new DexPatchApplier(zis, patchFileStream).executeAndSaveTo(zos);
+                        } finally {
+                            SharePatchFileUtil.closeQuietly(zis);
+                        }
+                    } else {
+                        new DexPatchApplier(oldDexStream, patchFileStream).executeAndSaveTo(zos);
+                    }
+                    zos.closeEntry();
+                } finally {
+                    SharePatchFileUtil.closeQuietly(zos);
+                }
+            } else {
+                new DexPatchApplier(oldDexStream, patchFileStream).executeAndSaveTo(patchedDexFile);
+            }
+        } finally {
+            SharePatchFileUtil.closeQuietly(oldDexStream);
+            SharePatchFileUtil.closeQuietly(patchFileStream);
+        }
+    }
+
 }
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/RepairPatch.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/RepairPatch.java
deleted file mode 100644
index 48a7395b..00000000
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/RepairPatch.java
+++ /dev/null
@@ -1,121 +0,0 @@
-/*
- * Tencent is pleased to support the open source community by making Tinker available.
- *
- * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
- *
- * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- *
- * https://opensource.org/licenses/BSD-3-Clause
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is
- * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
- * either express or implied. See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.tencent.tinker.lib.patch;
-
-import android.content.Context;
-
-import com.tencent.tinker.lib.service.PatchResult;
-import com.tencent.tinker.lib.tinker.Tinker;
-import com.tencent.tinker.lib.util.TinkerLog;
-import com.tencent.tinker.loader.shareutil.ShareConstants;
-import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
-import com.tencent.tinker.loader.shareutil.SharePatchInfo;
-import com.tencent.tinker.loader.shareutil.ShareSecurityCheck;
-import com.tencent.tinker.loader.shareutil.ShareTinkerInternals;
-
-import java.io.File;
-
-/**
- * Created by zhangshaowen on 16/3/18.
- *
- * if some of a patch data(such as so, dex) is deleted,
- * we will try to repair them via RepairPatch
- * you can implement your own patch processor class
- */
-public class RepairPatch extends AbstractPatch {
-    private static final String TAG = "Tinker.RepairPatch";
-
-    @Override
-    public boolean tryPatch(Context context, String tempPatchPath, PatchResult patchResult) {
-
-        Tinker manager = Tinker.with(context);
-
-        final File patchFile = new File(tempPatchPath);
-
-        if (!manager.isTinkerEnabled() || !ShareTinkerInternals.isTinkerEnableWithSharedPreferences(context)) {
-            TinkerLog.e(TAG, "RepairPatch tryPatch:patch is disabled, just return");
-            return false;
-        }
-
-        if (!patchFile.isFile() || !patchFile.exists()) {
-            TinkerLog.e(TAG, "RepairPatch tryPatch:patch file is not found, just return");
-            return false;
-        }
-        //check the signature, we should create a new checker
-        ShareSecurityCheck signatureCheck = new ShareSecurityCheck(context);
-
-
-        int returnCode = ShareTinkerInternals.checkTinkerPackage(context, manager.getTinkerFlags(), patchFile, signatureCheck);
-        if (returnCode != ShareConstants.ERROR_PACKAGE_CHECK_OK) {
-            TinkerLog.e(TAG, "RepairPatch tryPatch:onPatchPackageCheckFail");
-            manager.getPatchReporter().onPatchPackageCheckFail(patchFile, false, returnCode);
-            return false;
-        }
-
-        patchResult.patchTinkerID = signatureCheck.getNewTinkerID();
-        patchResult.baseTinkerID = signatureCheck.getTinkerID();
-
-        //it is a old patch, so we should find a exist
-        SharePatchInfo oldInfo = manager.getTinkerLoadResultIfPresent().patchInfo;
-        String patchMd5 = SharePatchFileUtil.getMD5(patchFile);
-
-        //use md5 as version
-        patchResult.patchVersion = patchMd5;
-
-        if (oldInfo == null) {
-            TinkerLog.e(TAG, "OldPatchProcessor tryPatch:onPatchVersionCheckFail, oldInfo is null");
-            manager.getPatchReporter().onPatchVersionCheckFail(patchFile, oldInfo, patchMd5, false);
-            return false;
-        } else {
-            if (oldInfo.oldVersion == null || oldInfo.newVersion == null) {
-                TinkerLog.e(TAG, "RepairPatch tryPatch:onPatchInfoCorrupted");
-                manager.getPatchReporter().onPatchInfoCorrupted(patchFile, oldInfo.oldVersion, oldInfo.newVersion, false);
-                return false;
-            }
-            //already have patch
-            if (!oldInfo.oldVersion.equals(patchMd5) || !oldInfo.newVersion.equals(patchMd5)) {
-                TinkerLog.e(TAG, "RepairPatch tryPatch:onPatchVersionCheckFail");
-                manager.getPatchReporter().onPatchVersionCheckFail(patchFile, oldInfo, patchMd5, false);
-                return false;
-            }
-        }
-
-        //check ok
-        final String patchDirectory = manager.getPatchDirectory().getAbsolutePath();
-
-        final String patchName = SharePatchFileUtil.getPatchVersionDirectory(patchMd5);
-
-        final String patchVersionDirectory = patchDirectory + "/" + patchName;
-
-        if (!DexDiffPatchInternal.tryRecoverDexFiles(manager, signatureCheck, context, patchVersionDirectory, patchFile, false)) {
-            TinkerLog.e(TAG, "RepairPatch tryPatch:try patch dex failed");
-            return false;
-        }
-
-        if (!BsDiffPatchInternal.tryRecoverLibraryFiles(manager, signatureCheck, context, patchVersionDirectory, patchFile, false)) {
-            TinkerLog.e(TAG, "RepairPatch tryPatch:try patch library failed");
-            return false;
-        }
-
-        if (!ResDiffPatchInternal.tryRecoverResourceFiles(manager, signatureCheck, context, patchVersionDirectory, patchFile, false)) {
-            TinkerLog.e(TAG, "RepairPatch tryPatch:try patch resource failed");
-            return false;
-        }
-        return true;
-    }
-
-}
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/ResDiffPatchInternal.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/ResDiffPatchInternal.java
index 21ac8d85..ce7a5081 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/ResDiffPatchInternal.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/ResDiffPatchInternal.java
@@ -50,7 +50,7 @@
     protected static final String TAG = "Tinker.ResDiffPatchInternal";
 
     protected static boolean tryRecoverResourceFiles(Tinker manager, ShareSecurityCheck checker, Context context,
-                                                String patchVersionDirectory, File patchFile, boolean isUpgradePatch) {
+                                                String patchVersionDirectory, File patchFile) {
 
         if (!manager.isEnabledForResource()) {
             TinkerLog.w(TAG, "patch recover, resource is not enabled");
@@ -64,23 +64,24 @@ protected static boolean tryRecoverResourceFiles(Tinker manager, ShareSecurityCh
         }
 
         long begin = SystemClock.elapsedRealtime();
-        boolean result = patchResourceExtractViaResourceDiff(context, patchVersionDirectory, resourceMeta, patchFile, isUpgradePatch);
+        boolean result = patchResourceExtractViaResourceDiff(context, patchVersionDirectory, resourceMeta, patchFile);
         long cost = SystemClock.elapsedRealtime() - begin;
-        TinkerLog.i(TAG, "recover resource result:%b, cost:%d, isNewPatch:%b", result, cost, isUpgradePatch);
+        TinkerLog.i(TAG, "recover resource result:%b, cost:%d", result, cost);
         return result;
     }
 
-    private static boolean patchResourceExtractViaResourceDiff(Context context, String patchVersionDirectory, String meta, File patchFile, boolean isUpgradePatch) {
+    private static boolean patchResourceExtractViaResourceDiff(Context context, String patchVersionDirectory,
+                                                               String meta, File patchFile) {
         String dir = patchVersionDirectory + "/" + ShareConstants.RES_PATH + "/";
 
-        if (!extractResourceDiffInternals(context, dir, meta, patchFile, TYPE_RESOURCE, isUpgradePatch)) {
+        if (!extractResourceDiffInternals(context, dir, meta, patchFile, TYPE_RESOURCE)) {
             TinkerLog.w(TAG, "patch recover, extractDiffInternals fail");
             return false;
         }
         return true;
     }
 
-    private static boolean extractResourceDiffInternals(Context context, String dir, String meta, File patchFile, int type, boolean isUpgradePatch) {
+    private static boolean extractResourceDiffInternals(Context context, String dir, String meta, File patchFile, int type) {
         ShareResPatchInfo resPatchInfo = new ShareResPatchInfo();
         ShareResPatchInfo.parseAllResPatchInfo(meta, resPatchInfo);
         TinkerLog.i(TAG, "res dir: %s, meta: %s", dir, resPatchInfo.toString());
@@ -88,7 +89,7 @@ private static boolean extractResourceDiffInternals(Context context, String dir,
 
         if (!SharePatchFileUtil.checkIfMd5Valid(resPatchInfo.resArscMd5)) {
             TinkerLog.w(TAG, "resource meta file md5 mismatch, type:%s, md5: %s", ShareTinkerInternals.getTypeString(type), resPatchInfo.resArscMd5);
-            manager.getPatchReporter().onPatchPackageCheckFail(patchFile, isUpgradePatch, BasePatchInternal.getMetaCorruptedCode(type));
+            manager.getPatchReporter().onPatchPackageCheckFail(patchFile, BasePatchInternal.getMetaCorruptedCode(type));
             return false;
         }
         File directory = new File(dir);
@@ -117,7 +118,7 @@ private static boolean extractResourceDiffInternals(Context context, String dir,
             }
             String apkPath = applicationInfo.sourceDir;
 
-            if (!checkAndExtractResourceLargeFile(context, apkPath, directory, patchFile, resPatchInfo, type, isUpgradePatch)) {
+            if (!checkAndExtractResourceLargeFile(context, apkPath, directory, patchFile, resPatchInfo, type)) {
                 return false;
             }
 
@@ -136,6 +137,9 @@ private static boolean extractResourceDiffInternals(Context context, String dir,
                         throw new TinkerRuntimeException("zipEntry is null when get from oldApk");
                     }
                     String name = zipEntry.getName();
+                    if (name.contains("../")) {
+                        continue;
+                    }
                     if (ShareResPatchInfo.checkFileInPattern(resPatchInfo.patterns, name)) {
                         //won't contain in add set.
                         if (!resPatchInfo.deleteRes.contains(name)
@@ -152,7 +156,7 @@ private static boolean extractResourceDiffInternals(Context context, String dir,
                 TinkerZipEntry manifestZipEntry = oldApk.getEntry(ShareConstants.RES_MANIFEST);
                 if (manifestZipEntry == null) {
                     TinkerLog.w(TAG, "manifest patch entry is null. path:" + ShareConstants.RES_MANIFEST);
-                    manager.getPatchReporter().onPatchTypeExtractFail(patchFile, resOutput, ShareConstants.RES_MANIFEST, type, isUpgradePatch);
+                    manager.getPatchReporter().onPatchTypeExtractFail(patchFile, resOutput, ShareConstants.RES_MANIFEST, type);
                     return false;
                 }
                 ResUtil.extractTinkerEntry(oldApk, manifestZipEntry, out);
@@ -162,7 +166,7 @@ private static boolean extractResourceDiffInternals(Context context, String dir,
                     TinkerZipEntry largeZipEntry = oldApk.getEntry(name);
                     if (largeZipEntry == null) {
                         TinkerLog.w(TAG, "large patch entry is null. path:" + name);
-                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, resOutput, name, type, isUpgradePatch);
+                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, resOutput, name, type);
                         return false;
                     }
                     ShareResPatchInfo.LargeModeInfo largeModeInfo = resPatchInfo.largeModMap.get(name);
@@ -174,7 +178,7 @@ private static boolean extractResourceDiffInternals(Context context, String dir,
                     TinkerZipEntry addZipEntry = newApk.getEntry(name);
                     if (addZipEntry == null) {
                         TinkerLog.w(TAG, "add patch entry is null. path:" + name);
-                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, resOutput, name, type, isUpgradePatch);
+                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, resOutput, name, type);
                         return false;
                     }
                     ResUtil.extractTinkerEntry(newApk, addZipEntry, out);
@@ -185,12 +189,14 @@ private static boolean extractResourceDiffInternals(Context context, String dir,
                     TinkerZipEntry modZipEntry = newApk.getEntry(name);
                     if (modZipEntry == null) {
                         TinkerLog.w(TAG, "mod patch entry is null. path:" + name);
-                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, resOutput, name, type, isUpgradePatch);
+                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, resOutput, name, type);
                         return false;
                     }
                     ResUtil.extractTinkerEntry(newApk, modZipEntry, out);
                     totalEntryCount++;
                 }
+                // set comment back
+                out.setComment(oldApk.getComment());
             } finally {
                 if (out != null) {
                     out.close();
@@ -211,7 +217,7 @@ private static boolean extractResourceDiffInternals(Context context, String dir,
             if (!result) {
                 TinkerLog.i(TAG, "check final new resource file fail path:%s, entry count:%d, size:%d", resOutput.getAbsolutePath(), totalEntryCount, resOutput.length());
                 SharePatchFileUtil.safeDeleteFile(resOutput);
-                manager.getPatchReporter().onPatchTypeExtractFail(patchFile, resOutput, ShareConstants.RES_NAME, type, isUpgradePatch);
+                manager.getPatchReporter().onPatchTypeExtractFail(patchFile, resOutput, ShareConstants.RES_NAME, type);
                 return false;
             }
 
@@ -224,7 +230,7 @@ private static boolean extractResourceDiffInternals(Context context, String dir,
     }
 
     private static boolean checkAndExtractResourceLargeFile(Context context, String apkPath, File directory,
-                                                            File patchFile, ShareResPatchInfo resPatchInfo, int type, boolean isUpgradePatch) {
+                                                            File patchFile, ShareResPatchInfo resPatchInfo, int type) {
         long start = System.currentTimeMillis();
         Tinker manager = Tinker.with(context);
         ZipFile apkFile = null;
@@ -236,14 +242,14 @@ private static boolean checkAndExtractResourceLargeFile(Context context, String
             File arscFile = new File(directory, ShareConstants.RES_ARSC);
             if (arscEntry == null) {
                 TinkerLog.w(TAG, "resources apk entry is null. path:" + ShareConstants.RES_ARSC);
-                manager.getPatchReporter().onPatchTypeExtractFail(patchFile, arscFile, ShareConstants.RES_ARSC, type, isUpgradePatch);
+                manager.getPatchReporter().onPatchTypeExtractFail(patchFile, arscFile, ShareConstants.RES_ARSC, type);
                 return false;
             }
             //use base resources.arsc crc to identify base.apk
             String baseArscCrc = String.valueOf(arscEntry.getCrc());
             if (!baseArscCrc.equals(resPatchInfo.arscBaseCrc)) {
                 TinkerLog.e(TAG, "resources.arsc's crc is not equal, expect crc: %s, got crc: %s", resPatchInfo.arscBaseCrc, baseArscCrc);
-                manager.getPatchReporter().onPatchTypeExtractFail(patchFile, arscFile, ShareConstants.RES_ARSC, type, isUpgradePatch);
+                manager.getPatchReporter().onPatchTypeExtractFail(patchFile, arscFile, ShareConstants.RES_ARSC, type);
                 return false;
             }
 
@@ -258,7 +264,7 @@ private static boolean checkAndExtractResourceLargeFile(Context context, String
 
                 if (largeModeInfo == null) {
                     TinkerLog.w(TAG, "resource not found largeModeInfo, type:%s, name: %s", ShareTinkerInternals.getTypeString(type), name);
-                    manager.getPatchReporter().onPatchPackageCheckFail(patchFile, isUpgradePatch, BasePatchInternal.getMetaCorruptedCode(type));
+                    manager.getPatchReporter().onPatchPackageCheckFail(patchFile, BasePatchInternal.getMetaCorruptedCode(type));
                     return false;
                 }
 
@@ -268,21 +274,21 @@ private static boolean checkAndExtractResourceLargeFile(Context context, String
                 //we do not check the intermediate files' md5 to save time, use check whether it is 32 length
                 if (!SharePatchFileUtil.checkIfMd5Valid(largeModeInfo.md5)) {
                     TinkerLog.w(TAG, "resource meta file md5 mismatch, type:%s, name: %s, md5: %s", ShareTinkerInternals.getTypeString(type), name, largeModeInfo.md5);
-                    manager.getPatchReporter().onPatchPackageCheckFail(patchFile, isUpgradePatch, BasePatchInternal.getMetaCorruptedCode(type));
+                    manager.getPatchReporter().onPatchPackageCheckFail(patchFile, BasePatchInternal.getMetaCorruptedCode(type));
                     return false;
                 }
                 patchZipFile = new ZipFile(patchFile);
                 ZipEntry patchEntry = patchZipFile.getEntry(name);
                 if (patchEntry == null) {
                     TinkerLog.w(TAG, "large mod patch entry is null. path:" + name);
-                    manager.getPatchReporter().onPatchTypeExtractFail(patchFile, largeModeInfo.file, name, type, isUpgradePatch);
+                    manager.getPatchReporter().onPatchTypeExtractFail(patchFile, largeModeInfo.file, name, type);
                     return false;
                 }
 
                 ZipEntry baseEntry = apkFile.getEntry(name);
                 if (baseEntry == null) {
                     TinkerLog.w(TAG, "resources apk entry is null. path:" + name);
-                    manager.getPatchReporter().onPatchTypeExtractFail(patchFile, largeModeInfo.file, name, type, isUpgradePatch);
+                    manager.getPatchReporter().onPatchTypeExtractFail(patchFile, largeModeInfo.file, name, type);
                     return false;
                 }
                 InputStream oldStream = null;
@@ -299,10 +305,10 @@ private static boolean checkAndExtractResourceLargeFile(Context context, String
                 if (!SharePatchFileUtil.verifyFileMd5(largeModeInfo.file, largeModeInfo.md5)) {
                     TinkerLog.w(TAG, "Failed to recover large modify file:%s", largeModeInfo.file.getPath());
                     SharePatchFileUtil.safeDeleteFile(largeModeInfo.file);
-                    manager.getPatchReporter().onPatchTypeExtractFail(patchFile, largeModeInfo.file, name, type, isUpgradePatch);
+                    manager.getPatchReporter().onPatchTypeExtractFail(patchFile, largeModeInfo.file, name, type);
                     return false;
                 }
-                TinkerLog.w(TAG, "success recover large modify file:%s , file size:%d, use time:%d", largeModeInfo.file.getPath(), largeModeInfo.file.length(), (System.currentTimeMillis() - largeStart));
+                TinkerLog.w(TAG, "success recover large modify file:%s, file size:%d, use time:%d", largeModeInfo.file.getPath(), largeModeInfo.file.length(), (System.currentTimeMillis() - largeStart));
             }
             TinkerLog.w(TAG, "success recover all large modify use time:%d", (System.currentTimeMillis() - start));
         } catch (Throwable e) {
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/UpgradePatch.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/UpgradePatch.java
index bde1e228..bc8d9bdd 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/UpgradePatch.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/UpgradePatch.java
@@ -17,6 +17,7 @@
 package com.tencent.tinker.lib.patch;
 
 import android.content.Context;
+import android.os.Build;
 
 import com.tencent.tinker.lib.service.PatchResult;
 import com.tencent.tinker.lib.tinker.Tinker;
@@ -49,7 +50,7 @@ public boolean tryPatch(Context context, String tempPatchPath, PatchResult patch
             return false;
         }
 
-        if (!patchFile.isFile() || !patchFile.exists()) {
+        if (!SharePatchFileUtil.isLegalFile(patchFile)) {
             TinkerLog.e(TAG, "UpgradePatch tryPatch:patch file is not found, just return");
             return false;
         }
@@ -59,98 +60,103 @@ public boolean tryPatch(Context context, String tempPatchPath, PatchResult patch
         int returnCode = ShareTinkerInternals.checkTinkerPackage(context, manager.getTinkerFlags(), patchFile, signatureCheck);
         if (returnCode != ShareConstants.ERROR_PACKAGE_CHECK_OK) {
             TinkerLog.e(TAG, "UpgradePatch tryPatch:onPatchPackageCheckFail");
-            manager.getPatchReporter().onPatchPackageCheckFail(patchFile, true, returnCode);
+            manager.getPatchReporter().onPatchPackageCheckFail(patchFile, returnCode);
             return false;
         }
 
-        patchResult.patchTinkerID = signatureCheck.getNewTinkerID();
-        patchResult.baseTinkerID = signatureCheck.getTinkerID();
-
-        //it is a new patch, so we should not find a exist
-        SharePatchInfo oldInfo = manager.getTinkerLoadResultIfPresent().patchInfo;
         String patchMd5 = SharePatchFileUtil.getMD5(patchFile);
-
         if (patchMd5 == null) {
             TinkerLog.e(TAG, "UpgradePatch tryPatch:patch md5 is null, just return");
             return false;
         }
+        TinkerLog.i(TAG, "UpgradePatch tryPatch:patchMd5:%s", patchMd5);
+
+        //check ok, we can real recover a new patch
+        final String patchDirectory = manager.getPatchDirectory().getAbsolutePath();
 
-        //use md5 as version
-        patchResult.patchVersion = patchMd5;
+        File patchInfoLockFile = SharePatchFileUtil.getPatchInfoLockFile(patchDirectory);
+        File patchInfoFile = SharePatchFileUtil.getPatchInfoFile(patchDirectory);
 
+        SharePatchInfo oldInfo = SharePatchInfo.readAndCheckPropertyWithLock(patchInfoFile, patchInfoLockFile);
+
+        //it is a new patch, so we should not find a exist
         SharePatchInfo newInfo;
 
         //already have patch
         if (oldInfo != null) {
-            if (oldInfo.oldVersion == null || oldInfo.newVersion == null) {
+            if (oldInfo.oldVersion == null || oldInfo.newVersion == null || oldInfo.oatDir == null) {
                 TinkerLog.e(TAG, "UpgradePatch tryPatch:onPatchInfoCorrupted");
-                manager.getPatchReporter().onPatchInfoCorrupted(patchFile, oldInfo.oldVersion, oldInfo.newVersion, true);
+                manager.getPatchReporter().onPatchInfoCorrupted(patchFile, oldInfo.oldVersion, oldInfo.newVersion);
                 return false;
             }
 
-            if (oldInfo.oldVersion.equals(patchMd5) || oldInfo.newVersion.equals(patchMd5)) {
-                TinkerLog.e(TAG, "UpgradePatch tryPatch:onPatchVersionCheckFail");
-                manager.getPatchReporter().onPatchVersionCheckFail(patchFile, oldInfo, patchMd5, true);
+            if (!SharePatchFileUtil.checkIfMd5Valid(patchMd5)) {
+                TinkerLog.e(TAG, "UpgradePatch tryPatch:onPatchVersionCheckFail md5 %s is valid", patchMd5);
+                manager.getPatchReporter().onPatchVersionCheckFail(patchFile, oldInfo, patchMd5);
                 return false;
             }
-            newInfo = new SharePatchInfo(oldInfo.oldVersion, patchMd5);
+            // if it is interpret now, use changing flag to wait main process
+            final String finalOatDir = oldInfo.oatDir.equals(ShareConstants.INTERPRET_DEX_OPTIMIZE_PATH)
+                ? ShareConstants.CHANING_DEX_OPTIMIZE_PATH : oldInfo.oatDir;
+            newInfo = new SharePatchInfo(oldInfo.oldVersion, patchMd5, Build.FINGERPRINT, finalOatDir);
         } else {
-            newInfo = new SharePatchInfo("", patchMd5);
+            newInfo = new SharePatchInfo("", patchMd5, Build.FINGERPRINT, ShareConstants.DEFAULT_DEX_OPTIMIZE_PATH);
         }
 
-        //check ok, we can real recover a new patch
-        final String patchDirectory = manager.getPatchDirectory().getAbsolutePath();
-
-        TinkerLog.i(TAG, "UpgradePatch tryPatch:patchMd5:%s", patchMd5);
-
+        //it is a new patch, we first delete if there is any files
+        //don't delete dir for faster retry
+//        SharePatchFileUtil.deleteDir(patchVersionDirectory);
         final String patchName = SharePatchFileUtil.getPatchVersionDirectory(patchMd5);
 
         final String patchVersionDirectory = patchDirectory + "/" + patchName;
 
         TinkerLog.i(TAG, "UpgradePatch tryPatch:patchVersionDirectory:%s", patchVersionDirectory);
 
-        //it is a new patch, we first delete if there is any files
-        //don't delete dir for faster retry
-//        SharePatchFileUtil.deleteDir(patchVersionDirectory);
-
         //copy file
         File destPatchFile = new File(patchVersionDirectory + "/" + SharePatchFileUtil.getPatchVersionFile(patchMd5));
+
         try {
-            SharePatchFileUtil.copyFileUsingStream(patchFile, destPatchFile);
-            TinkerLog.w(TAG, "UpgradePatch after %s size:%d, %s size:%d", patchFile.getAbsolutePath(), patchFile.length(),
-                destPatchFile.getAbsolutePath(), destPatchFile.length());
+            // check md5 first
+            if (!patchMd5.equals(SharePatchFileUtil.getMD5(destPatchFile))) {
+                SharePatchFileUtil.copyFileUsingStream(patchFile, destPatchFile);
+                TinkerLog.w(TAG, "UpgradePatch copy patch file, src file: %s size: %d, dest file: %s size:%d", patchFile.getAbsolutePath(), patchFile.length(),
+                    destPatchFile.getAbsolutePath(), destPatchFile.length());
+            }
         } catch (IOException e) {
 //            e.printStackTrace();
             TinkerLog.e(TAG, "UpgradePatch tryPatch:copy patch file fail from %s to %s", patchFile.getPath(), destPatchFile.getPath());
-            manager.getPatchReporter().onPatchTypeExtractFail(patchFile, destPatchFile, patchFile.getName(), ShareConstants.TYPE_PATCH_FILE, true);
+            manager.getPatchReporter().onPatchTypeExtractFail(patchFile, destPatchFile, patchFile.getName(), ShareConstants.TYPE_PATCH_FILE);
             return false;
         }
 
         //we use destPatchFile instead of patchFile, because patchFile may be deleted during the patch process
-        if (!DexDiffPatchInternal.tryRecoverDexFiles(manager, signatureCheck, context, patchVersionDirectory, destPatchFile, true)) {
+        if (!DexDiffPatchInternal.tryRecoverDexFiles(manager, signatureCheck, context, patchVersionDirectory, destPatchFile)) {
             TinkerLog.e(TAG, "UpgradePatch tryPatch:new patch recover, try patch dex failed");
             return false;
         }
 
-        if (!BsDiffPatchInternal.tryRecoverLibraryFiles(manager, signatureCheck, context, patchVersionDirectory, destPatchFile, true)) {
+        if (!BsDiffPatchInternal.tryRecoverLibraryFiles(manager, signatureCheck, context, patchVersionDirectory, destPatchFile)) {
             TinkerLog.e(TAG, "UpgradePatch tryPatch:new patch recover, try patch library failed");
             return false;
         }
 
-        if (!ResDiffPatchInternal.tryRecoverResourceFiles(manager, signatureCheck, context, patchVersionDirectory, destPatchFile, true)) {
+        if (!ResDiffPatchInternal.tryRecoverResourceFiles(manager, signatureCheck, context, patchVersionDirectory, destPatchFile)) {
             TinkerLog.e(TAG, "UpgradePatch tryPatch:new patch recover, try patch resource failed");
             return false;
         }
 
-        final File patchInfoFile = manager.getPatchInfoFile();
+        // check dex opt file at last, some phone such as VIVO/OPPO like to change dex2oat to interpreted
+        if (!DexDiffPatchInternal.waitAndCheckDexOptFile(patchFile, manager)) {
+            TinkerLog.e(TAG, "UpgradePatch tryPatch:new patch recover, check dex opt file failed");
+            return false;
+        }
 
-        if (!SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile, newInfo, SharePatchFileUtil.getPatchInfoLockFile(patchDirectory))) {
+        if (!SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile, newInfo, patchInfoLockFile)) {
             TinkerLog.e(TAG, "UpgradePatch tryPatch:new patch recover, rewrite patch info failed");
-            manager.getPatchReporter().onPatchInfoCorrupted(patchFile, newInfo.oldVersion, newInfo.newVersion, true);
+            manager.getPatchReporter().onPatchInfoCorrupted(patchFile, newInfo.oldVersion, newInfo.newVersion);
             return false;
         }
 
-
         TinkerLog.w(TAG, "UpgradePatch tryPatch: done, it is ok");
         return true;
     }
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultLoadReporter.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultLoadReporter.java
index 7fe4c3e1..928021db 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultLoadReporter.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultLoadReporter.java
@@ -22,9 +22,12 @@
 import com.tencent.tinker.lib.service.TinkerPatchService;
 import com.tencent.tinker.lib.tinker.Tinker;
 import com.tencent.tinker.lib.tinker.TinkerInstaller;
+import com.tencent.tinker.lib.tinker.TinkerLoadResult;
 import com.tencent.tinker.lib.util.TinkerLog;
+import com.tencent.tinker.lib.util.UpgradePatchRetry;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
 import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
+import com.tencent.tinker.loader.shareutil.SharePatchInfo;
 import com.tencent.tinker.loader.shareutil.ShareTinkerInternals;
 
 import java.io.File;
@@ -54,12 +57,11 @@ public DefaultLoadReporter(Context context) {
      *                  {@code ShareConstants.ERROR_PATCH_NOTEXIST}            the file of tempPatchPatch file is not exist
      *                  {@code ShareConstants.ERROR_PATCH_RUNNING}             the recover service is running now, try later
      *                  {@code ShareConstants.ERROR_PATCH_INSERVICE}           the recover service can't send patch request
-     *
-     * @param isUpgrade whether is a new patch, or just recover the old patch
      */
     @Override
-    public void onLoadPatchListenerReceiveFail(File patchFile, int errorCode, boolean isUpgrade) {
-        TinkerLog.i(TAG, "patch load Reporter: patch receive fail:%s, code:%d, isUpgrade:%b", patchFile.getAbsolutePath(), errorCode, isUpgrade);
+    public void onLoadPatchListenerReceiveFail(File patchFile, int errorCode) {
+        TinkerLog.i(TAG, "patch loadReporter onLoadPatchListenerReceiveFail: patch receive fail: %s, code: %d",
+            patchFile.getAbsolutePath(), errorCode);
     }
 
 
@@ -76,7 +78,7 @@ public void onLoadPatchListenerReceiveFail(File patchFile, int errorCode, boolea
      */
     @Override
     public void onLoadPatchVersionChanged(String oldVersion, String newVersion, File patchDirectoryFile, String currentPatchName) {
-        TinkerLog.i(TAG, "patch version change from " + oldVersion + " to " + newVersion);
+        TinkerLog.i(TAG, "patch loadReporter onLoadPatchVersionChanged: patch version change from " + oldVersion + " to " + newVersion);
 
         if (oldVersion == null || newVersion == null) {
             return;
@@ -89,7 +91,7 @@ public void onLoadPatchVersionChanged(String oldVersion, String newVersion, File
         if (!Tinker.with(context).isMainProcess()) {
             return;
         }
-        TinkerLog.i(TAG, "try kill all other process");
+        TinkerLog.i(TAG, "onLoadPatchVersionChanged, try kill all other process");
         //kill all other process to ensure that all process's code is the same.
         ShareTinkerInternals.killAllOtherProcess(context);
 
@@ -105,6 +107,34 @@ public void onLoadPatchVersionChanged(String oldVersion, String newVersion, File
         }
     }
 
+    /**
+     * After system ota, we will try to load dex with interpret mode
+     *
+     * @param type type define as following
+     *             {@code ShareConstants.TYPE_INTERPRET_OK}                                    it is ok, using interpret mode
+     *             {@code ShareConstants.TYPE_INTERPRET_GET_INSTRUCTION_SET_ERROR}             get instruction set from exist oat file fail
+     *             {@code ShareConstants.TYPE_INTERPRET_COMMAND_ERROR}                         use command line to generate interpret oat file fail
+     * @param e
+     */
+    @Override
+    public void onLoadInterpret(int type, Throwable e) {
+        TinkerLog.i(TAG, "patch loadReporter onLoadInterpret: type: %d, throwable: %s",
+            type, e);
+        switch (type) {
+            case ShareConstants.TYPE_INTERPRET_GET_INSTRUCTION_SET_ERROR:
+                TinkerLog.e(TAG, "patch loadReporter onLoadInterpret fail, can get instruction set from existed oat file");
+                break;
+            case ShareConstants.TYPE_INTERPRET_COMMAND_ERROR:
+                TinkerLog.e(TAG, "patch loadReporter onLoadInterpret fail, command line to interpret return error");
+                break;
+            case ShareConstants.TYPE_INTERPRET_OK:
+                TinkerLog.i(TAG, "patch loadReporter onLoadInterpret ok");
+                break;
+        }
+
+        retryPatch();
+    }
+
     /**
      * some files is not found,
      * we'd like to recover the old patch with {@link TinkerPatchService} in OldPatchProcessor mode
@@ -117,25 +147,19 @@ public void onLoadPatchVersionChanged(String oldVersion, String newVersion, File
      *                    {@code ShareConstants.TYPE_DEX}         patch dex file or directory not found
      *                    {@code ShareConstants.TYPE_LIBRARY}     patch lib file or directory not found
      *                    {@code ShareConstants.TYPE_RESOURCE}    patch lib file or directory not found
-     *
      * @param isDirectory whether is directory for the file type
      */
     @Override
     public void onLoadFileNotFound(File file, int fileType, boolean isDirectory) {
-        TinkerLog.i(TAG, "patch file not found: %s, fileType:%d, isDirectory:%b", file.getAbsolutePath(), fileType, isDirectory);
-        if (fileType == ShareConstants.TYPE_DEX || fileType == ShareConstants.TYPE_DEX_OPT
-            || fileType == ShareConstants.TYPE_LIBRARY || fileType == ShareConstants.TYPE_RESOURCE) {
-            Tinker tinker = Tinker.with(context);
+        TinkerLog.i(TAG, "patch loadReporter onLoadFileNotFound: patch file not found: %s, fileType: %d, isDirectory: %b",
+            file.getAbsolutePath(), fileType, isDirectory);
 
-            //we can recover at any process except recover process
-            if (!tinker.isPatchProcess()) {
-                File patchVersionFile = tinker.getTinkerLoadResultIfPresent().patchVersionFile;
-                if (patchVersionFile != null) {
-                    TinkerInstaller.onReceiveRepairPatch(context, patchVersionFile.getAbsolutePath());
-                }
-            }
-        } else if (fileType == ShareConstants.TYPE_PATCH_FILE || fileType == ShareConstants.TYPE_PATCH_INFO) {
-            Tinker.with(context).cleanPatch();
+        // only try to recover opt file
+        // check dex opt file at last, some phone such as VIVO/OPPO like to change dex2oat to interpreted
+        if (fileType == ShareConstants.TYPE_DEX_OPT) {
+            retryPatch();
+        } else {
+            checkAndCleanPatch();
         }
     }
 
@@ -153,9 +177,9 @@ public void onLoadFileNotFound(File file, int fileType, boolean isDirectory) {
      */
     @Override
     public void onLoadFileMd5Mismatch(File file, int fileType) {
-        TinkerLog.i(TAG, "patch file md5 mismatch file: %s, fileType:%d", file.getAbsolutePath(), fileType);
+        TinkerLog.i(TAG, "patch load Reporter onLoadFileMd5Mismatch: patch file md5 mismatch file: %s, fileType: %d", file.getAbsolutePath(), fileType);
         //clean patch for safety
-        Tinker.with(context).cleanPatch();
+        checkAndCleanPatch();
     }
 
     /**
@@ -169,10 +193,10 @@ public void onLoadFileMd5Mismatch(File file, int fileType) {
      */
     @Override
     public void onLoadPatchInfoCorrupted(String oldVersion, String newVersion, File patchInfoFile) {
-        TinkerLog.i(TAG, "patch info file damage: %s", patchInfoFile.getAbsolutePath());
-        TinkerLog.i(TAG, "patch info file damage from version: %s to version: %s", oldVersion, newVersion);
+        TinkerLog.i(TAG, "patch loadReporter onLoadPatchInfoCorrupted: patch info file damage: %s, from version: %s to version: %s",
+            patchInfoFile.getAbsolutePath(), oldVersion, newVersion);
 
-        Tinker.with(context).cleanPatch();
+        checkAndCleanPatch();
     }
 
     /**
@@ -185,7 +209,7 @@ public void onLoadPatchInfoCorrupted(String oldVersion, String newVersion, File
      */
     @Override
     public void onLoadResult(File patchDirectory, int loadCode, long cost) {
-        TinkerLog.i(TAG, "patch load result, path:%s, code:%d, cost:%d", patchDirectory.getAbsolutePath(), loadCode, cost);
+        TinkerLog.i(TAG, "patch loadReporter onLoadResult: patch load result, path:%s, code: %d, cost: %dms", patchDirectory.getAbsolutePath(), loadCode, cost);
         //you can just report the result here
     }
 
@@ -196,11 +220,11 @@ public void onLoadResult(File patchDirectory, int loadCode, long cost) {
      * you can disable patch as {@link DefaultLoadReporter#onLoadException(Throwable, int)}
      *
      * @param e
-     * @param errorCode    exception code
-     *                     {@code ShareConstants.ERROR_LOAD_EXCEPTION_UNKNOWN}        unknown exception
-     *                     {@code ShareConstants.ERROR_LOAD_EXCEPTION_DEX}            exception when load dex
-     *                     {@code ShareConstants.ERROR_LOAD_EXCEPTION_RESOURCE}       exception when load resource
-     *                     {@code ShareConstants.ERROR_LOAD_EXCEPTION_UNCAUGHT}       exception unCaught
+     * @param errorCode exception code
+     *                  {@code ShareConstants.ERROR_LOAD_EXCEPTION_UNKNOWN}        unknown exception
+     *                  {@code ShareConstants.ERROR_LOAD_EXCEPTION_DEX}            exception when load dex
+     *                  {@code ShareConstants.ERROR_LOAD_EXCEPTION_RESOURCE}       exception when load resource
+     *                  {@code ShareConstants.ERROR_LOAD_EXCEPTION_UNCAUGHT}       exception unCaught
      */
     @Override
     public void onLoadException(Throwable e, int errorCode) {
@@ -208,29 +232,37 @@ public void onLoadException(Throwable e, int errorCode) {
         switch (errorCode) {
             case ShareConstants.ERROR_LOAD_EXCEPTION_DEX:
                 if (e.getMessage().contains(ShareConstants.CHECK_DEX_INSTALL_FAIL)) {
-                    TinkerLog.e(TAG, "tinker dex check fail:" + e.getMessage());
+                    TinkerLog.e(TAG, "patch loadReporter onLoadException: tinker dex check fail:" + e.getMessage());
                 } else {
-                    TinkerLog.i(TAG, "patch load dex exception: %s", e);
+                    TinkerLog.i(TAG, "patch loadReporter onLoadException: patch load dex exception: %s", e);
                 }
                 ShareTinkerInternals.setTinkerDisableWithSharedPreferences(context);
                 TinkerLog.i(TAG, "dex exception disable tinker forever with sp");
                 break;
             case ShareConstants.ERROR_LOAD_EXCEPTION_RESOURCE:
                 if (e.getMessage().contains(ShareConstants.CHECK_RES_INSTALL_FAIL)) {
-                    TinkerLog.e(TAG, "tinker res check fail:" + e.getMessage());
+                    TinkerLog.e(TAG, "patch loadReporter onLoadException: tinker res check fail:" + e.getMessage());
                 } else {
-                    TinkerLog.i(TAG, "patch load resource exception: %s", e);
+                    TinkerLog.i(TAG, "patch loadReporter onLoadException: patch load resource exception: %s", e);
                 }
                 ShareTinkerInternals.setTinkerDisableWithSharedPreferences(context);
                 TinkerLog.i(TAG, "res exception disable tinker forever with sp");
                 break;
             case ShareConstants.ERROR_LOAD_EXCEPTION_UNCAUGHT:
-                TinkerLog.i(TAG, "patch load unCatch exception: %s", e);
+                TinkerLog.i(TAG, "patch loadReporter onLoadException: patch load unCatch exception: %s", e);
                 ShareTinkerInternals.setTinkerDisableWithSharedPreferences(context);
                 TinkerLog.i(TAG, "unCaught exception disable tinker forever with sp");
+
+                String uncaughtString = SharePatchFileUtil.checkTinkerLastUncaughtCrash(context);
+                if (!ShareTinkerInternals.isNullOrNil(uncaughtString)) {
+                    File laseCrashFile = SharePatchFileUtil.getPatchLastCrashFile(context);
+                    SharePatchFileUtil.safeDeleteFile(laseCrashFile);
+                    // found really crash reason
+                    TinkerLog.e(TAG, "tinker uncaught real exception:" + uncaughtString);
+                }
                 break;
             case ShareConstants.ERROR_LOAD_EXCEPTION_UNKNOWN:
-                TinkerLog.i(TAG, "patch load unknown exception: %s", e);
+                TinkerLog.i(TAG, "patch loadReporter onLoadException: patch load unknown exception: %s", e);
                 //exception can be caught, it is no need to disable Tinker with sharedPreference
                 break;
         }
@@ -238,7 +270,7 @@ public void onLoadException(Throwable e, int errorCode) {
         TinkerLog.printErrStackTrace(TAG, e, "tinker load exception");
 
         Tinker.with(context).setTinkerDisable();
-        Tinker.with(context).cleanPatch();
+        checkAndCleanPatch();
     }
     /**
      * check patch signature, TINKER_ID and meta files
@@ -258,7 +290,53 @@ public void onLoadException(Throwable e, int errorCode) {
      */
     @Override
     public void onLoadPackageCheckFail(File patchFile, int errorCode) {
-        TinkerLog.i(TAG, "load patch package check fail file path:%s, errorCode:%d", patchFile.getAbsolutePath(), errorCode);
-        Tinker.with(context).cleanPatch();
+        TinkerLog.i(TAG, "patch loadReporter onLoadPackageCheckFail: "
+            + "load patch package check fail file path: %s, errorCode: %d", patchFile.getAbsolutePath(), errorCode);
+        checkAndCleanPatch();
+    }
+
+    /**
+     * other process may have installed old patch version,
+     * if we try to clean patch, we should kill other process first
+     */
+    public void checkAndCleanPatch() {
+        Tinker tinker = Tinker.with(context);
+        //only main process can load a new patch
+        if (tinker.isMainProcess()) {
+            TinkerLoadResult tinkerLoadResult = tinker.getTinkerLoadResultIfPresent();
+            //if versionChange and the old patch version is not ""
+            if (tinkerLoadResult.versionChanged) {
+                SharePatchInfo sharePatchInfo = tinkerLoadResult.patchInfo;
+                if (sharePatchInfo != null && !ShareTinkerInternals.isNullOrNil(sharePatchInfo.oldVersion)) {
+                    TinkerLog.w(TAG, "checkAndCleanPatch, oldVersion %s is not null, try kill all other process",
+                        sharePatchInfo.oldVersion);
+
+                    ShareTinkerInternals.killAllOtherProcess(context);
+                }
+            }
+        }
+        tinker.cleanPatch();
+
+    }
+
+    public boolean retryPatch() {
+        final Tinker tinker = Tinker.with(context);
+        if (!tinker.isMainProcess()) {
+            return false;
+        }
+
+        File patchVersionFile = tinker.getTinkerLoadResultIfPresent().patchVersionFile;
+        if (patchVersionFile != null) {
+            if (UpgradePatchRetry.getInstance(context).onPatchListenerCheck(SharePatchFileUtil.getMD5(patchVersionFile))) {
+                TinkerLog.i(TAG, "try to repair oat file on patch process");
+                TinkerInstaller.onReceiveUpgradePatch(context, patchVersionFile.getAbsolutePath());
+                return true;
+            } else {
+                TinkerLog.i(TAG, "repair retry exceed must max time, just clean");
+                checkAndCleanPatch();
+            }
+        }
+
+        return false;
     }
 }
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultPatchReporter.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultPatchReporter.java
index f0e813f3..cc43ae28 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultPatchReporter.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultPatchReporter.java
@@ -23,11 +23,14 @@
 import com.tencent.tinker.lib.service.DefaultTinkerResultService;
 import com.tencent.tinker.lib.tinker.Tinker;
 import com.tencent.tinker.lib.util.TinkerLog;
+import com.tencent.tinker.lib.util.UpgradePatchRetry;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
+import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
 import com.tencent.tinker.loader.shareutil.SharePatchInfo;
 import com.tencent.tinker.loader.shareutil.ShareTinkerInternals;
 
 import java.io.File;
+import java.util.List;
 
 /**
  * Created by zhangshaowen on 16/3/14.
@@ -37,6 +40,7 @@
  */
 public class DefaultPatchReporter implements PatchReporter {
     private static final String TAG = "Tinker.DefaultPatchReporter";
+    private static boolean shouldRetry = false;
     protected final Context context;
 
     public DefaultPatchReporter(Context context) {
@@ -52,7 +56,10 @@ public DefaultPatchReporter(Context context) {
      */
     @Override
     public void onPatchServiceStart(Intent intent) {
-        TinkerLog.i(TAG, "patchReporter: patch service start");
+        TinkerLog.i(TAG, "patchReporter onPatchServiceStart: patch service start");
+        shouldRetry = false;
+        UpgradePatchRetry.getInstance(context).onPatchServiceStart(intent);
+
     }
 
     /**
@@ -72,8 +79,9 @@ public void onPatchServiceStart(Intent intent) {
      *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT}          some patch file type is not supported for current tinkerFlag
      */
     @Override
-    public void onPatchPackageCheckFail(File patchFile, boolean isUpgradePatch, int errorCode) {
-        TinkerLog.i(TAG, "patchReporter: package check failed. path:%s, isUpgrade:%b, code:%d", patchFile.getAbsolutePath(), isUpgradePatch, errorCode);
+    public void onPatchPackageCheckFail(File patchFile, int errorCode) {
+        TinkerLog.i(TAG, "patchReporter onPatchPackageCheckFail: package check failed. path: %s, code: %d",
+            patchFile.getAbsolutePath(), errorCode);
         //only meta corrupted, need to delete temp files. others is just in the check time!
         if (errorCode == ShareConstants.ERROR_PACKAGE_CHECK_DEX_META_CORRUPTED
             || errorCode == ShareConstants.ERROR_PACKAGE_CHECK_LIB_META_CORRUPTED
@@ -90,11 +98,11 @@ public void onPatchPackageCheckFail(File patchFile, boolean isUpgradePatch, int
      * @param patchFile        the input patch file to recover
      * @param oldPatchInfo     the current patch info
      * @param patchFileVersion it is the md5 of the input patchFile
-     * @param isUpgradePatch   whether it is a new patch file, or just recover some of the current patch files
      */
     @Override
-    public void onPatchVersionCheckFail(File patchFile, SharePatchInfo oldPatchInfo, String patchFileVersion, boolean isUpgradePatch) {
-        TinkerLog.i(TAG, "patchReporter: patch version exist. path:%s, version:%s, isUpgrade:%b", patchFile.getAbsolutePath(), patchFileVersion, isUpgradePatch);
+    public void onPatchVersionCheckFail(File patchFile, SharePatchInfo oldPatchInfo, String patchFileVersion) {
+        TinkerLog.i(TAG, "patchReporter onPatchVersionCheckFail: patch version exist. path: %s, version: %s",
+            patchFile.getAbsolutePath(), patchFileVersion);
         //no need to delete temp files, because it is only in the check time!
     }
 
@@ -110,12 +118,11 @@ public void onPatchVersionCheckFail(File patchFile, SharePatchInfo oldPatchInfo,
      *                       {@code ShareConstants.TYPE_LIBRARY}     extract patch library fail
      *                       {@code ShareConstants.TYPE_PATCH_FILE}  copy patch file fail
      *                       {@code ShareConstants.TYPE_RESOURCE}    extract patch resource fail
-     * @param isUpgradePatch whether it is a new patch file, or just recover some of the current patch files
      */
     @Override
-    public void onPatchTypeExtractFail(File patchFile, File extractTo, String filename, int fileType, boolean isUpgradePatch) {
-        TinkerLog.i(TAG, "patchReporter: file extract fail type:%s, path:%s, extractTo:%s, filename:%s, isUpgrade:%b",
-            ShareTinkerInternals.getTypeString(fileType), patchFile.getPath(), extractTo.getPath(), filename, isUpgradePatch);
+    public void onPatchTypeExtractFail(File patchFile, File extractTo, String filename, int fileType) {
+        TinkerLog.i(TAG, "patchReporter onPatchTypeExtractFail: file extract fail type: %s, path: %s, extractTo: %s, filename: %s",
+            ShareTinkerInternals.getTypeString(fileType), patchFile.getPath(), extractTo.getPath(), filename);
         //delete temp files
         Tinker.with(context).cleanPatchByVersion(patchFile);
     }
@@ -124,18 +131,24 @@ public void onPatchTypeExtractFail(File patchFile, File extractTo, String filena
      * dex opt failed
      *
      * @param patchFile      the input patch file to recover
-     * @param dexFile        the dex file
-     * @param optDirectory
-     * @param dexName        dexName try to dexOpt
-     * @param isUpgradePatch whether it is a new patch file, or just recover some of the current patch files
+     * @param dexFiles       the dex files
+     * @param t
      */
     @Override
-    public void onPatchDexOptFail(File patchFile, File dexFile, String optDirectory, String dexName, Throwable t, boolean isUpgradePatch) {
-        TinkerLog.i(TAG, "patchReporter: dex opt fail path:%s, dexPath:%s, optDir:%s, dexName:%s, isUpgrade:%b",
-            patchFile.getAbsolutePath(), dexFile.getPath(), optDirectory, dexName, isUpgradePatch);
+    public void onPatchDexOptFail(File patchFile, List<File> dexFiles, Throwable t) {
+        TinkerLog.i(TAG, "patchReporter onPatchDexOptFail: dex opt fail path: %s, dex size: %d",
+            patchFile.getAbsolutePath(), dexFiles.size());
         TinkerLog.printErrStackTrace(TAG, t, "onPatchDexOptFail:");
-        //delete temp files
-        Tinker.with(context).cleanPatchByVersion(patchFile);
+
+        // some phone such as VIVO/OPPO like to change dex2oat to interpreted may go here
+        // check oat file if it is elf format
+        if (t.getMessage().contains(ShareConstants.CHECK_DEX_OAT_EXIST_FAIL)
+            || t.getMessage().contains(ShareConstants.CHECK_DEX_OAT_FORMAT_FAIL)) {
+            shouldRetry = true;
+            deleteOptFiles(dexFiles);
+        } else {
+            Tinker.with(context).cleanPatchByVersion(patchFile);
+        }
     }
 
     /**
@@ -144,12 +157,15 @@ public void onPatchDexOptFail(File patchFile, File dexFile, String optDirectory,
      * @param patchFile      the input patch file to recover
      * @param success        if it is success
      * @param cost           cost time in ms
-     * @param isUpgradePatch whether it is a new patch file, or just recover some of the current patch files
      */
     @Override
-    public void onPatchResult(File patchFile, boolean success, long cost, boolean isUpgradePatch) {
-        TinkerLog.i(TAG, "patchReporter: patch all result path:%s, success:%b, cost:%d, isUpgrade:%b", patchFile.getAbsolutePath(), success, cost, isUpgradePatch);
-        //you can just report the result here
+    public void onPatchResult(File patchFile, boolean success, long cost) {
+        TinkerLog.i(TAG, "patchReporter onPatchResult: patch all result path: %s, success: %b, cost: %d",
+            patchFile.getAbsolutePath(), success, cost);
+        // if should retry don't delete the temp file
+        if (!shouldRetry) {
+            UpgradePatchRetry.getInstance(context).onPatchServiceResult();
+        }
     }
 
     /**
@@ -159,11 +175,11 @@ public void onPatchResult(File patchFile, boolean success, long cost, boolean is
      * @param patchFile      the input patch file to recover
      * @param oldVersion     old patch version
      * @param newVersion     new patch version
-     * @param isUpgradePatch whether it is a new patch file, or just recover some of the current patch files
      */
     @Override
-    public void onPatchInfoCorrupted(File patchFile, String oldVersion, String newVersion, boolean isUpgradePatch) {
-        TinkerLog.i(TAG, "patchReporter: patch info is corrupted. old:%s, new:%s, isUpgradeP:%b", oldVersion, newVersion, isUpgradePatch);
+    public void onPatchInfoCorrupted(File patchFile, String oldVersion, String newVersion) {
+        TinkerLog.i(TAG, "patchReporter onPatchInfoCorrupted: patch info is corrupted. old: %s, new: %s",
+            oldVersion, newVersion);
         //patch.info is corrupted, just clean all patch
         Tinker.with(context).cleanPatch();
     }
@@ -175,16 +191,27 @@ public void onPatchInfoCorrupted(File patchFile, String oldVersion, String newVe
      *
      * @param patchFile      the input file to patch
      * @param e
-     * @param isUpgradePatch whether it is a new patch file, or just recover some of the current patch files
      */
     @Override
-    public void onPatchException(File patchFile, Throwable e, boolean isUpgradePatch) {
-        TinkerLog.i(TAG, "patchReporter: patch exception path:%s, throwable:%s, isUpgrade:%b", patchFile.getAbsolutePath(), e.getMessage(), isUpgradePatch);
+    public void onPatchException(File patchFile, Throwable e) {
+        TinkerLog.i(TAG, "patchReporter onPatchException: patch exception path: %s, throwable: %s",
+            patchFile.getAbsolutePath(), e.getMessage());
         TinkerLog.e(TAG, "tinker patch exception, welcome to submit issue to us: https://github.com/Tencent/tinker/issues");
+//        if (e.getMessage().contains(ShareConstants.CHECK_VM_PROPERTY_FAIL)) {
+//            ShareTinkerInternals.setTinkerDisableWithSharedPreferences(context);
+//            TinkerLog.i(TAG, "check vm property exception disable tinker forever with sp");
+//        }
         TinkerLog.printErrStackTrace(TAG, e, "tinker patch exception");
         //don't accept request any more!
         Tinker.with(context).setTinkerDisable();
         ////delete temp files, I think we don't have to clean all patch
         Tinker.with(context).cleanPatchByVersion(patchFile);
     }
+
+    private void deleteOptFiles(List<File> dexFiles) {
+        for (File file : dexFiles) {
+            SharePatchFileUtil.safeDeleteFile(file);
+        }
+    }
+
 }
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/LoadReporter.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/LoadReporter.java
index 5ca258a9..48818506 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/LoadReporter.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/LoadReporter.java
@@ -36,9 +36,8 @@
      *                  {@code ShareConstants.ERROR_PATCH_NOTEXIST}            the file of tempPatchPatch file is not exist
      *                  {@code ShareConstants.ERROR_PATCH_RUNNING}             the recover service is running now, try later
      *                  {@code ShareConstants.ERROR_PATCH_INSERVICE}           the recover service can't send patch request
-     * @param isUpgrade whether is a new patch, or just recover the old patch
      */
-    void onLoadPatchListenerReceiveFail(File patchFile, int errorCode, boolean isUpgrade);
+    void onLoadPatchListenerReceiveFail(File patchFile, int errorCode);
 
     /**
      * we can only handle patch version change in the main process,
@@ -53,6 +52,15 @@
      */
     void onLoadPatchVersionChanged(String oldVersion, String newVersion, File patchDirectoryFile, String currentPatchName);
 
+    /**
+     * After system ota, we will try to load dex with interpret mode
+     * @param type type define as following
+     *             {@code ShareConstants.TYPE_INTERPRET_OK}                                    it is ok, using interpret mode
+     *             {@code ShareConstants.TYPE_INTERPRET_GET_INSTRUCTION_SET_ERROR}             get instruction set from exist oat file fail
+     *             {@code ShareConstants.TYPE_INTERPRET_COMMAND_ERROR}                         use command line to generate interpret oat file fail
+     * @param e
+     */
+    void onLoadInterpret(int type, Throwable e);
     /**
      * the load patch process is end, we can see the cost times and the return code
      * return codes are define in {@link com.tencent.tinker.loader.shareutil.ShareConstants}
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/PatchReporter.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/PatchReporter.java
index e9ac07d2..fee683bf 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/PatchReporter.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/PatchReporter.java
@@ -19,22 +19,18 @@
 
 import android.content.Intent;
 
-import com.tencent.tinker.lib.patch.RepairPatch;
 import com.tencent.tinker.lib.patch.UpgradePatch;
 import com.tencent.tinker.lib.service.DefaultTinkerResultService;
 import com.tencent.tinker.loader.shareutil.SharePatchInfo;
 
 import java.io.File;
+import java.util.List;
 
 /**
  * Created by zhangshaowen on 16/3/14.
  *
- * isUpgradePatch:
- * true: means that it is a newly patch, we would default use {@link UpgradePatch}
+ * means that it is a newly patch, we would default use {@link UpgradePatch}
  * to do the job
- *
- * false: means that there are some files missing in current patch, we want to repair them,
- * we would default use {@link RepairPatch} to do the recover patch job
  */
 public interface PatchReporter {
 
@@ -61,7 +57,7 @@
      *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_RESOURCE_META_CORRUPTED}         resource meta file's format check fail
      *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT}          some patch file type is not supported for current tinkerFlag
      */
-    void onPatchPackageCheckFail(File patchFile, boolean isUpgradePatch, int errorCode);
+    void onPatchPackageCheckFail(File patchFile, int errorCode);
 
     /**
      * for upgrade patch, patchFileVersion can't equal oldVersion or newVersion in oldPatchInfo
@@ -70,9 +66,8 @@
      * @param patchFile        the input patch file to recover
      * @param oldPatchInfo     the current patch info
      * @param patchFileVersion it is the md5 of the input patchFile
-     * @param isUpgradePatch   whether it is a new patch file, or just recover some of the current patch files
      */
-    void onPatchVersionCheckFail(File patchFile, SharePatchInfo oldPatchInfo, String patchFileVersion, boolean isUpgradePatch);
+    void onPatchVersionCheckFail(File patchFile, SharePatchInfo oldPatchInfo, String patchFileVersion);
 
 
     /**
@@ -87,22 +82,18 @@
      *                       {@code ShareConstants.TYPE_LIBRARY}     extract patch library fail
      *                       {@code ShareConstants.TYPE_PATCH_FILE}  copy patch file fail
      *                       {@code ShareConstants.TYPE_RESOURCE}    extract patch resource fail
-     * @param isUpgradePatch whether it is a new patch file, or just recover some of the current patch files
      */
-    void onPatchTypeExtractFail(File patchFile, File extractTo, String filename, int fileType, boolean isUpgradePatch);
+    void onPatchTypeExtractFail(File patchFile, File extractTo, String filename, int fileType);
 
 
     /**
      * dex opt failed
      *
      * @param patchFile      the input patch file to recover
-     * @param dexFile        the dex file
-     * @param optDirectory
-     * @param dexName        dexName try to dexOpt
+     * @param dexFiles       the dex file
      * @param t              throwable
-     * @param isUpgradePatch whether it is a new patch file, or just recover some of the current patch files
      */
-    void onPatchDexOptFail(File patchFile, File dexFile, String optDirectory, String dexName, Throwable t, boolean isUpgradePatch);
+    void onPatchDexOptFail(File patchFile, List<File> dexFiles, Throwable t);
 
 
     /**
@@ -111,9 +102,8 @@
      * @param patchFile      the input patch file to recover
      * @param success        if it is success
      * @param cost           cost time in ms
-     * @param isUpgradePatch whether it is a new patch file, or just recover some of the current patch files
      */
-    void onPatchResult(File patchFile, boolean success, long cost, boolean isUpgradePatch);
+    void onPatchResult(File patchFile, boolean success, long cost);
 
     /**
      * recover patch occur unknown exception that we have wrap try catch for you!
@@ -122,9 +112,8 @@
      *
      * @param patchFile      the input file to patch
      * @param e
-     * @param isUpgradePatch whether it is a new patch file, or just recover some of the current patch files
      */
-    void onPatchException(File patchFile, Throwable e, boolean isUpgradePatch);
+    void onPatchException(File patchFile, Throwable e);
 
     /**
      * when we load a new patch, we need to rewrite the patch.info file.
@@ -133,8 +122,7 @@
      * @param patchFile      the input patch file to recover
      * @param oldVersion     old patch version
      * @param newVersion     new patch version
-     * @param isUpgradePatch whether it is a new patch file, or just recover some of the current patch files
      */
-    void onPatchInfoCorrupted(File patchFile, String oldVersion, String newVersion, boolean isUpgradePatch);
+    void onPatchInfoCorrupted(File patchFile, String oldVersion, String newVersion);
 
 }
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/AbstractResultService.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/AbstractResultService.java
index 0ecb1bca..95429503 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/AbstractResultService.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/AbstractResultService.java
@@ -32,7 +32,6 @@
 
     private static final String RESULT_EXTRA = "result_extra";
 
-    private static Class<? extends AbstractResultService> resultServiceClass = null;
 
     /**
      * Creates an IntentService.  Invoked by your subclass's constructor.
@@ -41,25 +40,19 @@ public AbstractResultService() {
         super(AbstractResultService.class.getSimpleName());
     }
 
-    public static void runResultService(Context context, PatchResult result) {
+    public static void runResultService(Context context, PatchResult result, String resultServiceClass) {
         if (resultServiceClass == null) {
             throw new TinkerRuntimeException("resultServiceClass is null.");
         }
-        Intent intent = new Intent(context, resultServiceClass);
-        intent.putExtra(RESULT_EXTRA, result);
-
-        context.startService(intent);
-    }
-
-    public static void setResultServiceClass(Class<? extends AbstractResultService> serviceClass) {
-        resultServiceClass = serviceClass;
-        //try to load
         try {
-            Class.forName(serviceClass.getName());
-        } catch (ClassNotFoundException e) {
-//            e.printStackTrace();
-        }
+            Intent intent = new Intent();
+            intent.setClassName(context, resultServiceClass);
+            intent.putExtra(RESULT_EXTRA, result);
 
+            context.startService(intent);
+        } catch (Throwable throwable) {
+            TinkerLog.e(TAG, "run result service fail, exception:" + throwable);
+        }
     }
 
     @Override
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/DefaultTinkerResultService.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/DefaultTinkerResultService.java
index 078fb5ad..6291a457 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/DefaultTinkerResultService.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/DefaultTinkerResultService.java
@@ -21,6 +21,7 @@
 import com.tencent.tinker.lib.tinker.TinkerLoadResult;
 import com.tencent.tinker.lib.util.TinkerLog;
 import com.tencent.tinker.lib.util.TinkerServiceInternals;
+import com.tencent.tinker.loader.shareutil.ShareConstants;
 import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
 
 import java.io.File;
@@ -49,23 +50,41 @@ public void onPatchResult(PatchResult result) {
 
         // if success and newPatch, it is nice to delete the raw file, and restart at once
         // only main process can load an upgrade patch!
-        if (result.isSuccess && result.isUpgradePatch) {
-            File rawFile = new File(result.rawPatchFilePath);
-            if (rawFile.exists()) {
-                TinkerLog.i(TAG, "save delete raw patch file");
-                SharePatchFileUtil.safeDeleteFile(rawFile);
-            }
+        if (result.isSuccess) {
+            deleteRawPatchFile(new File(result.rawPatchFilePath));
             if (checkIfNeedKill(result)) {
                 android.os.Process.killProcess(android.os.Process.myPid());
             } else {
                 TinkerLog.i(TAG, "I have already install the newly patch version!");
             }
         }
+    }
 
-        //repair current patch fail, just clean!
-        if (!result.isSuccess && !result.isUpgradePatch) {
-            Tinker.with(getApplicationContext()).cleanPatch();
+    /**
+     * don't delete tinker version file
+     * @param rawFile
+     */
+    public void deleteRawPatchFile(File rawFile) {
+        if (!SharePatchFileUtil.isLegalFile(rawFile)) {
+            return;
         }
+        TinkerLog.w(TAG, "deleteRawPatchFile rawFile path: %s", rawFile.getPath());
+        String fileName = rawFile.getName();
+        if (!fileName.startsWith(ShareConstants.PATCH_BASE_NAME)
+            || !fileName.endsWith(ShareConstants.PATCH_SUFFIX)) {
+            SharePatchFileUtil.safeDeleteFile(rawFile);
+            return;
+        }
+        File parentFile = rawFile.getParentFile();
+        if (!parentFile.getName().startsWith(ShareConstants.PATCH_BASE_NAME)) {
+            SharePatchFileUtil.safeDeleteFile(rawFile);
+        } else {
+            File grandFile = parentFile.getParentFile();
+            if (!grandFile.getName().equals(ShareConstants.PATCH_DIRECTORY_NAME)) {
+                SharePatchFileUtil.safeDeleteFile(rawFile);
+            }
+        }
+
     }
 
     public boolean checkIfNeedKill(PatchResult result) {
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/PatchResult.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/PatchResult.java
index 9991c4e0..268a4dd8 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/PatchResult.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/PatchResult.java
@@ -22,8 +22,6 @@
  * Created by zhangshaowen on 16/3/19.
  */
 public class PatchResult implements Serializable {
-    public boolean isUpgradePatch;
-
     public boolean isSuccess;
 
     public String rawPatchFilePath;
@@ -35,29 +33,16 @@
     //@Nullable
     public String patchVersion;
 
-    //@Nullable
-    public String patchTinkerID;
-
-    //@Nullable
-    public String baseTinkerID;
-
     @Override
     public String toString() {
         StringBuffer sb = new StringBuffer();
         sb.append("\nPatchResult: \n");
-        sb.append("isUpgradePatch:" + isUpgradePatch + "\n");
         sb.append("isSuccess:" + isSuccess + "\n");
         sb.append("rawPatchFilePath:" + rawPatchFilePath + "\n");
         sb.append("costTime:" + costTime + "\n");
         if (patchVersion != null) {
             sb.append("patchVersion:" + patchVersion + "\n");
         }
-        if (patchTinkerID != null) {
-            sb.append("patchTinkerID:" + patchTinkerID + "\n");
-        }
-        if (baseTinkerID != null) {
-            sb.append("baseTinkerID:" + baseTinkerID + "\n");
-        }
 
         if (e != null) {
             sb.append("Throwable:" + e.getMessage() + "\n");
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/TinkerPatchService.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/TinkerPatchService.java
index 5afbdf35..db7d4526 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/TinkerPatchService.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/TinkerPatchService.java
@@ -41,10 +41,11 @@
     private static final String TAG = "Tinker.TinkerPatchService";
 
     private static final String        PATCH_PATH_EXTRA      = "patch_path_extra";
-    private static final String        PATCH_NEW_EXTRA       = "patch_new_extra";
+    private static final String        RESULT_CLASS_EXTRA    = "patch_result_class";
+
     private static       AbstractPatch upgradePatchProcessor = null;
-    private static       AbstractPatch repairPatchProcessor  = null;
-    private static       int           notificationId        = ShareConstants.TINKER_PATCH_SERVICE_NOTIFICATION;
+    private static       int                                    notificationId       = ShareConstants.TINKER_PATCH_SERVICE_NOTIFICATION;
+    private static       Class<? extends AbstractResultService> resultServiceClass   = null;
 
     /**
      * Creates an IntentService.  Invoked by your subclass's constructor.
@@ -53,17 +54,26 @@ public TinkerPatchService() {
         super(TinkerPatchService.class.getSimpleName());
     }
 
-    public static void runPatchService(Context context, String path, boolean isUpgradePatch) {
-        Intent intent = new Intent(context, TinkerPatchService.class);
-        intent.putExtra(PATCH_PATH_EXTRA, path);
-        intent.putExtra(PATCH_NEW_EXTRA, isUpgradePatch);
-
-        context.startService(intent);
+    public static void runPatchService(Context context, String path) {
+        try {
+            Intent intent = new Intent(context, TinkerPatchService.class);
+            intent.putExtra(PATCH_PATH_EXTRA, path);
+            intent.putExtra(RESULT_CLASS_EXTRA, resultServiceClass.getName());
+            context.startService(intent);
+        } catch (Throwable throwable) {
+            TinkerLog.e(TAG, "start patch service fail, exception:" + throwable);
+        }
     }
 
-    public static void setPatchProcessor(AbstractPatch upgradePatch, AbstractPatch repairPatch) {
+    public static void setPatchProcessor(AbstractPatch upgradePatch, Class<? extends AbstractResultService> serviceClass) {
         upgradePatchProcessor = upgradePatch;
-        repairPatchProcessor = repairPatch;
+        resultServiceClass = serviceClass;
+        //try to load
+        try {
+            Class.forName(serviceClass.getName());
+        } catch (ClassNotFoundException e) {
+//            e.printStackTrace();
+        }
     }
 
     public static String getPatchPathExtra(Intent intent) {
@@ -73,11 +83,11 @@ public static String getPatchPathExtra(Intent intent) {
         return ShareIntentUtil.getStringExtra(intent, PATCH_PATH_EXTRA);
     }
 
-    public static boolean getPatchUpgradeExtra(Intent intent) {
+    public static String getPatchResultExtra(Intent intent) {
         if (intent == null) {
-            throw new TinkerRuntimeException("getPatchUpgradeExtra, but intent is null");
+            throw new TinkerRuntimeException("getPatchResultExtra, but intent is null");
         }
-        return ShareIntentUtil.getBooleanExtra(intent, PATCH_NEW_EXTRA, false);
+        return ShareIntentUtil.getStringExtra(intent, RESULT_CLASS_EXTRA);
     }
 
     /**
@@ -105,8 +115,6 @@ protected void onHandleIntent(Intent intent) {
         }
         File patchFile = new File(path);
 
-        boolean isUpgradePatch = getPatchUpgradeExtra(intent);
-
         long begin = SystemClock.elapsedRealtime();
         boolean result;
         long cost;
@@ -115,44 +123,34 @@ protected void onHandleIntent(Intent intent) {
         increasingPriority();
         PatchResult patchResult = new PatchResult();
         try {
-            if (isUpgradePatch) {
-                if (upgradePatchProcessor == null) {
-                    throw new TinkerRuntimeException("upgradePatchProcessor is null.");
-                }
-                result = upgradePatchProcessor.tryPatch(context, path, patchResult);
-
-            } else {
-                //just recover from exist patch
-                if (repairPatchProcessor == null) {
-                    throw new TinkerRuntimeException("upgradePatchProcessor is null.");
-                }
-                result = repairPatchProcessor.tryPatch(context, path, patchResult);
+            if (upgradePatchProcessor == null) {
+                throw new TinkerRuntimeException("upgradePatchProcessor is null.");
             }
+            result = upgradePatchProcessor.tryPatch(context, path, patchResult);
         } catch (Throwable throwable) {
             e = throwable;
             result = false;
-            tinker.getPatchReporter().onPatchException(patchFile, e, isUpgradePatch);
+            tinker.getPatchReporter().onPatchException(patchFile, e);
         }
 
         cost = SystemClock.elapsedRealtime() - begin;
         tinker.getPatchReporter().
-            onPatchResult(patchFile, result, cost, isUpgradePatch);
+            onPatchResult(patchFile, result, cost);
 
         patchResult.isSuccess = result;
-        patchResult.isUpgradePatch = isUpgradePatch;
         patchResult.rawPatchFilePath = path;
         patchResult.costTime = cost;
         patchResult.e = e;
 
-        AbstractResultService.runResultService(context, patchResult);
+        AbstractResultService.runResultService(context, patchResult, getPatchResultExtra(intent));
 
     }
 
     private void increasingPriority() {
-        if (Build.VERSION.SDK_INT > 24) {
-            TinkerLog.i(TAG, "for Android 7.1, we just ignore increasingPriority job");
-            return;
-        }
+//        if (Build.VERSION.SDK_INT > 24) {
+//            TinkerLog.i(TAG, "for Android 7.1, we just ignore increasingPriority job");
+//            return;
+//        }
         TinkerLog.i(TAG, "try to increase patch process priority");
         try {
             Notification notification = new Notification();
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/Tinker.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/Tinker.java
index 8e46e2e7..ce514be5 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/Tinker.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/Tinker.java
@@ -22,7 +22,6 @@
 import com.tencent.tinker.lib.listener.DefaultPatchListener;
 import com.tencent.tinker.lib.listener.PatchListener;
 import com.tencent.tinker.lib.patch.AbstractPatch;
-import com.tencent.tinker.lib.patch.RepairPatch;
 import com.tencent.tinker.lib.patch.UpgradePatch;
 import com.tencent.tinker.lib.reporter.DefaultLoadReporter;
 import com.tencent.tinker.lib.reporter.DefaultPatchReporter;
@@ -58,6 +57,7 @@
     final LoadReporter  loadReporter;
     final PatchReporter patchReporter;
     final File          patchInfoFile;
+    final File          patchInfoLockFile;
     final boolean       isMainProcess;
     final boolean       isPatchProcess;
     /**
@@ -76,7 +76,7 @@
     private boolean loaded = false;
 
     private Tinker(Context context, int tinkerFlags, LoadReporter loadReporter, PatchReporter patchReporter,
-                   PatchListener listener, File patchDirectory, File patchInfoFile,
+                   PatchListener listener, File patchDirectory, File patchInfoFile, File patchInfoLockFile,
                    boolean isInMainProc, boolean isPatchProcess, boolean tinkerLoadVerifyFlag) {
         this.context = context;
         this.listener = listener;
@@ -85,6 +85,7 @@ private Tinker(Context context, int tinkerFlags, LoadReporter loadReporter, Patc
         this.tinkerFlags = tinkerFlags;
         this.patchDirectory = patchDirectory;
         this.patchInfoFile = patchInfoFile;
+        this.patchInfoLockFile = patchInfoLockFile;
         this.isMainProcess = isInMainProc;
         this.tinkerLoadVerifyFlag = tinkerLoadVerifyFlag;
         this.isPatchProcess = isPatchProcess;
@@ -124,20 +125,23 @@ public static void create(Tinker tinker) {
         sInstance = tinker;
     }
 
+    public static boolean isTinkerInstalled() {
+        return sInstalled;
+    }
+
     /**
      * you must install tinker first!!
      *
      * @param intentResult
      * @param serviceClass
      * @param upgradePatch
-     * @param repairPatch
      */
     public void install(Intent intentResult, Class<? extends AbstractResultService> serviceClass,
-                        AbstractPatch upgradePatch, AbstractPatch repairPatch
-    ) {
+                        AbstractPatch upgradePatch) {
         sInstalled = true;
-        AbstractResultService.setResultServiceClass(serviceClass);
-        TinkerPatchService.setPatchProcessor(upgradePatch, repairPatch);
+        TinkerPatchService.setPatchProcessor(upgradePatch, serviceClass);
+
+        TinkerLog.i(TAG, "try to install tinker, isEnable: %b, version: %s", isTinkerEnabled(), ShareConstants.TINKER_VERSION);
 
         if (!isTinkerEnabled()) {
             TinkerLog.e(TAG, "tinker is disabled");
@@ -165,7 +169,6 @@ public void setPatchServiceNotificationId(int id) {
         TinkerPatchService.setTinkerNotificationId(id);
     }
 
-
     /**
      * Nullable, should check the loaded flag first
      */
@@ -174,7 +177,7 @@ public TinkerLoadResult getTinkerLoadResultIfPresent() {
     }
 
     public void install(Intent intentResult) {
-        install(intentResult, DefaultTinkerResultService.class, new UpgradePatch(), new RepairPatch());
+        install(intentResult, DefaultTinkerResultService.class, new UpgradePatch());
     }
 
     public Context getContext() {
@@ -201,7 +204,6 @@ public PatchReporter getPatchReporter() {
         return patchReporter;
     }
 
-
     public boolean isTinkerEnabled() {
         return ShareTinkerInternals.isTinkerEnabled(tinkerFlags);
     }
@@ -214,10 +216,6 @@ public void setTinkerLoaded(boolean isLoaded) {
         loaded = isLoaded;
     }
 
-    public boolean isTinkerInstalled() {
-        return sInstalled;
-    }
-
     public boolean isTinkerLoadVerify() {
         return tinkerLoadVerifyFlag;
     }
@@ -242,6 +240,10 @@ public File getPatchInfoFile() {
         return patchInfoFile;
     }
 
+    public File getPatchInfoLockFile() {
+        return patchInfoLockFile;
+    }
+
     public PatchListener getPatchListener() {
         return listener;
     }
@@ -264,6 +266,21 @@ public void cleanPatch() {
         SharePatchFileUtil.deleteDir(patchDirectory);
     }
 
+    /**
+     * rollback patch should restart all process
+     */
+    public void rollbackPatch() {
+        if (!isTinkerLoaded()) {
+            TinkerLog.w(TAG, "rollbackPatch: tinker is not loaded, just return");
+            return;
+        }
+        // kill all other process
+        ShareTinkerInternals.killAllOtherProcess(context);
+        // clean patch
+        cleanPatch();
+        // kill itself
+        android.os.Process.killProcess(android.os.Process.myPid());
+    }
     /**
      * clean the patch version files, such as tinker/patch-641e634c
      *
@@ -315,6 +332,7 @@ public void cleanPatchByVersion(File patchFile) {
         private PatchListener listener;
         private File          patchDirectory;
         private File          patchInfoFile;
+        private File          patchInfoLockFile;
         private Boolean       tinkerLoadVerifyFlag;
 
         /**
@@ -333,6 +351,7 @@ public Builder(Context context) {
                 return;
             }
             this.patchInfoFile = SharePatchFileUtil.getPatchInfoFile(patchDirectory.getAbsolutePath());
+            this.patchInfoLockFile = SharePatchFileUtil.getPatchInfoLockFile(patchDirectory.getAbsolutePath());
             TinkerLog.w(TAG, "tinker patch directory: %s", patchDirectory);
         }
 
@@ -410,7 +429,7 @@ public Tinker build() {
             }
 
             return new Tinker(context, status, loadReporter, patchReporter, listener, patchDirectory,
-                patchInfoFile, mainProcess, patchProcess, tinkerLoadVerifyFlag);
+                patchInfoFile, patchInfoLockFile, mainProcess, patchProcess, tinkerLoadVerifyFlag);
         }
     }
 
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerInstaller.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerInstaller.java
index 1fa7eb21..9cb71ac0 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerInstaller.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerInstaller.java
@@ -24,12 +24,7 @@
 import com.tencent.tinker.lib.reporter.PatchReporter;
 import com.tencent.tinker.lib.service.AbstractResultService;
 import com.tencent.tinker.lib.util.TinkerLog;
-import com.tencent.tinker.loader.TinkerRuntimeException;
 import com.tencent.tinker.loader.app.ApplicationLike;
-import com.tencent.tinker.loader.shareutil.ShareConstants;
-import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
-
-import java.io.File;
 
 /**
  * Created by zhangshaowen on 16/3/19.
@@ -43,10 +38,11 @@
      *
      * @param applicationLike
      */
-    public static void install(ApplicationLike applicationLike) {
+    public static Tinker install(ApplicationLike applicationLike) {
         Tinker tinker = new Tinker.Builder(applicationLike.getApplication()).build();
         Tinker.create(tinker);
         tinker.install(applicationLike.getTinkerResultIntent());
+        return tinker;
     }
 
     /**
@@ -59,11 +55,10 @@ public static void install(ApplicationLike applicationLike) {
      * @param listener
      * @param resultServiceClass
      * @param upgradePatchProcessor
-     * @param repairPatchProcessor
      */
-    public static void install(ApplicationLike applicationLike, LoadReporter loadReporter, PatchReporter patchReporter,
+    public static Tinker install(ApplicationLike applicationLike, LoadReporter loadReporter, PatchReporter patchReporter,
                                PatchListener listener, Class<? extends AbstractResultService> resultServiceClass,
-                               AbstractPatch upgradePatchProcessor, AbstractPatch repairPatchProcessor) {
+                               AbstractPatch upgradePatchProcessor) {
 
         Tinker tinker = new Tinker.Builder(applicationLike.getApplication())
             .tinkerFlags(applicationLike.getTinkerFlags())
@@ -73,9 +68,8 @@ public static void install(ApplicationLike applicationLike, LoadReporter loadRep
             .tinkerLoadVerifyFlag(applicationLike.getTinkerLoadVerifyFlag()).build();
 
         Tinker.create(tinker);
-        tinker.install(applicationLike.getTinkerResultIntent(), resultServiceClass, upgradePatchProcessor, repairPatchProcessor);
-
-
+        tinker.install(applicationLike.getTinkerResultIntent(), resultServiceClass, upgradePatchProcessor);
+        return tinker;
     }
 
     /**
@@ -94,18 +88,7 @@ public static void cleanPatch(Context context) {
      * @param patchLocation
      */
     public static void onReceiveUpgradePatch(Context context, String patchLocation) {
-        Tinker.with(context).getPatchListener().onPatchReceived(patchLocation, true);
-    }
-
-    /**
-     * some file does not exist, repair them with :patch process
-     * Generally you will not use it
-     *
-     * @param context
-     * @param patchLocation
-     */
-    public static void onReceiveRepairPatch(Context context, String patchLocation) {
-        Tinker.with(context).getPatchListener().onPatchReceived(patchLocation, false);
+        Tinker.with(context).getPatchListener().onPatchReceived(patchLocation);
     }
 
     /**
@@ -116,91 +99,4 @@ public static void onReceiveRepairPatch(Context context, String patchLocation) {
     public static void setLogIml(TinkerLog.TinkerLogImp imp) {
         TinkerLog.setTinkerLogImp(imp);
     }
-
-    /**
-     * sample usage for native library
-     *
-     * @param context
-     * @param relativePath such as lib/armeabi
-     * @param libname      for the lib libTest.so, you can pass Test or libTest, or libTest.so
-     * @return boolean
-     * @throws UnsatisfiedLinkError
-     */
-    public static boolean loadLibraryFromTinker(Context context, String relativePath, String libname) throws UnsatisfiedLinkError {
-        final Tinker tinker = Tinker.with(context);
-
-        libname = libname.startsWith("lib") ? libname : "lib" + libname;
-        libname = libname.endsWith(".so") ? libname : libname + ".so";
-        String relativeLibPath = relativePath + "/" + libname;
-
-        //TODO we should add cpu abi, and the real path later
-        if (tinker.isEnabledForNativeLib() && tinker.isTinkerLoaded()) {
-            TinkerLoadResult loadResult = tinker.getTinkerLoadResultIfPresent();
-            if (loadResult.libs != null) {
-                for (String name : loadResult.libs.keySet()) {
-                    if (name.equals(relativeLibPath)) {
-                        String patchLibraryPath = loadResult.libraryDirectory + "/" + name;
-                        File library = new File(patchLibraryPath);
-                        if (library.exists()) {
-                            //whether we check md5 when load
-                            boolean verifyMd5 = tinker.isTinkerLoadVerify();
-                            if (verifyMd5 && !SharePatchFileUtil.verifyFileMd5(library, loadResult.libs.get(name))) {
-                                tinker.getLoadReporter().onLoadFileMd5Mismatch(library, ShareConstants.TYPE_LIBRARY);
-                            } else {
-                                System.load(patchLibraryPath);
-                                TinkerLog.i(TAG, "loadLibraryFromTinker success:" + patchLibraryPath);
-                                return true;
-                            }
-                        }
-                    }
-                }
-            }
-        }
-
-        return false;
-    }
-
-    /**
-     * you can use TinkerInstaller.loadLibrary replace your System.loadLibrary for auto update library!
-     * only support auto load lib/armeabi library from patch.
-     * for other library in lib/* or assets,
-     * you can load through {@code TinkerInstaller#loadLibraryFromTinker}
-     */
-    public static void loadArmLibrary(Context context, String libName) {
-        if (libName == null || libName.isEmpty() || context == null) {
-            throw new TinkerRuntimeException("libName or context is null!");
-        }
-
-        Tinker tinker = Tinker.with(context);
-        if (tinker.isEnabledForNativeLib()) {
-            if (TinkerInstaller.loadLibraryFromTinker(context, "lib/armeabi", libName)) {
-                return;
-            }
-
-        }
-        System.loadLibrary(libName);
-    }
-
-    /**
-     * you can use TinkerInstaller.loadArmV7Library replace your System.loadLibrary for auto update library!
-     * only support auto load lib/armeabi-v7a library from patch.
-     * for other library in lib/* or assets,
-     * you can load through {@code TinkerInstaller#loadLibraryFromTinker}
-     */
-    public static void loadArmV7Library(Context context, String libName) {
-        if (libName == null || libName.isEmpty() || context == null) {
-            throw new TinkerRuntimeException("libName or context is null!");
-        }
-
-        Tinker tinker = Tinker.with(context);
-        if (tinker.isEnabledForNativeLib()) {
-            if (TinkerInstaller.loadLibraryFromTinker(context, "lib/armeabi-v7a", libName)) {
-                return;
-            }
-
-        }
-        System.loadLibrary(libName);
-    }
-
-
 }
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerLoadResult.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerLoadResult.java
index 46316274..02602bc6 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerLoadResult.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerLoadResult.java
@@ -18,6 +18,7 @@
 
 import android.content.Context;
 import android.content.Intent;
+import android.os.Build;
 
 import com.tencent.tinker.lib.util.TinkerLog;
 import com.tencent.tinker.loader.TinkerRuntimeException;
@@ -39,8 +40,15 @@
     public SharePatchInfo patchInfo;
     //@Nullable
     public String         currentVersion;
+    //@Nullable
+    public String         oatDir;
+
+    public boolean versionChanged;
+
+    public boolean useInterpretMode;
+
+    public boolean systemOTA;
 
-    public boolean                 versionChanged;
     //@Nullable
     public File                    patchVersionDirectory;
     //@Nullable
@@ -67,9 +75,17 @@
     public boolean parseTinkerResult(Context context, Intent intentResult) {
         Tinker tinker = Tinker.with(context);
         loadCode = ShareIntentUtil.getIntentReturnCode(intentResult);
-        TinkerLog.i(TAG, "parseTinkerResult loadCode:%d", loadCode);
 
         costTime = ShareIntentUtil.getIntentPatchCostTime(intentResult);
+        systemOTA = ShareIntentUtil.getBooleanExtra(intentResult, ShareIntentUtil.INTENT_PATCH_SYSTEM_OTA, false);
+        oatDir = ShareIntentUtil.getStringExtra(intentResult, ShareIntentUtil.INTENT_PATCH_OAT_DIR);
+        useInterpretMode = ShareConstants.INTERPRET_DEX_OPTIMIZE_PATH.equals(oatDir);
+
+        final boolean isMainProcess = tinker.isMainProcess();
+
+        TinkerLog.i(TAG, "parseTinkerResult loadCode:%d, process name:%s, main process:%b, systemOTA:%b, oatDir:%s, useInterpretMode:%b",
+            loadCode, ShareTinkerInternals.getProcessName(context), isMainProcess, systemOTA, oatDir, useInterpretMode);
+
         //@Nullable
         final String oldVersion = ShareIntentUtil.getStringExtra(intentResult, ShareIntentUtil.INTENT_PATCH_OLD_VERSION);
         //@Nullable
@@ -78,9 +94,6 @@ public boolean parseTinkerResult(Context context, Intent intentResult) {
         final File patchDirectory = tinker.getPatchDirectory();
         final File patchInfoFile = tinker.getPatchInfoFile();
 
-        final boolean isMainProcess = tinker.isMainProcess();
-
-
         if (oldVersion != null && newVersion != null) {
             if (isMainProcess) {
                 currentVersion = newVersion;
@@ -100,7 +113,7 @@ public boolean parseTinkerResult(Context context, Intent intentResult) {
                 resourceDirectory = new File(patchVersionDirectory, ShareConstants.RES_PATH);
                 resourceFile = new File(resourceDirectory, ShareConstants.RES_NAME);
             }
-            patchInfo = new SharePatchInfo(oldVersion, newVersion);
+            patchInfo = new SharePatchInfo(oldVersion, newVersion, Build.FINGERPRINT, oatDir);
             versionChanged = !(oldVersion.equals(newVersion));
         }
 
@@ -298,6 +311,12 @@ public boolean parseTinkerResult(Context context, Intent intentResult) {
                 tinker.getLoadReporter().onLoadFileMd5Mismatch(resourceFile,
                     ShareConstants.TYPE_RESOURCE);
                 break;
+            case ShareConstants.ERROR_LOAD_PATCH_GET_OTA_INSTRUCTION_SET_EXCEPTION:
+                tinker.getLoadReporter().onLoadInterpret(ShareConstants.TYPE_INTERPRET_GET_INSTRUCTION_SET_ERROR, ShareIntentUtil.getIntentInterpretException(intentResult));
+                break;
+            case ShareConstants.ERROR_LOAD_PATCH_OTA_INTERPRET_ONLY_EXCEPTION:
+                tinker.getLoadReporter().onLoadInterpret(ShareConstants.TYPE_INTERPRET_COMMAND_ERROR, ShareIntentUtil.getIntentInterpretException(intentResult));
+                break;
             case ShareConstants.ERROR_LOAD_OK:
                 TinkerLog.i(TAG, "oh yeah, tinker load all success");
                 tinker.setTinkerLoaded(true);
@@ -307,11 +326,12 @@ public boolean parseTinkerResult(Context context, Intent intentResult) {
 
                 packageConfig = ShareIntentUtil.getIntentPackageConfig(intentResult);
 
+                if (useInterpretMode) {
+                    tinker.getLoadReporter().onLoadInterpret(ShareConstants.TYPE_INTERPRET_OK, null);
+                }
                 if (isMainProcess && versionChanged) {
                     //change the old version to new
-                    patchInfo.oldVersion = currentVersion;
                     tinker.getLoadReporter().onLoadPatchVersionChanged(oldVersion, newVersion, patchDirectory, patchVersionDirectory.getName());
-
                 }
                 return true;
         }
@@ -319,33 +339,6 @@ public boolean parseTinkerResult(Context context, Intent intentResult) {
 
     }
 
-    /**
-     * get the base tinkerId
-     *
-     * @return
-     */
-    public String getTinkerID() {
-        if (packageConfig != null) {
-            String tinkerId = packageConfig.get(ShareConstants.TINKER_ID);
-            return tinkerId;
-        }
-        return null;
-    }
-
-    /**
-     * get the new tinkerId
-     *
-     * @return
-     */
-    public String getNewTinkerID() {
-        if (packageConfig != null) {
-            String tinkerId = packageConfig.get(ShareConstants.NEW_TINKER_ID);
-
-            return tinkerId;
-        }
-        return null;
-    }
-
     /**
      * get package configs
      *
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/TinkerServiceInternals.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/TinkerServiceInternals.java
index 2118e23b..0db959ee 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/TinkerServiceInternals.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/TinkerServiceInternals.java
@@ -47,8 +47,13 @@ public static void killTinkerPatchServiceProcess(Context context) {
         }
 
         final ActivityManager am = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
-
-        for (ActivityManager.RunningAppProcessInfo appProcess : am.getRunningAppProcesses()) {
+        // ActivityManager getRunningAppProcesses()
+        List<ActivityManager.RunningAppProcessInfo> appProcessList = am
+            .getRunningAppProcesses();
+        if (appProcessList == null) {
+            return;
+        }
+        for (ActivityManager.RunningAppProcessInfo appProcess : appProcessList) {
             String processName = appProcess.processName;
             if (processName.equals(serverProcessName)) {
                 android.os.Process.killProcess(appProcess.pid);
@@ -64,10 +69,12 @@ public static boolean isTinkerPatchServiceRunning(Context context) {
             return false;
         }
         try {
-            // ActivityManagergetRunningAppProcesses()
+            // ActivityManager getRunningAppProcesses()
             List<ActivityManager.RunningAppProcessInfo> appProcessList = am
                 .getRunningAppProcesses();
-
+            if (appProcessList == null) {
+                return false;
+            }
             for (ActivityManager.RunningAppProcessInfo appProcess : appProcessList) {
                 String processName = appProcess.processName;
                 if (processName.equals(serverName)) {
@@ -122,7 +129,7 @@ private static String getServiceProcessName(Context context, Class<? extends Ser
         ServiceInfo serviceInfo;
         try {
             serviceInfo = packageManager.getServiceInfo(component, 0);
-        } catch (PackageManager.NameNotFoundException ignored) {
+        } catch (Throwable ignored) {
             // Service is disabled.
             return null;
         }
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/util/UpgradePatchRetry.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/UpgradePatchRetry.java
similarity index 79%
rename from tinker-sample-android/app/src/main/java/tinker/sample/android/util/UpgradePatchRetry.java
rename to tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/UpgradePatchRetry.java
index 714749e6..a34b4c9c 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/util/UpgradePatchRetry.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/UpgradePatchRetry.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package tinker.sample.android.util;
+package com.tencent.tinker.lib.util;
 
 import android.content.Context;
 import android.content.Intent;
@@ -22,8 +22,6 @@
 import com.tencent.tinker.lib.service.TinkerPatchService;
 import com.tencent.tinker.lib.tinker.Tinker;
 import com.tencent.tinker.lib.tinker.TinkerInstaller;
-import com.tencent.tinker.lib.util.TinkerLog;
-import com.tencent.tinker.lib.util.TinkerServiceInternals;
 import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
 
 import java.io.File;
@@ -32,8 +30,6 @@
 import java.io.IOException;
 import java.util.Properties;
 
-import tinker.sample.android.reporter.SampleTinkerReport;
-
 /**
  * optional
  * tinker :patch process may killed by some reason, we can retry it to increase upgrade success rate
@@ -49,14 +45,13 @@
 
     private static final String RETRY_FILE_MD5_PROPERTY = "md5";
     private static final String RETRY_COUNT_PROPERTY    = "times";
-    private static final int    RETRY_MAX_COUNT         = 2;
-
-    private boolean isRetryEnable = false;
+    private static final int    RETRY_MAX_COUNT         = 3;
+    private static UpgradePatchRetry sInstance;
+    private boolean isRetryEnable = true;
     private File    retryInfoFile = null;
     private File    tempPatchFile = null;
-
     private Context context = null;
-    private static UpgradePatchRetry sInstance;
+    private int maxRetryCount = RETRY_MAX_COUNT;
 
     /**
      * you must set after tinker has installed
@@ -65,8 +60,8 @@
      */
     public UpgradePatchRetry(Context context) {
         this.context = context;
-        retryInfoFile = new File(SharePatchFileUtil.getPatchDirectory(context), RETRY_INFO_NAME);
-        tempPatchFile = new File(SharePatchFileUtil.getPatchDirectory(context), TEMP_PATCH_NAME);
+        retryInfoFile = new File(SharePatchFileUtil.getPatchTempDirectory(context), RETRY_INFO_NAME);
+        tempPatchFile = new File(SharePatchFileUtil.getPatchTempDirectory(context), TEMP_PATCH_NAME);
     }
 
     public static UpgradePatchRetry getInstance(Context context) {
@@ -76,48 +71,48 @@ public static UpgradePatchRetry getInstance(Context context) {
         return sInstance;
     }
 
-    public void onPatchRetryLoad() {
+    public void setRetryEnable(boolean enable) {
+        isRetryEnable = enable;
+    }
+
+    public void setMaxRetryCount(int count) {
+        if (count <= 0) {
+            TinkerLog.e(TAG, "max count must large than 0");
+            return;
+        }
+        maxRetryCount = count;
+    }
+
+    public boolean onPatchRetryLoad() {
         if (!isRetryEnable) {
             TinkerLog.w(TAG, "onPatchRetryLoad retry disabled, just return");
-            return;
+            return false;
         }
         Tinker tinker = Tinker.with(context);
         //only retry on main process
         if (!tinker.isMainProcess()) {
             TinkerLog.w(TAG, "onPatchRetryLoad retry is not main process, just return");
-            return;
+            return false;
         }
 
         if (!retryInfoFile.exists()) {
             TinkerLog.w(TAG, "onPatchRetryLoad retry info not exist, just return");
-            return;
+            return false;
         }
 
         if (TinkerServiceInternals.isTinkerPatchServiceRunning(context)) {
             TinkerLog.w(TAG, "onPatchRetryLoad tinker service is running, just return");
-            return;
+            return false;
         }
         //must use temp file
         String path = tempPatchFile.getAbsolutePath();
         if (path == null || !new File(path).exists()) {
             TinkerLog.w(TAG, "onPatchRetryLoad patch file: %s is not exist, just return", path);
-            return;
+            return false;
         }
         TinkerLog.w(TAG, "onPatchRetryLoad patch file: %s is exist, retry to patch", path);
         TinkerInstaller.onReceiveUpgradePatch(context, path);
-        SampleTinkerReport.onReportRetryPatch();
-    }
-
-    private void copyToTempFile(File patchFile) {
-        if (patchFile.getAbsolutePath().equals(tempPatchFile.getAbsolutePath())) {
-            return;
-        }
-        TinkerLog.w(TAG, "try copy file: %s to %s", patchFile.getAbsolutePath(), tempPatchFile.getAbsolutePath());
-
-        try {
-            SharePatchFileUtil.copyFileUsingStream(patchFile, tempPatchFile);
-        } catch (IOException e) {
-        }
+        return true;
     }
 
     public void onPatchServiceStart(Intent intent) {
@@ -131,13 +126,6 @@ public void onPatchServiceStart(Intent intent) {
             return;
         }
 
-        boolean isUpgrade = TinkerPatchService.getPatchUpgradeExtra(intent);
-
-        if (!isUpgrade) {
-            TinkerLog.w(TAG, "onPatchServiceStart is not upgrade patch, just return");
-            return;
-        }
-
         String path = TinkerPatchService.getPatchPathExtra(intent);
 
         if (path == null) {
@@ -162,8 +150,7 @@ public void onPatchServiceStart(Intent intent) {
                 retryInfo.times = "1";
             } else {
                 int nowTimes = Integer.parseInt(retryInfo.times);
-                if (nowTimes >= RETRY_MAX_COUNT) {
-                    SharePatchFileUtil.safeDeleteFile(retryInfoFile);
+                if (nowTimes >= maxRetryCount) {
                     SharePatchFileUtil.safeDeleteFile(tempPatchFile);
                     TinkerLog.w(TAG, "onPatchServiceStart retry more than max count, delete retry info file!");
                     return;
@@ -178,37 +165,58 @@ public void onPatchServiceStart(Intent intent) {
         }
 
         RetryInfo.writeRetryProperty(retryInfoFile, retryInfo);
-
     }
 
+    public boolean onPatchListenerCheck(String md5) {
+        if (!isRetryEnable) {
+            TinkerLog.w(TAG, "onPatchListenerCheck retry disabled, just return");
+            return true;
+        }
+        if (!retryInfoFile.exists()) {
+            TinkerLog.w(TAG, "onPatchListenerCheck retry file is not exist, just return");
+            return true;
+        }
+        if (md5 == null) {
+            TinkerLog.w(TAG, "onPatchListenerCheck md5 is null, just return");
+            return true;
+        }
+        RetryInfo retryInfo = RetryInfo.readRetryProperty(retryInfoFile);
+        if (md5.equals(retryInfo.md5)) {
+            int nowTimes = Integer.parseInt(retryInfo.times);
+            if (nowTimes >= maxRetryCount) {
+                TinkerLog.w(TAG, "onPatchListenerCheck, retry count %d must exceed than max retry count", nowTimes);
+                SharePatchFileUtil.safeDeleteFile(tempPatchFile);
+                return false;
+            }
+        }
+        return true;
+    }
     /**
      * if we receive any result, we can delete the temp retry info file
-     *
-     * @param isUpgradePatch
      */
-    public void onPatchServiceResult(boolean isUpgradePatch) {
+    public void onPatchServiceResult() {
         if (!isRetryEnable) {
             TinkerLog.w(TAG, "onPatchServiceResult retry disabled, just return");
             return;
         }
 
-        if (!isUpgradePatch) {
-            TinkerLog.w(TAG, "onPatchServiceResult is not upgrade patch, just return");
-            return;
-        }
-
-        //delete info file
-        if (retryInfoFile.exists()) {
-            SharePatchFileUtil.safeDeleteFile(retryInfoFile);
-        }
         //delete temp patch file
         if (tempPatchFile.exists()) {
             SharePatchFileUtil.safeDeleteFile(tempPatchFile);
         }
     }
 
-    public void setRetryEnable(boolean enable) {
-        isRetryEnable = enable;
+    private void copyToTempFile(File patchFile) {
+        if (patchFile.getAbsolutePath().equals(tempPatchFile.getAbsolutePath())) {
+            return;
+        }
+        TinkerLog.w(TAG, "try copy file: %s to %s", patchFile.getAbsolutePath(), tempPatchFile.getAbsolutePath());
+
+        try {
+            SharePatchFileUtil.copyFileUsingStream(patchFile, tempPatchFile);
+        } catch (IOException e) {
+            TinkerLog.e(TAG, "fail to copy file: %s to %s", patchFile.getAbsolutePath(), tempPatchFile.getAbsolutePath());
+        }
     }
 
     static class RetryInfo {
@@ -232,7 +240,7 @@ static RetryInfo readRetryProperty(File infoFile) {
                 md5 = properties.getProperty(RETRY_FILE_MD5_PROPERTY);
                 times = properties.getProperty(RETRY_COUNT_PROPERTY);
             } catch (IOException e) {
-                e.printStackTrace();
+                TinkerLog.e(TAG, "fail to readRetryProperty:" + e);
             } finally {
                 SharePatchFileUtil.closeQuietly(inputStream);
             }
diff --git a/tinker-android/tinker-android-loader/build.gradle b/tinker-android/tinker-android-loader/build.gradle
index cb3264ad..b65288cc 100644
--- a/tinker-android/tinker-android-loader/build.gradle
+++ b/tinker-android/tinker-android-loader/build.gradle
@@ -19,7 +19,8 @@ dependencies {
     testCompile 'junit:junit:4.12'
 }
 
-task buildSdk(type: Copy, dependsOn: [build]) {
+task buildTinkerSdk(type: Copy, dependsOn: [build]) {
+    group = "tinker"
     from("$buildDir/outputs/aar/") {
         include "${project.getName()}-release.aar"
     }
diff --git a/tinker-android/tinker-android-loader/src/main/AndroidManifest.xml b/tinker-android/tinker-android-loader/src/main/AndroidManifest.xml
index 8b6db826..5a8b047a 100644
--- a/tinker-android/tinker-android-loader/src/main/AndroidManifest.xml
+++ b/tinker-android/tinker-android-loader/src/main/AndroidManifest.xml
@@ -1,8 +1,6 @@
-<manifest
-    package="com.tencent.tinker.loader">
-
+<manifest package="com.tencent.tinker.loader"
+          xmlns:android="http://schemas.android.com/apk/res/android">
     <application>
-
     </application>
 
 </manifest>
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AbstractTinkerLoader.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AbstractTinkerLoader.java
index 111e38c2..926977df 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AbstractTinkerLoader.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AbstractTinkerLoader.java
@@ -25,5 +25,5 @@
  * Created by zhangshaowen on 16/4/30.
  */
 public abstract class AbstractTinkerLoader {
-    abstract public Intent tryLoad(TinkerApplication app, int tinkerFlag, boolean tinkerLoadVerifyFlag);
+    abstract public Intent tryLoad(TinkerApplication app);
 }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AndroidNClassLoader.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AndroidNClassLoader.java
index 7fc6a66b..aa156098 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AndroidNClassLoader.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AndroidNClassLoader.java
@@ -24,10 +24,8 @@
 import com.tencent.tinker.loader.shareutil.ShareReflectUtil;
 
 import java.io.File;
-import java.io.IOException;
+import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
-import java.lang.reflect.Method;
-import java.util.ArrayList;
 import java.util.List;
 
 import dalvik.system.DexFile;
@@ -38,42 +36,81 @@
  */
 @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
 class AndroidNClassLoader extends PathClassLoader {
-    static ArrayList<DexFile> oldDexFiles = new ArrayList<>();
-    PathClassLoader originClassLoader;
+    private static final String TAG = "Tinker.NClassLoader";
 
-    private AndroidNClassLoader(String dexPath, PathClassLoader parent) {
+    private final PathClassLoader originClassLoader;
+    private String applicationClassName;
+
+    private AndroidNClassLoader(String dexPath, PathClassLoader parent, Application application) {
         super(dexPath, parent.getParent());
         originClassLoader = parent;
+        String name = application.getClass().getName();
+        if (name != null && !name.equals("android.app.Application")) {
+            applicationClassName = name;
+        }
     }
 
-    private static AndroidNClassLoader createAndroidNClassLoader(PathClassLoader original) throws Exception {
-        //let all element ""
-        AndroidNClassLoader androidNClassLoader = new AndroidNClassLoader("",  original);
-        Field originPathList = ShareReflectUtil.findField(original, "pathList");
-        Object originPathListObject = originPathList.get(original);
-        //should reflect definingContext also
-        Field originClassloader = ShareReflectUtil.findField(originPathListObject, "definingContext");
-        originClassloader.set(originPathListObject, androidNClassLoader);
-        //copy pathList
-        Field pathListField = ShareReflectUtil.findField(androidNClassLoader, "pathList");
-        //just use PathClassloader's pathList
-        pathListField.set(androidNClassLoader, originPathListObject);
-
-        //we must recreate dexFile due to dexCache
-        List<File> additionalClassPathEntries = new ArrayList<>();
-        Field dexElement = ShareReflectUtil.findField(originPathListObject, "dexElements");
-        Object[] originDexElements = (Object[]) dexElement.get(originPathListObject);
-        for (Object element : originDexElements) {
-            DexFile dexFile = (DexFile) ShareReflectUtil.findField(element, "dexFile").get(element);
-            additionalClassPathEntries.add(new File(dexFile.getName()));
-            //protect for java.lang.AssertionError: Failed to close dex file in finalizer.
-            oldDexFiles.add(dexFile);
+    @SuppressWarnings("unchecked")
+    private static Object recreateDexPathList(Object originalDexPathList, ClassLoader newDefiningContext) throws Exception {
+        final Field dexElementsField = ShareReflectUtil.findField(originalDexPathList, "dexElements");
+        final Object[] dexElements = (Object[]) dexElementsField.get(originalDexPathList);
+        final Field nativeLibraryDirectoriesField = ShareReflectUtil.findField(originalDexPathList, "nativeLibraryDirectories");
+        final List<File> nativeLibraryDirectories = (List<File>) nativeLibraryDirectoriesField.get(originalDexPathList);
+
+        final StringBuilder dexPathBuilder = new StringBuilder();
+        final Field dexFileField = ShareReflectUtil.findField(dexElements.getClass().getComponentType(), "dexFile");
+
+        boolean isFirstItem = true;
+        for (Object dexElement : dexElements) {
+            final DexFile dexFile = (DexFile) dexFileField.get(dexElement);
+            if (dexFile == null) {
+                continue;
+            }
+            if (isFirstItem) {
+                isFirstItem = false;
+            } else {
+                dexPathBuilder.append(File.pathSeparator);
+            }
+            dexPathBuilder.append(dexFile.getName());
         }
-        Method makePathElements = ShareReflectUtil.findMethod(originPathListObject, "makePathElements", List.class, File.class,
-            List.class);
-        ArrayList<IOException> suppressedExceptions = new ArrayList<>();
-        Object[] newDexElements = (Object[]) makePathElements.invoke(originPathListObject, additionalClassPathEntries, null, suppressedExceptions);
-        dexElement.set(originPathListObject, newDexElements);
+
+        final String dexPath = dexPathBuilder.toString();
+
+        final StringBuilder libraryPathBuilder = new StringBuilder();
+        isFirstItem = true;
+        for (File libDir : nativeLibraryDirectories) {
+            if (libDir == null) {
+                continue;
+            }
+            if (isFirstItem) {
+                isFirstItem = false;
+            } else {
+                libraryPathBuilder.append(File.pathSeparator);
+            }
+            libraryPathBuilder.append(libDir.getAbsolutePath());
+        }
+
+        final String libraryPath = libraryPathBuilder.toString();
+
+        final Constructor<?> dexPathListConstructor = ShareReflectUtil.findConstructor(originalDexPathList, ClassLoader.class, String.class, String.class, File.class);
+        return dexPathListConstructor.newInstance(newDefiningContext, dexPath, libraryPath, null);
+    }
+
+    private static AndroidNClassLoader createAndroidNClassLoader(PathClassLoader originalClassLoader, Application application) throws Exception {
+        //let all element ""
+        final AndroidNClassLoader androidNClassLoader = new AndroidNClassLoader("",  originalClassLoader, application);
+        final Field pathListField = ShareReflectUtil.findField(originalClassLoader, "pathList");
+        final Object originPathList = pathListField.get(originalClassLoader);
+
+        // To avoid 'dex file register with multiple classloader' exception on Android O, we must keep old
+        // dexPathList in original classloader so that after the newly loaded base dex was bound to
+        // AndroidNClassLoader we can still load class in base dex from original classloader.
+
+        Object newPathList = recreateDexPathList(originPathList, androidNClassLoader);
+
+        // Update new classloader's pathList.
+        pathListField.set(androidNClassLoader, newPathList);
+
         return androidNClassLoader;
     }
 
@@ -90,7 +127,7 @@ private static void reflectPackageInfoClassloader(Application application, Class
     }
 
     public static AndroidNClassLoader inject(PathClassLoader originClassLoader, Application application) throws Exception {
-        AndroidNClassLoader classLoader = createAndroidNClassLoader(originClassLoader);
+        AndroidNClassLoader classLoader = createAndroidNClassLoader(originClassLoader, application);
         reflectPackageInfoClassloader(application, classLoader);
         return classLoader;
     }
@@ -106,6 +143,13 @@ public static AndroidNClassLoader inject(PathClassLoader originClassLoader, Appl
 //    }
 
     public Class<?> findClass(String name) throws ClassNotFoundException {
+        // loader class use default pathClassloader to load
+        if ((name != null
+                && name.startsWith("com.tencent.tinker.loader.")
+                && !name.equals(SystemClassLoaderAdder.CHECK_DEX_CLASS))
+                || (applicationClassName != null && applicationClassName.equals(name))) {
+            return originClassLoader.loadClass(name);
+        }
         return super.findClass(name);
     }
 
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/SystemClassLoaderAdder.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/SystemClassLoaderAdder.java
index 6678afa3..bc32fad6 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/SystemClassLoaderAdder.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/SystemClassLoaderAdder.java
@@ -32,8 +32,13 @@
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.HashMap;
 import java.util.List;
 import java.util.ListIterator;
+import java.util.Map;
+import java.util.regex.Pattern;
 import java.util.zip.ZipFile;
 
 import dalvik.system.DexFile;
@@ -43,20 +48,20 @@
  * Created by zhangshaowen on 16/3/18.
  */
 public class SystemClassLoaderAdder {
+    public static final String CHECK_DEX_CLASS = "com.tencent.tinker.loader.TinkerTestDexLoad";
+    public static final String CHECK_DEX_FIELD = "isPatch";
     private static final String TAG = "Tinker.ClassLoaderAdder";
-
-    private static final String CHECK_DEX_CLASS = "com.tencent.tinker.loader.TinkerTestDexLoad";
-    private static final String CHECK_DEX_FIELD = "isPatch";
-
     private static int sPatchDexCount = 0;
 
     @SuppressLint("NewApi")
     public static void installDexes(Application application, PathClassLoader loader, File dexOptDir, List<File> files)
         throws Throwable {
+        Log.i(TAG, "installDexes dexOptDir: " + dexOptDir.getAbsolutePath() + ", dex size:" + files.size());
 
         if (!files.isEmpty()) {
+            files = createSortedAdditionalPathEntries(files);
             ClassLoader classLoader = loader;
-            if (Build.VERSION.SDK_INT >= 24) {
+            if (Build.VERSION.SDK_INT >= 24 && !checkIsProtectedApp(files)) {
                 classLoader = AndroidNClassLoader.inject(loader, application);
             }
             //because in dalvik, if inner class is not the same classloader with it wrapper class.
@@ -72,6 +77,7 @@ public static void installDexes(Application application, PathClassLoader loader,
             }
             //install done
             sPatchDexCount = files.size();
+            Log.i(TAG, "after loaded classloader: " + classLoader + ", dex size:" + sPatchDexCount);
 
             if (!checkDexInstall(classLoader)) {
                 //reset patch dex
@@ -108,8 +114,80 @@ private static boolean checkDexInstall(ClassLoader classLoader) throws ClassNotF
         return isPatch;
     }
 
+    private static boolean checkIsProtectedApp(List<File> files) {
+        if (!files.isEmpty()) {
+            for (File file : files) {
+                if (file == null) {
+                    continue;
+                }
+                if (file.getName().startsWith(ShareConstants.CHANGED_CLASSES_DEX_NAME)) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    private static List<File> createSortedAdditionalPathEntries(List<File> additionalPathEntries) {
+        final List<File> result = new ArrayList<>(additionalPathEntries);
+
+        final Pattern classNPattern = Pattern.compile("classes(?:[2-9]{0,1}|[1-9][0-9]+)\\.dex");
+        final Map<String, Boolean> matchesClassNPatternMemo = new HashMap<>();
+        for (File file : result) {
+            final String name = file.getName();
+            matchesClassNPatternMemo.put(name, classNPattern.matcher(name).matches());
+        }
+        Collections.sort(result, new Comparator<File>() {
+            @Override
+            public int compare(File lhs, File rhs) {
+                if (lhs == null && rhs == null) {
+                    return 0;
+                }
+                if (lhs == null) {
+                    return -1;
+                }
+                if (rhs == null) {
+                    return 1;
+                }
+
+                final String lhsName = lhs.getName();
+                final String rhsName = rhs.getName();
+                if (lhsName.equals(rhsName)) {
+                    return 0;
+                }
+
+                final String testDexSuffix = ShareConstants.TEST_DEX_NAME;
+                // test.dex should always be at tail.
+                if (lhsName.startsWith(testDexSuffix)) {
+                    return 1;
+                }
+                if (rhsName.startsWith(testDexSuffix)) {
+                    return -1;
+                }
+
+                final boolean isLhsNameMatchClassN = matchesClassNPatternMemo.get(lhsName);
+                final boolean isRhsNameMatchClassN = matchesClassNPatternMemo.get(rhsName);
+                if (isLhsNameMatchClassN && isRhsNameMatchClassN) {
+                    final int lhsDotPos = lhsName.lastIndexOf('.');
+                    final int rhsDotPos = rhsName.lastIndexOf('.');
+                    final int lhsId = (lhsDotPos > 7 ? Integer.parseInt(lhsName.substring(7, lhsDotPos)) : 1);
+                    final int rhsId = (rhsDotPos > 7 ? Integer.parseInt(rhsName.substring(7, rhsDotPos)) : 1);
+                    return (lhsId == rhsId ? 0 : (lhsId < rhsId ? -1 : 1));
+                } else if (isLhsNameMatchClassN) {
+                    // Dex name that matches class N rules should always be at first.
+                    return -1;
+                } else if (isRhsNameMatchClassN) {
+                    return 1;
+                }
+                return lhsName.compareTo(rhsName);
+            }
+        });
+
+        return result;
+    }
+
     /**
-     * Installer for platform versions 19.
+     * Installer for platform versions 23.
      */
     private static final class V23 {
 
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerDexLoader.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerDexLoader.java
index 2d8ed266..aed836fd 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerDexLoader.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerDexLoader.java
@@ -17,24 +17,25 @@
 package com.tencent.tinker.loader;
 
 import android.annotation.TargetApi;
-import android.app.Application;
 import android.content.Intent;
 import android.os.Build;
 import android.util.Log;
 
+import com.tencent.tinker.loader.app.TinkerApplication;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
 import com.tencent.tinker.loader.shareutil.ShareDexDiffPatchInfo;
 import com.tencent.tinker.loader.shareutil.ShareIntentUtil;
+import com.tencent.tinker.loader.shareutil.ShareOatUtil;
 import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
 import com.tencent.tinker.loader.shareutil.ShareSecurityCheck;
 import com.tencent.tinker.loader.shareutil.ShareTinkerInternals;
 
-import dalvik.system.PathClassLoader;
-
 import java.io.File;
 import java.util.ArrayList;
 import java.util.HashMap;
 
+import dalvik.system.PathClassLoader;
+
 /**
  * Created by zhangshaowen on 16/3/8.
  * check the complete of the dex files
@@ -44,10 +45,15 @@
 
     private static final String TAG = "Tinker.TinkerDexLoader";
 
-    private static final String                           DEX_MEAT_FILE     = ShareConstants.DEX_META_FILE;
-    private static final String                           DEX_PATH          = ShareConstants.DEX_PATH;
-    private static final String                           DEX_OPTIMIZE_PATH = ShareConstants.DEX_OPTIMIZE_PATH;
-    private static final ArrayList<ShareDexDiffPatchInfo> dexList           = new ArrayList<>();
+    private static final String DEX_MEAT_FILE               = ShareConstants.DEX_META_FILE;
+    private static final String DEX_PATH                    = ShareConstants.DEX_PATH;
+    private static final String DEFAULT_DEX_OPTIMIZE_PATH   = ShareConstants.DEFAULT_DEX_OPTIMIZE_PATH;
+    private static final String INTERPRET_DEX_OPTIMIZE_PATH = ShareConstants.INTERPRET_DEX_OPTIMIZE_PATH;
+
+    private static final ArrayList<ShareDexDiffPatchInfo> dexList = new ArrayList<>();
+
+
+    private static File testOptDexFile;
 
     private TinkerDexLoader() {
     }
@@ -59,7 +65,7 @@ private TinkerDexLoader() {
      * @param application The application.
      */
     @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
-    public static boolean loadTinkerJars(Application application, boolean tinkerLoadVerifyFlag, String directory, Intent intentResult) {
+    public static boolean loadTinkerJars(final TinkerApplication application, String directory, String oatDir, Intent intentResult, boolean isSystemOTA) {
         if (dexList.isEmpty()) {
             Log.w(TAG, "there is no dex to load");
             return true;
@@ -74,7 +80,6 @@ public static boolean loadTinkerJars(Application application, boolean tinkerLoad
             return false;
         }
         String dexPath = directory + "/" + DEX_PATH + "/";
-        File optimizeDir = new File(directory + "/" + DEX_OPTIMIZE_PATH);
 //        Log.i(TAG, "loadTinkerJars: dex path: " + dexPath);
 //        Log.i(TAG, "loadTinkerJars: opt path: " + optimizeDir.getAbsolutePath());
 
@@ -89,7 +94,7 @@ public static boolean loadTinkerJars(Application application, boolean tinkerLoad
             String path = dexPath + info.realName;
             File file = new File(path);
 
-            if (tinkerLoadVerifyFlag) {
+            if (application.isTinkerLoadVerifyFlag()) {
                 long start = System.currentTimeMillis();
                 String checkMd5 = isArtPlatForm ? info.destMd5InArt : info.destMd5InDvm;
                 if (!SharePatchFileUtil.verifyDexFileMd5(file, checkMd5)) {
@@ -103,6 +108,63 @@ public static boolean loadTinkerJars(Application application, boolean tinkerLoad
             }
             legalFiles.add(file);
         }
+        File optimizeDir = new File(directory + "/" + oatDir);
+
+        if (isSystemOTA) {
+            final boolean[] parallelOTAResult = {true};
+            final Throwable[] parallelOTAThrowable = new Throwable[1];
+            String targetISA;
+            try {
+                targetISA = ShareOatUtil.getOatFileInstructionSet(testOptDexFile);
+            } catch (Throwable e) {
+                // don't ota on the front
+                deleteOutOfDateOATFile(directory);
+
+                intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_INTERPRET_EXCEPTION, e);
+                ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_GET_OTA_INSTRUCTION_SET_EXCEPTION);
+                return false;
+            }
+
+            deleteOutOfDateOATFile(directory);
+
+            Log.w(TAG, "systemOTA, try parallel oat dexes, targetISA:" + targetISA);
+            // change dir
+            optimizeDir = new File(directory + "/" + INTERPRET_DEX_OPTIMIZE_PATH);
+
+            TinkerParallelDexOptimizer.optimizeAll(
+                legalFiles, optimizeDir, true, targetISA,
+                new TinkerParallelDexOptimizer.ResultCallback() {
+                    long start;
+
+                    @Override
+                    public void onStart(File dexFile, File optimizedDir) {
+                        start = System.currentTimeMillis();
+                        Log.i(TAG, "start to optimize dex:" + dexFile.getPath());
+                    }
+
+                    @Override
+                    public void onSuccess(File dexFile, File optimizedDir, File optimizedFile) {
+                        // Do nothing.
+                        Log.i(TAG, "success to optimize dex " + dexFile.getPath() + ", use time " + (System.currentTimeMillis() - start));
+                    }
+
+                    @Override
+                    public void onFailed(File dexFile, File optimizedDir, Throwable thr) {
+                        parallelOTAResult[0] = false;
+                        parallelOTAThrowable[0] = thr;
+                        Log.i(TAG, "fail to optimize dex " + dexFile.getPath() + ", use time " + (System.currentTimeMillis() - start));
+                    }
+                }
+            );
+
+
+            if (!parallelOTAResult[0]) {
+                Log.e(TAG, "parallel oat dexes failed");
+                intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_INTERPRET_EXCEPTION, parallelOTAThrowable);
+                ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_OTA_INTERPRET_ONLY_EXCEPTION);
+                return false;
+            }
+        }
         try {
             SystemClassLoaderAdder.installDexes(application, classLoader, optimizeDir, legalFiles);
         } catch (Throwable e) {
@@ -112,7 +174,6 @@ public static boolean loadTinkerJars(Application application, boolean tinkerLoad
             ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_DEX_LOAD_EXCEPTION);
             return false;
         }
-        Log.i(TAG, "after loaded classloader: " + application.getClassLoader().toString());
 
         return true;
     }
@@ -121,10 +182,9 @@ public static boolean loadTinkerJars(Application application, boolean tinkerLoad
      * all the dex files in meta file exist?
      * fast check, only check whether exist
      *
-     * @param directory
      * @return boolean
      */
-    public static boolean checkComplete(String directory, ShareSecurityCheck securityCheck, Intent intentResult) {
+    public static boolean checkComplete(String directory, ShareSecurityCheck securityCheck, String oatDir, Intent intentResult) {
         String meta = securityCheck.getMetaContentMap().get(DEX_MEAT_FILE);
         //not found dex
         if (meta == null) {
@@ -160,25 +220,29 @@ public static boolean checkComplete(String directory, ShareSecurityCheck securit
             ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_DEX_DIRECTORY_NOT_EXIST);
             return false;
         }
-
-        String optimizeDexDirectory = directory + "/" + DEX_OPTIMIZE_PATH + "/";
+        String optimizeDexDirectory = directory + "/" + oatDir + "/";
         File optimizeDexDirectoryFile = new File(optimizeDexDirectory);
 
         //fast check whether there is any dex files missing
         for (String name : dexes.keySet()) {
             File dexFile = new File(dexDirectory + name);
-            if (!dexFile.exists()) {
+
+            if (!SharePatchFileUtil.isLegalFile(dexFile)) {
                 intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_MISSING_DEX_PATH, dexFile.getAbsolutePath());
                 ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_DEX_FILE_NOT_EXIST);
                 return false;
             }
             //check dex opt whether complete also
             File dexOptFile = new File(SharePatchFileUtil.optimizedPathFor(dexFile, optimizeDexDirectoryFile));
-            if (!dexOptFile.exists()) {
+            if (!SharePatchFileUtil.isLegalFile(dexOptFile)) {
                 intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_MISSING_DEX_PATH, dexOptFile.getAbsolutePath());
                 ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_DEX_OPT_FILE_NOT_EXIST);
                 return false;
             }
+            // find test dex
+            if (dexOptFile.getName().startsWith(ShareConstants.TEST_DEX_NAME)) {
+                testOptDexFile = dexOptFile;
+            }
         }
 
         //if is ok, add to result intent
@@ -186,6 +250,11 @@ public static boolean checkComplete(String directory, ShareSecurityCheck securit
         return true;
     }
 
+    private static void deleteOutOfDateOATFile(String directory) {
+        String optimizeDexDirectory = directory + "/" + DEFAULT_DEX_OPTIMIZE_PATH + "/";
+        SharePatchFileUtil.deleteDir(optimizeDexDirectory);
+    }
+
     private static boolean isJustArtSupportDex(ShareDexDiffPatchInfo dexDiffPatchInfo) {
         if (ShareTinkerInternals.isVmArt()) {
             return false;
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerLoader.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerLoader.java
index adfb88f7..707c2228 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerLoader.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerLoader.java
@@ -19,6 +19,7 @@
 import android.content.Context;
 import android.content.Intent;
 import android.content.SharedPreferences;
+import android.os.Build;
 import android.os.SystemClock;
 import android.util.Log;
 
@@ -49,20 +50,29 @@
      * only main process can handle patch version change or incomplete
      */
     @Override
-    public Intent tryLoad(TinkerApplication app, int tinkerFlag, boolean tinkerLoadVerifyFlag) {
+    public Intent tryLoad(TinkerApplication app) {
         Intent resultIntent = new Intent();
 
         long begin = SystemClock.elapsedRealtime();
-        tryLoadPatchFilesInternal(app, tinkerFlag, tinkerLoadVerifyFlag, resultIntent);
+        tryLoadPatchFilesInternal(app, resultIntent);
         long cost = SystemClock.elapsedRealtime() - begin;
         ShareIntentUtil.setIntentPatchCostTime(resultIntent, cost);
         return resultIntent;
     }
 
-    private void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, boolean tinkerLoadVerifyFlag, Intent resultIntent) {
+    private void tryLoadPatchFilesInternal(TinkerApplication app, Intent resultIntent) {
+        final int tinkerFlag = app.getTinkerFlags();
+
         if (!ShareTinkerInternals.isTinkerEnabled(tinkerFlag)) {
+            Log.w(TAG, "tryLoadPatchFiles: tinker is disable, just return");
+            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_DISABLE);
+            return;
+        }
+        if (ShareTinkerInternals.isInPatchProcess(app)) {
+            Log.w(TAG, "tryLoadPatchFiles: we don't load patch with :patch process itself, just return");
             ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_DISABLE);
             return;
+
         }
         //tinker
         File patchDirectoryFile = SharePatchFileUtil.getPatchDirectory(app);
@@ -102,8 +112,9 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, bo
 
         String oldVersion = patchInfo.oldVersion;
         String newVersion = patchInfo.newVersion;
+        String oatDex = patchInfo.oatDir;
 
-        if (oldVersion == null || newVersion == null) {
+        if (oldVersion == null || newVersion == null || oatDex == null) {
             //it is nice to clean patch
             Log.w(TAG, "tryLoadPatchFiles:onPatchInfoCorrupted");
             ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_INFO_CORRUPTED);
@@ -115,8 +126,12 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, bo
 
         boolean mainProcess = ShareTinkerInternals.isInMainProcess(app);
         boolean versionChanged = !(oldVersion.equals(newVersion));
+        boolean oatModeChanged = oatDex.equals(ShareConstants.CHANING_DEX_OPTIMIZE_PATH) && mainProcess;
+        oatDex = ShareTinkerInternals.getCurrentOatMode(app, oatDex);
+        resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_OAT_DIR, oatDex);
 
         String version = oldVersion;
+
         if (versionChanged && mainProcess) {
             version = newVersion;
         }
@@ -128,9 +143,15 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, bo
 
         //patch-641e634c
         String patchName = SharePatchFileUtil.getPatchVersionDirectory(version);
-
+        if (patchName == null) {
+            Log.w(TAG, "tryLoadPatchFiles:patchName is null");
+            //we may delete patch info file
+            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_VERSION_DIRECTORY_NOT_EXIST);
+            return;
+        }
         //tinker/patch.info/patch-641e634c
         String patchVersionDirectory = patchDirectoryPath + "/" + patchName;
+
         File patchVersionDirectoryFile = new File(patchVersionDirectory);
 
         if (!patchVersionDirectoryFile.exists()) {
@@ -143,7 +164,7 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, bo
         //tinker/patch.info/patch-641e634c/patch-641e634c.apk
         File patchVersionFile = new File(patchVersionDirectoryFile.getAbsolutePath(), SharePatchFileUtil.getPatchVersionFile(version));
 
-        if (!patchVersionFile.exists()) {
+        if (!SharePatchFileUtil.isLegalFile(patchVersionFile)) {
             Log.w(TAG, "tryLoadPatchFiles:onPatchVersionFileNotFound");
             //we may delete patch info file
             ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_VERSION_FILE_NOT_EXIST);
@@ -166,7 +187,7 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, bo
 
         if (isEnabledForDex) {
             //tinker/patch.info/patch-641e634c/dex
-            boolean dexCheck = TinkerDexLoader.checkComplete(patchVersionDirectory, securityCheck, resultIntent);
+            boolean dexCheck = TinkerDexLoader.checkComplete(patchVersionDirectory, securityCheck, oatDex, resultIntent);
             if (!dexCheck) {
                 //file not found, do not load patch
                 Log.w(TAG, "tryLoadPatchFiles:dex check fail");
@@ -197,15 +218,30 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, bo
                 return;
             }
         }
+        //only work for art platform oat，because of interpret, refuse 4.4 art oat
+        boolean isSystemOTA = ShareTinkerInternals.isVmArt()
+            && ShareTinkerInternals.isSystemOTA(patchInfo.fingerPrint)
+            && Build.VERSION.SDK_INT >= 21;
+
+        resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_SYSTEM_OTA, isSystemOTA);
+
         //we should first try rewrite patch info file, if there is a error, we can't load jar
-        if (mainProcess && versionChanged) {
+        if ((mainProcess && versionChanged)
+             || oatModeChanged) {
             patchInfo.oldVersion = version;
+            patchInfo.oatDir = oatDex;
+
             //update old version to new
             if (!SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile, patchInfo, patchInfoLockFile)) {
                 ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_REWRITE_PATCH_INFO_FAIL);
                 Log.w(TAG, "tryLoadPatchFiles:onReWritePatchInfoCorrupted");
                 return;
             }
+            if (oatModeChanged) {
+                // delete interpret odex
+                Log.i(TAG, "tryLoadPatchFiles:oatModeChanged, try to delete interpret optimize files");
+                SharePatchFileUtil.deleteDir(patchVersionDirectory + "/" + ShareConstants.INTERPRET_DEX_OPTIMIZE_PATH);
+            }
         }
         if (!checkSafeModeCount(app)) {
             resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_EXCEPTION, new TinkerRuntimeException("checkSafeModeCount fail"));
@@ -213,9 +249,26 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, bo
             Log.w(TAG, "tryLoadPatchFiles:checkSafeModeCount fail");
             return;
         }
+
         //now we can load patch jar
         if (isEnabledForDex) {
-            boolean loadTinkerJars = TinkerDexLoader.loadTinkerJars(app, tinkerLoadVerifyFlag, patchVersionDirectory, resultIntent);
+            boolean loadTinkerJars = TinkerDexLoader.loadTinkerJars(app, patchVersionDirectory, oatDex, resultIntent, isSystemOTA);
+
+            if (isSystemOTA) {
+                // update fingerprint after load success
+                patchInfo.fingerPrint = Build.FINGERPRINT;
+                patchInfo.oatDir = loadTinkerJars ? ShareConstants.INTERPRET_DEX_OPTIMIZE_PATH : ShareConstants.DEFAULT_DEX_OPTIMIZE_PATH;
+                // reset to false
+                oatModeChanged = false;
+
+                if (!SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile, patchInfo, patchInfoLockFile)) {
+                    ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_REWRITE_PATCH_INFO_FAIL);
+                    Log.w(TAG, "tryLoadPatchFiles:onReWritePatchInfoCorrupted");
+                    return;
+                }
+                // update oat dir
+                resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_OAT_DIR, patchInfo.oatDir);
+            }
             if (!loadTinkerJars) {
                 Log.w(TAG, "tryLoadPatchFiles:onPatchLoadDexesFail");
                 return;
@@ -224,12 +277,17 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, bo
 
         //now we can load patch resource
         if (isEnabledForResource) {
-            boolean loadTinkerResources = TinkerResourceLoader.loadTinkerResources(app, tinkerLoadVerifyFlag, patchVersionDirectory, resultIntent);
+            boolean loadTinkerResources = TinkerResourceLoader.loadTinkerResources(app, patchVersionDirectory, resultIntent);
             if (!loadTinkerResources) {
                 Log.w(TAG, "tryLoadPatchFiles:onPatchLoadResourcesFail");
                 return;
             }
         }
+        // kill all other process if oat mode change
+        if (oatModeChanged) {
+            ShareTinkerInternals.killAllOtherProcess(app);
+            Log.i(TAG, "tryLoadPatchFiles:oatModeChanged, try to kill all other process");
+        }
         //all is ok!
         ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_OK);
         Log.i(TAG, "tryLoadPatchFiles: load end, ok!");
@@ -241,18 +299,14 @@ private boolean checkSafeModeCount(TinkerApplication application) {
         String preferName = ShareConstants.TINKER_OWN_PREFERENCE_CONFIG + processName;
         //each process have its own SharedPreferences file
         SharedPreferences sp = application.getSharedPreferences(preferName, Context.MODE_PRIVATE);
-        int count = sp.getInt(ShareConstants.TINKER_SAFE_MODE_COUNT, 0);
+        int count = sp.getInt(ShareConstants.TINKER_SAFE_MODE_COUNT, 0) + 1;
         Log.w(TAG, "tinker safe mode preferName:" + preferName + " count:" + count);
         if (count >= ShareConstants.TINKER_SAFE_MODE_MAX_COUNT) {
             sp.edit().putInt(ShareConstants.TINKER_SAFE_MODE_COUNT, 0).commit();
             return false;
         }
         application.setUseSafeMode(true);
-        count++;
         sp.edit().putInt(ShareConstants.TINKER_SAFE_MODE_COUNT, count).commit();
-        Log.w(TAG, "after tinker safe mode count:" + count);
         return true;
     }
-
-
 }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerParallelDexOptimizer.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerParallelDexOptimizer.java
new file mode 100644
index 00000000..1aa67fbe
--- /dev/null
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerParallelDexOptimizer.java
@@ -0,0 +1,226 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.loader;
+
+import android.util.Log;
+
+import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Executor;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import dalvik.system.DexFile;
+
+/**
+ * Created by tangyinsheng on 2016/11/15.
+ */
+
+public final class TinkerParallelDexOptimizer {
+    private static final String TAG = "Tinker.ParallelDex";
+
+    private static final int DEFAULT_THREAD_COUNT = 2;
+
+    /**
+     * Optimize (trigger dexopt or dex2oat) dexes.
+     *
+     * @param dexFiles
+     * @param optimizedDir
+     * @param cb
+     * @return If all dexes are optimized successfully, return true. Otherwise return false.
+     */
+    public static boolean optimizeAll(Collection<File> dexFiles, File optimizedDir, ResultCallback cb) {
+        return optimizeAll(dexFiles, optimizedDir, false, null, cb);
+    }
+
+    public static boolean optimizeAll(Collection<File> dexFiles, File optimizedDir, boolean useInterpretMode, String targetISA, ResultCallback cb) {
+        final AtomicInteger successCount = new AtomicInteger(0);
+        return optimizeAllLocked(dexFiles, optimizedDir, useInterpretMode, targetISA, successCount, cb, DEFAULT_THREAD_COUNT);
+    }
+
+    private synchronized static boolean optimizeAllLocked(Collection<File> dexFiles, File optimizedDir,
+                                             boolean useInterpretMode, String targetISA, AtomicInteger successCount, ResultCallback cb, int threadCount) {
+        final CountDownLatch latch = new CountDownLatch(dexFiles.size());
+        final ExecutorService threadPool = Executors.newFixedThreadPool(threadCount);
+        long startTick = System.nanoTime();
+        ArrayList<File> sortList = new ArrayList<>(dexFiles);
+        // sort input dexFiles with its file length
+        Collections.sort(sortList, new Comparator<File>() {
+            @Override
+            public int compare(File lhs, File rhs) {
+                long diffSize = lhs.length() - rhs.length();
+                if (diffSize > 0) {
+                    return 1;
+                } else if (diffSize == 0) {
+                    return 0;
+                } else {
+                    return -1;
+                }
+            }
+        });
+        Collections.reverse(sortList);
+        for (File dexFile : sortList) {
+            OptimizeWorker worker = new OptimizeWorker(dexFile, optimizedDir, useInterpretMode, targetISA, successCount, latch, cb);
+            threadPool.submit(worker);
+        }
+        try {
+            latch.await();
+            long timeCost = (System.nanoTime() - startTick) / 1000000;
+            if (successCount.get() == dexFiles.size()) {
+                Log.i(TAG, "All dexes are optimized successfully, cost: " + timeCost + " ms.");
+                return true;
+            } else {
+                Log.e(TAG, "Dexes optimizing failed, some dexes are not optimized.");
+                return false;
+            }
+        } catch (InterruptedException e) {
+            Log.w(TAG, "Dex optimizing was interrupted.", e);
+            return false;
+        } finally {
+            threadPool.shutdown();
+        }
+    }
+
+    public interface ResultCallback {
+        void onStart(File dexFile, File optimizedDir);
+
+        void onSuccess(File dexFile, File optimizedDir, File optimizedFile);
+
+        void onFailed(File dexFile, File optimizedDir, Throwable thr);
+    }
+
+    private static class OptimizeWorker implements Runnable {
+        private static       String   targetISA           = null;
+
+        private final File           dexFile;
+        private final File           optimizedDir;
+        private final boolean        useInterpretMode;
+        private final AtomicInteger  successCount;
+        private final CountDownLatch waitingLatch;
+        private final ResultCallback callback;
+
+        OptimizeWorker(File dexFile, File optimizedDir, boolean useInterpretMode, String targetISA, AtomicInteger successCount, CountDownLatch latch, ResultCallback cb) {
+            this.dexFile = dexFile;
+            this.optimizedDir = optimizedDir;
+            this.useInterpretMode = useInterpretMode;
+            this.successCount = successCount;
+            this.waitingLatch = latch;
+            this.callback = cb;
+            this.targetISA = targetISA;
+        }
+
+        @Override
+        public void run() {
+            try {
+                if (!SharePatchFileUtil.isLegalFile(dexFile)) {
+                    if (callback != null) {
+                        callback.onFailed(dexFile, optimizedDir,
+                            new IOException("dex file " + dexFile.getAbsolutePath() + " is not exist!"));
+                    }
+                }
+                if (callback != null) {
+                    callback.onStart(dexFile, optimizedDir);
+                }
+                String optimizedPath = SharePatchFileUtil.optimizedPathFor(this.dexFile, this.optimizedDir);
+                if (useInterpretMode) {
+                    interpretDex2Oat(dexFile.getAbsolutePath(), optimizedPath);
+                } else {
+                    DexFile.loadDex(dexFile.getAbsolutePath(), optimizedPath, 0);
+                }
+                successCount.incrementAndGet();
+                if (callback != null) {
+                    callback.onSuccess(dexFile, optimizedDir, new File(optimizedPath));
+                }
+            } catch (final Throwable e) {
+                Log.e(TAG, "Failed to optimize dex: " + dexFile.getAbsolutePath(), e);
+                if (callback != null) {
+                    callback.onFailed(dexFile, optimizedDir, e);
+                }
+            } finally {
+                this.waitingLatch.countDown();
+            }
+        }
+
+        private void interpretDex2Oat(String dexFilePath, String oatFilePath) throws IOException {
+
+            final File oatFile = new File(oatFilePath);
+            if (!oatFile.exists()) {
+                oatFile.getParentFile().mkdirs();
+            }
+
+            final List<String> commandAndParams = new ArrayList<>();
+            commandAndParams.add("dex2oat");
+            commandAndParams.add("--dex-file=" + dexFilePath);
+            commandAndParams.add("--oat-file=" + oatFilePath);
+            commandAndParams.add("--instruction-set=" + targetISA);
+            commandAndParams.add("--compiler-filter=interpret-only");
+
+            final ProcessBuilder pb = new ProcessBuilder(commandAndParams);
+            pb.redirectErrorStream(true);
+            final Process dex2oatProcess = pb.start();
+            StreamConsumer.consumeInputStream(dex2oatProcess.getInputStream());
+            StreamConsumer.consumeInputStream(dex2oatProcess.getErrorStream());
+            try {
+                final int ret = dex2oatProcess.waitFor();
+                if (ret != 0) {
+                    throw new IOException("dex2oat works unsuccessfully, exit code: " + ret);
+                }
+            } catch (InterruptedException e) {
+                throw new IOException("dex2oat is interrupted, msg: " + e.getMessage(), e);
+            }
+        }
+    }
+
+    private static class StreamConsumer {
+        static final Executor STREAM_CONSUMER = Executors.newSingleThreadExecutor();
+
+        static void consumeInputStream(final InputStream is) {
+            STREAM_CONSUMER.execute(new Runnable() {
+                @Override
+                public void run() {
+                    if (is == null) {
+                        return;
+                    }
+                    final byte[] buffer = new byte[256];
+                    try {
+                        while ((is.read(buffer)) > 0) {
+                            // To satisfy checkstyle rules.
+                        }
+                    } catch (IOException ignored) {
+                        // Ignored.
+                    } finally {
+                        try {
+                            is.close();
+                        } catch (Exception ignored) {
+                            // Ignored.
+                        }
+                    }
+                }
+            });
+        }
+    }
+}
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourceLoader.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourceLoader.java
index b46d5940..82a72983 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourceLoader.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourceLoader.java
@@ -20,6 +20,7 @@
 import android.content.Intent;
 import android.util.Log;
 
+import com.tencent.tinker.loader.app.TinkerApplication;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
 import com.tencent.tinker.loader.shareutil.ShareIntentUtil;
 import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
@@ -44,7 +45,7 @@ private TinkerResourceLoader() {
     /**
      * Load tinker resources
      */
-    public static boolean loadTinkerResources(Context context, boolean tinkerLoadVerifyFlag, String directory, Intent intentResult) {
+    public static boolean loadTinkerResources(TinkerApplication application, String directory, Intent intentResult) {
         if (resPatchInfo == null || resPatchInfo.resArscMd5 == null) {
             return true;
         }
@@ -52,7 +53,7 @@ public static boolean loadTinkerResources(Context context, boolean tinkerLoadVer
         File resourceFile = new File(resourceString);
         long start = System.currentTimeMillis();
 
-        if (tinkerLoadVerifyFlag) {
+        if (application.isTinkerLoadVerifyFlag()) {
             if (!SharePatchFileUtil.checkResourceArscMd5(resourceFile, resPatchInfo.resArscMd5)) {
                 Log.e(TAG, "Failed to load resource file, path: " + resourceFile.getPath() + ", expect md5: " + resPatchInfo.resArscMd5);
                 ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_RESOURCE_MD5_MISMATCH);
@@ -61,13 +62,13 @@ public static boolean loadTinkerResources(Context context, boolean tinkerLoadVer
             Log.i(TAG, "verify resource file:" + resourceFile.getPath() + " md5, use time: " + (System.currentTimeMillis() - start));
         }
         try {
-            TinkerResourcePatcher.monkeyPatchExistingResources(context, resourceString);
+            TinkerResourcePatcher.monkeyPatchExistingResources(application, resourceString);
             Log.i(TAG, "monkeyPatchExistingResources resource file:" + resourceString + ", use time: " + (System.currentTimeMillis() - start));
         } catch (Throwable e) {
             Log.e(TAG, "install resources failed");
             //remove patch dex if resource is installed failed
             try {
-                SystemClassLoaderAdder.uninstallPatchDex(context.getClassLoader());
+                SystemClassLoaderAdder.uninstallPatchDex(application.getClassLoader());
             } catch (Throwable throwable) {
                 Log.e(TAG, "uninstallPatchDex failed", e);
             }
@@ -113,7 +114,7 @@ public static boolean checkComplete(Context context, String directory, ShareSecu
         }
 
         File resourceFile = new File(resourcePath + RESOURCE_FILE);
-        if (!resourceFile.exists()) {
+        if (!SharePatchFileUtil.isLegalFile(resourceFile)) {
             ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_RESOURCE_FILE_NOT_EXIST);
             return false;
         }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java
index 56f1c0f8..351d703b 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java
@@ -17,8 +17,10 @@
 package com.tencent.tinker.loader;
 
 import android.content.Context;
+import android.content.pm.ApplicationInfo;
 import android.content.res.AssetManager;
 import android.content.res.Resources;
+import android.os.Build;
 import android.util.ArrayMap;
 import android.util.Log;
 
@@ -26,6 +28,7 @@
 import com.tencent.tinker.loader.shareutil.ShareReflectUtil;
 
 import java.lang.ref.WeakReference;
+import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
 import java.lang.reflect.Method;
 import java.util.Collection;
@@ -35,20 +38,34 @@
 import static android.os.Build.VERSION.SDK_INT;
 import static android.os.Build.VERSION_CODES.KITKAT;
 
+/**
+ * Created by zhangshaowen on 16/9/21.
+ * Thanks for Android Fragmentation
+ */
 class TinkerResourcePatcher {
     private static final String TAG               = "Tinker.ResourcePatcher";
     private static final String TEST_ASSETS_VALUE = "only_use_to_test_tinker_resource.txt";
+//    private static final String MIUI_RESOURCE_CLASSNAME = "android.content.res.MiuiResources";
+
+    // original object
+    private static Collection<WeakReference<Resources>> references            = null;
+    private static Object                               currentActivityThread = null;
+    private static AssetManager                         newAssetManager       = null;
+    //    private static ArrayMap<?, WeakReference<?>>         resourceImpls            = null;
+
+    // method
+    private static Method addAssetPathMethod       = null;
+    private static Method ensureStringBlocksMethod = null;
 
-    // original value
-    private static Collection<WeakReference<Resources>> references;
-    private static AssetManager newAssetManager          = null;
-    private static Method       addAssetPathMethod       = null;
-    private static Method       ensureStringBlocksMethod = null;
-    private static Field        assetsFiled              = null;
-    private static Field        resourcesImplFiled       = null;
-    private static Field        resDir                   = null;
-    private static Field        packagesFiled            = null;
-    private static Field        resourcePackagesFiled    = null;
+    // field
+    private static Field assetsFiled           = null;
+    private static Field resourcesImplFiled    = null;
+    private static Field resDir                = null;
+    private static Field packagesFiled         = null;
+    private static Field resourcePackagesFiled = null;
+    private static Field publicSourceDirField  = null;
+
+//    private static boolean isMiuiSystem = false;
 
     public static void isResourceCanPatch(Context context) throws Throwable {
         //   - Replace mResDir to point to the external resource file instead of the .apk. This is
@@ -57,6 +74,8 @@ public static void isResourceCanPatch(Context context) throws Throwable {
 
         // Find the ActivityThread instance for the current thread
         Class<?> activityThread = Class.forName("android.app.ActivityThread");
+        currentActivityThread = ShareReflectUtil.getActivityThread(context, activityThread);
+
         // API version 8 has PackageInfo, 10 has LoadedApk. 9, I don't know.
         Class<?> loadedApkClass;
         try {
@@ -64,8 +83,8 @@ public static void isResourceCanPatch(Context context) throws Throwable {
         } catch (ClassNotFoundException e) {
             loadedApkClass = Class.forName("android.app.ActivityThread$PackageInfo");
         }
-        Field mApplication = loadedApkClass.getDeclaredField("mApplication");
-        mApplication.setAccessible(true);
+
+
         resDir = loadedApkClass.getDeclaredField("mResDir");
         resDir.setAccessible(true);
         packagesFiled = activityThread.getDeclaredField("mPackages");
@@ -73,39 +92,8 @@ public static void isResourceCanPatch(Context context) throws Throwable {
 
         resourcePackagesFiled = activityThread.getDeclaredField("mResourcePackages");
         resourcePackagesFiled.setAccessible(true);
-        /*
-        (Note: the resource directory is *also* inserted into the loadedApk in
-        monkeyPatchApplication)
-        The code seems to perform this:
-        File externalResourceFile = <path to resources.ap_ or extracted directory>
-
-        AssetManager newAssetManager = new AssetManager();
-        newAssetManager.addAssetPath(externalResourceFile)
-
-        // Kitkat needs this method call, Lollipop doesn't. However, it doesn't seem to cause any harm
-        // in L, so we do it unconditionally.
-        newAssetManager.ensureStringBlocks();
-
-        // Find the singleton instance of ResourcesManager
-        ResourcesManager resourcesManager = ResourcesManager.getInstance();
 
-        // Iterate over all known Resources objects
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
-            for (WeakReference<Resources> wr : resourcesManager.mActiveResources.values()) {
-                Resources resources = wr.get();
-                // Set the AssetManager of the Resources instance to our brand new one
-                resources.mAssets = newAssetManager;
-                resources.updateConfiguration(resources.getConfiguration(), resources.getDisplayMetrics());
-            }
-        }
-
-        // Also, for each context, call getTheme() to get the current theme; null out its
-        // mTheme field, then invoke initializeTheme() to force it to be recreated (with the
-        // new asset manager!)
-
-        */
-        // Create a new AssetManager instance and point it to the resources installed under
-        // /sdcard
+        // Create a new AssetManager instance and point it to the resources
         AssetManager assets = context.getAssets();
         // Baidu os
         if (assets.getClass().getName().equals("android.content.res.BaiduAssetManager")) {
@@ -134,46 +122,60 @@ public static void isResourceCanPatch(Context context) throws Throwable {
             try {
                 Field fMActiveResources = resourcesManagerClass.getDeclaredField("mActiveResources");
                 fMActiveResources.setAccessible(true);
-                ArrayMap<?, WeakReference<Resources>> arrayMap =
+                ArrayMap<?, WeakReference<Resources>> activeResources19 =
                     (ArrayMap<?, WeakReference<Resources>>) fMActiveResources.get(resourcesManager);
-                references = arrayMap.values();
+                references = activeResources19.values();
             } catch (NoSuchFieldException ignore) {
                 // N moved the resources to mResourceReferences
                 Field mResourceReferences = resourcesManagerClass.getDeclaredField("mResourceReferences");
                 mResourceReferences.setAccessible(true);
-                //noinspection unchecked
                 references = (Collection<WeakReference<Resources>>) mResourceReferences.get(resourcesManager);
             }
         } else {
             Field fMActiveResources = activityThread.getDeclaredField("mActiveResources");
             fMActiveResources.setAccessible(true);
-            Object thread = getActivityThread(context, activityThread);
-            @SuppressWarnings("unchecked")
-            HashMap<?, WeakReference<Resources>> map =
-                (HashMap<?, WeakReference<Resources>>) fMActiveResources.get(thread);
-            references = map.values();
+            HashMap<?, WeakReference<Resources>> activeResources7 =
+                (HashMap<?, WeakReference<Resources>>) fMActiveResources.get(currentActivityThread);
+            references = activeResources7.values();
         }
         // check resource
-        if (references == null || references.isEmpty()) {
-            throw new IllegalStateException("resource references is null or empty");
+        if (references == null) {
+            throw new IllegalStateException("resource references is null");
         }
-        try {
+        // fix jianGuo pro has private field 'mAssets' with Resource
+        // try use mResourcesImpl first
+        if (SDK_INT >= 24) {
+            try {
+                // N moved the mAssets inside an mResourcesImpl field
+                resourcesImplFiled = Resources.class.getDeclaredField("mResourcesImpl");
+                resourcesImplFiled.setAccessible(true);
+            } catch (Throwable ignore) {
+                // for safety
+                assetsFiled = Resources.class.getDeclaredField("mAssets");
+                assetsFiled.setAccessible(true);
+            }
+        } else {
             assetsFiled = Resources.class.getDeclaredField("mAssets");
             assetsFiled.setAccessible(true);
-        } catch (Throwable ignore) {
-            // N moved the mAssets inside an mResourcesImpl field
-            resourcesImplFiled = Resources.class.getDeclaredField("mResourcesImpl");
-            resourcesImplFiled.setAccessible(true);
+        }
+//        final Resources resources = context.getResources();
+//        isMiuiSystem = resources != null && MIUI_RESOURCE_CLASSNAME.equals(resources.getClass().getName());
+
+        try {
+            publicSourceDirField = ShareReflectUtil.findField(ApplicationInfo.class, "publicSourceDir");
+        } catch (NoSuchFieldException ignore) {
         }
     }
 
+    /**
+     * @param context
+     * @param externalResourceFile
+     * @throws Throwable
+     */
     public static void monkeyPatchExistingResources(Context context, String externalResourceFile) throws Throwable {
         if (externalResourceFile == null) {
             return;
         }
-        // Find the ActivityThread instance for the current thread
-        Class<?> activityThread = Class.forName("android.app.ActivityThread");
-        Object currentActivityThread = getActivityThread(context, activityThread);
 
         for (Field field : new Field[]{packagesFiled, resourcePackagesFiled}) {
             Object value = field.get(currentActivityThread);
@@ -190,7 +192,6 @@ public static void monkeyPatchExistingResources(Context context, String external
             }
         }
         // Create a new AssetManager instance and point it to the resources installed under
-        // /sdcard
         if (((Integer) addAssetPathMethod.invoke(newAssetManager, externalResourceFile)) == 0) {
             throw new IllegalStateException("Could not create new AssetManager");
         }
@@ -215,49 +216,68 @@ public static void monkeyPatchExistingResources(Context context, String external
                     implAssets.set(resourceImpl, newAssetManager);
                 }
 
+                clearPreloadTypedArrayIssue(resources);
+
                 resources.updateConfiguration(resources.getConfiguration(), resources.getDisplayMetrics());
             }
         }
 
+        // Handle issues caused by WebView on Android N.
+        // Issue: On Android N, if an activity contains a webview, when screen rotates
+        // our resource patch may lost effects.
+        // for 5.x/6.x, we found Couldn't expand RemoteView for StatusBarNotification Exception
+        if (Build.VERSION.SDK_INT >= 24) {
+            try {
+                if (publicSourceDirField != null) {
+                    publicSourceDirField.set(context.getApplicationInfo(), externalResourceFile);
+                }
+            } catch (Throwable ignore) {
+            }
+        }
+
         if (!checkResUpdate(context)) {
             throw new TinkerRuntimeException(ShareConstants.CHECK_RES_INSTALL_FAIL);
         }
     }
 
+    /**
+     * Why must I do these?
+     * Resource has mTypedArrayPool field, which just like Message Poll to reduce gc
+     * MiuiResource change TypedArray to MiuiTypedArray, but it get string block from offset instead of assetManager
+     */
+    private static void clearPreloadTypedArrayIssue(Resources resources) {
+        // Perform this trick not only in Miui system since we can't predict if any other
+        // manufacturer would do the same modification to Android.
+//        if (!isMiuiSystem) {
+//            return;
+//        }
+        Log.w(TAG, "try to clear typedArray cache!");
+        // Clear typedArray cache.
+        try {
+            Field typedArrayPoolField = ShareReflectUtil.findField(Resources.class, "mTypedArrayPool");
+
+            final Object origTypedArrayPool = typedArrayPoolField.get(resources);
+
+            Field poolField = ShareReflectUtil.findField(origTypedArrayPool, "mPool");
+
+            final Constructor<?> typedArrayConstructor = origTypedArrayPool.getClass().getConstructor(int.class);
+            typedArrayConstructor.setAccessible(true);
+            final int poolSize = ((Object[]) poolField.get(origTypedArrayPool)).length;
+            final Object newTypedArrayPool = typedArrayConstructor.newInstance(poolSize);
+            typedArrayPoolField.set(resources, newTypedArrayPool);
+        } catch (Throwable ignored) {
+            Log.e(TAG, "clearPreloadTypedArrayIssue failed, ignore error: " + ignored);
+        }
+    }
+
     private static boolean checkResUpdate(Context context) {
         try {
-            Log.e(TAG, "checkResUpdate success, found test resource assets file " + TEST_ASSETS_VALUE);
             context.getAssets().open(TEST_ASSETS_VALUE);
         } catch (Throwable e) {
             Log.e(TAG, "checkResUpdate failed, can't find test resource assets file " + TEST_ASSETS_VALUE + " e:" + e.getMessage());
             return false;
         }
+        Log.i(TAG, "checkResUpdate success, found test resource assets file " + TEST_ASSETS_VALUE);
         return true;
     }
-
-    private static Object getActivityThread(Context context,
-                                            Class<?> activityThread) {
-        try {
-            if (activityThread == null) {
-                activityThread = Class.forName("android.app.ActivityThread");
-            }
-            Method m = activityThread.getMethod("currentActivityThread");
-            m.setAccessible(true);
-            Object currentActivityThread = m.invoke(null);
-            if (currentActivityThread == null && context != null) {
-                // In older versions of Android (prior to frameworks/base 66a017b63461a22842)
-                // the currentActivityThread was built on thread locals, so we'll need to try
-                // even harder
-                Field mLoadedApk = context.getClass().getField("mLoadedApk");
-                mLoadedApk.setAccessible(true);
-                Object apk = mLoadedApk.get(context);
-                Field mActivityThreadField = apk.getClass().getDeclaredField("mActivityThread");
-                mActivityThreadField.setAccessible(true);
-                currentActivityThread = mActivityThreadField.get(apk);
-            }
-            return currentActivityThread;
-        } catch (Throwable ignore) {
-            return null;
-        }
-    }
 }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcesKey.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcesKey.java
new file mode 100644
index 00000000..d235bdb8
--- /dev/null
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcesKey.java
@@ -0,0 +1,44 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.loader;
+
+/**
+ * Created by zhangshaowen on 17/1/12.
+ *
+ * TODO:
+ * Thanks for Android Fragmentation
+ * hold the issue https://github.com/Tencent/tinker/issues/302
+ */
+public class TinkerResourcesKey {
+
+    private static final class V24 {
+
+
+    }
+
+    private static final class V19 {
+
+    }
+
+    private static final class V17 {
+
+    }
+
+    private static final class V7 {
+
+    }
+}
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerSoLoader.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerSoLoader.java
index c495465b..5f97e388 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerSoLoader.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerSoLoader.java
@@ -21,6 +21,7 @@
 import com.tencent.tinker.loader.shareutil.ShareBsDiffPatchInfo;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
 import com.tencent.tinker.loader.shareutil.ShareIntentUtil;
+import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
 import com.tencent.tinker.loader.shareutil.ShareSecurityCheck;
 
 import java.io.File;
@@ -89,7 +90,7 @@ public static boolean checkComplete(String directory, ShareSecurityCheck securit
         //fast check whether there is any dex files missing
         for (String relative : libs.keySet()) {
             File libFile = new File(libraryPath + relative);
-            if (!libFile.exists()) {
+            if (!SharePatchFileUtil.isLegalFile(libFile)) {
                 ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_LIB_FILE_NOT_EXIST);
                 intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_MISSING_LIB_PATH, libFile.getAbsolutePath());
                 return false;
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerTestAndroidNClassLoader.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerTestAndroidNClassLoader.java
new file mode 100644
index 00000000..44c90d3e
--- /dev/null
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerTestAndroidNClassLoader.java
@@ -0,0 +1,39 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.loader;
+
+/**
+ * Created by tangyinsheng on 17/3/15.
+ *
+ * This class is used to test if our AndroidNClassLoader can load classes in base.apk
+ * after its pathList is updated.
+ *
+ * <b> DO NOT touch this class in any places !! </b>
+ *
+ * <b>
+ *     If you change name of this class, you should also make such change in these places:
+ *      TinkerProguardConfigTask.groovy
+ *      TinkerMultidexConfigTask.groovy
+ *      AndroidNClassLoader.java
+ * </b>
+ */
+public final class TinkerTestAndroidNClassLoader {
+
+    private TinkerTestAndroidNClassLoader() {
+        throw new UnsupportedOperationException();
+    }
+}
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerUncaughtHandler.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerUncaughtHandler.java
new file mode 100644
index 00000000..8471914c
--- /dev/null
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerUncaughtHandler.java
@@ -0,0 +1,78 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.loader;
+
+import android.content.Context;
+import android.util.Log;
+
+import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
+import com.tencent.tinker.loader.shareutil.ShareTinkerInternals;
+
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.io.PrintWriter;
+
+/**
+ * Created by zhangshaowen on 16/12/1.
+ */
+
+public class TinkerUncaughtHandler implements Thread.UncaughtExceptionHandler {
+    private static final String TAG = "Tinker.UncaughtHandler";
+
+
+    private final File crashFile;
+    private final Context context;
+    private final Thread.UncaughtExceptionHandler ueh;
+
+    public TinkerUncaughtHandler(Context context) {
+        this.context = context;
+        ueh = Thread.getDefaultUncaughtExceptionHandler();
+        crashFile = SharePatchFileUtil.getPatchLastCrashFile(context);
+    }
+
+    @Override
+    public void uncaughtException(Thread thread, Throwable ex) {
+        Log.e(TAG, "catch exception when loading tinker:" + Log.getStackTraceString(ex));
+        ueh.uncaughtException(thread, ex);
+
+        if (crashFile != null) {
+            Thread.UncaughtExceptionHandler handler = Thread.getDefaultUncaughtExceptionHandler();
+
+            //only catch real uncaught Exception
+            if (handler instanceof TinkerUncaughtHandler) {
+                File parentFile = crashFile.getParentFile();
+                if (!parentFile.exists() && !parentFile.mkdirs()) {
+                    Log.e(TAG, "print crash file error: create directory fail!");
+                    return;
+                }
+                PrintWriter pw = null;
+                try {
+                    pw = new PrintWriter(new FileWriter(crashFile, false));
+                    pw.println("process:" + ShareTinkerInternals.getProcessName(this.context));
+                    pw.println(ShareTinkerInternals.getExceptionCauseString(ex));
+                } catch (IOException e) {
+                    //ignore
+                    Log.e(TAG, "print crash file error:" + Log.getStackTraceString(e));
+                } finally {
+                    SharePatchFileUtil.closeQuietly(pw);
+                }
+                android.os.Process.killProcess(android.os.Process.myPid());
+            }
+        }
+    }
+}
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/ApplicationLike.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/ApplicationLike.java
index df3d558f..4278e3f1 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/ApplicationLike.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/ApplicationLike.java
@@ -33,34 +33,16 @@
     private final long        applicationStartMillisTime;
     private final int         tinkerFlags;
     private final boolean     tinkerLoadVerifyFlag;
-    private Resources[]    resources;
-    private ClassLoader[]  classLoader;
-    private AssetManager[] assetManager;
+
 
     public ApplicationLike(Application application, int tinkerFlags, boolean tinkerLoadVerifyFlag,
-                           long applicationStartElapsedTime, long applicationStartMillisTime, Intent tinkerResultIntent,
-                           Resources[] resources, ClassLoader[] classLoader, AssetManager[] assetManager) {
+                           long applicationStartElapsedTime, long applicationStartMillisTime, Intent tinkerResultIntent) {
         this.application = application;
         this.tinkerFlags = tinkerFlags;
         this.tinkerLoadVerifyFlag = tinkerLoadVerifyFlag;
         this.applicationStartElapsedTime = applicationStartElapsedTime;
         this.applicationStartMillisTime = applicationStartMillisTime;
         this.tinkerResultIntent = tinkerResultIntent;
-        this.resources = resources;
-        this.classLoader = classLoader;
-        this.assetManager = assetManager;
-    }
-
-    public void setResources(Resources resources) {
-        this.resources[0] = resources;
-    }
-
-    public void setAssetManager(AssetManager assetManager) {
-        this.assetManager[0] = assetManager;
-    }
-
-    public void setClassLoader(ClassLoader classLoader) {
-        this.classLoader[0] = classLoader;
     }
 
     public Application getApplication() {
@@ -116,4 +98,25 @@ public void onConfigurationChanged(Configuration newConfig) {
     public void onBaseContextAttached(Context base) {
 
     }
+    //some get methods that may be overwrite
+    public Resources getResources(Resources resources) {
+        return resources;
+    }
+
+    public ClassLoader getClassLoader(ClassLoader classLoader) {
+        return classLoader;
+    }
+
+    public AssetManager getAssets(AssetManager assetManager) {
+       return assetManager;
+    }
+
+    public Object getSystemService(String name, Object service) {
+        return service;
+    }
+
+    public Context getBaseContext(Context base) {
+        return base;
+    }
 }
+
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/DefaultApplicationLike.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/DefaultApplicationLike.java
index f0367db2..eabf146e 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/DefaultApplicationLike.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/DefaultApplicationLike.java
@@ -23,9 +23,7 @@
 import android.app.Application;
 import android.content.Context;
 import android.content.Intent;
-import android.content.res.AssetManager;
 import android.content.res.Configuration;
-import android.content.res.Resources;
 import android.util.Log;
 
 /**
@@ -35,9 +33,8 @@
     private static final String TAG = "Tinker.DefaultAppLike";
 
     public DefaultApplicationLike(Application application, int tinkerFlags, boolean tinkerLoadVerifyFlag,
-                                  long applicationStartElapsedTime, long applicationStartMillisTime, Intent tinkerResultIntent,
-                                  Resources[] resources, ClassLoader[] classLoader, AssetManager[] assetManager) {
-        super(application, tinkerFlags, tinkerLoadVerifyFlag, applicationStartElapsedTime, applicationStartMillisTime, tinkerResultIntent, resources, classLoader, assetManager);
+                                  long applicationStartElapsedTime, long applicationStartMillisTime, Intent tinkerResultIntent) {
+        super(application, tinkerFlags, tinkerLoadVerifyFlag, applicationStartElapsedTime, applicationStartMillisTime, tinkerResultIntent);
     }
 
     @Override
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/TinkerApplication.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/TinkerApplication.java
index eb908b86..22d22799 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/TinkerApplication.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/TinkerApplication.java
@@ -28,9 +28,9 @@
 
 import com.tencent.tinker.loader.TinkerLoader;
 import com.tencent.tinker.loader.TinkerRuntimeException;
+import com.tencent.tinker.loader.TinkerUncaughtHandler;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
 import com.tencent.tinker.loader.shareutil.ShareIntentUtil;
-import com.tencent.tinker.loader.shareutil.ShareReflectUtil;
 import com.tencent.tinker.loader.shareutil.ShareTinkerInternals;
 
 import java.lang.reflect.Constructor;
@@ -54,7 +54,7 @@
      * dex only, library only, all support
      * default: TINKER_ENABLE_ALL
      */
-    private final int tinkerFlags;
+    private final int     tinkerFlags;
     /**
      * whether verify md5 when we load dex or lib
      * they store at data/data/package, and we had verity them at the :patch process.
@@ -64,16 +64,14 @@
     private final boolean tinkerLoadVerifyFlag;
     private final String  delegateClassName;
     private final String  loaderClassName;
+
     /**
      * if we have load patch, we should use safe mode
      */
-    private boolean useSafeMode;
+    private       boolean useSafeMode;
     private       Intent  tinkerResultIntent;
 
-    private Object         delegate      = null;
-    private Resources[]    resources     = new Resources[1];
-    private ClassLoader[]  classLoader   = new ClassLoader[1];
-    private AssetManager[] assetManager  = new AssetManager[1];
+    private ApplicationLike applicationLike = null;
 
     private long applicationStartElapsedTime;
     private long applicationStartMillisTime;
@@ -95,31 +93,29 @@ protected TinkerApplication(int tinkerFlags, String delegateClassName,
         this.delegateClassName = delegateClassName;
         this.loaderClassName = loaderClassName;
         this.tinkerLoadVerifyFlag = tinkerLoadVerifyFlag;
-
     }
 
     protected TinkerApplication(int tinkerFlags, String delegateClassName) {
         this(tinkerFlags, delegateClassName, TinkerLoader.class.getName(), false);
     }
 
-    private Object createDelegate() {
+    private ApplicationLike createDelegate() {
         try {
             // Use reflection to create the delegate so it doesn't need to go into the primary dex.
             // And we can also patch it
             Class<?> delegateClass = Class.forName(delegateClassName, false, getClassLoader());
-            Constructor<?> constructor = delegateClass.getConstructor(Application.class, int.class, boolean.class, long.class, long.class,
-                Intent.class, Resources[].class, ClassLoader[].class, AssetManager[].class);
-            return constructor.newInstance(this, tinkerFlags, tinkerLoadVerifyFlag,
-                applicationStartElapsedTime, applicationStartMillisTime,
-                tinkerResultIntent, resources, classLoader, assetManager);
+            Constructor<?> constructor = delegateClass.getConstructor(Application.class, int.class, boolean.class,
+                long.class, long.class, Intent.class);
+            return (ApplicationLike) constructor.newInstance(this, tinkerFlags, tinkerLoadVerifyFlag,
+                applicationStartElapsedTime, applicationStartMillisTime, tinkerResultIntent);
         } catch (Throwable e) {
             throw new TinkerRuntimeException("createDelegate failed", e);
         }
     }
 
     private synchronized void ensureDelegate() {
-        if (delegate == null) {
-            delegate = createDelegate();
+        if (applicationLike == null) {
+            applicationLike = createDelegate();
         }
     }
 
@@ -133,12 +129,7 @@ private void onBaseContextAttached(Context base) {
         applicationStartMillisTime = System.currentTimeMillis();
         loadTinker();
         ensureDelegate();
-        try {
-            Method method = ShareReflectUtil.findMethod(delegate, "onBaseContextAttached", Context.class);
-            method.invoke(delegate, base);
-        } catch (Throwable t) {
-            throw new TinkerRuntimeException("onBaseContextAttached method not found", t);
-        }
+        applicationLike.onBaseContextAttached(base);
         //reset save mode
         if (useSafeMode) {
             String processName = ShareTinkerInternals.getProcessName(this);
@@ -149,8 +140,9 @@ private void onBaseContextAttached(Context base) {
     }
 
     @Override
-    protected final void attachBaseContext(Context base) {
+    protected void attachBaseContext(Context base) {
         super.attachBaseContext(base);
+        Thread.setDefaultUncaughtExceptionHandler(new TinkerUncaughtHandler(this));
         onBaseContextAttached(base);
     }
 
@@ -164,9 +156,9 @@ private void loadTinker() {
             //reflect tinker loader, because loaderClass may be define by user!
             Class<?> tinkerLoadClass = Class.forName(loaderClassName, false, getClassLoader());
 
-            Method loadMethod = tinkerLoadClass.getMethod(TINKER_LOADER_METHOD, TinkerApplication.class, int.class, boolean.class);
+            Method loadMethod = tinkerLoadClass.getMethod(TINKER_LOADER_METHOD, TinkerApplication.class);
             Constructor<?> constructor = tinkerLoadClass.getConstructor();
-            tinkerResultIntent = (Intent) loadMethod.invoke(constructor.newInstance(), this, tinkerFlags, tinkerLoadVerifyFlag);
+            tinkerResultIntent = (Intent) loadMethod.invoke(constructor.newInstance(), this);
         } catch (Throwable e) {
             //has exception, put exception error code
             ShareIntentUtil.setIntentReturnCode(tinkerResultIntent, ShareConstants.ERROR_LOAD_PATCH_UNKNOWN_EXCEPTION);
@@ -174,96 +166,100 @@ private void loadTinker() {
         }
     }
 
-    private void delegateMethod(String methodName) {
-        if (delegate != null) {
-            try {
-                Method method = ShareReflectUtil.findMethod(delegate, methodName, new Class[0]);
-                method.invoke(delegate, new Object[0]);
-            } catch (Throwable t) {
-                throw new TinkerRuntimeException(String.format("%s method not found", methodName), t);
-            }
-        }
-    }
-
     @Override
-    public final void onCreate() {
+    public void onCreate() {
         super.onCreate();
         ensureDelegate();
-        delegateMethod("onCreate");
+        applicationLike.onCreate();
     }
 
     @Override
-    public final void onTerminate() {
+    public void onTerminate() {
         super.onTerminate();
-        delegateMethod("onTerminate");
+        if (applicationLike != null) {
+            applicationLike.onTerminate();
+        }
     }
 
     @Override
-    public final void onLowMemory() {
+    public void onLowMemory() {
         super.onLowMemory();
-        delegateMethod("onLowMemory");
-    }
-
-    private void delegateTrimMemory(int level) {
-        if (delegate != null) {
-            try {
-                Method method = ShareReflectUtil.findMethod(delegate, "onTrimMemory", int.class);
-                method.invoke(delegate, level);
-            } catch (Throwable t) {
-                throw new TinkerRuntimeException("onTrimMemory method not found", t);
-            }
+        if (applicationLike != null) {
+            applicationLike.onLowMemory();
         }
     }
 
     @TargetApi(14)
     @Override
-    public final void onTrimMemory(int level) {
+    public void onTrimMemory(int level) {
         super.onTrimMemory(level);
-        delegateTrimMemory(level);
-    }
-
-    private void delegateConfigurationChanged(Configuration newConfig) {
-        if (delegate != null) {
-            try {
-                Method method = ShareReflectUtil.findMethod(delegate, "onConfigurationChanged", Configuration.class);
-                method.invoke(delegate, newConfig);
-            } catch (Throwable t) {
-                throw new TinkerRuntimeException("onConfigurationChanged method not found", t);
-            }
+        if (applicationLike != null) {
+            applicationLike.onTrimMemory(level);
         }
     }
 
     @Override
     public void onConfigurationChanged(Configuration newConfig) {
         super.onConfigurationChanged(newConfig);
-        delegateConfigurationChanged(newConfig);
+        if (applicationLike != null) {
+            applicationLike.onConfigurationChanged(newConfig);
+        }
     }
 
     @Override
     public Resources getResources() {
-        if (resources[0] != null) {
-            return resources[0];
+        Resources resources = super.getResources();
+        if (applicationLike != null) {
+            return applicationLike.getResources(resources);
         }
-        return super.getResources();
+        return resources;
     }
 
     @Override
     public ClassLoader getClassLoader() {
-        if (classLoader[0] != null) {
-            return classLoader[0];
+        ClassLoader classLoader = super.getClassLoader();
+        if (applicationLike != null) {
+            return applicationLike.getClassLoader(classLoader);
         }
-        return super.getClassLoader();
+        return classLoader;
     }
 
     @Override
     public AssetManager getAssets() {
-        if (assetManager[0] != null) {
-            return assetManager[0];
+        AssetManager assetManager = super.getAssets();
+        if (applicationLike != null) {
+            return applicationLike.getAssets(assetManager);
         }
-        return super.getAssets();
+        return assetManager;
+    }
+
+    @Override
+    public Object getSystemService(String name) {
+        Object service = super.getSystemService(name);
+        if (applicationLike != null) {
+            return applicationLike.getSystemService(name, service);
+        }
+        return service;
+    }
+
+    @Override
+    public Context getBaseContext() {
+        Context base = super.getBaseContext();
+        if (applicationLike != null) {
+            return applicationLike.getBaseContext(base);
+        }
+        return base;
     }
 
     public void setUseSafeMode(boolean useSafeMode) {
         this.useSafeMode = useSafeMode;
     }
+
+    public boolean isTinkerLoadVerifyFlag() {
+        return tinkerLoadVerifyFlag;
+    }
+
+    public int getTinkerFlags() {
+        return tinkerFlags;
+    }
 }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareConstants.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareConstants.java
index e3db652f..1cb0d61f 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareConstants.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareConstants.java
@@ -20,6 +20,8 @@
  * Created by zhangshaowen on 16/3/24.
  */
 public class ShareConstants {
+    public static final String TINKER_VERSION = "1.7.11";
+
     public static final int BUFFER_SIZE         = 16384;
     public static final int MD5_LENGTH          = 32;
     public static final int MD5_FILE_BUF_LENGTH = 1024 * 100;
@@ -39,18 +41,30 @@
     public static final String SO_META_FILE = "assets/so_meta.txt";
     public static final String SO_PATH      = "lib";
 
-    // If you changed this value, please change the same value in TypedValue, too.
-    public static final String DEX_SMALLPATCH_INFO_FILE = "smallpatch_info.ddextra";
 
-    public static final String DEX_META_FILE            = "assets/dex_meta.txt";
-    public static final String DEX_PATH                 = "dex";
-    public static final String DEX_OPTIMIZE_PATH        = "odex";
-    public static final String DEX_SUFFIX               = ".dex";
-    public static final String JAR_SUFFIX               = ".jar";
+    public static final String DEX_META_FILE               = "assets/dex_meta.txt";
+    public static final String DEX_PATH                    = "dex";
+    public static final String DEFAULT_DEX_OPTIMIZE_PATH   = "odex";
+    public static final String INTERPRET_DEX_OPTIMIZE_PATH = "interpet";
+    public static final String CHANING_DEX_OPTIMIZE_PATH   = "changing";
+
+
+    public static final String DEX_SUFFIX = ".dex";
+    public static final String JAR_SUFFIX = ".jar";
+
+    public static final String TEST_DEX_NAME = "test.dex";
+    public static final String CHANGED_CLASSES_DEX_NAME = "changed_classes.dex";
+
 
     public static final String CHECK_DEX_INSTALL_FAIL = "checkDexInstall failed";
     public static final String CHECK_RES_INSTALL_FAIL = "checkResInstall failed";
 
+    public static final String CHECK_DEX_OAT_EXIST_FAIL  = "checkDexOptExist failed";
+    public static final String CHECK_DEX_OAT_FORMAT_FAIL = "checkDexOptFormat failed";
+
+//    public static final String CHECK_VM_PROPERTY_FAIL = "checkVmArtProperty failed";
+
+
     public static final String RES_META_FILE       = "assets/res_meta.txt";
     public static final String RES_ARSC            = "resources.arsc";
     public static final String RES_MANIFEST        = "AndroidManifest.xml";
@@ -67,7 +81,10 @@
     public static final String DEXMODE_JAR = "jar";
     public static final String DEX_IN_JAR  = "classes.dex";
 
-    public static final String PATCH_DIRECTORY_NAME = "tinker";
+    public static final String PATCH_DIRECTORY_NAME       = "tinker";
+    public static final String PATCH_TEMP_DIRECTORY_NAME  = "tinker_temp";
+    public static final String PATCH_TEMP_LAST_CRASH_NAME = "tinker_last_crash";
+
     public static final String PATCH_INFO_NAME      = "patch.info";
     public static final String PATCH_INFO_LOCK_NAME = "info.lock";
 
@@ -77,7 +94,7 @@
      * multi process share
      */
     public static final String TINKER_SHARE_PREFERENCE_CONFIG = "tinker_share_config";
-    public static final String TINKER_ENABLE_CONFIG           = "tinker_enable";
+    public static final String TINKER_ENABLE_CONFIG           = "tinker_enable_";
 
     /**
      * only for each process
@@ -95,16 +112,13 @@
     public static final int TINKER_PATCH_SERVICE_NOTIFICATION = -1119860829;
 
     //resource type
-    public static final int TYPE_PATCH_FILE  = 1;
-    public static final int TYPE_PATCH_INFO  = 2;
-    public static final int TYPE_DEX         = 3;
-    /**
-     * for art small dex
-     */
-    public static final int TYPE_DEX_FOR_ART = 4;
-    public static final int TYPE_DEX_OPT     = 5;
-    public static final int TYPE_LIBRARY     = 6;
-    public static final int TYPE_RESOURCE    = 7;
+    public static final int TYPE_PATCH_FILE = 1;
+    public static final int TYPE_PATCH_INFO = 2;
+    public static final int TYPE_DEX        = 3;
+
+    public static final int TYPE_DEX_OPT  = 4;
+    public static final int TYPE_LIBRARY  = 5;
+    public static final int TYPE_RESOURCE = 6;
 
 
     public static final int TINKER_DISABLE             = 0x00;
@@ -115,31 +129,34 @@
     public static final int TINKER_ENABLE_ALL          = TINKER_DEX_MASK | TINKER_NATIVE_LIBRARY_MASK | TINKER_RESOURCE_MASK;
 
     //load error code
-    public static final int ERROR_LOAD_OK                                         = 0;
-    public static final int ERROR_LOAD_DISABLE                                    = -1;
-    public static final int ERROR_LOAD_PATCH_DIRECTORY_NOT_EXIST                  = -2;
-    public static final int ERROR_LOAD_PATCH_INFO_NOT_EXIST                       = -3;
-    public static final int ERROR_LOAD_PATCH_INFO_CORRUPTED                       = -4;
-    public static final int ERROR_LOAD_PATCH_INFO_BLANK                           = -5;
-    public static final int ERROR_LOAD_PATCH_VERSION_DIRECTORY_NOT_EXIST          = -6;
-    public static final int ERROR_LOAD_PATCH_VERSION_FILE_NOT_EXIST               = -7;
-    public static final int ERROR_LOAD_PATCH_PACKAGE_CHECK_FAIL                   = -9;
-    public static final int ERROR_LOAD_PATCH_VERSION_DEX_DIRECTORY_NOT_EXIST      = -10;
-    public static final int ERROR_LOAD_PATCH_VERSION_DEX_FILE_NOT_EXIST           = -11;
-    public static final int ERROR_LOAD_PATCH_VERSION_DEX_OPT_FILE_NOT_EXIST       = -12;
-    public static final int ERROR_LOAD_PATCH_VERSION_DEX_CLASSLOADER_NULL         = -13;
-    public static final int ERROR_LOAD_PATCH_VERSION_DEX_MD5_MISMATCH             = -14;
-    public static final int ERROR_LOAD_PATCH_VERSION_DEX_LOAD_EXCEPTION           = -15;
-    public static final int ERROR_LOAD_PATCH_VERSION_LIB_DIRECTORY_NOT_EXIST      = -16;
-    public static final int ERROR_LOAD_PATCH_VERSION_LIB_FILE_NOT_EXIST           = -17;
-    public static final int ERROR_LOAD_PATCH_REWRITE_PATCH_INFO_FAIL              = -18;
-    public static final int ERROR_LOAD_PATCH_UNKNOWN_EXCEPTION                    = -19;
+    public static final int ERROR_LOAD_OK                                      = 0;
+    public static final int ERROR_LOAD_DISABLE                                 = -1;
+    public static final int ERROR_LOAD_PATCH_DIRECTORY_NOT_EXIST               = -2;
+    public static final int ERROR_LOAD_PATCH_INFO_NOT_EXIST                    = -3;
+    public static final int ERROR_LOAD_PATCH_INFO_CORRUPTED                    = -4;
+    public static final int ERROR_LOAD_PATCH_INFO_BLANK                        = -5;
+    public static final int ERROR_LOAD_PATCH_VERSION_DIRECTORY_NOT_EXIST       = -6;
+    public static final int ERROR_LOAD_PATCH_VERSION_FILE_NOT_EXIST            = -7;
+    public static final int ERROR_LOAD_PATCH_PACKAGE_CHECK_FAIL                = -8;
+    public static final int ERROR_LOAD_PATCH_VERSION_DEX_DIRECTORY_NOT_EXIST   = -9;
+    public static final int ERROR_LOAD_PATCH_VERSION_DEX_FILE_NOT_EXIST        = -10;
+    public static final int ERROR_LOAD_PATCH_VERSION_DEX_OPT_FILE_NOT_EXIST    = -11;
+    public static final int ERROR_LOAD_PATCH_VERSION_DEX_CLASSLOADER_NULL      = -12;
+    public static final int ERROR_LOAD_PATCH_VERSION_DEX_MD5_MISMATCH          = -13;
+    public static final int ERROR_LOAD_PATCH_VERSION_DEX_LOAD_EXCEPTION        = -14;
+    public static final int ERROR_LOAD_PATCH_GET_OTA_INSTRUCTION_SET_EXCEPTION = -15;
+    public static final int ERROR_LOAD_PATCH_OTA_INTERPRET_ONLY_EXCEPTION      = -16;
+
+    public static final int ERROR_LOAD_PATCH_VERSION_LIB_DIRECTORY_NOT_EXIST      = -17;
+    public static final int ERROR_LOAD_PATCH_VERSION_LIB_FILE_NOT_EXIST           = -18;
+    public static final int ERROR_LOAD_PATCH_REWRITE_PATCH_INFO_FAIL              = -19;
+    public static final int ERROR_LOAD_PATCH_UNKNOWN_EXCEPTION                    = -20;
     //resource
-    public static final int ERROR_LOAD_PATCH_VERSION_RESOURCE_DIRECTORY_NOT_EXIST = -20;
-    public static final int ERROR_LOAD_PATCH_VERSION_RESOURCE_FILE_NOT_EXIST      = -21;
-    public static final int ERROR_LOAD_PATCH_VERSION_RESOURCE_LOAD_EXCEPTION      = -22;
-    public static final int ERROR_LOAD_PATCH_VERSION_RESOURCE_MD5_MISMATCH        = -23;
-    public static final int ERROR_LOAD_PATCH_UNCAUGHT_EXCEPTION                   = -24;
+    public static final int ERROR_LOAD_PATCH_VERSION_RESOURCE_DIRECTORY_NOT_EXIST = -21;
+    public static final int ERROR_LOAD_PATCH_VERSION_RESOURCE_FILE_NOT_EXIST      = -22;
+    public static final int ERROR_LOAD_PATCH_VERSION_RESOURCE_LOAD_EXCEPTION      = -23;
+    public static final int ERROR_LOAD_PATCH_VERSION_RESOURCE_MD5_MISMATCH        = -24;
+    public static final int ERROR_LOAD_PATCH_UNCAUGHT_EXCEPTION                   = -25;
 
     public static final int ERROR_LOAD_GET_INTENT_FAIL = -10000;
 
@@ -150,13 +167,14 @@
     public static final int ERROR_LOAD_EXCEPTION_RESOURCE = -3;
     public static final int ERROR_LOAD_EXCEPTION_UNCAUGHT = -4;
 
+    //patch listener error code
+    public static final int ERROR_PATCH_OK                = 0;
+    public static final int ERROR_PATCH_DISABLE           = -1;
+    public static final int ERROR_PATCH_NOTEXIST          = -2;
+    public static final int ERROR_PATCH_RUNNING           = -3;
+    public static final int ERROR_PATCH_INSERVICE         = -4;
+    public static final int ERROR_PATCH_JIT               = -5;
 
-    //recover error code
-    public static final int ERROR_PATCH_OK        = 0;
-    public static final int ERROR_PATCH_DISABLE   = -1;
-    public static final int ERROR_PATCH_NOTEXIST  = -2;
-    public static final int ERROR_PATCH_RUNNING   = -3;
-    public static final int ERROR_PATCH_INSERVICE = -4;
 
     //package check error code
     public static final int ERROR_PACKAGE_CHECK_OK                        = 0;
@@ -169,4 +187,11 @@
     public static final int ERROR_PACKAGE_CHECK_TINKER_ID_NOT_EQUAL       = -7;
     public static final int ERROR_PACKAGE_CHECK_RESOURCE_META_CORRUPTED   = -8;
     public static final int ERROR_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT    = -9;
+
+    // interpret error type
+    public static final int TYPE_INTERPRET_OK                        = 0;
+    public static final int TYPE_INTERPRET_GET_INSTRUCTION_SET_ERROR = 1;
+    public static final int TYPE_INTERPRET_COMMAND_ERROR             = 2;
+
+
 }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareElfFile.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareElfFile.java
new file mode 100755
index 00000000..54f36ed1
--- /dev/null
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareElfFile.java
@@ -0,0 +1,385 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.loader.shareutil;
+
+import java.io.Closeable;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.nio.channels.FileChannel;
+import java.nio.charset.Charset;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Created by tangyinsheng on 2017/3/13.
+ */
+
+public class ShareElfFile implements Closeable {
+    public static final int FILE_TYPE_OTHERS = -1;
+    public static final int FILE_TYPE_ODEX = 0;
+    public static final int FILE_TYPE_ELF = 1;
+
+    private final FileInputStream fis;
+    private final Map<String, SectionHeader> sectionNameToHeaderMap = new HashMap<>();
+    public ElfHeader elfHeader = null;
+    public ProgramHeader[] programHeaders = null;
+    public SectionHeader[] sectionHeaders = null;
+
+    public ShareElfFile(File file) throws IOException {
+        fis = new FileInputStream(file);
+        final FileChannel channel = fis.getChannel();
+
+        elfHeader = new ElfHeader(channel);
+
+        final ByteBuffer headerBuffer = ByteBuffer.allocate(128);
+
+        headerBuffer.limit(elfHeader.ePhEntSize);
+        headerBuffer.order(elfHeader.eIndent[ElfHeader.EI_DATA] == ElfHeader.ELFDATA2LSB ? ByteOrder.LITTLE_ENDIAN : ByteOrder.BIG_ENDIAN);
+        channel.position(elfHeader.ePhOff);
+        programHeaders = new ProgramHeader[elfHeader.ePhNum];
+        for (int i = 0; i < programHeaders.length; ++i) {
+            readUntilLimit(channel, headerBuffer, "failed to read phdr.");
+            programHeaders[i] = new ProgramHeader(headerBuffer, elfHeader.eIndent[ElfHeader.EI_CLASS]);
+        }
+
+        channel.position(elfHeader.eShOff);
+        headerBuffer.limit(elfHeader.eShEntSize);
+        sectionHeaders = new SectionHeader[elfHeader.eShNum];
+        for (int i = 0; i < sectionHeaders.length; ++i) {
+            readUntilLimit(channel, headerBuffer, "failed to read shdr.");
+            sectionHeaders[i] = new SectionHeader(headerBuffer, elfHeader.eIndent[ElfHeader.EI_CLASS]);
+        }
+
+        if (elfHeader.eShStrNdx > 0) {
+            final SectionHeader shStrTabSectionHeader = sectionHeaders[elfHeader.eShStrNdx];
+            final ByteBuffer shStrTab = getSection(shStrTabSectionHeader);
+            for (SectionHeader shdr : sectionHeaders) {
+                shStrTab.position(shdr.shName);
+                shdr.shNameStr = readCString(shStrTab);
+                sectionNameToHeaderMap.put(shdr.shNameStr, shdr);
+            }
+        }
+    }
+
+    private static void assertInRange(int b, int lb, int ub, String errMsg) throws IOException {
+        if (b < lb || b > ub) {
+            throw new IOException(errMsg);
+        }
+    }
+
+    public static int getFileTypeByMagic(File file) throws IOException {
+        InputStream is = null;
+        try {
+            final byte[] magicBuf = new byte[4];
+            is = new FileInputStream(file);
+            is.read(magicBuf);
+            if (magicBuf[0] == 'd' && magicBuf[1] == 'e' && magicBuf[2] == 'y' && magicBuf[3] == '\n') {
+                return FILE_TYPE_ODEX;
+            } else if (magicBuf[0] == 0x7F && magicBuf[1] == 'E' && magicBuf[2] == 'L' && magicBuf[3] == 'F') {
+                return FILE_TYPE_ELF;
+            } else {
+                return FILE_TYPE_OTHERS;
+            }
+        } finally {
+            if (is != null) {
+                try {
+                    is.close();
+                } catch (Throwable thr) {
+                    // Ignored.
+                }
+            }
+        }
+    }
+
+    public static void readUntilLimit(FileChannel channel, ByteBuffer bufferOut, String errMsg) throws IOException {
+        bufferOut.rewind();
+        int bytesRead = channel.read(bufferOut);
+        if (bytesRead != bufferOut.limit()) {
+            throw new IOException(errMsg + " Rest bytes insufficient, expect to read "
+                    + bufferOut.limit() + " bytes but only "
+                    + bytesRead + " bytes were read.");
+        }
+        bufferOut.flip();
+    }
+
+    public static String readCString(ByteBuffer buffer) {
+        final byte[] rawBuffer = buffer.array();
+        int begin = buffer.position();
+        while (buffer.hasRemaining() && rawBuffer[buffer.position()] != 0) {
+            buffer.position(buffer.position() + 1);
+        }
+        // Move to the start of next cstring.
+        buffer.position(buffer.position() + 1);
+        return new String(rawBuffer, begin, buffer.position() - begin - 1, Charset.forName("ASCII"));
+    }
+
+    public FileChannel getChannel() {
+        return fis.getChannel();
+    }
+
+    public boolean is32BitElf() {
+        return (elfHeader.eIndent[ElfHeader.EI_CLASS] == ElfHeader.ELFCLASS32);
+    }
+
+    public ByteOrder getDataOrder() {
+        return (elfHeader.eIndent[ElfHeader.EI_DATA] == ElfHeader.ELFDATA2LSB ? ByteOrder.LITTLE_ENDIAN : ByteOrder.BIG_ENDIAN);
+    }
+
+    public SectionHeader getSectionHeaderByName(String name) {
+        return sectionNameToHeaderMap.get(name);
+    }
+
+    public ByteBuffer getSection(SectionHeader sectionHeader) throws IOException {
+        final ByteBuffer result = ByteBuffer.allocate((int) sectionHeader.shSize);
+        fis.getChannel().position(sectionHeader.shOffset);
+        readUntilLimit(fis.getChannel(), result, "failed to read section: " + sectionHeader.shNameStr);
+        return result;
+    }
+
+    public ByteBuffer getSegment(ProgramHeader programHeader) throws IOException {
+        final ByteBuffer result = ByteBuffer.allocate((int) programHeader.pFileSize);
+        fis.getChannel().position(programHeader.pOffset);
+        readUntilLimit(fis.getChannel(), result, "failed to read segment (type: " + programHeader.pType + ").");
+        return result;
+    }
+
+    @Override
+    public void close() throws IOException {
+        fis.close();
+        sectionNameToHeaderMap.clear();
+        programHeaders = null;
+        sectionHeaders = null;
+    }
+
+    public static class ElfHeader {
+        // Elf indent field index.
+        public static final int EI_CLASS = 4;
+        public static final int EI_DATA = 5;
+        public static final int EI_VERSION = 6;
+        // Elf classes.
+        public static final int ELFCLASS32 = 1;
+        public static final int ELFCLASS64 = 2;
+        // Elf data encoding.
+        public static final int ELFDATA2LSB = 1;
+        public static final int ELFDATA2MSB = 2;
+        // Elf types.
+        public static final int ET_NONE = 0;
+        public static final int ET_REL = 1;
+        public static final int ET_EXEC = 2;
+        public static final int ET_DYN = 3;
+        public static final int ET_CORE = 4;
+        public static final int ET_LOPROC = 0xff00;
+        public static final int ET_HIPROC = 0xffff;
+        // Elf indent version.
+        public static final int EV_CURRENT = 1;
+        private static final int EI_NINDENT = 16;
+        public final byte[] eIndent = new byte[EI_NINDENT];
+        public final short eType;
+        public final short eMachine;
+        public final int eVersion;
+        public final long eEntry;
+        public final long ePhOff;
+        public final long eShOff;
+        public final int eFlags;
+        public final short eEhSize;
+        public final short ePhEntSize;
+        public final short ePhNum;
+        public final short eShEntSize;
+        public final short eShNum;
+        public final short eShStrNdx;
+
+        private ElfHeader(FileChannel channel) throws IOException {
+            channel.position(0);
+            channel.read(ByteBuffer.wrap(eIndent));
+            if (eIndent[0] != 0x7F || eIndent[1] != 'E' || eIndent[2] != 'L' || eIndent[3] != 'F') {
+                throw new IOException(String.format("bad elf magic: %x %x %x %x.", eIndent[0], eIndent[1], eIndent[2], eIndent[3]));
+            }
+
+            assertInRange(eIndent[EI_CLASS], ELFCLASS32, ELFCLASS64, "bad elf class: " + eIndent[EI_CLASS]);
+            assertInRange(eIndent[EI_DATA], ELFDATA2LSB, ELFDATA2MSB, "bad elf data encoding: " + eIndent[EI_DATA]);
+
+            final ByteBuffer restBuffer = ByteBuffer.allocate(eIndent[EI_CLASS] == ELFCLASS32 ? 36 : 48);
+            restBuffer.order(eIndent[EI_DATA] == ELFDATA2LSB ? ByteOrder.LITTLE_ENDIAN : ByteOrder.BIG_ENDIAN);
+            readUntilLimit(channel, restBuffer, "failed to read rest part of ehdr.");
+
+            eType = restBuffer.getShort();
+            eMachine = restBuffer.getShort();
+
+            eVersion = restBuffer.getInt();
+            assertInRange(eVersion, EV_CURRENT, EV_CURRENT, "bad elf version: " + eVersion);
+
+            switch (eIndent[EI_CLASS]) {
+                case ELFCLASS32:
+                    eEntry = restBuffer.getInt();
+                    ePhOff = restBuffer.getInt();
+                    eShOff = restBuffer.getInt();
+                    break;
+                case ELFCLASS64:
+                    eEntry = restBuffer.getLong();
+                    ePhOff = restBuffer.getLong();
+                    eShOff = restBuffer.getLong();
+                    break;
+                default:
+                    throw new IOException("Unexpected elf class: " + eIndent[EI_CLASS]);
+            }
+            eFlags = restBuffer.getInt();
+            eEhSize = restBuffer.getShort();
+            ePhEntSize = restBuffer.getShort();
+            ePhNum = restBuffer.getShort();
+            eShEntSize = restBuffer.getShort();
+            eShNum = restBuffer.getShort();
+            eShStrNdx = restBuffer.getShort();
+        }
+    }
+
+    public static class ProgramHeader {
+        // Segment types.
+        public static final int PT_NULL = 0;
+        public static final int PT_LOAD = 1;
+        public static final int PT_DYNAMIC = 2;
+        public static final int PT_INTERP = 3;
+        public static final int PT_NOTE = 4;
+        public static final int PT_SHLIB = 5;
+        public static final int PT_PHDR = 6;
+        public static final int PT_LOPROC = 0x70000000;
+        public static final int PT_HIPROC = 0x7fffffff;
+
+        // Segment flags.
+        public static final int PF_R = 0x04;
+        public static final int PF_W = 0x02;
+        public static final int PF_X = 0x01;
+
+        public final int pType;
+        public final int pFlags;
+        public final long pOffset;
+        public final long pVddr;
+        public final long pPddr;
+        public final long pFileSize;
+        public final long pMemSize;
+        public final long pAlign;
+
+        private ProgramHeader(ByteBuffer buffer, int elfClass) throws IOException {
+            switch (elfClass) {
+                case ElfHeader.ELFCLASS32:
+                    pType = buffer.getInt();
+                    pOffset = buffer.getInt();
+                    pVddr = buffer.getInt();
+                    pPddr = buffer.getInt();
+                    pFileSize = buffer.getInt();
+                    pMemSize = buffer.getInt();
+                    pFlags = buffer.getInt();
+                    pAlign = buffer.getInt();
+                    break;
+                case ElfHeader.ELFCLASS64:
+                    pType = buffer.getInt();
+                    pFlags = buffer.getInt();
+                    pOffset = buffer.getLong();
+                    pVddr = buffer.getLong();
+                    pPddr = buffer.getLong();
+                    pFileSize = buffer.getLong();
+                    pMemSize = buffer.getLong();
+                    pAlign = buffer.getLong();
+                    break;
+                default:
+                    throw new IOException("Unexpected elf class: " + elfClass);
+            }
+        }
+    }
+
+    public static class SectionHeader {
+        // Special section indexes.
+        public static final int SHN_UNDEF = 0;
+        public static final int SHN_LORESERVE = 0xff00;
+        public static final int SHN_LOPROC = 0xff00;
+        public static final int SHN_HIPROC = 0xff1f;
+        public static final int SHN_ABS = 0xfff1;
+        public static final int SHN_COMMON = 0xfff2;
+        public static final int SHN_HIRESERVE = 0xffff;
+
+        // Section types.
+        public static final int SHT_NULL = 0;
+        public static final int SHT_PROGBITS = 1;
+        public static final int SHT_SYMTAB = 2;
+        public static final int SHT_STRTAB = 3;
+        public static final int SHT_RELA = 4;
+        public static final int SHT_HASH = 5;
+        public static final int SHT_DYNAMIC = 6;
+        public static final int SHT_NOTE = 7;
+        public static final int SHT_NOBITS = 8;
+        public static final int SHT_REL = 9;
+        public static final int SHT_SHLIB = 10;
+        public static final int SHT_DYNSYM = 11;
+        public static final int SHT_LOPROC = 0x70000000;
+        public static final int SHT_HIPROC = 0x7fffffff;
+        public static final int SHT_LOUSER = 0x80000000;
+        public static final int SHT_HIUSER = 0xffffffff;
+
+        // Section flags.
+        public static final int SHF_WRITE = 0x1;
+        public static final int SHF_ALLOC = 0x2;
+        public static final int SHF_EXECINSTR = 0x4;
+        public static final int SHF_MASKPROC = 0xf0000000;
+
+        public final int shName;
+        public final int shType;
+        public final long shFlags;
+        public final long shAddr;
+        public final long shOffset;
+        public final long shSize;
+        public final int shLink;
+        public final int shInfo;
+        public final long shAddrAlign;
+        public final long shEntSize;
+        public String shNameStr;
+
+        private SectionHeader(ByteBuffer buffer, int elfClass) throws IOException {
+            switch (elfClass) {
+                case ElfHeader.ELFCLASS32:
+                    shName = buffer.getInt();
+                    shType = buffer.getInt();
+                    shFlags = buffer.getInt();
+                    shAddr = buffer.getInt();
+                    shOffset = buffer.getInt();
+                    shSize = buffer.getInt();
+                    shLink = buffer.getInt();
+                    shInfo = buffer.getInt();
+                    shAddrAlign = buffer.getInt();
+                    shEntSize = buffer.getInt();
+                    break;
+                case ElfHeader.ELFCLASS64:
+                    shName = buffer.getInt();
+                    shType = buffer.getInt();
+                    shFlags = buffer.getLong();
+                    shAddr = buffer.getLong();
+                    shOffset = buffer.getLong();
+                    shSize = buffer.getLong();
+                    shLink = buffer.getInt();
+                    shInfo = buffer.getInt();
+                    shAddrAlign = buffer.getLong();
+                    shEntSize = buffer.getLong();
+                    break;
+                default:
+                    throw new IOException("Unexpected elf class: " + elfClass);
+            }
+            shNameStr = null;
+        }
+    }
+}
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareIntentUtil.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareIntentUtil.java
index 965fb4cd..19a0280a 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareIntentUtil.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareIntentUtil.java
@@ -41,6 +41,11 @@
     public static final  String INTENT_PATCH_EXCEPTION           = "intent_patch_exception";
     public static final  String INTENT_PATCH_PACKAGE_PATCH_CHECK = "intent_patch_package_patch_check";
     public static final  String INTENT_PATCH_PACKAGE_CONFIG      = "intent_patch_package_config";
+    public static final  String INTENT_PATCH_SYSTEM_OTA          = "intent_patch_system_ota";
+    public static final  String INTENT_PATCH_OAT_DIR             = "intent_patch_oat_dir";
+    public static final  String INTENT_PATCH_INTERPRET_EXCEPTION = "intent_patch_interpret_exception";
+
+
     private static final String TAG                              = "ShareIntentUtil";
 
     public static void setIntentReturnCode(Intent intent, int code) {
@@ -59,10 +64,18 @@ public static long getIntentPatchCostTime(Intent intent) {
         return intent.getLongExtra(INTENT_PATCH_COST_TIME, 0);
     }
 
-    public static Exception getIntentPatchException(Intent intent) {
+    public static Throwable getIntentPatchException(Intent intent) {
         Serializable serializable = getSerializableExtra(intent, INTENT_PATCH_EXCEPTION);
         if (serializable != null) {
-            return (Exception) serializable;
+            return (Throwable) serializable;
+        }
+        return null;
+    }
+
+    public static Throwable getIntentInterpretException(Intent intent) {
+        Serializable serializable = getSerializableExtra(intent, INTENT_PATCH_INTERPRET_EXCEPTION);
+        if (serializable != null) {
+            return (Throwable) serializable;
         }
         return null;
     }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareOatUtil.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareOatUtil.java
new file mode 100755
index 00000000..d77c1af7
--- /dev/null
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareOatUtil.java
@@ -0,0 +1,151 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.loader.shareutil;
+
+import java.io.File;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.channels.FileChannel;
+import java.nio.charset.Charset;
+
+/**
+ * Created by tangyinsheng on 2017/3/14.
+ */
+
+public final class ShareOatUtil {
+    private static final String TAG = "Tinker.OatUtil";
+
+    private ShareOatUtil() {
+        throw new UnsupportedOperationException();
+    }
+
+    /**
+     * Get instruction set used to generate {@code oatFile}.
+     *
+     * @param oatFile
+     *  the oat file.
+     * @return
+     *  the instruction used to generate this oat file, if the oat file does not
+     *  contain this value, an empty string will be returned.
+     *
+     * @throws IOException
+     *  If anything wrong when parsing the elf format or locating target field in oat header.
+     */
+    public static String getOatFileInstructionSet(File oatFile) throws Throwable {
+        ShareElfFile elfFile = null;
+        String result = "";
+        try {
+            elfFile = new ShareElfFile(oatFile);
+            final ShareElfFile.SectionHeader roDataHdr = elfFile.getSectionHeaderByName(".rodata");
+            if (roDataHdr == null) {
+                throw new IOException("Unable to find .rodata section.");
+            }
+
+            final FileChannel channel = elfFile.getChannel();
+            channel.position(roDataHdr.shOffset);
+
+            final byte[] oatMagicAndVersion = new byte[8];
+            ShareElfFile.readUntilLimit(channel, ByteBuffer.wrap(oatMagicAndVersion), "Failed to read oat magic and version.");
+
+            if (oatMagicAndVersion[0] != 'o'
+                    || oatMagicAndVersion[1] != 'a'
+                    || oatMagicAndVersion[2] != 't'
+                    || oatMagicAndVersion[3] != '\n') {
+                throw new IOException(
+                        String.format("Bad oat magic: %x %x %x %x",
+                                oatMagicAndVersion[0],
+                                oatMagicAndVersion[1],
+                                oatMagicAndVersion[2],
+                                oatMagicAndVersion[3])
+                );
+            }
+
+            final int versionOffsetFromOatBegin = 4;
+            final int versionBytes = 3;
+
+            final String oatVersion = new String(oatMagicAndVersion,
+                    versionOffsetFromOatBegin, versionBytes, Charset.forName("ASCII"));
+            try {
+                Integer.parseInt(oatVersion);
+            } catch (NumberFormatException e) {
+                throw new IOException("Bad oat version: " + oatVersion);
+            }
+
+            ByteBuffer buffer = ByteBuffer.allocate(128);
+            buffer.order(elfFile.getDataOrder());
+            // TODO This is a risk point, since each oat version may use a different offset.
+            // So far it's ok. Perhaps we should use oatVersionNum to judge the right offset in
+            // the future.
+            final int isaNumOffsetFromOatBegin = 12;
+            channel.position(roDataHdr.shOffset + isaNumOffsetFromOatBegin);
+            buffer.limit(4);
+            ShareElfFile.readUntilLimit(channel, buffer, "Failed to read isa num.");
+
+            int isaNum = buffer.getInt();
+            if (isaNum < 0 || isaNum >= InstructionSet.values().length) {
+                throw new IOException("Bad isa num: " + isaNum);
+            }
+
+            switch (InstructionSet.values()[isaNum]) {
+                case kArm:
+                case kThumb2:
+                    result = "arm";
+                    break;
+                case kArm64:
+                    result = "arm64";
+                    break;
+                case kX86:
+                    result = "x86";
+                    break;
+                case kX86_64:
+                    result = "x86_64";
+                    break;
+                case kMips:
+                    result = "mips";
+                    break;
+                case kMips64:
+                    result = "mips64";
+                    break;
+                case kNone:
+                    result = "none";
+                    break;
+                default:
+                    throw new IOException("Should not reach here.");
+            }
+        } finally {
+            if (elfFile != null) {
+                try {
+                    elfFile.close();
+                } catch (Exception ignored) {
+                    // Ignored.
+                }
+            }
+        }
+        return result;
+    }
+
+    private enum InstructionSet {
+        kNone,
+        kArm,
+        kArm64,
+        kThumb2,
+        kX86,
+        kX86_64,
+        kMips,
+        kMips64
+    }
+}
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchFileUtil.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchFileUtil.java
index ddfee922..4b6f77e1 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchFileUtil.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchFileUtil.java
@@ -21,12 +21,14 @@
 import android.util.Log;
 
 import java.io.BufferedInputStream;
+import java.io.BufferedReader;
 import java.io.Closeable;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
+import java.io.InputStreamReader;
 import java.security.MessageDigest;
 import java.util.jar.JarEntry;
 import java.util.jar.JarFile;
@@ -52,6 +54,24 @@ public static File getPatchDirectory(Context context) {
         return new File(applicationInfo.dataDir, ShareConstants.PATCH_DIRECTORY_NAME);
     }
 
+    public static File getPatchTempDirectory(Context context) {
+        ApplicationInfo applicationInfo = context.getApplicationInfo();
+        if (applicationInfo == null) {
+            // Looks like running on a test Context, so just return without patching.
+            return null;
+        }
+
+        return new File(applicationInfo.dataDir, ShareConstants.PATCH_TEMP_DIRECTORY_NAME);
+    }
+
+    public static File getPatchLastCrashFile(Context context) {
+        File tempFile = getPatchTempDirectory(context);
+        if (tempFile == null) {
+            return null;
+        }
+        return new File(tempFile, ShareConstants.PATCH_TEMP_LAST_CRASH_NAME);
+    }
+
     public static File getPatchInfoFile(String patchDirectory) {
         return new File(patchDirectory + "/" + ShareConstants.PATCH_INFO_NAME);
     }
@@ -83,16 +103,33 @@ public static boolean checkIfMd5Valid(final String object) {
         return true;
     }
 
-    public static final boolean fileExists(String filePath) {
-        if (filePath == null) {
-            return false;
+    public static String checkTinkerLastUncaughtCrash(Context context) {
+        File crashFile = SharePatchFileUtil.getPatchLastCrashFile(context);
+        if (!SharePatchFileUtil.isLegalFile(crashFile)) {
+            return null;
         }
-
-        File file = new File(filePath);
-        if (file.exists()) {
-            return true;
+        StringBuffer buffer = new StringBuffer();
+        BufferedReader in = null;
+        try {
+            in = new BufferedReader(new InputStreamReader(new FileInputStream(crashFile)));
+            String line;
+            while ((line = in.readLine()) != null) {
+                buffer.append(line);
+                buffer.append("\n");
+            }
+        } catch (Exception e) {
+            Log.e(TAG, "checkTinkerLastUncaughtCrash exception: " + e);
+            return null;
+        } finally {
+            closeQuietly(in);
         }
-        return false;
+
+        return buffer.toString();
+
+    }
+
+    public static final boolean isLegalFile(File file) {
+        return file != null && file.exists() && file.canRead() && file.isFile() && file.length() > 0;
     }
 
     /**
@@ -208,17 +245,25 @@ public static boolean verifyDexFileMd5(File file, String md5) {
             try {
                 dexJar = new ZipFile(file);
                 ZipEntry classesDex = dexJar.getEntry(ShareConstants.DEX_IN_JAR);
-
                 // no code
                 if (null == classesDex) {
+                    Log.e(TAG, "There's no entry named: " + ShareConstants.DEX_IN_JAR + " in " + file.getAbsolutePath());
                     return false;
                 }
                 fileMd5 = getMD5(dexJar.getInputStream(classesDex));
-            } catch (IOException e) {
-//                e.printStackTrace();
+            } catch (Throwable e) {
+                Log.e(TAG, "Bad dex jar file: " + file.getAbsolutePath(), e);
                 return false;
             } finally {
-                SharePatchFileUtil.closeZip(dexJar);
+                // Bugfix: some device redefined ZipFile, which is not implemented closeable.
+                // SharePatchFileUtil.closeZip(dexJar);
+                if (dexJar != null) {
+                    try {
+                        dexJar.close();
+                    } catch (Throwable thr) {
+                        // Ignored.
+                    }
+                }
             }
         }
 
@@ -226,6 +271,12 @@ public static boolean verifyDexFileMd5(File file, String md5) {
     }
 
     public static void copyFileUsingStream(File source, File dest) throws IOException {
+        if (!SharePatchFileUtil.isLegalFile(source) || dest == null) {
+            return;
+        }
+        if (source.getAbsolutePath().equals(dest.getAbsolutePath())) {
+            return;
+        }
         FileInputStream is = null;
         FileOutputStream os = null;
         File parent = dest.getParentFile();
@@ -316,20 +367,11 @@ public static String getMD5(final File file) {
         try {
             fin = new FileInputStream(file);
             String md5 = getMD5(fin);
-            fin.close();
             return md5;
-
         } catch (Exception e) {
             return null;
-
         } finally {
-            try {
-                if (fin != null) {
-                    fin.close();
-                }
-            } catch (IOException e) {
-
-            }
+            closeQuietly(fin);
         }
     }
 
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchInfo.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchInfo.java
index f787fb38..be6dc661 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchInfo.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchInfo.java
@@ -16,6 +16,7 @@
 
 package com.tencent.tinker.loader.shareutil;
 
+import android.os.Build;
 import android.util.Log;
 
 import com.tencent.tinker.loader.TinkerRuntimeException;
@@ -33,17 +34,27 @@
     public static final int    MAX_EXTRACT_ATTEMPTS = ShareConstants.MAX_EXTRACT_ATTEMPTS;
     public static final String OLD_VERSION          = ShareConstants.OLD_VERSION;
     public static final String NEW_VERSION          = ShareConstants.NEW_VERSION;
-    private static final String TAG = "PatchInfo";
+    public static final String FINGER_PRINT         = "print";
+    public static final String OAT_DIR              = "dir";
+    public static final String DEFAULT_DIR   = ShareConstants.DEFAULT_DEX_OPTIMIZE_PATH;
+    private static final String TAG = "Tinker.PatchInfo";
     public String oldVersion;
     public String newVersion;
+    public String fingerPrint;
+    public String oatDir;
 
-    public SharePatchInfo(String oldVer, String newVew) {
+    public SharePatchInfo(String oldVer, String newVew, String finger, String oatDir) {
         // TODO Auto-generated constructor stub
         this.oldVersion = oldVer;
         this.newVersion = newVew;
+        this.fingerPrint = finger;
+        this.oatDir = oatDir;
     }
 
     public static SharePatchInfo readAndCheckPropertyWithLock(File pathInfoFile, File lockFile) {
+        if (pathInfoFile == null || lockFile == null) {
+            return null;
+        }
         File lockParentFile = lockFile.getParentFile();
         if (!lockParentFile.exists()) {
             lockParentFile.mkdirs();
@@ -62,7 +73,7 @@ public static SharePatchInfo readAndCheckPropertyWithLock(File pathInfoFile, Fil
                     fileLock.close();
                 }
             } catch (IOException e) {
-                Log.i(TAG, "releaseInfoLock error", e);
+                Log.w(TAG, "releaseInfoLock error", e);
             }
         }
 
@@ -70,6 +81,9 @@ public static SharePatchInfo readAndCheckPropertyWithLock(File pathInfoFile, Fil
     }
 
     public static boolean rewritePatchInfoFileWithLock(File pathInfoFile, SharePatchInfo info, File lockFile) {
+        if (pathInfoFile == null || info == null || lockFile == null) {
+            return false;
+        }
         File lockParentFile = lockFile.getParentFile();
         if (!lockParentFile.exists()) {
             lockParentFile.mkdirs();
@@ -99,6 +113,8 @@ private static SharePatchInfo readAndCheckProperty(File pathInfoFile) {
         int numAttempts = 0;
         String oldVer = null;
         String newVer = null;
+        String lastFingerPrint = null;
+        String oatDIr = null;
 
         while (numAttempts < MAX_EXTRACT_ATTEMPTS && !isReadPatchSuccessful) {
             numAttempts++;
@@ -109,8 +125,11 @@ private static SharePatchInfo readAndCheckProperty(File pathInfoFile) {
                 properties.load(inputStream);
                 oldVer = properties.getProperty(OLD_VERSION);
                 newVer = properties.getProperty(NEW_VERSION);
+                lastFingerPrint = properties.getProperty(FINGER_PRINT);
+                oatDIr = properties.getProperty(OAT_DIR);
             } catch (IOException e) {
-                e.printStackTrace();
+//                e.printStackTrace();
+                Log.w(TAG, "read property failed, e:" + e);
             } finally {
                 SharePatchFileUtil.closeQuietly(inputStream);
             }
@@ -118,8 +137,9 @@ private static SharePatchInfo readAndCheckProperty(File pathInfoFile) {
             if (oldVer == null || newVer == null) {
                 continue;
             }
-            //oldver may be "" or 32 md5
-            if ((!oldVer.equals("") && !SharePatchFileUtil.checkIfMd5Valid(oldVer)) || !SharePatchFileUtil.checkIfMd5Valid(newVer)) {
+            //oldVer may be "" or 32 md5
+            if ((!oldVer.equals("") && !SharePatchFileUtil.checkIfMd5Valid(oldVer))
+                || !SharePatchFileUtil.checkIfMd5Valid(newVer)) {
                 Log.w(TAG, "path info file  corrupted:" + pathInfoFile.getAbsolutePath());
                 continue;
             } else {
@@ -128,7 +148,7 @@ private static SharePatchInfo readAndCheckProperty(File pathInfoFile) {
         }
 
         if (isReadPatchSuccessful) {
-            return new SharePatchInfo(oldVer, newVer);
+            return new SharePatchInfo(oldVer, newVer, lastFingerPrint, oatDIr);
         }
 
         return null;
@@ -138,12 +158,23 @@ private static boolean rewritePatchInfoFile(File pathInfoFile, SharePatchInfo in
         if (pathInfoFile == null || info == null) {
             return false;
         }
+        // write fingerprint if it is null or nil
+        if (ShareTinkerInternals.isNullOrNil(info.fingerPrint)) {
+            info.fingerPrint = Build.FINGERPRINT;
+        }
+        if (ShareTinkerInternals.isNullOrNil(info.oatDir)) {
+            info.oatDir = DEFAULT_DIR;
+        }
         Log.i(TAG, "rewritePatchInfoFile file path:"
             + pathInfoFile.getAbsolutePath()
             + " , oldVer:"
             + info.oldVersion
             + ", newVer:"
-            + info.newVersion);
+            + info.newVersion
+            + ", fingerprint:"
+            + info.fingerPrint
+            + ", oatDir:"
+            + info.oatDir);
 
         boolean isWritePatchSuccessful = false;
         int numAttempts = 0;
@@ -159,13 +190,17 @@ private static boolean rewritePatchInfoFile(File pathInfoFile, SharePatchInfo in
             Properties newProperties = new Properties();
             newProperties.put(OLD_VERSION, info.oldVersion);
             newProperties.put(NEW_VERSION, info.newVersion);
+            newProperties.put(FINGER_PRINT, info.fingerPrint);
+            newProperties.put(OAT_DIR, info.oatDir);
+
             FileOutputStream outputStream = null;
             try {
                 outputStream = new FileOutputStream(pathInfoFile, false);
                 String comment = "from old version:" + info.oldVersion + " to new version:" + info.newVersion;
                 newProperties.store(outputStream, comment);
             } catch (Exception e) {
-                e.printStackTrace();
+//                e.printStackTrace();
+                Log.w(TAG, "write property failed, e:" + e);
             } finally {
                 SharePatchFileUtil.closeQuietly(outputStream);
             }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareReflectUtil.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareReflectUtil.java
index f27a5e0b..72b88059 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareReflectUtil.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareReflectUtil.java
@@ -16,7 +16,10 @@
 
 package com.tencent.tinker.loader.shareutil;
 
+import android.content.Context;
+
 import java.lang.reflect.Array;
+import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
 import java.lang.reflect.Method;
 import java.util.Arrays;
@@ -102,6 +105,36 @@ public static Method findMethod(Object instance, String name, Class<?>... parame
             + " not found in " + instance.getClass());
     }
 
+    /**
+     * Locates a given constructor anywhere in the class inheritance hierarchy.
+     *
+     * @param instance       an object to search the constructor into.
+     * @param parameterTypes constructor parameter types
+     * @return a constructor object
+     * @throws NoSuchMethodException if the constructor cannot be located
+     */
+    public static Constructor<?> findConstructor(Object instance, Class<?>... parameterTypes)
+            throws NoSuchMethodException {
+        for (Class<?> clazz = instance.getClass(); clazz != null; clazz = clazz.getSuperclass()) {
+            try {
+                Constructor<?> ctor = clazz.getDeclaredConstructor(parameterTypes);
+
+                if (!ctor.isAccessible()) {
+                    ctor.setAccessible(true);
+                }
+
+                return ctor;
+            } catch (NoSuchMethodException e) {
+                // ignore and search next
+            }
+        }
+
+        throw new NoSuchMethodException("Constructor"
+                + " with parameters "
+                + Arrays.asList(parameterTypes)
+                + " not found in " + instance.getClass());
+    }
+
     /**
      * Replace the value of a field containing a non null array, by a new array containing the
      * elements of the original array plus the elements of extraElements.
@@ -154,4 +187,30 @@ public static void reduceFieldArray(Object instance, String fieldName, int reduc
         jlrField.set(instance, combined);
     }
 
+    public static Object getActivityThread(Context context,
+                                            Class<?> activityThread) {
+        try {
+            if (activityThread == null) {
+                activityThread = Class.forName("android.app.ActivityThread");
+            }
+            Method m = activityThread.getMethod("currentActivityThread");
+            m.setAccessible(true);
+            Object currentActivityThread = m.invoke(null);
+            if (currentActivityThread == null && context != null) {
+                // In older versions of Android (prior to frameworks/base 66a017b63461a22842)
+                // the currentActivityThread was built on thread locals, so we'll need to try
+                // even harder
+                Field mLoadedApk = context.getClass().getField("mLoadedApk");
+                mLoadedApk.setAccessible(true);
+                Object apk = mLoadedApk.get(context);
+                Field mActivityThreadField = apk.getClass().getDeclaredField("mActivityThread");
+                mActivityThreadField.setAccessible(true);
+                currentActivityThread = mActivityThreadField.get(apk);
+            }
+            return currentActivityThread;
+        } catch (Throwable ignore) {
+            return null;
+        }
+    }
+
 }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareSecurityCheck.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareSecurityCheck.java
index d62e4693..921984cb 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareSecurityCheck.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareSecurityCheck.java
@@ -64,32 +64,6 @@ public ShareSecurityCheck(Context context) {
         return metaContentMap;
     }
 
-    /**
-     * get the base tinkerId
-     *
-     * @return
-     */
-    public String getTinkerID() {
-        if (packageProperties != null) {
-            String tinkerId = packageProperties.get(ShareConstants.TINKER_ID);
-            return tinkerId;
-        }
-        return null;
-    }
-
-    /**
-     * get the new tinkerId
-     *
-     * @return
-     */
-    public String getNewTinkerID() {
-        if (packageProperties != null) {
-            String tinkerId = packageProperties.get(ShareConstants.NEW_TINKER_ID);
-
-            return tinkerId;
-        }
-        return null;
-    }
     /**
      * Nullable
      *
@@ -128,7 +102,7 @@ public String getNewTinkerID() {
     }
 
     public boolean verifyPatchMetaSignature(File path) {
-        if (path == null || !path.isFile() || !path.exists() || path.length() == 0) {
+        if (!SharePatchFileUtil.isLegalFile(path)) {
             return false;
         }
         JarFile jarFile = null;
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java
index aba789cc..416fccbe 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java
@@ -21,13 +21,18 @@
 import android.content.SharedPreferences;
 import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageManager;
+import android.os.Build;
 import android.util.Log;
 
+import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.InputStream;
+import java.io.PrintStream;
+import java.lang.reflect.Method;
 import java.util.HashMap;
+import java.util.List;
 import java.util.Properties;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
@@ -40,14 +45,41 @@
 public class ShareTinkerInternals {
     private static final String TAG = "Tinker.TinkerInternals";
     private static final boolean VM_IS_ART = isVmArt(System.getProperty("java.vm.version"));
+    private static final boolean VM_IS_JIT = isVmJitInternal();
+
+    private static final String PATCH_PROCESS_NAME = ":patch";
+    private static Boolean isPatchProcess = null;
     /**
      * or you may just hardcode them in your app
      */
     private static String processName = null;
-    private static String tinkerID = null;
+    private static String tinkerID    = null;
 
     public static boolean isVmArt() {
-        return VM_IS_ART;
+        return VM_IS_ART || Build.VERSION.SDK_INT >= 21;
+    }
+
+    public static boolean isVmJit() {
+        return VM_IS_JIT && Build.VERSION.SDK_INT < 24;
+    }
+
+    public static boolean isSystemOTA(String lastFingerPrint) {
+        String currentFingerprint = Build.FINGERPRINT;
+        if (lastFingerPrint == null
+            || lastFingerPrint.equals("")
+            || currentFingerprint == null
+            || currentFingerprint.equals("")) {
+            Log.d(TAG, "fingerprint empty:" + lastFingerPrint + ",current:" + currentFingerprint);
+            return false;
+        } else {
+            if (lastFingerPrint.equals(currentFingerprint)) {
+                Log.d(TAG, "same fingerprint:" + currentFingerprint);
+                return false;
+            } else {
+                Log.d(TAG, "system OTA,fingerprint not equal:" + lastFingerPrint + "," + currentFingerprint);
+                return true;
+            }
+        }
     }
 
     public static boolean isNullOrNil(final String object) {
@@ -59,6 +91,7 @@ public static boolean isNullOrNil(final String object) {
 
     /**
      * thinker package check
+     *
      * @param context
      * @param tinkerFlag
      * @param patchFile
@@ -72,6 +105,7 @@ public static int checkTinkerPackage(Context context, int tinkerFlag, File patch
         }
         return returnCode;
     }
+
     /**
      * check patch file signature and TINKER_ID
      *
@@ -101,6 +135,7 @@ public static int checkSignatureAndTinkerID(Context context, File patchFile, Sha
             return ShareConstants.ERROR_PACKAGE_CHECK_PATCH_TINKER_ID_NOT_FOUND;
         }
         if (!oldTinkerId.equals(patchTinkerId)) {
+            Log.e(TAG, "tinkerId is not equal, base is " + oldTinkerId + ", but patch is " + patchTinkerId);
             return ShareConstants.ERROR_PACKAGE_CHECK_TINKER_ID_NOT_EQUAL;
         }
         return ShareConstants.ERROR_PACKAGE_CHECK_OK;
@@ -134,6 +169,7 @@ public static int checkPackageAndTinkerFlag(ShareSecurityCheck securityCheck, in
     /**
      * not like {@cod ShareSecurityCheck.getPackagePropertiesIfPresent}
      * we don't check Signatures or other files, we just get the package meta's properties directly
+     *
      * @param patchFile
      * @return
      */
@@ -166,6 +202,7 @@ public static Properties fastGetPatchPackageMeta(File patchFile) {
             SharePatchFileUtil.closeZip(zipFile);
         }
     }
+
     public static String getManifestTinkerID(Context context) {
         if (tinkerID != null) {
             return tinkerID;
@@ -205,8 +242,6 @@ public static String getTypeString(int type) {
         switch (type) {
             case ShareConstants.TYPE_DEX:
                 return "dex";
-            case ShareConstants.TYPE_DEX_FOR_ART:
-                return "dex_art";
             case ShareConstants.TYPE_DEX_OPT:
                 return "dex_opt";
             case ShareConstants.TYPE_LIBRARY:
@@ -224,21 +259,30 @@ public static String getTypeString(int type) {
 
     /**
      * you can set Tinker disable in runtime at some times!
+     *
      * @param context
      */
     public static void setTinkerDisableWithSharedPreferences(Context context) {
         SharedPreferences sp = context.getSharedPreferences(ShareConstants.TINKER_SHARE_PREFERENCE_CONFIG, Context.MODE_MULTI_PROCESS);
-        sp.edit().putBoolean(ShareConstants.TINKER_ENABLE_CONFIG, false).commit();
+        sp.edit().putBoolean(getTinkerSharedPreferencesName(), false).commit();
     }
 
     /**
      * can't load or receive any patch!
+     *
      * @param context
      * @return
      */
     public static boolean isTinkerEnableWithSharedPreferences(Context context) {
+        if (context == null) {
+            return false;
+        }
         SharedPreferences sp = context.getSharedPreferences(ShareConstants.TINKER_SHARE_PREFERENCE_CONFIG, Context.MODE_MULTI_PROCESS);
-        return sp.getBoolean(ShareConstants.TINKER_ENABLE_CONFIG, true);
+        return sp.getBoolean(getTinkerSharedPreferencesName(), true);
+    }
+
+    private static String getTinkerSharedPreferencesName() {
+        return ShareConstants.TINKER_ENABLE_CONFIG + ShareConstants.TINKER_VERSION;
     }
 
     public static boolean isTinkerEnabled(int flag) {
@@ -259,11 +303,40 @@ public static boolean isInMainProcess(Context context) {
         return pkgName.equals(processName);
     }
 
+    public static boolean isInPatchProcess(Context context) {
+        if (isPatchProcess != null) {
+            return isPatchProcess;
+        }
+
+        isPatchProcess = getProcessName(context).endsWith(PATCH_PROCESS_NAME);
+        return isPatchProcess;
+    }
+
+    public static String getCurrentOatMode(Context context, String current) {
+        if (current.equals(ShareConstants.CHANING_DEX_OPTIMIZE_PATH)) {
+            if (isInMainProcess(context)) {
+                current = ShareConstants.DEFAULT_DEX_OPTIMIZE_PATH;
+            } else {
+                current = ShareConstants.INTERPRET_DEX_OPTIMIZE_PATH;
+            }
+        }
+        return current;
+    }
+
     public static void killAllOtherProcess(Context context) {
         final ActivityManager am = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
+        if (am == null) {
+            return;
+        }
+        List<ActivityManager.RunningAppProcessInfo> appProcessList = am
+            .getRunningAppProcesses();
+
+        if (appProcessList == null) {
+            return;
+        }
         // NOTE: getRunningAppProcess() ONLY GIVE YOU THE PROCESS OF YOUR OWN PACKAGE IN ANDROID M
         // BUT THAT'S ENOUGH HERE
-        for (ActivityManager.RunningAppProcessInfo ai : am.getRunningAppProcesses()) {
+        for (ActivityManager.RunningAppProcessInfo ai : appProcessList) {
             // KILL OTHER PROCESS OF MINE
             if (ai.uid == android.os.Process.myUid() && ai.pid != android.os.Process.myPid()) {
                 android.os.Process.killProcess(ai.pid);
@@ -299,19 +372,26 @@ private static String getProcessNameInternal(final Context context) {
         ActivityManager activityManager =
             (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
 
-        try {
-            for (ActivityManager.RunningAppProcessInfo process : activityManager.getRunningAppProcesses()) {
-                if (process.pid == myPid) {
-                    myProcess = process;
-                    break;
+        if (activityManager != null) {
+            List<ActivityManager.RunningAppProcessInfo> appProcessList = activityManager
+                .getRunningAppProcesses();
+
+            if (appProcessList != null) {
+                try {
+                    for (ActivityManager.RunningAppProcessInfo process : appProcessList) {
+                        if (process.pid == myPid) {
+                            myProcess = process;
+                            break;
+                        }
+                    }
+                } catch (Exception e) {
+                    Log.e(TAG, "getProcessNameInternal exception:" + e.getMessage());
                 }
-            }
-        } catch (Exception e) {
-            Log.e(TAG, "getProcessNameInternal exception:" + e.getMessage());
-        }
 
-        if (myProcess != null) {
-            return myProcess.processName;
+                if (myProcess != null) {
+                    return myProcess.processName;
+                }
+            }
         }
 
         byte[] b = new byte[128];
@@ -330,7 +410,7 @@ private static String getProcessNameInternal(final Context context) {
             }
 
         } catch (Exception e) {
-            e.printStackTrace();
+            Log.e(TAG, "getProcessNameInternal exception:" + e.getMessage());
         } finally {
             try {
                 if (in != null) {
@@ -345,6 +425,7 @@ private static String getProcessNameInternal(final Context context) {
 
     /**
      * vm whether it is art
+     *
      * @return
      */
     private static boolean isVmArt(String versionString) {
@@ -365,4 +446,68 @@ private static boolean isVmArt(String versionString) {
         }
         return isArt;
     }
+
+    private static boolean isVmJitInternal() {
+        try {
+            Class<?> clazz = Class.forName("android.os.SystemProperties");
+            Method mthGet = clazz.getDeclaredMethod("get", String.class);
+
+            String jit = (String) mthGet.invoke(null, "dalvik.vm.usejit");
+            String jitProfile = (String) mthGet.invoke(null, "dalvik.vm.usejitprofiles");
+
+            //usejit is true and usejitprofiles is null
+            if (!isNullOrNil(jit) && isNullOrNil(jitProfile) && jit.equals("true")) {
+                return true;
+            }
+        } catch (Throwable e) {
+            Log.e(TAG, "isVmJitInternal ex:" + e);
+        }
+        return false;
+    }
+
+    public static String getExceptionCauseString(final Throwable ex) {
+        final ByteArrayOutputStream bos = new ByteArrayOutputStream();
+        final PrintStream ps = new PrintStream(bos);
+
+        try {
+            // print directly
+            Throwable t = ex;
+            while (t.getCause() != null) {
+                t = t.getCause();
+            }
+            t.printStackTrace(ps);
+            return toVisualString(bos.toString());
+        } finally {
+            try {
+                bos.close();
+            } catch (IOException e) {
+            }
+        }
+    }
+
+    public static String toVisualString(String src) {
+        boolean cutFlg = false;
+        if (null == src) {
+            return null;
+        }
+        char[] chr = src.toCharArray();
+        if (null == chr) {
+            return null;
+        }
+        int i = 0;
+        for (; i < chr.length; i++) {
+            if (chr[i] > 127) {
+                chr[i] = 0;
+                cutFlg = true;
+                break;
+            }
+        }
+
+        if (cutFlg) {
+            return new String(chr, 0, i);
+        } else {
+            return src;
+        }
+    }
+
 }
diff --git a/tinker-build/tinker-patch-cli/build.gradle b/tinker-build/tinker-patch-cli/build.gradle
index 9b48cc3a..c1bd4e62 100644
--- a/tinker-build/tinker-patch-cli/build.gradle
+++ b/tinker-build/tinker-patch-cli/build.gradle
@@ -21,7 +21,8 @@ jar {
 }
 
 // copy the jar to work directory
-task buildSdk(type: Copy, dependsOn: [build, jar]) {
+task buildTinkerSdk(type: Copy, dependsOn: [build, jar]) {
+    group = "tinker"
     from('build/libs') {
         include '*.jar'
         exclude '*-javadoc.jar'
@@ -33,4 +34,4 @@ task buildSdk(type: Copy, dependsOn: [build, jar]) {
     into(rootProject.file("buildSdk/build"))
 }
 
-defaultTasks 'buildSdk'
+defaultTasks 'buildTinkerSdk'
diff --git a/tinker-build/tinker-patch-cli/tool_output/merge_mapping.py b/tinker-build/tinker-patch-cli/tool_output/merge_mapping.py
new file mode 100644
index 00000000..a60fda39
--- /dev/null
+++ b/tinker-build/tinker-patch-cli/tool_output/merge_mapping.py
@@ -0,0 +1,165 @@
+#!/usr/bin/python
+# coding: utf-8
+"""
+当工程使用了applymapping之后，会遇到这样的问题
+    1.类和方法上个版本被keep住了，这个版本不keep
+    2.类和方法上个版本没有被keep住，这个版本又keep住了
+这两个问题会导致proguard报warning，官方建议是手动解决冲突
+(http://proguard.sourceforge.net/manual/troubleshooting.html#mappingconflict1)
+不解决的话默认以mapping文件为最高优先级处理，这样混淆会带来一些问题
+
+该方案为
+简单来说，上个版本的mapping称为mapping1，直接编译当前项目，获取当前的mapping文件，称为mapping2。
+从mapping2中可以得到当前项目需要混淆的类，因为重用mapping的意义在于同样的类在不同版本中混淆后的名称保持一致性，
+所以将mapping2里面的所有类和方法统统在mapping1中去查找对应的混淆名称，生成新的mapping3，找不到则不写入mapping3，
+然后mapping3就是最后可以使用的mapping文件。最后重用mapping3来编译当前项目，完成打包整个过程
+
+最后生成的mapping会保留当前版本和之前版本都需要混淆的类和方法，且混淆后的名字取之前的mapping版本中的名字，
+对于keep状态冲突的类和方法，处理方式是不保留在新生成的mapping中，编译过程中由当前的proguard的配置文件来处理
+so  新生成的mapping是之前版本mapping的一个子集
+
+使用教程是传入上版本的mapping和当前项目未applymapping得到的mapping文件，输出处理后的mapping 文件。
+"""
+import os
+import sys
+
+
+def print_usage():
+    print >>sys.stderr, \
+        """usage: python merge_mapping.py old_mapping.txt current_mapping.txt
+           the output mapping file is 'new_mapping.txt' in the cwd directory
+        """
+    sys.exit(1)
+
+
+class MappingData:
+    def __init__(self):
+        self.raw_line = ""
+        self.key = ""
+        self.field_methods = []
+
+
+class DealWithProguardWarning:
+    def __init__(self):
+        self.classes = {}
+        self.class_list = []
+        self.current_classes = {}
+        self.current_class_list = []
+
+    @staticmethod
+    def read_mapping_file(classes, class_list, mapping):
+        current_mapping_data = None
+        with open(mapping, 'r') as fd:
+            # 一行一行读取
+            for line in fd.xreadlines():
+                # 如果不是空格开头，类的处理
+                if not line.startswith(' '):
+                    # 对象不为空，先保存之前的
+                    if current_mapping_data is not None:
+                        classes[current_mapping_data.key] = current_mapping_data
+                        class_list.append(current_mapping_data.key)
+                    # 重新创建对象，并赋值
+                    current_mapping_data = MappingData()
+                    current_mapping_data.raw_line = line
+                    current_mapping_data.key = line.split('->')[0].strip()
+                else:
+                    # 方法的处理，直接加进去
+                    current_mapping_data.field_methods.append(line)
+            classes[current_mapping_data.key] = current_mapping_data
+            class_list.append(current_mapping_data.key)
+        print "size: ", len(classes)
+
+    def remove_warning_mapping(self, old_mapping, current_mapping):
+        self.read_mapping_file(self.classes, self.class_list, old_mapping)
+        self.read_mapping_file(self.current_classes, self.current_class_list, current_mapping)
+        self.do_merge()
+        self.print_new_mapping()
+
+    def exe(self, args):
+        if len(args) < 2:
+            print_usage()
+
+        old_mapping_path = args[0]
+        if not os.path.exists(old_mapping_path):
+            raise Exception("mapping file is not exist, path=%s", old_mapping_path)
+
+        current_mapping_path = args[1]
+        if not os.path.exists(current_mapping_path):
+            raise Exception("proguard warning file is not exist, path=%s", current_mapping_path)
+
+        self.remove_warning_mapping(old_mapping_path, current_mapping_path)
+
+    def do_merge(self):
+        # 遍历当前的mapping class_key
+        for key in self.current_class_list:
+            if key in self.classes:
+                data = self.classes[key]
+                current_data = self.current_classes[key]
+                # 如果当前的类没有被混淆，则保留，否则用之前的mapping里面的内容覆盖
+                # ___.___ -> ___.___:
+                if current_data.raw_line.split("->")[0] != current_data.raw_line.split("->")[1][:-1]:
+                    current_data.raw_line = data.raw_line
+                new_method_list = []
+                # 处理方法
+                for line in current_data.field_methods:
+                    result, new_line = self.find_same_methods(line, data)
+                    # 只有找到才写入
+                    if result:
+                        new_method_list.append(new_line)
+                current_data.field_methods = new_method_list
+            # 新的混淆不在旧的里面，则删除
+            else:
+                del self.current_classes[key]
+
+    def find_same_methods(self, line, data):
+        search_name, search_complete_name, search_new_name = self.get_name_and_complete_name_and_new_name(line)
+        # 这里是特殊情况，如果在当前mapping发现查找的这个并没有混淆，就不打算保留在mapping文件中
+        if search_name == search_new_name:
+            return False, ""
+        for method_line in data.field_methods:
+            target_name, target_complete_name, target_new_name = self.get_name_and_complete_name_and_new_name(method_line)
+            # 这里必须要用最完整的信息来进行比较，避免重载的影响
+            if search_complete_name == target_complete_name:
+                print "1"
+                return True, method_line
+            print "0"
+        return False, ""
+
+    # 返回名字 包含返回值和参数的名字 和 混淆后的名字
+    @staticmethod
+    def get_name_and_complete_name_and_new_name(line):
+        """ ___ ___ -> ___
+            ___:___:___ ___(___) -> ___
+            ___:___:___ ___(___):___ -> ___
+            ___:___:___ ___(___):___:___ -> ___
+        """
+        no_space_line = line.strip()
+        colonIndex1 = no_space_line.find(":")
+        colonIndex2 = no_space_line.find(":", colonIndex1+1) if colonIndex1 != -1 else -1
+        spaceIndex = no_space_line.find(" ", colonIndex2+2)
+        argumentIndex1 = no_space_line.find("(", spaceIndex+1)
+        argumentIndex2 = no_space_line.find(")", argumentIndex1+1) if argumentIndex1 != -1 else -1
+        colonIndex3 = no_space_line.find(":", argumentIndex2+1) if argumentIndex2 != -1 else -1
+        colonIndex4 = no_space_line.find(":", colonIndex3+1) if colonIndex3 != -1 else -1
+        arrowIndex = no_space_line.find("->")
+
+        if spaceIndex < 0 or arrowIndex < 0:
+            raise Exception("can not parse line %s", no_space_line)
+        name = no_space_line[spaceIndex + 1: argumentIndex1 if argumentIndex1 >= 0 else arrowIndex].strip()
+        new_name = no_space_line[arrowIndex + 2:].strip()
+        complete_name = no_space_line[colonIndex2 + 1:arrowIndex].strip()
+        return name, complete_name,  new_name
+
+    def print_new_mapping(self):
+        output_path = os.path.join(os.getcwd(), "new_mapping.txt")
+        with open(output_path, "w") as fw:
+            for key in self.current_class_list:
+                if key in self.current_classes:
+                    data = self.current_classes[key]
+                    fw.write(data.raw_line)
+                    for line in data.field_methods:
+                        fw.write(line)
+
+
+if __name__ == '__main__':
+    DealWithProguardWarning().exe(sys.argv[1:])
diff --git a/tinker-build/tinker-patch-cli/tool_output/proguard_warning.py b/tinker-build/tinker-patch-cli/tool_output/proguard_warning.py
new file mode 100755
index 00000000..a9cb7681
--- /dev/null
+++ b/tinker-build/tinker-patch-cli/tool_output/proguard_warning.py
@@ -0,0 +1,109 @@
+#!/usr/bin/python
+# coding: utf8
+
+import os
+import sys
+
+
+def print_usage():
+    print >>sys.stderr, \
+        """usage: python proguard_warning.py mapping.txt warning.txt
+
+           the output mapping file is 'mapping_edit.txt' in the cwd directory
+        """
+    sys.exit(1)
+
+class MappingData:
+    raw_line = ""
+    key = ""
+    filed_methods = []
+
+    def __init__(self):
+        self.raw_line = ""
+        self.key = ""
+        self.filed_methods = []
+
+class RemoveProguardWarning:
+    def __init__(self):
+        self.classes = {}
+        self.class_list = []
+
+    def read_mapping_file(self, mapping):
+        current_mapping_data = None
+        with open(mapping) as fd:
+            for line in fd.readlines():
+                if not line.startswith(' '):
+                    if current_mapping_data is not None:
+                        self.classes[current_mapping_data.key] = current_mapping_data
+                        self.class_list.append(current_mapping_data.key)
+
+                    current_mapping_data = MappingData()
+                    current_mapping_data.raw_line = line
+                    current_mapping_data.key = line.split('->')[0].strip()
+                else:
+                    current_mapping_data.filed_methods.append(line)
+
+            self.classes[current_mapping_data.key] = current_mapping_data
+            self.class_list.append(current_mapping_data.key)
+
+        # print "size: ", len(self.classes)
+
+    def remove_warning(self, warning):
+        with open(warning) as fd:
+            for line in fd.readlines():
+                if not line.startswith("Warning:"):
+                    raise Exception("proguard warning must begin with 'Warning:', line=", line)
+                splits = line.split(':')
+                class_key = splits[1].strip()
+                # print "class_key", class_key
+                if class_key not in self.classes:
+                    print "Warning:can't find warning class in the mapping file, class=", class_key
+                    continue
+                warning_value = splits[2].split("'")[1] + " -> " + splits[2].split("'")[5]
+                mapping_data = self.classes[class_key]
+                # print "warning_value", warning_value
+
+                find = False
+                for mappings in mapping_data.filed_methods:
+                    if mappings.find(warning_value) != -1:
+                        mapping_data.filed_methods.remove(mappings)
+                        find = True
+                        break
+
+                if not find:
+                    print "Warning: can't find warning field or method in the mapping file:', value=", warning_value
+
+                if len(mapping_data.filed_methods) == 0:
+                    del self.classes[class_key]
+
+        output_path = os.path.join(os.getcwd(), "mapping_edit.txt")
+        with open(output_path, "w") as fw:
+            for key in self.class_list:
+                if key in self.classes:
+                    data = self.classes[key]
+                    fw.write(data.raw_line)
+                    for line in data.filed_methods:
+                        fw.write(line)
+
+    def remove_warning_mapping(self, mapping, warning):
+        self.read_mapping_file(mapping)
+        self.remove_warning(warning)
+
+    def do_command(self, args):
+        if (len(args) < 2):
+            print_usage()
+
+        mapping_path = args[0]
+        if not os.path.exists(mapping_path):
+            raise Exception("mapping file is not exist, path=%s", mapping_path)
+
+        warning_patch = args[1]
+        if not os.path.exists(warning_patch):
+            raise Exception("proguard warning file is not exist, path=%s", warning_patch)
+
+        self.remove_warning_mapping(mapping_path, warning_patch)
+
+
+
+if __name__ == '__main__':
+    RemoveProguardWarning().do_command(sys.argv[1:])
\ No newline at end of file
diff --git a/tinker-build/tinker-patch-cli/tool_output/tinker_config.xml b/tinker-build/tinker-patch-cli/tool_output/tinker_config.xml
index de0c6c99..12d0920c 100644
--- a/tinker-build/tinker-patch-cli/tool_output/tinker_config.xml
+++ b/tinker-build/tinker-patch-cli/tool_output/tinker_config.xml
@@ -24,6 +24,11 @@
 
         <!--if you don't set sevenZip path, we just use 7za to try-->
         <sevenZipPath value="/usr/local/bin/7za"/>
+        <!--Whether tinker should treat the base apk as the one being protected by app-->
+        <!--protection tools.-->
+        <!--If this attribute is true, the generated patch package will contain a-->
+        <!--dex including all changed classes instead of any dexdiff patch-info files.-->
+        <isProtectedApp value="false"/>
     </issue>
 
     <issue id="dex">
@@ -52,7 +57,7 @@
         <!--it support * or ? pattern.-->
         <!--for library in assets, we would just recover them in the patch directory-->
         <!--you can get them in TinkerLoadResult with Tinker-->
-        <pattern value="lib/armeabi/*.so"/>
+        <pattern value="lib/*/*.so"/>
     </issue>
 
     <issue id="resource">
diff --git a/tinker-build/tinker-patch-cli/tool_output/tinker_multidexkeep.pro b/tinker-build/tinker-patch-cli/tool_output/tinker_multidexkeep.pro
index af70fdb0..5c9f4c5b 100644
--- a/tinker-build/tinker-patch-cli/tool_output/tinker_multidexkeep.pro
+++ b/tinker-build/tinker-patch-cli/tool_output/tinker_multidexkeep.pro
@@ -1,21 +1,27 @@
+#tinker multidex keep patterns:
 -keep public class * implements com.tencent.tinker.loader.app.ApplicationLifeCycle {
-    *;
+    <init>();
+    void onBaseContextAttached(android.content.Context);
 }
 
 -keep public class * extends com.tencent.tinker.loader.TinkerLoader {
-    *;
+    <init>();
 }
 
--keep public class * extends com.tencent.tinker.loader.app.TinkerApplication {
-    *;
+-keep public class * extends android.app.Application {
+     <init>();
+     void attachBaseContext(android.content.Context);
 }
 
-#your dex.loader pattern here
--keep class com.tencent.tinker.loader.** {
-    *;
+-keep class com.tencent.tinker.loader.TinkerTestAndroidNClassLoader {
+    <init>();
 }
 
+#your dex.loader patterns here
 -keep class tinker.sample.android.app.SampleApplication {
-    *;
+    <init>();
 }
 
+-keep class com.tencent.tinker.loader.** {
+    <init>();
+}
\ No newline at end of file
diff --git a/tinker-build/tinker-patch-cli/tool_output/tinker_proguard.pro b/tinker-build/tinker-patch-cli/tool_output/tinker_proguard.pro
index e4ef8030..85e96b50 100644
--- a/tinker-build/tinker-patch-cli/tool_output/tinker_proguard.pro
+++ b/tinker-build/tinker-patch-cli/tool_output/tinker_proguard.pro
@@ -25,7 +25,16 @@
     *;
 }
 
+-keep public class com.tencent.tinker.loader.TinkerTestAndroidNClassLoader {
+    *;
+}
+
+#for command line version, we must keep all the loader class to avoid proguard mapping conflict
 #your dex.loader pattern here
--keep class com.tencent.tinker.loader.**
--keep class tinker.sample.android.app.SampleApplication
+-keep public class com.tencent.tinker.loader.** {
+    *;
+}
 
+-keep class tinker.sample.android.app.SampleApplication {
+    *;
+}
\ No newline at end of file
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/TinkerPatchPlugin.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/TinkerPatchPlugin.groovy
index 8f539a16..a3c6e0bc 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/TinkerPatchPlugin.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/TinkerPatchPlugin.groovy
@@ -18,13 +18,13 @@ package com.tencent.tinker.build.gradle
 
 import com.tencent.tinker.build.gradle.extension.*
 import com.tencent.tinker.build.gradle.task.*
-import com.tencent.tinker.build.gradle.transform.AuxiliaryInjectTransform
 import com.tencent.tinker.build.util.FileOperation
 import com.tencent.tinker.build.util.TypedValue
+import com.tencent.tinker.build.util.Utils
 import org.gradle.api.GradleException
 import org.gradle.api.Plugin
 import org.gradle.api.Project
-import org.gradle.api.UnknownTaskException
+import org.gradle.api.Task
 
 /**
  * Registers the plugin's tasks.
@@ -37,7 +37,12 @@ class TinkerPatchPlugin implements Plugin<Project> {
 
     @Override
     public void apply(Project project) {
-        project.apply plugin: 'osdetector'
+        //osdetector change its plugin name in 1.4.0
+        try {
+            project.apply plugin: 'osdetector'
+        } catch (Throwable e) {
+            project.apply plugin: 'com.google.osdetector'
+        }
 
         project.extensions.create('tinkerPatch', TinkerPatchExtension)
 
@@ -49,29 +54,36 @@ class TinkerPatchPlugin implements Plugin<Project> {
         project.tinkerPatch.extensions.create('packageConfig', TinkerPackageConfigExtension, project)
         project.tinkerPatch.extensions.create('sevenZip', TinkerSevenZipExtension, project)
 
-        def configuration = project.tinkerPatch
+        if (!project.plugins.hasPlugin('com.android.application')) {
+            throw new GradleException('generateTinkerApk: Android Application plugin required')
+        }
+
+        def android = project.extensions.android
+
+        //open jumboMode
+        android.dexOptions.jumboMode = true
 
-        project.android.registerTransform(new AuxiliaryInjectTransform(project))
+        //close preDexLibraries
+        try {
+            android.dexOptions.preDexLibraries = false
+        } catch (Throwable e) {
+            //no preDexLibraries field, just continue
+        }
 
         project.afterEvaluate {
-            if (!project.plugins.hasPlugin('com.android.application')) {
-                throw new GradleException('generateTinkerApk: Android Application plugin required')
-            }
+            def configuration = project.tinkerPatch
 
-            def android = project.extensions.android
-            //add the tinker anno resource to the package exclude option
-            android.packagingOptions.exclude("META-INF/services/javax.annotation.processing.Processor")
-            android.packagingOptions.exclude("TinkerAnnoApplication.tmpl")
-            //open jumboMode
-            android.dexOptions.jumboMode = true
-            //close preDexLibraries
-            try {
-                android.dexOptions.preDexLibraries = false
-            } catch (Throwable e) {
-                //no preDexLibraries field, just continue
+            if (!configuration.tinkerEnable) {
+                project.logger.error("tinker tasks are disabled.")
+                return
             }
 
             project.logger.error("----------------------tinker build warning ------------------------------------")
+            project.logger.error("tinker auto operation: ")
+            project.logger.error("excluding annotation processor and source template from app packaging. Enable dx jumboMode to reduce package size.")
+            project.logger.error("enable dx jumboMode to reduce package size.")
+            project.logger.error("disable preDexLibraries to prevent ClassDefNotFoundException when your app is booting.")
+            project.logger.error("")
             project.logger.error("tinker will change your build configs:")
             project.logger.error("we will add TINKER_ID=${configuration.buildConfig.tinkerId} in your build output manifest file build/intermediates/manifests/full/*")
             project.logger.error("")
@@ -88,7 +100,7 @@ class TinkerPatchPlugin implements Plugin<Project> {
             project.logger.error("")
             project.logger.error("if multiDexEnabled is true")
             project.logger.error("you will find the gen multiDexKeepProguard file at ${TinkerMultidexConfigTask.MULTIDEX_CONFIG_PATH}")
-            project.logger.error("and you should copy it to your own multiDex keep proguard file yourself.")
+            project.logger.error("and we will help you to put it in the MultiDexKeepProguardFile.")
             project.logger.error("")
             project.logger.error("if applyResourceMapping file is exist")
             String tempResourceMappingPath = configuration.buildConfig.applyResourceMapping
@@ -105,28 +117,22 @@ class TinkerPatchPlugin implements Plugin<Project> {
                 def variantOutput = variant.outputs.first()
                 def variantName = variant.name.capitalize()
 
-                try {
-                    def instantRunTask = project.tasks.getByName("transformClassesWithInstantRunFor${variantName}")
-                    if (instantRunTask) {
-                        throw new GradleException(
-                                "Tinker does not support instant run mode, please trigger build"
-                                        + " by assemble${variantName} or disable instant run"
-                                        + " in 'File->Settings...'."
-                        )
-                    }
-                } catch (UnknownTaskException e) {
-                    // Not in instant run mode, continue.
+                def instantRunTask = getInstantRunTask(project, variantName)
+                if (instantRunTask != null) {
+                    throw new GradleException(
+                            "Tinker does not support instant run mode, please trigger build"
+                                    + " by assemble${variantName} or disable instant run"
+                                    + " in 'File->Settings...'."
+                    )
                 }
 
                 TinkerPatchSchemaTask tinkerPatchBuildTask = project.tasks.create("tinkerPatch${variantName}", TinkerPatchSchemaTask)
-                tinkerPatchBuildTask.dependsOn variant.assemble
 
                 tinkerPatchBuildTask.signConfig = variant.apkVariantData.variantConfiguration.signingConfig
 
                 variant.outputs.each { output ->
-                    tinkerPatchBuildTask.buildApkPath = output.outputFile
-                    File parentFile = output.outputFile
-                    tinkerPatchBuildTask.outputFolder = "${parentFile.getParentFile().getParentFile().getAbsolutePath()}/" + TypedValue.PATH_DEFAULT_OUTPUT + "/" + variant.dirName
+                    setPatchNewApkPath(configuration, output, variant, tinkerPatchBuildTask)
+                    setPatchOutputFolder(configuration, output, variant, tinkerPatchBuildTask)
                 }
 
                 // Create a task to add a build TINKER_ID to AndroidManifest.xml
@@ -152,7 +158,13 @@ class TinkerPatchPlugin implements Plugin<Project> {
                 if (proguardEnable) {
                     TinkerProguardConfigTask proguardConfigTask = project.tasks.create("tinkerProcess${variantName}Proguard", TinkerProguardConfigTask)
                     proguardConfigTask.applicationVariant = variant
-                    variantOutput.packageApplication.dependsOn proguardConfigTask
+                    proguardConfigTask.mustRunAfter manifestTask
+
+                    def proguardTask = getProguardTask(project, variantName)
+                    if (proguardTask != null) {
+                        proguardTask.dependsOn proguardConfigTask
+                    }
+
                 }
 
                 // Add this multidex proguard settings file to the list
@@ -161,12 +173,87 @@ class TinkerPatchPlugin implements Plugin<Project> {
                 if (multiDexEnabled) {
                     TinkerMultidexConfigTask multidexConfigTask = project.tasks.create("tinkerProcess${variantName}MultidexKeep", TinkerMultidexConfigTask)
                     multidexConfigTask.applicationVariant = variant
-                    variantOutput.packageApplication.dependsOn multidexConfigTask
+                    multidexConfigTask.mustRunAfter manifestTask
+
+                    def multidexTask = getMultiDexTask(project, variantName)
+                    if (multidexTask != null) {
+                        multidexTask.dependsOn multidexConfigTask
+                    }
+                    def collectMultiDexComponentsTask = getCollectMultiDexComponentsTask(project, variantName)
+                    if (collectMultiDexComponentsTask != null) {
+                        multidexConfigTask.mustRunAfter collectMultiDexComponentsTask
+                    }
+                }
+
+                if (configuration.buildConfig.keepDexApply
+                    && FileOperation.isLegalFile(project.tinkerPatch.oldApk)) {
+                    com.tencent.tinker.build.gradle.transform.ImmutableDexTransform.inject(project, variant)
                 }
+            }
+        }
+    }
 
+    /**
+     * Specify the output folder of tinker patch result.
+     *
+     * @param configuration the tinker configuration 'tinkerPatch'
+     * @param output the output of assemble result
+     * @param variant the variant
+     * @param tinkerPatchBuildTask the task that tinker patch uses
+     */
+    void setPatchOutputFolder(configuration, output, variant, tinkerPatchBuildTask) {
+        File parentFile = output.outputFile
+        String outputFolder = "${configuration.outputFolder}";
+        if (!Utils.isNullOrNil(outputFolder)) {
+            outputFolder = "${outputFolder}/${TypedValue.PATH_DEFAULT_OUTPUT}/${variant.dirName}"
+        } else {
+            outputFolder =
+                    "${parentFile.getParentFile().getParentFile().getAbsolutePath()}/${TypedValue.PATH_DEFAULT_OUTPUT}/${variant.dirName}"
+        }
+        tinkerPatchBuildTask.outputFolder = outputFolder
+    }
+
+    /**
+     * Specify the new apk path. If the new apk file is specified by {@code tinkerPatch.buildConfig.newApk},
+     * just use it as the new apk input for tinker patch, otherwise use the assemble output.
+     *
+     * @param project the project which applies this plugin
+     * @param configuration the tinker configuration 'tinkerPatch'
+     * @param output the output of assemble result
+     * @param variant the variant
+     * @param tinkerPatchBuildTask the task that tinker patch uses
+     */
+    void setPatchNewApkPath(configuration, output, variant, tinkerPatchBuildTask) {
+        def newApkPath = configuration.newApk;
+        if (!Utils.isNullOrNil(newApkPath)) {
+            if (FileOperation.isLegalFile(newApkPath)) {
+                tinkerPatchBuildTask.buildApkPath = newApkPath
+                return
             }
         }
 
+        tinkerPatchBuildTask.buildApkPath = output.outputFile
+        tinkerPatchBuildTask.dependsOn variant.assemble
+    }
+
+    Task getMultiDexTask(Project project, String variantName) {
+        String multiDexTaskName = "transformClassesWithMultidexlistFor${variantName}"
+        return project.tasks.findByName(multiDexTaskName)
+    }
+
+    Task getProguardTask(Project project, String variantName) {
+        String proguardTaskName = "transformClassesAndResourcesWithProguardFor${variantName}"
+        return project.tasks.findByName(proguardTaskName)
+    }
+
+    Task getInstantRunTask(Project project, String variantName) {
+        String instantRunTask = "transformClassesWithInstantRunFor${variantName}"
+        return project.tasks.findByName(instantRunTask)
+    }
+
+    Task getCollectMultiDexComponentsTask(Project project, String variantName) {
+        String collectMultiDexComponents = "collect${variantName}MultiDexComponents"
+        return project.tasks.findByName(collectMultiDexComponents)
     }
 
 }
\ No newline at end of file
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerBuildConfigExtension.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerBuildConfigExtension.groovy
index 4ad1b62e..490eb48e 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerBuildConfigExtension.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerBuildConfigExtension.groovy
@@ -45,16 +45,33 @@ public class TinkerBuildConfigExtension {
      */
     String tinkerId
 
+    /**
+     * Whether tinker should treat the base apk as the one being protected by app
+     * protection tools.
+     * If this attribute is true, the generated patch package will contain a
+     * dex including all changed classes instead of any dexdiff patch-info files.
+     * default: false
+     */
+    boolean isProtectedApp
+
     private Project project
 
     boolean usingResourceMapping
 
+    /**
+     * if keepDexApply is true,class in which dex refer to the old apk.
+     * open this can reduce the dex diff file size.
+     */
+    boolean keepDexApply;
+
     public TinkerBuildConfigExtension(Project project) {
         this.project = project
         applyMapping = ""
         applyResourceMapping = ""
         tinkerId = null
         usingResourceMapping = false
+        keepDexApply = false
+        isProtectedApp = false
     }
 
     void checkParameter() {
@@ -68,6 +85,8 @@ public class TinkerBuildConfigExtension {
     public String toString() {
         """| applyMapping = ${applyMapping}
            | applyResourceMapping = ${applyResourceMapping}
+           | isProtectedApp = ${isProtectedApp}
+           | keepDexApply = ${keepDexApply}
            | tinkerId = ${tinkerId}
         """.stripMargin()
     }
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerDexExtension.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerDexExtension.groovy
index 0bab55fe..e2429f03 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerDexExtension.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerDexExtension.groovy
@@ -32,18 +32,6 @@ public class TinkerDexExtension {
      */
     String dexMode;
 
-    /**
-     * If mUsePreGeneratedPatchDex was enabled, tinker framework would generate
-     * a dex file including all added and changed classes instead of patch info file.
-     *
-     * You can make this mode enabled if you're using any dex encrypting solutions or
-     * maintaining patches that suitable for multi-channel base packages.
-     *
-     * Notice that although you use this mode, proguard mappings should still be applied
-     * to base package and all patched packages.
-     */
-    boolean usePreGeneratedPatchDex
-
     /**
      * the dex file patterns, which dex or jar files will be deal to gen patch
      * such as [classes.dex, classes-*.dex, assets/multiDex/*.jar]
@@ -55,13 +43,16 @@ public class TinkerDexExtension {
      * such as [com.tencent.tinker.loader.*, com.tinker.sample.MyApplication]
      */
     Iterable<String> loader;
+
+    Iterable<String> ignoreWarningLoader;
+
     private Project project;
 
     public TinkerDexExtension(Project project) {
         dexMode = "jar"
         pattern = []
         loader = []
-        usePreGeneratedPatchDex = false
+        ignoreWarningLoader = []
         this.project = project
     }
 
@@ -74,9 +65,9 @@ public class TinkerDexExtension {
     @Override
     public String toString() {
         """| dexMode = ${dexMode}
-           | usePreGeneratedPatchDex = ${usePreGeneratedPatchDex}
            | pattern = ${pattern}
            | loader = ${loader}
+           | ignoreWarningLoader = ${ignoreWarningLoader}
         """.stripMargin()
     }
 }
\ No newline at end of file
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerPatchExtension.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerPatchExtension.groovy
index 17ec5b63..3b99a728 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerPatchExtension.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerPatchExtension.groovy
@@ -30,6 +30,16 @@ public class TinkerPatchExtension {
      */
     String oldApk
 
+    /**
+     * Specify a folder for the outputs where place the tinker patch results.
+     */
+    String outputFolder
+
+    /**
+     * Specify the new apk path instead of running assemble task again.
+     */
+    String newApk;
+
     /**
      * If there is loader class changes,
      * or Activity, Service, Receiver, Provider change, it will terminal
@@ -44,10 +54,19 @@ public class TinkerPatchExtension {
      */
     boolean useSign
 
+    /**
+     * whether use tinker
+     * default: true
+     */
+    boolean tinkerEnable
+
     public TinkerPatchExtension() {
         oldApk = ""
+        outputFolder = ""
+        newApk = ""
         ignoreWarning = false
         useSign = true
+        tinkerEnable = true
     }
 
     void checkParameter() {
@@ -66,7 +85,10 @@ public class TinkerPatchExtension {
     @Override
     public String toString() {
         """| oldApk = ${oldApk}
+           | outputFolder = ${outputFolder}
+           | newApk = ${newApk}
            | ignoreWarning = ${ignoreWarning}
+           | tinkerEnable = ${tinkerEnable}
            | useSign = ${useSign}
         """.stripMargin()
     }
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerManifestTask.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerManifestTask.groovy
index 50af6687..2c4b19d1 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerManifestTask.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerManifestTask.groovy
@@ -31,6 +31,8 @@ import org.gradle.api.tasks.TaskAction
 public class TinkerManifestTask extends DefaultTask {
     static final String MANIFEST_XML = TinkerPatchPlugin.TINKER_INTERMEDIATES + "AndroidManifest.xml"
     static final String TINKER_ID = "TINKER_ID"
+    static final String TINKER_ID_PREFIX = "tinker_id_"
+
     String manifestPath
     TinkerManifestTask() {
         group = 'tinker'
@@ -43,11 +45,25 @@ public class TinkerManifestTask extends DefaultTask {
         if (tinkerValue == null || tinkerValue.isEmpty()) {
             throw new GradleException('tinkerId is not set!!!')
         }
+
+        tinkerValue = TINKER_ID_PREFIX + tinkerValue
+
         project.logger.error("tinker add ${tinkerValue} to your AndroidManifest.xml ${manifestPath}")
 
+        writeManifestMeta(manifestPath, TINKER_ID, tinkerValue)
+        addApplicationToLoaderPattern()
+        File manifestFile = new File(manifestPath)
+        if (manifestFile.exists()) {
+            FileOperation.copyFileUsingStream(manifestFile, project.file(MANIFEST_XML))
+            project.logger.error("tinker gen AndroidManifest.xml in ${MANIFEST_XML}")
+        }
+
+    }
+
+    void writeManifestMeta(String path, String name, String value) {
         def ns = new Namespace("http://schemas.android.com/apk/res/android", "android")
 
-        def xml = new XmlParser().parse(new InputStreamReader(new FileInputStream(manifestPath), "utf-8"))
+        def xml = new XmlParser().parse(new InputStreamReader(new FileInputStream(path), "utf-8"))
 
         def application = xml.application[0]
         if (application) {
@@ -55,25 +71,46 @@ public class TinkerManifestTask extends DefaultTask {
 
             // remove any old TINKER_ID elements
             def tinkerId = metaDataTags.findAll {
-                it.attributes()[ns.name].equals(TINKER_ID)
+                it.attributes()[ns.name].equals(name)
             }.each {
                 it.parent().remove(it)
             }
 
             // Add the new TINKER_ID element
-            application.appendNode('meta-data', [(ns.name): TINKER_ID, (ns.value): tinkerValue])
+            application.appendNode('meta-data', [(ns.name): name, (ns.value): value])
 
             // Write the manifest file
-            def printer = new XmlNodePrinter(new PrintWriter(manifestPath, "utf-8"))
+            def printer = new XmlNodePrinter(new PrintWriter(path, "utf-8"))
             printer.preserveWhitespace = true
             printer.print(xml)
         }
-        File manifestFile = new File(manifestPath)
-        if (manifestFile.exists()) {
-            FileOperation.copyFileUsingStream(manifestFile, project.file(MANIFEST_XML))
-            project.logger.error("tinker gen AndroidManifest.xml in ${MANIFEST_XML}")
+    }
+
+    void addApplicationToLoaderPattern() {
+        Iterable<String> loader = project.extensions.tinkerPatch.dex.loader
+        String applicationName = readManifestApplicationName(manifestPath)
+
+        if (applicationName != null && !loader.contains(applicationName)) {
+            loader.add(applicationName)
+            project.logger.error("tinker add ${applicationName} to dex loader pattern")
+        }
+        String loaderClass = "com.tencent.tinker.loader.*"
+        if (!loader.contains(loaderClass)) {
+            loader.add(loaderClass)
+            project.logger.error("tinker add ${loaderClass} to dex loader pattern")
         }
 
     }
+
+    String readManifestApplicationName(String path) {
+        def xml = new XmlParser().parse(new InputStreamReader(new FileInputStream(path), "utf-8"))
+        def ns = new Namespace("http://schemas.android.com/apk/res/android", "android")
+
+        def application = xml.application[0]
+        if (application) {
+            return application.attributes()[ns.name]
+        }
+        return null
+    }
 }
 
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerMultidexConfigTask.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerMultidexConfigTask.groovy
index edc22e81..2b148947 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerMultidexConfigTask.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerMultidexConfigTask.groovy
@@ -16,12 +16,10 @@
 
 package com.tencent.tinker.build.gradle.task
 
-import com.tencent.tinker.build.auxiliaryclass.AuxiliaryClassInjector
 import com.tencent.tinker.build.gradle.TinkerPatchPlugin
 import org.gradle.api.DefaultTask
 import org.gradle.api.tasks.TaskAction
 
-
 /**
  * The configuration properties.
  *
@@ -31,15 +29,17 @@ public class TinkerMultidexConfigTask extends DefaultTask {
     static final String MULTIDEX_CONFIG_PATH = TinkerPatchPlugin.TINKER_INTERMEDIATES + "tinker_multidexkeep.pro"
     static final String MULTIDEX_CONFIG_SETTINGS =
             "-keep public class * implements com.tencent.tinker.loader.app.ApplicationLifeCycle {\n" +
-                    "    *;\n" +
+                    "    <init>(...);\n" +
+                    "    void onBaseContextAttached(android.content.Context);\n" +
                     "}\n" +
                     "\n" +
                     "-keep public class * extends com.tencent.tinker.loader.TinkerLoader {\n" +
-                    "    *;\n" +
+                    "    <init>(...);\n" +
                     "}\n" +
                     "\n" +
-                    "-keep public class * extends com.tencent.tinker.loader.app.TinkerApplication {\n" +
-                    "    *;\n" +
+                    "-keep public class * extends android.app.Application {\n" +
+                    "     <init>();\n" +
+                    "     void attachBaseContext(android.content.Context);\n" +
                     "}\n"
 
 
@@ -51,20 +51,27 @@ public class TinkerMultidexConfigTask extends DefaultTask {
 
     @TaskAction
     def updateTinkerProguardConfig() {
-        def file = project.file(MULTIDEX_CONFIG_PATH)
+        File file = project.file(MULTIDEX_CONFIG_PATH)
         project.logger.error("try update tinker multidex keep proguard file with ${file}")
 
         // Create the directory if it doesn't exist already
         file.getParentFile().mkdirs()
 
-        // Write our recommended proguard settings to this file
-        FileWriter fr = new FileWriter(file.path)
+        StringBuffer lines = new StringBuffer()
+        lines.append("\n")
+             .append("#tinker multidex keep patterns:\n")
+             .append(MULTIDEX_CONFIG_SETTINGS)
+             .append("\n")
 
-        fr.write(MULTIDEX_CONFIG_SETTINGS)
-        fr.write("\n")
+        // This class must be placed in main dex so that we can use it to check if new pathList
+        // in AndroidNClassLoader is fine when under the protected app (whose main dex is always encrypted).
+        lines.append("-keep class com.tencent.tinker.loader.TinkerTestAndroidNClassLoader {\n" +
+                "    <init>(...);\n" +
+                "}\n")
+             .append("\n")
+
+        lines.append("#your dex.loader patterns here\n")
 
-        //unlike proguard, if loader endwith *, we must change to **
-        fr.write("#your dex.loader patterns here\n")
         Iterable<String> loader = project.extensions.tinkerPatch.dex.loader
         for (String pattern : loader) {
             if (pattern.endsWith("*")) {
@@ -72,12 +79,46 @@ public class TinkerMultidexConfigTask extends DefaultTask {
                     pattern += "*"
                 }
             }
-            fr.write("-keep class " + pattern + " {\n" +
-                    "    *;\n" +
+            lines.append("-keep class " + pattern + " {\n" +
+                    "    <init>(...);\n" +
                     "}\n")
-            fr.write("\n")
+                    .append("\n")
+        }
+
+
+
+        // Write our recommended proguard settings to this file
+        FileWriter fr = new FileWriter(file.path)
+        try {
+            for (String line : lines) {
+                fr.write(line)
+            }
+        } finally {
+            fr.close()
+        }
+
+        File multiDexKeepProguard = null
+        try {
+            multiDexKeepProguard = applicationVariant.getVariantData().getScope().getManifestKeepListProguardFile()
+        } catch (Throwable ignore) {
+            try {
+                multiDexKeepProguard = applicationVariant.getVariantData().getScope().getManifestKeepListFile()
+            } catch (Throwable e) {
+                project.logger.error("can't find getManifestKeepListFile method, exception:${e}")
+            }
+        }
+        if (multiDexKeepProguard == null) {
+            project.logger.error("auto add multidex keep pattern fail, you can only copy ${file} to your own multiDex keep proguard file yourself.")
+            return
+        }
+        FileWriter manifestWriter = new FileWriter(multiDexKeepProguard, true)
+        try {
+            for (String line : lines) {
+                manifestWriter.write(line)
+            }
+        } finally {
+            manifestWriter.close()
         }
-        fr.close()
     }
 
 
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerPatchSchemaTask.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerPatchSchemaTask.groovy
index 8ae768d3..f1ef7453 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerPatchSchemaTask.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerPatchSchemaTask.groovy
@@ -44,8 +44,6 @@ public class TinkerPatchSchemaTask extends DefaultTask {
 
     @TaskAction
     def tinkerPatch() {
-//        println configuration.toString()
-
         configuration.checkParameter()
         configuration.buildConfig.checkParameter()
         configuration.res.checkParameter()
@@ -55,7 +53,7 @@ public class TinkerPatchSchemaTask extends DefaultTask {
         InputParam.Builder builder = new InputParam.Builder()
         if (configuration.useSign) {
             if (signConfig == null) {
-                throw new GradleException("can't the get signConfig for ${taskName} build")
+                throw new GradleException("can't the get signConfig for this build")
             }
             builder.setSignFile(signConfig.storeFile)
                     .setKeypass(signConfig.keyPassword)
@@ -68,16 +66,17 @@ public class TinkerPatchSchemaTask extends DefaultTask {
                .setNewApk(buildApkPath)
                .setOutBuilder(outputFolder)
                .setIgnoreWarning(configuration.ignoreWarning)
-               .setUsePreGeneratedPatchDex(configuration.dex.usePreGeneratedPatchDex)
-               .setDexFilePattern(configuration.dex.pattern)
-               .setDexLoaderPattern(configuration.dex.loader)
+               .setDexFilePattern(new ArrayList<String>(configuration.dex.pattern))
+               .setIsProtectedApp(configuration.buildConfig.isProtectedApp)
+               .setDexLoaderPattern(new ArrayList<String>(configuration.dex.loader))
+               .setDexIgnoreWarningLoaderPattern(new ArrayList<String>(configuration.dex.ignoreWarningLoader))
                .setDexMode(configuration.dex.dexMode)
-               .setSoFilePattern(configuration.lib.pattern)
-               .setResourceFilePattern(configuration.res.pattern)
-               .setResourceIgnoreChangePattern(configuration.res.ignoreChange)
+               .setSoFilePattern(new ArrayList<String>(configuration.lib.pattern))
+               .setResourceFilePattern(new ArrayList<String>(configuration.res.pattern))
+               .setResourceIgnoreChangePattern(new ArrayList<String>(configuration.res.ignoreChange))
                .setResourceLargeModSize(configuration.res.largeModSize)
                .setUseApplyResource(configuration.buildConfig.usingResourceMapping)
-               .setConfigFields(configuration.packageConfig.getFields())
+               .setConfigFields(new HashMap<String, String>(configuration.packageConfig.getFields()))
                .setSevenZipPath(configuration.sevenZip.path)
                .setUseSign(configuration.useSign)
 
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerProguardConfigTask.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerProguardConfigTask.groovy
index 8528b265..23230b52 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerProguardConfigTask.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerProguardConfigTask.groovy
@@ -16,7 +16,6 @@
 
 package com.tencent.tinker.build.gradle.task
 
-import com.tencent.tinker.build.auxiliaryclass.AuxiliaryClassInjector
 import com.tencent.tinker.build.gradle.TinkerPatchPlugin
 import com.tencent.tinker.build.util.FileOperation
 import org.gradle.api.DefaultTask
@@ -32,7 +31,6 @@ public class TinkerProguardConfigTask extends DefaultTask {
     static final String PROGUARD_CONFIG_SETTINGS =
             "-keepattributes *Annotation* \n" +
                     "-dontwarn com.tencent.tinker.anno.AnnotationProcessor \n" +
-                    "-dontwarn ${AuxiliaryClassInjector.NOT_EXISTS_CLASSNAME} \n" +
                     "-keep @com.tencent.tinker.anno.DefaultLifeCycle public class *\n" +
                     "-keep public class * extends android.app.Application {\n" +
                     "    *;\n" +
@@ -54,6 +52,9 @@ public class TinkerProguardConfigTask extends DefaultTask {
                     "-keep public class com.tencent.tinker.loader.TinkerTestDexLoad {\n" +
                     "    *;\n" +
                     "}\n" +
+                    "-keep public class com.tencent.tinker.loader.TinkerTestAndroidNClassLoader {\n" +
+                    "    *;\n" +
+                    "}\n" +
                     "\n"
 
 
@@ -89,21 +90,6 @@ public class TinkerProguardConfigTask extends DefaultTask {
 
         fr.write(PROGUARD_CONFIG_SETTINGS)
 
-        // Write additional rules to keep <init> and <clinit>
-        if (project.tinkerPatch.dex.usePreGeneratedPatchDex) {
-            def additionalKeptRules =
-                            "-keep class ${AuxiliaryClassInjector.NOT_EXISTS_CLASSNAME} { \n" +
-                            '    *; \n' +
-                            '}\n' +
-                            '\n' +
-                            '-keepclassmembers class * { \n' +
-                            '    <init>(...); \n' +
-                            '    static void <clinit>(...); \n' +
-                            '}\n'
-            fr.write(additionalKeptRules)
-            fr.write('\n')
-        }
-
         fr.write("#your dex.loader patterns here\n")
         //they will removed when apply
         Iterable<String> loader = project.extensions.tinkerPatch.dex.loader
@@ -118,6 +104,7 @@ public class TinkerProguardConfigTask extends DefaultTask {
         // Add this proguard settings file to the list
         applicationVariant.getBuildType().buildType.proguardFiles(file)
         def files = applicationVariant.getBuildType().buildType.getProguardFiles()
+
         project.logger.error("now proguard files is ${files}")
     }
 }
\ No newline at end of file
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/transform/AuxiliaryInjectTransform.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/transform/AuxiliaryInjectTransform.groovy
deleted file mode 100644
index c1a929b0..00000000
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/transform/AuxiliaryInjectTransform.groovy
+++ /dev/null
@@ -1,344 +0,0 @@
-/*
- * Tencent is pleased to support the open source community by making Tinker available.
- *
- * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
- *
- * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- *
- * https://opensource.org/licenses/BSD-3-Clause
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is
- * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
- * either express or implied. See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.tencent.tinker.build.gradle.transform
-
-import com.android.build.api.transform.*
-import com.google.common.collect.ImmutableSet
-import com.google.common.io.Files
-import com.tencent.tinker.build.auxiliaryclass.AuxiliaryClassInjector
-import com.tencent.tinker.build.auxiliaryclass.AuxiliaryClassInjector.ProcessJarCallback
-import com.tencent.tinker.build.util.MD5
-import groovy.io.FileType
-import groovy.xml.Namespace
-import org.gradle.api.Project
-
-/**
- * Transform for calling AuxiliaryClassInjector.
- *
- * @author tangyinsheng
- */
-public class AuxiliaryInjectTransform extends Transform {
-    private static final String TRANSFORM_NAME = 'AuxiliaryInject'
-
-    private final Project project
-
-    private boolean isEnabled = false
-
-    def applicationVariants
-
-    /* ****** Variant related parameters start ****** */
-
-    boolean isInitialized = false
-    def manifestFile = null
-    def appClassName = ''
-    def appClassPathName = ''
-
-    /* ******  Variant related parameters end  ****** */
-
-    public AuxiliaryInjectTransform(Project project) {
-        this.project = project
-
-        project.afterEvaluate {
-            this.isEnabled = project.tinkerPatch.dex.usePreGeneratedPatchDex
-
-            this.applicationVariants = project.android.applicationVariants
-        }
-    }
-
-    @Override
-    String getName() {
-        return TRANSFORM_NAME
-    }
-
-    @Override
-    Set<QualifiedContent.ContentType> getInputTypes() {
-        return ImmutableSet.of(QualifiedContent.DefaultContentType.CLASSES)
-    }
-
-    @Override
-    Set<QualifiedContent.Scope> getScopes() {
-        return ImmutableSet.of(
-                QualifiedContent.Scope.PROJECT,
-                QualifiedContent.Scope.SUB_PROJECTS,
-                QualifiedContent.Scope.PROJECT_LOCAL_DEPS,
-                QualifiedContent.Scope.SUB_PROJECTS_LOCAL_DEPS,
-                QualifiedContent.Scope.EXTERNAL_LIBRARIES
-        )
-    }
-
-    @Override
-    boolean isIncremental() {
-        return true
-    }
-
-    private String getTaskNamePrefix(Transform transform) {
-        StringBuilder sb = new StringBuilder(100);
-        sb.append("transform");
-
-        Iterator<QualifiedContent.ContentType> iterator = transform.getInputTypes().iterator();
-        // there's always at least one
-        sb.append(iterator.next().name().toLowerCase(Locale.getDefault()).capitalize());
-        while (iterator.hasNext()) {
-            sb.append("And").append(
-                    iterator.next().name().toLowerCase(Locale.getDefault()).capitalize());
-        }
-
-        sb.append("With").append(transform.getName().capitalize()).append("For");
-
-        return sb.toString();
-    }
-
-    private String decapitalize(String src) {
-        char[] chars = src.toCharArray()
-        chars[0] += (char) 32
-        return new String(chars)
-    }
-
-    private void initVariantRelatedParamsIfNeeded(String variantName) {
-        if (this.isInitialized) {
-            return
-        }
-
-        // Get manifest file path.
-        this.applicationVariants.any { variant ->
-            if (variant.name.equals(variantName)) {
-                def variantOutput = variant.outputs.first()
-                this.manifestFile = variantOutput.processManifest.manifestOutputFile
-                return true  // break out.
-            }
-        }
-
-        // Get application classname from manifest file.
-        if (this.manifestFile != null) {
-            def parsedManifest = new XmlParser().parse(
-                    new InputStreamReader(new FileInputStream(this.manifestFile), "utf-8"))
-            def androidTag = new Namespace(
-                    'http://schemas.android.com/apk/res/android', 'android')
-            this.appClassName = parsedManifest.application[0].attribute(androidTag.name)
-
-            if (this.appClassName != null && this.appClassName.length() > 0) {
-                this.appClassPathName = this.appClassName.replace('.', '/') + '.class'
-            }
-        }
-
-        this.isInitialized = true
-    }
-
-    @Override
-    public void transform(TransformInvocation transformInvocation) throws TransformException, InterruptedException, IOException {
-        String variantName = decapitalize(transformInvocation.context.path.split(getTaskNamePrefix(this))[1])
-        initVariantRelatedParamsIfNeeded(variantName)
-
-        def dirInputs = new HashSet<>()
-        def jarInputs = new HashSet<>()
-
-        // Collecting inputs.
-        transformInvocation.inputs.each { input ->
-            input.directoryInputs.each { dirInput ->
-                dirInputs.add(dirInput)
-            }
-            input.jarInputs.each { jarInput ->
-                jarInputs.add(jarInput)
-            }
-        }
-
-        if (!this.isEnabled) {
-            printMsgLog("PreGeneratedPatchDex mode is disabled, skip transforming.")
-        }
-
-        if (!dirInputs.isEmpty() || !jarInputs.isEmpty()) {
-            File dirOutput = transformInvocation.outputProvider.getContentLocation(
-                    "classes", getOutputTypes(), getScopes(), Format.DIRECTORY)
-            if (!dirOutput.exists()) {
-                dirOutput.mkdirs()
-            }
-
-            if (!dirInputs.isEmpty()) {
-                dirInputs.each { dirInput ->
-                    if (transformInvocation.incremental) {
-                        dirInput.changedFiles.each { entry ->
-                            File fileInput = entry.getKey()
-                            File fileOutput = new File(fileInput.getAbsolutePath().replace(
-                                    dirInput.file.getAbsolutePath(), dirOutput.getAbsolutePath()))
-                            if (!fileOutput.exists()) {
-                                fileOutput.getParentFile().mkdirs()
-                            }
-                            final String relativeInputClassPath =
-                                    dirInput.file.toPath().relativize(fileInput.toPath())
-                                            .toString().replace('\\', '/')
-
-                            Status fileStatus = entry.getValue()
-                            switch(fileStatus) {
-                                case Status.ADDED:
-                                case Status.CHANGED:
-                                    if (fileInput.isDirectory()) {
-                                        return // continue.
-                                    }
-
-                                    // If disabled or not a class file, skip transforming them.
-                                    if (!this.isEnabled || !fileInput.getName().endsWith('.class')) {
-                                        Files.copy(fileInput, fileOutput)
-                                    } else {
-                                        // Skip application class.
-                                        if (relativeInputClassPath.equals(this.appClassPathName)) {
-                                            printWarnLog('Skipping Application class: %s',
-                                                    relativeInputClassPath)
-                                            Files.copy(fileInput, fileOutput)
-                                        } else {
-                                            printMsgLog('Processing %s file %s',
-                                                    fileStatus,
-                                                    relativeInputClassPath)
-                                            AuxiliaryClassInjector.processClass(fileInput, fileOutput)
-                                        }
-                                    }
-                                    break
-                                case Status.REMOVED:
-                                    // Print log if it's enabled only.
-                                    if (this.isEnabled) {
-                                        printMsgLog('Removing %s file %s from result.', fileStatus,
-                                                dirOutput.toPath().relativize(fileOutput.toPath()).toString())
-                                    }
-
-                                    if (fileOutput.exists()) {
-                                        if (fileOutput.isDirectory()) {
-                                            fileOutput.deleteDir()
-                                        } else {
-                                            fileOutput.delete()
-                                        }
-                                    }
-                                    break
-                            }
-                        }
-                    } else {
-                        if (dirOutput.exists()) {
-                            dirOutput.deleteDir()
-                        }
-
-                        dirInput.file.traverse(type: FileType.FILES) { fileInput ->
-                            File fileOutput = new File(fileInput.getAbsolutePath().replace(dirInput.file.getAbsolutePath(), dirOutput.getAbsolutePath()))
-                            if (!fileOutput.exists()) {
-                                fileOutput.getParentFile().mkdirs()
-                            }
-                            final String relativeInputClassPath =
-                                    dirInput.file.toPath().relativize(fileInput.toPath())
-                                            .toString().replace('\\', '/')
-
-                            // If disabled or not a class file, skip transforming them.
-                            if (!this.isEnabled || !fileInput.getName().endsWith('.class')) {
-                                Files.copy(fileInput, fileOutput)
-                            } else {
-                                // Skip application class.
-                                if (relativeInputClassPath.equals(this.appClassPathName)) {
-                                    printWarnLog('Skipping Application class: %s',
-                                            relativeInputClassPath)
-                                    Files.copy(fileInput, fileOutput)
-                                } else {
-                                    printMsgLog('Processing %s file %s',
-                                            Status.ADDED,
-                                            relativeInputClassPath)
-                                    AuxiliaryClassInjector.processClass(fileInput, fileOutput)
-                                }
-                            }
-                        }
-                    }
-                }
-            }
-
-            if (!jarInputs.isEmpty()) {
-                jarInputs.each { jarInput ->
-                    File jarInputFile = jarInput.file
-                    File jarOutputFile = transformInvocation.outputProvider.getContentLocation(
-                            getUniqueHashName(jarInputFile), getOutputTypes(), getScopes(), Format.JAR
-                    )
-                    if (!jarOutputFile.exists()) {
-                        jarOutputFile.getParentFile().mkdirs()
-                    }
-
-                    switch (jarInput.status) {
-                        case Status.NOTCHANGED:
-                            if (transformInvocation.incremental) {
-                                break
-                            }
-                        case Status.ADDED:
-                        case Status.CHANGED:
-                            // Print log if it's enabled only.
-                            if (this.isEnabled) {
-                                printMsgLog('Processing %s file %s',
-                                        transformInvocation.incremental ? jarInput.status : Status.ADDED,
-                                        jarInputFile)
-                            }
-
-                            AuxiliaryClassInjector.processJar(jarInputFile, jarOutputFile, new ProcessJarCallback() {
-                                @Override
-                                boolean onProcessClassEntry(String entryName) {
-                                    // If disabled or not a class file, skip transforming them.
-                                    if (!this.isEnabled || !entryName.endsWith('.class')) {
-                                        return false
-                                    } else {
-                                        // Skip application class.
-                                        if (entryName.equals(AuxiliaryInjectTransform.this.appClassPathName)) {
-                                            return false
-                                        } else {
-                                            return true;
-                                        }
-                                    }
-                                }
-                            })
-                            break
-                        case Status.REMOVED:
-                            // Print log if it's enabled only.
-                            if (this.isEnabled) {
-                                printMsgLog('Removing %s file %s from result.', fileStatus,
-                                        jarOutputFile)
-                            }
-
-                            if (jarOutputFile.exists()) {
-                                jarOutputFile.delete()
-                            }
-                            break
-                    }
-                }
-            }
-        }
-    }
-
-    private String getUniqueHashName(File fileInput) {
-        final String fileInputName = fileInput.getName()
-        if (fileInput.isDirectory()) {
-            return fileInputName
-        }
-        final String parentDirPath = fileInput.getParentFile().getAbsolutePath()
-        final String pathMD5 = MD5.getMessageDigest(parentDirPath.getBytes())
-        final int extSepPos = fileInputName.lastIndexOf('.')
-        final String fileInputNamePrefix =
-                (extSepPos >= 0 ? fileInputName.substring(0, extSepPos) : fileInputName)
-        return fileInputNamePrefix + '_' + pathMD5
-    }
-
-    private void printMsgLog(String fmt, Object... vals) {
-        final String title = TRANSFORM_NAME.capitalize()
-        this.project.logger.lifecycle("[{}] {}", title,
-                (vals == null || vals.length == 0 ? fmt : String.format(fmt, vals)))
-    }
-
-    private void printWarnLog(String fmt, Object... vals) {
-        final String title = TRANSFORM_NAME.capitalize()
-        this.project.logger.warn("[{}] {}", title,
-                (vals == null || vals.length == 0 ? fmt : String.format(fmt, vals)))
-    }
-}
-
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/transform/ImmutableDexTransform.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/transform/ImmutableDexTransform.groovy
new file mode 100644
index 00000000..f0611a2f
--- /dev/null
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/transform/ImmutableDexTransform.groovy
@@ -0,0 +1,519 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.build.gradle.transform
+
+import com.android.annotations.NonNull
+import com.android.build.api.transform.Format
+import com.android.build.api.transform.JarInput;
+import com.android.build.api.transform.QualifiedContent
+import com.android.build.api.transform.Transform;
+import com.android.build.api.transform.TransformException
+import com.android.build.api.transform.TransformInput
+import com.android.build.api.transform.TransformInvocation
+import com.android.build.api.transform.TransformOutputProvider
+import com.android.build.gradle.internal.pipeline.TransformTask
+import com.android.build.gradle.internal.transforms.DexTransform
+import com.google.common.base.Joiner
+import com.google.common.collect.Lists
+import com.tencent.tinker.android.dex.ClassDef
+import com.tencent.tinker.android.dex.Dex
+import com.tencent.tinker.build.gradle.TinkerPatchPlugin
+import com.tencent.tinker.build.immutable.ClassSimDef
+import com.tencent.tinker.build.immutable.DexRefData
+import com.tencent.tinker.build.util.FileOperation
+import com.tencent.tinker.build.util.Utils
+import org.gradle.api.Action
+import org.gradle.api.GradleException
+import org.gradle.api.Project
+import org.gradle.api.Task
+import org.gradle.api.execution.TaskExecutionGraph
+import org.gradle.api.execution.TaskExecutionGraphListener
+import org.gradle.api.logging.Logging
+import org.gradle.api.tasks.JavaExec
+
+import java.lang.reflect.Field;
+import java.util.zip.ZipEntry
+import java.util.zip.ZipFile
+import java.util.zip.ZipOutputStream
+
+/**
+ * Created by wangzhi on 16/11/24.
+ */
+public class ImmutableDexTransform extends Transform {
+
+    public static final String TASK_WORK_DIR = "keep_dex"
+
+    private static final Joiner PATH_JOINER = Joiner.on(File.separatorChar);
+
+    Project project
+
+    String oldApkPath
+
+    File classPreDir
+
+    File baseDexDir
+
+    File dxOutDir
+
+    File mainDexListFile
+
+    String varName
+
+    String varDirName
+
+    def variant
+
+    DexTransform dexTransform
+
+
+    ImmutableDexTransform(Project project, def variant, DexTransform dexTransform) {
+        this.dexTransform = dexTransform
+        this.project = project
+        this.variant = variant
+        this.varName = variant.name.capitalize()
+        this.varDirName = variant.getDirName()
+        this.oldApkPath = project.tinkerPatch.oldApk
+        this.mainDexListFile = dexTransform.mainDexListFile
+    }
+
+    public void initFileEnv(TransformOutputProvider outputProvider) {
+        classPreDir = getDirInWorkDir("class_pre")
+        baseDexDir = getDirInWorkDir("base_dex")
+        dxOutDir = outputProvider.getContentLocation("main",
+                getOutputTypes(), getScopes(),
+                Format.DIRECTORY);
+
+        classPreDir.mkdirs()
+        baseDexDir.mkdirs()
+        dxOutDir.mkdirs()
+
+        FileOperation.cleanDir(classPreDir)
+        FileOperation.cleanDir(baseDexDir)
+        FileOperation.cleanDir(dxOutDir)
+    }
+
+    private File getDirInWorkDir(String name) {
+        return new File(PATH_JOINER.join(project.projectDir,
+                TinkerPatchPlugin.TINKER_INTERMEDIATES,
+                TASK_WORK_DIR,
+                name,
+                varDirName)
+        )
+    }
+
+
+    @NonNull
+    @Override
+    public Set<QualifiedContent.ContentType> getOutputTypes() {
+        return dexTransform.getOutputTypes();
+    }
+
+    @NonNull
+    @Override
+    public Collection<File> getSecondaryFileInputs() {
+        return dexTransform.getSecondaryFileInputs()
+    }
+
+    @NonNull
+    @Override
+    public Collection<File> getSecondaryDirectoryOutputs() {
+        return dexTransform.getSecondaryDirectoryOutputs()
+    }
+
+    @NonNull
+    @Override
+    public Map<String, Object> getParameterInputs() {
+       return dexTransform.getParameterInputs()
+    }
+
+    @Override
+    String getName() {
+        return dexTransform.getName()
+    }
+
+    @Override
+    Set<QualifiedContent.ContentType> getInputTypes() {
+        return dexTransform.getInputTypes()
+    }
+
+    @Override
+    Set<QualifiedContent.Scope> getScopes() {
+        return dexTransform.getScopes()
+    }
+
+    @Override
+    boolean isIncremental() {
+        return dexTransform.isIncremental()
+    }
+
+    @Override
+    void transform(TransformInvocation transformInvocation) throws TransformException, IOException, InterruptedException {
+
+        // because multi dex is enable,we only process jar file.
+        List<JarInput> jarInputs = Lists.newArrayList();
+        for (TransformInput input : transformInvocation.getInputs()) {
+            jarInputs.addAll(input.getJarInputs());
+        }
+        //because the multi-dex is turned on,so the jarInput.size()==1 in theory.
+        if (jarInputs.size() != 1) {
+            project.logger.error("jar input size is ${jarInputs.size()}, expected is 1. we will skip immutable dex!")
+            dexTransform.transform(transformInvocation)
+            return
+        }
+
+        //init
+        initFileEnv(transformInvocation.getOutputProvider());
+        //get all old dex
+        ArrayList<File> oldDexList = new ArrayList<>()
+        traversal(new ZipFile(oldApkPath), { ZipEntry zipEntry, byte[] bytes ->
+            if (zipEntry.name.startsWith("classes") && zipEntry.name.endsWith(".dex")) {
+                project.logger.info("find dex: ${zipEntry.name} in old apk. ")
+                File classDxFile = new File(baseDexDir, zipEntry.name)
+                classDxFile.withDataOutputStream { output ->
+                    output.write(bytes, 0, bytes.length)
+                    output.close()
+                }
+                oldDexList.add(classDxFile)
+            }
+        })
+
+        //hashmap:classPath <==> dexName
+        HashMap<String, String> pathDexMap = new HashMap<>()
+        project.logger.info("old dex list is : ${oldDexList}.")
+
+        //hashmap:classPath<=>dexName
+        oldDexList.each { dexFile ->
+            Dex dex = new Dex(dexFile)
+            dex.classDefs().each { ClassDef classDef ->
+                String classPath = dex.typeNames().get(classDef.typeIndex)
+                if (pathDexMap.get(classPath)) {
+                    throw new GradleException("double class: ${classPath} in dex: ${dexFile.name} ")
+                }
+                pathDexMap.put(classPath, dexFile.name - ".dex")
+            }
+        }
+        //the dex start index for orphan class
+        int newDexIndex = oldDexList.size()
+        //a hashset for maindexlist
+        HashSet<String> mainDexSets = initMainDexSet(mainDexListFile)
+        project.logger.info("mainDexSets is ${mainDexSets}.")
+        //zip file name <==> ZipOutputStream
+        HashMap<String, ZipOutputStream> osMap = new HashMap<>()
+        //zip file name <==> mtd count and filed count in the zip
+        HashMap<String, DexRefData> methodAndFieldsNum = new HashMap<>()
+        //orphan class's entry <==> orphan class's bytes
+        HashMap<ZipEntry, ByteArrayOutputStream> orphanMap = new HashMap()
+
+        //all class  in allClass.jar
+        HashSet<String> allClassSet = new HashSet<>()
+        //process all-classes.jar
+        processJar(jarInputs.get(0).file, allClassSet, pathDexMap, mainDexSets, methodAndFieldsNum, osMap, orphanMap)
+
+        Iterator<Map.Entry<ZipEntry, ByteArrayOutputStream>> iterator = orphanMap.entrySet().iterator()
+        Map.Entry<ZipEntry, ByteArrayOutputStream> leaveEntry = null
+        while (iterator.hasNext()) {
+            boolean writeResult = true
+            while (writeResult && iterator.hasNext()) {
+                if (leaveEntry != null) {
+                    String newDexName = dexIndexToName(newDexIndex, "")
+                    project.logger.info("write level orphan class: ${leaveEntry.key.name} to zip: ${newDexName}")
+                    writeResult = writeClassToZip(methodAndFieldsNum, osMap, newDexName, leaveEntry.value.toByteArray(), leaveEntry.key)
+                    if (!writeResult) {
+                        throw new GradleException("add one class to a new zip failed!\n" +
+                                "\t class:" + leaveEntry.key.name + "  zip: " + newDexName)
+                    }
+                }
+                Map.Entry<ZipEntry, ByteArrayOutputStream> entry = iterator.next()
+                leaveEntry = entry
+                String newDexName = dexIndexToName(newDexIndex, "")
+                project.logger.info("write orphan class: ${entry.key.name} to zip: ${newDexName}")
+                writeResult = writeClassToZip(methodAndFieldsNum, osMap, newDexName, entry.value.toByteArray(), entry.key)
+                if (writeResult) {
+                    leaveEntry = null
+                }
+            }
+            newDexIndex++
+        }
+
+        osMap.each { key, value ->
+            value.close()
+        }
+
+        //a list for all dex's path,use for checkClassConsistence mtd
+        ArrayList<String> dexPathList = new ArrayList<>()
+        classPreDir.eachFile { classZip ->
+            String classIndexName = classZip.name - ".jar"
+            String dexPath = "${dxOutDir.absolutePath}/${classIndexName}.dex"
+            dexPathList.add(dexPath)
+            doDex(classIndexName, classZip, project.android.getDexOptions())
+        }
+
+        checkClassConsistence(dexPathList, allClassSet)
+
+    }
+
+    private void processJar(File jarFile,
+                            HashSet<String> allClassSet, HashMap<String, String> pathDexMap, HashSet<String> mainDexSets, HashMap<String, DexRefData> methodAndFieldsNum, HashMap<String, ZipOutputStream> osMap, HashMap<ZipEntry, ByteArrayOutputStream> orphanMap) {
+
+
+        ZipFile zipFile = new ZipFile(jarFile)
+        //process class in maindexlist in first
+        traversal(zipFile, { ZipEntry zipEntry, byte[] bytes ->
+            if (zipEntry.name.endsWith(".class")) {
+                if (mainDexSets.contains(zipEntry.name)) {
+                    String classPath = rePathToClassPath(zipEntry.name)
+                    allClassSet.add(classPath)
+                    project.logger.info("process main dex list's class " + classPath)
+                    if (!writeClassToZip(methodAndFieldsNum, osMap, "classes", bytes, zipEntry)) {
+                        throw new GradleException("main dex is exceed the limit! reduce the class number on your main dex keep please.")
+                    }
+                }
+            }
+        })
+
+        traversal(zipFile, {
+            ZipEntry zipEntry,
+            byte[] bytes ->
+                if (zipEntry.name.endsWith(".class")) {
+                    String classPath = rePathToClassPath(zipEntry.name)
+                    if (!Utils.isBlank(classPath) && !allClassSet.contains(classPath)) {
+                        allClassSet.add(classPath)
+                        //get the old dex name which class be located
+                        String belongDex = belongTo(pathDexMap, classPath)
+                        //the class is new or method|fields exceeds limit
+                        if (Utils.isBlank(belongDex) ||
+                                !writeClassToZip(methodAndFieldsNum, osMap, belongDex, bytes, zipEntry)) {
+                            if (Utils.isBlank(belongDex)) {
+                                project.logger.warn("find new class: " + classPath)
+                            }
+                            saveOrphan(orphanMap, zipEntry, bytes)
+                        }
+                    } else {
+                        if (Utils.isBlank(classPath)) {
+                            project.logger.error("illegal zip entry: " + zipEntry.name)
+                        }
+                    }
+
+                }
+        })
+    }
+
+    public HashSet<String> initMainDexSet(File mainDexList) {
+        HashSet<String> mainDexSets = new HashSet<>()
+        BufferedReader reader = mainDexList.newReader()
+        List<String> lines = reader.readLines()
+        lines.each {
+            mainDexSets.add(it)
+        }
+        return mainDexSets
+    }
+
+    private String rePathToClassPath(String rePath) {
+        int eIndex = rePath.lastIndexOf(".class")
+        if (eIndex >= 0) {
+            return "L${rePath.substring(0, eIndex)};"
+        } else {
+            return ""
+        }
+    }
+
+
+    private void doDex(String classIndexName, File classZip, def dexOptions) {
+
+        def dexJar = "${project.android.getSdkDirectory()}/build-tools/${project.android.buildToolsVersion}/lib/dx.jar"
+        def task = project.tasks.create("dx" + classIndexName + varName, JavaExec.class, new Action<JavaExec>() {
+            @Override
+            void execute(JavaExec javaExec) {
+                ArrayList<String> execArgs = new ArrayList()
+                execArgs.add("--dex")
+                if (dexOptions.getJumboMode()) {
+                    execArgs.add("--force-jumbo");
+                }
+                if (dexOptions.getIncremental()) {
+                    execArgs.add("--incremental");
+                    execArgs.add("--no-strict");
+                }
+                execArgs.add("--output=${dxOutDir.absolutePath}/${classIndexName}.dex".toString())
+                execArgs.add(classZip.absolutePath)
+                project.logger.info(execArgs.toString())
+                javaExec.setClasspath(project.files(dexJar))
+                javaExec.setMain("com.android.dx.command.Main")
+                javaExec.setArgs(execArgs)
+            }
+        })
+        task.execute()
+    }
+
+    public static void inject(Project project, def variant) {
+        project.logger.info("prepare inject dex transform ")
+        if (!variant.apkVariantData.variantConfiguration.isMultiDexEnabled()) {
+            project.logger.warn("multidex is diable. we will not replace the dex transform.")
+            return
+        }
+        if (!FileOperation.isLegalFile(project.tinkerPatch.oldApk)) {
+            project.logger.warn("oldApk is illegal. we will not replace the dex transform.")
+            return
+        }
+
+        project.getGradle().getTaskGraph().addTaskExecutionGraphListener(new TaskExecutionGraphListener() {
+            @Override
+            public void graphPopulated(TaskExecutionGraph taskGraph) {
+                for (Task task : taskGraph.getAllTasks()) {
+                    if (task instanceof TransformTask && task.name.toLowerCase().contains(variant.name.toLowerCase())) {
+
+                        if (((TransformTask) task).getTransform() instanceof DexTransform && !(((TransformTask) task).getTransform() instanceof ImmutableDexTransform)) {
+                            project.logger.warn("find dex transform. transform class: " + task.transform.getClass() + " . task name: " + task.name)
+
+                            DexTransform dexTransform = task.transform
+                            ImmutableDexTransform hookDexTransform = new ImmutableDexTransform(project,
+                                    variant, dexTransform)
+                            project.logger.info("variant name: " + variant.name)
+
+                            Field field = TransformTask.class.getDeclaredField("transform")
+                            field.setAccessible(true)
+                            field.set(task, hookDexTransform)
+                            project.logger.warn("transform class after hook: " + task.transform.getClass())
+                            break;
+                        }
+                    }
+                }
+            }
+        });
+
+    }
+
+
+    void checkClassConsistence(ArrayList<String> dexPathList, HashSet<String> allClassSet) {
+        project.logger.info("start check class's consistence ..")
+        if (dexPathList == null || dexPathList.size() == 0) {
+            throw new GradleException("immutable dex list is null! ")
+        }
+        project.logger.info("check dex list: " + dexPathList)
+        HashSet<String> dexClassSet = new HashSet<>()
+        int classSize = 0
+        dexPathList.each { path ->
+            File dexFile = new File(path)
+            if (dexFile.isFile()) {
+                Dex dex = new Dex(dexFile)
+                classSize += dex.classDefs().size()
+                for (ClassDef item : dex.classDefs()) {
+                    int index = item.typeIndex
+                    dexClassSet.add(dex.typeNames().get(index))
+                }
+            } else {
+                throw new GradleException("dex: ${dexFile} is illegal!")
+            }
+        }
+
+        HashSet<String> hashSet1 = new HashSet<>(dexClassSet)
+        HashSet<String> hashSet2 = new HashSet<>(allClassSet)
+
+        hashSet1.removeAll(allClassSet)
+        hashSet2.removeAll(dexClassSet)
+
+        if (hashSet1.size() != 0 || hashSet2.size() != 0) {
+            throw new GradleException("class is inconsistent! " + "\n\t"
+                    + "allClassSet size is " + allClassSet.size()
+                    + ",dexClassSet size is " + dexClassSet.size() + "\n"
+                    + "allClassSet has extra class: " + hashSet2 + ",\n"
+                    + "dexClassSet has extra class: " + hashSet1 + ".\n"
+            )
+        } else {
+            project.logger.info("check class consistence successful! ")
+        }
+
+    }
+
+    boolean writeClassToZip(HashMap<String, DexRefData> methodAndFieldsNum,
+                            HashMap<String, ZipOutputStream> osMap,
+                            String belongDex,
+                            byte[] bytes,
+                            ZipEntry zipEntry) {
+        File jarFile = new File(classPreDir, belongDex + ".jar")
+        DexRefData mfData = methodAndFieldsNum.get(jarFile.name)
+        if (mfData == null) {
+            mfData = new DexRefData()
+            methodAndFieldsNum.put(jarFile.name, mfData)
+        }
+        ClassSimDef cf = new ClassSimDef(bytes, mfData.refFields, mfData.refMtds)
+        ZipOutputStream zos = osMap.get(belongDex)
+        if (zos == null) {
+            project.logger.info("jarFile is  ${jarFile}.")
+            zos = new ZipOutputStream(new FileOutputStream(jarFile))
+            osMap.put(belongDex, zos)
+        }
+        if (!writeClassToZipNoCheck(mfData, cf, zos, zipEntry, bytes)) {
+            project.logger.error("except limit! \n \tfind class ${zipEntry.name} method num: ${mfData.methodNum},field num: ${mfData.fieldNum},belong dex: ${belongDex} ")
+            return false
+        } else {
+            return true
+        }
+    }
+
+    boolean writeClassToZipNoCheck(DexRefData mfData, ClassSimDef cf, ZipOutputStream zos, ZipEntry zipEntry, byte[] bytes) {
+        /**
+         * In ClassSimDef, only the fields  which  methods referenced or in the class definition are scanned.
+         * But in fact, some fields may be referenced in annotation. So the statistics in ClassSimDef is not complete.
+         * The threshold is adjusted lower in order to avoid the troubles to calculate the fields referred by annotations.
+         */
+        if (mfData.methodNum + cf.methodCount >= 65536 || mfData.fieldNum + cf.fieldCount >= 64536) {
+            return false
+        } else {
+            mfData.methodNum += cf.methodCount
+            mfData.fieldNum += cf.fieldCount
+            zos.putNextEntry(zipEntry)
+            zos.write(bytes)
+            zos.closeEntry()
+            return true
+        }
+    }
+
+    void saveOrphan(HashMap<ZipEntry, ByteArrayOutputStream> orphanMap, ZipEntry zipEntry, byte[] bytes) {
+        ByteArrayOutputStream bos = new ByteArrayOutputStream(bytes.length)
+        bos.write(bytes, 0, bytes.length)
+        bos.flush()
+        orphanMap.put(zipEntry, bos)
+    }
+
+    public static String getNextClassName(int index) {
+        return "classes${index + 1}.dex"
+    }
+
+    public String dexIndexToName(int index, String suffix) {
+        return "classes" + (index == 1 ? "" : index) + suffix
+    }
+
+    public String belongTo(HashMap<String, String> pathDexMap, String classPath) {
+        return pathDexMap.get(classPath)
+    }
+
+    public static void traversal(ZipFile zipFile, Closure callback) {
+        try {
+            Enumeration<? extends ZipEntry> enumeration = zipFile.entries();
+            while (enumeration.hasMoreElements()) {
+                ZipEntry entry = enumeration.nextElement();
+                callback.call(entry, zipFile.getInputStream(entry).bytes)
+            }
+        } catch (IOException e) {
+            e.printStackTrace();
+            Utils.closeQuietly(zipFile);
+        }
+    }
+}
+
+
+
diff --git a/tinker-build/tinker-patch-lib/build.gradle b/tinker-build/tinker-patch-lib/build.gradle
index ddb4e9b4..04389db0 100644
--- a/tinker-build/tinker-patch-lib/build.gradle
+++ b/tinker-build/tinker-patch-lib/build.gradle
@@ -9,10 +9,10 @@ group rootProject.ext.GROUP
 dependencies {
     compile fileTree(dir: 'libs', include: ['*.jar'])
     compile project(':tinker-commons')
-    compile group: 'com.tencent.mm', name: 'apk-parser-lib', version: '1.0.0'
+    compile group: 'com.tencent.mm', name: 'apk-parser-lib', version: '1.2.0'
     compile group: 'com.google.guava', name: 'guava', version: '11.0.2'
+    compile group: 'org.ow2.asm', name: 'asm', version: '5.0.3'
     compile group: 'org.smali', name: 'dexlib2', version: '2.1.3'
-    compile group: 'org.ow2.asm', name: 'asm-all', version: '5.0.4'
 }
 
 sourceSets {
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptResourceCollector.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptResourceCollector.java
index 2682965c..f4735892 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptResourceCollector.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptResourceCollector.java
@@ -70,7 +70,7 @@ public AaptResourceCollector(Map<RType, Set<RDotTxtEntry>> rTypeResourceMap) {
                     originalResourceMap.put(rDotTxtEntry, rDotTxtEntry);
                     ResourceIdEnumerator resourceIdEnumerator = null;
                     if (!rDotTxtEntry.idType.equals(IdType.INT_ARRAY)) {
-                        int resourceId = Integer.decode(rDotTxtEntry.idValue).intValue();
+                        int resourceId = Integer.decode(rDotTxtEntry.idValue.trim()).intValue();
                         int typeId = ((resourceId & 0x00FF0000) / 0x00010000);
                         if (typeId >= currentTypeId) {
                             currentTypeId = typeId + 1;
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptUtil.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptUtil.java
index 8e058f76..6dcc2646 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptUtil.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptUtil.java
@@ -105,8 +105,8 @@ public static void processXmlFilesForIds(String resourceDirectory, List<RDotTxtE
                 File xmlFile = new File(xmlFullFilename);
                 String parentFullFilename = xmlFile.getParent();
                 File parentFile = new File(parentFullFilename);
-                if (isAValuesDirectory(parentFile.getName())) {
-                    // Ignore files under values* directories.
+                if (isAValuesDirectory(parentFile.getName()) || parentFile.getName().startsWith("raw")) {
+                    // Ignore files under values* directories and raw*.
                     continue;
                 }
                 processXmlFile(xmlFullFilename, references, resourceCollector);
@@ -304,7 +304,7 @@ private static void addToResourceCollector(AaptResourceCollector resourceCollect
                 resourceCollector.addResource(RType.STYLEABLE, IdType.INT, String.format("%s_%s", resourceName, attrName), Integer.toString(count++));
 
                 if (!rawAttrName.startsWith("android:")) {
-                    resourceCollector.addIntResourceIfNotPresent(RType.ATTR, attrName);
+                    resourceCollector.addIntResourceIfNotPresent(RType.ATTR, rawAttrName);
                     resourceCollector.addRTypeResourceName(RType.ATTR, rawAttrName, nodeToString(attrNode, true), resourceDirectory);
                 }
             }
@@ -353,7 +353,7 @@ private static String extractNameAttribute(Node node) {
                     if (rDotTxtEntry.idType.equals(IdType.INT)) {
                         aaptResourceCollector.addIntResourceIfNotPresent(rType, rDotTxtEntry.name);
                     } else if (rDotTxtEntry.idType.equals(IdType.INT_ARRAY)) {
-                        aaptResourceCollector.addResource(rType, rDotTxtEntry.idType, rDotTxtEntry.name, rDotTxtEntry.idValue);
+                        aaptResourceCollector.addResource(rType, rDotTxtEntry.idType, rDotTxtEntry.name, rDotTxtEntry.idValue.trim());
                     }
                 }
             }
@@ -388,7 +388,7 @@ public static void writeRJava(String outputDirectory, String packageName, Map<RT
                 for (com.tencent.tinker.build.aapt.RDotTxtEntry rDotTxtEntry : rTypeResourceMap.get(rType)) {
                     // Write out the resource.
                     // Write as an int.
-                    writer.format("    public static%s%s %s=%s;\n", isFinal ? " final " : " ", rDotTxtEntry.idType, rDotTxtEntry.name, rDotTxtEntry.idValue);
+                    writer.format("    public static%s%s %s=%s;\n", isFinal ? " final " : " ", rDotTxtEntry.idType, rDotTxtEntry.name, rDotTxtEntry.idValue.trim());
                 }
                 writer.println("  }\n");
             }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/PatchUtil.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/PatchUtil.java
index af195a50..9cd3e3af 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/PatchUtil.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/PatchUtil.java
@@ -20,8 +20,8 @@
 import com.tencent.tinker.build.aapt.RDotTxtEntry.RType;
 
 import java.io.BufferedReader;
+import java.io.File;
 import java.io.FileInputStream;
-import java.io.FileOutputStream;
 import java.io.InputStreamReader;
 import java.io.PrintWriter;
 import java.util.Arrays;
@@ -102,8 +102,8 @@ public static void generatePublicResourceXml(AaptResourceCollector aaptResourceC
         try {
             FileUtil.createFile(outputIdsXmlFullFilename);
             FileUtil.createFile(outputPublicXmlFullFilename);
-            idsWriter = new PrintWriter(new FileOutputStream(outputIdsXmlFullFilename));
-            publicWriter = new PrintWriter(new FileOutputStream(outputPublicXmlFullFilename));
+            idsWriter = new PrintWriter(new File(outputIdsXmlFullFilename), "UTF-8");
+            publicWriter = new PrintWriter(new File(outputPublicXmlFullFilename), "UTF-8");
             idsWriter.println("<?xml version=\"1.0\" encoding=\"utf-8\"?>");
             publicWriter.println("<?xml version=\"1.0\" encoding=\"utf-8\"?>");
             idsWriter.println("<resources>");
@@ -122,7 +122,7 @@ public static void generatePublicResourceXml(AaptResourceCollector aaptResourceC
 //                                System.err.println("Blank?" + rDotTxtEntry.name);
                                 rawName = rDotTxtEntry.name;
                             }
-                            publicWriter.println("<public type=\"" + rType + "\" name=\"" + rawName + "\" id=\"" + rDotTxtEntry.idValue + "\" />");
+                            publicWriter.println("<public type=\"" + rType + "\" name=\"" + rawName + "\" id=\"" + rDotTxtEntry.idValue.trim() + "\" />");
 //                        } else {
 //                            publicWriter.println("<public type=\"" + rType + "\" name=\"" + rDotTxtEntry.name + "\" id=\"" + rDotTxtEntry.idValue + "\" />");
 //                        }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/RDotTxtEntry.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/RDotTxtEntry.java
index 11e43aa8..e78e01b7 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/RDotTxtEntry.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/RDotTxtEntry.java
@@ -110,7 +110,7 @@ public int hashCode() {
 
     @Override
     public String toString() {
-        return Objects.toStringHelper(RDotTxtEntry.class).add("idType", idType).add("type", type).add("name", name).add("idValue", idValue).toString();
+        return Objects.toStringHelper(RDotTxtEntry.class).add("idType", idType).add("type", type).add("name", name).add("idValue", idValue.trim()).toString();
     }
 
     // Taken from http://developer.android.com/reference/android/R.html
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/apkparser/AndroidParser.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/apkparser/AndroidParser.java
index b417847d..cea56771 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/apkparser/AndroidParser.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/apkparser/AndroidParser.java
@@ -18,13 +18,6 @@
 
 import com.tencent.tinker.build.patch.Configuration;
 
-import net.dongliu.apk.parser.ApkParser;
-import net.dongliu.apk.parser.bean.ApkMeta;
-import net.dongliu.apk.parser.exception.ParserException;
-import net.dongliu.apk.parser.struct.StringPool;
-import net.dongliu.apk.parser.struct.resource.ResourceTable;
-import net.dongliu.apk.parser.utils.ParseUtils;
-
 import org.w3c.dom.Document;
 import org.w3c.dom.NamedNodeMap;
 import org.w3c.dom.Node;
@@ -43,6 +36,13 @@
 import javax.xml.parsers.DocumentBuilder;
 import javax.xml.parsers.DocumentBuilderFactory;
 
+import tinker.net.dongliu.apk.parser.ApkParser;
+import tinker.net.dongliu.apk.parser.bean.ApkMeta;
+import tinker.net.dongliu.apk.parser.exception.ParserException;
+import tinker.net.dongliu.apk.parser.struct.StringPool;
+import tinker.net.dongliu.apk.parser.struct.resource.ResourceTable;
+import tinker.net.dongliu.apk.parser.utils.ParseUtils;
+
 /**
  * Created by zhangshaowen on 16/5/5.
  */
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/auxiliaryclass/AuxiliaryClassInjectAdapter.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/auxiliaryclass/AuxiliaryClassInjectAdapter.java
deleted file mode 100644
index 6cd7200d..00000000
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/auxiliaryclass/AuxiliaryClassInjectAdapter.java
+++ /dev/null
@@ -1,150 +0,0 @@
-/*
- * Tencent is pleased to support the open source community by making Tinker available.
- *
- * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
- *
- * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- *
- * https://opensource.org/licenses/BSD-3-Clause
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is
- * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
- * either express or implied. See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.tencent.tinker.build.auxiliaryclass;
-
-import org.objectweb.asm.ClassVisitor;
-import org.objectweb.asm.ClassWriter;
-import org.objectweb.asm.Label;
-import org.objectweb.asm.MethodVisitor;
-import org.objectweb.asm.Opcodes;
-import org.objectweb.asm.Type;
-
-/**
- * Created by tangyinsheng on 2016/10/10.
- */
-
-public final class AuxiliaryClassInjectAdapter extends ClassVisitor {
-    private final String auxiliaryClassDesc;
-    private boolean isClInitExists;
-    private boolean isInitExists;
-    private boolean isTargetClass;
-    private boolean isInjected;
-
-    public AuxiliaryClassInjectAdapter(String auxiliaryClassName, ClassWriter cw) {
-        super(Opcodes.ASM5, cw);
-        this.auxiliaryClassDesc = fastClassNameToDesc(auxiliaryClassName);
-    }
-
-    private String fastClassNameToDesc(String className) {
-        if (className.startsWith("L") && className.endsWith(";")) {
-            return className;
-        }
-        if ("boolean".equals(className)) {
-            return "Z";
-        } else
-        if ("byte".equals(className)) {
-            return "B";
-        } else
-        if ("char".equals(className)) {
-            return "C";
-        } else
-        if ("short".equals(className)) {
-            return "S";
-        } else
-        if ("int".equals(className)) {
-            return "I";
-        } else
-        if ("long".equals(className)) {
-            return "J";
-        } else
-        if ("float".equals(className)) {
-            return "F";
-        } else
-        if ("double".equals(className)) {
-            return "D";
-        } else {
-            className = className.replace('.', '/');
-            return "L" + className + ";";
-        }
-    }
-
-    @Override
-    public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {
-        super.visit(version, access, name, signature, superName, interfaces);
-        this.isClInitExists = false;
-        this.isInitExists = false;
-        this.isTargetClass = ((access & Opcodes.ACC_INTERFACE) == 0);
-        this.isInjected = false;
-    }
-
-    @Override
-    public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {
-        MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);
-        if (mv != null && this.isTargetClass && !this.isInjected) {
-            if ("<clinit>".equals(name)) {
-                this.isClInitExists = true;
-                this.isInjected = true;
-                mv = new InjectImplMethodVisitor(mv);
-            } else
-            if ("<init>".equals(name)) {
-                this.isInitExists = true;
-                this.isInjected = true;
-                mv = new InjectImplMethodVisitor(mv);
-            }
-        }
-        return mv;
-    }
-
-    @Override
-    public void visitEnd() {
-        // If method <clinit> and <init> are not found, we should generate a <clinit>.
-        if (!this.isClInitExists && !this.isInitExists) {
-            MethodVisitor mv = super.visitMethod(Opcodes.ACC_STATIC, "<clinit>", "()V", null, null);
-            mv.visitCode();
-            mv.visitMethodInsn(Opcodes.INVOKESTATIC, "java/lang/System", "lineSeparator", "()Ljava/lang/String;", false);
-            Label lblSkipInvalidInsn = new Label();
-            mv.visitJumpInsn(Opcodes.IFNONNULL, lblSkipInvalidInsn);
-            mv.visitLdcInsn(Type.getType(this.auxiliaryClassDesc));
-            mv.visitVarInsn(Opcodes.ASTORE, 0);
-            mv.visitLabel(lblSkipInvalidInsn);
-            mv.visitInsn(Opcodes.RETURN);
-            mv.visitMaxs(1, 1);
-            mv.visitEnd();
-        }
-        super.visitEnd();
-    }
-
-    private class InjectImplMethodVisitor extends MethodVisitor {
-        InjectImplMethodVisitor(MethodVisitor mv) {
-            super(Opcodes.ASM5, mv);
-        }
-
-        @Override
-        public void visitInsn(int opcode) {
-            if (opcode == Opcodes.RETURN) {
-                super.visitMethodInsn(Opcodes.INVOKESTATIC, "java/lang/System", "lineSeparator", "()Ljava/lang/String;", false);
-                Label lblSkipInvalidInsn = new Label();
-                super.visitJumpInsn(Opcodes.IFNONNULL, lblSkipInvalidInsn);
-                super.visitLdcInsn(Type.getType(AuxiliaryClassInjectAdapter.this.auxiliaryClassDesc));
-                super.visitVarInsn(Opcodes.ASTORE, 0);
-                super.visitLabel(lblSkipInvalidInsn);
-            }
-            super.visitInsn(opcode);
-        }
-
-        @Override
-        public void visitMaxs(int maxStack, int maxLocals) {
-            if (maxStack < 1) {
-                maxStack = 1;
-            }
-            if (maxLocals < 1) {
-                maxLocals = 1;
-            }
-            super.visitMaxs(maxStack, maxLocals);
-        }
-    }
-}
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/auxiliaryclass/AuxiliaryClassInjector.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/auxiliaryclass/AuxiliaryClassInjector.java
deleted file mode 100644
index a74cfea6..00000000
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/auxiliaryclass/AuxiliaryClassInjector.java
+++ /dev/null
@@ -1,153 +0,0 @@
-/*
- * Tencent is pleased to support the open source community by making Tinker available.
- *
- * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
- *
- * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- *
- * https://opensource.org/licenses/BSD-3-Clause
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is
- * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
- * either express or implied. See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.tencent.tinker.build.auxiliaryclass;
-
-import com.tencent.tinker.commons.ziputil.Streams;
-
-import org.objectweb.asm.ClassReader;
-import org.objectweb.asm.ClassWriter;
-
-import java.io.BufferedInputStream;
-import java.io.BufferedOutputStream;
-import java.io.Closeable;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.nio.charset.Charset;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.zip.ZipEntry;
-import java.util.zip.ZipInputStream;
-import java.util.zip.ZipOutputStream;
-
-/**
- * Created by tangyinsheng on 2016/10/9.
- */
-
-public final class AuxiliaryClassInjector {
-    // The descriptor of this class is so strange so that we hope no one
-    // would happen to create a class named the same as it.
-    public static final String NOT_EXISTS_CLASSNAME
-            = "tInKEr.pReVEnT.PrEVErIfIEd.STuBCLaSS";
-
-    public interface ProcessJarCallback {
-        boolean onProcessClassEntry(String entryName);
-    }
-
-    public static void processClass(File classIn, File classOut) throws IOException {
-        InputStream is = null;
-        OutputStream os = null;
-        try {
-            is = new BufferedInputStream(new FileInputStream(classIn));
-            os = new BufferedOutputStream(new FileOutputStream(classOut));
-            processClass(is, os);
-        } finally {
-            closeQuietly(os);
-            closeQuietly(is);
-        }
-    }
-
-    public static void processJar(File jarIn, File jarOut, ProcessJarCallback cb) throws IOException {
-        try {
-            processJarHelper(jarIn, jarOut, cb, Charset.forName("UTF-8"), Charset.forName("UTF-8"));
-        } catch (IllegalArgumentException e) {
-            if ("MALFORMED".equals(e.getMessage())) {
-                processJarHelper(jarIn, jarOut, cb, Charset.forName("GBK"), Charset.forName("UTF-8"));
-            } else {
-                throw e;
-            }
-        }
-    }
-
-    @SuppressWarnings("NewApi")
-    private static void processJarHelper(File jarIn, File jarOut, ProcessJarCallback cb, Charset charsetIn, Charset charsetOut) throws IOException {
-        ZipInputStream zis = null;
-        ZipOutputStream zos = null;
-        try {
-            zis = new ZipInputStream(new BufferedInputStream(new FileInputStream(jarIn)), charsetIn);
-            zos = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(jarOut)), charsetOut);
-            ZipEntry entryIn = null;
-            Map<String, Integer> processedEntryNamesMap = new HashMap<>();
-            while ((entryIn = zis.getNextEntry()) != null) {
-                final String entryName = entryIn.getName();
-                ZipEntry entryOut = new ZipEntry(entryIn);
-                entryOut.setCompressedSize(-1);
-                if (!processedEntryNamesMap.containsKey(entryName)) {
-                    zos.putNextEntry(entryOut);
-                    if (!entryIn.isDirectory()) {
-                        if (entryName.endsWith(".class")) {
-                            if (cb == null || cb.onProcessClassEntry(entryName)) {
-                                processClass(zis, zos);
-                            } else {
-                                Streams.copy(zis, zos);
-                            }
-                        } else {
-                            Streams.copy(zis, zos);
-                        }
-                    }
-                    zos.closeEntry();
-                    processedEntryNamesMap.put(entryName, 1);
-                } else {
-                    int duplicateCount = processedEntryNamesMap.get(entryName);
-                    final String wrapperJarName
-                            = jarOut.getName().substring(0, jarOut.getName().lastIndexOf(".jar"))
-                            + "_dup_ew_" + duplicateCount + ".jar";
-                    File wrapperJarOut = new File(jarOut.getParentFile(), wrapperJarName);
-                    wrapEntryByJar(entryOut, zis, wrapperJarOut);
-                    processedEntryNamesMap.put(entryName, duplicateCount + 1);
-                }
-            }
-        } finally {
-            closeQuietly(zos);
-            closeQuietly(zis);
-        }
-    }
-
-    private static void wrapEntryByJar(ZipEntry ze, InputStream eData, File jarOut) throws IOException {
-        ZipOutputStream zos = null;
-        try {
-            zos = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(jarOut)));
-            zos.putNextEntry(ze);
-            Streams.copy(eData, zos);
-            zos.closeEntry();
-        } finally {
-            closeQuietly(zos);
-        }
-    }
-
-    private static void processClass(InputStream classIn, OutputStream classOut) throws IOException {
-        ClassReader cr = new ClassReader(classIn);
-        ClassWriter cw = new ClassWriter(0);
-        AuxiliaryClassInjectAdapter aia = new AuxiliaryClassInjectAdapter(NOT_EXISTS_CLASSNAME, cw);
-        cr.accept(aia, 0);
-        classOut.write(cw.toByteArray());
-        classOut.flush();
-    }
-
-    private static void closeQuietly(Closeable target) {
-        if (target != null) {
-            try {
-                target.close();
-            } catch (Exception e) {
-                // Ignored.
-            }
-        }
-    }
-}
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/builder/PatchBuilder.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/builder/PatchBuilder.java
index 7b2e0d3e..8cfc6091 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/builder/PatchBuilder.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/builder/PatchBuilder.java
@@ -157,7 +157,7 @@ private void generateUnsignedApk(File output) throws IOException {
             throw new IOException(String.format(
                 "Missing patch unzip files, path=%s\n", tempOutDir.getAbsolutePath()));
         }
-        FileOperation.zipInputDir(tempOutDir, output);
+        FileOperation.zipInputDir(tempOutDir, output, null);
 
         if (!output.exists()) {
             throw new IOException(String.format(
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ApkDecoder.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ApkDecoder.java
index 679f3e2f..d099a697 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ApkDecoder.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ApkDecoder.java
@@ -116,7 +116,7 @@ public boolean patch(File oldFile, File newFile) throws Exception {
         for (File duplicateRes : resDuplicateFiles) {
 //            resPatchDecoder.patch(duplicateRes, null);
             Logger.e("Warning: res file %s is also match at dex or library pattern, "
-                + "we treat it as unchanged in the new resource_out.zip", getRelativeStringByOldDir(duplicateRes));
+                + "we treat it as unchanged in the new resource_out.zip", getRelativePathStringToOldFile(duplicateRes));
         }
 
         soPatchDecoder.onAllPatchesEnd();
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/BaseDecoder.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/BaseDecoder.java
index d6550847..8ea4eb5e 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/BaseDecoder.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/BaseDecoder.java
@@ -58,20 +58,16 @@ public Path getOutputPath(File file) {
         return config.mTempResultDir.toPath().resolve(getRelativePath(file));
     }
 
-    public String getRelativeString(File file) {
-        return config.mTempUnzipNewDir.toPath().relativize(file.toPath()).toString().replace("\\", "/");
+    public String getRelativePathStringToOldFile(File oldFile) {
+        return config.mTempUnzipOldDir.toPath().relativize(oldFile.toPath()).toString().replace("\\", "/");
     }
 
-    public String getParentRelativeString(File file) {
-        return config.mTempUnzipNewDir.toPath().relativize(file.getParentFile().toPath()).toString().replace("\\", "/");
+    public String getRelativePathStringToNewFile(File newFile) {
+        return config.mTempUnzipNewDir.toPath().relativize(newFile.toPath()).toString().replace("\\", "/");
     }
 
-    public String getRelativeStringByOldDir(File file) {
-        return config.mTempUnzipOldDir.toPath().relativize(file.toPath()).toString().replace("\\", "/");
-    }
-
-    public String getParentRelativeStringByOldDir(File file) {
-        return config.mTempUnzipOldDir.toPath().relativize(file.getParentFile().toPath()).toString().replace("\\", "/");
+    public String getParentRelativePathStringToNewFile(File newFile) {
+        return config.mTempUnzipNewDir.toPath().relativize(newFile.getParentFile().toPath()).toString().replace("\\", "/");
     }
 
     /**
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/BsDiffDecoder.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/BsDiffDecoder.java
index 48e27930..a46b0d8b 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/BsDiffDecoder.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/BsDiffDecoder.java
@@ -118,8 +118,8 @@ protected void writeLogFiles(File newFile, File oldFile, File bsDiff, String new
         if (metaWriter == null && logWriter == null) {
             return;
         }
-        String parentRelative = getParentRelativeString(newFile);
-        String relative = getRelativeString(newFile);
+        String parentRelative = getParentRelativePathStringToNewFile(newFile);
+        String relative = getRelativePathStringToNewFile(newFile);
 
         if (metaWriter != null) {
             String fileName = newFile.getName();
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java
index 0a298879..ee541a1f 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java
@@ -17,15 +17,11 @@
 package com.tencent.tinker.build.decoder;
 
 
-import com.google.common.io.Files;
-
 import com.tencent.tinker.android.dex.ClassDef;
 import com.tencent.tinker.android.dex.Dex;
 import com.tencent.tinker.android.dex.DexFormat;
-import com.tencent.tinker.android.dx.util.Hex;
 import com.tencent.tinker.build.dexpatcher.DexPatchGenerator;
-import com.tencent.tinker.build.dexpatcher.util.SmallDexClassInfoCollector;
-import com.tencent.tinker.build.dexpatcher.util.SmallDexPatchGenerator;
+import com.tencent.tinker.build.dexpatcher.util.ChangedClassesDexClassInfoCollector;
 import com.tencent.tinker.build.info.InfoWriter;
 import com.tencent.tinker.build.patch.Configuration;
 import com.tencent.tinker.build.util.DexClassesComparator;
@@ -40,14 +36,13 @@
 import com.tencent.tinker.build.util.Utils;
 import com.tencent.tinker.commons.dexpatcher.DexPatchApplier;
 import com.tencent.tinker.commons.dexpatcher.DexPatcherLogger.IDexPatcherLogger;
-import com.tencent.tinker.commons.dexpatcher.struct.SmallPatchedDexItemFile;
 
-import org.jf.dexlib2.Opcodes;
 import org.jf.dexlib2.builder.BuilderMutableMethodImplementation;
 import org.jf.dexlib2.dexbacked.DexBackedDexFile;
 import org.jf.dexlib2.iface.DexFile;
 import org.jf.dexlib2.iface.Field;
 import org.jf.dexlib2.iface.Method;
+import org.jf.dexlib2.iface.MethodImplementation;
 import org.jf.dexlib2.writer.builder.BuilderField;
 import org.jf.dexlib2.writer.builder.BuilderMethod;
 import org.jf.dexlib2.writer.builder.DexBuilder;
@@ -71,7 +66,7 @@
  */
 public class DexDiffDecoder extends BaseDecoder {
     private static final String TEST_DEX_NAME = "test.dex";
-    private static final String PREGENERATED_PATCH_DEX_NAME = "changed_classes.dex";
+    private static final String CHANGED_CLASSES_DEX_NAME = "changed_classes.dex";
 
     private final InfoWriter logWriter;
     private final InfoWriter metaWriter;
@@ -121,13 +116,21 @@ public void onAllPatchesStart() throws IOException, TinkerPatchException {
 
     }
 
+    /**
+     * Provide /oldFileRoot/dir/to/oldDex, /newFileRoot/dir/to/newDex,
+     * return dir/to/oldDex or dir/to/newDex if any one is not null.
+     */
+    protected String getRelativeDexName(File oldDexFile, File newDexFile) {
+        return oldDexFile != null ? getRelativePathStringToOldFile(oldDexFile) : getRelativePathStringToNewFile(newDexFile);
+    }
+
     @SuppressWarnings("NewApi")
     @Override
     public boolean patch(final File oldFile, final File newFile) throws IOException, TinkerPatchException {
+        final String dexName = getRelativeDexName(oldFile, newFile);
+
         // first of all, we should check input files if excluded classes were modified.
-        Logger.d("Check for loader classes in dex: %s",
-            (oldFile == null ? getRelativeString(newFile) : getRelativeString(oldFile))
-        );
+        Logger.d("Check for loader classes in dex: %s", dexName);
 
         try {
             excludedClassModifiedChecker.checkIfExcludedClassWasModifiedInNewDex(oldFile, newFile);
@@ -152,23 +155,21 @@ public boolean patch(final File oldFile, final File newFile) throws IOException,
 
         File dexDiffOut = getOutputPath(newFile).toFile();
 
-        final String newMd5 = MD5.getMD5(newFile);
+        final String newMd5 = getRawOrWrappedDexMD5(newFile);
 
         //new add file
         if (oldFile == null || !oldFile.exists() || oldFile.length() == 0) {
             hasDexChanged = true;
-            if (!config.mUsePreGeneratedPatchDex) {
-                copyNewDexAndMarkInMeta(newFile, newMd5, dexDiffOut);
-                return true;
-            }
+            copyNewDexAndLogToDexMeta(newFile, newMd5, dexDiffOut);
+            return true;
         }
 
-        final String oldMd5 = MD5.getMD5(oldFile);
+        final String oldMd5 = getRawOrWrappedDexMD5(oldFile);
 
         if ((oldMd5 != null && !oldMd5.equals(newMd5)) || (oldMd5 == null && newMd5 != null)) {
             hasDexChanged = true;
             if (oldMd5 != null) {
-                checkAddedOrDeletedClasses(oldFile, newFile);
+                collectAddedOrDeletedClasses(oldFile, newFile);
             }
         }
 
@@ -179,7 +180,6 @@ public boolean patch(final File oldFile, final File newFile) throws IOException,
         // collect current old dex file and corresponding new dex file for further processing.
         oldAndNewDexFilePairList.add(new AbstractMap.SimpleEntry<>(oldFile, newFile));
 
-        final String dexName = (oldFile != null ? oldFile.getName() : newFile.getName());
         dexNameToRelatedInfoMap.put(dexName, relatedInfo);
 
         return true;
@@ -192,15 +192,22 @@ public void onAllPatchesEnd() throws Exception {
             return;
         }
 
-        if (config.mUsePreGeneratedPatchDex) {
-            generateStubModePatchDex();
+        if (config.mIsProtectedApp) {
+            generateChangedClassesDexFile();
         } else {
             generatePatchInfoFile();
         }
+
+        addTestDex();
     }
 
     @SuppressWarnings("NewApi")
-    private void generateStubModePatchDex() throws IOException {
+    private void generateChangedClassesDexFile() throws IOException {
+        final String dexMode = config.mDexRaw ? "raw" : "jar";
+        final File dest = new File(config.mTempResultDir + "/" + CHANGED_CLASSES_DEX_NAME);
+
+        Logger.d("\nBuilding changed classes dex: %s, size: %d\n", dest.getAbsolutePath(), dest.length());
+
         List<File> oldDexList = new ArrayList<>();
         List<File> newDexList = new ArrayList<>();
         for (AbstractMap.SimpleEntry<File, File> oldAndNewDexFilePair : oldAndNewDexFilePairList) {
@@ -217,181 +224,121 @@ private void generateStubModePatchDex() throws IOException {
         DexGroup oldDexGroup = DexGroup.wrap(oldDexList);
         DexGroup newDexGroup = DexGroup.wrap(newDexList);
 
-        SmallDexClassInfoCollector smallDexClassInfoCollector = new SmallDexClassInfoCollector();
-        smallDexClassInfoCollector.setLoaderClassPatterns(config.mDexLoaderPattern);
-        smallDexClassInfoCollector.setLogger(this.dexPatcherLoggerBridge);
-
-        Set<DexClassInfo> classInfosInPatchedDex =
-                smallDexClassInfoCollector.doCollect(oldDexGroup, newDexGroup);
-
-        // So far we have got all infos of classes we need to include in stub mode patch dex.
-        // Now construct the stub mode patch dex.
-        final Set<String> classDescsInPatchedDex = new HashSet<>();
-        Set<Dex> newDexes = new HashSet<>();
-
-        DexBuilder dexBuilder = DexBuilder.makeDexBuilder(Opcodes.forApi(15));
-
-        for (DexClassInfo classInfo : classInfosInPatchedDex) {
-            classDescsInPatchedDex.add(classInfo.classDesc);
-            newDexes.add(classInfo.owner);
-        }
-
-        for (Dex newDex : newDexes) {
-            DexFile dexFile = new DexBackedDexFile(Opcodes.forApi(15), newDex.getBytes());
-            for (org.jf.dexlib2.iface.ClassDef parsedClassDef : dexFile.getClasses()) {
-                if (classDescsInPatchedDex.contains(parsedClassDef.getType())) {
-                    List<BuilderField> builderFields = new ArrayList<>();
-                    for (Field parsedField : parsedClassDef.getFields()) {
-                        BuilderField builderField = dexBuilder.internField(
-                                parsedField.getDefiningClass(),
-                                parsedField.getName(),
-                                parsedField.getType(),
-                                parsedField.getAccessFlags(),
-                                parsedField.getInitialValue(),
-                                parsedField.getAnnotations()
-                        );
-                        builderFields.add(builderField);
-                    }
-                    List<BuilderMethod> builderMethods = new ArrayList<>();
-                    for (Method parsedMethod : parsedClassDef.getMethods()) {
-                        BuilderMethod builderMethod = dexBuilder.internMethod(
-                                parsedMethod.getDefiningClass(),
-                                parsedMethod.getName(),
-                                parsedMethod.getParameters(),
-                                parsedMethod.getReturnType(),
-                                parsedMethod.getAccessFlags(),
-                                parsedMethod.getAnnotations(),
-                                new BuilderMutableMethodImplementation(
-                                        dexBuilder, parsedMethod.getImplementation()
-                                )
-                        );
-                        builderMethods.add(builderMethod);
-                    }
+        ChangedClassesDexClassInfoCollector collector = new ChangedClassesDexClassInfoCollector();
+        collector.setExcludedClassPatterns(config.mDexLoaderPattern);
+        collector.setLogger(dexPatcherLoggerBridge);
+        collector.setIncludeRefererToRefererAffectedClasses(true);
+
+        Set<DexClassInfo> classInfosInChangedClassesDex = collector.doCollect(oldDexGroup, newDexGroup);
+
+        Set<Dex> owners = new HashSet<>();
+        Map<Dex, Set<String>> ownerToDescOfChangedClassesMap = new HashMap<>();
+        for (DexClassInfo classInfo : classInfosInChangedClassesDex) {
+            owners.add(classInfo.owner);
+            Set<String> descOfChangedClasses = ownerToDescOfChangedClassesMap.get(classInfo.owner);
+            if (descOfChangedClasses == null) {
+                descOfChangedClasses = new HashSet<>();
+                ownerToDescOfChangedClassesMap.put(classInfo.owner, descOfChangedClasses);
+            }
+            descOfChangedClasses.add(classInfo.classDesc);
+        }
 
-                    dexBuilder.internClassDef(
-                            parsedClassDef.getType(),
-                            parsedClassDef.getAccessFlags(),
-                            parsedClassDef.getSuperclass(),
-                            parsedClassDef.getInterfaces(),
-                            parsedClassDef.getSourceFile(),
-                            parsedClassDef.getAnnotations(),
-                            builderFields,
-                            builderMethods
+        DexBuilder dexBuilder = DexBuilder.makeDexBuilder();
+        for (Dex dex : owners) {
+            Set<String> descOfChangedClassesInCurrDex = ownerToDescOfChangedClassesMap.get(dex);
+            DexFile dexFile = new DexBackedDexFile(org.jf.dexlib2.Opcodes.forApi(20), dex.getBytes());
+            for (org.jf.dexlib2.iface.ClassDef classDef : dexFile.getClasses()) {
+                if (!descOfChangedClassesInCurrDex.contains(classDef.getType())) {
+                    continue;
+                }
+
+                Logger.d("Class %s will be added into changed classes dex ...", classDef.getType());
+
+                List<BuilderField> builderFields = new ArrayList<>();
+                for (Field field : classDef.getFields()) {
+                    final BuilderField builderField = dexBuilder.internField(
+                            field.getDefiningClass(),
+                            field.getName(),
+                            field.getType(),
+                            field.getAccessFlags(),
+                            field.getInitialValue(),
+                            field.getAnnotations()
+                    );
+                    builderFields.add(builderField);
+                }
+                List<BuilderMethod> builderMethods = new ArrayList<>();
+
+                for (Method method : classDef.getMethods()) {
+                    MethodImplementation methodImpl = method.getImplementation();
+                    if (methodImpl != null) {
+                        methodImpl = new BuilderMutableMethodImplementation(dexBuilder, methodImpl);
+                    }
+                    BuilderMethod builderMethod = dexBuilder.internMethod(
+                            method.getDefiningClass(),
+                            method.getName(),
+                            method.getParameters(),
+                            method.getReturnType(),
+                            method.getAccessFlags(),
+                            method.getAnnotations(),
+                            methodImpl
                     );
+                    builderMethods.add(builderMethod);
                 }
+                dexBuilder.internClassDef(
+                        classDef.getType(),
+                        classDef.getAccessFlags(),
+                        classDef.getSuperclass(),
+                        classDef.getInterfaces(),
+                        classDef.getSourceFile(),
+                        classDef.getAnnotations(),
+                        builderFields,
+                        builderMethods
+                );
             }
         }
 
-        // Write constructed stub mode patch dex to file and record it in meta file.
-        final String dexMode = config.mDexRaw ? "raw" : "jar";
-        final File dest = new File(config.mTempResultDir + "/" + PREGENERATED_PATCH_DEX_NAME);
-
+        // Write constructed changed classes dex to file and record it in meta file.
         FileDataStore fileDataStore = new FileDataStore(dest);
         dexBuilder.writeTo(fileDataStore);
 
-        final File tempPreGeneratedPatchDexPath = new File(config.mOutFolder + File.separator + TypedValue.DEX_TEMP_PATCH_DIR + File.separator + "pre-generated");
-        ensureDirectoryExist(tempPreGeneratedPatchDexPath);
-        Files.copy(dest, new File(tempPreGeneratedPatchDexPath, PREGENERATED_PATCH_DEX_NAME));
-
         final String md5 = MD5.getMD5(dest);
 
-        String meta = PREGENERATED_PATCH_DEX_NAME + "," + "" + "," + md5 + "," + md5 + "," + 0
-                        + "," + 0 + "," + dexMode;
+        String meta = CHANGED_CLASSES_DEX_NAME + "," + "" + "," + md5 + "," + md5 + "," + 0
+                + "," + 0 + "," + dexMode;
 
-        Logger.d("\nPre-generated patch dex: %s, size:%d", dest.getAbsolutePath(), dest.length());
-        Logger.d("DexDecoder:write pre-generated patch dex meta file data: %s", meta);
+        Logger.d("\nDexDecoder:write changed classes dex meta file data: %s", meta);
 
         metaWriter.writeLineToInfoFile(meta);
-
-        addTestDex();
     }
 
     @SuppressWarnings("NewApi")
     private void generatePatchInfoFile() throws IOException {
-        File tempFullPatchDexPath = new File(config.mOutFolder + File.separator + TypedValue.DEX_TEMP_PATCH_DIR + File.separator + "dalvik");
-        ensureDirectoryExist(tempFullPatchDexPath);
-        File tempSmallPatchDexPath = new File(config.mOutFolder + File.separator + TypedValue.DEX_TEMP_PATCH_DIR + File.separator + "art");
-        ensureDirectoryExist(tempSmallPatchDexPath);
-
-        // Generate dex diff out and full patched dex if a pair of dex is different.
-        for (AbstractMap.SimpleEntry<File, File> oldAndNewDexFilePair : oldAndNewDexFilePairList) {
-            File oldFile = oldAndNewDexFilePair.getKey();
-            File newFile = oldAndNewDexFilePair.getValue();
-            final String dexName = oldFile.getName();
-            RelatedInfo relatedInfo = dexNameToRelatedInfoMap.get(dexName);
-
-            if (!relatedInfo.oldMd5.equals(relatedInfo.newMd5)) {
-                File dexDiffOut = getOutputPath(newFile).toFile();
-                ensureDirectoryExist(dexDiffOut.getParentFile());
-
-                try {
-                    DexPatchGenerator dexPatchGen = new DexPatchGenerator(oldFile, newFile);
-                    dexPatchGen.setAdditionalRemovingClassPatterns(config.mDexLoaderPattern);
-
-                    logWriter.writeLineToInfoFile(
-                            String.format(
-                                    "Start diff between [%s] as old and [%s] as new:",
-                                    getRelativeStringBy(oldFile, config.mTempUnzipOldDir),
-                                    getRelativeStringBy(newFile, config.mTempUnzipNewDir)
-                            )
-                    );
-
-                    dexPatchGen.executeAndSaveTo(dexDiffOut);
-                } catch (Exception e) {
-                    throw new TinkerPatchException(e);
-                }
+        generatePatchedDexInfoFile();
 
-                if (!dexDiffOut.exists()) {
-                    throw new TinkerPatchException("can not find the diff file:" + dexDiffOut.getAbsolutePath());
-                }
-
-                relatedInfo.dexDiffFile = dexDiffOut;
-                relatedInfo.dexDiffMd5 = MD5.getMD5(dexDiffOut);
-                Logger.d("\nGen %s patch file:%s, size:%d, md5:%s", dexName, relatedInfo.dexDiffFile.getAbsolutePath(), relatedInfo.dexDiffFile.length(), relatedInfo.dexDiffMd5);
-
-                File tempFullPatchedDexFile = new File(tempFullPatchDexPath, dexName);
-
-                try {
-                    new DexPatchApplier(oldFile, dexDiffOut).executeAndSaveTo(tempFullPatchedDexFile);
+        // generateSmallPatchedDexInfoFile is blocked by issue we found in ART environment
+        // which indicates that if inline optimization is done on patched class, some error
+        // such as crash, ClassCastException, mistaken string fetching, etc. would happen.
+        //
+        // Instead, we will log all classN dexes as 'copy directly' in dex-meta, so that
+        // tinker patch applying procedure will copy them out and load them in ART environment.
 
-                    Logger.d(
-                            String.format("Verifying if patched new dex is logically the same as original new dex: %s ...", getRelativeStringBy(newFile, config.mTempUnzipNewDir))
-                    );
+        //generateSmallPatchedDexInfoFile();
 
-                    Dex origNewDex = new Dex(newFile);
-                    Dex patchedNewDex = new Dex(tempFullPatchedDexFile);
-                    checkDexChange(origNewDex, patchedNewDex);
+        logDexesToDexMeta();
 
-                    relatedInfo.newOrFullPatchedFile = tempFullPatchedDexFile;
-                    relatedInfo.newOrFullPatchedMd5 = MD5.getMD5(tempFullPatchedDexFile);
-                } catch (Exception e) {
-                    e.printStackTrace();
-                    throw new TinkerPatchException(
-                            "Failed to generate temporary patched dex, which makes MD5 generating procedure of new dex failed, either.", e
-                    );
-                }
-
-                if (!tempFullPatchedDexFile.exists()) {
-                    throw new TinkerPatchException("can not find the temporary full patched dex file:" + tempFullPatchedDexFile.getAbsolutePath());
-                }
-                Logger.d("\nGen %s for dalvik full dex file:%s, size:%d, md5:%s", dexName, tempFullPatchedDexFile.getAbsolutePath(), tempFullPatchedDexFile.length(), relatedInfo.newOrFullPatchedMd5);
-            } else {
-                // In this case newDexFile is the same as oldDexFile, but we still
-                // need to treat it as patched dex file so that the SmallPatchGenerator
-                // can analyze which class of this dex should be kept in small patch.
-                relatedInfo.newOrFullPatchedFile = newFile;
-                relatedInfo.newOrFullPatchedMd5 = relatedInfo.newMd5;
-            }
-        }
+        checkCrossDexMovingClasses();
+    }
 
-        Set<File> classNOldDexFiles = new HashSet<>();
+    @SuppressWarnings("NewApi")
+    private void logDexesToDexMeta() throws IOException {
+        Map<String, File> dexNameToClassNOldDexFileMap = new HashMap<>();
+        Set<File> realClassNDexFiles = new HashSet<>();
 
         for (AbstractMap.SimpleEntry<File, File> oldAndNewDexFilePair : oldAndNewDexFilePairList) {
             File oldFile = oldAndNewDexFilePair.getKey();
-            final String dexName = oldFile.getName();
-
+            final String dexName = getRelativeDexName(oldFile, null);
             if (isDexNameMatchesClassNPattern(dexName)) {
-                classNOldDexFiles.add(oldFile);
+                dexNameToClassNOldDexFileMap.put(dexName, oldFile);
             }
         }
 
@@ -399,113 +346,146 @@ private void generatePatchInfoFile() throws IOException {
         // classes.dex, classes2.dex, classes4.dex, classes5.dex
         // Since classes3.dex is missing, according to the logic in AOSP, we should not treat
         // rest dexes as part of class N dexes.
-        Map<String, File> dexNameToClassNOldDexFileMap = new HashMap<>();
-        for (File classNOldDex : classNOldDexFiles) {
-            dexNameToClassNOldDexFileMap.put(classNOldDex.getName(), classNOldDex);
+        for (int i = 0; i < dexNameToClassNOldDexFileMap.size(); ++i) {
+            final String expectedDexName = (i == 0 ? DexFormat.DEX_IN_JAR_NAME : "classes" + (i + 1) + ".dex");
+            if (dexNameToClassNOldDexFileMap.containsKey(expectedDexName)) {
+                File oldDexFile = dexNameToClassNOldDexFileMap.get(expectedDexName);
+                realClassNDexFiles.add(oldDexFile);
+            } else {
+                break;
+            }
         }
 
-        boolean isRestDexNotInClassN = false;
-        for (int i = 0; i < classNOldDexFiles.size(); ++i) {
-            final String expectedDexName = (i == 0 ? DexFormat.DEX_IN_JAR_NAME : "classes" + (i + 1) + ".dex");
-            if (!dexNameToClassNOldDexFileMap.containsKey(expectedDexName)) {
-                isRestDexNotInClassN = true;
+        for (AbstractMap.SimpleEntry<File, File> oldAndNewDexFilePair : oldAndNewDexFilePairList) {
+            final File oldDexFile = oldAndNewDexFilePair.getKey();
+            final File newDexFile = oldAndNewDexFilePair.getValue();
+            final String dexName = getRelativeDexName(oldDexFile, newDexFile);
+            final RelatedInfo relatedInfo = dexNameToRelatedInfoMap.get(dexName);
+            if (!relatedInfo.oldMd5.equals(relatedInfo.newMd5)) {
+                logToDexMeta(newDexFile, oldDexFile, relatedInfo.dexDiffFile, relatedInfo.newOrFullPatchedMd5, relatedInfo.newOrFullPatchedMd5, relatedInfo.dexDiffMd5);
             } else {
-                if (isRestDexNotInClassN) {
-                    File mistakenClassNOldDexFile = dexNameToClassNOldDexFileMap.get(expectedDexName);
-                    classNOldDexFiles.remove(mistakenClassNOldDexFile);
+                // For class N dexes, if new dex is the same as old dex, we should log it as 'copy directly'
+                // in dex meta to fix problems in Art environment.
+                if (realClassNDexFiles.contains(oldDexFile)) {
+                    // Bugfix: However, if what we would copy directly is main dex, we should do an additional diff operation
+                    // so that patch applier would help us remove all loader classes of it in runtime.
+                    if (dexName.equals(DexFormat.DEX_IN_JAR_NAME)) {
+                        Logger.d("\nDo additional diff on main dex to remove loader classes in it.");
+                        diffDexPairAndFillRelatedInfo(oldDexFile, newDexFile, relatedInfo);
+                        logToDexMeta(newDexFile, oldDexFile, relatedInfo.dexDiffFile, relatedInfo.newOrFullPatchedMd5, relatedInfo.newOrFullPatchedMd5, relatedInfo.dexDiffMd5);
+                    } else {
+                        logToDexMeta(newDexFile, oldDexFile, null, "0", relatedInfo.oldMd5, "0");
+                    }
                 }
             }
         }
+    }
 
-        File tempSmallPatchInfoFile = new File(config.mTempResultDir, TypedValue.DEX_SMALLPATCH_INFO_FILE);
-        ensureDirectoryExist(tempSmallPatchInfoFile.getParentFile());
-
-        // So far we know whether a pair of dex is belong to class N dexes or other dexes.
-        // Then we collect class N dex pairs and other dex pairs by separate their old dex
-        // and full patched dex into different list.
-        SmallDexPatchGenerator smallDexPatchGenerator = new SmallDexPatchGenerator();
-        smallDexPatchGenerator.setLoaderClassPatterns(config.mDexLoaderPattern);
-        smallDexPatchGenerator.setLogger(dexPatcherLoggerBridge);
-
-        logWriter.writeLineToInfoFile("\nStart collecting old dex and full patched dex...");
-
-        List<File> classNOldDexFileList = new ArrayList<>();
-        List<File> classNFullPatchedDexFileList = new ArrayList<>();
-        List<File> otherOldDexFileList = new ArrayList<>();
-        List<File> otherFullPatchedDexFileList = new ArrayList<>();
+    @SuppressWarnings("NewApi")
+    private void generatePatchedDexInfoFile() {
+        // Generate dex diff out and full patched dex if a pair of dex is different.
         for (AbstractMap.SimpleEntry<File, File> oldAndNewDexFilePair : oldAndNewDexFilePairList) {
             File oldFile = oldAndNewDexFilePair.getKey();
-            final String dexName = oldFile.getName();
-            File fullPatchedFile = dexNameToRelatedInfoMap.get(dexName).newOrFullPatchedFile;
-            if (classNOldDexFiles.contains(oldFile)) {
-                classNOldDexFileList.add(oldFile);
-                classNFullPatchedDexFileList.add(fullPatchedFile);
+            File newFile = oldAndNewDexFilePair.getValue();
+            final String dexName = getRelativeDexName(oldFile, newFile);
+            RelatedInfo relatedInfo = dexNameToRelatedInfoMap.get(dexName);
+            if (!relatedInfo.oldMd5.equals(relatedInfo.newMd5)) {
+                diffDexPairAndFillRelatedInfo(oldFile, newFile, relatedInfo);
             } else {
-                otherOldDexFileList.add(oldFile);
-                otherFullPatchedDexFileList.add(fullPatchedFile);
+                // In this case newDexFile is the same as oldDexFile, but we still
+                // need to treat it as patched dex file so that the SmallPatchGenerator
+                // can analyze which class of this dex should be kept in small patch.
+                relatedInfo.newOrFullPatchedFile = newFile;
+                relatedInfo.newOrFullPatchedMd5 = relatedInfo.newMd5;
             }
         }
+    }
+
+    private void diffDexPairAndFillRelatedInfo(File oldDexFile, File newDexFile, RelatedInfo relatedInfo) {
+        File tempFullPatchDexPath = new File(config.mOutFolder + File.separator + TypedValue.DEX_TEMP_PATCH_DIR);
+        final String dexName = getRelativeDexName(oldDexFile, newDexFile);
+
+        File dexDiffOut = getOutputPath(newDexFile).toFile();
+        ensureDirectoryExist(dexDiffOut.getParentFile());
+
+        try {
+            DexPatchGenerator dexPatchGen = new DexPatchGenerator(oldDexFile, newDexFile);
+            dexPatchGen.setAdditionalRemovingClassPatterns(config.mDexLoaderPattern);
+
+            logWriter.writeLineToInfoFile(
+                    String.format(
+                            "Start diff between [%s] as old and [%s] as new:",
+                            getRelativeStringBy(oldDexFile, config.mTempUnzipOldDir),
+                            getRelativeStringBy(newDexFile, config.mTempUnzipNewDir)
+                    )
+            );
+
+            dexPatchGen.executeAndSaveTo(dexDiffOut);
+        } catch (Exception e) {
+            throw new TinkerPatchException(e);
+        }
 
-        logWriter.writeLineToInfoFile(String.format("\nCollected class N old dexes: %s", classNOldDexFileList));
-        logWriter.writeLineToInfoFile(String.format("Collected class N full patched dexes: %s", classNFullPatchedDexFileList));
-        logWriter.writeLineToInfoFile(String.format("\nCollected other old dexes: %s", otherOldDexFileList));
-        logWriter.writeLineToInfoFile(String.format("Collected other full patched dexes: %s", otherFullPatchedDexFileList));
+        if (!dexDiffOut.exists()) {
+            throw new TinkerPatchException("can not find the diff file:" + dexDiffOut.getAbsolutePath());
+        }
 
-        smallDexPatchGenerator.appendDexGroup(DexGroup.wrap(classNOldDexFileList), DexGroup.wrap(classNFullPatchedDexFileList));
+        relatedInfo.dexDiffFile = dexDiffOut;
+        relatedInfo.dexDiffMd5 = MD5.getMD5(dexDiffOut);
+        Logger.d("\nGen %s patch file:%s, size:%d, md5:%s", dexName, relatedInfo.dexDiffFile.getAbsolutePath(), relatedInfo.dexDiffFile.length(), relatedInfo.dexDiffMd5);
 
-        if (!otherOldDexFileList.isEmpty()) {
-            smallDexPatchGenerator.appendDexGroup(DexGroup.wrap(otherOldDexFileList), DexGroup.wrap(otherFullPatchedDexFileList));
+        File tempFullPatchedDexFile = new File(tempFullPatchDexPath, dexName);
+        if (!tempFullPatchedDexFile.exists()) {
+            ensureDirectoryExist(tempFullPatchedDexFile.getParentFile());
         }
 
         try {
-            Logger.d("Start generating small patch info file...");
-            smallDexPatchGenerator.executeAndSaveTo(tempSmallPatchInfoFile);
+            new DexPatchApplier(oldDexFile, dexDiffOut).executeAndSaveTo(tempFullPatchedDexFile);
+
+            Logger.d(
+                    String.format("Verifying if patched new dex is logically the same as original new dex: %s ...", getRelativeStringBy(newDexFile, config.mTempUnzipNewDir))
+            );
+
+            Dex origNewDex = new Dex(newDexFile);
+            Dex patchedNewDex = new Dex(tempFullPatchedDexFile);
+            checkDexChange(origNewDex, patchedNewDex);
+
+            relatedInfo.newOrFullPatchedFile = tempFullPatchedDexFile;
+            relatedInfo.newOrFullPatchedMd5 = MD5.getMD5(tempFullPatchedDexFile);
         } catch (Exception e) {
-            throw new TinkerPatchException("\nFailed to generate small patch info file.", e);
+            e.printStackTrace();
+            throw new TinkerPatchException(
+                    "Failed to generate temporary patched dex, which makes MD5 generating procedure of new dex failed, either.", e
+            );
         }
-        if (!tempSmallPatchInfoFile.exists()) {
-            throw new TinkerPatchException("can not find the small patch info file:" + tempSmallPatchInfoFile.getAbsolutePath());
+
+        if (!tempFullPatchedDexFile.exists()) {
+            throw new TinkerPatchException("can not find the temporary full patched dex file:" + tempFullPatchedDexFile.getAbsolutePath());
         }
+        Logger.d("\nGen %s for dalvik full dex file:%s, size:%d, md5:%s", dexName, tempFullPatchedDexFile.getAbsolutePath(), tempFullPatchedDexFile.length(), relatedInfo.newOrFullPatchedMd5);
+    }
 
-        SmallPatchedDexItemFile smallPatchedDexItemFile = new SmallPatchedDexItemFile(tempSmallPatchInfoFile);
+    private void addTestDex() throws IOException {
+        //write test dex
+        String dexMode = "jar";
+        if (config.mDexRaw) {
+            dexMode = "raw";
+        }
 
-        // Generate small patched dex and write meta.
-        for (AbstractMap.SimpleEntry<File, File> oldAndNewDexFilePair : oldAndNewDexFilePairList) {
-            File oldFile = oldAndNewDexFilePair.getKey();
-            File newFile = oldAndNewDexFilePair.getValue();
-            final String dexName = oldFile.getName();
-            final String oldDexSignStr = Hex.toHexString(new Dex(oldFile).computeSignature(false));
-            File tempSmallPatchedFile = new File(tempSmallPatchDexPath, dexName);
-            RelatedInfo relatedInfo = dexNameToRelatedInfoMap.get(dexName);
-            File dexDiffFile = relatedInfo.dexDiffFile;
+        final InputStream is = DexDiffDecoder.class.getResourceAsStream("/" + TEST_DEX_NAME);
+        String md5 = MD5.getMD5(is, 1024);
+        is.close();
 
-            if (!smallPatchedDexItemFile.isSmallPatchedDexEmpty(oldDexSignStr)) {
-                try {
-                    new DexPatchApplier(oldFile, dexDiffFile, smallPatchedDexItemFile).executeAndSaveTo(tempSmallPatchedFile);
-                } catch (Exception e) {
-                    e.printStackTrace();
-                    throw new TinkerPatchException(
-                            "Failed to generate temporary small patched dex, which makes MD5 generating procedure of small patched dex failed, either.", e
-                    );
-                }
-                if (!tempSmallPatchedFile.exists()) {
-                    throw new TinkerPatchException("can not find the temporary small patched dex file:" + tempSmallPatchInfoFile.getAbsolutePath());
-                }
-                relatedInfo.smallPatchedMd5 = MD5.getMD5(tempSmallPatchedFile);
-                Logger.d("\nGen %s for art small dex file:%s, size:%d, md5:%s", dexName, tempSmallPatchedFile.getAbsolutePath(), tempSmallPatchedFile.length(), relatedInfo.smallPatchedMd5);
-
-                if (relatedInfo.oldMd5.equals(relatedInfo.newMd5)) {
-                    // Unmodified dex, which has no dexDiffFile, and is ignored in dvm environment.
-                    // So we pass zero string to destMd5InDvm and dexDiffMd5.
-                    writeLogFiles(newFile, oldFile, relatedInfo.dexDiffFile, "0", relatedInfo.smallPatchedMd5, "0");
-                } else {
-                    writeLogFiles(newFile, oldFile, relatedInfo.dexDiffFile, relatedInfo.newOrFullPatchedMd5, relatedInfo.smallPatchedMd5, relatedInfo.dexDiffMd5);
-                }
-            }
-        }
+        String meta = TEST_DEX_NAME + "," + "" + "," + md5 + "," + md5 + "," + 0 + "," + 0 + "," + dexMode;
 
-        addTestDex();
+        File dest = new File(config.mTempResultDir + "/" + TEST_DEX_NAME);
+        FileOperation.copyResourceUsingStream(TEST_DEX_NAME, dest);
+        Logger.d("\nAdd test install result dex: %s, size:%d", dest.getAbsolutePath(), dest.length());
+        Logger.d("DexDecoder:write test dex meta file data: %s", meta);
+
+        metaWriter.writeLineToInfoFile(meta);
+    }
 
+    private void checkCrossDexMovingClasses() {
         // Here we will check if any classes that were deleted in one dex
         // would be added to another dex. e.g. classA is deleted in dex0 and
         // added in dex1.
@@ -535,33 +515,11 @@ private void generatePatchInfoFile() throws IOException {
         }
     }
 
-    @Override
-    public void clean() {
-        metaWriter.close();
-        logWriter.close();
-    }
-
-    private void ensureDirectoryExist(File dir) {
-        if (!dir.exists()) {
-            if (!dir.mkdirs()) {
-                throw new TinkerPatchException("failed to create directory: " + dir);
-            }
-        }
-    }
-
-    private boolean isDexNameMatchesClassNPattern(String dexName) {
-        return (dexName.matches("^classes[0-9]*\\.dex$"));
-    }
-
-    private void copyNewDexAndMarkInMeta(File newFile, String newMd5, File output) throws IOException {
-        newMd5 = checkNewDexAndMd5(newMd5, newFile);
-        FileOperation.copyFileUsingStream(newFile, output);
-        writeLogFiles(newFile, null, null, newMd5, newMd5, "0");
-    }
-
-    private void checkAddedOrDeletedClasses(File oldFile, File newFile) throws IOException {
-        // Before starting real diff works, we collect added class descriptor
-        // and deleted class descriptor for further analysing.
+    /**
+     * Before starting real diff works, we collect added class descriptor
+     * and deleted class descriptor for further analysing in {@code checkCrossDexMovingClasses}.
+     */
+    private void collectAddedOrDeletedClasses(File oldFile, File newFile) throws IOException {
         Dex oldDex = new Dex(oldFile);
         Dex newDex = new Dex(newFile);
 
@@ -612,6 +570,15 @@ private void checkAddedOrDeletedClasses(File oldFile, File newFile) throws IOExc
         }
     }
 
+    private boolean isDexNameMatchesClassNPattern(String dexName) {
+        return (dexName.matches("^classes[0-9]*\\.dex$"));
+    }
+
+    private void copyNewDexAndLogToDexMeta(File newFile, String newMd5, File output) throws IOException {
+        FileOperation.copyFileUsingStream(newFile, output);
+        logToDexMeta(newFile, null, null, newMd5, newMd5, "0");
+    }
+
     private void checkDexChange(Dex originDex, Dex newDex) {
         DexClassesComparator classesCmptor = new DexClassesComparator("*");
         classesCmptor.setIgnoredRemovedClassDescPattern(config.mDexLoaderPattern);
@@ -652,59 +619,6 @@ private void checkDexChange(Dex originDex, Dex newDex) {
         }
     }
 
-    private void addTestDex() throws IOException {
-        //write test dex
-        String dexMode = "jar";
-        if (config.mDexRaw) {
-            dexMode = "raw";
-        }
-
-        final InputStream is = DexDiffDecoder.class.getResourceAsStream("/" + TEST_DEX_NAME);
-        String md5 = MD5.getMD5(is, 1024);
-        is.close();
-
-        String meta = TEST_DEX_NAME + "," + "" + "," + md5 + "," + md5 + "," + 0 + "," + 0 + "," + dexMode;
-
-        File dest = new File(config.mTempResultDir + "/" + TEST_DEX_NAME);
-        FileOperation.copyResourceUsingStream(TEST_DEX_NAME, dest);
-        Logger.d("\nAdd test install result dex: %s, size:%d", dest.getAbsolutePath(), dest.length());
-        Logger.d("DexDecoder:write test dex meta file data: %s", meta);
-
-        metaWriter.writeLineToInfoFile(meta);
-    }
-
-    private String checkNewDexAndMd5(String md5, File dexFile) {
-        String name = dexFile.getName();
-        if (name.endsWith(".dex")) {
-            return md5;
-        } else {
-            try {
-                final JarFile dexJar = new JarFile(dexFile);
-                ZipEntry classesDex = dexJar.getEntry(DexFormat.DEX_IN_JAR_NAME);
-                // no code
-                if (null == classesDex) {
-                    throw new TinkerPatchException(
-                        String.format("dex jar file %s do not contain 'classes.dex', it is not a correct dex jar file!", dexFile.getAbsolutePath())
-                    );
-                }
-
-                return MD5.getMD5(dexJar.getInputStream(classesDex), 1024 * 100);
-            } catch (IOException e) {
-                throw new TinkerPatchException(
-                    String.format("dex file %s is not end with '.dex', but it is not a correct dex jar file also!", dexFile.getAbsolutePath()), e
-                );
-            }
-        }
-    }
-
-    private String getRelativeStringBy(File file, File reference) {
-        File actualReference = reference.getParentFile();
-        if (actualReference == null) {
-            actualReference = reference;
-        }
-        return actualReference.toPath().relativize(file.toPath()).toString().replace("\\", "/");
-    }
-
     /**
      * Construct dex meta-info and write it to meta file and log.
      *
@@ -723,12 +637,12 @@ private String getRelativeStringBy(File file, File reference) {
      *
      * @throws IOException
      */
-    protected void writeLogFiles(File newOrFullPatchedFile, File oldFile, File dexDiffFile, String destMd5InDvm, String destMd5InArt, String dexDiffMd5) throws IOException {
+    protected void logToDexMeta(File newOrFullPatchedFile, File oldFile, File dexDiffFile, String destMd5InDvm, String destMd5InArt, String dexDiffMd5) throws IOException {
         if (metaWriter == null && logWriter == null) {
             return;
         }
-        String parentRelative = getParentRelativeString(newOrFullPatchedFile);
-        String relative = getRelativeString(newOrFullPatchedFile);
+        String parentRelative = getParentRelativePathStringToNewFile(newOrFullPatchedFile);
+        String relative = getRelativePathStringToNewFile(newOrFullPatchedFile);
 
         if (metaWriter != null) {
             String fileName = newOrFullPatchedFile.getName();
@@ -765,6 +679,60 @@ protected void writeLogFiles(File newOrFullPatchedFile, File oldFile, File dexDi
         }
     }
 
+    @Override
+    public void clean() {
+        metaWriter.close();
+        logWriter.close();
+    }
+
+    private String getRawOrWrappedDexMD5(File dexOrJarFile) {
+        final String name = dexOrJarFile.getName();
+        if (name.endsWith(".dex")) {
+            return MD5.getMD5(dexOrJarFile);
+        } else {
+            JarFile dexJar = null;
+            try {
+                dexJar = new JarFile(dexOrJarFile);
+                ZipEntry classesDex = dexJar.getEntry(DexFormat.DEX_IN_JAR_NAME);
+                // no code
+                if (classesDex == null) {
+                    throw new TinkerPatchException(
+                            String.format("Jar file %s do not contain 'classes.dex', it is not a correct dex jar file!", dexOrJarFile.getAbsolutePath())
+                    );
+                }
+                return MD5.getMD5(dexJar.getInputStream(classesDex), 1024 * 100);
+            } catch (IOException e) {
+                throw new TinkerPatchException(
+                        String.format("File %s is not end with '.dex', but it is not a correct dex jar file !", dexOrJarFile.getAbsolutePath()), e
+                );
+            } finally {
+                if (dexJar != null) {
+                    try {
+                        dexJar.close();
+                    } catch (Exception e) {
+                        // Ignored.
+                    }
+                }
+            }
+        }
+    }
+
+    private String getRelativeStringBy(File file, File reference) {
+        File actualReference = reference.getParentFile();
+        if (actualReference == null) {
+            actualReference = reference;
+        }
+        return actualReference.toPath().relativize(file.toPath()).toString().replace("\\", "/");
+    }
+
+    private void ensureDirectoryExist(File dir) {
+        if (!dir.exists()) {
+            if (!dir.mkdirs()) {
+                throw new TinkerPatchException("failed to create directory: " + dir);
+            }
+        }
+    }
+
     private final class RelatedInfo {
         File newOrFullPatchedFile = null;
         /**
@@ -781,39 +749,38 @@ protected void writeLogFiles(File newOrFullPatchedFile, File oldFile, File dexDi
          *  newDex md5, if new dex is marked to be copied directly;
          */
         String newOrFullPatchedMd5 = "0";
-        String smallPatchedMd5 = "0";
     }
 
     private final class DexPatcherLoggerBridge implements IDexPatcherLogger {
-        private final InfoWriter logWritter;
+        private final InfoWriter logWriter;
 
         DexPatcherLoggerBridge(InfoWriter logWritter) {
-            this.logWritter = logWritter;
+            this.logWriter = logWritter;
         }
 
         @Override
         public void v(String msg) {
-            this.logWritter.writeLineToInfoFile(msg);
+            this.logWriter.writeLineToInfoFile(msg);
         }
 
         @Override
         public void d(String msg) {
-            this.logWritter.writeLineToInfoFile(msg);
+            this.logWriter.writeLineToInfoFile(msg);
         }
 
         @Override
         public void i(String msg) {
-            this.logWritter.writeLineToInfoFile(msg);
+            this.logWriter.writeLineToInfoFile(msg);
         }
 
         @Override
         public void w(String msg) {
-            this.logWritter.writeLineToInfoFile(msg);
+            this.logWriter.writeLineToInfoFile(msg);
         }
 
         @Override
         public void e(String msg) {
-            this.logWritter.writeLineToInfoFile(msg);
+            this.logWriter.writeLineToInfoFile(msg);
         }
     }
 }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ResDiffDecoder.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ResDiffDecoder.java
index 9ec77664..5abce200 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ResDiffDecoder.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ResDiffDecoder.java
@@ -92,11 +92,11 @@ private boolean checkLargeModFile(File file) {
 
     @Override
     public boolean patch(File oldFile, File newFile) throws IOException, TinkerPatchException {
-        String name = getRelativeString(newFile);
+        String name = getRelativePathStringToNewFile(newFile);
 
         //actually, it won't go below
         if (newFile == null || !newFile.exists()) {
-            String relativeStringByOldDir = getRelativeStringByOldDir(oldFile);
+            String relativeStringByOldDir = getRelativePathStringToOldFile(oldFile);
             if (Utils.checkFileInPattern(config.mResIgnoreChangePattern, relativeStringByOldDir)) {
                 Logger.e("found delete resource: " + relativeStringByOldDir + " ,but it match ignore change pattern, just ignore!");
                 return false;
@@ -178,25 +178,25 @@ private void writeResLog(File newFile, File oldFile, int mode) throws IOExceptio
             String relative;
             switch (mode) {
                 case TypedValue.ADD:
-                    relative = getRelativeString(newFile);
+                    relative = getRelativePathStringToNewFile(newFile);
                     Logger.d("Found add resource: " + relative);
                     log = "add resource: " + relative + ", oldSize=" + FileOperation.getFileSizes(oldFile) + ", newSize="
                         + FileOperation.getFileSizes(newFile);
                     break;
                 case TypedValue.MOD:
-                    relative = getRelativeString(newFile);
+                    relative = getRelativePathStringToNewFile(newFile);
                     Logger.d("Found modify resource: " + relative);
                     log = "modify resource: " + relative + ", oldSize=" + FileOperation.getFileSizes(oldFile) + ", newSize="
                         + FileOperation.getFileSizes(newFile);
                     break;
                 case TypedValue.DEL:
-                    relative = getRelativeStringByOldDir(oldFile);
+                    relative = getRelativePathStringToOldFile(oldFile);
                     Logger.d("Found deleted resource: " + relative);
                     log = "deleted resource: " + relative + ", oldSize=" + FileOperation.getFileSizes(oldFile) + ", newSize="
                         + FileOperation.getFileSizes(newFile);
                     break;
                 case TypedValue.LARGE_MOD:
-                    relative = getRelativeString(newFile);
+                    relative = getRelativePathStringToNewFile(newFile);
                     Logger.d("Found large modify resource: " + relative + " size:" + newFile.length());
                     log = "large modify resource: " + relative + ", oldSize=" + FileOperation.getFileSizes(oldFile) + ", newSize="
                         + FileOperation.getFileSizes(newFile);
@@ -235,8 +235,6 @@ public void onAllPatchesEnd() throws IOException, TinkerPatchException {
             throw new TinkerPatchException("resource must contain AndroidManifest.xml pattern");
         }
 
-        addAssetsFileForTestResource();
-
         //check gradle build
         if (config.mUsingGradle) {
             final boolean ignoreWarning = config.mIgnoreWarning;
@@ -274,11 +272,14 @@ public void onAllPatchesEnd() throws IOException, TinkerPatchException {
         removeIgnoreChangeFile(addedSet);
         removeIgnoreChangeFile(largeModifiedSet);
 
+        // last add test res in assets for user cannot ignore it;
+        addAssetsFileForTestResource();
+
         File tempResZip = new File(config.mOutFolder + File.separator + TEMP_RES_ZIP);
         final File tempResFiles = config.mTempResultDir;
 
         //gen zip resources_out.zip
-        FileOperation.zipInputDir(tempResFiles, tempResZip);
+        FileOperation.zipInputDir(tempResFiles, tempResZip, null);
         File extractToZip = new File(config.mOutFolder + File.separator + TypedValue.RES_OUT);
 
         String resZipMd5 = Utils.genResOutputFile(extractToZip, tempResZip, config,
@@ -421,7 +422,7 @@ public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IO
             if (Utils.checkFileInPattern(config.mResFilePattern, patternKey)) {
                 //not contain in new path, is deleted
                 if (!newPath.toFile().exists()) {
-                    deletedFiles.add(relativePath.toString());
+                    deletedFiles.add(patternKey);
                     writeResLog(newPath.toFile(), file.toFile(), TypedValue.DEL);
                 }
                 return FileVisitResult.CONTINUE;
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/UniqueDexDiffDecoder.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/UniqueDexDiffDecoder.java
index 46a61f7c..88258320 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/UniqueDexDiffDecoder.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/UniqueDexDiffDecoder.java
@@ -48,4 +48,4 @@ public boolean patch(File oldFile, File newFile) throws IOException, TinkerPatch
         return added;
     }
 
-}
+}
\ No newline at end of file
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/DexPatchGenerator.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/DexPatchGenerator.java
index d058b2d0..ce25e7e4 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/DexPatchGenerator.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/DexPatchGenerator.java
@@ -33,7 +33,7 @@
 import com.tencent.tinker.android.dex.StringData;
 import com.tencent.tinker.android.dex.TypeList;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 import com.tencent.tinker.build.dexpatcher.algorithms.diff.AnnotationSectionDiffAlgorithm;
 import com.tencent.tinker.build.dexpatcher.algorithms.diff.AnnotationSetRefListSectionDiffAlgorithm;
 import com.tencent.tinker.build.dexpatcher.algorithms.diff.AnnotationSetSectionDiffAlgorithm;
@@ -136,10 +136,10 @@ public DexPatchGenerator(Dex oldDex, Dex newDex) {
         this.oldDex = oldDex;
         this.newDex = newDex;
 
-        IndexMap oldToNewIndexMap = new IndexMap();
-        IndexMap oldToPatchedIndexMap = new IndexMap();
-        IndexMap newToPatchedIndexMap = new IndexMap();
-        IndexMap selfIndexMapForSkip = new IndexMap();
+        SparseIndexMap oldToNewIndexMap = new SparseIndexMap();
+        SparseIndexMap oldToPatchedIndexMap = new SparseIndexMap();
+        SparseIndexMap newToPatchedIndexMap = new SparseIndexMap();
+        SparseIndexMap selfIndexMapForSkip = new SparseIndexMap();
 
         additionalRemovingClassPatternSet = new HashSet<>();
 
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/AnnotationSectionDiffAlgorithm.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/AnnotationSectionDiffAlgorithm.java
index 3d07d29e..d9979724 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/AnnotationSectionDiffAlgorithm.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/AnnotationSectionDiffAlgorithm.java
@@ -20,13 +20,14 @@
 import com.tencent.tinker.android.dex.Dex;
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 /**
  * Created by tangyinsheng on 2016/6/30.
  */
 public class AnnotationSectionDiffAlgorithm extends DexSectionDiffAlgorithm<Annotation> {
-    public AnnotationSectionDiffAlgorithm(Dex oldDex, Dex newDex, IndexMap oldToNewIndexMap, IndexMap oldToPatchedIndexMap, IndexMap newToPatchedIndexMap, IndexMap selfIndexMapForSkip) {
+    public AnnotationSectionDiffAlgorithm(Dex oldDex, Dex newDex, SparseIndexMap oldToNewIndexMap, SparseIndexMap oldToPatchedIndexMap, SparseIndexMap newToPatchedIndexMap, SparseIndexMap selfIndexMapForSkip) {
         super(oldDex, newDex, oldToNewIndexMap, oldToPatchedIndexMap, newToPatchedIndexMap, selfIndexMapForSkip);
     }
 
@@ -46,19 +47,19 @@ protected int getItemSize(Annotation item) {
     }
 
     @Override
-    protected Annotation adjustItem(IndexMap indexMap, Annotation item) {
+    protected Annotation adjustItem(AbstractIndexMap indexMap, Annotation item) {
         return indexMap.adjust(item);
     }
 
     @Override
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         if (oldOffset != newOffset) {
-            indexMap.mapAnnotationOffset(oldOffset, newOffset);
+            sparseIndexMap.mapAnnotationOffset(oldOffset, newOffset);
         }
     }
 
     @Override
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
-        indexMap.markAnnotationDeleted(deletedOffset);
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
+        sparseIndexMap.markAnnotationDeleted(deletedOffset);
     }
 }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/AnnotationSetRefListSectionDiffAlgorithm.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/AnnotationSetRefListSectionDiffAlgorithm.java
index b8561637..27971231 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/AnnotationSetRefListSectionDiffAlgorithm.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/AnnotationSetRefListSectionDiffAlgorithm.java
@@ -20,13 +20,14 @@
 import com.tencent.tinker.android.dex.Dex;
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 /**
  * Created by tangyinsheng on 2016/6/30.
  */
 public class AnnotationSetRefListSectionDiffAlgorithm extends DexSectionDiffAlgorithm<AnnotationSetRefList> {
-    public AnnotationSetRefListSectionDiffAlgorithm(Dex oldDex, Dex newDex, IndexMap oldToNewIndexMap, IndexMap oldToPatchedIndexMap, IndexMap newToPatchedIndexMap, IndexMap selfIndexMapForSkip) {
+    public AnnotationSetRefListSectionDiffAlgorithm(Dex oldDex, Dex newDex, SparseIndexMap oldToNewIndexMap, SparseIndexMap oldToPatchedIndexMap, SparseIndexMap newToPatchedIndexMap, SparseIndexMap selfIndexMapForSkip) {
         super(oldDex, newDex, oldToNewIndexMap, oldToPatchedIndexMap, newToPatchedIndexMap, selfIndexMapForSkip);
     }
 
@@ -46,19 +47,19 @@ protected int getItemSize(AnnotationSetRefList item) {
     }
 
     @Override
-    protected AnnotationSetRefList adjustItem(IndexMap indexMap, AnnotationSetRefList item) {
+    protected AnnotationSetRefList adjustItem(AbstractIndexMap indexMap, AnnotationSetRefList item) {
         return indexMap.adjust(item);
     }
 
     @Override
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         if (oldOffset != newOffset) {
-            indexMap.mapAnnotationSetRefListOffset(oldOffset, newOffset);
+            sparseIndexMap.mapAnnotationSetRefListOffset(oldOffset, newOffset);
         }
     }
 
     @Override
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
-        indexMap.markAnnotationSetRefListDeleted(deletedOffset);
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
+        sparseIndexMap.markAnnotationSetRefListDeleted(deletedOffset);
     }
 }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/AnnotationSetSectionDiffAlgorithm.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/AnnotationSetSectionDiffAlgorithm.java
index 98f02533..557713d4 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/AnnotationSetSectionDiffAlgorithm.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/AnnotationSetSectionDiffAlgorithm.java
@@ -20,13 +20,14 @@
 import com.tencent.tinker.android.dex.Dex;
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 /**
  * Created by tangyinsheng on 2016/6/30.
  */
 public class AnnotationSetSectionDiffAlgorithm extends DexSectionDiffAlgorithm<AnnotationSet> {
-    public AnnotationSetSectionDiffAlgorithm(Dex oldDex, Dex newDex, IndexMap oldToNewIndexMap, IndexMap oldToPatchedIndexMap, IndexMap newToPatchedIndexMap, IndexMap selfIndexMapForSkip) {
+    public AnnotationSetSectionDiffAlgorithm(Dex oldDex, Dex newDex, SparseIndexMap oldToNewIndexMap, SparseIndexMap oldToPatchedIndexMap, SparseIndexMap newToPatchedIndexMap, SparseIndexMap selfIndexMapForSkip) {
         super(oldDex, newDex, oldToNewIndexMap, oldToPatchedIndexMap, newToPatchedIndexMap, selfIndexMapForSkip);
     }
 
@@ -46,19 +47,19 @@ protected int getItemSize(AnnotationSet item) {
     }
 
     @Override
-    protected AnnotationSet adjustItem(IndexMap indexMap, AnnotationSet item) {
+    protected AnnotationSet adjustItem(AbstractIndexMap indexMap, AnnotationSet item) {
         return indexMap.adjust(item);
     }
 
     @Override
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         if (oldOffset != newOffset) {
-            indexMap.mapAnnotationSetOffset(oldOffset, newOffset);
+            sparseIndexMap.mapAnnotationSetOffset(oldOffset, newOffset);
         }
     }
 
     @Override
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
-        indexMap.markAnnotationSetDeleted(deletedOffset);
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
+        sparseIndexMap.markAnnotationSetDeleted(deletedOffset);
     }
 }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/AnnotationsDirectorySectionDiffAlgorithm.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/AnnotationsDirectorySectionDiffAlgorithm.java
index a72a15ca..5c4f9ffb 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/AnnotationsDirectorySectionDiffAlgorithm.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/AnnotationsDirectorySectionDiffAlgorithm.java
@@ -20,13 +20,14 @@
 import com.tencent.tinker.android.dex.Dex;
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 /**
  * Created by tangyinsheng on 2016/6/30.
  */
 public class AnnotationsDirectorySectionDiffAlgorithm extends DexSectionDiffAlgorithm<AnnotationsDirectory> {
-    public AnnotationsDirectorySectionDiffAlgorithm(Dex oldDex, Dex newDex, IndexMap oldToNewIndexMap, IndexMap oldToPatchedIndexMap, IndexMap newToPatchedIndexMap, IndexMap selfIndexMapForSkip) {
+    public AnnotationsDirectorySectionDiffAlgorithm(Dex oldDex, Dex newDex, SparseIndexMap oldToNewIndexMap, SparseIndexMap oldToPatchedIndexMap, SparseIndexMap newToPatchedIndexMap, SparseIndexMap selfIndexMapForSkip) {
         super(oldDex, newDex, oldToNewIndexMap, oldToPatchedIndexMap, newToPatchedIndexMap, selfIndexMapForSkip);
     }
 
@@ -46,19 +47,19 @@ protected int getItemSize(AnnotationsDirectory item) {
     }
 
     @Override
-    protected AnnotationsDirectory adjustItem(IndexMap indexMap, AnnotationsDirectory item) {
+    protected AnnotationsDirectory adjustItem(AbstractIndexMap indexMap, AnnotationsDirectory item) {
         return indexMap.adjust(item);
     }
 
     @Override
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         if (oldOffset != newOffset) {
-            indexMap.mapAnnotationsDirectoryOffset(oldOffset, newOffset);
+            sparseIndexMap.mapAnnotationsDirectoryOffset(oldOffset, newOffset);
         }
     }
 
     @Override
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
-        indexMap.markAnnotationsDirectoryDeleted(deletedOffset);
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
+        sparseIndexMap.markAnnotationsDirectoryDeleted(deletedOffset);
     }
 }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/ClassDataSectionDiffAlgorithm.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/ClassDataSectionDiffAlgorithm.java
index addf7b0d..e835b6b9 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/ClassDataSectionDiffAlgorithm.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/ClassDataSectionDiffAlgorithm.java
@@ -21,7 +21,8 @@
 import com.tencent.tinker.android.dex.SizeOf;
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 import java.util.Collection;
 import java.util.HashSet;
@@ -33,7 +34,7 @@
 public class ClassDataSectionDiffAlgorithm extends DexSectionDiffAlgorithm<ClassData> {
     private Set<Integer> offsetOfClassDataToRemoveSet = new HashSet<>();
 
-    public ClassDataSectionDiffAlgorithm(Dex oldDex, Dex newDex, IndexMap oldToNewIndexMap, IndexMap oldToPatchedIndexMap, IndexMap newToPatchedIndexMap, IndexMap selfIndexMapForSkip) {
+    public ClassDataSectionDiffAlgorithm(Dex oldDex, Dex newDex, SparseIndexMap oldToNewIndexMap, SparseIndexMap oldToPatchedIndexMap, SparseIndexMap newToPatchedIndexMap, SparseIndexMap selfIndexMapForSkip) {
         super(oldDex, newDex, oldToNewIndexMap, oldToPatchedIndexMap, newToPatchedIndexMap, selfIndexMapForSkip);
     }
 
@@ -62,7 +63,7 @@ protected int getItemSize(ClassData item) {
     }
 
     @Override
-    protected ClassData adjustItem(IndexMap indexMap, ClassData item) {
+    protected ClassData adjustItem(AbstractIndexMap indexMap, ClassData item) {
         return indexMap.adjust(item);
     }
 
@@ -78,14 +79,14 @@ protected boolean shouldSkipInNewDex(ClassData newItem) {
     }
 
     @Override
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         if (oldOffset != newOffset) {
-            indexMap.mapClassDataOffset(oldOffset, newOffset);
+            sparseIndexMap.mapClassDataOffset(oldOffset, newOffset);
         }
     }
 
     @Override
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
-        indexMap.markClassDataDeleted(deletedOffset);
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
+        sparseIndexMap.markClassDataDeleted(deletedOffset);
     }
 }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/ClassDefSectionDiffAlgorithm.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/ClassDefSectionDiffAlgorithm.java
index ebb558c7..8d8c8867 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/ClassDefSectionDiffAlgorithm.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/ClassDefSectionDiffAlgorithm.java
@@ -21,7 +21,8 @@
 import com.tencent.tinker.android.dex.SizeOf;
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 import java.util.Collection;
 import java.util.HashSet;
@@ -33,7 +34,7 @@
 public class ClassDefSectionDiffAlgorithm extends DexSectionDiffAlgorithm<ClassDef> {
     private Set<Integer> typeIdOfClassDefToRemoveSet = new HashSet<>();
 
-    public ClassDefSectionDiffAlgorithm(Dex oldDex, Dex newDex, IndexMap oldToNewIndexMap, IndexMap oldToPatchedIndexMap, IndexMap newToPatchedIndexMap, IndexMap selfIndexMapForSkip) {
+    public ClassDefSectionDiffAlgorithm(Dex oldDex, Dex newDex, SparseIndexMap oldToNewIndexMap, SparseIndexMap oldToPatchedIndexMap, SparseIndexMap newToPatchedIndexMap, SparseIndexMap selfIndexMapForSkip) {
         super(oldDex, newDex, oldToNewIndexMap, oldToPatchedIndexMap, newToPatchedIndexMap, selfIndexMapForSkip);
     }
 
@@ -67,7 +68,7 @@ protected int getItemSize(ClassDef item) {
     }
 
     @Override
-    protected ClassDef adjustItem(IndexMap indexMap, ClassDef item) {
+    protected ClassDef adjustItem(AbstractIndexMap indexMap, ClassDef item) {
         return indexMap.adjust(item);
     }
 }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/CodeSectionDiffAlgorithm.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/CodeSectionDiffAlgorithm.java
index 2672f9ca..7a4e24c2 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/CodeSectionDiffAlgorithm.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/CodeSectionDiffAlgorithm.java
@@ -20,13 +20,14 @@
 import com.tencent.tinker.android.dex.Dex;
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 /**
  * Created by tangyinsheng on 2016/6/30.
  */
 public class CodeSectionDiffAlgorithm extends DexSectionDiffAlgorithm<Code> {
-    public CodeSectionDiffAlgorithm(Dex oldDex, Dex newDex, IndexMap oldToNewIndexMap, IndexMap oldToPatchedIndexMap, IndexMap newToPatchedIndexMap, IndexMap selfIndexMapForSkip) {
+    public CodeSectionDiffAlgorithm(Dex oldDex, Dex newDex, SparseIndexMap oldToNewIndexMap, SparseIndexMap oldToPatchedIndexMap, SparseIndexMap newToPatchedIndexMap, SparseIndexMap selfIndexMapForSkip) {
         super(oldDex, newDex, oldToNewIndexMap, oldToPatchedIndexMap, newToPatchedIndexMap, selfIndexMapForSkip);
     }
 
@@ -46,19 +47,19 @@ protected int getItemSize(Code item) {
     }
 
     @Override
-    protected Code adjustItem(IndexMap indexMap, Code item) {
+    protected Code adjustItem(AbstractIndexMap indexMap, Code item) {
         return indexMap.adjust(item);
     }
 
     @Override
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         if (oldOffset != newOffset) {
-            indexMap.mapCodeOffset(oldOffset, newOffset);
+            sparseIndexMap.mapCodeOffset(oldOffset, newOffset);
         }
     }
 
     @Override
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
-        indexMap.markCodeDeleted(deletedOffset);
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
+        sparseIndexMap.markCodeDeleted(deletedOffset);
     }
 }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/DebugInfoItemSectionDiffAlgorithm.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/DebugInfoItemSectionDiffAlgorithm.java
index 5c329203..c5135ba7 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/DebugInfoItemSectionDiffAlgorithm.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/DebugInfoItemSectionDiffAlgorithm.java
@@ -20,13 +20,14 @@
 import com.tencent.tinker.android.dex.Dex;
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 /**
  * Created by tangyinsheng on 2016/6/30.
  */
 public class DebugInfoItemSectionDiffAlgorithm extends DexSectionDiffAlgorithm<DebugInfoItem> {
-    public DebugInfoItemSectionDiffAlgorithm(Dex oldDex, Dex newDex, IndexMap oldToNewIndexMap, IndexMap oldToPatchedIndexMap, IndexMap newToPatchedIndexMap, IndexMap selfIndexMapForSkip) {
+    public DebugInfoItemSectionDiffAlgorithm(Dex oldDex, Dex newDex, SparseIndexMap oldToNewIndexMap, SparseIndexMap oldToPatchedIndexMap, SparseIndexMap newToPatchedIndexMap, SparseIndexMap selfIndexMapForSkip) {
         super(oldDex, newDex, oldToNewIndexMap, oldToPatchedIndexMap, newToPatchedIndexMap, selfIndexMapForSkip);
     }
 
@@ -46,19 +47,19 @@ protected int getItemSize(DebugInfoItem item) {
     }
 
     @Override
-    protected DebugInfoItem adjustItem(IndexMap indexMap, DebugInfoItem item) {
+    protected DebugInfoItem adjustItem(AbstractIndexMap indexMap, DebugInfoItem item) {
         return indexMap.adjust(item);
     }
 
     @Override
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         if (oldOffset != newOffset) {
-            indexMap.mapDebugInfoItemOffset(oldOffset, newOffset);
+            sparseIndexMap.mapDebugInfoItemOffset(oldOffset, newOffset);
         }
     }
 
     @Override
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
-        indexMap.markDebugInfoItemDeleted(deletedOffset);
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
+        sparseIndexMap.markDebugInfoItemDeleted(deletedOffset);
     }
 }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/DexSectionDiffAlgorithm.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/DexSectionDiffAlgorithm.java
index 9c3f9671..75cd2e7f 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/DexSectionDiffAlgorithm.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/DexSectionDiffAlgorithm.java
@@ -22,8 +22,9 @@
 import com.tencent.tinker.android.dex.TableOfContents.Section.Item;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
 import com.tencent.tinker.android.dex.util.CompareUtils;
-import com.tencent.tinker.android.dx.util.IndexMap;
 import com.tencent.tinker.commons.dexpatcher.struct.PatchOperation;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 import java.util.AbstractMap;
 import java.util.ArrayList;
@@ -43,24 +44,24 @@
     protected final Dex oldDex;
     protected final Dex newDex;
     /**
-     * IndexMap for mapping items between old dex and new dex.
+     * SparseIndexMap for mapping items between old dex and new dex.
      * e.g. item.oldIndex => item.newIndex
      */
-    private final IndexMap oldToNewIndexMap;
+    private final SparseIndexMap oldToNewIndexMap;
     /**
-     * IndexMap for mapping items between old dex and patched dex.
+     * SparseIndexMap for mapping items between old dex and patched dex.
      * e.g. item.oldIndex => item.patchedIndex
      */
-    private final IndexMap oldToPatchedIndexMap;
+    private final SparseIndexMap oldToPatchedIndexMap;
     /**
-     * IndexMap for mapping items between new dex and patched dex.
+     * SparseIndexMap for mapping items between new dex and patched dex.
      * e.g. item.newIndex => item.newIndexInPatchedDex
      */
-    private final IndexMap newToPatchedIndexMap;
+    private final SparseIndexMap newToPatchedIndexMap;
     /**
-     * IndexMap for mapping items in new dex when skip items.
+     * SparseIndexMap for mapping items in new dex when skip items.
      */
-    private final IndexMap selfIndexMapForSkip;
+    private final SparseIndexMap selfIndexMapForSkip;
     private final List<PatchOperation<T>> patchOperationList;
     private final Map<Integer, PatchOperation<T>> indexToDelOperationMap = new HashMap<>();
     private final Map<Integer, PatchOperation<T>> indexToAddOperationMap = new HashMap<>();
@@ -118,10 +119,10 @@ public int compare(PatchOperation<T> o1, PatchOperation<T> o2) {
     public DexSectionDiffAlgorithm(
             Dex oldDex,
             Dex newDex,
-            IndexMap oldToNewIndexMap,
-            IndexMap oldToPatchedIndexMap,
-            IndexMap newToPatchedIndexMap,
-            IndexMap selfIndexMapForSkip
+            SparseIndexMap oldToNewIndexMap,
+            SparseIndexMap oldToPatchedIndexMap,
+            SparseIndexMap newToPatchedIndexMap,
+            SparseIndexMap selfIndexMapForSkip
     ) {
         this.oldDex = oldDex;
         this.newDex = newDex;
@@ -157,9 +158,9 @@ public int getPatchedSectionSize() {
     protected abstract int getItemSize(T item);
 
     /**
-     * Adjust {@code item} using specific {@code indexMap}
+     * Adjust {@code item} using specific {@code sparseIndexMap}
      */
-    protected T adjustItem(IndexMap indexMap, T item) {
+    protected T adjustItem(AbstractIndexMap indexMap, T item) {
         return item;
     }
 
@@ -171,26 +172,26 @@ protected boolean shouldSkipInNewDex(T newItem) {
     }
 
     /**
-     * Update index or offset mapping in {@code indexMap}.
+     * Update index or offset mapping in {@code sparseIndexMap}.
      */
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         // Should override by subclass if needed.
     }
 
     /**
-     * Mark deleted index or offset in {@code indexMap}.
+     * Mark deleted index or offset in {@code sparseIndexMap}.
      *
      * Here we mark deleted item for such a case like this:
      *   Item in DebugInfo section reference a string in StringData section
      *   by index X, while in patched dex, the referenced string is removed.
      *
-     * The {@code indexMap} must be aware of this case and return -1
+     * The {@code sparseIndexMap} must be aware of this case and return -1
      * instead of the original value X.
      *
      * Further more, the special value -1 is not chosen by our inspiration but
      * the definition of NO_INDEX in document of dex file format.
      */
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
         // Should override by subclass if needed.
     }
 
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/FieldIdSectionDiffAlgorithm.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/FieldIdSectionDiffAlgorithm.java
index f1751361..5511e264 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/FieldIdSectionDiffAlgorithm.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/FieldIdSectionDiffAlgorithm.java
@@ -21,13 +21,14 @@
 import com.tencent.tinker.android.dex.SizeOf;
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 /**
  * Created by tangyinsheng on 2016/6/30.
  */
 public class FieldIdSectionDiffAlgorithm extends DexSectionDiffAlgorithm<FieldId> {
-    public FieldIdSectionDiffAlgorithm(Dex oldDex, Dex newDex, IndexMap oldToNewIndexMap, IndexMap oldToPatchedIndexMap, IndexMap newToPatchedIndexMap, IndexMap selfIndexMapForSkip) {
+    public FieldIdSectionDiffAlgorithm(Dex oldDex, Dex newDex, SparseIndexMap oldToNewIndexMap, SparseIndexMap oldToPatchedIndexMap, SparseIndexMap newToPatchedIndexMap, SparseIndexMap selfIndexMapForSkip) {
         super(oldDex, newDex, oldToNewIndexMap, oldToPatchedIndexMap, newToPatchedIndexMap, selfIndexMapForSkip);
     }
 
@@ -47,19 +48,19 @@ protected int getItemSize(FieldId item) {
     }
 
     @Override
-    protected FieldId adjustItem(IndexMap indexMap, FieldId item) {
+    protected FieldId adjustItem(AbstractIndexMap indexMap, FieldId item) {
         return indexMap.adjust(item);
     }
 
     @Override
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         if (oldIndex != newIndex) {
-            indexMap.mapFieldIds(oldIndex, newIndex);
+            sparseIndexMap.mapFieldIds(oldIndex, newIndex);
         }
     }
 
     @Override
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
-        indexMap.markFieldIdDeleted(deletedIndex);
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
+        sparseIndexMap.markFieldIdDeleted(deletedIndex);
     }
 }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/MethodIdSectionDiffAlgorithm.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/MethodIdSectionDiffAlgorithm.java
index 4456dacb..2320bed2 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/MethodIdSectionDiffAlgorithm.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/MethodIdSectionDiffAlgorithm.java
@@ -21,13 +21,14 @@
 import com.tencent.tinker.android.dex.SizeOf;
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 /**
  * Created by tangyinsheng on 2016/6/30.
  */
 public class MethodIdSectionDiffAlgorithm extends DexSectionDiffAlgorithm<MethodId> {
-    public MethodIdSectionDiffAlgorithm(Dex oldDex, Dex newDex, IndexMap oldToNewIndexMap, IndexMap oldToPatchedIndexMap, IndexMap newToPatchedIndexMap, IndexMap selfIndexMapForSkip) {
+    public MethodIdSectionDiffAlgorithm(Dex oldDex, Dex newDex, SparseIndexMap oldToNewIndexMap, SparseIndexMap oldToPatchedIndexMap, SparseIndexMap newToPatchedIndexMap, SparseIndexMap selfIndexMapForSkip) {
         super(oldDex, newDex, oldToNewIndexMap, oldToPatchedIndexMap, newToPatchedIndexMap, selfIndexMapForSkip);
     }
 
@@ -47,19 +48,19 @@ protected int getItemSize(MethodId item) {
     }
 
     @Override
-    protected MethodId adjustItem(IndexMap indexMap, MethodId item) {
+    protected MethodId adjustItem(AbstractIndexMap indexMap, MethodId item) {
         return indexMap.adjust(item);
     }
 
     @Override
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         if (oldIndex != newIndex) {
-            indexMap.mapMethodIds(oldIndex, newIndex);
+            sparseIndexMap.mapMethodIds(oldIndex, newIndex);
         }
     }
 
     @Override
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
-        indexMap.markMethodIdDeleted(deletedIndex);
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
+        sparseIndexMap.markMethodIdDeleted(deletedIndex);
     }
 }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/ProtoIdSectionDiffAlgorithm.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/ProtoIdSectionDiffAlgorithm.java
index fcec419b..aa495b5f 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/ProtoIdSectionDiffAlgorithm.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/ProtoIdSectionDiffAlgorithm.java
@@ -21,13 +21,14 @@
 import com.tencent.tinker.android.dex.SizeOf;
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 /**
  * Created by tangyinsheng on 2016/6/30.
  */
 public class ProtoIdSectionDiffAlgorithm extends DexSectionDiffAlgorithm<ProtoId> {
-    public ProtoIdSectionDiffAlgorithm(Dex oldDex, Dex newDex, IndexMap oldToNewIndexMap, IndexMap oldToPatchedIndexMap, IndexMap newToPatchedIndexMap, IndexMap selfIndexMapForSkip) {
+    public ProtoIdSectionDiffAlgorithm(Dex oldDex, Dex newDex, SparseIndexMap oldToNewIndexMap, SparseIndexMap oldToPatchedIndexMap, SparseIndexMap newToPatchedIndexMap, SparseIndexMap selfIndexMapForSkip) {
         super(oldDex, newDex, oldToNewIndexMap, oldToPatchedIndexMap, newToPatchedIndexMap, selfIndexMapForSkip);
     }
 
@@ -47,19 +48,19 @@ protected int getItemSize(ProtoId item) {
     }
 
     @Override
-    protected ProtoId adjustItem(IndexMap indexMap, ProtoId item) {
+    protected ProtoId adjustItem(AbstractIndexMap indexMap, ProtoId item) {
         return indexMap.adjust(item);
     }
 
     @Override
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         if (oldIndex != newIndex) {
-            indexMap.mapProtoIds(oldIndex, newIndex);
+            sparseIndexMap.mapProtoIds(oldIndex, newIndex);
         }
     }
 
     @Override
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
-        indexMap.markProtoIdDeleted(deletedIndex);
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
+        sparseIndexMap.markProtoIdDeleted(deletedIndex);
     }
 }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/StaticValueSectionDiffAlgorithm.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/StaticValueSectionDiffAlgorithm.java
index 51e7a223..974eadb8 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/StaticValueSectionDiffAlgorithm.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/StaticValueSectionDiffAlgorithm.java
@@ -20,13 +20,14 @@
 import com.tencent.tinker.android.dex.EncodedValue;
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 /**
  * Created by tangyinsheng on 2016/6/30.
  */
 public class StaticValueSectionDiffAlgorithm extends DexSectionDiffAlgorithm<EncodedValue> {
-    public StaticValueSectionDiffAlgorithm(Dex oldDex, Dex newDex, IndexMap oldToNewIndexMap, IndexMap oldToPatchedIndexMap, IndexMap newToPatchedIndexMap, IndexMap selfIndexMapForSkip) {
+    public StaticValueSectionDiffAlgorithm(Dex oldDex, Dex newDex, SparseIndexMap oldToNewIndexMap, SparseIndexMap oldToPatchedIndexMap, SparseIndexMap newToPatchedIndexMap, SparseIndexMap selfIndexMapForSkip) {
         super(oldDex, newDex, oldToNewIndexMap, oldToPatchedIndexMap, newToPatchedIndexMap, selfIndexMapForSkip);
     }
 
@@ -46,19 +47,19 @@ protected int getItemSize(EncodedValue item) {
     }
 
     @Override
-    protected EncodedValue adjustItem(IndexMap indexMap, EncodedValue item) {
+    protected EncodedValue adjustItem(AbstractIndexMap indexMap, EncodedValue item) {
         return indexMap.adjust(item);
     }
 
     @Override
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         if (oldOffset != newOffset) {
-            indexMap.mapStaticValuesOffset(oldOffset, newOffset);
+            sparseIndexMap.mapStaticValuesOffset(oldOffset, newOffset);
         }
     }
 
     @Override
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
-        indexMap.markStaticValuesDeleted(deletedOffset);
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
+        sparseIndexMap.markStaticValuesDeleted(deletedOffset);
     }
 }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/StringDataSectionDiffAlgorithm.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/StringDataSectionDiffAlgorithm.java
index e75a9c37..aed29a38 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/StringDataSectionDiffAlgorithm.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/StringDataSectionDiffAlgorithm.java
@@ -20,13 +20,13 @@
 import com.tencent.tinker.android.dex.StringData;
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 /**
  * Created by tangyinsheng on 2016/6/30.
  */
 public class StringDataSectionDiffAlgorithm extends DexSectionDiffAlgorithm<StringData> {
-    public StringDataSectionDiffAlgorithm(Dex oldDex, Dex newDex, IndexMap oldToNewIndexMap, IndexMap oldToPatchedIndexMap, IndexMap newToPatchedIndexMap, IndexMap selfIndexMapForSkip) {
+    public StringDataSectionDiffAlgorithm(Dex oldDex, Dex newDex, SparseIndexMap oldToNewIndexMap, SparseIndexMap oldToPatchedIndexMap, SparseIndexMap newToPatchedIndexMap, SparseIndexMap selfIndexMapForSkip) {
         super(oldDex, newDex, oldToNewIndexMap, oldToPatchedIndexMap, newToPatchedIndexMap, selfIndexMapForSkip);
     }
 
@@ -46,14 +46,14 @@ protected int getItemSize(StringData item) {
     }
 
     @Override
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         if (oldIndex != newIndex) {
-            indexMap.mapStringIds(oldIndex, newIndex);
+            sparseIndexMap.mapStringIds(oldIndex, newIndex);
         }
     }
 
     @Override
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
-        indexMap.markStringIdDeleted(deletedIndex);
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
+        sparseIndexMap.markStringIdDeleted(deletedIndex);
     }
 }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/TypeIdSectionDiffAlgorithm.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/TypeIdSectionDiffAlgorithm.java
index e9b3dd75..cdfe82bb 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/TypeIdSectionDiffAlgorithm.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/TypeIdSectionDiffAlgorithm.java
@@ -20,13 +20,14 @@
 import com.tencent.tinker.android.dex.SizeOf;
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 /**
  * Created by tangyinsheng on 2016/6/30.
  */
 public class TypeIdSectionDiffAlgorithm extends DexSectionDiffAlgorithm<Integer> {
-    public TypeIdSectionDiffAlgorithm(Dex oldDex, Dex newDex, IndexMap oldToNewIndexMap, IndexMap oldToPatchedIndexMap, IndexMap newToPatchedIndexMap, IndexMap selfIndexMapForSkip) {
+    public TypeIdSectionDiffAlgorithm(Dex oldDex, Dex newDex, SparseIndexMap oldToNewIndexMap, SparseIndexMap oldToPatchedIndexMap, SparseIndexMap newToPatchedIndexMap, SparseIndexMap selfIndexMapForSkip) {
         super(oldDex, newDex, oldToNewIndexMap, oldToPatchedIndexMap, newToPatchedIndexMap, selfIndexMapForSkip);
     }
 
@@ -46,19 +47,19 @@ protected int getItemSize(Integer item) {
     }
 
     @Override
-    protected Integer adjustItem(IndexMap indexMap, Integer item) {
+    protected Integer adjustItem(AbstractIndexMap indexMap, Integer item) {
         return indexMap.adjustStringIndex(item);
     }
 
     @Override
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         if (oldIndex != newIndex) {
-            indexMap.mapTypeIds(oldIndex, newIndex);
+            sparseIndexMap.mapTypeIds(oldIndex, newIndex);
         }
     }
 
     @Override
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
-        indexMap.markTypeIdDeleted(deletedIndex);
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
+        sparseIndexMap.markTypeIdDeleted(deletedIndex);
     }
 }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/TypeListSectionDiffAlgorithm.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/TypeListSectionDiffAlgorithm.java
index 2562600e..3ce0061e 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/TypeListSectionDiffAlgorithm.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/TypeListSectionDiffAlgorithm.java
@@ -20,13 +20,14 @@
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.TypeList;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 /**
  * Created by tangyinsheng on 2016/6/30.
  */
 public class TypeListSectionDiffAlgorithm extends DexSectionDiffAlgorithm<TypeList> {
-    public TypeListSectionDiffAlgorithm(Dex oldDex, Dex newDex, IndexMap oldToNewIndexMap, IndexMap oldToPatchedIndexMap, IndexMap newToPatchedIndexMap, IndexMap selfIndexMapForSkip) {
+    public TypeListSectionDiffAlgorithm(Dex oldDex, Dex newDex, SparseIndexMap oldToNewIndexMap, SparseIndexMap oldToPatchedIndexMap, SparseIndexMap newToPatchedIndexMap, SparseIndexMap selfIndexMapForSkip) {
         super(oldDex, newDex, oldToNewIndexMap, oldToPatchedIndexMap, newToPatchedIndexMap, selfIndexMapForSkip);
     }
 
@@ -46,19 +47,19 @@ protected int getItemSize(TypeList item) {
     }
 
     @Override
-    protected TypeList adjustItem(IndexMap indexMap, TypeList item) {
+    protected TypeList adjustItem(AbstractIndexMap indexMap, TypeList item) {
         return indexMap.adjust(item);
     }
 
     @Override
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         if (oldOffset != newOffset) {
-            indexMap.mapTypeListOffset(oldOffset, newOffset);
+            sparseIndexMap.mapTypeListOffset(oldOffset, newOffset);
         }
     }
 
     @Override
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
-        indexMap.markTypeListDeleted(deletedOffset);
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
+        sparseIndexMap.markTypeListDeleted(deletedOffset);
     }
 }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/ChangedClassesDexClassInfoCollector.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/ChangedClassesDexClassInfoCollector.java
new file mode 100644
index 00000000..6fb11914
--- /dev/null
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/ChangedClassesDexClassInfoCollector.java
@@ -0,0 +1,252 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.build.dexpatcher.util;
+
+import com.tencent.tinker.android.dex.ClassData;
+import com.tencent.tinker.android.dex.ClassDef;
+import com.tencent.tinker.android.dex.Code;
+import com.tencent.tinker.android.dex.Dex;
+import com.tencent.tinker.android.dex.FieldId;
+import com.tencent.tinker.android.dex.MethodId;
+import com.tencent.tinker.android.dex.ProtoId;
+import com.tencent.tinker.android.dx.instruction.InstructionCodec;
+import com.tencent.tinker.android.dx.instruction.InstructionReader;
+import com.tencent.tinker.android.dx.instruction.InstructionVisitor;
+import com.tencent.tinker.android.dx.instruction.ShortArrayCodeInput;
+import com.tencent.tinker.build.util.DexClassesComparator;
+import com.tencent.tinker.commons.dexpatcher.DexPatcherLogger;
+
+import java.io.EOFException;
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.Set;
+
+import static com.tencent.tinker.build.util.DexClassesComparator.DexClassInfo;
+import static com.tencent.tinker.build.util.DexClassesComparator.DexGroup;
+
+/**
+ * Created by tangyinsheng on 2017/2/26.
+ */
+
+public class ChangedClassesDexClassInfoCollector {
+    private static final String TAG = "ChangedClassesDexClassInfoCollector";
+
+    private static final DexPatcherLogger logger = new DexPatcherLogger();
+    private final Set<String> excludedClassPatterns = new HashSet<>();
+    private boolean includeRefererToRefererAffectedClasses = false;
+
+    public ChangedClassesDexClassInfoCollector setExcludedClassPatterns(Collection<String> loaderClassPatterns) {
+        this.excludedClassPatterns.clear();
+        this.excludedClassPatterns.addAll(loaderClassPatterns);
+        return this;
+    }
+
+    public ChangedClassesDexClassInfoCollector clearExcludedClassPatterns() {
+        this.excludedClassPatterns.clear();
+        return this;
+    }
+
+    public ChangedClassesDexClassInfoCollector setLogger(DexPatcherLogger.IDexPatcherLogger loggerImpl) {
+        logger.setLoggerImpl(loggerImpl);
+        return this;
+    }
+
+    public ChangedClassesDexClassInfoCollector setIncludeRefererToRefererAffectedClasses(boolean enabled) {
+        this.includeRefererToRefererAffectedClasses = enabled;
+        return this;
+    }
+
+    public Set<DexClassInfo> doCollect(DexGroup oldDexGroup, DexGroup newDexGroup) {
+        final Set<String> classDescsInResult = new HashSet<>();
+        final Set<DexClassInfo> result = new HashSet<>();
+
+        DexClassesComparator dexClassCmptor = new DexClassesComparator("*");
+        dexClassCmptor.setCompareMode(DexClassesComparator.COMPARE_MODE_NORMAL);
+        dexClassCmptor.setIgnoredRemovedClassDescPattern(excludedClassPatterns);
+        dexClassCmptor.setLogger(logger.getLoggerImpl());
+        dexClassCmptor.startCheck(oldDexGroup, newDexGroup);
+
+        // So far we collected infos of all added, changed, and deleted classes.
+        result.addAll(dexClassCmptor.getAddedClassInfos());
+
+        final Collection<DexClassInfo[]> changedClassInfos = dexClassCmptor.getChangedClassDescToInfosMap().values();
+
+        for (DexClassInfo[] oldAndNewInfoPair : changedClassInfos) {
+            final DexClassInfo newClassInfo = oldAndNewInfoPair[1];
+
+            logger.i(TAG, "Add class %s to changed classes dex.", newClassInfo.classDesc);
+            result.add(newClassInfo);
+        }
+
+        for (DexClassInfo classInfo : result) {
+            classDescsInResult.add(classInfo.classDesc);
+        }
+
+        if (includeRefererToRefererAffectedClasses) {
+            // Then we also need to add classes who refer to classes with referrer
+            // affected changes to the result. (referrer affected change means the changes
+            // that may cause referrer refer to wrong target.)
+            dexClassCmptor.setCompareMode(DexClassesComparator.COMPARE_MODE_REFERRER_AFFECTED_CHANGE_ONLY);
+            dexClassCmptor.startCheck(oldDexGroup, newDexGroup);
+
+            Set<String> referrerAffectedChangedClassDescs = dexClassCmptor.getChangedClassDescToInfosMap().keySet();
+            Set<DexClassInfo> oldClassInfos = oldDexGroup.getClassInfosInDexesWithDuplicateCheck();
+
+            for (DexClassInfo oldClassInfo : oldClassInfos) {
+                if (!classDescsInResult.contains(oldClassInfo.classDesc)
+                        && isClassReferToAnyClasses(oldClassInfo, referrerAffectedChangedClassDescs)) {
+                    logger.i(TAG, "Add class %s in old dex to changed classes dex since it is affected by modified referee.", oldClassInfo.classDesc);
+                    result.add(oldClassInfo);
+                }
+            }
+        }
+
+        return result;
+    }
+
+    private boolean isClassReferToAnyClasses(DexClassInfo classInfo, Set<String> refereeClassDescs) {
+        if (classInfo.classDef.classDataOffset == ClassDef.NO_OFFSET) {
+            return false;
+        }
+        ClassData classData = classInfo.owner.readClassData(classInfo.classDef);
+        for (ClassData.Method method : classData.directMethods) {
+            if (isMethodReferToAnyClasses(classInfo, method, refereeClassDescs)) {
+                return true;
+            }
+        }
+        for (ClassData.Method method : classData.virtualMethods) {
+            if (isMethodReferToAnyClasses(classInfo, method, refereeClassDescs)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private boolean isMethodReferToAnyClasses(DexClassInfo classInfo, ClassData.Method method, Set<String> refereeClassDescs) {
+        if (method.codeOffset == ClassDef.NO_OFFSET) {
+            return false;
+        }
+        Code methodCode = classInfo.owner.readCode(method);
+        InstructionReader ir = new InstructionReader(new ShortArrayCodeInput(methodCode.instructions));
+        ReferToClassesCheckVisitor rtcv = new ReferToClassesCheckVisitor(classInfo.owner, method, refereeClassDescs);
+        try {
+            ir.accept(rtcv);
+        } catch (EOFException e) {
+            // Should not be here.
+        }
+        return rtcv.isReferToAnyRefereeClasses;
+    }
+
+    private static class ReferToClassesCheckVisitor extends InstructionVisitor {
+        private final Dex owner;
+        private final ClassData.Method method;
+        private final Collection<String> refereeClassDescs;
+
+        private boolean isReferToAnyRefereeClasses = false;
+
+        ReferToClassesCheckVisitor(Dex owner, ClassData.Method method, Collection<String> refereeClassDescs) {
+            super(null);
+            this.owner = owner;
+            this.method = method;
+            this.refereeClassDescs = refereeClassDescs;
+        }
+
+        @Override
+        public void visitZeroRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal) {
+            processIndexByType(index, indexType);
+        }
+
+        @Override
+        public void visitOneRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a) {
+            processIndexByType(index, indexType);
+        }
+
+        @Override
+        public void visitTwoRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int b) {
+            processIndexByType(index, indexType);
+        }
+
+        @Override
+        public void visitThreeRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int b, int c) {
+            processIndexByType(index, indexType);
+        }
+
+        @Override
+        public void visitFourRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int b, int c, int d) {
+            processIndexByType(index, indexType);
+        }
+
+        @Override
+        public void visitFiveRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int b, int c, int d, int e) {
+            processIndexByType(index, indexType);
+        }
+
+        @Override
+        public void visitRegisterRangeInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int registerCount) {
+            processIndexByType(index, indexType);
+        }
+
+        private void processIndexByType(int index, int indexType) {
+            String typeName = null;
+            String refInfoInLog = null;
+            switch (indexType) {
+                case InstructionCodec.INDEX_TYPE_TYPE_REF: {
+                    typeName = owner.typeNames().get(index);
+                    refInfoInLog = "init referrer-affected class";
+                    break;
+                }
+                case InstructionCodec.INDEX_TYPE_FIELD_REF: {
+                    final FieldId fieldId = owner.fieldIds().get(index);
+                    typeName = owner.typeNames().get(fieldId.declaringClassIndex);
+                    refInfoInLog = "referencing to field: " + owner.strings().get(fieldId.nameIndex);
+                    break;
+                }
+                case InstructionCodec.INDEX_TYPE_METHOD_REF: {
+                    final MethodId methodId = owner.methodIds().get(index);
+                    typeName = owner.typeNames().get(methodId.declaringClassIndex);
+                    refInfoInLog = "invoking method: " + getMethodProtoTypeStr(methodId);
+                    break;
+                }
+            }
+            if (typeName != null && refereeClassDescs.contains(typeName)) {
+                MethodId methodId = owner.methodIds().get(method.methodIndex);
+                logger.i(
+                        TAG,
+                        "Method %s in class %s referenced referrer-affected class %s by %s",
+                        getMethodProtoTypeStr(methodId),
+                        owner.typeNames().get(methodId.declaringClassIndex),
+                        typeName,
+                        refInfoInLog
+                );
+                isReferToAnyRefereeClasses = true;
+            }
+        }
+
+        private String getMethodProtoTypeStr(MethodId methodId) {
+            StringBuilder strBuilder = new StringBuilder();
+            strBuilder.append(owner.strings().get(methodId.nameIndex));
+            ProtoId protoId = owner.protoIds().get(methodId.protoIndex);
+            strBuilder.append('(');
+            short[] paramTypeIds = owner.parameterTypeIndicesFromMethodId(methodId);
+            for (short typeId : paramTypeIds) {
+                strBuilder.append(owner.typeNames().get(typeId));
+            }
+            strBuilder.append(')').append(owner.typeNames().get(protoId.returnTypeIndex));
+            return strBuilder.toString();
+        }
+    }
+}
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/ClassReferringInsnVisitor.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/ClassReferringInsnVisitor.java
deleted file mode 100644
index af443b81..00000000
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/ClassReferringInsnVisitor.java
+++ /dev/null
@@ -1,136 +0,0 @@
-/*
- * Tencent is pleased to support the open source community by making Tinker available.
- *
- * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
- *
- * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- *
- * https://opensource.org/licenses/BSD-3-Clause
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is
- * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
- * either express or implied. See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.tencent.tinker.build.dexpatcher.util;
-
-import com.tencent.tinker.android.dex.ClassData;
-import com.tencent.tinker.android.dex.Dex;
-import com.tencent.tinker.android.dex.FieldId;
-import com.tencent.tinker.android.dex.MethodId;
-import com.tencent.tinker.android.dex.ProtoId;
-import com.tencent.tinker.android.dx.instruction.InstructionCodec;
-import com.tencent.tinker.android.dx.instruction.InstructionVisitor;
-import com.tencent.tinker.commons.dexpatcher.DexPatcherLogger;
-
-import java.util.Collection;
-
-/**
- * Created by tangyinsheng on 2016/10/8.
- */
-
-public class ClassReferringInsnVisitor extends InstructionVisitor {
-    private static final String TAG = "ClassReferringInsnVisitor";
-
-    private final Dex methodOwner;
-    private final ClassData.Method method;
-    private final Collection<String> classDescsToCheck;
-    private final DexPatcherLogger logger;
-
-    public boolean isMethodReferencedToAnyProvidedClasses;
-
-    ClassReferringInsnVisitor(Dex methodOwner, ClassData.Method method, Collection<String> classDescsToCheck, DexPatcherLogger logger) {
-        super(null);
-        this.methodOwner = methodOwner;
-        this.method = method;
-        this.classDescsToCheck = classDescsToCheck;
-        this.logger = logger;
-        this.isMethodReferencedToAnyProvidedClasses = false;
-    }
-
-    @Override
-    public void visitZeroRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal) {
-        processIndexByType(index, indexType);
-    }
-
-    @Override
-    public void visitOneRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a) {
-        processIndexByType(index, indexType);
-    }
-
-    @Override
-    public void visitTwoRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int b) {
-        processIndexByType(index, indexType);
-    }
-
-    @Override
-    public void visitThreeRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int b, int c) {
-        processIndexByType(index, indexType);
-    }
-
-    @Override
-    public void visitFourRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int b, int c, int d) {
-        processIndexByType(index, indexType);
-    }
-
-    @Override
-    public void visitFiveRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int b, int c, int d, int e) {
-        processIndexByType(index, indexType);
-    }
-
-    @Override
-    public void visitRegisterRangeInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int registerCount) {
-        processIndexByType(index, indexType);
-    }
-
-    private void processIndexByType(int index, int indexType) {
-        String typeName = null;
-        String refInfoInLog = null;
-        switch (indexType) {
-            case InstructionCodec.INDEX_TYPE_TYPE_REF: {
-                typeName = methodOwner.typeNames().get(index);
-                refInfoInLog = "init class";
-                break;
-            }
-            case InstructionCodec.INDEX_TYPE_FIELD_REF: {
-                final FieldId fieldId = methodOwner.fieldIds().get(index);
-                typeName = methodOwner.typeNames().get(fieldId.declaringClassIndex);
-                refInfoInLog = "referencing to field: " + methodOwner.strings().get(fieldId.nameIndex);
-                break;
-            }
-            case InstructionCodec.INDEX_TYPE_METHOD_REF: {
-                final MethodId methodId = methodOwner.methodIds().get(index);
-                typeName = methodOwner.typeNames().get(methodId.declaringClassIndex);
-                refInfoInLog = "invoking method: " + getMethodProtoTypeStr(methodId);
-                break;
-            }
-        }
-        if (typeName != null && classDescsToCheck.contains(typeName)) {
-            MethodId methodId = methodOwner.methodIds().get(method.methodIndex);
-            logger.i(
-                    TAG,
-                    "Method %s in class %s referenced class %s by %s",
-                    getMethodProtoTypeStr(methodId),
-                    methodOwner.typeNames().get(methodId.declaringClassIndex),
-                    typeName,
-                    refInfoInLog
-            );
-            isMethodReferencedToAnyProvidedClasses = true;
-        }
-    }
-
-    private String getMethodProtoTypeStr(MethodId methodId) {
-        StringBuilder strBuilder = new StringBuilder();
-        strBuilder.append(methodOwner.strings().get(methodId.nameIndex));
-        ProtoId protoId = methodOwner.protoIds().get(methodId.protoIndex);
-        strBuilder.append('(');
-        short[] paramTypeIds = methodOwner.parameterTypeIndicesFromMethodId(methodId);
-        for (short typeId : paramTypeIds) {
-            strBuilder.append(methodOwner.typeNames().get(typeId));
-        }
-        strBuilder.append(')').append(methodOwner.typeNames().get(protoId.returnTypeIndex));
-        return strBuilder.toString();
-    }
-}
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/OffsetToIndexConverter.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/OffsetToIndexConverter.java
deleted file mode 100644
index 80673a8a..00000000
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/OffsetToIndexConverter.java
+++ /dev/null
@@ -1,187 +0,0 @@
-/*
- * Tencent is pleased to support the open source community by making Tinker available.
- *
- * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
- *
- * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- *
- * https://opensource.org/licenses/BSD-3-Clause
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is
- * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
- * either express or implied. See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.tencent.tinker.build.dexpatcher.util;
-
-import com.tencent.tinker.android.dex.Dex;
-
-import java.util.HashMap;
-import java.util.Map;
-
-/**
- * Created by tangyinsheng on 2016/9/11.
- */
-public final class OffsetToIndexConverter {
-    private final Map<Integer, Integer> typeListOffsetToIndexMap = new HashMap<>();
-    private final Map<Integer, Integer> classDataOffsetToIndexMap = new HashMap<>();
-    private final Map<Integer, Integer> encodedArrayOffsetToIndexMap = new HashMap<>();
-    private final Map<Integer, Integer> annotationOffsetToIndexMap = new HashMap<>();
-    private final Map<Integer, Integer> annotationSetOffsetToIndexMap = new HashMap<>();
-    private final Map<Integer, Integer> annotationSetRefListOffsetToIndexMap = new HashMap<>();
-    private final Map<Integer, Integer> annotationsDirectoryOffsetToIndexMap = new HashMap<>();
-    private final Map<Integer, Integer> codeOffsetToIndexMap = new HashMap<>();
-    private final Map<Integer, Integer> debugInfoItemOffsetToIndexMap = new HashMap<>();
-
-    public OffsetToIndexConverter(Dex dex) {
-        if (dex == null) {
-            throw new IllegalArgumentException("dex is null.");
-        }
-
-        if (dex.getTableOfContents().typeLists.exists()) {
-            Dex.Section typeListSec = dex.openSection(dex.getTableOfContents().typeLists);
-            int typeListCount = dex.getTableOfContents().typeLists.size;
-            for (int i = 0; i < typeListCount; ++i) {
-                typeListOffsetToIndexMap.put(typeListSec.readTypeList().off, i);
-            }
-        }
-
-        if (dex.getTableOfContents().classDatas.exists()) {
-            Dex.Section classDataSec = dex.openSection(dex.getTableOfContents().classDatas);
-            int classDataCount = dex.getTableOfContents().classDatas.size;
-            for (int i = 0; i < classDataCount; ++i) {
-                classDataOffsetToIndexMap.put(classDataSec.readClassData().off, i);
-            }
-        }
-
-        if (dex.getTableOfContents().encodedArrays.exists()) {
-            Dex.Section encodedArraySec = dex.openSection(dex.getTableOfContents().encodedArrays);
-            int encodedArrayCount = dex.getTableOfContents().encodedArrays.size;
-            for (int i = 0; i < encodedArrayCount; ++i) {
-                encodedArrayOffsetToIndexMap.put(encodedArraySec.readEncodedArray().off, i);
-            }
-        }
-
-        if (dex.getTableOfContents().annotations.exists()) {
-            Dex.Section annotationSec = dex.openSection(dex.getTableOfContents().annotations);
-            int annotationCount = dex.getTableOfContents().annotations.size;
-            for (int i = 0; i < annotationCount; ++i) {
-                annotationOffsetToIndexMap.put(annotationSec.readAnnotation().off, i);
-            }
-        }
-
-        if (dex.getTableOfContents().annotationSets.exists()) {
-            Dex.Section annotationSetSec = dex.openSection(dex.getTableOfContents().annotationSets);
-            int annotationSetCount = dex.getTableOfContents().annotationSets.size;
-            for (int i = 0; i < annotationSetCount; ++i) {
-                annotationSetOffsetToIndexMap.put(annotationSetSec.readAnnotationSet().off, i);
-            }
-        }
-
-        if (dex.getTableOfContents().annotationSetRefLists.exists()) {
-            Dex.Section annotationSetRefListSec = dex.openSection(dex.getTableOfContents().annotationSetRefLists);
-            int annotationSetRefListCount = dex.getTableOfContents().annotationSetRefLists.size;
-            for (int i = 0; i < annotationSetRefListCount; ++i) {
-                annotationSetRefListOffsetToIndexMap.put(annotationSetRefListSec.readAnnotationSetRefList().off, i);
-            }
-        }
-
-        if (dex.getTableOfContents().annotationsDirectories.exists()) {
-            Dex.Section annotationsDirectorySec = dex.openSection(dex.getTableOfContents().annotationsDirectories);
-            int annotationsDirectoryCount = dex.getTableOfContents().annotationsDirectories.size;
-            for (int i = 0; i < annotationsDirectoryCount; ++i) {
-                annotationsDirectoryOffsetToIndexMap.put(annotationsDirectorySec.readAnnotationsDirectory().off, i);
-            }
-        }
-
-        if (dex.getTableOfContents().codes.exists()) {
-            Dex.Section codeSec = dex.openSection(dex.getTableOfContents().codes);
-            int codeCount = dex.getTableOfContents().codes.size;
-            for (int i = 0; i < codeCount; ++i) {
-                codeOffsetToIndexMap.put(codeSec.readCode().off, i);
-            }
-        }
-
-        if (dex.getTableOfContents().debugInfos.exists()) {
-            Dex.Section debugInfoItemSec = dex.openSection(dex.getTableOfContents().debugInfos);
-            int debugInfoItemCount = dex.getTableOfContents().debugInfos.size;
-            for (int i = 0; i < debugInfoItemCount; ++i) {
-                debugInfoItemOffsetToIndexMap.put(debugInfoItemSec.readDebugInfoItem().off, i);
-            }
-        }
-    }
-
-    public int getTypeListIndexByOffset(int offset) {
-        if (typeListOffsetToIndexMap.containsKey(offset)) {
-            return typeListOffsetToIndexMap.get(offset);
-        } else {
-            throw new IllegalArgumentException("cannot find corresponding index of offset: " + offset);
-        }
-    }
-
-    public int getClassDataIndexByOffset(int offset) {
-        if (classDataOffsetToIndexMap.containsKey(offset)) {
-            return classDataOffsetToIndexMap.get(offset);
-        } else {
-            throw new IllegalArgumentException("cannot find corresponding index of offset: " + offset);
-        }
-    }
-
-    public int getEncodedArrayIndexByOffset(int offset) {
-        if (encodedArrayOffsetToIndexMap.containsKey(offset)) {
-            return encodedArrayOffsetToIndexMap.get(offset);
-        } else {
-            throw new IllegalArgumentException("cannot find corresponding index of offset: " + offset);
-        }
-    }
-
-    public int getAnnotationIndexByOffset(int offset) {
-        if (annotationOffsetToIndexMap.containsKey(offset)) {
-            return annotationOffsetToIndexMap.get(offset);
-        } else {
-            throw new IllegalArgumentException("cannot find corresponding index of offset: " + offset);
-        }
-    }
-
-    public int getAnnotationSetIndexByOffset(int offset) {
-        if (annotationSetOffsetToIndexMap.containsKey(offset)) {
-            return annotationSetOffsetToIndexMap.get(offset);
-        } else {
-            throw new IllegalArgumentException("cannot find corresponding index of offset: " + offset);
-        }
-    }
-
-    public int getAnnotationSetRefListIndexByOffset(int offset) {
-        if (annotationSetRefListOffsetToIndexMap.containsKey(offset)) {
-            return annotationSetRefListOffsetToIndexMap.get(offset);
-        } else {
-            throw new IllegalArgumentException("cannot find corresponding index of offset: " + offset);
-        }
-    }
-
-    public int getAnnotationsDirectoryIndexByOffset(int offset) {
-        if (annotationsDirectoryOffsetToIndexMap.containsKey(offset)) {
-            return annotationsDirectoryOffsetToIndexMap.get(offset);
-        } else {
-            throw new IllegalArgumentException("cannot find corresponding index of offset: " + offset);
-        }
-    }
-
-    public int getCodeIndexByOffset(int offset) {
-        if (codeOffsetToIndexMap.containsKey(offset)) {
-            return codeOffsetToIndexMap.get(offset);
-        } else {
-            throw new IllegalArgumentException("cannot find corresponding index of offset: " + offset);
-        }
-    }
-
-    public int getDebugInfoItemIndexByOffset(int offset) {
-        if (debugInfoItemOffsetToIndexMap.containsKey(offset)) {
-            return debugInfoItemOffsetToIndexMap.get(offset);
-        } else {
-            throw new IllegalArgumentException("cannot find corresponding index of offset: " + offset);
-        }
-    }
-}
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/SmallDexClassInfoCollector.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/SmallDexClassInfoCollector.java
deleted file mode 100644
index 3a3a3428..00000000
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/SmallDexClassInfoCollector.java
+++ /dev/null
@@ -1,219 +0,0 @@
-/*
- * Tencent is pleased to support the open source community by making Tinker available.
- *
- * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
- *
- * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- *
- * https://opensource.org/licenses/BSD-3-Clause
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is
- * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
- * either express or implied. See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.tencent.tinker.build.dexpatcher.util;
-
-import com.tencent.tinker.android.dex.ClassData;
-import com.tencent.tinker.android.dex.ClassDef;
-import com.tencent.tinker.android.dex.Code;
-import com.tencent.tinker.android.dex.Dex;
-import com.tencent.tinker.android.dx.instruction.InstructionReader;
-import com.tencent.tinker.android.dx.instruction.ShortArrayCodeInput;
-import com.tencent.tinker.build.util.DexClassesComparator;
-import com.tencent.tinker.build.util.DexClassesComparator.DexClassInfo;
-import com.tencent.tinker.build.util.DexClassesComparator.DexGroup;
-import com.tencent.tinker.commons.dexpatcher.DexPatcherLogger;
-
-import java.io.EOFException;
-import java.util.Collection;
-import java.util.HashSet;
-import java.util.Set;
-
-/**
- * Created by tangyinsheng on 2016/10/8.
- */
-
-public final class SmallDexClassInfoCollector {
-    private static final String TAG = "SmallDexClassInfoCollector";
-
-    private static final DexPatcherLogger logger = new DexPatcherLogger();
-    private final Set<String> loaderClassPatterns = new HashSet<>();
-
-    public SmallDexClassInfoCollector setLoaderClassPatterns(Collection<String> loaderClassPatterns) {
-        this.loaderClassPatterns.clear();
-        this.loaderClassPatterns.addAll(loaderClassPatterns);
-        return this;
-    }
-
-    public SmallDexClassInfoCollector addLoaderClassPattern(String loaderClassPattern) {
-        this.loaderClassPatterns.add(loaderClassPattern);
-        return this;
-    }
-
-    public SmallDexClassInfoCollector clearLoaderClassPattern() {
-        this.loaderClassPatterns.clear();
-        return this;
-    }
-
-    public SmallDexClassInfoCollector setLogger(DexPatcherLogger.IDexPatcherLogger loggerImpl) {
-        this.logger.setLoggerImpl(loggerImpl);
-        return this;
-    }
-
-    // Collect target:
-    //  Added classes;
-    //  Changed classes;
-    //  Subclasses of referrer-affected changed classes;
-    //  Classes which refer to changed classes.
-    public Set<DexClassInfo> doCollect(DexGroup oldDexGroup, DexGroup newDexGroup) {
-        Set<DexClassInfo> classInfosInSmallDex = new HashSet<>();
-
-        DexClassesComparator dexClassesCmp = new DexClassesComparator("*");
-        dexClassesCmp.setIgnoredRemovedClassDescPattern(this.loaderClassPatterns);
-
-        dexClassesCmp.setCompareMode(DexClassesComparator.COMPARE_MODE_CAUSE_REF_CHANGE_ONLY);
-        dexClassesCmp.startCheck(oldDexGroup, newDexGroup);
-
-        Set<String> referrerAffectedChangedClassDescs
-                = dexClassesCmp.getChangedClassDescToInfosMap().keySet();
-
-        Set<String> referrerAffectedChangedClassesChainSet = new HashSet<>();
-        referrerAffectedChangedClassesChainSet.addAll(referrerAffectedChangedClassDescs);
-
-        // Add added classes to small patched dex.
-        Collection<DexClassInfo> addedClassInfos = dexClassesCmp.getAddedClassInfos();
-        for (DexClassInfo addClassInfo : addedClassInfos) {
-            logger.i(TAG, "Add class %s to small dex.", addClassInfo.classDesc);
-            classInfosInSmallDex.add(addClassInfo);
-        }
-
-        // Use normal mode to compare again, then we get all changed class infos.
-        dexClassesCmp.setCompareMode(DexClassesComparator.COMPARE_MODE_NORMAL);
-        dexClassesCmp.startCheck(oldDexGroup, newDexGroup);
-
-        Collection<DexClassInfo[]> changedOldNewClassInfos =
-                dexClassesCmp.getChangedClassDescToInfosMap().values();
-
-        // Add changed classes to small patched dex.
-        // changedOldNewClassInfo[1] means changedNewClassInfo
-        for (DexClassInfo[] changedOldNewClassInfo : changedOldNewClassInfos) {
-            logger.i(TAG, "Add class %s to small dex.", changedOldNewClassInfo[1].classDesc);
-            classInfosInSmallDex.add(changedOldNewClassInfo[1]);
-        }
-
-        Set<DexClassInfo> classInfosInNewDexGroup
-                = newDexGroup.getClassInfosInDexesWithDuplicateCheck();
-
-        Set<String> changedClassDescs = dexClassesCmp.getChangedClassDescToInfosMap().keySet();
-
-        // Add subclasses of referrer-affected changed classes to small patched dex.
-        // By the way, collect all subclasses to form referrer-affected changed classes chain.
-        for (DexClassInfo patchedClassInfo : classInfosInNewDexGroup) {
-            final String superClassDesc
-                    = patchedClassInfo.classDef.supertypeIndex == ClassDef.NO_INDEX
-                    ? ""
-                    : patchedClassInfo.owner.typeNames().get(patchedClassInfo.classDef.supertypeIndex);
-
-            if (referrerAffectedChangedClassesChainSet.contains(superClassDesc)) {
-                referrerAffectedChangedClassesChainSet.add(patchedClassInfo.classDesc);
-                logger.i(TAG, "Class %s is subclass of referrer-affected changed class %s.",
-                        patchedClassInfo.classDesc, superClassDesc);
-
-                logger.i(TAG, "Add class %s to small dex.", patchedClassInfo.classDesc);
-
-                classInfosInSmallDex.add(patchedClassInfo);
-            }
-        }
-
-        Set<String> classesToCheckReference = new HashSet<>();
-        classesToCheckReference.addAll(changedClassDescs);
-        classesToCheckReference.addAll(referrerAffectedChangedClassesChainSet);
-
-        Set<String> addedClassDescs = new HashSet<>();
-        for (DexClassInfo addedClassInfo : addedClassInfos) {
-            addedClassDescs.add(addedClassInfo.classDesc);
-        }
-
-        // Add classes which refer to changed classes and referrer-affected
-        // changed classes chain to small patched dex.
-        for (DexClassInfo patchedClassInfo : classInfosInNewDexGroup) {
-            if (!addedClassDescs.contains(patchedClassInfo.classDesc)
-             && !changedClassDescs.contains(patchedClassInfo.classDesc)) {
-                processMethodReference(
-                        patchedClassInfo,
-                        classesToCheckReference,
-                        classInfosInSmallDex
-                );
-            }
-        }
-
-        return classInfosInSmallDex;
-    }
-
-    private void processMethodReference(
-            DexClassInfo patchedClassInfo,
-            Set<String> classDescsToCheck,
-            Set<DexClassInfo> result
-    ) {
-        final ClassDef classDef = patchedClassInfo.classDef;
-        if (classDef.classDataOffset == ClassDef.NO_OFFSET) {
-            return;
-        }
-
-        ClassData patchedClassData
-                = patchedClassInfo.owner.readClassData(classDef);
-
-        boolean shouldAdd = isClassMethodReferenceToClasses(
-                patchedClassInfo.owner,
-                patchedClassData.directMethods,
-                classDescsToCheck
-        );
-
-        if (!shouldAdd) {
-            shouldAdd = isClassMethodReferenceToClasses(
-                    patchedClassInfo.owner,
-                    patchedClassData.virtualMethods,
-                    classDescsToCheck
-            );
-        }
-
-        if (shouldAdd) {
-            logger.i(TAG, "Add class %s to small dex.", patchedClassInfo.classDesc);
-            result.add(patchedClassInfo);
-        }
-    }
-
-    private boolean isClassMethodReferenceToClasses(
-            Dex owner,
-            ClassData.Method[] methods,
-            Collection<String> referredClassDescs
-    ) {
-        if (referredClassDescs.isEmpty() || methods == null || methods.length == 0) {
-            return false;
-        }
-
-        for (ClassData.Method method : methods) {
-            if (method.codeOffset == 0) {
-                continue;
-            }
-            Code code = owner.readCode(method);
-            ClassReferringInsnVisitor refInsnVisitor =
-                    new ClassReferringInsnVisitor(owner, method, referredClassDescs, logger);
-            InstructionReader insnReader =
-                    new InstructionReader(new ShortArrayCodeInput(code.instructions));
-            try {
-                insnReader.accept(refInsnVisitor);
-                if (refInsnVisitor.isMethodReferencedToAnyProvidedClasses) {
-                    return true;
-                }
-            } catch (EOFException e) {
-                throw new IllegalStateException(e);
-            }
-        }
-
-        return false;
-    }
-}
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/SmallDexPatchGenerator.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/SmallDexPatchGenerator.java
deleted file mode 100644
index d56b2a1e..00000000
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/SmallDexPatchGenerator.java
+++ /dev/null
@@ -1,1778 +0,0 @@
-/*
- * Tencent is pleased to support the open source community by making Tinker available.
- *
- * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
- *
- * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- *
- * https://opensource.org/licenses/BSD-3-Clause
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is
- * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
- * either express or implied. See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.tencent.tinker.build.dexpatcher.util;
-
-import com.tencent.tinker.android.dex.Annotation;
-import com.tencent.tinker.android.dex.AnnotationSet;
-import com.tencent.tinker.android.dex.AnnotationSetRefList;
-import com.tencent.tinker.android.dex.AnnotationsDirectory;
-import com.tencent.tinker.android.dex.ClassData;
-import com.tencent.tinker.android.dex.ClassDef;
-import com.tencent.tinker.android.dex.Code;
-import com.tencent.tinker.android.dex.DebugInfoItem;
-import com.tencent.tinker.android.dex.Dex;
-import com.tencent.tinker.android.dex.DexException;
-import com.tencent.tinker.android.dex.EncodedValue;
-import com.tencent.tinker.android.dex.EncodedValueReader;
-import com.tencent.tinker.android.dex.FieldId;
-import com.tencent.tinker.android.dex.Leb128;
-import com.tencent.tinker.android.dex.MethodId;
-import com.tencent.tinker.android.dex.ProtoId;
-import com.tencent.tinker.android.dex.SizeOf;
-import com.tencent.tinker.android.dex.StringData;
-import com.tencent.tinker.android.dex.TableOfContents;
-import com.tencent.tinker.android.dex.TypeList;
-import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dex.util.ByteInput;
-import com.tencent.tinker.android.dx.instruction.InstructionCodec;
-import com.tencent.tinker.android.dx.instruction.InstructionReader;
-import com.tencent.tinker.android.dx.instruction.InstructionVisitor;
-import com.tencent.tinker.android.dx.instruction.ShortArrayCodeInput;
-import com.tencent.tinker.android.dx.util.Hex;
-import com.tencent.tinker.android.dx.util.IndexMap;
-import com.tencent.tinker.build.util.DexClassesComparator.DexClassInfo;
-import com.tencent.tinker.build.util.DexClassesComparator.DexGroup;
-import com.tencent.tinker.commons.dexpatcher.DexPatcherLogger;
-import com.tencent.tinker.commons.dexpatcher.DexPatcherLogger.IDexPatcherLogger;
-import com.tencent.tinker.commons.dexpatcher.struct.SmallPatchedDexItemFile;
-
-import java.io.BufferedOutputStream;
-import java.io.ByteArrayInputStream;
-import java.io.EOFException;
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.OutputStream;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-/**
- * Created by tangyinsheng on 2016/8/8.
- */
-public final class SmallDexPatchGenerator {
-    private static final String TAG = "SmallDexPatchGenerator";
-
-    private final List<DexGroup> oldDexGroups = new ArrayList<>();
-    private final List<DexGroup> patchedDexGroups = new ArrayList<>();
-
-    private final Map<Dex, Set<Integer>>
-            patchedDexToCollectedStringIndicesMap = new HashMap<>();
-    private final Map<Dex, Set<Integer>>
-            patchedDexToCollectedTypeIdIndicesMap = new HashMap<>();
-    private final Map<Dex, Set<Integer>>
-            patchedDexToCollectedTypeListIndicesMap = new HashMap<>();
-    private final Map<Dex, Set<Integer>>
-            patchedDexToCollectedProtoIdIndicesMap = new HashMap<>();
-    private final Map<Dex, Set<Integer>>
-            patchedDexToCollectedFieldIdIndicesMap = new HashMap<>();
-    private final Map<Dex, Set<Integer>>
-            patchedDexToCollectedMethodIdIndicesMap = new HashMap<>();
-    private final Map<Dex, Set<Integer>>
-            patchedDexToCollectedAnnotationIndicesMap = new HashMap<>();
-    private final Map<Dex, Set<Integer>>
-            patchedDexToCollectedAnnotationSetIndicesMap = new HashMap<>();
-    private final Map<Dex, Set<Integer>>
-            patchedDexToCollectedAnnotationSetRefListIndicesMap = new HashMap<>();
-    private final Map<Dex, Set<Integer>>
-            patchedDexToCollectedAnnotationsDirectoryIndicesMap = new HashMap<>();
-    private final Map<Dex, Set<Integer>>
-            patchedDexToCollectedEncodedArrayIndicesMap = new HashMap<>();
-    private final Map<Dex, Set<Integer>>
-            patchedDexToCollectedDebugInfoIndicesMap = new HashMap<>();
-    private final Map<Dex, Set<Integer>>
-            patchedDexToCollectedCodeIndicesMap = new HashMap<>();
-    private final Map<Dex, Set<Integer>>
-            patchedDexToCollectedClassDataIndicesMap = new HashMap<>();
-    private final Map<Dex, Set<Integer>>
-            patchedDexToCollectedClassDefIndicesMap = new HashMap<>();
-
-    private final Map<Dex, Integer>
-            patchedDexToSmallPatchedStringIdOffsetMap = new HashMap<>();
-    private final Map<Dex, Integer>
-            patchedDexToSmallPatchedTypeIdOffsetMap = new HashMap<>();
-    private final Map<Dex, Integer>
-            patchedDexToSmallPatchedProtoIdOffsetMap = new HashMap<>();
-    private final Map<Dex, Integer>
-            patchedDexToSmallPatchedFieldIdOffsetMap = new HashMap<>();
-    private final Map<Dex, Integer>
-            patchedDexToSmallPatchedMethodIdOffsetMap = new HashMap<>();
-    private final Map<Dex, Integer>
-            patchedDexToSmallPatchedClassDefOffsetMap = new HashMap<>();
-    private final Map<Dex, Integer>
-            patchedDexToSmallPatchedMapListOffsetMap = new HashMap<>();
-    private final Map<Dex, Integer>
-            patchedDexToSmallPatchedTypeListOffsetMap = new HashMap<>();
-    private final Map<Dex, Integer>
-            patchedDexToSmallPatchedAnnotationSetRefListOffsetMap = new HashMap<>();
-    private final Map<Dex, Integer>
-            patchedDexToSmallPatchedAnnotationSetOffsetMap = new HashMap<>();
-    private final Map<Dex, Integer>
-            patchedDexToSmallPatchedClassDataOffsetMap = new HashMap<>();
-    private final Map<Dex, Integer>
-            patchedDexToSmallPatchedCodeOffsetMap = new HashMap<>();
-    private final Map<Dex, Integer>
-            patchedDexToSmallPatchedStringDataOffsetMap = new HashMap<>();
-    private final Map<Dex, Integer>
-            patchedDexToSmallPatchedDebugInfoOffsetMap = new HashMap<>();
-    private final Map<Dex, Integer>
-            patchedDexToSmallPatchedAnnotationOffsetMap = new HashMap<>();
-    private final Map<Dex, Integer>
-            patchedDexToSmallPatchedEncodedArrayOffsetMap = new HashMap<>();
-    private final Map<Dex, Integer>
-            patchedDexToSmallPatchedAnnotationsDirectoryOffsetMap = new HashMap<>();
-    private final Map<Dex, Integer>
-            patchedDexToSmallPatchedDexSizeMap = new HashMap<>();
-
-    private final Set<String> loaderClassPatterns = new HashSet<>();
-
-    private final DexPatcherLogger logger = new DexPatcherLogger();
-
-    public void addLoaderClassPattern(String pattern) {
-        this.loaderClassPatterns.add(pattern);
-    }
-
-    public void setLoaderClassPatterns(Collection<String> patterns) {
-        this.loaderClassPatterns.clear();
-        this.loaderClassPatterns.addAll(patterns);
-    }
-
-    public void clearLoaderClassPatterns() {
-        this.loaderClassPatterns.clear();
-    }
-
-    public void setLogger(IDexPatcherLogger logger) {
-        this.logger.setLoggerImpl(logger);
-    }
-
-    public SmallDexPatchGenerator appendDexGroup(DexGroup oldDexGroup, DexGroup patchedDexGroup) {
-        if (oldDexGroup == null) {
-            throw new IllegalArgumentException("oldDexGroup is null.");
-        }
-        if (patchedDexGroup == null) {
-            throw new IllegalArgumentException("patchedDexGroup is null.");
-        }
-
-        this.oldDexGroups.add(oldDexGroup);
-        this.patchedDexGroups.add(patchedDexGroup);
-
-        // Build map between patched dex and old dex, which is used in next logic.
-        if (oldDexGroup.dexes.length != patchedDexGroup.dexes.length) {
-            throw new IllegalArgumentException(
-                    "dex count in oldDexGroup is not matched to dex count in patchedDexGroup."
-            );
-        }
-
-        return this;
-    }
-
-    public void executeAndSaveTo(File out) throws IOException {
-        OutputStream os = null;
-        try {
-            os = new BufferedOutputStream(new FileOutputStream(out));
-            executeAndSaveTo(os);
-        } finally {
-            if (os != null) {
-                try {
-                    os.close();
-                } catch (Exception e) {
-                    // ignored.
-                }
-            }
-        }
-    }
-
-    public void executeAndSaveTo(OutputStream os) throws IOException {
-        int dexGroupCount = this.oldDexGroups.size();
-
-        // Collect all items that should be exist in small patched dex.
-        for (int i = 0; i < dexGroupCount; ++i) {
-            DexGroup oldDexGroup = oldDexGroups.get(i);
-            DexGroup patchedDexGroup = patchedDexGroups.get(i);
-
-            collectItemIndicesFromDexGroup(oldDexGroup, patchedDexGroup);
-            calculateSmallPatchedSectionOffsets(oldDexGroup, patchedDexGroup);
-        }
-
-        saveToStream(os);
-    }
-
-    private void calculateSmallPatchedSectionOffsets(
-            DexGroup oldDexGroup, DexGroup patchedDexGroup
-    ) {
-        if (oldDexGroup.dexes.length != patchedDexGroup.dexes.length) {
-            throw new IllegalStateException("dex group contains different amount of dexes.");
-        }
-        int dexCount = oldDexGroup.dexes.length;
-        for (int dexId = 0; dexId < dexCount; ++dexId) {
-            Dex oldDex = oldDexGroup.dexes[dexId];
-            Dex patchedDex = patchedDexGroup.dexes[dexId];
-
-            final String currOldDexSignStr = Hex.toHexString(oldDex.computeSignature(false));
-
-            IndexMap fullToSmallPatchIndexMap = new IndexMap();
-
-            // For calculating size of mapList soon.
-            // Initialize it to 2 means a dex must contains two sections: header
-            // and mapList.
-            int smallPatchedSectionCount = 2;
-
-            // In next steps we do a bunch of simulations to calculate actual sizes of
-            // each section in small patched dex.
-
-            // First, calculate header and id sections size, so that we can work out
-            // base offsets of data sections soon.
-            int smallPatchedHeaderSize = SizeOf.HEADER_ITEM;
-            int collectedStringIndicesCount = getCollectedIndicesCountSafely(
-                    patchedDexToCollectedStringIndicesMap, patchedDex
-            );
-            int smallPatchedStringIdsSize = collectedStringIndicesCount * SizeOf.STRING_ID_ITEM;
-            if (smallPatchedHeaderSize > 0) {
-                ++smallPatchedSectionCount;
-            }
-            int collectedTypeIndicesCount = getCollectedIndicesCountSafely(
-                    patchedDexToCollectedTypeIdIndicesMap, patchedDex
-            );
-            int smallPatchedTypeIdsSize = collectedTypeIndicesCount * SizeOf.TYPE_ID_ITEM;
-            if (smallPatchedTypeIdsSize > 0) {
-                ++smallPatchedSectionCount;
-            }
-
-            // Although simulatePatchOperation can calculate this value, since protoIds section
-            // depends on typeLists section, we can't run protoIds Section's simulatePatchOperation
-            // method so far. Instead we calculate protoIds section's size using information we known
-            // directly.
-            int collectedProtoIdsIndicesCount = getCollectedIndicesCountSafely(
-                    patchedDexToCollectedProtoIdIndicesMap, patchedDex
-            );
-            int smallPatchedProtoIdsSize = collectedProtoIdsIndicesCount * SizeOf.PROTO_ID_ITEM;
-            if (smallPatchedProtoIdsSize > 0) {
-                ++smallPatchedSectionCount;
-            }
-
-            int collectedFieldIdsIndicesCount = getCollectedIndicesCountSafely(
-                    patchedDexToCollectedFieldIdIndicesMap, patchedDex
-            );
-            int smallPatchedFieldIdsSize = collectedFieldIdsIndicesCount * SizeOf.MEMBER_ID_ITEM;
-            if (smallPatchedFieldIdsSize > 0) {
-                ++smallPatchedSectionCount;
-            }
-            int collectedMethodIdsIndicesCount = getCollectedIndicesCountSafely(
-                    patchedDexToCollectedMethodIdIndicesMap, patchedDex
-            );
-            int smallPatchedMethodIdsSize = collectedMethodIdsIndicesCount * SizeOf.MEMBER_ID_ITEM;
-            if (smallPatchedMethodIdsSize > 0) {
-                ++smallPatchedSectionCount;
-            }
-            int collectedClassDefsIndicesCount = getCollectedIndicesCountSafely(
-                    patchedDexToCollectedClassDefIndicesMap, patchedDex
-            );
-            int smallPatchedClassDefsSize = collectedClassDefsIndicesCount * SizeOf.CLASS_DEF_ITEM;
-            if (smallPatchedClassDefsSize > 0) {
-                ++smallPatchedSectionCount;
-            }
-
-            int smallPatchedIdSectionSize =
-                    smallPatchedStringIdsSize
-                            + smallPatchedTypeIdsSize
-                            + smallPatchedProtoIdsSize
-                            + smallPatchedFieldIdsSize
-                            + smallPatchedMethodIdsSize
-                            + smallPatchedClassDefsSize;
-
-            int smallPatchedHeaderOffset = 0;
-
-            int smallPatchedStringIdsOffset = smallPatchedHeaderOffset + smallPatchedHeaderSize;
-            if (oldDex.getTableOfContents().stringIds.isElementFourByteAligned) {
-                smallPatchedStringIdsOffset = SizeOf.roundToTimesOfFour(smallPatchedStringIdsOffset);
-            }
-            patchedDexToSmallPatchedStringIdOffsetMap.put(patchedDex, smallPatchedStringIdsOffset);
-
-            int smallPatchedStringDatasOffset = smallPatchedHeaderSize + smallPatchedIdSectionSize;
-            if (oldDex.getTableOfContents().stringDatas.isElementFourByteAligned) {
-                smallPatchedStringDatasOffset
-                        = SizeOf.roundToTimesOfFour(smallPatchedStringDatasOffset);
-            }
-            patchedDexToSmallPatchedStringDataOffsetMap.put(patchedDex, smallPatchedStringDatasOffset);
-            int smallPatchedStringDataItemsSize = new SmallPatchSimulator<StringData>(
-                    patchedDex,
-                    patchedDex.getTableOfContents().stringDatas,
-                    fullToSmallPatchIndexMap,
-                    patchedDexToCollectedStringIndicesMap.get(patchedDex)
-            ).simulate(smallPatchedStringDatasOffset);
-            if (smallPatchedStringDataItemsSize > 0) {
-                ++smallPatchedSectionCount;
-            }
-
-            int smallPatchedTypeIdsOffset
-                    = smallPatchedStringIdsOffset + smallPatchedStringIdsSize;
-            if (oldDex.getTableOfContents().typeIds.isElementFourByteAligned) {
-                smallPatchedTypeIdsOffset = SizeOf.roundToTimesOfFour(smallPatchedTypeIdsOffset);
-            }
-            patchedDexToSmallPatchedTypeIdOffsetMap.put(patchedDex, smallPatchedTypeIdsOffset);
-
-            int smallPatchedTypeListsOffset
-                    = smallPatchedHeaderSize
-                    + smallPatchedIdSectionSize
-                    + smallPatchedStringDataItemsSize;
-            if (oldDex.getTableOfContents().typeLists.isElementFourByteAligned) {
-                smallPatchedTypeListsOffset = SizeOf.roundToTimesOfFour(smallPatchedTypeListsOffset);
-            }
-            patchedDexToSmallPatchedTypeListOffsetMap.put(
-                    patchedDex, smallPatchedTypeListsOffset
-            );
-            int smallPatchedTypeListsSize = new SmallPatchSimulator<TypeList>(
-                    patchedDex,
-                    patchedDex.getTableOfContents().typeLists,
-                    fullToSmallPatchIndexMap,
-                    patchedDexToCollectedTypeListIndicesMap.get(patchedDex)
-            ).simulate(smallPatchedTypeListsOffset);
-            if (smallPatchedTypeListsSize > 0) {
-                ++smallPatchedSectionCount;
-            }
-
-            int smallPatchedProtoIdsOffset
-                    = smallPatchedTypeIdsOffset + smallPatchedTypeIdsSize;
-            if (oldDex.getTableOfContents().protoIds.isElementFourByteAligned) {
-                smallPatchedProtoIdsOffset = SizeOf.roundToTimesOfFour(smallPatchedProtoIdsOffset);
-            }
-            patchedDexToSmallPatchedProtoIdOffsetMap.put(
-                    patchedDex, smallPatchedProtoIdsOffset
-            );
-
-            int smallPatchedFieldIdsOffset
-                    = smallPatchedProtoIdsOffset + smallPatchedProtoIdsSize;
-            if (oldDex.getTableOfContents().fieldIds.isElementFourByteAligned) {
-                smallPatchedFieldIdsOffset = SizeOf.roundToTimesOfFour(smallPatchedFieldIdsOffset);
-            }
-            patchedDexToSmallPatchedFieldIdOffsetMap.put(
-                    patchedDex, smallPatchedFieldIdsOffset
-            );
-
-            int smallPatchedMethodIdsOffset
-                    = smallPatchedFieldIdsOffset + smallPatchedFieldIdsSize;
-            if (oldDex.getTableOfContents().methodIds.isElementFourByteAligned) {
-                smallPatchedMethodIdsOffset
-                        = SizeOf.roundToTimesOfFour(smallPatchedMethodIdsOffset);
-            }
-            patchedDexToSmallPatchedMethodIdOffsetMap.put(
-                    patchedDex, smallPatchedMethodIdsOffset
-            );
-
-            int smallPatchedAnnotationsOffset
-                    = smallPatchedTypeListsOffset + smallPatchedTypeListsSize;
-            if (oldDex.getTableOfContents().annotations.isElementFourByteAligned) {
-                smallPatchedAnnotationsOffset
-                        = SizeOf.roundToTimesOfFour(smallPatchedAnnotationsOffset);
-            }
-            patchedDexToSmallPatchedAnnotationOffsetMap.put(
-                    patchedDex, smallPatchedAnnotationsOffset
-            );
-            int smallPatchedAnnotationsSize = new SmallPatchSimulator<Annotation>(
-                    patchedDex,
-                    patchedDex.getTableOfContents().annotations,
-                    fullToSmallPatchIndexMap,
-                    patchedDexToCollectedAnnotationIndicesMap.get(patchedDex)
-            ).simulate(smallPatchedAnnotationsOffset);
-            if (smallPatchedAnnotationsSize > 0) {
-                ++smallPatchedSectionCount;
-            }
-
-            int smallPatchedAnnotationSetsOffset
-                    = smallPatchedAnnotationsOffset + smallPatchedAnnotationsSize;
-            if (oldDex.getTableOfContents().annotationSets.isElementFourByteAligned) {
-                smallPatchedAnnotationSetsOffset
-                        = SizeOf.roundToTimesOfFour(smallPatchedAnnotationSetsOffset);
-            }
-            patchedDexToSmallPatchedAnnotationSetOffsetMap.put(
-                    patchedDex, smallPatchedAnnotationSetsOffset
-            );
-            int smallPatchedAnnotationSetsSize = new SmallPatchSimulator<AnnotationSet>(
-                    patchedDex,
-                    patchedDex.getTableOfContents().annotationSets,
-                    fullToSmallPatchIndexMap,
-                    patchedDexToCollectedAnnotationSetIndicesMap.get(patchedDex)
-            ).simulate(smallPatchedAnnotationSetsOffset);
-            if (smallPatchedAnnotationSetsSize > 0) {
-                ++smallPatchedSectionCount;
-            }
-
-            int smallPatchedAnnotationSetRefListsOffset
-                    = smallPatchedAnnotationSetsOffset
-                    + smallPatchedAnnotationSetsSize;
-            if (oldDex.getTableOfContents().annotationSetRefLists.isElementFourByteAligned) {
-                smallPatchedAnnotationSetRefListsOffset
-                        = SizeOf.roundToTimesOfFour(smallPatchedAnnotationSetRefListsOffset);
-            }
-            patchedDexToSmallPatchedAnnotationSetRefListOffsetMap.put(
-                    patchedDex, smallPatchedAnnotationSetRefListsOffset
-            );
-            int smallPatchedAnnotationSetRefListsSize
-                    = new SmallPatchSimulator<AnnotationSetRefList>(
-                    patchedDex,
-                    patchedDex.getTableOfContents().annotationSetRefLists,
-                    fullToSmallPatchIndexMap,
-                    patchedDexToCollectedAnnotationSetRefListIndicesMap.get(patchedDex)
-            ).simulate(smallPatchedAnnotationSetRefListsOffset);
-            if (smallPatchedAnnotationSetRefListsSize > 0) {
-                ++smallPatchedSectionCount;
-            }
-
-            int smallPatchedAnnotationsDirectoriesOffset
-                    = smallPatchedAnnotationSetRefListsOffset
-                    + smallPatchedAnnotationSetRefListsSize;
-            if (oldDex.getTableOfContents().annotationsDirectories.isElementFourByteAligned) {
-                smallPatchedAnnotationsDirectoriesOffset
-                        = SizeOf.roundToTimesOfFour(smallPatchedAnnotationsDirectoriesOffset);
-            }
-            patchedDexToSmallPatchedAnnotationsDirectoryOffsetMap.put(
-                    patchedDex, smallPatchedAnnotationsDirectoriesOffset
-            );
-            int smallPatchedAnnotationsDirectoriesSize
-                    = new SmallPatchSimulator<AnnotationsDirectory>(
-                    patchedDex,
-                    patchedDex.getTableOfContents().annotationsDirectories,
-                    fullToSmallPatchIndexMap,
-                    patchedDexToCollectedAnnotationsDirectoryIndicesMap.get(patchedDex)
-            ).simulate(smallPatchedAnnotationsDirectoriesOffset);
-            if (smallPatchedAnnotationsDirectoriesSize > 0) {
-                ++smallPatchedSectionCount;
-            }
-
-            int smallPatchedDebugInfoItemsOffset
-                    = smallPatchedAnnotationsDirectoriesOffset
-                    + smallPatchedAnnotationsDirectoriesSize;
-            if (oldDex.getTableOfContents().debugInfos.isElementFourByteAligned) {
-                smallPatchedDebugInfoItemsOffset
-                        = SizeOf.roundToTimesOfFour(smallPatchedDebugInfoItemsOffset);
-            }
-            patchedDexToSmallPatchedDebugInfoOffsetMap.put(
-                    patchedDex, smallPatchedDebugInfoItemsOffset
-            );
-            int smallPatchedDebugInfoItemsSize = new SmallPatchSimulator<DebugInfoItem>(
-                    patchedDex,
-                    patchedDex.getTableOfContents().debugInfos,
-                    fullToSmallPatchIndexMap,
-                    patchedDexToCollectedDebugInfoIndicesMap.get(patchedDex)
-            ).simulate(smallPatchedDebugInfoItemsOffset);
-            if (smallPatchedDebugInfoItemsSize > 0) {
-                ++smallPatchedSectionCount;
-            }
-
-            int smallPatchedCodesOffset
-                    = smallPatchedDebugInfoItemsOffset
-                    + smallPatchedDebugInfoItemsSize;
-            if (oldDex.getTableOfContents().codes.isElementFourByteAligned) {
-                smallPatchedCodesOffset
-                        = SizeOf.roundToTimesOfFour(smallPatchedCodesOffset);
-            }
-            patchedDexToSmallPatchedCodeOffsetMap.put(
-                    patchedDex, smallPatchedCodesOffset
-            );
-            int smallPatchedCodesSize = new SmallPatchSimulator<Code>(
-                    patchedDex,
-                    patchedDex.getTableOfContents().codes,
-                    fullToSmallPatchIndexMap,
-                    patchedDexToCollectedCodeIndicesMap.get(patchedDex)
-            ).simulate(smallPatchedCodesOffset);
-            if (smallPatchedCodesSize > 0) {
-                ++smallPatchedSectionCount;
-            }
-
-            int smallPatchedClassDatasOffset
-                    = smallPatchedCodesOffset
-                    + smallPatchedCodesSize;
-            if (oldDex.getTableOfContents().classDatas.isElementFourByteAligned) {
-                smallPatchedClassDatasOffset
-                        = SizeOf.roundToTimesOfFour(smallPatchedClassDatasOffset);
-            }
-            patchedDexToSmallPatchedClassDataOffsetMap.put(
-                    patchedDex, smallPatchedClassDatasOffset
-            );
-            int smallPatchedClassDatasSize = new SmallPatchSimulator<ClassData>(
-                    patchedDex,
-                    patchedDex.getTableOfContents().classDatas,
-                    fullToSmallPatchIndexMap,
-                    patchedDexToCollectedClassDataIndicesMap.get(patchedDex)
-            ).simulate(smallPatchedClassDatasOffset);
-            if (smallPatchedClassDatasSize > 0) {
-                ++smallPatchedSectionCount;
-            }
-
-            int smallPatchedEncodedArraysOffset
-                    = smallPatchedClassDatasOffset
-                    + smallPatchedClassDatasSize;
-            if (oldDex.getTableOfContents().encodedArrays.isElementFourByteAligned) {
-                smallPatchedEncodedArraysOffset
-                        = SizeOf.roundToTimesOfFour(smallPatchedEncodedArraysOffset);
-            }
-            patchedDexToSmallPatchedEncodedArrayOffsetMap.put(
-                    patchedDex, smallPatchedEncodedArraysOffset
-            );
-            int smallPatchedEncodedArraysSize = new SmallPatchSimulator<EncodedValue>(
-                    patchedDex,
-                    patchedDex.getTableOfContents().encodedArrays,
-                    fullToSmallPatchIndexMap,
-                    patchedDexToCollectedEncodedArrayIndicesMap.get(patchedDex)
-            ).simulate(smallPatchedEncodedArraysOffset);
-            if (smallPatchedEncodedArraysSize > 0) {
-                ++smallPatchedSectionCount;
-            }
-
-            int smallPatchedClassDefsOffset
-                    = smallPatchedMethodIdsOffset
-                    + smallPatchedMethodIdsSize;
-            if (oldDex.getTableOfContents().classDefs.isElementFourByteAligned) {
-                smallPatchedClassDefsOffset
-                        = SizeOf.roundToTimesOfFour(smallPatchedClassDefsOffset);
-            }
-            patchedDexToSmallPatchedClassDefOffsetMap.put(
-                    patchedDex, smallPatchedClassDefsOffset
-            );
-
-            // Calculate any values we still know nothing about them.
-            int smallPatchedMapListOffset
-                    = smallPatchedEncodedArraysOffset
-                    + smallPatchedEncodedArraysSize;
-            if (oldDex.getTableOfContents().mapList.isElementFourByteAligned) {
-                smallPatchedMapListOffset
-                        = SizeOf.roundToTimesOfFour(smallPatchedMapListOffset);
-            }
-            patchedDexToSmallPatchedMapListOffsetMap.put(
-                    patchedDex, smallPatchedMapListOffset
-            );
-            int smallPatchedMapListSize
-                    = SizeOf.UINT + SizeOf.MAP_ITEM * smallPatchedSectionCount;
-
-            int smallPatchedDexSize
-                    = smallPatchedMapListOffset
-                    + smallPatchedMapListSize;
-            patchedDexToSmallPatchedDexSizeMap.put(patchedDex, smallPatchedDexSize);
-        }
-    }
-
-    private int getCollectedIndicesCountSafely(
-            Map<Dex, Set<Integer>> collectedIndicesMap, Dex patchedDex
-    ) {
-        Set<Integer> indices = collectedIndicesMap.get(patchedDex);
-        if (indices == null) {
-            return 0;
-        } else {
-            return indices.size();
-        }
-    }
-
-    private void saveToStream(OutputStream os) throws IOException {
-        DexDataBuffer buffer = new DexDataBuffer();
-
-        // Write header
-        buffer.write(SmallPatchedDexItemFile.MAGIC);
-        buffer.writeShort(SmallPatchedDexItemFile.CURRENT_VERSION);
-        // Take the field 'firstChunkOffset' into header's size account.
-        buffer.writeInt(buffer.position() + SizeOf.UINT);
-
-        // Gather old dexes
-        List<Dex> oldDexes = new ArrayList<>();
-        int oldDexGroupCount = this.oldDexGroups.size();
-        for (int i = 0; i < oldDexGroupCount; ++i) {
-            DexGroup oldDexGroup = oldDexGroups.get(i);
-            for (Dex oldDex : oldDexGroup.dexes) {
-                oldDexes.add(oldDex);
-            }
-        }
-
-        // Gather patched dexes
-        List<Dex> patchedDexes = new ArrayList<>();
-        int patchedDexGroupCount = this.patchedDexGroups.size();
-        for (int i = 0; i < patchedDexGroupCount; ++i) {
-            DexGroup patchedDexGroup = patchedDexGroups.get(i);
-            for (Dex patchedDex : patchedDexGroup.dexes) {
-                patchedDexes.add(patchedDex);
-            }
-        }
-
-        // Dex sign chunk
-        int oldDexSignCount = oldDexes.size();
-        buffer.writeUleb128(oldDexSignCount);
-
-        Map<String, Integer> oldDexSignToIdxInSignList = new HashMap<>();
-        for (int i = 0; i < oldDexSignCount; ++i) {
-            final byte[] signBytes = oldDexes.get(i).computeSignature(false);
-            final String signStr = Hex.toHexString(signBytes);
-            buffer.write(signBytes);
-            oldDexSignToIdxInSignList.put(signStr, i);
-        }
-
-        for (Dex patchedDex : patchedDexes) {
-            writeSmallPatchedSectionOffset(
-                    buffer, patchedDex, patchedDexToSmallPatchedStringIdOffsetMap
-            );
-            writeSmallPatchedSectionOffset(
-                    buffer, patchedDex, patchedDexToSmallPatchedTypeIdOffsetMap
-            );
-            writeSmallPatchedSectionOffset(
-                    buffer, patchedDex, patchedDexToSmallPatchedProtoIdOffsetMap
-            );
-            writeSmallPatchedSectionOffset(
-                    buffer, patchedDex, patchedDexToSmallPatchedFieldIdOffsetMap
-            );
-            writeSmallPatchedSectionOffset(
-                    buffer, patchedDex, patchedDexToSmallPatchedMethodIdOffsetMap
-            );
-            writeSmallPatchedSectionOffset(
-                    buffer, patchedDex, patchedDexToSmallPatchedClassDefOffsetMap
-            );
-            writeSmallPatchedSectionOffset(
-                    buffer, patchedDex, patchedDexToSmallPatchedStringDataOffsetMap
-            );
-            writeSmallPatchedSectionOffset(
-                    buffer, patchedDex, patchedDexToSmallPatchedTypeListOffsetMap
-            );
-            writeSmallPatchedSectionOffset(
-                    buffer, patchedDex, patchedDexToSmallPatchedAnnotationOffsetMap
-            );
-            writeSmallPatchedSectionOffset(
-                    buffer, patchedDex, patchedDexToSmallPatchedAnnotationSetOffsetMap
-            );
-            writeSmallPatchedSectionOffset(
-                    buffer, patchedDex, patchedDexToSmallPatchedAnnotationSetRefListOffsetMap
-            );
-            writeSmallPatchedSectionOffset(
-                    buffer, patchedDex, patchedDexToSmallPatchedAnnotationsDirectoryOffsetMap
-            );
-            writeSmallPatchedSectionOffset(
-                    buffer, patchedDex, patchedDexToSmallPatchedDebugInfoOffsetMap
-            );
-            writeSmallPatchedSectionOffset(
-                    buffer, patchedDex, patchedDexToSmallPatchedCodeOffsetMap
-            );
-            writeSmallPatchedSectionOffset(
-                    buffer, patchedDex, patchedDexToSmallPatchedClassDataOffsetMap
-            );
-            writeSmallPatchedSectionOffset(
-                    buffer, patchedDex, patchedDexToSmallPatchedEncodedArrayOffsetMap
-            );
-            writeSmallPatchedSectionOffset(
-                    buffer, patchedDex, patchedDexToSmallPatchedMapListOffsetMap
-            );
-            writeSmallPatchedSectionOffset(
-                    buffer, patchedDex, patchedDexToSmallPatchedDexSizeMap
-            );
-        }
-
-        writeDataChunk(buffer, patchedDexes, patchedDexToCollectedStringIndicesMap);
-        writeDataChunk(buffer, patchedDexes, patchedDexToCollectedTypeIdIndicesMap);
-        writeDataChunk(buffer, patchedDexes, patchedDexToCollectedTypeListIndicesMap);
-        writeDataChunk(buffer, patchedDexes, patchedDexToCollectedProtoIdIndicesMap);
-        writeDataChunk(buffer, patchedDexes, patchedDexToCollectedFieldIdIndicesMap);
-        writeDataChunk(buffer, patchedDexes, patchedDexToCollectedMethodIdIndicesMap);
-        writeDataChunk(buffer, patchedDexes, patchedDexToCollectedAnnotationIndicesMap);
-        writeDataChunk(buffer, patchedDexes, patchedDexToCollectedAnnotationSetIndicesMap);
-        writeDataChunk(buffer, patchedDexes, patchedDexToCollectedAnnotationSetRefListIndicesMap);
-        writeDataChunk(buffer, patchedDexes, patchedDexToCollectedAnnotationsDirectoryIndicesMap);
-        writeDataChunk(buffer, patchedDexes, patchedDexToCollectedEncodedArrayIndicesMap);
-        writeDataChunk(buffer, patchedDexes, patchedDexToCollectedDebugInfoIndicesMap);
-        writeDataChunk(buffer, patchedDexes, patchedDexToCollectedCodeIndicesMap);
-        writeDataChunk(buffer, patchedDexes, patchedDexToCollectedClassDataIndicesMap);
-        writeDataChunk(buffer, patchedDexes, patchedDexToCollectedClassDefIndicesMap);
-
-        os.write(buffer.array());
-        os.flush();
-    }
-
-    private void writeSmallPatchedSectionOffset(
-            DexDataBuffer buffer,
-            Dex patchedDex,
-            Map<Dex, Integer> patchedDexToSmallPatchedSectionOffsetMap
-    ) {
-        Integer offset = patchedDexToSmallPatchedSectionOffsetMap.get(patchedDex);
-        if (offset != null) {
-            buffer.writeInt(offset);
-        } else {
-            throw new IllegalStateException("section offset is missing.");
-        }
-    }
-
-    private void writeDataChunk(
-            DexDataBuffer buffer,
-            List<Dex> patchedDexList,
-            Map<Dex, Set<Integer>> patchedDexToCollectedItemIndicesMap
-    ) {
-        for (Dex patchedDex : patchedDexList) {
-            Set<Integer> itemIndices = patchedDexToCollectedItemIndicesMap.get(patchedDex);
-            if (itemIndices == null) {
-                buffer.writeUleb128(0);
-            } else {
-                int indexCount = itemIndices.size();
-                Integer[] itemIndexArr = new Integer[indexCount];
-                itemIndices.toArray(itemIndexArr);
-                Arrays.sort(itemIndexArr);
-                buffer.writeUleb128(indexCount);
-                int prevIndex = 0;
-                for (int j = 0; j < indexCount; ++j) {
-                    buffer.writeSleb128(itemIndexArr[j] - prevIndex);
-                    prevIndex = itemIndexArr[j];
-                }
-            }
-        }
-    }
-
-    private void collectItemIndicesFromDexGroup(
-            DexGroup oldDexGroup,
-            DexGroup patchedDexGroup
-    ) {
-        SmallDexClassInfoCollector smallDexClassInfoCollector = new SmallDexClassInfoCollector();
-        smallDexClassInfoCollector.setLoaderClassPatterns(this.loaderClassPatterns);
-        smallDexClassInfoCollector.setLogger(this.logger.getLoggerImpl());
-        Set<DexClassInfo> patchedClassInfosForItemIndexCollecting =
-                smallDexClassInfoCollector.doCollect(oldDexGroup, patchedDexGroup);
-
-        // Collect all elements' indices of collected class.
-
-        Map<Dex, OffsetToIndexConverter> dexToOffsetToIndexConverterMap = new HashMap<>();
-
-        for (DexClassInfo classInfo : patchedClassInfosForItemIndexCollecting) {
-            Dex owner = classInfo.owner;
-            OffsetToIndexConverter offsetToIndexConverter =
-                    dexToOffsetToIndexConverterMap.get(owner);
-
-            if (offsetToIndexConverter == null) {
-                offsetToIndexConverter = new OffsetToIndexConverter(owner);
-                dexToOffsetToIndexConverterMap.put(owner, offsetToIndexConverter);
-            }
-
-            collectItemIndicesFromClassInfo(classInfo, offsetToIndexConverter);
-        }
-    }
-
-    private void collectItemIndicesFromClassInfo(
-            DexClassInfo classInfo,
-            OffsetToIndexConverter offsetToIndexConverter
-    ) {
-        Dex owner = classInfo.owner;
-
-        putValueIntoSetMap(
-                patchedDexToCollectedClassDefIndicesMap,
-                owner,
-                classInfo.classDefIndex
-        );
-
-        collectItemIndicesFromTypeIndex(
-                owner, classInfo.classDef.typeIndex, offsetToIndexConverter
-        );
-
-        collectItemIndicesFromTypeIndex(
-                owner, classInfo.classDef.supertypeIndex, offsetToIndexConverter
-        );
-
-        collectItemIndicesFromTypeList(
-                owner, classInfo.classDef.interfacesOffset, offsetToIndexConverter
-        );
-
-        collectItemIndicesFromStringIndex(
-                owner, classInfo.classDef.sourceFileIndex, offsetToIndexConverter
-        );
-
-        collectItemIndicesFromAnnotationsDirectory(
-                owner, classInfo.classDef.annotationsOffset, offsetToIndexConverter
-        );
-
-        collectItemIndicesFromClassData(
-                owner, classInfo.classDef.classDataOffset, offsetToIndexConverter
-        );
-
-        collectItemIndicesFromEncodedArray(
-                owner, classInfo.classDef.staticValuesOffset, offsetToIndexConverter
-        );
-    }
-
-    private void collectItemIndicesFromStringIndex(
-            Dex owner,
-            int stringIndex,
-            OffsetToIndexConverter offsetToIndexConverter
-    ) {
-        if (stringIndex == ClassDef.NO_INDEX) {
-            return;
-        }
-
-        putValueIntoSetMap(
-                patchedDexToCollectedStringIndicesMap,
-                owner,
-                stringIndex
-        );
-    }
-
-    private void collectItemIndicesFromTypeList(
-            Dex owner,
-            int typeListOffset,
-            OffsetToIndexConverter offsetToIndexConverter
-    ) {
-        if (typeListOffset == ClassDef.NO_OFFSET) {
-            return;
-        }
-
-        putValueIntoSetMap(
-                patchedDexToCollectedTypeListIndicesMap,
-                owner,
-                offsetToIndexConverter.getTypeListIndexByOffset(typeListOffset)
-        );
-
-        TypeList typeList = owner.openSection(typeListOffset).readTypeList();
-        for (int typeIndex : typeList.types) {
-            collectItemIndicesFromTypeIndex(
-                    owner, typeIndex, offsetToIndexConverter
-            );
-        }
-    }
-
-    private void collectItemIndicesFromTypeIndex(
-            Dex owner,
-            int typeIndex,
-            OffsetToIndexConverter offsetToIndexConverter
-    ) {
-        if (typeIndex == ClassDef.NO_INDEX) {
-            return;
-        }
-
-        putValueIntoSetMap(
-                patchedDexToCollectedTypeIdIndicesMap,
-                owner,
-                typeIndex
-        );
-
-        collectItemIndicesFromStringIndex(
-                owner, owner.typeIds().get(typeIndex), offsetToIndexConverter
-        );
-    }
-
-    private void collectItemIndicesFromFieldIndex(
-            Dex owner,
-            int fieldIndex,
-            OffsetToIndexConverter offsetToIndexConverter
-    ) {
-        if (fieldIndex == ClassDef.NO_INDEX) {
-            return;
-        }
-
-        putValueIntoSetMap(
-                patchedDexToCollectedFieldIdIndicesMap,
-                owner,
-                fieldIndex
-        );
-
-        FieldId fieldId = owner.fieldIds().get(fieldIndex);
-        collectItemIndicesFromStringIndex(owner, fieldId.nameIndex, offsetToIndexConverter);
-        collectItemIndicesFromTypeIndex(
-                owner, fieldId.declaringClassIndex, offsetToIndexConverter
-        );
-        collectItemIndicesFromTypeIndex(owner, fieldId.typeIndex, offsetToIndexConverter);
-    }
-
-    private void collectItemIndicesFromMethodIndex(
-            Dex owner,
-            int methodIndex,
-            OffsetToIndexConverter offsetToIndexConverter
-    ) {
-        if (methodIndex == ClassDef.NO_INDEX) {
-            return;
-        }
-
-        putValueIntoSetMap(
-                patchedDexToCollectedMethodIdIndicesMap,
-                owner,
-                methodIndex
-        );
-
-        MethodId methodId = owner.methodIds().get(methodIndex);
-        collectItemIndicesFromStringIndex(
-                owner, methodId.nameIndex, offsetToIndexConverter
-        );
-        collectItemIndicesFromTypeIndex(
-                owner, methodId.declaringClassIndex, offsetToIndexConverter
-        );
-        collectItemIndicesFromProtoIndex(
-                owner, methodId.protoIndex, offsetToIndexConverter
-        );
-    }
-
-    private void collectItemIndicesFromProtoIndex(
-            Dex owner,
-            int protoIndex,
-            OffsetToIndexConverter offsetToIndexConverter
-    ) {
-        if (protoIndex == ClassDef.NO_INDEX) {
-            return;
-        }
-
-        putValueIntoSetMap(
-                patchedDexToCollectedProtoIdIndicesMap,
-                owner,
-                protoIndex
-        );
-
-        ProtoId protoId = owner.protoIds().get(protoIndex);
-
-        collectItemIndicesFromStringIndex(
-                owner, protoId.shortyIndex, offsetToIndexConverter
-        );
-        collectItemIndicesFromTypeIndex(
-                owner, protoId.returnTypeIndex, offsetToIndexConverter
-        );
-        collectItemIndicesFromTypeList(
-                owner, protoId.parametersOffset, offsetToIndexConverter
-        );
-    }
-
-    private void collectItemIndicesFromAnnotationsDirectory(
-            Dex owner,
-            int annotationsDirectoryOffset,
-            OffsetToIndexConverter offsetToIndexConverter
-    ) {
-        if (annotationsDirectoryOffset == ClassDef.NO_OFFSET) {
-            return;
-        }
-
-        putValueIntoSetMap(
-                patchedDexToCollectedAnnotationsDirectoryIndicesMap,
-                owner,
-                offsetToIndexConverter.getAnnotationsDirectoryIndexByOffset(
-                        annotationsDirectoryOffset
-                )
-        );
-
-        AnnotationsDirectory annotationsDirectory =
-                owner.openSection(annotationsDirectoryOffset).readAnnotationsDirectory();
-
-        collectItemIndicesFromAnnotationSet(
-                owner,
-                annotationsDirectory.classAnnotationsOffset,
-                offsetToIndexConverter
-        );
-
-        for (int[] fieldAnnoPair : annotationsDirectory.fieldAnnotations) {
-            collectItemIndicesFromFieldIndex(
-                    owner, fieldAnnoPair[0], offsetToIndexConverter
-            );
-            collectItemIndicesFromAnnotationSet(
-                    owner, fieldAnnoPair[1], offsetToIndexConverter
-            );
-        }
-        for (int[] methodAnnoPair : annotationsDirectory.methodAnnotations) {
-            collectItemIndicesFromMethodIndex(
-                    owner, methodAnnoPair[0], offsetToIndexConverter
-            );
-            collectItemIndicesFromAnnotationSet(
-                    owner, methodAnnoPair[1], offsetToIndexConverter
-            );
-        }
-        for (int[] paramAnnoPair : annotationsDirectory.parameterAnnotations) {
-            collectItemIndicesFromMethodIndex(
-                    owner, paramAnnoPair[0], offsetToIndexConverter
-            );
-            collectItemIndicesFromAnnotationSetRefList(
-                    owner, paramAnnoPair[1], offsetToIndexConverter
-            );
-        }
-    }
-
-    private void collectItemIndicesFromAnnotationSetRefList(
-            Dex owner,
-            int annotationSetRefListOffset,
-            OffsetToIndexConverter offsetToIndexConverter
-    ) {
-        if (annotationSetRefListOffset == ClassDef.NO_OFFSET) {
-            return;
-        }
-
-        putValueIntoSetMap(
-                patchedDexToCollectedAnnotationSetRefListIndicesMap,
-                owner,
-                offsetToIndexConverter.getAnnotationSetRefListIndexByOffset(
-                        annotationSetRefListOffset
-                )
-        );
-
-        AnnotationSetRefList annotationSetRefList =
-                owner.openSection(annotationSetRefListOffset).readAnnotationSetRefList();
-
-        for (int annotationSetOffset : annotationSetRefList.annotationSetRefItems) {
-            collectItemIndicesFromAnnotationSet(
-                    owner, annotationSetOffset, offsetToIndexConverter
-            );
-        }
-    }
-
-    private void collectItemIndicesFromAnnotationSet(
-            Dex owner,
-            int annotationSetOffset,
-            OffsetToIndexConverter offsetToIndexConverter
-    ) {
-        if (annotationSetOffset == ClassDef.NO_OFFSET) {
-            return;
-        }
-
-        putValueIntoSetMap(
-                patchedDexToCollectedAnnotationSetIndicesMap,
-                owner,
-                offsetToIndexConverter.getAnnotationSetIndexByOffset(
-                        annotationSetOffset
-                )
-        );
-
-        AnnotationSet annotationSet = owner.openSection(annotationSetOffset).readAnnotationSet();
-
-        for (int annotationOffset : annotationSet.annotationOffsets) {
-            collectItemIndicesFromAnnotation(
-                    owner, annotationOffset, offsetToIndexConverter
-            );
-        }
-    }
-
-    private void collectItemIndicesFromAnnotation(
-            Dex owner,
-            int annotationOffset,
-            OffsetToIndexConverter offsetToIndexConverter
-    ) {
-        if (annotationOffset == ClassDef.NO_OFFSET) {
-            return;
-        }
-
-        putValueIntoSetMap(
-                patchedDexToCollectedAnnotationIndicesMap,
-                owner,
-                offsetToIndexConverter.getAnnotationIndexByOffset(
-                        annotationOffset
-                )
-        );
-
-        Annotation annotation =
-                owner.openSection(annotationOffset).readAnnotation();
-
-        EncodedValueReader annotationReader = annotation.getReader();
-
-        collectItemIndicesFromAnnotationReader(
-                owner,
-                annotationReader,
-                offsetToIndexConverter
-        );
-    }
-
-    private void collectItemIndicesFromAnnotationReader(
-            Dex owner,
-            EncodedValueReader annotationReader,
-            OffsetToIndexConverter offsetToIndexConverter
-    ) {
-        int fieldCount = annotationReader.readAnnotation();
-
-        collectItemIndicesFromTypeIndex(
-                owner, annotationReader.getAnnotationType(), offsetToIndexConverter
-        );
-
-        for (int i = 0; i < fieldCount; ++i) {
-            int annotationNameIndex = annotationReader.readAnnotationName();
-            collectItemIndicesFromStringIndex(
-                    owner, annotationNameIndex, offsetToIndexConverter
-            );
-            collectItemIndicesFromEncodedValueReader(
-                    owner, annotationReader, offsetToIndexConverter
-            );
-        }
-    }
-
-    private void collectItemIndicesFromEncodedArrayReader(
-            Dex owner,
-            EncodedValueReader arrayReader,
-            OffsetToIndexConverter offsetToIndexConverter
-    ) {
-        int size = arrayReader.readArray();
-        for (int i = 0; i < size; ++i) {
-            collectItemIndicesFromEncodedValueReader(
-                    owner, arrayReader, offsetToIndexConverter
-            );
-        }
-    }
-
-    private void collectItemIndicesFromEncodedValueReader(
-            Dex owner,
-            EncodedValueReader encodedValueReader,
-            OffsetToIndexConverter offsetToIndexConverter
-    ) {
-        switch (encodedValueReader.peek()) {
-            case EncodedValueReader.ENCODED_BYTE:
-                // Skip value.
-                encodedValueReader.readByte();
-                break;
-            case EncodedValueReader.ENCODED_SHORT:
-                // Skip value.
-                encodedValueReader.readShort();
-                break;
-            case EncodedValueReader.ENCODED_INT:
-                // Skip value.
-                encodedValueReader.readInt();
-                break;
-            case EncodedValueReader.ENCODED_LONG:
-                // Skip value.
-                encodedValueReader.readLong();
-                break;
-            case EncodedValueReader.ENCODED_CHAR:
-                // Skip value.
-                encodedValueReader.readChar();
-                break;
-            case EncodedValueReader.ENCODED_FLOAT:
-                // Skip value.
-                encodedValueReader.readFloat();
-                break;
-            case EncodedValueReader.ENCODED_DOUBLE:
-                // Skip value.
-                encodedValueReader.readDouble();
-                break;
-            case EncodedValueReader.ENCODED_STRING:
-                collectItemIndicesFromStringIndex(
-                        owner,
-                        encodedValueReader.readString(),
-                        offsetToIndexConverter
-                );
-                break;
-            case EncodedValueReader.ENCODED_TYPE:
-                collectItemIndicesFromTypeIndex(
-                        owner,
-                        encodedValueReader.readType(),
-                        offsetToIndexConverter
-                );
-                break;
-            case EncodedValueReader.ENCODED_FIELD:
-                collectItemIndicesFromFieldIndex(
-                        owner,
-                        encodedValueReader.readField(),
-                        offsetToIndexConverter
-                );
-                break;
-            case EncodedValueReader.ENCODED_ENUM:
-                collectItemIndicesFromFieldIndex(
-                        owner,
-                        encodedValueReader.readEnum(),
-                        offsetToIndexConverter
-                );
-                break;
-            case EncodedValueReader.ENCODED_METHOD:
-                collectItemIndicesFromMethodIndex(
-                        owner,
-                        encodedValueReader.readMethod(),
-                        offsetToIndexConverter
-                );
-                break;
-            case EncodedValueReader.ENCODED_ARRAY:
-                collectItemIndicesFromEncodedArrayReader(
-                        owner,
-                        encodedValueReader,
-                        offsetToIndexConverter
-                );
-                break;
-            case EncodedValueReader.ENCODED_ANNOTATION:
-                collectItemIndicesFromAnnotationReader(
-                        owner,
-                        encodedValueReader,
-                        offsetToIndexConverter
-
-                );
-                break;
-            case EncodedValueReader.ENCODED_NULL:
-                // Skip value.
-                encodedValueReader.readNull();
-                break;
-            case EncodedValueReader.ENCODED_BOOLEAN:
-                // Skip value.
-                encodedValueReader.readBoolean();
-                break;
-            default:
-                throw new DexException(
-                        "Unexpected type: " + Integer.toHexString(encodedValueReader.peek())
-                );
-        }
-    }
-
-    private void collectItemIndicesFromClassData(
-            Dex owner,
-            int classDataOffset,
-            OffsetToIndexConverter offsetToIndexConverter
-    ) {
-        if (classDataOffset == ClassDef.NO_OFFSET) {
-            return;
-        }
-
-        putValueIntoSetMap(
-                patchedDexToCollectedClassDataIndicesMap,
-                owner,
-                offsetToIndexConverter.getClassDataIndexByOffset(classDataOffset)
-        );
-
-        ClassData classData = owner.openSection(classDataOffset).readClassData();
-
-        for (ClassData.Field field : classData.instanceFields) {
-            collectItemIndicesFromFieldIndex(
-                    owner, field.fieldIndex, offsetToIndexConverter
-            );
-        }
-
-        for (ClassData.Field field : classData.staticFields) {
-            collectItemIndicesFromFieldIndex(
-                    owner, field.fieldIndex, offsetToIndexConverter
-            );
-        }
-
-        for (ClassData.Method method : classData.directMethods) {
-            collectItemIndicesFromMethodIndex(
-                    owner, method.methodIndex, offsetToIndexConverter
-            );
-            collectItemIndicesFromCode(
-                    owner, method.codeOffset, offsetToIndexConverter
-            );
-        }
-
-        for (ClassData.Method method : classData.virtualMethods) {
-            collectItemIndicesFromMethodIndex(
-                    owner, method.methodIndex, offsetToIndexConverter
-            );
-            collectItemIndicesFromCode(
-                    owner, method.codeOffset, offsetToIndexConverter
-            );
-        }
-    }
-
-    private void collectItemIndicesFromCode(
-            Dex owner,
-            int codeOffset,
-            OffsetToIndexConverter offsetToIndexConverter
-    ) {
-        if (codeOffset == ClassDef.NO_OFFSET) {
-            return;
-        }
-
-
-        putValueIntoSetMap(
-                patchedDexToCollectedCodeIndicesMap,
-                owner,
-                offsetToIndexConverter.getCodeIndexByOffset(codeOffset)
-        );
-
-        Code code = owner.openSection(codeOffset).readCode();
-
-        collectItemIndicesFromDebugInfoItem(
-                owner,
-                code.debugInfoOffset,
-                offsetToIndexConverter
-        );
-
-        InstructionReader ir = new InstructionReader(new ShortArrayCodeInput(code.instructions));
-        try {
-            ir.accept(new IndicesCollectorInsnVisitor(
-                    owner, offsetToIndexConverter
-            ));
-        } catch (EOFException e) {
-            throw new IllegalStateException(e);
-        }
-
-        for (Code.CatchHandler catchHandler : code.catchHandlers) {
-            for (int typeIndex : catchHandler.typeIndexes) {
-                collectItemIndicesFromTypeIndex(
-                        owner,
-                        typeIndex,
-                        offsetToIndexConverter
-                );
-            }
-        }
-    }
-
-    private void collectItemIndicesFromDebugInfoItem(
-            Dex owner,
-            int debugInfoItemOffset,
-            OffsetToIndexConverter offsetToIndexConverter
-    ) {
-        if (debugInfoItemOffset == ClassDef.NO_OFFSET) {
-            return;
-        }
-
-        putValueIntoSetMap(
-                patchedDexToCollectedDebugInfoIndicesMap,
-                owner,
-                offsetToIndexConverter.getDebugInfoItemIndexByOffset(debugInfoItemOffset)
-        );
-
-        DebugInfoItem debugInfoItem = owner.openSection(debugInfoItemOffset).readDebugInfoItem();
-
-        for (int stringIndex : debugInfoItem.parameterNames) {
-            collectItemIndicesFromStringIndex(
-                    owner, stringIndex, offsetToIndexConverter
-            );
-        }
-
-        final ByteArrayInputStream bais = new ByteArrayInputStream(debugInfoItem.infoSTM);
-        ByteInput inAdapter = new ByteInput() {
-            @Override
-            public byte readByte() {
-                return (byte) (bais.read() & 0xFF);
-            }
-        };
-
-        outside_whileloop:
-        while (true) {
-            int opcode = bais.read() & 0xFF;
-            switch (opcode) {
-                case DebugInfoItem.DBG_END_SEQUENCE: {
-                    break outside_whileloop;
-                }
-                case DebugInfoItem.DBG_ADVANCE_PC: {
-                    // Skip addrDiff.
-                    int addrDiff = Leb128.readUnsignedLeb128(inAdapter);
-                    break;
-                }
-                case DebugInfoItem.DBG_ADVANCE_LINE: {
-                    // Skip lineDiff.
-                    int lineDiff = Leb128.readSignedLeb128(inAdapter);
-                    break;
-                }
-                case DebugInfoItem.DBG_START_LOCAL:
-                case DebugInfoItem.DBG_START_LOCAL_EXTENDED: {
-                    // Skip registerNum.
-                    int registerNum = Leb128.readUnsignedLeb128(inAdapter);
-
-                    int nameIndex = Leb128.readUnsignedLeb128p1(inAdapter);
-                    collectItemIndicesFromStringIndex(
-                            owner, nameIndex, offsetToIndexConverter
-                    );
-
-                    int typeIndex = Leb128.readUnsignedLeb128p1(inAdapter);
-                    collectItemIndicesFromTypeIndex(
-                            owner, typeIndex, offsetToIndexConverter
-                    );
-
-                    if (opcode == DebugInfoItem.DBG_START_LOCAL_EXTENDED) {
-                        int sigIndex = Leb128.readUnsignedLeb128p1(inAdapter);
-                        collectItemIndicesFromStringIndex(
-                                owner, sigIndex, offsetToIndexConverter
-                        );
-                    }
-                    break;
-                }
-                case DebugInfoItem.DBG_END_LOCAL:
-                case DebugInfoItem.DBG_RESTART_LOCAL: {
-                    // Skip registerNum.
-                    int registerNum = Leb128.readUnsignedLeb128(inAdapter);
-                    break;
-                }
-                case DebugInfoItem.DBG_SET_FILE: {
-                    int nameIndex = Leb128.readUnsignedLeb128p1(inAdapter);
-                    collectItemIndicesFromStringIndex(
-                            owner, nameIndex, offsetToIndexConverter
-                    );
-                    break;
-                }
-                case DebugInfoItem.DBG_SET_PROLOGUE_END:
-                case DebugInfoItem.DBG_SET_EPILOGUE_BEGIN:
-                default: {
-                    break;
-                }
-            }
-        }
-    }
-
-    private void collectItemIndicesFromEncodedArray(
-            Dex owner,
-            int encodedArrayOffset,
-            OffsetToIndexConverter offsetToIndexConverter
-    ) {
-        if (encodedArrayOffset == ClassDef.NO_OFFSET) {
-            return;
-        }
-
-        putValueIntoSetMap(
-                patchedDexToCollectedEncodedArrayIndicesMap,
-                owner,
-                offsetToIndexConverter.getEncodedArrayIndexByOffset(encodedArrayOffset)
-        );
-
-        EncodedValue arrayVal = owner.openSection(encodedArrayOffset).readEncodedArray();
-        EncodedValueReader arrayReader =
-                new EncodedValueReader(arrayVal, EncodedValueReader.ENCODED_ARRAY);
-
-        collectItemIndicesFromEncodedArrayReader(
-                owner, arrayReader, offsetToIndexConverter
-        );
-    }
-
-    private <K, V> void putValueIntoSetMap(Map<K, Set<V>> map, K key, V value) {
-        Set<V> valueSet = map.get(key);
-        if (valueSet == null) {
-            valueSet = new HashSet<>();
-            map.put(key, valueSet);
-        }
-        valueSet.add(value);
-    }
-
-    private class SmallPatchSimulator<T extends Comparable<T>> {
-        private final TableOfContents.Section tocSec;
-        private final Dex.Section patchedSection;
-        private final int patchedItemCount;
-        private final IndexMap fullToSmallPatchMap;
-        private final Set<Integer> collectedIndices;
-
-        SmallPatchSimulator(
-                Dex patchedDex,
-                TableOfContents.Section tocSec,
-                IndexMap fullToSmallPatchMap,
-                Set<Integer> collectedIndices
-        ) {
-            if (tocSec.exists()) {
-                this.tocSec = tocSec;
-                this.patchedSection = patchedDex.openSection(tocSec);
-                this.patchedItemCount = tocSec.size;
-                this.fullToSmallPatchMap = fullToSmallPatchMap;
-                this.collectedIndices = collectedIndices;
-            } else {
-                this.tocSec = null;
-                this.patchedSection = null;
-                this.patchedItemCount = 0;
-                this.fullToSmallPatchMap = null;
-                this.collectedIndices = null;
-            }
-        }
-
-        private int getItemIndexOrOffset(T item, int index) {
-            if (item instanceof TableOfContents.Section.Item) {
-                return ((TableOfContents.Section.Item) item).off;
-            } else {
-                return index;
-            }
-        }
-
-        @SuppressWarnings("unchecked")
-        private T nextItem(DexDataBuffer buffer) {
-            switch (this.tocSec.type) {
-                case TableOfContents.SECTION_TYPE_TYPEIDS: {
-                    return (T) (Integer) buffer.readInt();
-                }
-                case TableOfContents.SECTION_TYPE_PROTOIDS: {
-                    return (T) buffer.readProtoId();
-                }
-                case TableOfContents.SECTION_TYPE_FIELDIDS: {
-                    return (T) buffer.readFieldId();
-                }
-                case TableOfContents.SECTION_TYPE_METHODIDS: {
-                    return (T) buffer.readMethodId();
-                }
-                case TableOfContents.SECTION_TYPE_CLASSDEFS: {
-                    return (T) buffer.readClassDef();
-                }
-                case TableOfContents.SECTION_TYPE_STRINGDATAS: {
-                    return (T) buffer.readStringData();
-                }
-                case TableOfContents.SECTION_TYPE_TYPELISTS: {
-                    return (T) buffer.readTypeList();
-                }
-                case TableOfContents.SECTION_TYPE_ANNOTATIONS: {
-                    return (T) buffer.readAnnotation();
-                }
-                case TableOfContents.SECTION_TYPE_ANNOTATIONSETS: {
-                    return (T) buffer.readAnnotationSet();
-                }
-                case TableOfContents.SECTION_TYPE_ANNOTATIONSETREFLISTS: {
-                    return (T) buffer.readAnnotationSetRefList();
-                }
-                case TableOfContents.SECTION_TYPE_ANNOTATIONSDIRECTORIES: {
-                    return (T) buffer.readAnnotationsDirectory();
-                }
-                case TableOfContents.SECTION_TYPE_DEBUGINFOS: {
-                    return (T) buffer.readDebugInfoItem();
-                }
-                case TableOfContents.SECTION_TYPE_CODES: {
-                    return (T) buffer.readCode();
-                }
-                case TableOfContents.SECTION_TYPE_ENCODEDARRAYS: {
-                    return (T) buffer.readEncodedArray();
-                }
-                case TableOfContents.SECTION_TYPE_CLASSDATA: {
-                    return (T) buffer.readClassData();
-                }
-                default:
-                    throw new IllegalStateException("unknown section type: " + this.tocSec.type);
-            }
-        }
-
-        private int getItemSize(T item) {
-            if (item instanceof TableOfContents.Section.Item) {
-                return ((TableOfContents.Section.Item) item).byteCountInDex();
-            } else {
-                if (item instanceof Integer) {
-                    return SizeOf.UINT;
-                } else {
-                    throw new IllegalStateException(
-                            "unexpected item type: " + item.getClass().getName()
-                    );
-                }
-            }
-        }
-
-        @SuppressWarnings("unchecked")
-        private T adjustItem(IndexMap indexMap, T item) {
-            switch (this.tocSec.type) {
-                case TableOfContents.SECTION_TYPE_TYPEIDS: {
-                    return (T) (Integer) indexMap.adjustStringIndex((Integer) item);
-                }
-                case TableOfContents.SECTION_TYPE_PROTOIDS: {
-                    return (T) indexMap.adjust((ProtoId) item);
-                }
-                case TableOfContents.SECTION_TYPE_FIELDIDS: {
-                    return (T) indexMap.adjust((FieldId) item);
-                }
-                case TableOfContents.SECTION_TYPE_METHODIDS: {
-                    return (T) indexMap.adjust((MethodId) item);
-                }
-                case TableOfContents.SECTION_TYPE_CLASSDEFS: {
-                    return (T) indexMap.adjust((ClassDef) item);
-                }
-                case TableOfContents.SECTION_TYPE_STRINGDATAS: {
-                    // nothing to do.
-                    return item;
-                }
-                case TableOfContents.SECTION_TYPE_TYPELISTS: {
-                    return (T) indexMap.adjust((TypeList) item);
-                }
-                case TableOfContents.SECTION_TYPE_ANNOTATIONS: {
-                    return (T) indexMap.adjust((Annotation) item);
-                }
-                case TableOfContents.SECTION_TYPE_ANNOTATIONSETS: {
-                    return (T) indexMap.adjust((AnnotationSet) item);
-                }
-                case TableOfContents.SECTION_TYPE_ANNOTATIONSETREFLISTS: {
-                    return (T) indexMap.adjust((AnnotationSetRefList) item);
-                }
-                case TableOfContents.SECTION_TYPE_ANNOTATIONSDIRECTORIES: {
-                    return (T) indexMap.adjust((AnnotationsDirectory) item);
-                }
-                case TableOfContents.SECTION_TYPE_DEBUGINFOS: {
-                    return (T) indexMap.adjust((DebugInfoItem) item);
-                }
-                case TableOfContents.SECTION_TYPE_CODES: {
-                    return (T) indexMap.adjust((Code) item);
-                }
-                case TableOfContents.SECTION_TYPE_ENCODEDARRAYS: {
-                    return (T) indexMap.adjust((EncodedValue) item);
-                }
-                case TableOfContents.SECTION_TYPE_CLASSDATA: {
-                    return (T) indexMap.adjust((ClassData) item);
-                }
-                default:
-                    throw new IllegalStateException("unknown section type: " + this.tocSec.type);
-            }
-        }
-
-        @SuppressWarnings("unchecked")
-        private void updateIndexOrOffset(
-                IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset
-        ) {
-            switch (this.tocSec.type) {
-                case TableOfContents.SECTION_TYPE_TYPEIDS: {
-                    indexMap.mapTypeIds(oldIndex, newIndex);
-                    break;
-                }
-                case TableOfContents.SECTION_TYPE_PROTOIDS: {
-                    indexMap.mapProtoIds(oldIndex, newIndex);
-                    break;
-                }
-                case TableOfContents.SECTION_TYPE_FIELDIDS: {
-                    indexMap.mapFieldIds(oldIndex, newIndex);
-                    break;
-                }
-                case TableOfContents.SECTION_TYPE_METHODIDS: {
-                    indexMap.mapMethodIds(oldIndex, newIndex);
-                    break;
-                }
-                case TableOfContents.SECTION_TYPE_CLASSDEFS: {
-                    // nothing to do.
-                    break;
-                }
-                case TableOfContents.SECTION_TYPE_STRINGDATAS: {
-                    indexMap.mapStringIds(oldIndex, newIndex);
-                    break;
-                }
-                case TableOfContents.SECTION_TYPE_TYPELISTS: {
-                    indexMap.mapTypeListOffset(oldOffset, newOffset);
-                    break;
-                }
-                case TableOfContents.SECTION_TYPE_ANNOTATIONS: {
-                    indexMap.mapAnnotationOffset(oldOffset, newOffset);
-                    break;
-                }
-                case TableOfContents.SECTION_TYPE_ANNOTATIONSETS: {
-                    indexMap.mapAnnotationSetOffset(oldOffset, newOffset);
-                    break;
-                }
-                case TableOfContents.SECTION_TYPE_ANNOTATIONSETREFLISTS: {
-                    indexMap.mapAnnotationSetRefListOffset(oldOffset, newOffset);
-                    break;
-                }
-                case TableOfContents.SECTION_TYPE_ANNOTATIONSDIRECTORIES: {
-                    indexMap.mapAnnotationsDirectoryOffset(oldOffset, newOffset);
-                    break;
-                }
-                case TableOfContents.SECTION_TYPE_DEBUGINFOS: {
-                    indexMap.mapDebugInfoItemOffset(oldOffset, newOffset);
-                    break;
-                }
-                case TableOfContents.SECTION_TYPE_CODES: {
-                    indexMap.mapCodeOffset(oldOffset, newOffset);
-                    break;
-                }
-                case TableOfContents.SECTION_TYPE_ENCODEDARRAYS: {
-                    indexMap.mapStaticValuesOffset(oldOffset, newOffset);
-                    break;
-                }
-                case TableOfContents.SECTION_TYPE_CLASSDATA: {
-                    indexMap.mapClassDataOffset(oldOffset, newOffset);
-                    break;
-                }
-                default:
-                    throw new IllegalStateException("unknown section type: " + this.tocSec.type);
-            }
-        }
-
-        public int simulate(int smallPatchBaseOffset) {
-            if (patchedSection == null) {
-                return 0;
-            }
-            if (collectedIndices == null || collectedIndices.isEmpty()) {
-                return 0;
-            }
-            int smallPatchedIndex = 0;
-            int smallPatchOffset = smallPatchBaseOffset;
-            for (int fullPatchedItemIndex = 0;
-                 fullPatchedItemIndex < this.patchedItemCount;
-                 ++fullPatchedItemIndex
-            ) {
-                T fullPatchedItemInSmallPatch = adjustItem(
-                        this.fullToSmallPatchMap, nextItem(this.patchedSection)
-                );
-                if (collectedIndices.contains(fullPatchedItemIndex)) {
-                    if (this.tocSec.isElementFourByteAligned) {
-                        smallPatchOffset = SizeOf.roundToTimesOfFour(smallPatchOffset);
-                    }
-
-                    int fullPatchedOffset = getItemIndexOrOffset(
-                            fullPatchedItemInSmallPatch, fullPatchedItemIndex
-                    );
-
-                    if (fullPatchedItemIndex != smallPatchedIndex
-                            || fullPatchedOffset != smallPatchOffset) {
-                        updateIndexOrOffset(
-                                this.fullToSmallPatchMap,
-                                fullPatchedItemIndex,
-                                fullPatchedOffset,
-                                smallPatchedIndex,
-                                smallPatchOffset
-                        );
-                    }
-
-                    ++smallPatchedIndex;
-                    smallPatchOffset += getItemSize(fullPatchedItemInSmallPatch);
-                }
-            }
-            return smallPatchOffset - smallPatchBaseOffset;
-        }
-    }
-
-    private class IndicesCollectorInsnVisitor extends InstructionVisitor {
-        private final Dex ownerDex;
-        private final OffsetToIndexConverter offsetToIndexConverter;
-
-        IndicesCollectorInsnVisitor(
-                Dex ownerDex, OffsetToIndexConverter offsetToIndexConverter
-        ) {
-            super(null);
-            this.ownerDex = ownerDex;
-            this.offsetToIndexConverter = offsetToIndexConverter;
-        }
-
-        @Override
-        public void visitZeroRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal) {
-            processIndexByType(index, indexType);
-        }
-
-        @Override
-        public void visitOneRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a) {
-            processIndexByType(index, indexType);
-        }
-
-        @Override
-        public void visitTwoRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int b) {
-            processIndexByType(index, indexType);
-        }
-
-        @Override
-        public void visitThreeRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int b, int c) {
-            processIndexByType(index, indexType);
-        }
-
-        @Override
-        public void visitFourRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int b, int c, int d) {
-            processIndexByType(index, indexType);
-        }
-
-        @Override
-        public void visitFiveRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int b, int c, int d, int e) {
-            processIndexByType(index, indexType);
-        }
-
-        @Override
-        public void visitRegisterRangeInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int registerCount) {
-            processIndexByType(index, indexType);
-        }
-
-        private void processIndexByType(int index, int indexType) {
-            switch (indexType) {
-                case InstructionCodec.INDEX_TYPE_STRING_REF: {
-                    collectItemIndicesFromStringIndex(
-                            ownerDex, index, offsetToIndexConverter
-                    );
-                    break;
-                }
-                case InstructionCodec.INDEX_TYPE_TYPE_REF: {
-                    collectItemIndicesFromTypeIndex(
-                            ownerDex, index, offsetToIndexConverter
-                    );
-                    break;
-                }
-                case InstructionCodec.INDEX_TYPE_FIELD_REF: {
-                    collectItemIndicesFromFieldIndex(
-                            ownerDex, index, offsetToIndexConverter
-                    );
-                    break;
-                }
-                case InstructionCodec.INDEX_TYPE_METHOD_REF: {
-                    collectItemIndicesFromMethodIndex(
-                            ownerDex, index, offsetToIndexConverter
-                    );
-                    break;
-                }
-            }
-        }
-    }
-}
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/immutable/ClassSimDef.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/immutable/ClassSimDef.java
new file mode 100644
index 00000000..7d968672
--- /dev/null
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/immutable/ClassSimDef.java
@@ -0,0 +1,103 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.build.immutable;
+
+import org.objectweb.asm.ClassReader;
+import org.objectweb.asm.ClassVisitor;
+import org.objectweb.asm.FieldVisitor;
+import org.objectweb.asm.MethodVisitor;
+import org.objectweb.asm.Opcodes;
+
+import java.util.HashSet;
+
+
+public class ClassSimDef {
+
+    int methodCount;
+    int fieldCount;
+    byte[] bytes;
+    HashSet<String> refFieldSet;
+    HashSet<String> refMtdSet;
+
+    public ClassSimDef(byte[] bytes, HashSet<String> refFieldSet, HashSet<String> refMtdSet) {
+        this.bytes = bytes;
+        this.refFieldSet = refFieldSet;
+        this.refMtdSet = refMtdSet;
+        init();
+    }
+
+    public void init() {
+        methodCount = 0;
+        fieldCount = 0;
+
+        ClassReader cr = new ClassReader(bytes);
+        ClassVisitor cv = new ClassVisitor(Opcodes.ASM4) {
+            String className;
+
+            @Override
+            public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {
+                className = name;
+                super.visit(version, access, name, signature, superName, interfaces);
+            }
+
+            @Override
+            public MethodVisitor visitMethod(int access, String mtdName, String mtdDesc, String mtdSig, String[] exceptions) {
+
+                String defMtd = className + ":" + mtdName + ":" + mtdDesc;
+                if (!refMtdSet.contains(defMtd)) {
+                    refMtdSet.add(defMtd);
+                    methodCount++;
+                }
+
+                MethodVisitor mv = super.visitMethod(access, mtdName, mtdDesc, mtdSig, exceptions);
+                mv = new MethodVisitor(Opcodes.ASM4, mv) {
+                    @Override
+                    public void visitFieldInsn(int opcode, String owner, String fName, String fDesc) {
+                        String invokeField = owner + ":" + fName + ":" + fDesc;
+                        if (!refFieldSet.contains(invokeField)) {
+                            refFieldSet.add(invokeField);
+                            fieldCount++;
+                        }
+                        super.visitFieldInsn(opcode, owner, fName, fDesc);
+                    }
+
+                    @Override
+                    public void visitMethodInsn(int opcode, String owner, String mName, String mDesc) {
+                        String invokeMtd = owner + ":" + mName + ":" + mDesc;
+                        if (!refMtdSet.contains(invokeMtd)) {
+                            refMtdSet.add(invokeMtd);
+                            methodCount++;
+                        }
+                        super.visitMethodInsn(opcode, owner, mName, mDesc);
+                    }
+                };
+                return mv;
+            }
+
+            @Override
+            public FieldVisitor visitField(int access, String name, String desc, String signature, Object value) {
+                String fieldDesc = className + ":" + name + ":" + desc;
+                if (!refFieldSet.contains(fieldDesc)) {
+                    refFieldSet.add(fieldDesc);
+                    fieldCount++;
+                }
+                return super.visitField(access, name, desc, signature, value);
+            }
+        };
+        cr.accept(cv, 0);
+    }
+}
\ No newline at end of file
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/immutable/DexRefData.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/immutable/DexRefData.java
new file mode 100644
index 00000000..a1e342eb
--- /dev/null
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/immutable/DexRefData.java
@@ -0,0 +1,38 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.build.immutable;
+
+import java.util.HashSet;
+import java.util.Set;
+
+public class DexRefData {
+    int methodNum;
+    int fieldNum;
+    public Set<String> refFields;
+    public Set<String> refMtds;
+
+    DexRefData() {
+        this(0, 0);
+    }
+
+    DexRefData(int methodNum, int fieldNum) {
+        this.methodNum = methodNum;
+        this.fieldNum = fieldNum;
+        refFields = new HashSet<>();
+        refMtds = new HashSet<>();
+    }
+}
\ No newline at end of file
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/info/PatchInfo.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/info/PatchInfo.java
index 2adf51a4..1ac70a60 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/info/PatchInfo.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/info/PatchInfo.java
@@ -23,13 +23,10 @@
  */
 public class PatchInfo {
 
-    private final Configuration config;
-
     private final PatchInfoGen infoGen;
 
 
     public PatchInfo(Configuration config) {
-        this.config = config;
         infoGen = new PatchInfoGen(config);
     }
 
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/Configuration.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/Configuration.java
index e1823c93..ef88dfc2 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/Configuration.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/Configuration.java
@@ -59,13 +59,14 @@
     protected static final String ATTR_VALUE = "value";
     protected static final String ATTR_NAME  = "name";
 
-    protected static final String ATTR_IGNORE_WARNING    = "ignoreWarning";
-    protected static final String ATTR_USE_SIGN          = "useSign";
-    protected static final String ATTR_SEVEN_ZIP_PATH    = "sevenZipPath";
-    protected static final String ATTR_DEX_MODE          = "dexMode";
-    protected static final String ATTR_PATTERN           = "pattern";
-    protected static final String ATTR_RES_IGNORE_CHANGE = "ignoreChange";
-    protected static final String ATTR_RES_LARGE_MOD     = "largeModSize";
+    protected static final String ATTR_IGNORE_WARNING   = "ignoreWarning";
+    protected static final String ATTR_IS_PROTECTED_APP = "isProtectedApp";
+    protected static final String ATTR_USE_SIGN         = "useSign";
+    protected static final String ATTR_SEVEN_ZIP_PATH   = "sevenZipPath";
+    protected static final String ATTR_DEX_MODE         = "dexMode";
+    protected static final String ATTR_PATTERN          = "pattern";
+    protected static final String ATTR_IGNORE_CHANGE    = "ignoreChange";
+    protected static final String ATTR_RES_LARGE_MOD    = "largeModSize";
 
     protected static final String ATTR_LOADER       = "loader";
     protected static final String ATTR_CONFIG_FIELD = "configField";
@@ -77,13 +78,14 @@
     /**
      * base config data
      */
-    public String           mOldApkPath;
-    public String           mNewApkPath;
-    public String           mOutFolder;
-    public File             mOldApkFile;
-    public File             mNewApkFile;
-    public boolean          mIgnoreWarning;
-    public boolean          mUsePreGeneratedPatchDex;
+    public String  mOldApkPath;
+    public String  mNewApkPath;
+    public String  mOutFolder;
+    public File    mOldApkFile;
+    public File    mNewApkFile;
+    public boolean mIgnoreWarning;
+    public boolean mIsProtectedApp;
+
     /**
      * lib config
      */
@@ -93,6 +95,8 @@
      */
     public HashSet<Pattern> mDexFilePattern;
     public HashSet<String>  mDexLoaderPattern;
+    public HashSet<String>  mDexIgnoreWarningLoaderPattern;
+
     public boolean          mDexRaw;
     /**
      * resource config
@@ -142,6 +146,7 @@ public Configuration(File config, File outputFile, File oldApkFile, File newApkF
         mSoFilePattern = new HashSet<>();
         mDexFilePattern = new HashSet<>();
         mDexLoaderPattern = new HashSet<>();
+        mDexIgnoreWarningLoaderPattern = new HashSet<>();
 
         mResFilePattern = new HashSet<>();
         mResRawPattern = new HashSet<>();
@@ -171,6 +176,7 @@ public Configuration(InputParam param) throws IOException, TinkerPatchException
         mSoFilePattern = new HashSet<>();
         mDexFilePattern = new HashSet<>();
         mDexLoaderPattern = new HashSet<>();
+        mDexIgnoreWarningLoaderPattern = new HashSet<>();
 
         mResFilePattern = new HashSet<>();
         mResRawPattern = new HashSet<>();
@@ -199,7 +205,7 @@ public Configuration(InputParam param) throws IOException, TinkerPatchException
         mUseApplyResource = param.useApplyResource;
 
         mDexLoaderPattern.addAll(param.dexLoaderPattern);
-
+        mDexIgnoreWarningLoaderPattern.addAll(param.dexIgnoreWarningLoaderPattern);
         //can be only raw or jar
         if (param.dexMode.equals("raw")) {
             mDexRaw = true;
@@ -214,7 +220,8 @@ public Configuration(InputParam param) throws IOException, TinkerPatchException
         mOutFolder = param.outFolder;
 
         mIgnoreWarning = param.ignoreWarning;
-        mUsePreGeneratedPatchDex = param.usePreGeneratedPatchDex;
+
+        mIsProtectedApp = param.isProtectedApp;
 
         mSevenZipPath = param.sevenZipPath;
         mPackageFields = param.configFields;
@@ -237,7 +244,7 @@ public String toString() {
         sb.append("newApk:" + mNewApkPath + "\n");
         sb.append("outputFolder:" + mOutFolder + "\n");
         sb.append("isIgnoreWarning:" + mIgnoreWarning + "\n");
-        sb.append("isInsertStubMode:" + mUsePreGeneratedPatchDex + "\n");
+        sb.append("isProtectedApp:" + mIsProtectedApp + "\n");
         sb.append("7-ZipPath:" + mSevenZipPath + "\n");
         sb.append("useSignAPk:" + mUseSignAPk + "\n");
 
@@ -259,6 +266,9 @@ public String toString() {
         for (String name : mDexLoaderPattern) {
             sb.append("dex loader:" + name + "\n");
         }
+        for (String name : mDexIgnoreWarningLoaderPattern) {
+            sb.append("dex ignore warning loader:" + name.toString() + "\n");
+        }
 
         sb.append("lib configs: \n");
         for (Pattern name : mSoFilePattern) {
@@ -303,7 +313,8 @@ private void createTempDirectory() throws TinkerPatchException {
 
         String tempNewName = newApkName.substring(0, newApkName.indexOf(TypedValue.FILE_APK));
 
-        if (tempNewName.equals(tempOldName)) {
+        // Bugfix: For windows user, filename is case-insensitive.
+        if (tempNewName.equalsIgnoreCase(tempOldName)) {
             tempOldName += "-old";
             tempNewName += "-new";
         }
@@ -410,6 +421,8 @@ private void readPropertyFromXml(Node node) throws IOException {
                     }
                     if (tagName.equals(ATTR_IGNORE_WARNING)) {
                         mIgnoreWarning = value.equals("true");
+                    } else if (tagName.equals(ATTR_IS_PROTECTED_APP)) {
+                        mIsProtectedApp = value.equals("true");
                     } else if (tagName.equals(ATTR_USE_SIGN)) {
                         mUseSignAPk = value.equals("true");
                     } else if (tagName.equals(ATTR_SEVEN_ZIP_PATH)) {
@@ -490,6 +503,8 @@ private void readDexPatternsFromXml(Node node) throws IOException {
                         addToPatterns(value, mDexFilePattern);
                     } else if (tagName.equals(ATTR_LOADER)) {
                         mDexLoaderPattern.add(value);
+                    } else if (tagName.equals(ATTR_IGNORE_CHANGE)) {
+                        mDexIgnoreWarningLoaderPattern.add(value);
                     } else {
                         System.err.println("unknown dex tag " + tagName);
                     }
@@ -531,7 +546,7 @@ private void readResPatternsFromXml(Node node) throws IOException {
                     if (tagName.equals(ATTR_PATTERN)) {
                         mResRawPattern.add(value);
                         addToPatterns(value, mResFilePattern);
-                    } else if (tagName.equals(ATTR_RES_IGNORE_CHANGE)) {
+                    } else if (tagName.equals(ATTR_IGNORE_CHANGE)) {
                         addToPatterns(value, mResIgnoreChangePattern);
                     } else if (tagName.equals(ATTR_RES_LARGE_MOD)) {
                         mLargeModSize = Integer.valueOf(value);
@@ -576,5 +591,4 @@ private void addToPatterns(String value, HashSet<Pattern> patterns) throws IOExc
         patterns.add(pattern);
     }
 
-}
-
+}
\ No newline at end of file
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/InputParam.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/InputParam.java
index 348f431a..6bc9e9e0 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/InputParam.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/InputParam.java
@@ -35,14 +35,16 @@
     public final String  storealias;
     public final String  storepass;
     public final boolean ignoreWarning;
-    public final boolean usePreGeneratedPatchDex;
+    public final boolean isProtectedApp;
     public final boolean useSign;
 
     /**
      * tinkerPatch.dex
      */
-    public final ArrayList<String>       dexFilePattern;
-    public final ArrayList<String>       dexLoaderPattern;
+    public final ArrayList<String> dexFilePattern;
+    public final ArrayList<String> dexLoaderPattern;
+    public final ArrayList<String> dexIgnoreWarningLoaderPattern;
+
     public final String                  dexMode;
     /**
      * tinkerPatch.lib
@@ -82,11 +84,13 @@ private InputParam(
         String storealias,
         String storepass,
         boolean ignoreWarning,
-        boolean usePreGeneratedPatchDex,
+        boolean isProtectedApp,
         boolean useSign,
 
         ArrayList<String> dexFilePattern,
         ArrayList<String> dexLoaderPattern,
+        ArrayList<String> dexIgnoreChangeLoaderPattern,
+
         String dexMode,
         ArrayList<String> soFilePattern,
         ArrayList<String> resourceFilePattern,
@@ -105,11 +109,12 @@ private InputParam(
         this.storealias = storealias;
         this.storepass = storepass;
         this.ignoreWarning = ignoreWarning;
-        this.usePreGeneratedPatchDex = usePreGeneratedPatchDex;
+        this.isProtectedApp = isProtectedApp;
         this.useSign = useSign;
 
         this.dexFilePattern = dexFilePattern;
         this.dexLoaderPattern = dexLoaderPattern;
+        this.dexIgnoreWarningLoaderPattern = dexIgnoreChangeLoaderPattern;
         this.dexMode = dexMode;
 
         this.soFilePattern = soFilePattern;
@@ -135,14 +140,16 @@ private InputParam(
         private String  storealias;
         private String  storepass;
         private boolean ignoreWarning;
-        private boolean usePreGeneratedPatchDex;
+        private boolean isProtectedApp;
         private boolean useSign;
 
         /**
          * tinkerPatch.dex
          */
-        private ArrayList<String>       dexFilePattern;
-        private ArrayList<String>       dexLoaderPattern;
+        private ArrayList<String> dexFilePattern;
+        private ArrayList<String> dexLoaderPattern;
+        private ArrayList<String> dexIgnoreWarningLoaderPattern;
+
         private String                  dexMode;
         /**
          * tinkerPatch.lib
@@ -247,8 +254,8 @@ public Builder setIgnoreWarning(boolean ignoreWarning) {
             return this;
         }
 
-        public Builder setUsePreGeneratedPatchDex(boolean usePreGeneratedPatchDex) {
-            this.usePreGeneratedPatchDex = usePreGeneratedPatchDex;
+        public Builder setIsProtectedApp(boolean isProtectedApp) {
+            this.isProtectedApp = isProtectedApp;
             return this;
         }
 
@@ -257,6 +264,11 @@ public Builder setDexLoaderPattern(ArrayList<String> dexLoaderPattern) {
             return this;
         }
 
+        public Builder setDexIgnoreWarningLoaderPattern(ArrayList<String> loader) {
+            this.dexIgnoreWarningLoaderPattern = loader;
+            return this;
+        }
+
         public Builder setDexMode(String dexMode) {
             this.dexMode = dexMode;
             return this;
@@ -287,10 +299,11 @@ public InputParam create() {
                     storealias,
                     storepass,
                     ignoreWarning,
-                    usePreGeneratedPatchDex,
+                    isProtectedApp,
                     useSign,
                     dexFilePattern,
                     dexLoaderPattern,
+                    dexIgnoreWarningLoaderPattern,
                     dexMode,
                     soFilePattern,
                     resourceFilePattern,
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/DexClassesComparator.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/DexClassesComparator.java
index d0c99383..5c2eb055 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/DexClassesComparator.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/DexClassesComparator.java
@@ -57,12 +57,16 @@
  * Created by tangyinsheng on 2016/4/14.
  */
 public final class DexClassesComparator {
-    public static final int COMPARE_MODE_NORMAL = 0;
-    public static final int COMPARE_MODE_CAUSE_REF_CHANGE_ONLY = 1;
     private static final String TAG = "DexClassesComparator";
+
+    public static final int COMPARE_MODE_NORMAL = 0;
+    public static final int COMPARE_MODE_REFERRER_AFFECTED_CHANGE_ONLY = 1;
+
     private static final int DBG_FIRST_SPECIAL = 0x0A;  // the smallest special opcode
     private static final int DBG_LINE_BASE   = -4;      // the smallest line number increment
     private static final int DBG_LINE_RANGE  = 15;      // the number of line increments represented
+
+    private int compareMode = COMPARE_MODE_NORMAL;
     private final List<DexClassInfo> addedClassInfoList = new ArrayList<>();
     private final List<DexClassInfo> deletedClassInfoList = new ArrayList<>();
     // classDesc => [oldClassInfo, newClassInfo]
@@ -73,17 +77,17 @@
     private final Set<String> newDescriptorOfClassesToCheck = new HashSet<>();
     private final Map<String, DexClassInfo> oldClassDescriptorToClassInfoMap = new HashMap<>();
     private final Map<String, DexClassInfo> newClassDescriptorToClassInfoMap = new HashMap<>();
+
     // Record class descriptors whose references key (index or offset) of methods and fields
     // are changed.
     private final Set<String> refAffectedClassDescs = new HashSet<>();
     private final DexPatcherLogger logger = new DexPatcherLogger();
-    private int compareMode = COMPARE_MODE_NORMAL;
 
     public DexClassesComparator(String patternStringOfClassDescToCheck) {
         patternsOfClassDescToCheck.add(
-            Pattern.compile(
-                PatternUtils.dotClassNamePatternToDescriptorRegEx(patternStringOfClassDescToCheck)
-            )
+                Pattern.compile(
+                        PatternUtils.dotClassNamePatternToDescriptorRegEx(patternStringOfClassDescToCheck)
+                )
         );
     }
 
@@ -100,9 +104,9 @@ public DexClassesComparator(String... patternStringsOfClassDescToCheck) {
     public DexClassesComparator(Collection<String> patternStringsOfClassDescToCheck) {
         for (String patternStr : patternStringsOfClassDescToCheck) {
             patternsOfClassDescToCheck.add(
-                Pattern.compile(
-                    PatternUtils.dotClassNamePatternToDescriptorRegEx(patternStr)
-                )
+                    Pattern.compile(
+                            PatternUtils.dotClassNamePatternToDescriptorRegEx(patternStr)
+                    )
             );
         }
     }
@@ -122,15 +126,15 @@ public void setIgnoredRemovedClassDescPattern(Collection<String> patternStringsO
         patternsOfIgnoredRemovedClassDesc.clear();
         for (String patternStr : patternStringsOfLoaderClassDesc) {
             patternsOfIgnoredRemovedClassDesc.add(
-                Pattern.compile(
-                    PatternUtils.dotClassNamePatternToDescriptorRegEx(patternStr)
-                )
+                    Pattern.compile(
+                            PatternUtils.dotClassNamePatternToDescriptorRegEx(patternStr)
+                    )
             );
         }
     }
 
     public void setCompareMode(int mode) {
-        if (mode == COMPARE_MODE_NORMAL || mode == COMPARE_MODE_CAUSE_REF_CHANGE_ONLY) {
+        if (mode == COMPARE_MODE_NORMAL || mode == COMPARE_MODE_REFERRER_AFFECTED_CHANGE_ONLY) {
             this.compareMode = mode;
         } else {
             throw new IllegalArgumentException("bad compare mode: " + mode);
@@ -224,19 +228,22 @@ public void startCheck(DexGroup oldDexGroup, DexGroup newDexGroup) {
             // from result.
             if (Utils.isStringMatchesPatterns(desc, patternsOfIgnoredRemovedClassDesc)) {
                 logger.i(TAG, "Ignored deleted class: %s", desc);
-                continue;
             } else {
                 logger.i(TAG, "Deleted class: %s", desc);
+                deletedClassInfoList.add(oldClassDescriptorToClassInfoMap.get(desc));
             }
-            deletedClassInfoList.add(oldClassDescriptorToClassInfoMap.get(desc));
         }
 
         Set<String> addedClassDescs = new HashSet<>(newDescriptorOfClassesToCheck);
         addedClassDescs.removeAll(oldDescriptorOfClassesToCheck);
 
         for (String desc : addedClassDescs) {
-            logger.i(TAG, "Added class: %s", desc);
-            addedClassInfoList.add(newClassDescriptorToClassInfoMap.get(desc));
+            if (Utils.isStringMatchesPatterns(desc, patternsOfIgnoredRemovedClassDesc)) {
+                logger.i(TAG, "Ignored added class: %s", desc);
+            } else {
+                logger.i(TAG, "Added class: %s", desc);
+                addedClassInfoList.add(newClassDescriptorToClassInfoMap.get(desc));
+            }
         }
 
         Set<String> mayBeChangedClassDescs = new HashSet<>(oldDescriptorOfClassesToCheck);
@@ -253,24 +260,32 @@ public void startCheck(DexGroup oldDexGroup, DexGroup newDexGroup) {
                             oldClassInfo.classDef,
                             newClassInfo.classDef
                     )) {
-                        logger.i(TAG, "Changed class: %s", desc);
-                        changedClassDescToClassInfosMap.put(
-                                desc, new DexClassInfo[]{oldClassInfo, newClassInfo}
-                        );
+                        if (Utils.isStringMatchesPatterns(desc, patternsOfIgnoredRemovedClassDesc)) {
+                            logger.i(TAG, "Ignored changed class: %s", desc);
+                        } else {
+                            logger.i(TAG, "Changed class: %s", desc);
+                            changedClassDescToClassInfosMap.put(
+                                    desc, new DexClassInfo[]{oldClassInfo, newClassInfo}
+                            );
+                        }
                     }
                     break;
                 }
-                case COMPARE_MODE_CAUSE_REF_CHANGE_ONLY: {
-                    if (isClassChangeAffectedToRef(
+                case COMPARE_MODE_REFERRER_AFFECTED_CHANGE_ONLY: {
+                    if (isClassChangeAffectedToReferrer(
                             oldClassInfo.owner,
                             newClassInfo.owner,
                             oldClassInfo.classDef,
                             newClassInfo.classDef
                     )) {
-                        logger.i(TAG, "Ref-changed class: %s", desc);
-                        changedClassDescToClassInfosMap.put(
-                                desc, new DexClassInfo[]{oldClassInfo, newClassInfo}
-                        );
+                        if (Utils.isStringMatchesPatterns(desc, patternsOfIgnoredRemovedClassDesc)) {
+                            logger.i(TAG, "Ignored referrer-affected changed class: %s", desc);
+                        } else {
+                            logger.i(TAG, "Referrer-affected change class: %s", desc);
+                            changedClassDescToClassInfosMap.put(
+                                    desc, new DexClassInfo[]{oldClassInfo, newClassInfo}
+                            );
+                        }
                     }
                     break;
                 }
@@ -278,7 +293,7 @@ public void startCheck(DexGroup oldDexGroup, DexGroup newDexGroup) {
         }
     }
 
-    private boolean isClassChangeAffectedToRef(
+    private boolean isClassChangeAffectedToReferrer(
             Dex oldDex,
             Dex newDex,
             ClassDef oldClassDef,
@@ -295,7 +310,7 @@ private boolean isClassChangeAffectedToRef(
             }
 
             // Any changes on superclass could affect refs of members in current class.
-            if (isTypeChangeAffectedToRef(
+            if (isTypeChangeAffectedToReferrer(
                     oldDex, newDex, oldClassDef.supertypeIndex, newClassDef.supertypeIndex
             )) {
                 result = true;
@@ -306,7 +321,7 @@ private boolean isClassChangeAffectedToRef(
             // of members in current class.
             short[] oldInterfaceTypeIds = oldDex.interfaceTypeIndicesFromClassDef(oldClassDef);
             short[] newInterfaceTypeIds = newDex.interfaceTypeIndicesFromClassDef(newClassDef);
-            if (isTypeIdsChangeAffectedToRef(
+            if (isTypeIdsChangeAffectedToReferrer(
                     oldDex, newDex, oldInterfaceTypeIds, newInterfaceTypeIds, false
             )) {
                 result = true;
@@ -319,7 +334,7 @@ private boolean isClassChangeAffectedToRef(
                     (oldClassDef.classDataOffset != 0 ? oldDex.readClassData(oldClassDef) : null);
             ClassData newClassData =
                     (newClassDef.classDataOffset != 0 ? newDex.readClassData(newClassDef) : null);
-            if (isClassDataChangeAffectedToRef(
+            if (isClassDataChangeAffectedToReferrer(
                     oldDex, newDex, oldClassData, newClassData
             )) {
                 result = true;
@@ -334,7 +349,7 @@ private boolean isClassChangeAffectedToRef(
         return result;
     }
 
-    private boolean isTypeChangeAffectedToRef(
+    private boolean isTypeChangeAffectedToReferrer(
             Dex oldDex, Dex newDex, int oldTypeId, int newTypeId
     ) {
         if (oldTypeId != ClassDef.NO_INDEX && newTypeId != ClassDef.NO_INDEX) {
@@ -349,7 +364,7 @@ private boolean isTypeChangeAffectedToRef(
             ClassDef oldClassDef = (oldClassInfo != null ? oldClassInfo.classDef : null);
             ClassDef newClassDef = (newClassInfo != null ? newClassInfo.classDef : null);
             if (oldClassDef != null && newClassDef != null) {
-                return isClassChangeAffectedToRef(oldClassInfo.owner, newClassInfo.owner, oldClassDef, newClassDef);
+                return isClassChangeAffectedToReferrer(oldClassInfo.owner, newClassInfo.owner, oldClassDef, newClassDef);
             } else
             if (oldClassDef == null && newClassDef == null) {
                 return false;
@@ -366,7 +381,7 @@ private boolean isTypeChangeAffectedToRef(
         return false;
     }
 
-    private boolean isTypeIdsChangeAffectedToRef(
+    private boolean isTypeIdsChangeAffectedToReferrer(
             Dex oldDex,
             Dex newDex,
             short[] oldTypeIds,
@@ -386,7 +401,7 @@ private boolean isTypeIdsChangeAffectedToRef(
                     return true;
                 }
             } else {
-                if (isTypeChangeAffectedToRef(oldDex, newDex, oldTypeIds[i], newTypeIds[i])) {
+                if (isTypeChangeAffectedToReferrer(oldDex, newDex, oldTypeIds[i], newTypeIds[i])) {
                     return true;
                 }
             }
@@ -395,32 +410,32 @@ private boolean isTypeIdsChangeAffectedToRef(
         return false;
     }
 
-    private boolean isClassDataChangeAffectedToRef(
+    private boolean isClassDataChangeAffectedToReferrer(
             Dex oldDex,
             Dex newDex,
             ClassData oldClassData,
             ClassData newClassData
     ) {
         if (oldClassData != null && newClassData != null) {
-            if (isFieldsChangeAffectedToRef(
+            if (isFieldsChangeAffectedToReferrer(
                     oldDex, newDex, oldClassData.instanceFields, newClassData.instanceFields
             )) {
                 return true;
             }
 
-            if (isFieldsChangeAffectedToRef(
+            if (isFieldsChangeAffectedToReferrer(
                     oldDex, newDex, oldClassData.staticFields, newClassData.staticFields
             )) {
                 return true;
             }
 
-            if (isMethodsChangeAffectedToRef(
+            if (isMethodsChangeAffectedToReferrer(
                     oldDex, newDex, oldClassData.directMethods, newClassData.directMethods
             )) {
                 return true;
             }
 
-            if (isMethodsChangeAffectedToRef(
+            if (isMethodsChangeAffectedToReferrer(
                     oldDex, newDex, oldClassData.virtualMethods, newClassData.virtualMethods
             )) {
                 return true;
@@ -433,7 +448,7 @@ private boolean isClassDataChangeAffectedToRef(
         return false;
     }
 
-    private boolean isFieldsChangeAffectedToRef(
+    private boolean isFieldsChangeAffectedToReferrer(
             Dex oldDex,
             Dex newDex,
             Field[] oldFields,
@@ -471,7 +486,7 @@ private boolean isFieldsChangeAffectedToRef(
         return false;
     }
 
-    private boolean isMethodsChangeAffectedToRef(
+    private boolean isMethodsChangeAffectedToReferrer(
             Dex oldDex,
             Dex newDex,
             Method[] oldMethods,
@@ -516,7 +531,7 @@ private boolean isMethodsChangeAffectedToRef(
 
             short[] oldParameterIds = oldDex.parameterTypeIndicesFromMethodId(oldMethodId);
             short[] newParameterIds = newDex.parameterTypeIndicesFromMethodId(newMethodId);
-            if (isTypeIdsChangeAffectedToRef(
+            if (isTypeIdsChangeAffectedToReferrer(
                     oldDex, newDex, oldParameterIds, newParameterIds, true
             )) {
                 return true;
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/ExcludedClassModifiedChecker.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/ExcludedClassModifiedChecker.java
index e87132ff..1ed5a31c 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/ExcludedClassModifiedChecker.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/ExcludedClassModifiedChecker.java
@@ -26,6 +26,8 @@
 import java.io.File;
 import java.io.IOException;
 import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
@@ -45,19 +47,25 @@
     private static final int STMCODE_ERROR_LOADER_CLASS_FOUND_IN_SECONDARY_NEW_DEX = 0x06;
     private static final int STMCODE_ERROR_LOADER_CLASS_CHANGED                    = 0x07;
     private static final int STMCODE_END                                           = 0x08;
-    private final Configuration config;
+    private final Configuration        config;
     private final DexClassesComparator dexCmptor;
-    private Dex oldDex = null;
-    private Dex newDex = null;
-    private List<DexClassInfo> deletedClassInfos = null;
-    private List<DexClassInfo> addedClassInfos = null;
-    private Map<String, DexClassInfo[]> changedClassInfosMap = null;
-    private Set<String> oldClassesDescToCheck = new HashSet<>();
-    private Set<String> newClassesDescToCheck = new HashSet<>();
+    private Dex                         oldDex                = null;
+    private Dex                         newDex                = null;
+    private List<DexClassInfo>          deletedClassInfos     = null;
+    private List<DexClassInfo>          addedClassInfos       = null;
+    private Map<String, DexClassInfo[]> changedClassInfosMap  = null;
+    private Set<String>                 oldClassesDescToCheck = new HashSet<>();
+    private Set<String>                 newClassesDescToCheck = new HashSet<>();
+    private HashSet<Pattern>            ignoreChangeWarning   = new HashSet<>();
 
     public ExcludedClassModifiedChecker(Configuration config) {
         this.config = config;
         this.dexCmptor = new DexClassesComparator(config.mDexLoaderPattern);
+        for (String classname : config.mDexIgnoreWarningLoaderPattern) {
+            ignoreChangeWarning.add(Pattern.compile(
+                PatternUtils.dotClassNamePatternToDescriptorRegEx(classname)
+            ));
+        }
     }
 
     public void checkIfExcludedClassWasModifiedInNewDex(File oldFile, File newFile) throws IOException, TinkerPatchException {
@@ -98,7 +106,7 @@ public void checkIfExcludedClassWasModifiedInNewDex(File oldFile, File newFile)
                             dexCmptor.startCheck(oldDex, newDex);
                             deletedClassInfos = dexCmptor.getDeletedClassInfos();
                             addedClassInfos = dexCmptor.getAddedClassInfos();
-                            changedClassInfosMap = dexCmptor.getChangedClassDescToInfosMap();
+                            changedClassInfosMap = new HashMap<>(dexCmptor.getChangedClassDescToInfosMap());
 
                             // All loader classes are in new dex, while none of them in old one.
                             if (deletedClassInfos.isEmpty() && changedClassInfosMap.isEmpty() && !addedClassInfos.isEmpty()) {
@@ -106,6 +114,14 @@ public void checkIfExcludedClassWasModifiedInNewDex(File oldFile, File newFile)
                             } else {
                                 if (deletedClassInfos.isEmpty() && addedClassInfos.isEmpty()) {
                                     // class descriptor is completely matches, see if any contents changes.
+                                    ArrayList<String> removeClasses = new ArrayList<>();
+                                    for (String classname : changedClassInfosMap.keySet()) {
+                                        if (Utils.checkFileInPattern(ignoreChangeWarning, classname)) {
+                                            Logger.e("loader class pattern: " + classname + " has changed, but it match ignore change pattern, just ignore!");
+                                            removeClasses.add(classname);
+                                        }
+                                    }
+                                    changedClassInfosMap.keySet().removeAll(removeClasses);
                                     if (changedClassInfosMap.isEmpty()) {
                                         stmCode = STMCODE_END;
                                     } else {
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/FileOperation.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/FileOperation.java
index 62fa8630..2f38f6b9 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/FileOperation.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/FileOperation.java
@@ -247,13 +247,16 @@ public static void unZipAPk(String fileName, String filePath) throws IOException
      * @param zipFile     output zip file
      * @throws IOException
      */
-    public static void zipFiles(Collection<File> resFileList, File zipFile) throws IOException {
+    public static void zipFiles(Collection<File> resFileList, File zipFile, String comment) throws IOException {
         ZipOutputStream zipout = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(zipFile), TypedValue.BUFFER_SIZE));
         for (File resFile : resFileList) {
             if (resFile.exists()) {
                 zipFile(resFile, zipout, "");
             }
         }
+        if (comment != null) {
+            zipout.setComment(comment);
+        }
         zipout.close();
     }
 
@@ -364,14 +367,14 @@ public static String getZipEntryMd5(File file, String entryName) {
         return null;
     }
 
-    public static void zipInputDir(File inputDir, File outputFile) throws IOException {
+    public static void zipInputDir(File inputDir, File outputFile, String comment) throws IOException {
         File[] unzipFiles = inputDir.listFiles();
         List<File> collectFiles = new ArrayList<>();
         for (File f : unzipFiles) {
             collectFiles.add(f);
         }
 
-        FileOperation.zipFiles(collectFiles, outputFile);
+        FileOperation.zipFiles(collectFiles, outputFile, comment);
     }
 
     public static boolean sevenZipInputDir(File inputDir, File outputFile, Configuration config) {
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/Logger.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/Logger.java
index 777c3245..93115188 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/Logger.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/Logger.java
@@ -51,6 +51,7 @@ public static void d(final String format, final Object... obj) {
         }
         //add \n
         System.out.printf(log + "\n");
+        System.out.flush();
 
         logWriter.writeLineToInfoFile(log);
     }
@@ -66,8 +67,9 @@ public static void e(final String format, final Object... obj) {
         }
         //add \n
         System.err.printf(log + "\n");
-        logWriter.writeLineToInfoFile(log);
+        System.err.flush();
 
+        logWriter.writeLineToInfoFile(log);
     }
 
 }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/TypedValue.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/TypedValue.java
index 13120a8d..3d5822cb 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/TypedValue.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/TypedValue.java
@@ -24,19 +24,18 @@
 
     public static final int K_BYTES = 1024;
 
-    public static final String FILE_TXT                 = ".txt";
-    public static final String FILE_XML                 = ".xml";
-    public static final String FILE_APK                 = ".apk";
-    public static final String FILE_CONFIG              = "config.xml";
-    public static final String FILE_LOG                 = "log.txt";
-    public static final String SO_LOG_FILE              = "so_log.txt";
-    public static final String SO_META_FILE             = "so_meta.txt";
-    public static final String DEX_LOG_FILE             = "dex_log.txt";
-    public static final String DEX_META_FILE            = "dex_meta.txt";
-    public static final String DEX_TEMP_PATCH_DIR       = "tempPatchedDexes";
-    public static final String DEX_SMALLPATCH_INFO_FILE = "smallpatch_info.ddextra";
-    public static final String RES_LOG_FILE             = "res_log.txt";
-    public static final String RES_META_TXT             = "res_meta.txt";
+    public static final String FILE_TXT           = ".txt";
+    public static final String FILE_XML           = ".xml";
+    public static final String FILE_APK           = ".apk";
+    public static final String FILE_CONFIG        = "config.xml";
+    public static final String FILE_LOG           = "log.txt";
+    public static final String SO_LOG_FILE        = "so_log.txt";
+    public static final String SO_META_FILE       = "so_meta.txt";
+    public static final String DEX_LOG_FILE       = "dex_log.txt";
+    public static final String DEX_META_FILE      = "dex_meta.txt";
+    public static final String DEX_TEMP_PATCH_DIR = "tempPatchedDexes";
+    public static final String RES_LOG_FILE       = "res_log.txt";
+    public static final String RES_META_TXT       = "res_meta.txt";
 
     public static final String FILE_ASSETS = "assets";
 
@@ -55,10 +54,10 @@
     public static final double DEX_JAR_PATCH_MAX_RATIO = 1.0;
     public static final double BSDIFF_PATCH_MAX_RATIO  = 0.8;
 
-    public static final String RES_ARSC        = "resources.arsc";
-    public static final String RES_MANIFEST    = "AndroidManifest.xml";
-    public static final String RES_OUT         = "resources_out.zip";
-    public static final String RES_OUT_7ZIP    = "resources_out_7z.zip";
+    public static final String RES_ARSC     = "resources.arsc";
+    public static final String RES_MANIFEST = "AndroidManifest.xml";
+    public static final String RES_OUT      = "resources_out.zip";
+    public static final String RES_OUT_7ZIP = "resources_out_7z.zip";
 
     public static final int ADD       = 1;
     public static final int MOD       = 2;
@@ -70,8 +69,4 @@
     public static final String LARGE_MOD_TITLE = "large modify:";
     public static final String DEL_TITLE       = "delete:";
     public static final String PATTERN_TITLE   = "pattern:";
-
-    public static final String TEST_STRING_VALUE_A = "only use for test tinker resource: a";
-    public static final String TEST_STRING_VALUE_B = "only use for test tinker resource: b";
-
 }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/Utils.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/Utils.java
index bcc20917..400bc9b0 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/Utils.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/Utils.java
@@ -24,9 +24,12 @@
 import com.tencent.tinker.commons.ziputil.TinkerZipOutputStream;
 
 import java.io.BufferedOutputStream;
+import java.io.BufferedReader;
+import java.io.Closeable;
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
+import java.io.InputStreamReader;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Enumeration;
@@ -71,6 +74,10 @@ public static String convertToPatternString(String input) {
         return input;
     }
 
+    public static boolean isNullOrNil(final String object) {
+        return (object == null) || (object.length() <= 0);
+    }
+
     public static boolean isStringMatchesPatterns(String str, Collection<Pattern> patterns) {
         for (Pattern pattern : patterns) {
             if (pattern.matcher(str).matches()) {
@@ -125,6 +132,9 @@ public static String genResOutputFile(File output, File newZipFile, Configuratio
                     );
                 }
                 String name = zipEntry.getName();
+                if (name.contains("../")) {
+                    continue;
+                }
                 if (Utils.checkFileInPattern(config.mResFilePattern, name)) {
                     //won't contain in add set.
                     if (!deletedSet.contains(name)
@@ -210,4 +220,33 @@ public static boolean checkBsDiffFileSize(File bsDiffFile, File newFile) {
         }
         return true;
     }
+
+    public static void closeQuietly(Closeable closeable) {
+        try {
+            if (closeable != null) {
+                closeable.close();
+            }
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static void exec(ArrayList<String> args, File path) throws RuntimeException, IOException, InterruptedException {
+        ProcessBuilder ps = new ProcessBuilder(args);
+        ps.redirectErrorStream(true);
+        if (path != null) {
+            ps.directory(path);
+        }
+        Process pr = ps.start();
+        BufferedReader ins = new BufferedReader(new InputStreamReader(pr.getInputStream()));
+        String line;
+        while ((line = ins.readLine()) != null) {
+            System.out.println(line);
+        }
+        if (pr.waitFor() != 0) {
+            throw new RuntimeException("exec cmd failed! args: " + args);
+        }
+        ins.close();
+    }
+
 }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/org/jf/dexlib2/builder/BuilderMutableMethodImplementation.java b/tinker-build/tinker-patch-lib/src/main/java/org/jf/dexlib2/builder/BuilderMutableMethodImplementation.java
index 620e5e43..71e6168d 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/org/jf/dexlib2/builder/BuilderMutableMethodImplementation.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/org/jf/dexlib2/builder/BuilderMutableMethodImplementation.java
@@ -143,7 +143,7 @@
 import javax.annotation.Nullable;
 
 /**
- * Created by tangyinsheng on 2016/10/9.
+ * Created by tangyinsheng on 2017/02/16.
  */
 public class BuilderMutableMethodImplementation implements MethodImplementation {
     private final DexBuilder dexBuilder;
@@ -219,8 +219,12 @@ public void perform() {
         }
     }
 
-    public BuilderMutableMethodImplementation(int registerCount) {
-        this.dexBuilder = null;
+    private interface Task {
+        void perform();
+    }
+
+    public BuilderMutableMethodImplementation(DexBuilder dexBuilder, int registerCount) {
+        this.dexBuilder = dexBuilder;
         this.registerCount = registerCount;
     }
 
@@ -281,7 +285,7 @@ public int size() {
                         assert input != null;
                         if (fixInstructions) {
                             throw new IllegalStateException("This iterator was invalidated by a change to"
-                                + " this MutableMethodImplementation.");
+                                    + " this MutableMethodImplementation.");
                         }
                         return input.getDebugItems();
                     }
@@ -470,7 +474,7 @@ private void fixInstructions() {
                         BuilderInstruction targetInstruction = targetLocation.instruction;
                         if (targetInstruction == null) {
                             throw new IllegalStateException(String.format("Switch instruction at address/index "
-                                + "0x%x/%d points to the end of the method.", location.codeAddress, location.index));
+                                    + "0x%x/%d points to the end of the method.", location.codeAddress, location.index));
                         }
 
                         if (targetInstruction.getOpcode() == Opcode.NOP) {
@@ -478,21 +482,21 @@ private void fixInstructions() {
                         }
                         if (targetInstruction == null || !(targetInstruction instanceof BuilderSwitchPayload)) {
                             throw new IllegalStateException(String.format("Switch instruction at address/index "
-                                + "0x%x/%d does not refer to a payload instruction.",
+                                            + "0x%x/%d does not refer to a payload instruction.",
                                     location.codeAddress, location.index));
                         }
                         if ((instruction.opcode == Opcode.PACKED_SWITCH
-                            && targetInstruction.getOpcode() != Opcode.PACKED_SWITCH_PAYLOAD)
-                            || (instruction.opcode == Opcode.SPARSE_SWITCH
-                            && targetInstruction.getOpcode() != Opcode.SPARSE_SWITCH_PAYLOAD)) {
+                                && targetInstruction.getOpcode() != Opcode.PACKED_SWITCH_PAYLOAD)
+                                || (instruction.opcode == Opcode.SPARSE_SWITCH
+                                        && targetInstruction.getOpcode() != Opcode.SPARSE_SWITCH_PAYLOAD)) {
                             throw new IllegalStateException(String.format("Switch instruction at address/index "
-                                + "0x%x/%d refers to the wrong type of payload instruction.",
+                                            + "0x%x/%d refers to the wrong type of payload instruction.",
                                     location.codeAddress, location.index));
                         }
 
                         if (!payloadLocations.add(targetLocation)) {
                             throw new IllegalStateException("Multiple switch instructions refer to the same payload. "
-                                + "This is not currently supported. Please file a bug :)");
+                                    + "This is not currently supported. Please file a bug :)");
                         }
 
                         ((BuilderSwitchPayload) targetInstruction).referrer = location;
@@ -634,6 +638,11 @@ private Label newLabel(@Nonnull int[] codeAddressToIndex, int codeAddress) {
         return referent.addNewLabel();
     }
 
+    private static class SwitchPayloadReferenceLabel extends Label {
+        @Nonnull
+        public MethodLocation switchLocation;
+    }
+
     @Nonnull
     public Label newSwitchPayloadReferenceLabel(@Nonnull MethodLocation switchLocation,
                                                 @Nonnull int[] codeAddressToIndex, int codeAddress) {
@@ -1008,7 +1017,7 @@ private MethodLocation findSwitchForPayload(@Nonnull MethodLocation payloadLocat
                 if (label instanceof SwitchPayloadReferenceLabel) {
                     if (switchLocation != null) {
                         throw new IllegalStateException("Multiple switch instructions refer to the same payload. "
-                            + "This is not currently supported. Please file a bug :)");
+                                + "This is not currently supported. Please file a bug :)");
                     }
                     switchLocation = ((SwitchPayloadReferenceLabel) label).switchLocation;
                 }
@@ -1129,14 +1138,4 @@ private BuilderDebugItem convertDebugItem(@Nonnull DebugItem debugItem) {
                 throw new ExceptionWithContext("Invalid debug item type: " + debugItem.getDebugItemType());
         }
     }
-
-    private interface Task {
-        void perform();
-    }
-
-    private static class SwitchPayloadReferenceLabel extends Label {
-        @Nonnull
-        public MethodLocation switchLocation;
-    }
-}
-
+}
\ No newline at end of file
diff --git a/tinker-commons/build.gradle b/tinker-commons/build.gradle
index c6025027..b7de68c6 100644
--- a/tinker-commons/build.gradle
+++ b/tinker-commons/build.gradle
@@ -12,7 +12,8 @@ dependencies {
     compile project(':third-party:bsdiff-util')
 }
 
-task buildSdk(type: Copy, dependsOn: [build]) {
+task buildTinkerSdk(type: Copy, dependsOn: [build]) {
+    group = "tinker"
     from('build/libs') {
         include '*.jar'
         exclude '*javadoc.jar'
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/DexPatchApplier.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/DexPatchApplier.java
index 42d8c19b..1d9f7fef 100644
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/DexPatchApplier.java
+++ b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/DexPatchApplier.java
@@ -33,8 +33,7 @@
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.TypeList;
 import com.tencent.tinker.android.dex.util.CompareUtils;
-import com.tencent.tinker.android.dx.util.Hex;
-import com.tencent.tinker.android.dx.util.IndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 import com.tencent.tinker.commons.dexpatcher.algorithms.patch.AnnotationSectionPatchAlgorithm;
 import com.tencent.tinker.commons.dexpatcher.algorithms.patch.AnnotationSetRefListSectionPatchAlgorithm;
 import com.tencent.tinker.commons.dexpatcher.algorithms.patch.AnnotationSetSectionPatchAlgorithm;
@@ -52,7 +51,6 @@
 import com.tencent.tinker.commons.dexpatcher.algorithms.patch.TypeIdSectionPatchAlgorithm;
 import com.tencent.tinker.commons.dexpatcher.algorithms.patch.TypeListSectionPatchAlgorithm;
 import com.tencent.tinker.commons.dexpatcher.struct.DexPatchFile;
-import com.tencent.tinker.commons.dexpatcher.struct.SmallPatchedDexItemFile;
 
 import java.io.BufferedOutputStream;
 import java.io.File;
@@ -69,14 +67,9 @@
     private final Dex oldDex;
     private final Dex patchedDex;
 
-    /** May be null if we need to generate small patch. **/
     private final DexPatchFile patchFile;
 
-    private final SmallPatchedDexItemFile extraInfoFile;
-    private final IndexMap oldToFullPatchedIndexMap;
-    private final IndexMap patchedToSmallPatchedIndexMap;
-
-    private final String oldDexSignStr;
+    private final SparseIndexMap oldToPatchedIndexMap;
 
     private DexSectionPatchAlgorithm<StringData> stringDataSectionPatchAlg;
     private DexSectionPatchAlgorithm<Integer> typeIdSectionPatchAlg;
@@ -95,93 +88,21 @@
     private DexSectionPatchAlgorithm<AnnotationsDirectory> annotationsDirectorySectionPatchAlg;
 
     public DexPatchApplier(File oldDexIn, File patchFileIn) throws IOException {
-        this(
-                new Dex(oldDexIn),
-                (patchFileIn != null ? new DexPatchFile(patchFileIn) : null),
-                null
-        );
+        this(new Dex(oldDexIn), new DexPatchFile(patchFileIn));
     }
 
     public DexPatchApplier(InputStream oldDexIn, InputStream patchFileIn) throws IOException {
-        this(
-                new Dex(oldDexIn),
-                (patchFileIn != null ? new DexPatchFile(patchFileIn) : null),
-                null
-        );
-    }
-
-    public DexPatchApplier(InputStream oldDexIn, int initDexSize, InputStream patchFileIn) throws IOException {
-        this(
-                new Dex(oldDexIn, initDexSize),
-                (patchFileIn != null ? new DexPatchFile(patchFileIn) : null),
-                null
-        );
-    }
-
-    public DexPatchApplier(
-            File oldDexIn,
-            File patchFileIn,
-            SmallPatchedDexItemFile extraInfoFile
-    ) throws IOException {
-        this(
-                new Dex(oldDexIn),
-                (patchFileIn != null ? new DexPatchFile(patchFileIn) : null),
-                extraInfoFile
-        );
-    }
-
-    public DexPatchApplier(
-            InputStream oldDexIn,
-            InputStream patchFileIn,
-            SmallPatchedDexItemFile extraInfoFile
-    ) throws IOException {
-        this(
-                new Dex(oldDexIn),
-                (patchFileIn != null ? new DexPatchFile(patchFileIn) : null),
-                extraInfoFile
-        );
-    }
-
-    public DexPatchApplier(
-            InputStream oldDexIn,
-            int initDexSize,
-            InputStream patchFileIn,
-            SmallPatchedDexItemFile extraInfoFile
-    ) throws IOException {
-        this(
-                new Dex(oldDexIn, initDexSize),
-                (patchFileIn != null ? new DexPatchFile(patchFileIn) : null),
-                extraInfoFile
-        );
+        this(new Dex(oldDexIn), new DexPatchFile(patchFileIn));
     }
 
     public DexPatchApplier(
             Dex oldDexIn,
-            DexPatchFile patchFileIn,
-            SmallPatchedDexItemFile extraAddedDexElementsFile
+            DexPatchFile patchFileIn
     ) {
         this.oldDex = oldDexIn;
-        this.oldDexSignStr = Hex.toHexString(oldDexIn.computeSignature(false));
         this.patchFile = patchFileIn;
-        if (extraAddedDexElementsFile == null) {
-            this.patchedDex = new Dex(patchFileIn.getPatchedDexSize());
-        } else {
-            this.patchedDex = new Dex(
-                    extraAddedDexElementsFile.getPatchedDexSizeByOldDexSign(this.oldDexSignStr)
-            );
-        }
-        this.oldToFullPatchedIndexMap = new IndexMap();
-        this.patchedToSmallPatchedIndexMap = (extraAddedDexElementsFile != null ? new IndexMap() : null);
-        this.extraInfoFile = extraAddedDexElementsFile;
-
-        if ((patchFileIn == null) && (extraAddedDexElementsFile == null
-                || !extraAddedDexElementsFile.isAffectedOldDex(this.oldDexSignStr))) {
-            throw new UnsupportedOperationException(
-                    "patchFileIn is null, and extraAddedDexElementFile"
-                            + "(smallPatchInfo) is null or does not mention "
-                            + "oldDexIn."
-            );
-        }
+        this.patchedDex = new Dex(patchFileIn.getPatchedDexSize());
+        this.oldToPatchedIndexMap = new SparseIndexMap();
     }
 
     public void executeAndSaveTo(OutputStream out) throws IOException {
@@ -191,21 +112,19 @@ public void executeAndSaveTo(OutputStream out) throws IOException {
         if (oldDexSign == null) {
             throw new IOException("failed to compute old dex's signature.");
         }
-
-        if (this.patchFile != null) {
-            byte[] oldDexSignInPatchFile = this.patchFile.getOldDexSignature();
-            if (CompareUtils.uArrCompare(oldDexSign, oldDexSignInPatchFile) != 0) {
-                throw new IOException(
-                        String.format(
-                                "old dex signature mismatch! expected: %s, actual: %s",
-                                Arrays.toString(oldDexSign),
-                                Arrays.toString(oldDexSignInPatchFile)
-                        )
-                );
-            }
+        if (this.patchFile == null) {
+            throw new IllegalArgumentException("patch file is null.");
+        }
+        byte[] oldDexSignInPatchFile = this.patchFile.getOldDexSignature();
+        if (CompareUtils.uArrCompare(oldDexSign, oldDexSignInPatchFile) != 0) {
+            throw new IOException(
+                    String.format(
+                            "old dex signature mismatch! expected: %s, actual: %s",
+                            Arrays.toString(oldDexSign),
+                            Arrays.toString(oldDexSignInPatchFile)
+                    )
+            );
         }
-
-        String oldDexSignStr = Hex.toHexString(oldDexSign);
 
         // Firstly, set sections' offset after patched, sort according to their offset so that
         // the dex lib of aosp can calculate section size.
@@ -215,81 +134,42 @@ public void executeAndSaveTo(OutputStream out) throws IOException {
         patchedToc.header.size = 1;
         patchedToc.mapList.size = 1;
 
-        if (extraInfoFile == null || !extraInfoFile.isAffectedOldDex(this.oldDexSignStr)) {
-            patchedToc.stringIds.off
-                    = this.patchFile.getPatchedStringIdSectionOffset();
-            patchedToc.typeIds.off
-                    = this.patchFile.getPatchedTypeIdSectionOffset();
-            patchedToc.typeLists.off
-                    = this.patchFile.getPatchedTypeListSectionOffset();
-            patchedToc.protoIds.off
-                    = this.patchFile.getPatchedProtoIdSectionOffset();
-            patchedToc.fieldIds.off
-                    = this.patchFile.getPatchedFieldIdSectionOffset();
-            patchedToc.methodIds.off
-                    = this.patchFile.getPatchedMethodIdSectionOffset();
-            patchedToc.classDefs.off
-                    = this.patchFile.getPatchedClassDefSectionOffset();
-            patchedToc.mapList.off
-                    = this.patchFile.getPatchedMapListSectionOffset();
-            patchedToc.stringDatas.off
-                    = this.patchFile.getPatchedStringDataSectionOffset();
-            patchedToc.annotations.off
-                    = this.patchFile.getPatchedAnnotationSectionOffset();
-            patchedToc.annotationSets.off
-                    = this.patchFile.getPatchedAnnotationSetSectionOffset();
-            patchedToc.annotationSetRefLists.off
-                    = this.patchFile.getPatchedAnnotationSetRefListSectionOffset();
-            patchedToc.annotationsDirectories.off
-                    = this.patchFile.getPatchedAnnotationsDirectorySectionOffset();
-            patchedToc.encodedArrays.off
-                    = this.patchFile.getPatchedEncodedArraySectionOffset();
-            patchedToc.debugInfos.off
-                    = this.patchFile.getPatchedDebugInfoSectionOffset();
-            patchedToc.codes.off
-                    = this.patchFile.getPatchedCodeSectionOffset();
-            patchedToc.classDatas.off
-                    = this.patchFile.getPatchedClassDataSectionOffset();
-            patchedToc.fileSize
-                    = this.patchFile.getPatchedDexSize();
-        } else {
-            patchedToc.stringIds.off
-                    = this.extraInfoFile.getPatchedStringIdOffsetByOldDexSign(oldDexSignStr);
-            patchedToc.typeIds.off
-                    = this.extraInfoFile.getPatchedTypeIdOffsetByOldDexSign(oldDexSignStr);
-            patchedToc.typeLists.off
-                    = this.extraInfoFile.getPatchedTypeListOffsetByOldDexSign(oldDexSignStr);
-            patchedToc.protoIds.off
-                    = this.extraInfoFile.getPatchedProtoIdOffsetByOldDexSign(oldDexSignStr);
-            patchedToc.fieldIds.off
-                    = this.extraInfoFile.getPatchedFieldIdOffsetByOldDexSign(oldDexSignStr);
-            patchedToc.methodIds.off
-                    = this.extraInfoFile.getPatchedMethodIdOffsetByOldDexSign(oldDexSignStr);
-            patchedToc.classDefs.off
-                    = this.extraInfoFile.getPatchedClassDefOffsetByOldDexSign(oldDexSignStr);
-            patchedToc.mapList.off
-                    = this.extraInfoFile.getPatchedMapListOffsetByOldDexSign(oldDexSignStr);
-            patchedToc.stringDatas.off
-                    = this.extraInfoFile.getPatchedStringDataOffsetByOldDexSign(oldDexSignStr);
-            patchedToc.annotations.off
-                    = this.extraInfoFile.getPatchedAnnotationOffsetByOldDexSign(oldDexSignStr);
-            patchedToc.annotationSets.off
-                    = this.extraInfoFile.getPatchedAnnotationSetOffsetByOldDexSign(oldDexSignStr);
-            patchedToc.annotationSetRefLists.off
-                    = this.extraInfoFile.getPatchedAnnotationSetRefListOffsetByOldDexSign(oldDexSignStr);
-            patchedToc.annotationsDirectories.off
-                    = this.extraInfoFile.getPatchedAnnotationsDirectoryOffsetByOldDexSign(oldDexSignStr);
-            patchedToc.encodedArrays.off
-                    = this.extraInfoFile.getPatchedEncodedArrayOffsetByOldDexSign(oldDexSignStr);
-            patchedToc.debugInfos.off
-                    = this.extraInfoFile.getPatchedDebugInfoOffsetByOldDexSign(oldDexSignStr);
-            patchedToc.codes.off
-                    = this.extraInfoFile.getPatchedCodeOffsetByOldDexSign(oldDexSignStr);
-            patchedToc.classDatas.off
-                    = this.extraInfoFile.getPatchedClassDataOffsetByOldDexSign(oldDexSignStr);
-            patchedToc.fileSize
-                    = this.extraInfoFile.getPatchedDexSizeByOldDexSign(oldDexSignStr);
-        }
+        patchedToc.stringIds.off
+                = this.patchFile.getPatchedStringIdSectionOffset();
+        patchedToc.typeIds.off
+                = this.patchFile.getPatchedTypeIdSectionOffset();
+        patchedToc.typeLists.off
+                = this.patchFile.getPatchedTypeListSectionOffset();
+        patchedToc.protoIds.off
+                = this.patchFile.getPatchedProtoIdSectionOffset();
+        patchedToc.fieldIds.off
+                = this.patchFile.getPatchedFieldIdSectionOffset();
+        patchedToc.methodIds.off
+                = this.patchFile.getPatchedMethodIdSectionOffset();
+        patchedToc.classDefs.off
+                = this.patchFile.getPatchedClassDefSectionOffset();
+        patchedToc.mapList.off
+                = this.patchFile.getPatchedMapListSectionOffset();
+        patchedToc.stringDatas.off
+                = this.patchFile.getPatchedStringDataSectionOffset();
+        patchedToc.annotations.off
+                = this.patchFile.getPatchedAnnotationSectionOffset();
+        patchedToc.annotationSets.off
+                = this.patchFile.getPatchedAnnotationSetSectionOffset();
+        patchedToc.annotationSetRefLists.off
+                = this.patchFile.getPatchedAnnotationSetRefListSectionOffset();
+        patchedToc.annotationsDirectories.off
+                = this.patchFile.getPatchedAnnotationsDirectorySectionOffset();
+        patchedToc.encodedArrays.off
+                = this.patchFile.getPatchedEncodedArraySectionOffset();
+        patchedToc.debugInfos.off
+                = this.patchFile.getPatchedDebugInfoSectionOffset();
+        patchedToc.codes.off
+                = this.patchFile.getPatchedCodeSectionOffset();
+        patchedToc.classDatas.off
+                = this.patchFile.getPatchedClassDataSectionOffset();
+        patchedToc.fileSize
+                = this.patchFile.getPatchedDexSize();
 
         Arrays.sort(patchedToc.sections);
 
@@ -297,64 +177,49 @@ public void executeAndSaveTo(OutputStream out) throws IOException {
 
         // Secondly, run patch algorithms according to sections' dependencies.
         this.stringDataSectionPatchAlg = new StringDataSectionPatchAlgorithm(
-                patchFile, oldDex, patchedDex, oldToFullPatchedIndexMap,
-                patchedToSmallPatchedIndexMap, extraInfoFile
+                patchFile, oldDex, patchedDex, oldToPatchedIndexMap
         );
         this.typeIdSectionPatchAlg = new TypeIdSectionPatchAlgorithm(
-                patchFile, oldDex, patchedDex, oldToFullPatchedIndexMap,
-                patchedToSmallPatchedIndexMap, extraInfoFile
+                patchFile, oldDex, patchedDex, oldToPatchedIndexMap
         );
         this.protoIdSectionPatchAlg = new ProtoIdSectionPatchAlgorithm(
-                patchFile, oldDex, patchedDex, oldToFullPatchedIndexMap,
-                patchedToSmallPatchedIndexMap, extraInfoFile
+                patchFile, oldDex, patchedDex, oldToPatchedIndexMap
         );
         this.fieldIdSectionPatchAlg = new FieldIdSectionPatchAlgorithm(
-                patchFile, oldDex, patchedDex, oldToFullPatchedIndexMap,
-                patchedToSmallPatchedIndexMap, extraInfoFile
+                patchFile, oldDex, patchedDex, oldToPatchedIndexMap
         );
         this.methodIdSectionPatchAlg = new MethodIdSectionPatchAlgorithm(
-                patchFile, oldDex, patchedDex, oldToFullPatchedIndexMap,
-                patchedToSmallPatchedIndexMap, extraInfoFile
+                patchFile, oldDex, patchedDex, oldToPatchedIndexMap
         );
         this.classDefSectionPatchAlg = new ClassDefSectionPatchAlgorithm(
-                patchFile, oldDex, patchedDex, oldToFullPatchedIndexMap,
-                patchedToSmallPatchedIndexMap, extraInfoFile
+                patchFile, oldDex, patchedDex, oldToPatchedIndexMap
         );
         this.typeListSectionPatchAlg = new TypeListSectionPatchAlgorithm(
-                patchFile, oldDex, patchedDex, oldToFullPatchedIndexMap,
-                patchedToSmallPatchedIndexMap, extraInfoFile
+                patchFile, oldDex, patchedDex, oldToPatchedIndexMap
         );
         this.annotationSetRefListSectionPatchAlg = new AnnotationSetRefListSectionPatchAlgorithm(
-                patchFile, oldDex, patchedDex, oldToFullPatchedIndexMap,
-                patchedToSmallPatchedIndexMap, extraInfoFile
+                patchFile, oldDex, patchedDex, oldToPatchedIndexMap
         );
         this.annotationSetSectionPatchAlg = new AnnotationSetSectionPatchAlgorithm(
-                patchFile, oldDex, patchedDex, oldToFullPatchedIndexMap,
-                patchedToSmallPatchedIndexMap, extraInfoFile
+                patchFile, oldDex, patchedDex, oldToPatchedIndexMap
         );
         this.classDataSectionPatchAlg = new ClassDataSectionPatchAlgorithm(
-                patchFile, oldDex, patchedDex, oldToFullPatchedIndexMap,
-                patchedToSmallPatchedIndexMap, extraInfoFile
+                patchFile, oldDex, patchedDex, oldToPatchedIndexMap
         );
         this.codeSectionPatchAlg = new CodeSectionPatchAlgorithm(
-                patchFile, oldDex, patchedDex, oldToFullPatchedIndexMap,
-                patchedToSmallPatchedIndexMap, extraInfoFile
+                patchFile, oldDex, patchedDex, oldToPatchedIndexMap
         );
         this.debugInfoSectionPatchAlg = new DebugInfoItemSectionPatchAlgorithm(
-                patchFile, oldDex, patchedDex, oldToFullPatchedIndexMap,
-                patchedToSmallPatchedIndexMap, extraInfoFile
+                patchFile, oldDex, patchedDex, oldToPatchedIndexMap
         );
         this.annotationSectionPatchAlg = new AnnotationSectionPatchAlgorithm(
-                patchFile, oldDex, patchedDex, oldToFullPatchedIndexMap,
-                patchedToSmallPatchedIndexMap, extraInfoFile
+                patchFile, oldDex, patchedDex, oldToPatchedIndexMap
         );
         this.encodedArraySectionPatchAlg = new StaticValueSectionPatchAlgorithm(
-                patchFile, oldDex, patchedDex, oldToFullPatchedIndexMap,
-                patchedToSmallPatchedIndexMap, extraInfoFile
+                patchFile, oldDex, patchedDex, oldToPatchedIndexMap
         );
         this.annotationsDirectorySectionPatchAlg = new AnnotationsDirectorySectionPatchAlgorithm(
-                patchFile, oldDex, patchedDex, oldToFullPatchedIndexMap,
-                patchedToSmallPatchedIndexMap, extraInfoFile
+                patchFile, oldDex, patchedDex, oldToPatchedIndexMap
         );
 
         this.stringDataSectionPatchAlg.execute();
@@ -363,19 +228,15 @@ public void executeAndSaveTo(OutputStream out) throws IOException {
         this.protoIdSectionPatchAlg.execute();
         this.fieldIdSectionPatchAlg.execute();
         this.methodIdSectionPatchAlg.execute();
-        Runtime.getRuntime().gc();
         this.annotationSectionPatchAlg.execute();
         this.annotationSetSectionPatchAlg.execute();
         this.annotationSetRefListSectionPatchAlg.execute();
         this.annotationsDirectorySectionPatchAlg.execute();
-        Runtime.getRuntime().gc();
         this.debugInfoSectionPatchAlg.execute();
         this.codeSectionPatchAlg.execute();
-        Runtime.getRuntime().gc();
         this.classDataSectionPatchAlg.execute();
         this.encodedArraySectionPatchAlg.execute();
         this.classDefSectionPatchAlg.execute();
-        Runtime.getRuntime().gc();
 
         // Thirdly, write header, mapList. Calculate and write patched dex's sign and checksum.
         Dex.Section headerOut = this.patchedDex.openSection(patchedToc.header.off);
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/AnnotationSectionPatchAlgorithm.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/AnnotationSectionPatchAlgorithm.java
index 6d97bc26..66acfce3 100644
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/AnnotationSectionPatchAlgorithm.java
+++ b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/AnnotationSectionPatchAlgorithm.java
@@ -20,9 +20,9 @@
 import com.tencent.tinker.android.dex.Dex;
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
 import com.tencent.tinker.commons.dexpatcher.struct.DexPatchFile;
-import com.tencent.tinker.commons.dexpatcher.struct.SmallPatchedDexItemFile;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 /**
  * Created by tangyinsheng on 2016/7/4.
@@ -35,44 +35,9 @@ public AnnotationSectionPatchAlgorithm(
             DexPatchFile patchFile,
             Dex oldDex,
             Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            final SmallPatchedDexItemFile extraInfoFile
+            SparseIndexMap oldToPatchedIndexMap
     ) {
-        this(
-                patchFile,
-                oldDex,
-                patchedDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                new SmallPatchedDexItemChooser() {
-                    @Override
-                    public boolean isPatchedItemInSmallPatchedDex(
-                            String oldDexSign, int patchedItemIndex
-                    ) {
-                        return extraInfoFile.isAnnotationInSmallPatchedDex(
-                                oldDexSign, patchedItemIndex
-                        );
-                    }
-                }
-        );
-    }
-
-    public AnnotationSectionPatchAlgorithm(
-            DexPatchFile patchFile,
-            Dex oldDex,
-            Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            SmallPatchedDexItemChooser spdItemChooser
-    ) {
-        super(
-                patchFile,
-                oldDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                spdItemChooser
-        );
+        super(patchFile, oldDex, oldToPatchedIndexMap);
 
         if (patchedDex != null) {
             this.patchedAnnotationTocSec = patchedDex.getTableOfContents().annotations;
@@ -96,16 +61,7 @@ protected int getItemSize(Annotation item) {
     }
 
     @Override
-    protected int getFullPatchSectionBase() {
-        if (this.patchFile != null) {
-            return this.patchFile.getPatchedAnnotationSectionOffset();
-        } else {
-            return getTocSection(this.oldDex).off;
-        }
-    }
-
-    @Override
-    protected Annotation adjustItem(IndexMap indexMap, Annotation item) {
+    protected Annotation adjustItem(AbstractIndexMap indexMap, Annotation item) {
         return indexMap.adjust(item);
     }
 
@@ -116,14 +72,14 @@ protected int writePatchedItem(Annotation patchedItem) {
     }
 
     @Override
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         if (oldOffset != newOffset) {
-            indexMap.mapAnnotationOffset(oldOffset, newOffset);
+            sparseIndexMap.mapAnnotationOffset(oldOffset, newOffset);
         }
     }
 
     @Override
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
-        indexMap.markAnnotationDeleted(deletedOffset);
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
+        sparseIndexMap.markAnnotationDeleted(deletedOffset);
     }
 }
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/AnnotationSetRefListSectionPatchAlgorithm.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/AnnotationSetRefListSectionPatchAlgorithm.java
index e23ad8d2..5253c41c 100644
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/AnnotationSetRefListSectionPatchAlgorithm.java
+++ b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/AnnotationSetRefListSectionPatchAlgorithm.java
@@ -20,9 +20,9 @@
 import com.tencent.tinker.android.dex.Dex;
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
 import com.tencent.tinker.commons.dexpatcher.struct.DexPatchFile;
-import com.tencent.tinker.commons.dexpatcher.struct.SmallPatchedDexItemFile;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 /**
  * Created by tangyinsheng on 2016/7/4.
@@ -35,44 +35,9 @@ public AnnotationSetRefListSectionPatchAlgorithm(
             DexPatchFile patchFile,
             Dex oldDex,
             Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            final SmallPatchedDexItemFile extraInfoFile
+            SparseIndexMap oldToPatchedIndexMap
     ) {
-        this(
-                patchFile,
-                oldDex,
-                patchedDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                new SmallPatchedDexItemChooser() {
-                    @Override
-                    public boolean isPatchedItemInSmallPatchedDex(
-                            String oldDexSign, int patchedItemIndex
-                    ) {
-                        return extraInfoFile.isAnnotationSetRefListInSmallPatchedDex(
-                                oldDexSign, patchedItemIndex
-                        );
-                    }
-                }
-        );
-    }
-
-    public AnnotationSetRefListSectionPatchAlgorithm(
-            DexPatchFile patchFile,
-            Dex oldDex,
-            Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            SmallPatchedDexItemChooser spdItemChooser
-    ) {
-        super(
-                patchFile,
-                oldDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                spdItemChooser
-        );
+        super(patchFile, oldDex, oldToPatchedIndexMap);
 
         if (patchedDex != null) {
             this.patchedAnnotationSetRefListTocSec
@@ -98,16 +63,7 @@ protected int getItemSize(AnnotationSetRefList item) {
     }
 
     @Override
-    protected int getFullPatchSectionBase() {
-        if (this.patchFile != null) {
-            return this.patchFile.getPatchedAnnotationSetRefListSectionOffset();
-        } else {
-            return getTocSection(this.oldDex).off;
-        }
-    }
-
-    @Override
-    protected AnnotationSetRefList adjustItem(IndexMap indexMap, AnnotationSetRefList item) {
+    protected AnnotationSetRefList adjustItem(AbstractIndexMap indexMap, AnnotationSetRefList item) {
         return indexMap.adjust(item);
     }
 
@@ -118,14 +74,14 @@ protected int writePatchedItem(AnnotationSetRefList patchedItem) {
     }
 
     @Override
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         if (oldOffset != newOffset) {
-            indexMap.mapAnnotationSetRefListOffset(oldOffset, newOffset);
+            sparseIndexMap.mapAnnotationSetRefListOffset(oldOffset, newOffset);
         }
     }
 
     @Override
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
-        indexMap.markAnnotationSetRefListDeleted(deletedOffset);
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
+        sparseIndexMap.markAnnotationSetRefListDeleted(deletedOffset);
     }
 }
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/AnnotationSetSectionPatchAlgorithm.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/AnnotationSetSectionPatchAlgorithm.java
index 738229c1..33a053ee 100644
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/AnnotationSetSectionPatchAlgorithm.java
+++ b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/AnnotationSetSectionPatchAlgorithm.java
@@ -20,9 +20,9 @@
 import com.tencent.tinker.android.dex.Dex;
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
 import com.tencent.tinker.commons.dexpatcher.struct.DexPatchFile;
-import com.tencent.tinker.commons.dexpatcher.struct.SmallPatchedDexItemFile;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 /**
  * Created by tangyinsheng on 2016/7/4.
@@ -35,45 +35,9 @@ public AnnotationSetSectionPatchAlgorithm(
             DexPatchFile patchFile,
             Dex oldDex,
             Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            final SmallPatchedDexItemFile extraInfoFile
+            SparseIndexMap oldToPatchedIndexMap
     ) {
-        this(
-                patchFile,
-                oldDex,
-                patchedDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                new SmallPatchedDexItemChooser() {
-                    @Override
-                    public boolean isPatchedItemInSmallPatchedDex(
-                            String oldDexSign, int patchedItemIndex
-                    ) {
-                        return extraInfoFile.isAnnotationSetInSmallPatchedDex(
-                                oldDexSign, patchedItemIndex
-                        );
-                    }
-                }
-        );
-    }
-
-    public AnnotationSetSectionPatchAlgorithm(
-            DexPatchFile patchFile,
-            Dex oldDex,
-            Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            SmallPatchedDexItemChooser spdItemChooser
-    ) {
-        super(
-                patchFile,
-                oldDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                spdItemChooser
-        );
-
+        super(patchFile, oldDex, oldToPatchedIndexMap);
         if (patchedDex != null) {
             this.patchedAnnotationSetTocSec = patchedDex.getTableOfContents().annotationSets;
             this.patchedAnnotationSetSec = patchedDex.openSection(this.patchedAnnotationSetTocSec);
@@ -96,16 +60,7 @@ protected int getItemSize(AnnotationSet item) {
     }
 
     @Override
-    protected int getFullPatchSectionBase() {
-        if (this.patchFile != null) {
-            return this.patchFile.getPatchedAnnotationSetSectionOffset();
-        } else {
-            return getTocSection(this.oldDex).off;
-        }
-    }
-
-    @Override
-    protected AnnotationSet adjustItem(IndexMap indexMap, AnnotationSet item) {
+    protected AnnotationSet adjustItem(AbstractIndexMap indexMap, AnnotationSet item) {
         return indexMap.adjust(item);
     }
 
@@ -116,14 +71,14 @@ protected int writePatchedItem(AnnotationSet patchedItem) {
     }
 
     @Override
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         if (oldOffset != newOffset) {
-            indexMap.mapAnnotationSetOffset(oldOffset, newOffset);
+            sparseIndexMap.mapAnnotationSetOffset(oldOffset, newOffset);
         }
     }
 
     @Override
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
-        indexMap.markAnnotationSetDeleted(deletedOffset);
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
+        sparseIndexMap.markAnnotationSetDeleted(deletedOffset);
     }
 }
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/AnnotationsDirectorySectionPatchAlgorithm.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/AnnotationsDirectorySectionPatchAlgorithm.java
index 508d4336..c0402270 100644
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/AnnotationsDirectorySectionPatchAlgorithm.java
+++ b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/AnnotationsDirectorySectionPatchAlgorithm.java
@@ -20,9 +20,9 @@
 import com.tencent.tinker.android.dex.Dex;
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
 import com.tencent.tinker.commons.dexpatcher.struct.DexPatchFile;
-import com.tencent.tinker.commons.dexpatcher.struct.SmallPatchedDexItemFile;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 /**
  * Created by tangyinsheng on 2016/7/4.
@@ -35,44 +35,9 @@ public AnnotationsDirectorySectionPatchAlgorithm(
             DexPatchFile patchFile,
             Dex oldDex,
             Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            final SmallPatchedDexItemFile extraInfoFile
+            SparseIndexMap oldToPatchedIndexMap
     ) {
-        this(
-                patchFile,
-                oldDex,
-                patchedDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                new SmallPatchedDexItemChooser() {
-                    @Override
-                    public boolean isPatchedItemInSmallPatchedDex(
-                            String oldDexSign, int patchedItemIndex
-                    ) {
-                        return extraInfoFile.isAnnotationsDirectoryInSmallPatchedDex(
-                                oldDexSign, patchedItemIndex
-                        );
-                    }
-                }
-        );
-    }
-
-    public AnnotationsDirectorySectionPatchAlgorithm(
-            DexPatchFile patchFile,
-            Dex oldDex,
-            Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            SmallPatchedDexItemChooser spdItemChooser
-    ) {
-        super(
-                patchFile,
-                oldDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                spdItemChooser
-        );
+        super(patchFile, oldDex, oldToPatchedIndexMap);
 
         if (patchedDex != null) {
             this.patchedAnnotationsDirectoryTocSec = patchedDex.getTableOfContents().annotationsDirectories;
@@ -96,16 +61,7 @@ protected int getItemSize(AnnotationsDirectory item) {
     }
 
     @Override
-    protected int getFullPatchSectionBase() {
-        if (this.patchFile != null) {
-            return this.patchFile.getPatchedAnnotationsDirectorySectionOffset();
-        } else {
-            return getTocSection(this.oldDex).off;
-        }
-    }
-
-    @Override
-    protected AnnotationsDirectory adjustItem(IndexMap indexMap, AnnotationsDirectory item) {
+    protected AnnotationsDirectory adjustItem(AbstractIndexMap indexMap, AnnotationsDirectory item) {
         return indexMap.adjust(item);
     }
 
@@ -116,14 +72,14 @@ protected int writePatchedItem(AnnotationsDirectory patchedItem) {
     }
 
     @Override
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         if (oldOffset != newOffset) {
-            indexMap.mapAnnotationsDirectoryOffset(oldOffset, newOffset);
+            sparseIndexMap.mapAnnotationsDirectoryOffset(oldOffset, newOffset);
         }
     }
 
     @Override
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
-        indexMap.markAnnotationsDirectoryDeleted(deletedOffset);
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
+        sparseIndexMap.markAnnotationsDirectoryDeleted(deletedOffset);
     }
 }
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/ClassDataSectionPatchAlgorithm.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/ClassDataSectionPatchAlgorithm.java
index 5881c215..570e8162 100644
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/ClassDataSectionPatchAlgorithm.java
+++ b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/ClassDataSectionPatchAlgorithm.java
@@ -20,9 +20,9 @@
 import com.tencent.tinker.android.dex.Dex;
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
 import com.tencent.tinker.commons.dexpatcher.struct.DexPatchFile;
-import com.tencent.tinker.commons.dexpatcher.struct.SmallPatchedDexItemFile;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 /**
  * Created by tangyinsheng on 2016/7/4.
@@ -35,44 +35,9 @@ public ClassDataSectionPatchAlgorithm(
             DexPatchFile patchFile,
             Dex oldDex,
             Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            final SmallPatchedDexItemFile extraInfoFile
+            SparseIndexMap oldToPatchedIndexMap
     ) {
-        this(
-                patchFile,
-                oldDex,
-                patchedDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                new SmallPatchedDexItemChooser() {
-                    @Override
-                    public boolean isPatchedItemInSmallPatchedDex(
-                            String oldDexSign, int patchedItemIndex
-                    ) {
-                        return extraInfoFile.isClassDataInSmallPatchedDex(
-                                oldDexSign, patchedItemIndex
-                        );
-                    }
-                }
-        );
-    }
-
-    public ClassDataSectionPatchAlgorithm(
-            DexPatchFile patchFile,
-            Dex oldDex,
-            Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            SmallPatchedDexItemChooser spdItemChooser
-    ) {
-        super(
-                patchFile,
-                oldDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                spdItemChooser
-        );
+        super(patchFile, oldDex, oldToPatchedIndexMap);
 
         if (patchedDex != null) {
             this.patchedClassDataTocSec = patchedDex.getTableOfContents().classDatas;
@@ -96,16 +61,7 @@ protected int getItemSize(ClassData item) {
     }
 
     @Override
-    protected int getFullPatchSectionBase() {
-        if (this.patchFile != null) {
-            return this.patchFile.getPatchedClassDataSectionOffset();
-        } else {
-            return getTocSection(this.oldDex).off;
-        }
-    }
-
-    @Override
-    protected ClassData adjustItem(IndexMap indexMap, ClassData item) {
+    protected ClassData adjustItem(AbstractIndexMap indexMap, ClassData item) {
         return indexMap.adjust(item);
     }
 
@@ -116,14 +72,14 @@ protected int writePatchedItem(ClassData patchedItem) {
     }
 
     @Override
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         if (oldOffset != newOffset) {
-            indexMap.mapClassDataOffset(oldOffset, newOffset);
+            sparseIndexMap.mapClassDataOffset(oldOffset, newOffset);
         }
     }
 
     @Override
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
-        indexMap.markClassDataDeleted(deletedOffset);
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
+        sparseIndexMap.markClassDataDeleted(deletedOffset);
     }
 }
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/ClassDefSectionPatchAlgorithm.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/ClassDefSectionPatchAlgorithm.java
index 86f25fbb..9af801ed 100644
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/ClassDefSectionPatchAlgorithm.java
+++ b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/ClassDefSectionPatchAlgorithm.java
@@ -20,9 +20,9 @@
 import com.tencent.tinker.android.dex.Dex;
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
 import com.tencent.tinker.commons.dexpatcher.struct.DexPatchFile;
-import com.tencent.tinker.commons.dexpatcher.struct.SmallPatchedDexItemFile;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 /**
  * Created by tangyinsheng on 2016/7/4.
@@ -35,44 +35,9 @@ public ClassDefSectionPatchAlgorithm(
             DexPatchFile patchFile,
             Dex oldDex,
             Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            final SmallPatchedDexItemFile extraInfoFile
+            SparseIndexMap oldToPatchedIndexMap
     ) {
-        this(
-                patchFile,
-                oldDex,
-                patchedDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                new SmallPatchedDexItemChooser() {
-                    @Override
-                    public boolean isPatchedItemInSmallPatchedDex(
-                            String oldDexSign, int patchedItemIndex
-                    ) {
-                        return extraInfoFile.isClassDefInSmallPatchedDex(
-                                oldDexSign, patchedItemIndex
-                        );
-                    }
-                }
-        );
-    }
-
-    public ClassDefSectionPatchAlgorithm(
-            DexPatchFile patchFile,
-            Dex oldDex,
-            Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            SmallPatchedDexItemChooser spdItemChooser
-    ) {
-        super(
-                patchFile,
-                oldDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                spdItemChooser
-        );
+        super(patchFile, oldDex, oldToPatchedIndexMap);
 
         if (patchedDex != null) {
             this.patchedClassDefTocSec = patchedDex.getTableOfContents().classDefs;
@@ -97,16 +62,7 @@ protected int getItemSize(ClassDef item) {
     }
 
     @Override
-    protected int getFullPatchSectionBase() {
-        if (this.patchFile != null) {
-            return this.patchFile.getPatchedClassDefSectionOffset();
-        } else {
-            return getTocSection(this.oldDex).off;
-        }
-    }
-
-    @Override
-    protected ClassDef adjustItem(IndexMap indexMap, ClassDef item) {
+    protected ClassDef adjustItem(AbstractIndexMap indexMap, ClassDef item) {
         return indexMap.adjust(item);
     }
 
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/CodeSectionPatchAlgorithm.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/CodeSectionPatchAlgorithm.java
index d12abd74..023a4afd 100644
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/CodeSectionPatchAlgorithm.java
+++ b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/CodeSectionPatchAlgorithm.java
@@ -20,9 +20,9 @@
 import com.tencent.tinker.android.dex.Dex;
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
 import com.tencent.tinker.commons.dexpatcher.struct.DexPatchFile;
-import com.tencent.tinker.commons.dexpatcher.struct.SmallPatchedDexItemFile;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 /**
  * Created by tangyinsheng on 2016/7/4.
@@ -35,44 +35,9 @@ public CodeSectionPatchAlgorithm(
             DexPatchFile patchFile,
             Dex oldDex,
             Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            final SmallPatchedDexItemFile extraInfoFile
+            SparseIndexMap oldToPatchedIndexMap
     ) {
-        this(
-                patchFile,
-                oldDex,
-                patchedDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                new SmallPatchedDexItemChooser() {
-                    @Override
-                    public boolean isPatchedItemInSmallPatchedDex(
-                            String oldDexSign, int patchedItemIndex
-                    ) {
-                        return extraInfoFile.isCodeInSmallPatchedDex(
-                                oldDexSign, patchedItemIndex
-                        );
-                    }
-                }
-        );
-    }
-
-    public CodeSectionPatchAlgorithm(
-            DexPatchFile patchFile,
-            Dex oldDex,
-            Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            SmallPatchedDexItemChooser spdItemChooser
-    ) {
-        super(
-                patchFile,
-                oldDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                spdItemChooser
-        );
+        super(patchFile, oldDex, oldToPatchedIndexMap);
 
         if (patchedDex != null) {
             this.patchedCodeTocSec = patchedDex.getTableOfContents().codes;
@@ -96,16 +61,7 @@ protected int getItemSize(Code item) {
     }
 
     @Override
-    protected int getFullPatchSectionBase() {
-        if (this.patchFile != null) {
-            return this.patchFile.getPatchedCodeSectionOffset();
-        } else {
-            return getTocSection(this.oldDex).off;
-        }
-    }
-
-    @Override
-    protected Code adjustItem(IndexMap indexMap, Code item) {
+    protected Code adjustItem(AbstractIndexMap indexMap, Code item) {
         return indexMap.adjust(item);
     }
 
@@ -116,14 +72,14 @@ protected int writePatchedItem(Code patchedItem) {
     }
 
     @Override
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         if (oldOffset != newOffset) {
-            indexMap.mapCodeOffset(oldOffset, newOffset);
+            sparseIndexMap.mapCodeOffset(oldOffset, newOffset);
         }
     }
 
     @Override
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
-        indexMap.markCodeDeleted(deletedOffset);
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
+        sparseIndexMap.markCodeDeleted(deletedOffset);
     }
 }
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/DebugInfoItemSectionPatchAlgorithm.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/DebugInfoItemSectionPatchAlgorithm.java
index 955f1771..86295e07 100644
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/DebugInfoItemSectionPatchAlgorithm.java
+++ b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/DebugInfoItemSectionPatchAlgorithm.java
@@ -20,9 +20,9 @@
 import com.tencent.tinker.android.dex.Dex;
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
 import com.tencent.tinker.commons.dexpatcher.struct.DexPatchFile;
-import com.tencent.tinker.commons.dexpatcher.struct.SmallPatchedDexItemFile;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 /**
  * Created by tangyinsheng on 2016/7/4.
@@ -35,44 +35,9 @@ public DebugInfoItemSectionPatchAlgorithm(
             DexPatchFile patchFile,
             Dex oldDex,
             Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            final SmallPatchedDexItemFile extraInfoFile
+            SparseIndexMap oldToPatchedIndexMap
     ) {
-        this(
-                patchFile,
-                oldDex,
-                patchedDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                new SmallPatchedDexItemChooser() {
-                    @Override
-                    public boolean isPatchedItemInSmallPatchedDex(
-                            String oldDexSign, int patchedItemIndex
-                    ) {
-                        return extraInfoFile.isDebugInfoInSmallPatchedDex(
-                                oldDexSign, patchedItemIndex
-                        );
-                    }
-                }
-        );
-    }
-
-    public DebugInfoItemSectionPatchAlgorithm(
-            DexPatchFile patchFile,
-            Dex oldDex,
-            Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            SmallPatchedDexItemChooser spdItemChooser
-    ) {
-        super(
-                patchFile,
-                oldDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                spdItemChooser
-        );
+        super(patchFile, oldDex, oldToPatchedIndexMap);
 
         if (patchedDex != null) {
             this.patchedDebugInfoItemTocSec = patchedDex.getTableOfContents().debugInfos;
@@ -96,16 +61,7 @@ protected int getItemSize(DebugInfoItem item) {
     }
 
     @Override
-    protected int getFullPatchSectionBase() {
-        if (this.patchFile != null) {
-            return this.patchFile.getPatchedDebugInfoSectionOffset();
-        } else {
-            return getTocSection(this.oldDex).off;
-        }
-    }
-
-    @Override
-    protected DebugInfoItem adjustItem(IndexMap indexMap, DebugInfoItem item) {
+    protected DebugInfoItem adjustItem(AbstractIndexMap indexMap, DebugInfoItem item) {
         return indexMap.adjust(item);
     }
 
@@ -116,14 +72,14 @@ protected int writePatchedItem(DebugInfoItem patchedItem) {
     }
 
     @Override
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         if (oldOffset != newOffset) {
-            indexMap.mapDebugInfoItemOffset(oldOffset, newOffset);
+            sparseIndexMap.mapDebugInfoItemOffset(oldOffset, newOffset);
         }
     }
 
     @Override
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
-        indexMap.markDebugInfoItemDeleted(deletedOffset);
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
+        sparseIndexMap.markDebugInfoItemDeleted(deletedOffset);
     }
 }
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/DexSectionPatchAlgorithm.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/DexSectionPatchAlgorithm.java
index 835ebd94..be68c43d 100644
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/DexSectionPatchAlgorithm.java
+++ b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/DexSectionPatchAlgorithm.java
@@ -17,12 +17,11 @@
 package com.tencent.tinker.commons.dexpatcher.algorithms.patch;
 
 import com.tencent.tinker.android.dex.Dex;
-import com.tencent.tinker.android.dex.SizeOf;
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.Hex;
-import com.tencent.tinker.android.dx.util.IndexMap;
 import com.tencent.tinker.commons.dexpatcher.struct.DexPatchFile;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 import java.util.Arrays;
 
@@ -35,43 +34,14 @@
     protected final Dex oldDex;
 
     /**
-     * IndexMap for mapping old item to corresponding one in full patch.
+     * SparseIndexMap for mapping old item to corresponding one in patched item.
      */
-    private final IndexMap oldToFullPatchedIndexMap;
+    private final SparseIndexMap oldToPatchedIndexMap;
 
-    /**
-     * IndexMap for mapping item in full patch to corresponding one in small patch.
-     */
-    private final IndexMap fullPatchedToSmallPatchedIndexMap;
-
-    /**
-     * Signature string of dex we're processing. For extra info file usage.
-     */
-    private final String oldDexSignStr;
-    private SmallPatchedDexItemChooser smallPatchedDexItemChooser = null;
-
-    public DexSectionPatchAlgorithm(
-            DexPatchFile patchFile,
-            Dex oldDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap
-    ) {
-        this(patchFile, oldDex, oldToFullPatchedIndexMap, fullPatchedToSmallPatchedIndexMap, null);
-    }
-
-    public DexSectionPatchAlgorithm(
-            DexPatchFile patchFile,
-            Dex oldDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            SmallPatchedDexItemChooser smallPatchedDexItemChooser
-    ) {
+    public DexSectionPatchAlgorithm(DexPatchFile patchFile, Dex oldDex, SparseIndexMap oldToPatchedIndexMap) {
         this.patchFile = patchFile;
         this.oldDex = oldDex;
-        this.oldToFullPatchedIndexMap = oldToFullPatchedIndexMap;
-        this.fullPatchedToSmallPatchedIndexMap = fullPatchedToSmallPatchedIndexMap;
-        this.oldDexSignStr = Hex.toHexString(oldDex.computeSignature(false));
-        this.smallPatchedDexItemChooser = smallPatchedDexItemChooser;
+        this.oldToPatchedIndexMap = oldToPatchedIndexMap;
     }
 
     /**
@@ -90,53 +60,36 @@ public DexSectionPatchAlgorithm(
     protected abstract int getItemSize(T item);
 
     /**
-     * Adjust {@code item} using specific {@code indexMap}
+     * Adjust {@code item} using specific {@code sparseIndexMap}
      */
-    protected T adjustItem(IndexMap indexMap, T item) {
+    protected T adjustItem(AbstractIndexMap indexMap, T item) {
         return item;
     }
 
     /**
-     * Update index or offset mapping in {@code indexMap}.
+     * Update index or offset mapping in {@code sparseIndexMap}.
      */
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         // Should override by subclass if needed.
     }
 
     /**
-     * Mark deleted index or offset in {@code indexMap}.
+     * Mark deleted index or offset in {@code sparseIndexMap}.
      *
      * Here we mark deleted item for such a case like this:
      *   Item in DebugInfo section reference a string in StringData section
      *   by index X, while in patched dex, the referenced string is removed.
      *
-     * The {@code indexMap} must be aware of this case and return -1
+     * The {@code sparseIndexMap} must be aware of this case and return -1
      * instead of the original value X.
      *
      * Further more, the special value -1 is not chosen by our inspiration but
      * the definition of NO_INDEX in document of dex file format.
      */
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
         // Should override by subclass if needed.
     }
 
-    /**
-     * Judge if item on index {@code patchedIndex} should be kept in small dex.
-     */
-    protected final boolean isPatchedItemInSmallPatchedDex(String oldDexSignStr, int patchedIndex) {
-        if (this.smallPatchedDexItemChooser != null) {
-            return this.smallPatchedDexItemChooser
-                    .isPatchedItemInSmallPatchedDex(oldDexSignStr, patchedIndex);
-        } else {
-            return true;
-        }
-    }
-
-    /**
-     * Return base offset of current section in full patched dex.
-     */
-    protected abstract int getFullPatchSectionBase();
-
     /**
      * Output patched item. This method should be overrided by subclass
      * so that patched item can be written to right place.
@@ -171,36 +124,16 @@ private int getItemOffsetOrIndex(int index, T item) {
     }
 
     public void execute() {
-        int deletedItemCount;
-        int[] deletedIndices;
-
-        int addedItemCount;
-        int[] addedIndices;
-
-        int replacedItemCount;
-        int[] replacedIndices;
-
-        if (patchFile != null) {
-            deletedItemCount = patchFile.getBuffer().readUleb128();
-            deletedIndices = readDeltaIndiciesOrOffsets(deletedItemCount);
+        final int deletedItemCount = patchFile.getBuffer().readUleb128();
+        final int[] deletedIndices = readDeltaIndiciesOrOffsets(deletedItemCount);
 
-            addedItemCount = patchFile.getBuffer().readUleb128();
-            addedIndices = readDeltaIndiciesOrOffsets(addedItemCount);
+        final int addedItemCount = patchFile.getBuffer().readUleb128();
+        final int[] addedIndices = readDeltaIndiciesOrOffsets(addedItemCount);
 
-            replacedItemCount = patchFile.getBuffer().readUleb128();
-            replacedIndices = readDeltaIndiciesOrOffsets(replacedItemCount);
-        } else {
-            deletedItemCount = 0;
-            deletedIndices = new int[deletedItemCount];
-
-            addedItemCount = 0;
-            addedIndices = new int[addedItemCount];
-
-            replacedItemCount = 0;
-            replacedIndices = new int[replacedItemCount];
-        }
+        final int replacedItemCount = patchFile.getBuffer().readUleb128();
+        final int[] replacedIndices = readDeltaIndiciesOrOffsets(replacedItemCount);
 
-        TableOfContents.Section tocSec = getTocSection(this.oldDex);
+        final TableOfContents.Section tocSec = getTocSection(this.oldDex);
         Dex.Section oldSection = null;
 
         int oldItemCount = 0;
@@ -211,17 +144,9 @@ public void execute() {
 
         // Now rest data are added and replaced items arranged in the order of
         // added indices and replaced indices.
-        boolean genFullPatchDex = (fullPatchedToSmallPatchedIndexMap == null);
-
-        if (genFullPatchDex) {
-            doFullPatch(
-                    oldSection, oldItemCount, deletedIndices, addedIndices, replacedIndices
-            );
-        } else {
-            doSmallPatch(
-                    oldSection, oldItemCount, deletedIndices, addedIndices, replacedIndices
-            );
-        }
+        doFullPatch(
+                oldSection, oldItemCount, deletedIndices, addedIndices, replacedIndices
+        );
     }
 
     private void doFullPatch(
@@ -258,7 +183,7 @@ private void doFullPatch(
             if (Arrays.binarySearch(deletedIndices, oldIndex) >= 0) {
                 T skippedOldItem = nextItem(oldSection); // skip old item.
                 markDeletedIndexOrOffset(
-                        oldToFullPatchedIndexMap,
+                        oldToPatchedIndexMap,
                         oldIndex,
                         getItemOffsetOrIndex(oldIndex, skippedOldItem)
                 );
@@ -268,19 +193,19 @@ private void doFullPatch(
             if (Arrays.binarySearch(replacedIndices, oldIndex) >= 0) {
                 T skippedOldItem = nextItem(oldSection); // skip old item.
                 markDeletedIndexOrOffset(
-                        oldToFullPatchedIndexMap,
+                        oldToPatchedIndexMap,
                         oldIndex,
                         getItemOffsetOrIndex(oldIndex, skippedOldItem)
                 );
                 ++oldIndex;
             } else
             if (oldIndex < oldItemCount) {
-                T oldItem = adjustItem(this.oldToFullPatchedIndexMap, nextItem(oldSection));
+                T oldItem = adjustItem(this.oldToPatchedIndexMap, nextItem(oldSection));
 
                 int patchedOffset = writePatchedItem(oldItem);
 
                 updateIndexOrOffset(
-                        this.oldToFullPatchedIndexMap,
+                        this.oldToPatchedIndexMap,
                         oldIndex,
                         getItemOffsetOrIndex(oldIndex, oldItem),
                         patchedIndex,
@@ -310,157 +235,4 @@ private void doFullPatch(
             );
         }
     }
-
-    private void doSmallPatch(
-            Dex.Section oldSection,
-            int oldItemCount,
-            int[] deletedIndices,
-            int[] addedIndices,
-            int[] replacedIndices
-    ) {
-        int deletedItemCount = deletedIndices.length;
-        int addedItemCount = addedIndices.length;
-        int replacedItemCount = replacedIndices.length;
-        int newItemCount = oldItemCount + addedItemCount - deletedItemCount;
-
-        int deletedItemCounter = 0;
-        int addActionCursor = 0;
-        int replaceActionCursor = 0;
-
-        int oldIndex = 0;
-        int fullPatchedIndex = 0;
-        int fullPatchedOffset = getFullPatchSectionBase();
-        int smallPatchedIndex = 0;
-        while (oldIndex < oldItemCount || fullPatchedIndex < newItemCount) {
-            if (addActionCursor < addedItemCount && addedIndices[addActionCursor] == fullPatchedIndex) {
-                T addedItem = nextItem(patchFile.getBuffer());
-                ++addActionCursor;
-
-                if (getTocSection(oldDex).isElementFourByteAligned) {
-                    fullPatchedOffset = SizeOf.roundToTimesOfFour(fullPatchedOffset);
-                }
-
-                if (isPatchedItemInSmallPatchedDex(this.oldDexSignStr, fullPatchedIndex)) {
-                    T adjustedItem = adjustItem(fullPatchedToSmallPatchedIndexMap, addedItem);
-                    int smallPatchedOffset = writePatchedItem(adjustedItem);
-                    updateIndexOrOffset(
-                            fullPatchedToSmallPatchedIndexMap,
-                            fullPatchedIndex,
-                            fullPatchedOffset,
-                            smallPatchedIndex,
-                            smallPatchedOffset
-                    );
-                    ++smallPatchedIndex;
-                }
-
-                ++fullPatchedIndex;
-                fullPatchedOffset += getItemSize(addedItem);
-            } else
-            if (replaceActionCursor < replacedItemCount && replacedIndices[replaceActionCursor] == fullPatchedIndex) {
-                T replacedItem = nextItem(patchFile.getBuffer());
-                ++replaceActionCursor;
-
-                if (getTocSection(oldDex).isElementFourByteAligned) {
-                    fullPatchedOffset = SizeOf.roundToTimesOfFour(fullPatchedOffset);
-                }
-
-                if (isPatchedItemInSmallPatchedDex(this.oldDexSignStr, fullPatchedIndex)) {
-                    T adjustedItem = adjustItem(fullPatchedToSmallPatchedIndexMap, replacedItem);
-                    int smallPatchedOffset = writePatchedItem(adjustedItem);
-                    updateIndexOrOffset(
-                            fullPatchedToSmallPatchedIndexMap,
-                            fullPatchedIndex,
-                            fullPatchedOffset,
-                            smallPatchedIndex,
-                            smallPatchedOffset
-                    );
-                    ++smallPatchedIndex;
-                }
-
-                ++fullPatchedIndex;
-                fullPatchedOffset += getItemSize(replacedItem);
-            } else
-            if (Arrays.binarySearch(deletedIndices, oldIndex) >= 0) {
-                T skippedOldItem = nextItem(oldSection); // skip old item.
-                markDeletedIndexOrOffset(
-                        oldToFullPatchedIndexMap,
-                        oldIndex,
-                        getItemOffsetOrIndex(oldIndex, skippedOldItem)
-                );
-                ++oldIndex;
-                ++deletedItemCounter;
-            } else
-            if (Arrays.binarySearch(replacedIndices, oldIndex) >= 0) {
-                T skippedOldItem = nextItem(oldSection); // skip old item.
-                markDeletedIndexOrOffset(
-                        oldToFullPatchedIndexMap,
-                        oldIndex,
-                        getItemOffsetOrIndex(oldIndex, skippedOldItem)
-                );
-                ++oldIndex;
-            } else
-            if (oldIndex < oldItemCount) {
-                T oldItem = nextItem(oldSection);
-                T oldItemInFullPatch = adjustItem(this.oldToFullPatchedIndexMap, oldItem);
-
-                if (getTocSection(oldDex).isElementFourByteAligned) {
-                    fullPatchedOffset = SizeOf.roundToTimesOfFour(fullPatchedOffset);
-                }
-
-                if (isPatchedItemInSmallPatchedDex(this.oldDexSignStr, fullPatchedIndex)) {
-                    T patchedItemInSmallPatch = adjustItem(
-                            this.fullPatchedToSmallPatchedIndexMap, oldItemInFullPatch
-                    );
-                    int smallPatchedOffset = writePatchedItem(patchedItemInSmallPatch);
-                    updateIndexOrOffset(
-                            fullPatchedToSmallPatchedIndexMap,
-                            fullPatchedIndex,
-                            fullPatchedOffset,
-                            smallPatchedIndex,
-                            smallPatchedOffset
-                    );
-                    ++smallPatchedIndex;
-                }
-
-                updateIndexOrOffset(
-                        oldToFullPatchedIndexMap,
-                        oldIndex,
-                        getItemOffsetOrIndex(oldIndex, oldItem),
-                        fullPatchedIndex,
-                        fullPatchedOffset
-                );
-
-                ++fullPatchedIndex;
-                fullPatchedOffset += getItemSize(oldItemInFullPatch);
-
-                ++oldIndex;
-            }
-        }
-
-        if (addActionCursor != addedItemCount || deletedItemCounter != deletedItemCount
-                || replaceActionCursor != replacedItemCount
-        ) {
-            throw new IllegalStateException(
-                    String.format(
-                            "bad patch operation sequence. addCounter: %d, addCount: %d, "
-                                    + "delCounter: %d, delCount: %d, "
-                                    + "replaceCounter: %d, replaceCount:%d",
-                            addActionCursor,
-                            addedItemCount,
-                            deletedItemCounter,
-                            deletedItemCount,
-                            replaceActionCursor,
-                            replacedItemCount
-                    )
-            );
-        }
-    }
-
-    /**
-     * Indicates if an item in full patched dex with specific index
-     * should be kept in small patched dex of current old dex.
-     */
-    public interface SmallPatchedDexItemChooser {
-        boolean isPatchedItemInSmallPatchedDex(String oldDexSign, int patchedItemIndex);
-    }
 }
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/FieldIdSectionPatchAlgorithm.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/FieldIdSectionPatchAlgorithm.java
index f8cbd1da..9f6100ef 100644
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/FieldIdSectionPatchAlgorithm.java
+++ b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/FieldIdSectionPatchAlgorithm.java
@@ -20,9 +20,9 @@
 import com.tencent.tinker.android.dex.FieldId;
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
 import com.tencent.tinker.commons.dexpatcher.struct.DexPatchFile;
-import com.tencent.tinker.commons.dexpatcher.struct.SmallPatchedDexItemFile;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 /**
  * Created by tangyinsheng on 2016/7/4.
@@ -35,44 +35,9 @@ public FieldIdSectionPatchAlgorithm(
             DexPatchFile patchFile,
             Dex oldDex,
             Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            final SmallPatchedDexItemFile extraInfoFile
+            SparseIndexMap oldToPatchedIndexMap
     ) {
-        this(
-                patchFile,
-                oldDex,
-                patchedDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                new SmallPatchedDexItemChooser() {
-                    @Override
-                    public boolean isPatchedItemInSmallPatchedDex(
-                            String oldDexSign, int patchedItemIndex
-                    ) {
-                        return extraInfoFile.isFieldIdInSmallPatchedDex(
-                                oldDexSign, patchedItemIndex
-                        );
-                    }
-                }
-        );
-    }
-
-    public FieldIdSectionPatchAlgorithm(
-            DexPatchFile patchFile,
-            Dex oldDex,
-            Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            SmallPatchedDexItemChooser spdItemChooser
-    ) {
-        super(
-                patchFile,
-                oldDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                spdItemChooser
-        );
+        super(patchFile, oldDex, oldToPatchedIndexMap);
 
         if (patchedDex != null) {
             this.patchedFieldIdTocSec = patchedDex.getTableOfContents().fieldIds;
@@ -96,16 +61,7 @@ protected int getItemSize(FieldId item) {
     }
 
     @Override
-    protected int getFullPatchSectionBase() {
-        if (this.patchFile != null) {
-            return this.patchFile.getPatchedFieldIdSectionOffset();
-        } else {
-            return getTocSection(this.oldDex).off;
-        }
-    }
-
-    @Override
-    protected FieldId adjustItem(IndexMap indexMap, FieldId item) {
+    protected FieldId adjustItem(AbstractIndexMap indexMap, FieldId item) {
         return indexMap.adjust(item);
     }
 
@@ -116,14 +72,14 @@ protected int writePatchedItem(FieldId patchedItem) {
     }
 
     @Override
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         if (oldIndex != newIndex) {
-            indexMap.mapFieldIds(oldIndex, newIndex);
+            sparseIndexMap.mapFieldIds(oldIndex, newIndex);
         }
     }
 
     @Override
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
-        indexMap.markFieldIdDeleted(deletedIndex);
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
+        sparseIndexMap.markFieldIdDeleted(deletedIndex);
     }
 }
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/MethodIdSectionPatchAlgorithm.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/MethodIdSectionPatchAlgorithm.java
index 5dcef75d..56e87630 100644
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/MethodIdSectionPatchAlgorithm.java
+++ b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/MethodIdSectionPatchAlgorithm.java
@@ -20,9 +20,9 @@
 import com.tencent.tinker.android.dex.MethodId;
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
 import com.tencent.tinker.commons.dexpatcher.struct.DexPatchFile;
-import com.tencent.tinker.commons.dexpatcher.struct.SmallPatchedDexItemFile;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 /**
  * Created by tangyinsheng on 2016/7/4.
@@ -35,44 +35,9 @@ public MethodIdSectionPatchAlgorithm(
             DexPatchFile patchFile,
             Dex oldDex,
             Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            final SmallPatchedDexItemFile extraInfoFile
+            SparseIndexMap oldToPatchedIndexMap
     ) {
-        this(
-                patchFile,
-                oldDex,
-                patchedDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                new SmallPatchedDexItemChooser() {
-                    @Override
-                    public boolean isPatchedItemInSmallPatchedDex(
-                            String oldDexSign, int patchedItemIndex
-                    ) {
-                        return extraInfoFile.isMethodIdInSmallPatchedDex(
-                                oldDexSign, patchedItemIndex
-                        );
-                    }
-                }
-        );
-    }
-
-    public MethodIdSectionPatchAlgorithm(
-            DexPatchFile patchFile,
-            Dex oldDex,
-            Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            SmallPatchedDexItemChooser spdItemChooser
-    ) {
-        super(
-                patchFile,
-                oldDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                spdItemChooser
-        );
+        super(patchFile, oldDex, oldToPatchedIndexMap);
 
         if (patchedDex != null) {
             this.patchedMethodIdTocSec = patchedDex.getTableOfContents().methodIds;
@@ -96,16 +61,7 @@ protected int getItemSize(MethodId item) {
     }
 
     @Override
-    protected int getFullPatchSectionBase() {
-        if (this.patchFile != null) {
-            return this.patchFile.getPatchedMethodIdSectionOffset();
-        } else {
-            return getTocSection(this.oldDex).off;
-        }
-    }
-
-    @Override
-    protected MethodId adjustItem(IndexMap indexMap, MethodId item) {
+    protected MethodId adjustItem(AbstractIndexMap indexMap, MethodId item) {
         return indexMap.adjust(item);
     }
 
@@ -116,14 +72,14 @@ protected int writePatchedItem(MethodId patchedItem) {
     }
 
     @Override
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         if (oldIndex != newIndex) {
-            indexMap.mapMethodIds(oldIndex, newIndex);
+            sparseIndexMap.mapMethodIds(oldIndex, newIndex);
         }
     }
 
     @Override
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
-        indexMap.markMethodIdDeleted(deletedIndex);
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
+        sparseIndexMap.markMethodIdDeleted(deletedIndex);
     }
 }
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/ProtoIdSectionPatchAlgorithm.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/ProtoIdSectionPatchAlgorithm.java
index f427cfd9..e59beb69 100644
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/ProtoIdSectionPatchAlgorithm.java
+++ b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/ProtoIdSectionPatchAlgorithm.java
@@ -20,9 +20,9 @@
 import com.tencent.tinker.android.dex.ProtoId;
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
 import com.tencent.tinker.commons.dexpatcher.struct.DexPatchFile;
-import com.tencent.tinker.commons.dexpatcher.struct.SmallPatchedDexItemFile;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 /**
  * Created by tangyinsheng on 2016/7/4.
@@ -35,44 +35,9 @@ public ProtoIdSectionPatchAlgorithm(
             DexPatchFile patchFile,
             Dex oldDex,
             Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            final SmallPatchedDexItemFile extraInfoFile
+            SparseIndexMap oldToPatchedIndexMap
     ) {
-        this(
-                patchFile,
-                oldDex,
-                patchedDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                new SmallPatchedDexItemChooser() {
-                    @Override
-                    public boolean isPatchedItemInSmallPatchedDex(
-                            String oldDexSign, int patchedItemIndex
-                    ) {
-                        return extraInfoFile.isProtoIdInSmallPatchedDex(
-                                oldDexSign, patchedItemIndex
-                        );
-                    }
-                }
-        );
-    }
-
-    public ProtoIdSectionPatchAlgorithm(
-            DexPatchFile patchFile,
-            Dex oldDex,
-            Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            SmallPatchedDexItemChooser spdItemChooser
-    ) {
-        super(
-                patchFile,
-                oldDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                spdItemChooser
-        );
+        super(patchFile, oldDex, oldToPatchedIndexMap);
 
         if (patchedDex != null) {
             this.patchedProtoIdTocSec = patchedDex.getTableOfContents().protoIds;
@@ -96,16 +61,7 @@ protected int getItemSize(ProtoId item) {
     }
 
     @Override
-    protected int getFullPatchSectionBase() {
-        if (this.patchFile != null) {
-            return this.patchFile.getPatchedProtoIdSectionOffset();
-        } else {
-            return getTocSection(this.oldDex).off;
-        }
-    }
-
-    @Override
-    protected ProtoId adjustItem(IndexMap indexMap, ProtoId item) {
+    protected ProtoId adjustItem(AbstractIndexMap indexMap, ProtoId item) {
         return indexMap.adjust(item);
     }
 
@@ -116,14 +72,14 @@ protected int writePatchedItem(ProtoId patchedItem) {
     }
 
     @Override
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         if (oldIndex != newIndex) {
-            indexMap.mapProtoIds(oldIndex, newIndex);
+            sparseIndexMap.mapProtoIds(oldIndex, newIndex);
         }
     }
 
     @Override
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
-        indexMap.markProtoIdDeleted(deletedIndex);
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
+        sparseIndexMap.markProtoIdDeleted(deletedIndex);
     }
 }
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/StaticValueSectionPatchAlgorithm.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/StaticValueSectionPatchAlgorithm.java
index dd8f4bc9..c16dcc33 100644
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/StaticValueSectionPatchAlgorithm.java
+++ b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/StaticValueSectionPatchAlgorithm.java
@@ -20,9 +20,9 @@
 import com.tencent.tinker.android.dex.EncodedValue;
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
 import com.tencent.tinker.commons.dexpatcher.struct.DexPatchFile;
-import com.tencent.tinker.commons.dexpatcher.struct.SmallPatchedDexItemFile;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 /**
  * Created by tangyinsheng on 2016/7/4.
@@ -35,44 +35,9 @@ public StaticValueSectionPatchAlgorithm(
             DexPatchFile patchFile,
             Dex oldDex,
             Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            final SmallPatchedDexItemFile extraInfoFile
+            SparseIndexMap oldToPatchedIndexMap
     ) {
-        this(
-                patchFile,
-                oldDex,
-                patchedDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                new SmallPatchedDexItemChooser() {
-                    @Override
-                    public boolean isPatchedItemInSmallPatchedDex(
-                            String oldDexSign, int patchedItemIndex
-                    ) {
-                        return extraInfoFile.isEncodedArrayInSmallPatchedDex(
-                                oldDexSign, patchedItemIndex
-                        );
-                    }
-                }
-        );
-    }
-
-    public StaticValueSectionPatchAlgorithm(
-            DexPatchFile patchFile,
-            Dex oldDex,
-            Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            SmallPatchedDexItemChooser spdItemChooser
-    ) {
-        super(
-                patchFile,
-                oldDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                spdItemChooser
-        );
+        super(patchFile, oldDex, oldToPatchedIndexMap);
 
         if (patchedDex != null) {
             this.patchedEncodedValueTocSec = patchedDex.getTableOfContents().encodedArrays;
@@ -96,16 +61,7 @@ protected int getItemSize(EncodedValue item) {
     }
 
     @Override
-    protected int getFullPatchSectionBase() {
-        if (this.patchFile != null) {
-            return this.patchFile.getPatchedEncodedArraySectionOffset();
-        } else {
-            return getTocSection(this.oldDex).off;
-        }
-    }
-
-    @Override
-    protected EncodedValue adjustItem(IndexMap indexMap, EncodedValue item) {
+    protected EncodedValue adjustItem(AbstractIndexMap indexMap, EncodedValue item) {
         return indexMap.adjust(item);
     }
 
@@ -116,14 +72,14 @@ protected int writePatchedItem(EncodedValue patchedItem) {
     }
 
     @Override
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         if (oldOffset != newOffset) {
-            indexMap.mapStaticValuesOffset(oldOffset, newOffset);
+            sparseIndexMap.mapStaticValuesOffset(oldOffset, newOffset);
         }
     }
 
     @Override
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
-        indexMap.markStaticValuesDeleted(deletedOffset);
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
+        sparseIndexMap.markStaticValuesDeleted(deletedOffset);
     }
 }
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/StringDataSectionPatchAlgorithm.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/StringDataSectionPatchAlgorithm.java
index 66df249e..959261bd 100644
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/StringDataSectionPatchAlgorithm.java
+++ b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/StringDataSectionPatchAlgorithm.java
@@ -20,9 +20,8 @@
 import com.tencent.tinker.android.dex.StringData;
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 import com.tencent.tinker.commons.dexpatcher.struct.DexPatchFile;
-import com.tencent.tinker.commons.dexpatcher.struct.SmallPatchedDexItemFile;
 
 /**
  * Created by tangyinsheng on 2016/7/4.
@@ -33,48 +32,14 @@
     private Dex.Section patchedStringDataSec = null;
     private Dex.Section patchedStringIdSec = null;
 
-    public StringDataSectionPatchAlgorithm(
-            DexPatchFile patchFile,
-            Dex oldDex,
-            Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            final SmallPatchedDexItemFile extraInfoFile
-    ) {
-        this(
-                patchFile,
-                oldDex,
-                patchedDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                new SmallPatchedDexItemChooser() {
-                    @Override
-                    public boolean isPatchedItemInSmallPatchedDex(
-                            String oldDexSign, int patchedItemIndex
-                    ) {
-                        return extraInfoFile.isStringInSmallPatchedDex(
-                                oldDexSign, patchedItemIndex
-                        );
-                    }
-                }
-        );
-    }
 
     public StringDataSectionPatchAlgorithm(
             DexPatchFile patchFile,
             Dex oldDex,
             Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            SmallPatchedDexItemChooser spdItemChooser
+            SparseIndexMap oldToPatchedIndexMap
     ) {
-        super(
-                patchFile,
-                oldDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                spdItemChooser
-        );
+        super(patchFile, oldDex, oldToPatchedIndexMap);
 
         if (patchedDex != null) {
             this.patchedStringDataTocSec = patchedDex.getTableOfContents().stringDatas;
@@ -99,15 +64,6 @@ protected int getItemSize(StringData item) {
         return item.byteCountInDex();
     }
 
-    @Override
-    protected int getFullPatchSectionBase() {
-        if (this.patchFile != null) {
-            return this.patchFile.getPatchedStringDataSectionOffset();
-        } else {
-            return getTocSection(this.oldDex).off;
-        }
-    }
-
     @Override
     protected int writePatchedItem(StringData patchedItem) {
         int off = this.patchedStringDataSec.writeStringData(patchedItem);
@@ -118,14 +74,14 @@ protected int writePatchedItem(StringData patchedItem) {
     }
 
     @Override
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         if (oldIndex != newIndex) {
-            indexMap.mapStringIds(oldIndex, newIndex);
+            sparseIndexMap.mapStringIds(oldIndex, newIndex);
         }
     }
 
     @Override
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
-        indexMap.markStringIdDeleted(deletedIndex);
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
+        sparseIndexMap.markStringIdDeleted(deletedIndex);
     }
 }
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/TypeIdSectionPatchAlgorithm.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/TypeIdSectionPatchAlgorithm.java
index 4296ab4e..76c4b648 100644
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/TypeIdSectionPatchAlgorithm.java
+++ b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/TypeIdSectionPatchAlgorithm.java
@@ -20,9 +20,9 @@
 import com.tencent.tinker.android.dex.SizeOf;
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
 import com.tencent.tinker.commons.dexpatcher.struct.DexPatchFile;
-import com.tencent.tinker.commons.dexpatcher.struct.SmallPatchedDexItemFile;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 /**
  * Created by tangyinsheng on 2016/7/4.
@@ -35,44 +35,9 @@ public TypeIdSectionPatchAlgorithm(
             DexPatchFile patchFile,
             Dex oldDex,
             Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            final SmallPatchedDexItemFile extraInfoFile
+            SparseIndexMap oldToPatchedIndexMap
     ) {
-        this(
-                patchFile,
-                oldDex,
-                patchedDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                new SmallPatchedDexItemChooser() {
-                    @Override
-                    public boolean isPatchedItemInSmallPatchedDex(
-                            String oldDexSign, int patchedItemIndex
-                    ) {
-                        return extraInfoFile.isTypeIdInSmallPatchedDex(
-                                oldDexSign, patchedItemIndex
-                        );
-                    }
-                }
-        );
-    }
-
-    public TypeIdSectionPatchAlgorithm(
-            DexPatchFile patchFile,
-            Dex oldDex,
-            Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            SmallPatchedDexItemChooser spdItemChooser
-    ) {
-        super(
-                patchFile,
-                oldDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                spdItemChooser
-        );
+        super(patchFile, oldDex, oldToPatchedIndexMap);
 
         if (patchedDex != null) {
             this.patchedTypeIdTocSec = patchedDex.getTableOfContents().typeIds;
@@ -96,16 +61,7 @@ protected int getItemSize(Integer item) {
     }
 
     @Override
-    protected int getFullPatchSectionBase() {
-        if (this.patchFile != null) {
-            return this.patchFile.getPatchedTypeIdSectionOffset();
-        } else {
-            return getTocSection(this.oldDex).off;
-        }
-    }
-
-    @Override
-    protected Integer adjustItem(IndexMap indexMap, Integer item) {
+    protected Integer adjustItem(AbstractIndexMap indexMap, Integer item) {
         return indexMap.adjustStringIndex(item);
     }
 
@@ -118,14 +74,14 @@ protected int writePatchedItem(Integer patchedItem) {
     }
 
     @Override
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         if (oldIndex != newIndex) {
-            indexMap.mapTypeIds(oldIndex, newIndex);
+            sparseIndexMap.mapTypeIds(oldIndex, newIndex);
         }
     }
 
     @Override
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
-        indexMap.markTypeIdDeleted(deletedIndex);
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
+        sparseIndexMap.markTypeIdDeleted(deletedIndex);
     }
 }
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/TypeListSectionPatchAlgorithm.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/TypeListSectionPatchAlgorithm.java
index 2267a1ee..5b40c6f1 100644
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/TypeListSectionPatchAlgorithm.java
+++ b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/TypeListSectionPatchAlgorithm.java
@@ -20,9 +20,9 @@
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.TypeList;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
 import com.tencent.tinker.commons.dexpatcher.struct.DexPatchFile;
-import com.tencent.tinker.commons.dexpatcher.struct.SmallPatchedDexItemFile;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 /**
  * Created by tangyinsheng on 2016/7/4.
@@ -35,44 +35,9 @@ public TypeListSectionPatchAlgorithm(
             DexPatchFile patchFile,
             Dex oldDex,
             Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            final SmallPatchedDexItemFile extraInfoFile
+            SparseIndexMap oldToPatchedIndexMap
     ) {
-        this(
-                patchFile,
-                oldDex,
-                patchedDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                new SmallPatchedDexItemChooser() {
-                    @Override
-                    public boolean isPatchedItemInSmallPatchedDex(
-                            String oldDexSign, int patchedItemIndex
-                    ) {
-                        return extraInfoFile.isTypeListInSmallPatchedDex(
-                                oldDexSign, patchedItemIndex
-                        );
-                    }
-                }
-        );
-    }
-
-    public TypeListSectionPatchAlgorithm(
-            DexPatchFile patchFile,
-            Dex oldDex,
-            Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            SmallPatchedDexItemChooser spdItemChooser
-    ) {
-        super(
-                patchFile,
-                oldDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                spdItemChooser
-        );
+        super(patchFile, oldDex, oldToPatchedIndexMap);
 
         if (patchedDex != null) {
             this.patchedTypeListTocSec = patchedDex.getTableOfContents().typeLists;
@@ -96,16 +61,7 @@ protected int getItemSize(TypeList item) {
     }
 
     @Override
-    protected int getFullPatchSectionBase() {
-        if (this.patchFile != null) {
-            return this.patchFile.getPatchedTypeListSectionOffset();
-        } else {
-            return getTocSection(this.oldDex).off;
-        }
-    }
-
-    @Override
-    protected TypeList adjustItem(IndexMap indexMap, TypeList item) {
+    protected TypeList adjustItem(AbstractIndexMap indexMap, TypeList item) {
         return indexMap.adjust(item);
     }
 
@@ -116,14 +72,14 @@ protected int writePatchedItem(TypeList patchedItem) {
     }
 
     @Override
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         if (oldOffset != newOffset) {
-            indexMap.mapTypeListOffset(oldOffset, newOffset);
+            sparseIndexMap.mapTypeListOffset(oldOffset, newOffset);
         }
     }
 
     @Override
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
-        indexMap.markTypeListDeleted(deletedOffset);
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
+        sparseIndexMap.markTypeListDeleted(deletedOffset);
     }
 }
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/struct/SmallPatchedDexItemFile.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/struct/SmallPatchedDexItemFile.java
deleted file mode 100644
index 2fc9dd71..00000000
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/struct/SmallPatchedDexItemFile.java
+++ /dev/null
@@ -1,419 +0,0 @@
-/*
- * Tencent is pleased to support the open source community by making Tinker available.
- *
- * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
- *
- * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- *
- * https://opensource.org/licenses/BSD-3-Clause
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is
- * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
- * either express or implied. See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.tencent.tinker.commons.dexpatcher.struct;
-
-import com.tencent.tinker.android.dex.SizeOf;
-import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dex.util.CompareUtils;
-import com.tencent.tinker.android.dex.util.FileUtils;
-import com.tencent.tinker.android.dx.util.Hex;
-
-import java.io.File;
-import java.io.IOException;
-import java.io.InputStream;
-import java.nio.ByteBuffer;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.BitSet;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-/**
- * Created by tangyinsheng on 2016/8/10.
- */
-public final class SmallPatchedDexItemFile {
-    public static final byte[] MAGIC = {0x44, 0x44, 0x45, 0x58, 0x54, 0x52, 0x41}; // DDEXTRA
-    public static final short CURRENT_VERSION = 0x0001;
-    private final List<String> oldDexSigns = new ArrayList<>();
-
-    private final Map<String, DexOffsets> oldDexSignToOffsetInfoMap = new HashMap<>();
-
-    private final Map<String, BitSet>
-            oldDexSignToStringIndicesInSmallPatch = new HashMap<>();
-    private final Map<String, BitSet>
-            oldDexSignToTypeIdIndicesInSmallPatch = new HashMap<>();
-    private final Map<String, BitSet>
-            oldDexSignToTypeListIndicesInSmallPatch = new HashMap<>();
-    private final Map<String, BitSet>
-            oldDexSignToProtoIdIndicesInSmallPatch = new HashMap<>();
-    private final Map<String, BitSet>
-            oldDexSignToFieldIdIndicesInSmallPatch = new HashMap<>();
-    private final Map<String, BitSet>
-            oldDexSignToMethodIdIndicesInSmallPatch = new HashMap<>();
-    private final Map<String, BitSet>
-            oldDexSignToAnnotationIndicesInSmallPatch = new HashMap<>();
-    private final Map<String, BitSet>
-            oldDexSignToAnnotationSetIndicesInSmallPatch = new HashMap<>();
-    private final Map<String, BitSet>
-            oldDexSignToAnnotationSetRefListIndicesInSmallPatch = new HashMap<>();
-    private final Map<String, BitSet>
-            oldDexSignToAnnotationsDirectoryIndicesInSmallPatch = new HashMap<>();
-    private final Map<String, BitSet>
-            oldDexSignToEncodedArrayIndicesInSmallPatch = new HashMap<>();
-    private final Map<String, BitSet>
-            oldDexSignToDebugInfoIndicesInSmallPatch = new HashMap<>();
-    private final Map<String, BitSet>
-            oldDexSignToCodeIndicesInSmallPatch = new HashMap<>();
-    private final Map<String, BitSet>
-            oldDexSignToClassDataIndicesInSmallPatch = new HashMap<>();
-    private final Map<String, BitSet>
-            oldDexSignToClassDefIndicesInSmallPatch = new HashMap<>();
-    private int version;
-    private int firstChunkOffset;
-
-    private static final class DexOffsets {
-        int stringIdsOffset = -1;
-        int typeIdsOffset = -1;
-        int protoIdsOffset = -1;
-        int fieldIdsOffset = -1;
-        int methodIdsOffset = -1;
-        int classDefsOffset = -1;
-        int mapListOffset = -1;
-        int typeListsOffset = -1;
-        int annotationsOffset = -1;
-        int annotationSetsOffset = -1;
-        int annotationSetRefListsOffset = -1;
-        int annotationsDirectoriesOffset = -1;
-        int classDataItemsOffset = -1;
-        int codeItemsOffset = -1;
-        int stringDataItemsOffset = -1;
-        int debugInfoItemsOffset = -1;
-        int encodedArraysOffset = -1;
-        int dexSize = -1;
-    }
-
-    public SmallPatchedDexItemFile(File input) throws IOException {
-        DexDataBuffer buffer = new DexDataBuffer(ByteBuffer.wrap(FileUtils.readFile(input)));
-        init(buffer);
-    }
-
-    public SmallPatchedDexItemFile(InputStream is) throws IOException {
-        DexDataBuffer buffer = new DexDataBuffer(ByteBuffer.wrap(FileUtils.readStream(is)));
-        init(buffer);
-    }
-
-    private void init(DexDataBuffer buffer) throws IOException {
-        byte[] magic = buffer.readByteArray(MAGIC.length);
-        if (CompareUtils.uArrCompare(magic, MAGIC) != 0) {
-            throw new IllegalStateException(
-                    "bad dexdiff extra file magic: " + Arrays.toString(magic)
-            );
-        }
-        this.version = buffer.readShort();
-        if (this.version != CURRENT_VERSION) {
-            throw new IllegalStateException(
-                    "bad dexdiff extra file version: " + this.version + ", expected: " + CURRENT_VERSION
-            );
-        }
-
-        this.firstChunkOffset = buffer.readInt();
-        buffer.position(this.firstChunkOffset);
-
-        int oldDexSignCount = buffer.readUleb128();
-        for (int i = 0; i < oldDexSignCount; ++i) {
-            byte[] oldDexSign = buffer.readByteArray(SizeOf.SIGNATURE);
-            oldDexSigns.add(Hex.toHexString(oldDexSign));
-        }
-
-        for (int i = 0; i < oldDexSignCount; ++i) {
-            final String oldDexSign = oldDexSigns.get(i);
-            final DexOffsets dexOffsets = new DexOffsets();
-            dexOffsets.stringIdsOffset = buffer.readInt();
-            dexOffsets.typeIdsOffset = buffer.readInt();
-            dexOffsets.protoIdsOffset = buffer.readInt();
-            dexOffsets.fieldIdsOffset = buffer.readInt();
-            dexOffsets.methodIdsOffset = buffer.readInt();
-            dexOffsets.classDefsOffset = buffer.readInt();
-            dexOffsets.stringDataItemsOffset = buffer.readInt();
-            dexOffsets.typeListsOffset = buffer.readInt();
-            dexOffsets.annotationsOffset = buffer.readInt();
-            dexOffsets.annotationSetsOffset = buffer.readInt();
-            dexOffsets.annotationSetRefListsOffset = buffer.readInt();
-            dexOffsets.annotationsDirectoriesOffset = buffer.readInt();
-            dexOffsets.debugInfoItemsOffset = buffer.readInt();
-            dexOffsets.codeItemsOffset = buffer.readInt();
-            dexOffsets.classDataItemsOffset = buffer.readInt();
-            dexOffsets.encodedArraysOffset = buffer.readInt();
-            dexOffsets.mapListOffset = buffer.readInt();
-            dexOffsets.dexSize = buffer.readInt();
-            oldDexSignToOffsetInfoMap.put(oldDexSign, dexOffsets);
-        }
-
-        readDataChunk(buffer, oldDexSignToStringIndicesInSmallPatch);
-        readDataChunk(buffer, oldDexSignToTypeIdIndicesInSmallPatch);
-        readDataChunk(buffer, oldDexSignToTypeListIndicesInSmallPatch);
-        readDataChunk(buffer, oldDexSignToProtoIdIndicesInSmallPatch);
-        readDataChunk(buffer, oldDexSignToFieldIdIndicesInSmallPatch);
-        readDataChunk(buffer, oldDexSignToMethodIdIndicesInSmallPatch);
-        readDataChunk(buffer, oldDexSignToAnnotationIndicesInSmallPatch);
-        readDataChunk(buffer, oldDexSignToAnnotationSetIndicesInSmallPatch);
-        readDataChunk(buffer, oldDexSignToAnnotationSetRefListIndicesInSmallPatch);
-        readDataChunk(buffer, oldDexSignToAnnotationsDirectoryIndicesInSmallPatch);
-        readDataChunk(buffer, oldDexSignToEncodedArrayIndicesInSmallPatch);
-        readDataChunk(buffer, oldDexSignToDebugInfoIndicesInSmallPatch);
-        readDataChunk(buffer, oldDexSignToCodeIndicesInSmallPatch);
-        readDataChunk(buffer, oldDexSignToClassDataIndicesInSmallPatch);
-        readDataChunk(buffer, oldDexSignToClassDefIndicesInSmallPatch);
-    }
-
-    private void readDataChunk(
-            DexDataBuffer buffer, Map<String, BitSet> oldDexSignToIndicesInSmallPatchMap
-    ) {
-        int oldDexSignCount = oldDexSigns.size();
-        for (int i = 0; i < oldDexSignCount; ++i) {
-            int itemCount = buffer.readUleb128();
-            int prevIndex = 0;
-            for (int j = 0; j < itemCount; ++j) {
-                int indexDelta = buffer.readSleb128();
-                prevIndex += indexDelta;
-
-                final String oldDexSign = oldDexSigns.get(i);
-                BitSet indices = oldDexSignToIndicesInSmallPatchMap.get(oldDexSign);
-                if (indices == null) {
-                    indices = new BitSet();
-                    oldDexSignToIndicesInSmallPatchMap.put(oldDexSign, indices);
-                }
-
-                indices.set(prevIndex);
-            }
-        }
-    }
-
-    public boolean isAffectedOldDex(String oldDexSign) {
-        return this.oldDexSigns.contains(oldDexSign);
-    }
-
-    public boolean isSmallPatchedDexEmpty(String oldDexSign) {
-        BitSet indices = this.oldDexSignToClassDefIndicesInSmallPatch.get(oldDexSign);
-        return (indices == null || indices.isEmpty());
-    }
-
-    public int getPatchedStringIdOffsetByOldDexSign(String oldDexSign) {
-        DexOffsets dexOffsets = this.oldDexSignToOffsetInfoMap.get(oldDexSign);
-        return dexOffsets != null ? dexOffsets.stringIdsOffset : -1;
-    }
-
-    public int getPatchedTypeIdOffsetByOldDexSign(String oldDexSign) {
-        DexOffsets dexOffsets = this.oldDexSignToOffsetInfoMap.get(oldDexSign);
-        return dexOffsets != null ? dexOffsets.typeIdsOffset : -1;
-    }
-
-    public int getPatchedProtoIdOffsetByOldDexSign(String oldDexSign) {
-        DexOffsets dexOffsets = this.oldDexSignToOffsetInfoMap.get(oldDexSign);
-        return dexOffsets != null ? dexOffsets.protoIdsOffset : -1;
-    }
-
-    public int getPatchedFieldIdOffsetByOldDexSign(String oldDexSign) {
-        DexOffsets dexOffsets = this.oldDexSignToOffsetInfoMap.get(oldDexSign);
-        return dexOffsets != null ? dexOffsets.fieldIdsOffset : -1;
-    }
-
-    public int getPatchedMethodIdOffsetByOldDexSign(String oldDexSign) {
-        DexOffsets dexOffsets = this.oldDexSignToOffsetInfoMap.get(oldDexSign);
-        return dexOffsets != null ? dexOffsets.methodIdsOffset : -1;
-    }
-
-    public int getPatchedClassDefOffsetByOldDexSign(String oldDexSign) {
-        DexOffsets dexOffsets = this.oldDexSignToOffsetInfoMap.get(oldDexSign);
-        return dexOffsets != null ? dexOffsets.classDefsOffset : -1;
-    }
-
-    public int getPatchedMapListOffsetByOldDexSign(String oldDexSign) {
-        DexOffsets dexOffsets = this.oldDexSignToOffsetInfoMap.get(oldDexSign);
-        return dexOffsets != null ? dexOffsets.mapListOffset : -1;
-    }
-
-    public int getPatchedTypeListOffsetByOldDexSign(String oldDexSign) {
-        DexOffsets dexOffsets = this.oldDexSignToOffsetInfoMap.get(oldDexSign);
-        return dexOffsets != null ? dexOffsets.typeListsOffset : -1;
-    }
-
-    public int getPatchedAnnotationSetRefListOffsetByOldDexSign(String oldDexSign) {
-        DexOffsets dexOffsets = this.oldDexSignToOffsetInfoMap.get(oldDexSign);
-        return dexOffsets != null ? dexOffsets.annotationSetRefListsOffset : -1;
-    }
-
-    public int getPatchedAnnotationSetOffsetByOldDexSign(String oldDexSign) {
-        DexOffsets dexOffsets = this.oldDexSignToOffsetInfoMap.get(oldDexSign);
-        return dexOffsets != null ? dexOffsets.annotationSetsOffset : -1;
-    }
-
-    public int getPatchedClassDataOffsetByOldDexSign(String oldDexSign) {
-        DexOffsets dexOffsets = this.oldDexSignToOffsetInfoMap.get(oldDexSign);
-        return dexOffsets != null ? dexOffsets.classDataItemsOffset : -1;
-    }
-
-    public int getPatchedCodeOffsetByOldDexSign(String oldDexSign) {
-        DexOffsets dexOffsets = this.oldDexSignToOffsetInfoMap.get(oldDexSign);
-        return dexOffsets != null ? dexOffsets.codeItemsOffset : -1;
-    }
-
-    public int getPatchedStringDataOffsetByOldDexSign(String oldDexSign) {
-        DexOffsets dexOffsets = this.oldDexSignToOffsetInfoMap.get(oldDexSign);
-        return dexOffsets != null ? dexOffsets.stringDataItemsOffset : -1;
-    }
-
-    public int getPatchedDebugInfoOffsetByOldDexSign(String oldDexSign) {
-        DexOffsets dexOffsets = this.oldDexSignToOffsetInfoMap.get(oldDexSign);
-        return dexOffsets != null ? dexOffsets.debugInfoItemsOffset : -1;
-    }
-
-    public int getPatchedAnnotationOffsetByOldDexSign(String oldDexSign) {
-        DexOffsets dexOffsets = this.oldDexSignToOffsetInfoMap.get(oldDexSign);
-        return dexOffsets != null ? dexOffsets.annotationsOffset : -1;
-    }
-
-    public int getPatchedEncodedArrayOffsetByOldDexSign(String oldDexSign) {
-        DexOffsets dexOffsets = this.oldDexSignToOffsetInfoMap.get(oldDexSign);
-        return dexOffsets != null ? dexOffsets.encodedArraysOffset : -1;
-    }
-
-    public int getPatchedAnnotationsDirectoryOffsetByOldDexSign(String oldDexSign) {
-        DexOffsets dexOffsets = this.oldDexSignToOffsetInfoMap.get(oldDexSign);
-        return dexOffsets != null ? dexOffsets.annotationsDirectoriesOffset : -1;
-    }
-
-    public int getPatchedDexSizeByOldDexSign(String oldDexSign) {
-        DexOffsets dexOffsets = this.oldDexSignToOffsetInfoMap.get(oldDexSign);
-        return dexOffsets != null ? dexOffsets.dexSize : -1;
-    }
-
-    public boolean isStringInSmallPatchedDex(String oldDexSign, int indexInPatchedDex) {
-        BitSet indices = oldDexSignToStringIndicesInSmallPatch.get(oldDexSign);
-        if (indices == null) {
-            return false;
-        }
-        return indices.get(indexInPatchedDex);
-    }
-
-    public boolean isTypeIdInSmallPatchedDex(String oldDexSign, int indexInPatchedDex) {
-        BitSet indices = oldDexSignToTypeIdIndicesInSmallPatch.get(oldDexSign);
-        if (indices == null) {
-            return false;
-        }
-        return indices.get(indexInPatchedDex);
-    }
-
-    public boolean isTypeListInSmallPatchedDex(String oldDexSign, int indexInPatchedDex) {
-        BitSet indices = oldDexSignToTypeListIndicesInSmallPatch.get(oldDexSign);
-        if (indices == null) {
-            return false;
-        }
-        return indices.get(indexInPatchedDex);
-    }
-
-    public boolean isProtoIdInSmallPatchedDex(String oldDexSign, int indexInPatchedDex) {
-        BitSet indices = oldDexSignToProtoIdIndicesInSmallPatch.get(oldDexSign);
-        if (indices == null) {
-            return false;
-        }
-        return indices.get(indexInPatchedDex);
-    }
-
-    public boolean isFieldIdInSmallPatchedDex(String oldDexSign, int indexInPatchedDex) {
-        BitSet indices = oldDexSignToFieldIdIndicesInSmallPatch.get(oldDexSign);
-        if (indices == null) {
-            return false;
-        }
-        return indices.get(indexInPatchedDex);
-    }
-
-    public boolean isMethodIdInSmallPatchedDex(String oldDexSign, int indexInPatchedDex) {
-        BitSet indices = oldDexSignToMethodIdIndicesInSmallPatch.get(oldDexSign);
-        if (indices == null) {
-            return false;
-        }
-        return indices.get(indexInPatchedDex);
-    }
-
-    public boolean isAnnotationInSmallPatchedDex(String oldDexSign, int indexInPatchedDex) {
-        BitSet indices = oldDexSignToAnnotationIndicesInSmallPatch.get(oldDexSign);
-        if (indices == null) {
-            return false;
-        }
-        return indices.get(indexInPatchedDex);
-    }
-
-    public boolean isAnnotationSetInSmallPatchedDex(String oldDexSign, int indexInPatchedDex) {
-        BitSet indices = oldDexSignToAnnotationSetIndicesInSmallPatch.get(oldDexSign);
-        if (indices == null) {
-            return false;
-        }
-        return indices.get(indexInPatchedDex);
-    }
-
-    public boolean isAnnotationSetRefListInSmallPatchedDex(
-            String oldDexSign, int indexInPatchedDex
-    ) {
-        BitSet indices = oldDexSignToAnnotationSetRefListIndicesInSmallPatch.get(oldDexSign);
-        if (indices == null) {
-            return false;
-        }
-        return indices.get(indexInPatchedDex);
-    }
-
-    public boolean isAnnotationsDirectoryInSmallPatchedDex(
-            String oldDexSign, int indexInPatchedDex
-    ) {
-        BitSet indices = oldDexSignToAnnotationsDirectoryIndicesInSmallPatch.get(oldDexSign);
-        if (indices == null) {
-            return false;
-        }
-        return indices.get(indexInPatchedDex);
-    }
-
-    public boolean isEncodedArrayInSmallPatchedDex(String oldDexSign, int indexInPatchedDex) {
-        BitSet indices = oldDexSignToEncodedArrayIndicesInSmallPatch.get(oldDexSign);
-        if (indices == null) {
-            return false;
-        }
-        return indices.get(indexInPatchedDex);
-    }
-
-    public boolean isDebugInfoInSmallPatchedDex(String oldDexSign, int indexInPatchedDex) {
-        BitSet indices = oldDexSignToDebugInfoIndicesInSmallPatch.get(oldDexSign);
-        if (indices == null) {
-            return false;
-        }
-        return indices.get(indexInPatchedDex);
-    }
-
-    public boolean isCodeInSmallPatchedDex(String oldDexSign, int indexInPatchedDex) {
-        BitSet indices = oldDexSignToCodeIndicesInSmallPatch.get(oldDexSign);
-        if (indices == null) {
-            return false;
-        }
-        return indices.get(indexInPatchedDex);
-    }
-
-    public boolean isClassDataInSmallPatchedDex(String oldDexSign, int indexInPatchedDex) {
-        BitSet indices = oldDexSignToClassDataIndicesInSmallPatch.get(oldDexSign);
-        if (indices == null) {
-            return false;
-        }
-        return indices.get(indexInPatchedDex);
-    }
-
-    public boolean isClassDefInSmallPatchedDex(String oldDexSign, int indexInPatchedDex) {
-        BitSet indices = oldDexSignToClassDefIndicesInSmallPatch.get(oldDexSign);
-        if (indices == null) {
-            return false;
-        }
-        return indices.get(indexInPatchedDex);
-    }
-}
diff --git a/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dx/util/IndexMap.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/util/AbstractIndexMap.java
similarity index 66%
rename from third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dx/util/IndexMap.java
rename to tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/util/AbstractIndexMap.java
index a9e46362..870320f0 100644
--- a/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dx/util/IndexMap.java
+++ b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/util/AbstractIndexMap.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.tencent.tinker.android.dx.util;
+package com.tencent.tinker.commons.dexpatcher.util;
 
 import com.tencent.tinker.android.dex.Annotation;
 import com.tencent.tinker.android.dex.AnnotationSet;
@@ -35,297 +35,45 @@
 import com.tencent.tinker.android.dex.TypeList;
 import com.tencent.tinker.android.dex.util.ByteInput;
 import com.tencent.tinker.android.dex.util.ByteOutput;
-import com.tencent.tinker.android.utils.SparseIntArray;
 
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
-import java.util.BitSet;
 
 /**
  * Created by tangyinsheng on 2016/6/29.
+ *
+ * *** This file is renamed from IndexMap in dx project. ***
  */
-public class IndexMap {
-    private final SparseIntArray stringIdsMap = new SparseIntArray();
-    private final SparseIntArray typeIdsMap = new SparseIntArray();
-    private final SparseIntArray protoIdsMap = new SparseIntArray();
-    private final SparseIntArray fieldIdsMap = new SparseIntArray();
-    private final SparseIntArray methodIdsMap = new SparseIntArray();
-    private final SparseIntArray typeListOffsetsMap = new SparseIntArray();
-    private final SparseIntArray annotationOffsetsMap = new SparseIntArray();
-    private final SparseIntArray annotationSetOffsetsMap = new SparseIntArray();
-    private final SparseIntArray annotationSetRefListOffsetsMap = new SparseIntArray();
-    private final SparseIntArray annotationsDirectoryOffsetsMap = new SparseIntArray();
-    private final SparseIntArray staticValuesOffsetsMap = new SparseIntArray();
-    private final SparseIntArray classDataOffsetsMap = new SparseIntArray();
-    private final SparseIntArray debugInfoItemOffsetsMap = new SparseIntArray();
-    private final SparseIntArray codeOffsetsMap = new SparseIntArray();
-
-    private final BitSet deletedStringIds = new BitSet();
-    private final BitSet deletedTypeIds = new BitSet();
-    private final BitSet deletedProtoIds = new BitSet();
-    private final BitSet deletedFieldIds = new BitSet();
-    private final BitSet deletedMethodIds = new BitSet();
-    private final BitSet deletedTypeListOffsets = new BitSet();
-    private final BitSet deletedAnnotationOffsets = new BitSet();
-    private final BitSet deletedAnnotationSetOffsets = new BitSet();
-    private final BitSet deletedAnnotationSetRefListOffsets = new BitSet();
-    private final BitSet deletedAnnotationsDirectoryOffsets = new BitSet();
-    private final BitSet deletedStaticValuesOffsets = new BitSet();
-    private final BitSet deletedClassDataOffsets = new BitSet();
-    private final BitSet deletedDebugInfoItemOffsets = new BitSet();
-    private final BitSet deletedCodeOffsets = new BitSet();
-
-    public void mapStringIds(int oldIndex, int newIndex) {
-        stringIdsMap.put(oldIndex, newIndex);
-    }
-
-    public void markStringIdDeleted(int index) {
-        if (index < 0) return;
-        deletedStringIds.set(index);
-    }
-
-    public void mapTypeIds(int oldIndex, int newIndex) {
-        typeIdsMap.put(oldIndex, newIndex);
-    }
-
-    public void markTypeIdDeleted(int index) {
-        if (index < 0) return;
-        deletedTypeIds.set(index);
-    }
-
-    public void mapProtoIds(int oldIndex, int newIndex) {
-        protoIdsMap.put(oldIndex, newIndex);
-    }
-
-    public void markProtoIdDeleted(int index) {
-        if (index < 0) return;
-        deletedProtoIds.set(index);
-    }
-
-    public void mapFieldIds(int oldIndex, int newIndex) {
-        fieldIdsMap.put(oldIndex, newIndex);
-    }
-
-    public void markFieldIdDeleted(int index) {
-        if (index < 0) return;
-        deletedFieldIds.set(index);
-    }
-
-    public void mapMethodIds(int oldIndex, int newIndex) {
-        methodIdsMap.put(oldIndex, newIndex);
-    }
-
-    public void markMethodIdDeleted(int index) {
-        if (index < 0) return;
-        deletedMethodIds.set(index);
-    }
-
-    public void mapTypeListOffset(int oldOffset, int newOffset) {
-        typeListOffsetsMap.put(oldOffset, newOffset);
-    }
 
-    public void markTypeListDeleted(int offset) {
-        if (offset < 0) return;
-        deletedTypeListOffsets.set(offset);
-    }
+public abstract class AbstractIndexMap {
 
-    public void mapAnnotationOffset(int oldOffset, int newOffset) {
-        annotationOffsetsMap.put(oldOffset, newOffset);
-    }
+    public abstract int adjustStringIndex(int stringIndex);
 
-    public void markAnnotationDeleted(int offset) {
-        if (offset < 0) return;
-        deletedAnnotationOffsets.set(offset);
-    }
+    public abstract int adjustTypeIdIndex(int typeIdIndex);
 
-    public void mapAnnotationSetOffset(int oldOffset, int newOffset) {
-        annotationSetOffsetsMap.put(oldOffset, newOffset);
-    }
+    public abstract int adjustProtoIdIndex(int protoIndex);
 
-    public void markAnnotationSetDeleted(int offset) {
-        if (offset < 0) return;
-        deletedAnnotationSetOffsets.set(offset);
-    }
+    public abstract int adjustFieldIdIndex(int fieldIndex);
 
-    public void mapAnnotationSetRefListOffset(int oldOffset, int newOffset) {
-        annotationSetRefListOffsetsMap.put(oldOffset, newOffset);
-    }
+    public abstract int adjustMethodIdIndex(int methodIndex);
 
-    public void markAnnotationSetRefListDeleted(int offset) {
-        if (offset < 0) return;
-        deletedAnnotationSetRefListOffsets.set(offset);
-    }
+    public abstract int adjustTypeListOffset(int typeListOffset);
 
-    public void mapAnnotationsDirectoryOffset(int oldOffset, int newOffset) {
-        annotationsDirectoryOffsetsMap.put(oldOffset, newOffset);
-    }
+    public abstract int adjustAnnotationOffset(int annotationOffset);
 
-    public void markAnnotationsDirectoryDeleted(int offset) {
-        if (offset < 0) return;
-        deletedAnnotationsDirectoryOffsets.set(offset);
-    }
+    public abstract int adjustAnnotationSetOffset(int annotationSetOffset);
 
-    public void mapStaticValuesOffset(int oldOffset, int newOffset) {
-        staticValuesOffsetsMap.put(oldOffset, newOffset);
-    }
+    public abstract int adjustAnnotationSetRefListOffset(int annotationSetRefListOffset);
 
-    public void markStaticValuesDeleted(int offset) {
-        if (offset < 0) return;
-        deletedStaticValuesOffsets.set(offset);
-    }
-
-    public void mapClassDataOffset(int oldOffset, int newOffset) {
-        classDataOffsetsMap.put(oldOffset, newOffset);
-    }
-
-    public void markClassDataDeleted(int offset) {
-        if (offset < 0) return;
-        deletedClassDataOffsets.set(offset);
-    }
+    public abstract int adjustAnnotationsDirectoryOffset(int annotationsDirectoryOffset);
 
-    public void mapDebugInfoItemOffset(int oldOffset, int newOffset) {
-        debugInfoItemOffsetsMap.put(oldOffset, newOffset);
-    }
+    public abstract int adjustStaticValuesOffset(int staticValuesOffset);
 
-    public void markDebugInfoItemDeleted(int offset) {
-        if (offset < 0) return;
-        deletedDebugInfoItemOffsets.set(offset);
-    }
+    public abstract int adjustClassDataOffset(int classDataOffset);
 
-    public void mapCodeOffset(int oldOffset, int newOffset) {
-        codeOffsetsMap.put(oldOffset, newOffset);
-    }
-
-    public void markCodeDeleted(int offset) {
-        if (offset < 0) return;
-        deletedCodeOffsets.set(offset);
-    }
+    public abstract int adjustDebugInfoItemOffset(int debugInfoItemOffset);
 
-    public int adjustStringIndex(int stringIndex) {
-        int index = stringIdsMap.indexOfKey(stringIndex);
-        if (index < 0) {
-            return (stringIndex >= 0 && deletedStringIds.get(stringIndex) ? -1 : stringIndex);
-        } else {
-            return stringIdsMap.valueAt(index);
-        }
-    }
-
-    public int adjustTypeIdIndex(int typeIdIndex) {
-        int index = typeIdsMap.indexOfKey(typeIdIndex);
-        if (index < 0) {
-            return (typeIdIndex >= 0 && deletedTypeIds.get(typeIdIndex) ? -1 : typeIdIndex);
-        } else {
-            return typeIdsMap.valueAt(index);
-        }
-    }
-
-    public int adjustProtoIdIndex(int protoIndex) {
-        int index = protoIdsMap.indexOfKey(protoIndex);
-        if (index < 0) {
-            return (protoIndex >= 0 && deletedProtoIds.get(protoIndex) ? -1 : protoIndex);
-        } else {
-            return protoIdsMap.valueAt(index);
-        }
-    }
-
-    public int adjustFieldIdIndex(int fieldIndex) {
-        int index = fieldIdsMap.indexOfKey(fieldIndex);
-        if (index < 0) {
-            return (fieldIndex >= 0 && deletedFieldIds.get(fieldIndex) ? -1 : fieldIndex);
-        } else {
-            return fieldIdsMap.valueAt(index);
-        }
-    }
-
-    public int adjustMethodIdIndex(int methodIndex) {
-        int index = methodIdsMap.indexOfKey(methodIndex);
-        if (index < 0) {
-            return (methodIndex >= 0 && deletedMethodIds.get(methodIndex) ? -1 : methodIndex);
-        } else {
-            return methodIdsMap.valueAt(index);
-        }
-    }
-
-    public int adjustTypeListOffset(int typeListOffset) {
-        int index = typeListOffsetsMap.indexOfKey(typeListOffset);
-        if (index < 0) {
-            return (typeListOffset >= 0 && deletedTypeListOffsets.get(typeListOffset) ? -1 : typeListOffset);
-        } else {
-            return typeListOffsetsMap.valueAt(index);
-        }
-    }
-
-    public int adjustAnnotationOffset(int annotationOffset) {
-        int index = annotationOffsetsMap.indexOfKey(annotationOffset);
-        if (index < 0) {
-            return (annotationOffset >= 0 && deletedAnnotationOffsets.get(annotationOffset) ? -1 : annotationOffset);
-        } else {
-            return annotationOffsetsMap.valueAt(index);
-        }
-    }
-
-    public int adjustAnnotationSetOffset(int annotationSetOffset) {
-        int index = annotationSetOffsetsMap.indexOfKey(annotationSetOffset);
-        if (index < 0) {
-            return (annotationSetOffset >= 0 && deletedAnnotationSetOffsets.get(annotationSetOffset) ? -1 : annotationSetOffset);
-        } else {
-            return annotationSetOffsetsMap.valueAt(index);
-        }
-    }
-
-    public int adjustAnnotationSetRefListOffset(int annotationSetRefListOffset) {
-        int index = annotationSetRefListOffsetsMap.indexOfKey(annotationSetRefListOffset);
-        if (index < 0) {
-            return (annotationSetRefListOffset >= 0 && deletedAnnotationSetRefListOffsets.get(annotationSetRefListOffset) ? -1 : annotationSetRefListOffset);
-        } else {
-            return annotationSetRefListOffsetsMap.valueAt(index);
-        }
-    }
-
-    public int adjustAnnotationsDirectoryOffset(int annotationsDirectoryOffset) {
-        int index = annotationsDirectoryOffsetsMap.indexOfKey(annotationsDirectoryOffset);
-        if (index < 0) {
-            return (annotationsDirectoryOffset >= 0 && deletedAnnotationsDirectoryOffsets.get(annotationsDirectoryOffset) ? -1 : annotationsDirectoryOffset);
-        } else {
-            return annotationsDirectoryOffsetsMap.valueAt(index);
-        }
-    }
-
-    public int adjustStaticValuesOffset(int staticValuesOffset) {
-        int index = staticValuesOffsetsMap.indexOfKey(staticValuesOffset);
-        if (index < 0) {
-            return (staticValuesOffset >= 0 && deletedStaticValuesOffsets.get(staticValuesOffset) ? -1 : staticValuesOffset);
-        } else {
-            return staticValuesOffsetsMap.valueAt(index);
-        }
-    }
-
-    public int adjustClassDataOffset(int classDataOffset) {
-        int index = classDataOffsetsMap.indexOfKey(classDataOffset);
-        if (index < 0) {
-            return (classDataOffset >= 0 && deletedClassDataOffsets.get(classDataOffset) ? -1 : classDataOffset);
-        } else {
-            return classDataOffsetsMap.valueAt(index);
-        }
-    }
-
-    public int adjustDebugInfoItemOffset(int debugInfoItemOffset) {
-        int index = debugInfoItemOffsetsMap.indexOfKey(debugInfoItemOffset);
-        if (index < 0) {
-            return (debugInfoItemOffset >= 0 && deletedDebugInfoItemOffsets.get(debugInfoItemOffset) ? -1 : debugInfoItemOffset);
-        } else {
-            return debugInfoItemOffsetsMap.valueAt(index);
-        }
-    }
-
-    public int adjustCodeOffset(int codeOffset) {
-        int index = codeOffsetsMap.indexOfKey(codeOffset);
-        if (index < 0) {
-            return (codeOffset >= 0 && deletedCodeOffsets.get(codeOffset) ? -1 : codeOffset);
-        } else {
-            return codeOffsetsMap.valueAt(index);
-        }
-    }
+    public abstract int adjustCodeOffset(int codeOffset);
 
     public TypeList adjust(TypeList typeList) {
         if (typeList == TypeList.EMPTY) {
diff --git a/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dx/util/InstructionTransformer.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/util/InstructionTransformer.java
similarity index 96%
rename from third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dx/util/InstructionTransformer.java
rename to tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/util/InstructionTransformer.java
index cc6562d2..3a1b590b 100644
--- a/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dx/util/InstructionTransformer.java
+++ b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/util/InstructionTransformer.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.tencent.tinker.android.dx.util;
+package com.tencent.tinker.commons.dexpatcher.util;
 
 import com.tencent.tinker.android.dex.DexException;
 import com.tencent.tinker.android.dx.instruction.InstructionCodec;
@@ -31,9 +31,9 @@
  * Created by tangyinsheng on 2016/6/29.
  */
 public final class InstructionTransformer {
-    private final com.tencent.tinker.android.dx.util.IndexMap indexMap;
+    private final AbstractIndexMap indexMap;
 
-    public InstructionTransformer(com.tencent.tinker.android.dx.util.IndexMap indexMap) {
+    public InstructionTransformer(AbstractIndexMap indexMap) {
         this.indexMap = indexMap;
     }
 
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/util/SparseIndexMap.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/util/SparseIndexMap.java
new file mode 100644
index 00000000..f922079a
--- /dev/null
+++ b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/util/SparseIndexMap.java
@@ -0,0 +1,324 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.commons.dexpatcher.util;
+
+import com.tencent.tinker.android.utils.SparseBoolArray;
+import com.tencent.tinker.android.utils.SparseIntArray;
+
+/**
+ * Created by tangyinsheng on 2016/6/29.
+ *
+ * *** This file is renamed from IndexMap in dx project. ***
+ */
+
+public class SparseIndexMap extends AbstractIndexMap {
+    private final SparseIntArray stringIdsMap = new SparseIntArray();
+    private final SparseIntArray typeIdsMap = new SparseIntArray();
+    private final SparseIntArray protoIdsMap = new SparseIntArray();
+    private final SparseIntArray fieldIdsMap = new SparseIntArray();
+    private final SparseIntArray methodIdsMap = new SparseIntArray();
+    private final SparseIntArray typeListOffsetsMap = new SparseIntArray();
+    private final SparseIntArray annotationOffsetsMap = new SparseIntArray();
+    private final SparseIntArray annotationSetOffsetsMap = new SparseIntArray();
+    private final SparseIntArray annotationSetRefListOffsetsMap = new SparseIntArray();
+    private final SparseIntArray annotationsDirectoryOffsetsMap = new SparseIntArray();
+    private final SparseIntArray staticValuesOffsetsMap = new SparseIntArray();
+    private final SparseIntArray classDataOffsetsMap = new SparseIntArray();
+    private final SparseIntArray debugInfoItemOffsetsMap = new SparseIntArray();
+    private final SparseIntArray codeOffsetsMap = new SparseIntArray();
+
+    private final SparseBoolArray deletedStringIds = new SparseBoolArray();
+    private final SparseBoolArray deletedTypeIds = new SparseBoolArray();
+    private final SparseBoolArray deletedProtoIds = new SparseBoolArray();
+    private final SparseBoolArray deletedFieldIds = new SparseBoolArray();
+    private final SparseBoolArray deletedMethodIds = new SparseBoolArray();
+    private final SparseBoolArray deletedTypeListOffsets = new SparseBoolArray();
+    private final SparseBoolArray deletedAnnotationOffsets = new SparseBoolArray();
+    private final SparseBoolArray deletedAnnotationSetOffsets = new SparseBoolArray();
+    private final SparseBoolArray deletedAnnotationSetRefListOffsets = new SparseBoolArray();
+    private final SparseBoolArray deletedAnnotationsDirectoryOffsets = new SparseBoolArray();
+    private final SparseBoolArray deletedStaticValuesOffsets = new SparseBoolArray();
+    private final SparseBoolArray deletedClassDataOffsets = new SparseBoolArray();
+    private final SparseBoolArray deletedDebugInfoItemOffsets = new SparseBoolArray();
+    private final SparseBoolArray deletedCodeOffsets = new SparseBoolArray();
+
+    public void mapStringIds(int oldIndex, int newIndex) {
+        stringIdsMap.put(oldIndex, newIndex);
+    }
+
+    public void markStringIdDeleted(int index) {
+        if (index < 0) return;
+        deletedStringIds.put(index, true);
+    }
+
+    public void mapTypeIds(int oldIndex, int newIndex) {
+        typeIdsMap.put(oldIndex, newIndex);
+    }
+
+    public void markTypeIdDeleted(int index) {
+        if (index < 0) return;
+        deletedTypeIds.put(index, true);
+    }
+
+    public void mapProtoIds(int oldIndex, int newIndex) {
+        protoIdsMap.put(oldIndex, newIndex);
+    }
+
+    public void markProtoIdDeleted(int index) {
+        if (index < 0) return;
+        deletedProtoIds.put(index, true);
+    }
+
+    public void mapFieldIds(int oldIndex, int newIndex) {
+        fieldIdsMap.put(oldIndex, newIndex);
+    }
+
+    public void markFieldIdDeleted(int index) {
+        if (index < 0) return;
+        deletedFieldIds.put(index, true);
+    }
+
+    public void mapMethodIds(int oldIndex, int newIndex) {
+        methodIdsMap.put(oldIndex, newIndex);
+    }
+
+    public void markMethodIdDeleted(int index) {
+        if (index < 0) return;
+        deletedMethodIds.put(index, true);
+    }
+
+    public void mapTypeListOffset(int oldOffset, int newOffset) {
+        typeListOffsetsMap.put(oldOffset, newOffset);
+    }
+
+    public void markTypeListDeleted(int offset) {
+        if (offset < 0) return;
+        deletedTypeListOffsets.put(offset, true);
+    }
+
+    public void mapAnnotationOffset(int oldOffset, int newOffset) {
+        annotationOffsetsMap.put(oldOffset, newOffset);
+    }
+
+    public void markAnnotationDeleted(int offset) {
+        if (offset < 0) return;
+        deletedAnnotationOffsets.put(offset, true);
+    }
+
+    public void mapAnnotationSetOffset(int oldOffset, int newOffset) {
+        annotationSetOffsetsMap.put(oldOffset, newOffset);
+    }
+
+    public void markAnnotationSetDeleted(int offset) {
+        if (offset < 0) return;
+        deletedAnnotationSetOffsets.put(offset, true);
+    }
+
+    public void mapAnnotationSetRefListOffset(int oldOffset, int newOffset) {
+        annotationSetRefListOffsetsMap.put(oldOffset, newOffset);
+    }
+
+    public void markAnnotationSetRefListDeleted(int offset) {
+        if (offset < 0) return;
+        deletedAnnotationSetRefListOffsets.put(offset, true);
+    }
+
+    public void mapAnnotationsDirectoryOffset(int oldOffset, int newOffset) {
+        annotationsDirectoryOffsetsMap.put(oldOffset, newOffset);
+    }
+
+    public void markAnnotationsDirectoryDeleted(int offset) {
+        if (offset < 0) return;
+        deletedAnnotationsDirectoryOffsets.put(offset, true);
+    }
+
+    public void mapStaticValuesOffset(int oldOffset, int newOffset) {
+        staticValuesOffsetsMap.put(oldOffset, newOffset);
+    }
+
+    public void markStaticValuesDeleted(int offset) {
+        if (offset < 0) return;
+        deletedStaticValuesOffsets.put(offset, true);
+    }
+
+    public void mapClassDataOffset(int oldOffset, int newOffset) {
+        classDataOffsetsMap.put(oldOffset, newOffset);
+    }
+
+    public void markClassDataDeleted(int offset) {
+        if (offset < 0) return;
+        deletedClassDataOffsets.put(offset, true);
+    }
+
+    public void mapDebugInfoItemOffset(int oldOffset, int newOffset) {
+        debugInfoItemOffsetsMap.put(oldOffset, newOffset);
+    }
+
+    public void markDebugInfoItemDeleted(int offset) {
+        if (offset < 0) return;
+        deletedDebugInfoItemOffsets.put(offset, true);
+    }
+
+    public void mapCodeOffset(int oldOffset, int newOffset) {
+        codeOffsetsMap.put(oldOffset, newOffset);
+    }
+
+    public void markCodeDeleted(int offset) {
+        if (offset < 0) return;
+        deletedCodeOffsets.put(offset, true);
+    }
+
+    @Override
+    public int adjustStringIndex(int stringIndex) {
+        int index = stringIdsMap.indexOfKey(stringIndex);
+        if (index < 0) {
+            return (stringIndex >= 0 && deletedStringIds.containsKey(stringIndex) ? -1 : stringIndex);
+        } else {
+            return stringIdsMap.valueAt(index);
+        }
+    }
+
+    @Override
+    public int adjustTypeIdIndex(int typeIdIndex) {
+        int index = typeIdsMap.indexOfKey(typeIdIndex);
+        if (index < 0) {
+            return (typeIdIndex >= 0 && deletedTypeIds.containsKey(typeIdIndex) ? -1 : typeIdIndex);
+        } else {
+            return typeIdsMap.valueAt(index);
+        }
+    }
+
+    @Override
+    public int adjustProtoIdIndex(int protoIndex) {
+        int index = protoIdsMap.indexOfKey(protoIndex);
+        if (index < 0) {
+            return (protoIndex >= 0 && deletedProtoIds.containsKey(protoIndex) ? -1 : protoIndex);
+        } else {
+            return protoIdsMap.valueAt(index);
+        }
+    }
+
+    @Override
+    public int adjustFieldIdIndex(int fieldIndex) {
+        int index = fieldIdsMap.indexOfKey(fieldIndex);
+        if (index < 0) {
+            return (fieldIndex >= 0 && deletedFieldIds.containsKey(fieldIndex) ? -1 : fieldIndex);
+        } else {
+            return fieldIdsMap.valueAt(index);
+        }
+    }
+
+    @Override
+    public int adjustMethodIdIndex(int methodIndex) {
+        int index = methodIdsMap.indexOfKey(methodIndex);
+        if (index < 0) {
+            return (methodIndex >= 0 && deletedMethodIds.containsKey(methodIndex) ? -1 : methodIndex);
+        } else {
+            return methodIdsMap.valueAt(index);
+        }
+    }
+
+    @Override
+    public int adjustTypeListOffset(int typeListOffset) {
+        int index = typeListOffsetsMap.indexOfKey(typeListOffset);
+        if (index < 0) {
+            return (typeListOffset >= 0 && deletedTypeListOffsets.containsKey(typeListOffset) ? -1 : typeListOffset);
+        } else {
+            return typeListOffsetsMap.valueAt(index);
+        }
+    }
+
+    @Override
+    public int adjustAnnotationOffset(int annotationOffset) {
+        int index = annotationOffsetsMap.indexOfKey(annotationOffset);
+        if (index < 0) {
+            return (annotationOffset >= 0 && deletedAnnotationOffsets.containsKey(annotationOffset) ? -1 : annotationOffset);
+        } else {
+            return annotationOffsetsMap.valueAt(index);
+        }
+    }
+
+    @Override
+    public int adjustAnnotationSetOffset(int annotationSetOffset) {
+        int index = annotationSetOffsetsMap.indexOfKey(annotationSetOffset);
+        if (index < 0) {
+            return (annotationSetOffset >= 0 && deletedAnnotationSetOffsets.containsKey(annotationSetOffset) ? -1 : annotationSetOffset);
+        } else {
+            return annotationSetOffsetsMap.valueAt(index);
+        }
+    }
+
+    @Override
+    public int adjustAnnotationSetRefListOffset(int annotationSetRefListOffset) {
+        int index = annotationSetRefListOffsetsMap.indexOfKey(annotationSetRefListOffset);
+        if (index < 0) {
+            return (annotationSetRefListOffset >= 0 && deletedAnnotationSetRefListOffsets.containsKey(annotationSetRefListOffset) ? -1 : annotationSetRefListOffset);
+        } else {
+            return annotationSetRefListOffsetsMap.valueAt(index);
+        }
+    }
+
+    @Override
+    public int adjustAnnotationsDirectoryOffset(int annotationsDirectoryOffset) {
+        int index = annotationsDirectoryOffsetsMap.indexOfKey(annotationsDirectoryOffset);
+        if (index < 0) {
+            return (annotationsDirectoryOffset >= 0 && deletedAnnotationsDirectoryOffsets.containsKey(annotationsDirectoryOffset) ? -1 : annotationsDirectoryOffset);
+        } else {
+            return annotationsDirectoryOffsetsMap.valueAt(index);
+        }
+    }
+
+    @Override
+    public int adjustStaticValuesOffset(int staticValuesOffset) {
+        int index = staticValuesOffsetsMap.indexOfKey(staticValuesOffset);
+        if (index < 0) {
+            return (staticValuesOffset >= 0 && deletedStaticValuesOffsets.containsKey(staticValuesOffset) ? -1 : staticValuesOffset);
+        } else {
+            return staticValuesOffsetsMap.valueAt(index);
+        }
+    }
+
+    @Override
+    public int adjustClassDataOffset(int classDataOffset) {
+        int index = classDataOffsetsMap.indexOfKey(classDataOffset);
+        if (index < 0) {
+            return (classDataOffset >= 0 && deletedClassDataOffsets.containsKey(classDataOffset) ? -1 : classDataOffset);
+        } else {
+            return classDataOffsetsMap.valueAt(index);
+        }
+    }
+
+    @Override
+    public int adjustDebugInfoItemOffset(int debugInfoItemOffset) {
+        int index = debugInfoItemOffsetsMap.indexOfKey(debugInfoItemOffset);
+        if (index < 0) {
+            return (debugInfoItemOffset >= 0 && deletedDebugInfoItemOffsets.containsKey(debugInfoItemOffset) ? -1 : debugInfoItemOffset);
+        } else {
+            return debugInfoItemOffsetsMap.valueAt(index);
+        }
+    }
+
+    @Override
+    public int adjustCodeOffset(int codeOffset) {
+        int index = codeOffsetsMap.indexOfKey(codeOffset);
+        if (index < 0) {
+            return (codeOffset >= 0 && deletedCodeOffsets.containsKey(codeOffset) ? -1 : codeOffset);
+        } else {
+            return codeOffsetsMap.valueAt(index);
+        }
+    }
+}
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/ziputil/TinkerZipEntry.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/ziputil/TinkerZipEntry.java
index a1f03235..54510611 100644
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/ziputil/TinkerZipEntry.java
+++ b/tinker-commons/src/main/java/com/tencent/tinker/commons/ziputil/TinkerZipEntry.java
@@ -418,7 +418,7 @@ public String toString() {
         sb.append("\ncrc:" + crc);
         sb.append("\ncompressionMethod:" + compressionMethod);
         sb.append("\nmodDate:" + modDate);
-        sb.append("\nextra:" + extra);
+        sb.append("\nextra length:" + extra.length);
         sb.append("\nlocalHeaderRelOffset:" + localHeaderRelOffset);
         sb.append("\ndataOffset:" + dataOffset);
         return sb.toString();
diff --git a/tinker-sample-android/app/build.gradle b/tinker-sample-android/app/build.gradle
index 516f6b4e..8af387d0 100644
--- a/tinker-sample-android/app/build.gradle
+++ b/tinker-sample-android/app/build.gradle
@@ -77,12 +77,6 @@ android {
          * you can use multiDex and install it in your ApplicationLifeCycle implement
          */
         multiDexEnabled true
-        /**
-         * not like proguard, multiDexKeepProguard is not a list, so we can't just
-         * add for you in our task. you can copy tinker keep rules at
-         * build/intermediates/tinker_intermediates/tinker_multidexkeep.pro
-         */
-        multiDexKeepProguard file("keep_in_main_dex.txt")
         /**
          * buildConfig can change during patch!
          * we can use the newly value when patch
@@ -93,7 +87,7 @@ android {
          * client version would update with patch
          * so we can get the newly git version easily!
          */
-        buildConfigField "String", "CLIENTVERSION", "\"${getTinkerIdValue()}\""
+        buildConfigField "String", "TINKER_ID", "\"${getTinkerIdValue()}\""
         buildConfigField "String", "PLATFORM",  "\"all\""
     }
 
@@ -214,6 +208,12 @@ if (buildWithTinker()) {
          */
         useSign = true
 
+        /**
+         * optional，default 'true'
+         * whether use tinker to build
+         */
+        tinkerEnable = buildWithTinker()
+
         /**
          * Warning, applyMapping will affect the normal android build!
          */
@@ -240,6 +240,21 @@ if (buildWithTinker()) {
              * we will gen the tinkerId in your manifest automatic
              */
             tinkerId = getTinkerIdValue()
+
+            /**
+             * if keepDexApply is true, class in which dex refer to the old apk.
+             * open this can reduce the dex diff file size.
+             */
+            keepDexApply = false
+
+            /**
+             * optional, default 'false'
+             * Whether tinker should treat the base apk as the one being protected by app
+             * protection tools.
+             * If this attribute is true, the generated patch package will contain a
+             * dex including all changed classes instead of any dexdiff patch-info files.
+             */
+            isProtectedApp = false
         }
 
         dex {
@@ -251,20 +266,7 @@ if (buildWithTinker()) {
              * or you want to save rom or check quicker, you can use raw mode also
              */
             dexMode = "jar"
-            /**
-             * optional，default 'false'
-             * if usePreGeneratedPatchDex is true, tinker framework will generate auxiliary class
-             * and insert auxiliary instruction when compiling base package using
-             * assemble{Debug/Release} task to prevent class pre-verified issue in dvm.
-             * Besides, a real dex file contains necessary class will be generated and packed into
-             * patch package instead of any patch info files.
-             *
-             * Use this mode if you have to use any dex encryption solutions.
-             *
-             * Notice: If you change this value, please trigger clean task
-             * and regenerate base package.
-             */
-            usePreGeneratedPatchDex = false
+
             /**
              * necessary，default '[]'
              * what dexes in apk are expected to deal with tinkerPatch
@@ -281,9 +283,7 @@ if (buildWithTinker()) {
              * own tinkerLoader, and the classes you use in them
              *
              */
-            loader = ["com.tencent.tinker.loader.*",
-                      //warning, you must change it with your application
-                      "tinker.sample.android.app.SampleApplication",
+            loader = [
                       //use sample, let BaseBuildInfo unchangeable with tinker
                       "tinker.sample.android.app.BaseBuildInfo"
             ]
@@ -297,7 +297,7 @@ if (buildWithTinker()) {
              * for library in assets, we would just recover them in the patch directory
              * you can get them in TinkerLoadResult with Tinker
              */
-            pattern = ["lib/armeabi/*.so"]
+            pattern = ["lib/*/*.so"]
         }
 
         res {
@@ -359,7 +359,7 @@ if (buildWithTinker()) {
              * optional，default '7za'
              * the 7zip artifact path, it will use the right 7za with your platform
              */
-            zipArtifact = "com.tencent.mm:SevenZip:1.1.10"
+           zipArtifact = "com.tencent.mm:SevenZip:1.1.10"
             /**
              * optional，default '7za'
              * you can specify the 7za path yourself, it will overwrite the zipArtifact value
@@ -373,6 +373,8 @@ if (buildWithTinker()) {
         flavors.add(flavor.name)
     }
     boolean hasFlavors = flavors.size() > 0
+    def date = new Date().format("MMdd-HH-mm-ss")
+
     /**
     * bak apk and mapping
     */
@@ -381,7 +383,6 @@ if (buildWithTinker()) {
          * task type, you want to bak
          */
         def taskName = variant.name
-        def date = new Date().format("MMdd-HH-mm-ss")
 
         tasks.all {
             if ("assemble${taskName.capitalize()}".equalsIgnoreCase(it.name)) {
diff --git a/tinker-sample-android/app/keep_in_main_dex.txt b/tinker-sample-android/app/keep_in_main_dex.txt
deleted file mode 100644
index 12c1dcf5..00000000
--- a/tinker-sample-android/app/keep_in_main_dex.txt
+++ /dev/null
@@ -1,26 +0,0 @@
-# you can copy the tinker keep rule at
-# build/intermediates/tinker_intermediates/tinker_multidexkeep.pro
-
--keep class com.tencent.tinker.loader.** {
-    *;
-}
-
--keep class tinker.sample.android.app.SampleApplication {
-    *;
-}
-
--keep public class * implements com.tencent.tinker.loader.app.ApplicationLifeCycle {
-    *;
-}
-
--keep public class * extends com.tencent.tinker.loader.TinkerLoader {
-    *;
-}
-
--keep public class * extends com.tencent.tinker.loader.app.TinkerApplication {
-    *;
-}
-
-# here, it is your own keep rules.
-# you must be careful that the class name you write won't be proguard
-# but the tinker class above is OK, we have already keep for you!
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/app/BaseBuildInfo.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/app/BaseBuildInfo.java
index 4ffa7d4d..eca15927 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/app/BaseBuildInfo.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/app/BaseBuildInfo.java
@@ -16,10 +16,13 @@
 
 package tinker.sample.android.app;
 
+import tinker.sample.android.BuildConfig;
+
 /**
  * Created by zhangshaowen on 16/6/30.
  * we add BaseBuildInfo to loader pattern, so it won't change with patch!
  */
 public class BaseBuildInfo {
     public static String TEST_MESSAGE = "I won't change with tinker patch!";
+    public static String BASE_TINKER_ID = BuildConfig.TINKER_ID;
 }
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/app/BuildInfo.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/app/BuildInfo.java
index 58ea3527..e1d73f52 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/app/BuildInfo.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/app/BuildInfo.java
@@ -31,7 +31,7 @@
     public static int     VERSION_CODE = BuildConfig.VERSION_CODE;
 
     public static String MESSAGE       = BuildConfig.MESSAGE;
-    public static String CLIENTVERSION = BuildConfig.CLIENTVERSION;
+    public static String TINKER_ID     = BuildConfig.TINKER_ID;
     public static String PLATFORM      = BuildConfig.PLATFORM;
 
 }
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/app/MainActivity.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/app/MainActivity.java
index bc55dc62..6bc8122b 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/app/MainActivity.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/app/MainActivity.java
@@ -30,6 +30,7 @@
 import android.widget.Button;
 import android.widget.TextView;
 
+import com.tencent.tinker.lib.library.TinkerLoadLibrary;
 import com.tencent.tinker.lib.tinker.Tinker;
 import com.tencent.tinker.lib.tinker.TinkerInstaller;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
@@ -64,9 +65,16 @@ public void onClick(View v) {
         loadLibraryButton.setOnClickListener(new View.OnClickListener() {
             @Override
             public void onClick(View v) {
-                //for lib/armeabi, just use TinkerInstaller.loadLibrary
-                TinkerInstaller.loadArmLibrary(getApplicationContext(), "stlport_shared");
+                // #method 1, hack classloader library path
+                TinkerLoadLibrary.installNavitveLibraryABI(getApplicationContext(), "armeabi");
+                System.loadLibrary("stlport_shared");
+
+                // #method 2, for lib/armeabi, just use TinkerInstaller.loadLibrary
+//                TinkerLoadLibrary.loadArmLibrary(getApplicationContext(), "stlport_shared");
+
+                // #method 3, load tinker patch library directly
 //                TinkerInstaller.loadLibraryFromTinker(getApplicationContext(), "assets/x86", "stlport_shared");
+
             }
         });
 
@@ -84,6 +92,7 @@ public void onClick(View v) {
         killSelfButton.setOnClickListener(new View.OnClickListener() {
             @Override
             public void onClick(View v) {
+                ShareTinkerInternals.killAllOtherProcess(getApplicationContext());
                 android.os.Process.killProcess(android.os.Process.myPid());
             }
         });
@@ -104,16 +113,19 @@ public boolean showInfo(Context context) {
         Tinker tinker = Tinker.with(getApplicationContext());
         if (tinker.isTinkerLoaded()) {
             sb.append(String.format("[patch is loaded] \n"));
-            sb.append(String.format("[buildConfig CLIENTVERSION] %s \n", BuildInfo.CLIENTVERSION));
+            sb.append(String.format("[buildConfig TINKER_ID] %s \n", BuildInfo.TINKER_ID));
+            sb.append(String.format("[buildConfig BASE_TINKER_ID] %s \n", BaseBuildInfo.BASE_TINKER_ID));
+
             sb.append(String.format("[buildConfig MESSSAGE] %s \n", BuildInfo.MESSAGE));
             sb.append(String.format("[TINKER_ID] %s \n", tinker.getTinkerLoadResultIfPresent().getPackageConfigByName(ShareConstants.TINKER_ID)));
-            sb.append(String.format("[REAL TINKER_ID] %s \n", tinker.getTinkerLoadResultIfPresent().getTinkerID()));
             sb.append(String.format("[packageConfig patchMessage] %s \n", tinker.getTinkerLoadResultIfPresent().getPackageConfigByName("patchMessage")));
             sb.append(String.format("[TINKER_ID Rom Space] %d k \n", tinker.getTinkerRomSpace()));
 
         } else {
             sb.append(String.format("[patch is not loaded] \n"));
-            sb.append(String.format("[buildConfig CLIENTVERSION] %s \n", BuildInfo.CLIENTVERSION));
+            sb.append(String.format("[buildConfig TINKER_ID] %s \n", BuildInfo.TINKER_ID));
+            sb.append(String.format("[buildConfig BASE_TINKER_ID] %s \n", BaseBuildInfo.BASE_TINKER_ID));
+
             sb.append(String.format("[buildConfig MESSSAGE] %s \n", BuildInfo.MESSAGE));
             sb.append(String.format("[TINKER_ID] %s \n", ShareTinkerInternals.getManifestTinkerID(getApplicationContext())));
         }
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/app/SampleApplicationLike.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/app/SampleApplicationLike.java
index bf550dbe..9233951e 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/app/SampleApplicationLike.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/app/SampleApplicationLike.java
@@ -20,12 +20,11 @@
 import android.app.Application;
 import android.content.Context;
 import android.content.Intent;
-import android.content.res.AssetManager;
-import android.content.res.Resources;
 import android.os.Build;
 import android.support.multidex.MultiDex;
 
 import com.tencent.tinker.anno.DefaultLifeCycle;
+import com.tencent.tinker.lib.tinker.Tinker;
 import com.tencent.tinker.lib.tinker.TinkerInstaller;
 import com.tencent.tinker.loader.app.ApplicationLifeCycle;
 import com.tencent.tinker.loader.app.DefaultApplicationLike;
@@ -64,9 +63,8 @@
     private static final String TAG = "Tinker.SampleApplicationLike";
 
     public SampleApplicationLike(Application application, int tinkerFlags, boolean tinkerLoadVerifyFlag,
-                                 long applicationStartElapsedTime, long applicationStartMillisTime, Intent tinkerResultIntent,
-                                 Resources[] resources, ClassLoader[] classLoader, AssetManager[] assetManager) {
-        super(application, tinkerFlags, tinkerLoadVerifyFlag, applicationStartElapsedTime, applicationStartMillisTime, tinkerResultIntent, resources, classLoader, assetManager);
+                                 long applicationStartElapsedTime, long applicationStartMillisTime, Intent tinkerResultIntent) {
+        super(application, tinkerFlags, tinkerLoadVerifyFlag, applicationStartElapsedTime, applicationStartMillisTime, tinkerResultIntent);
     }
 
     /**
@@ -85,6 +83,7 @@ public void onBaseContextAttached(Context base) {
         SampleApplicationContext.application = getApplication();
         SampleApplicationContext.context = getApplication();
         TinkerManager.setTinkerApplicationLike(this);
+
         TinkerManager.initFastCrashProtect();
         //should set before tinker is installed
         TinkerManager.setUpgradeRetryEnable(true);
@@ -95,6 +94,7 @@ public void onBaseContextAttached(Context base) {
         //installTinker after load multiDex
         //or you can put com.tencent.tinker.** to main dex
         TinkerManager.installTinker(this);
+        Tinker tinker = Tinker.with(getApplication());
     }
 
     @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/crash/SampleUncaughtExceptionHandler.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/crash/SampleUncaughtExceptionHandler.java
index b98bbb4d..90dcd767 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/crash/SampleUncaughtExceptionHandler.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/crash/SampleUncaughtExceptionHandler.java
@@ -19,7 +19,6 @@
 import android.content.Context;
 import android.content.SharedPreferences;
 import android.os.SystemClock;
-import android.widget.Toast;
 
 import com.tencent.tinker.lib.tinker.TinkerApplicationHelper;
 import com.tencent.tinker.lib.util.TinkerLog;
@@ -66,38 +65,46 @@ public void uncaughtException(Thread thread, Throwable ex) {
      * If it use Xposed, we can just clean patch or mention user to uninstall it.
      */
     private void tinkerPreVerifiedCrashHandler(Throwable ex) {
-        if (Utils.isXposedExists(ex)) {
-            //method 1
-            ApplicationLike applicationLike = TinkerManager.getTinkerApplicationLike();
-            if (applicationLike == null || applicationLike.getApplication() == null) {
-                return;
-            }
+        ApplicationLike applicationLike = TinkerManager.getTinkerApplicationLike();
+        if (applicationLike == null || applicationLike.getApplication() == null) {
+            TinkerLog.w(TAG, "applicationlike is null");
+            return;
+        }
 
-            if (!TinkerApplicationHelper.isTinkerLoadSuccess(applicationLike)) {
-                return;
-            }
-            boolean isCausedByXposed = false;
-            //for art, we can't know the actually crash type
-            //art's xposed has not much people
-            if (ShareTinkerInternals.isVmArt()) {
-                isCausedByXposed = true;
-            } else if (ex instanceof IllegalAccessError && ex.getMessage().contains(DALVIK_XPOSED_CRASH)) {
-                //for dalvik, we know the actual crash type
-                isCausedByXposed = true;
-            }
+        if (!TinkerApplicationHelper.isTinkerLoadSuccess(applicationLike)) {
+            TinkerLog.w(TAG, "tinker is not loaded");
+            return;
+        }
 
-            if (isCausedByXposed) {
-                SampleTinkerReport.onXposedCrash();
-                TinkerLog.e(TAG, "have xposed: just clean tinker");
-                //kill all other process to ensure that all process's code is the same.
-                ShareTinkerInternals.killAllOtherProcess(applicationLike.getApplication());
+        Throwable throwable = ex;
+        boolean isXposed = false;
+        while (throwable != null) {
+            if (!isXposed) {
+                isXposed = Utils.isXposedExists(throwable);
+            }
 
-                TinkerApplicationHelper.cleanPatch(applicationLike);
-                ShareTinkerInternals.setTinkerDisableWithSharedPreferences(applicationLike.getApplication());
-                //method 2
-                //or you can mention user to uninstall Xposed!
-                Toast.makeText(applicationLike.getApplication(), "please uninstall Xposed, illegal modify the app", Toast.LENGTH_LONG).show();
+            // xposed?
+            if (isXposed) {
+                boolean isCausedByXposed = false;
+                //for art, we can't know the actually crash type
+                //just ignore art
+                if (throwable instanceof IllegalAccessError && throwable.getMessage().contains(DALVIK_XPOSED_CRASH)) {
+                    //for dalvik, we know the actual crash type
+                    isCausedByXposed = true;
+                }
+
+                if (isCausedByXposed) {
+                    SampleTinkerReport.onXposedCrash();
+                    TinkerLog.e(TAG, "have xposed: just clean tinker");
+                    //kill all other process to ensure that all process's code is the same.
+                    ShareTinkerInternals.killAllOtherProcess(applicationLike.getApplication());
+
+                    TinkerApplicationHelper.cleanPatch(applicationLike);
+                    ShareTinkerInternals.setTinkerDisableWithSharedPreferences(applicationLike.getApplication());
+                    return;
+                }
             }
+            throwable = throwable.getCause();
         }
     }
 
@@ -123,14 +130,14 @@ private boolean tinkerFastCrashProtect() {
             }
 
             SharedPreferences sp = applicationLike.getApplication().getSharedPreferences(ShareConstants.TINKER_SHARE_PREFERENCE_CONFIG, Context.MODE_MULTI_PROCESS);
-            int fastCrashCount = sp.getInt(currentVersion, 0);
+            int fastCrashCount = sp.getInt(currentVersion, 0) + 1;
             if (fastCrashCount >= MAX_CRASH_COUNT) {
                 SampleTinkerReport.onFastCrashProtect();
                 TinkerApplicationHelper.cleanPatch(applicationLike);
                 TinkerLog.e(TAG, "tinker has fast crash more than %d, we just clean patch!", fastCrashCount);
                 return true;
             } else {
-                sp.edit().putInt(currentVersion, ++fastCrashCount).commit();
+                sp.edit().putInt(currentVersion, fastCrashCount).commit();
                 TinkerLog.e(TAG, "tinker has fast crash %d times", fastCrashCount);
             }
         }
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SampleLoadReporter.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SampleLoadReporter.java
index 138f7725..05dd146e 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SampleLoadReporter.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SampleLoadReporter.java
@@ -17,55 +17,30 @@
 package tinker.sample.android.reporter;
 
 import android.content.Context;
-import android.os.Handler;
 import android.os.Looper;
 import android.os.MessageQueue;
-import android.widget.Toast;
 
 import com.tencent.tinker.lib.reporter.DefaultLoadReporter;
-import com.tencent.tinker.lib.tinker.Tinker;
-import com.tencent.tinker.lib.tinker.TinkerInstaller;
+import com.tencent.tinker.lib.util.UpgradePatchRetry;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
 
 import java.io.File;
 
-import tinker.sample.android.util.UpgradePatchRetry;
-import tinker.sample.android.util.Utils;
 
 /**
  * optional, you can just use DefaultLoadReporter
  * Created by zhangshaowen on 16/4/13.
  */
 public class SampleLoadReporter extends DefaultLoadReporter {
-    private Handler handler = new Handler();
+    private final static String TAG = "Tinker.SampleLoadReporter";
 
     public SampleLoadReporter(Context context) {
         super(context);
     }
 
     @Override
-    public void onLoadPatchListenerReceiveFail(final File patchFile, int errorCode, final boolean isUpgrade) {
-        super.onLoadPatchListenerReceiveFail(patchFile, errorCode, isUpgrade);
-        switch (errorCode) {
-            case ShareConstants.ERROR_PATCH_NOTEXIST:
-                Toast.makeText(context, "patch file is not exist", Toast.LENGTH_LONG).show();
-                break;
-            case ShareConstants.ERROR_PATCH_RUNNING:
-                // try later
-                // only retry for upgrade patch
-                if (isUpgrade) {
-                    handler.postDelayed(new Runnable() {
-                        @Override
-                        public void run() {
-                            TinkerInstaller.onReceiveUpgradePatch(context, patchFile.getAbsolutePath());
-                        }
-                    }, 60 * 1000);
-                }
-                break;
-            case Utils.ERROR_PATCH_ROM_SPACE:
-                Toast.makeText(context, "rom space is not enough", Toast.LENGTH_LONG).show();
-                break;
-        }
+    public void onLoadPatchListenerReceiveFail(final File patchFile, int errorCode) {
+        super.onLoadPatchListenerReceiveFail(patchFile, errorCode);
         SampleTinkerReport.onTryApplyFail(errorCode);
     }
 
@@ -78,12 +53,16 @@ public void onLoadResult(File patchDirectory, int loadCode, long cost) {
                 break;
         }
         Looper.getMainLooper().myQueue().addIdleHandler(new MessageQueue.IdleHandler() {
-            @Override public boolean queueIdle() {
-                UpgradePatchRetry.getInstance(context).onPatchRetryLoad();
+            @Override
+            public boolean queueIdle() {
+                if (UpgradePatchRetry.getInstance(context).onPatchRetryLoad()) {
+                    SampleTinkerReport.onReportRetryPatch();
+                }
                 return false;
             }
         });
     }
+
     @Override
     public void onLoadException(Throwable e, int errorCode) {
         super.onLoadException(e, errorCode);
@@ -96,6 +75,13 @@ public void onLoadFileMd5Mismatch(File file, int fileType) {
         SampleTinkerReport.onLoadFileMisMatch(fileType);
     }
 
+    /**
+     * try to recover patch oat file
+     *
+     * @param file
+     * @param fileType
+     * @param isDirectory
+     */
     @Override
     public void onLoadFileNotFound(File file, int fileType, boolean isDirectory) {
         super.onLoadFileNotFound(file, fileType, isDirectory);
@@ -114,6 +100,12 @@ public void onLoadPatchInfoCorrupted(String oldVersion, String newVersion, File
         SampleTinkerReport.onLoadInfoCorrupted();
     }
 
+    @Override
+    public void onLoadInterpret(int type, Throwable e) {
+        super.onLoadInterpret(type, e);
+        SampleTinkerReport.onLoadInterpretReport(type, e);
+    }
+
     @Override
     public void onLoadPatchVersionChanged(String oldVersion, String newVersion, File patchDirectoryFile, String currentPatchName) {
         super.onLoadPatchVersionChanged(oldVersion, newVersion, patchDirectoryFile, currentPatchName);
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SamplePatchListener.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SamplePatchListener.java
index 852ef447..2e863107 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SamplePatchListener.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SamplePatchListener.java
@@ -24,6 +24,7 @@
 import com.tencent.tinker.lib.tinker.Tinker;
 import com.tencent.tinker.lib.tinker.TinkerLoadResult;
 import com.tencent.tinker.lib.util.TinkerLog;
+import com.tencent.tinker.lib.util.UpgradePatchRetry;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
 import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
 import com.tencent.tinker.loader.shareutil.ShareTinkerInternals;
@@ -45,7 +46,6 @@
     private static final String TAG = "Tinker.SamplePatchListener";
 
     protected static final long NEW_PATCH_RESTRICTION_SPACE_SIZE_MIN = 60 * 1024 * 1024;
-    protected static final long OLD_PATCH_RESTRICTION_SPACE_SIZE_MIN = 30 * 1024 * 1024;
 
     private final int maxMemory;
 
@@ -64,17 +64,13 @@ public SamplePatchListener(Context context) {
      * @return
      */
     @Override
-    public int patchCheck(String path, boolean isUpgrade) {
+    public int patchCheck(String path) {
         File patchFile = new File(path);
-        TinkerLog.i(TAG, "receive a patch file: %s, isUpgrade:%b, file size:%d", path, isUpgrade, SharePatchFileUtil.getFileOrDirectorySize(patchFile));
-        int returnCode = super.patchCheck(path, isUpgrade);
+        TinkerLog.i(TAG, "receive a patch file: %s, file size:%d", path, SharePatchFileUtil.getFileOrDirectorySize(patchFile));
+        int returnCode = super.patchCheck(path);
 
         if (returnCode == ShareConstants.ERROR_PATCH_OK) {
-            if (isUpgrade) {
-                returnCode = Utils.checkForPatchRecover(NEW_PATCH_RESTRICTION_SPACE_SIZE_MIN, maxMemory);
-            } else {
-                returnCode = Utils.checkForPatchRecover(OLD_PATCH_RESTRICTION_SPACE_SIZE_MIN, maxMemory);
-            }
+            returnCode = Utils.checkForPatchRecover(NEW_PATCH_RESTRICTION_SPACE_SIZE_MIN, maxMemory);
         }
 
         if (returnCode == ShareConstants.ERROR_PATCH_OK) {
@@ -91,7 +87,7 @@ public int patchCheck(String path, boolean isUpgrade) {
 
                 if (tinker.isTinkerLoaded()) {
                     TinkerLoadResult tinkerLoadResult = tinker.getTinkerLoadResultIfPresent();
-                    if (tinkerLoadResult != null) {
+                    if (tinkerLoadResult != null && !tinkerLoadResult.useInterpretMode) {
                         String currentVersion = tinkerLoadResult.currentVersion;
                         if (patchMd5.equals(currentVersion)) {
                             returnCode = Utils.ERROR_PATCH_ALREADY_APPLY;
@@ -99,6 +95,11 @@ public int patchCheck(String path, boolean isUpgrade) {
                     }
                 }
             }
+            //check whether retry so many times
+            if (returnCode == ShareConstants.ERROR_PATCH_OK) {
+                returnCode = UpgradePatchRetry.getInstance(context).onPatchListenerCheck(patchMd5)
+                    ? ShareConstants.ERROR_PATCH_OK : Utils.ERROR_PATCH_RETRY_COUNT_LIMIT;
+            }
         }
         // Warning, it is just a sample case, you don't need to copy all of these
         // Interception some of the request
@@ -116,7 +117,7 @@ public int patchCheck(String path, boolean isUpgrade) {
             }
         }
 
-        SampleTinkerReport.onTryApply(isUpgrade, returnCode == ShareConstants.ERROR_PATCH_OK);
+        SampleTinkerReport.onTryApply(returnCode == ShareConstants.ERROR_PATCH_OK);
         return returnCode;
     }
 }
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SamplePatchReporter.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SamplePatchReporter.java
index a3566d68..9099bb4c 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SamplePatchReporter.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SamplePatchReporter.java
@@ -23,14 +23,14 @@
 import com.tencent.tinker.loader.shareutil.SharePatchInfo;
 
 import java.io.File;
-
-import tinker.sample.android.util.UpgradePatchRetry;
+import java.util.List;
 
 /**
  * optional, you can just use DefaultPatchReporter
  * Created by zhangshaowen on 16/4/8.
  */
 public class SamplePatchReporter extends DefaultPatchReporter {
+    private final static String TAG = "Tinker.SamplePatchReporter";
     public SamplePatchReporter(Context context) {
         super(context);
     }
@@ -39,49 +39,47 @@ public SamplePatchReporter(Context context) {
     public void onPatchServiceStart(Intent intent) {
         super.onPatchServiceStart(intent);
         SampleTinkerReport.onApplyPatchServiceStart();
-        UpgradePatchRetry.getInstance(context).onPatchServiceStart(intent);
     }
 
     @Override
-    public void onPatchDexOptFail(File patchFile, File dexFile, String optDirectory, String dexName, Throwable t, boolean isUpgradePatch) {
-        super.onPatchDexOptFail(patchFile, dexFile, optDirectory, dexName, t, isUpgradePatch);
+    public void onPatchDexOptFail(File patchFile, List<File> dexFiles, Throwable t) {
+        super.onPatchDexOptFail(patchFile, dexFiles, t);
         SampleTinkerReport.onApplyDexOptFail(t);
     }
 
     @Override
-    public void onPatchException(File patchFile, Throwable e, boolean isUpgradePatch) {
-        super.onPatchException(patchFile, e, isUpgradePatch);
+    public void onPatchException(File patchFile, Throwable e) {
+        super.onPatchException(patchFile, e);
         SampleTinkerReport.onApplyCrash(e);
     }
 
     @Override
-    public void onPatchInfoCorrupted(File patchFile, String oldVersion, String newVersion, boolean isUpgradePatch) {
-        super.onPatchInfoCorrupted(patchFile, oldVersion, newVersion, isUpgradePatch);
+    public void onPatchInfoCorrupted(File patchFile, String oldVersion, String newVersion) {
+        super.onPatchInfoCorrupted(patchFile, oldVersion, newVersion);
         SampleTinkerReport.onApplyInfoCorrupted();
     }
 
     @Override
-    public void onPatchPackageCheckFail(File patchFile, boolean isUpgradePatch, int errorCode) {
-        super.onPatchPackageCheckFail(patchFile, isUpgradePatch, errorCode);
+    public void onPatchPackageCheckFail(File patchFile, int errorCode) {
+        super.onPatchPackageCheckFail(patchFile, errorCode);
         SampleTinkerReport.onApplyPackageCheckFail(errorCode);
     }
 
     @Override
-    public void onPatchResult(File patchFile, boolean success, long cost, boolean isUpgradePatch) {
-        super.onPatchResult(patchFile, success, cost, isUpgradePatch);
-        SampleTinkerReport.onApplied(isUpgradePatch, cost, success);
-        UpgradePatchRetry.getInstance(context).onPatchServiceResult(isUpgradePatch);
+    public void onPatchResult(File patchFile, boolean success, long cost) {
+        super.onPatchResult(patchFile, success, cost);
+        SampleTinkerReport.onApplied(cost, success);
     }
 
     @Override
-    public void onPatchTypeExtractFail(File patchFile, File extractTo, String filename, int fileType, boolean isUpgradePatch) {
-        super.onPatchTypeExtractFail(patchFile, extractTo, filename, fileType, isUpgradePatch);
+    public void onPatchTypeExtractFail(File patchFile, File extractTo, String filename, int fileType) {
+        super.onPatchTypeExtractFail(patchFile, extractTo, filename, fileType);
         SampleTinkerReport.onApplyExtractFail(fileType);
     }
 
     @Override
-    public void onPatchVersionCheckFail(File patchFile, SharePatchInfo oldPatchInfo, String patchFileVersion, boolean isUpgradePatch) {
-        super.onPatchVersionCheckFail(patchFile, oldPatchInfo, patchFileVersion, isUpgradePatch);
+    public void onPatchVersionCheckFail(File patchFile, SharePatchInfo oldPatchInfo, String patchFileVersion) {
+        super.onPatchVersionCheckFail(patchFile, oldPatchInfo, patchFileVersion);
         SampleTinkerReport.onApplyVersionCheckFail();
     }
 }
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SampleTinkerReport.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SampleTinkerReport.java
index 9ec92dd2..d2a032ca 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SampleTinkerReport.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SampleTinkerReport.java
@@ -43,28 +43,28 @@
     public static final int KEY_APPLY_WITH_RETRY          = 10;
 
     //Key -- try apply detail
-    public static final int KEY_TRY_APPLY_REPAIR                  = 70;
-    public static final int KEY_TRY_APPLY_UPGRADE                 = 71;
-    public static final int KEY_TRY_APPLY_DISABLE                 = 72;
-    public static final int KEY_TRY_APPLY_RUNNING                 = 73;
-    public static final int KEY_TRY_APPLY_INSERVICE               = 74;
-    public static final int KEY_TRY_APPLY_NOT_EXIST               = 75;
-    public static final int KEY_TRY_APPLY_GOOGLEPLAY              = 76;
-    public static final int KEY_TRY_APPLY_ROM_SPACE               = 77;
-    public static final int KEY_TRY_APPLY_ALREADY_APPLY           = 78;
-    public static final int KEY_TRY_APPLY_MEMORY_LIMIT            = 79;
-    public static final int KEY_TRY_APPLY_CRASH_LIMIT             = 80;
-    public static final int KEY_TRY_APPLY_CONDITION_NOT_SATISFIED = 81;
+    public static final int KEY_TRY_APPLY_UPGRADE                 = 70;
+    public static final int KEY_TRY_APPLY_DISABLE                 = 71;
+    public static final int KEY_TRY_APPLY_RUNNING                 = 72;
+    public static final int KEY_TRY_APPLY_INSERVICE               = 73;
+    public static final int KEY_TRY_APPLY_NOT_EXIST               = 74;
+    public static final int KEY_TRY_APPLY_GOOGLEPLAY              = 75;
+    public static final int KEY_TRY_APPLY_ROM_SPACE               = 76;
+    public static final int KEY_TRY_APPLY_ALREADY_APPLY           = 77;
+    public static final int KEY_TRY_APPLY_MEMORY_LIMIT            = 78;
+    public static final int KEY_TRY_APPLY_CRASH_LIMIT             = 79;
+    public static final int KEY_TRY_APPLY_CONDITION_NOT_SATISFIED = 80;
+    public static final int KEY_TRY_APPLY_JIT                     = 81;
 
     //Key -- apply detail
-    public static final int KEY_APPLIED_REPAIR       = 100;
-    public static final int KEY_APPLIED_UPGRADE      = 101;
-    public static final int KEY_APPLIED_REPAIR_FAIL  = 102;
-    public static final int KEY_APPLIED_UPGRADE_FAIL = 103;
+    public static final int KEY_APPLIED_UPGRADE      = 100;
+    public static final int KEY_APPLIED_UPGRADE_FAIL = 101;
 
     public static final int KEY_APPLIED_EXCEPTION                               = 120;
-    public static final int KEY_APPLIED_DEXOPT                                  = 121;
-    public static final int KEY_APPLIED_INFO_CORRUPTED                          = 122;
+    public static final int KEY_APPLIED_DEXOPT_OTHER                            = 121;
+    public static final int KEY_APPLIED_DEXOPT_EXIST                            = 122;
+    public static final int KEY_APPLIED_DEXOPT_FORMAT                           = 123;
+    public static final int KEY_APPLIED_INFO_CORRUPTED                          = 124;
     //package check
     public static final int KEY_APPLIED_PACKAGE_CHECK_SIGNATURE                 = 150;
     public static final int KEY_APPLIED_PACKAGE_CHECK_DEX_META                  = 151;
@@ -77,22 +77,18 @@
     public static final int KEY_APPLIED_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT    = 158;
 
     //version check
-    public static final int KEY_APPLIED_VERSION_CHECK                           = 180;
+    public static final int KEY_APPLIED_VERSION_CHECK      = 180;
     //extract error
-    public static final int KEY_APPLIED_PATCH_FILE_EXTRACT                      = 181;
-    public static final int KEY_APPLIED_DEX_EXTRACT                             = 182;
-    /**
-     * for art small dex
-     */
-    public static final int KEY_APPLIED_DEX_ART_EXTRACT                         = 183;
-    public static final int KEY_APPLIED_LIB_EXTRACT                             = 184;
-    public static final int KEY_APPLIED_RESOURCE_EXTRACT                        = 185;
+    public static final int KEY_APPLIED_PATCH_FILE_EXTRACT = 181;
+    public static final int KEY_APPLIED_DEX_EXTRACT        = 182;
+    public static final int KEY_APPLIED_LIB_EXTRACT        = 183;
+    public static final int KEY_APPLIED_RESOURCE_EXTRACT   = 184;
     //cost time
-    public static final int KEY_APPLIED_SUCC_COST_5S_LESS                       = 200;
-    public static final int KEY_APPLIED_SUCC_COST_10S_LESS                      = 201;
-    public static final int KEY_APPLIED_SUCC_COST_30S_LESS                      = 202;
-    public static final int KEY_APPLIED_SUCC_COST_60S_LESS                      = 203;
-    public static final int KEY_APPLIED_SUCC_COST_OTHER                         = 204;
+    public static final int KEY_APPLIED_SUCC_COST_5S_LESS  = 200;
+    public static final int KEY_APPLIED_SUCC_COST_10S_LESS = 201;
+    public static final int KEY_APPLIED_SUCC_COST_30S_LESS = 202;
+    public static final int KEY_APPLIED_SUCC_COST_60S_LESS = 203;
+    public static final int KEY_APPLIED_SUCC_COST_OTHER    = 204;
 
     public static final int KEY_APPLIED_FAIL_COST_5S_LESS  = 205;
     public static final int KEY_APPLIED_FAIL_COST_10S_LESS = 206;
@@ -107,7 +103,7 @@
     public static final int KEY_LOADED_EXCEPTION_DEX            = 252;
     public static final int KEY_LOADED_EXCEPTION_DEX_CHECK      = 253;
     public static final int KEY_LOADED_EXCEPTION_RESOURCE       = 254;
-    public static final int KEY_LOADED_EXCEPTION_RESOURCE_CEHCK = 255;
+    public static final int KEY_LOADED_EXCEPTION_RESOURCE_CHECK = 255;
 
 
     public static final int KEY_LOADED_MISMATCH_DEX       = 300;
@@ -139,6 +135,11 @@
     public static final int KEY_LOADED_SUCC_COST_5000_LESS = 403;
     public static final int KEY_LOADED_SUCC_COST_OTHER     = 404;
 
+    public static final int KEY_LOADED_INTERPRET_GET_INSTRUCTION_SET_ERROR = 450;
+    public static final int KEY_LOADED_INTERPRET_INTERPRET_COMMAND_ERROR   = 451;
+    public static final int KEY_LOADED_INTERPRET_TYPE_INTERPRET_OK         = 452;
+
+
     interface Reporter {
         void onReport(int key);
 
@@ -151,16 +152,14 @@ public void setReporter(Reporter reporter) {
         this.reporter = reporter;
     }
 
-    public static void onTryApply(boolean upgrade, boolean success) {
+    public static void onTryApply(boolean success) {
         if (reporter == null) {
             return;
         }
         reporter.onReport(KEY_TRY_APPLY);
-        if (upgrade) {
-            reporter.onReport(KEY_TRY_APPLY_UPGRADE);
-        } else {
-            reporter.onReport(KEY_TRY_APPLY_REPAIR);
-        }
+
+        reporter.onReport(KEY_TRY_APPLY_UPGRADE);
+
         if (success) {
             reporter.onReport(KEY_TRY_APPLY_SUCCESS);
         }
@@ -183,6 +182,9 @@ public static void onTryApplyFail(int errorCode) {
             case ShareConstants.ERROR_PATCH_RUNNING:
                 reporter.onReport(KEY_TRY_APPLY_RUNNING);
                 break;
+            case ShareConstants.ERROR_PATCH_JIT:
+                reporter.onReport(KEY_TRY_APPLY_JIT);
+                break;
             case Utils.ERROR_PATCH_ROM_SPACE:
                 reporter.onReport(KEY_TRY_APPLY_ROM_SPACE);
                 break;
@@ -201,6 +203,7 @@ public static void onTryApplyFail(int errorCode) {
             case Utils.ERROR_PATCH_CONDITION_NOT_SATISFIED:
                 reporter.onReport(KEY_TRY_APPLY_CONDITION_NOT_SATISFIED);
                 break;
+
         }
     }
 
@@ -297,6 +300,25 @@ public static void onLoadFileNotFound(int fileType) {
         }
     }
 
+    public static void onLoadInterpretReport(int type, Throwable e) {
+        if (reporter == null) {
+            return;
+        }
+        switch (type) {
+            case ShareConstants.TYPE_INTERPRET_GET_INSTRUCTION_SET_ERROR:
+                reporter.onReport(KEY_LOADED_INTERPRET_GET_INSTRUCTION_SET_ERROR);
+                reporter.onReport("Tinker Exception:interpret occur exception " + Utils.getExceptionCauseString(e));
+                break;
+            case ShareConstants.TYPE_INTERPRET_COMMAND_ERROR:
+                reporter.onReport(KEY_LOADED_INTERPRET_INTERPRET_COMMAND_ERROR);
+                reporter.onReport("Tinker Exception:interpret occur exception " + Utils.getExceptionCauseString(e));
+                break;
+            case ShareConstants.TYPE_INTERPRET_OK:
+                reporter.onReport(KEY_LOADED_INTERPRET_TYPE_INTERPRET_OK);
+                break;
+        }
+    }
+
     public static void onLoadFileMisMatch(int fileType) {
         if (reporter == null) {
             return;
@@ -332,7 +354,7 @@ public static void onLoadException(Throwable throwable, int errorCode) {
                 break;
             case ShareConstants.ERROR_LOAD_EXCEPTION_RESOURCE:
                 if (throwable.getMessage().contains(ShareConstants.CHECK_RES_INSTALL_FAIL)) {
-                    reporter.onReport(KEY_LOADED_EXCEPTION_RESOURCE_CEHCK);
+                    reporter.onReport(KEY_LOADED_EXCEPTION_RESOURCE_CHECK);
                     isCheckFail = true;
                     TinkerLog.e(TAG, "tinker res check fail:" + throwable.getMessage());
                 } else {
@@ -364,8 +386,14 @@ public static void onApplyDexOptFail(Throwable throwable) {
         if (reporter == null) {
             return;
         }
-        reporter.onReport(KEY_APPLIED_DEXOPT);
-        reporter.onReport("Tinker Exception:apply tinker occur exception " + Utils.getExceptionCauseString(throwable));
+        if (throwable.getMessage().contains(ShareConstants.CHECK_DEX_OAT_EXIST_FAIL)) {
+            reporter.onReport(KEY_APPLIED_DEXOPT_EXIST);
+        } else if (throwable.getMessage().contains(ShareConstants.CHECK_DEX_OAT_FORMAT_FAIL)) {
+            reporter.onReport(KEY_APPLIED_DEXOPT_FORMAT);
+        } else {
+            reporter.onReport(KEY_APPLIED_DEXOPT_OTHER);
+            reporter.onReport("Tinker Exception:apply tinker occur exception " + Utils.getExceptionCauseString(throwable));
+        }
     }
 
     public static void onApplyInfoCorrupted() {
@@ -390,9 +418,6 @@ public static void onApplyExtractFail(int fileType) {
             case ShareConstants.TYPE_DEX:
                 reporter.onReport(KEY_APPLIED_DEX_EXTRACT);
                 break;
-            case ShareConstants.TYPE_DEX_FOR_ART:
-                reporter.onReport(KEY_APPLIED_DEX_ART_EXTRACT);
-                break;
             case ShareConstants.TYPE_LIBRARY:
                 reporter.onReport(KEY_APPLIED_LIB_EXTRACT);
                 break;
@@ -405,7 +430,7 @@ public static void onApplyExtractFail(int fileType) {
         }
     }
 
-    public static void onApplied(boolean isUpgrade, long cost, boolean success) {
+    public static void onApplied(long cost, boolean success) {
         if (reporter == null) {
             return;
         }
@@ -413,19 +438,10 @@ public static void onApplied(boolean isUpgrade, long cost, boolean success) {
             reporter.onReport(KEY_APPLIED);
         }
 
-        if (isUpgrade) {
-            if (success) {
-                reporter.onReport(KEY_APPLIED_UPGRADE);
-            } else {
-                reporter.onReport(KEY_APPLIED_UPGRADE_FAIL);
-            }
-
+        if (success) {
+            reporter.onReport(KEY_APPLIED_UPGRADE);
         } else {
-            if (success) {
-                reporter.onReport(KEY_APPLIED_REPAIR);
-            } else {
-                reporter.onReport(KEY_APPLIED_REPAIR_FAIL);
-            }
+            reporter.onReport(KEY_APPLIED_UPGRADE_FAIL);
         }
 
         TinkerLog.i(TAG, "hp_report report apply cost = %d", cost);
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/service/SampleResultService.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/service/SampleResultService.java
index d98c3a50..34550ba8 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/service/SampleResultService.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/service/SampleResultService.java
@@ -16,23 +16,16 @@
 
 package tinker.sample.android.service;
 
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.Intent;
-import android.content.IntentFilter;
 import android.os.Handler;
 import android.os.Looper;
 import android.widget.Toast;
 
 import com.tencent.tinker.lib.service.DefaultTinkerResultService;
 import com.tencent.tinker.lib.service.PatchResult;
-import com.tencent.tinker.lib.tinker.Tinker;
 import com.tencent.tinker.lib.util.TinkerLog;
 import com.tencent.tinker.lib.util.TinkerServiceInternals;
-import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
 
 import java.io.File;
-import java.util.zip.ZipFile;
 
 import tinker.sample.android.util.Utils;
 
@@ -69,12 +62,9 @@ public void run() {
         });
         // is success and newPatch, it is nice to delete the raw file, and restart at once
         // for old patch, you can't delete the patch file
-        if (result.isSuccess && result.isUpgradePatch) {
-            File rawFile = new File(result.rawPatchFilePath);
-            if (rawFile.exists()) {
-                TinkerLog.i(TAG, "save delete raw patch file");
-                SharePatchFileUtil.safeDeleteFile(rawFile);
-            }
+        if (result.isSuccess) {
+            deleteRawPatchFile(new File(result.rawPatchFilePath));
+
             //not like TinkerResultService, I want to restart just when I am at background!
             //if you have not install tinker this moment, you can use TinkerApplicationHelper api
             if (checkIfNeedKill(result)) {
@@ -85,7 +75,7 @@ public void run() {
                     //we can wait process at background, such as onAppBackground
                     //or we can restart when the screen off
                     TinkerLog.i(TAG, "tinker wait screen to restart process");
-                    new ScreenState(getApplicationContext(), new ScreenState.IOnScreenOff() {
+                    new Utils.ScreenState(getApplicationContext(), new Utils.ScreenState.IOnScreenOff() {
                         @Override
                         public void onScreenOff() {
                             restartProcess();
@@ -96,12 +86,6 @@ public void onScreenOff() {
                 TinkerLog.i(TAG, "I have already install the newly patch version!");
             }
         }
-
-        //repair current patch fail, just clean!
-        if (!result.isSuccess && !result.isUpgradePatch) {
-            //if you have not install tinker this moment, you can use TinkerApplicationHelper api
-            Tinker.with(getApplicationContext()).cleanPatch();
-        }
     }
 
     /**
@@ -113,31 +97,4 @@ private void restartProcess() {
         android.os.Process.killProcess(android.os.Process.myPid());
     }
 
-    static class ScreenState {
-        interface IOnScreenOff {
-            void onScreenOff();
-        }
-
-        ScreenState(Context context, final IOnScreenOff onScreenOffInterface) {
-            IntentFilter filter = new IntentFilter();
-            filter.addAction(Intent.ACTION_SCREEN_OFF);
-            context.registerReceiver(new BroadcastReceiver() {
-
-                @Override
-                public void onReceive(Context context, Intent in) {
-                    String action = in == null ? "" : in.getAction();
-                    TinkerLog.i(TAG, "ScreenReceiver action [%s] ", action);
-                    if (Intent.ACTION_SCREEN_OFF.equals(action)) {
-
-                        context.unregisterReceiver(this);
-
-                        if (onScreenOffInterface != null) {
-                            onScreenOffInterface.onScreenOff();
-                        }
-                    }
-                }
-            }, filter);
-        }
-    }
-
 }
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/util/TinkerManager.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/util/TinkerManager.java
index 4106eceb..e3af535f 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/util/TinkerManager.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/util/TinkerManager.java
@@ -18,12 +18,12 @@
 
 import com.tencent.tinker.lib.listener.PatchListener;
 import com.tencent.tinker.lib.patch.AbstractPatch;
-import com.tencent.tinker.lib.patch.RepairPatch;
 import com.tencent.tinker.lib.patch.UpgradePatch;
 import com.tencent.tinker.lib.reporter.LoadReporter;
 import com.tencent.tinker.lib.reporter.PatchReporter;
 import com.tencent.tinker.lib.tinker.TinkerInstaller;
 import com.tencent.tinker.lib.util.TinkerLog;
+import com.tencent.tinker.lib.util.UpgradePatchRetry;
 import com.tencent.tinker.loader.app.ApplicationLike;
 
 import tinker.sample.android.crash.SampleUncaughtExceptionHandler;
@@ -94,12 +94,10 @@ public static void installTinker(ApplicationLike appLike) {
         PatchListener patchListener = new SamplePatchListener(appLike.getApplication());
         //you can set your own upgrade patch if you need
         AbstractPatch upgradePatchProcessor = new UpgradePatch();
-        //you can set your own repair patch if you need
-        AbstractPatch repairPatchProcessor = new RepairPatch();
 
         TinkerInstaller.install(appLike,
             loadReporter, patchReporter, patchListener,
-            SampleResultService.class, upgradePatchProcessor, repairPatchProcessor);
+            SampleResultService.class, upgradePatchProcessor);
 
         isInstalled = true;
     }
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/util/Utils.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/util/Utils.java
index d6f2b993..2ae441c9 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/util/Utils.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/util/Utils.java
@@ -16,9 +16,14 @@
 
 package tinker.sample.android.util;
 
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
 import android.os.Environment;
 import android.os.StatFs;
 
+import com.tencent.tinker.lib.util.TinkerLog;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
 
 import java.io.ByteArrayOutputStream;
@@ -30,17 +35,19 @@
  * Created by zhangshaowen on 16/4/7.
  */
 public class Utils {
+    private static final String TAG = "Tinker.Utils";
 
     /**
      * the error code define by myself
      * should after {@code ShareConstants.ERROR_PATCH_INSERVICE
      */
-    public static final int ERROR_PATCH_GOOGLEPLAY_CHANNEL      = -5;
-    public static final int ERROR_PATCH_ROM_SPACE               = -6;
-    public static final int ERROR_PATCH_MEMORY_LIMIT            = -7;
-    public static final int ERROR_PATCH_ALREADY_APPLY           = -8;
+    public static final int ERROR_PATCH_GOOGLEPLAY_CHANNEL      = -6;
+    public static final int ERROR_PATCH_ROM_SPACE               = -7;
+    public static final int ERROR_PATCH_MEMORY_LIMIT            = -8;
     public static final int ERROR_PATCH_CRASH_LIMIT             = -9;
     public static final int ERROR_PATCH_CONDITION_NOT_SATISFIED = -10;
+    public static final int ERROR_PATCH_ALREADY_APPLY           = -11;
+    public static final int ERROR_PATCH_RETRY_COUNT_LIMIT       = -12;
 
     public static final String PLATFORM = "platform";
 
@@ -153,4 +160,30 @@ private static String toVisualString(String src) {
             return src;
         }
     }
+
+    public static class ScreenState {
+        public interface IOnScreenOff {
+            void onScreenOff();
+        }
+
+        public ScreenState(final Context context, final IOnScreenOff onScreenOffInterface) {
+            IntentFilter filter = new IntentFilter();
+            filter.addAction(Intent.ACTION_SCREEN_OFF);
+
+            context.registerReceiver(new BroadcastReceiver() {
+
+                @Override
+                public void onReceive(Context context, Intent in) {
+                    String action = in == null ? "" : in.getAction();
+                    TinkerLog.i(TAG, "ScreenReceiver action [%s] ", action);
+                    if (Intent.ACTION_SCREEN_OFF.equals(action)) {
+                        if (onScreenOffInterface != null) {
+                            onScreenOffInterface.onScreenOff();
+                        }
+                    }
+                    context.unregisterReceiver(this);
+                }
+            }, filter);
+        }
+    }
 }
diff --git a/tinker-sample-android/app/src/test/java/tinker/sample/android/ExampleUnitTest.java b/tinker-sample-android/app/src/test/java/tinker/sample/android/ExampleUnitTest.java
index 8bbca8ab..4f1c077c 100644
--- a/tinker-sample-android/app/src/test/java/tinker/sample/android/ExampleUnitTest.java
+++ b/tinker-sample-android/app/src/test/java/tinker/sample/android/ExampleUnitTest.java
@@ -18,7 +18,7 @@
 
 import org.junit.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
 
 /**
  * To work on unit tests, switch the Test Artifact in the Build Variants view.
diff --git a/tinker-sample-android/gradle.properties b/tinker-sample-android/gradle.properties
index eda0fddb..8d774e53 100644
--- a/tinker-sample-android/gradle.properties
+++ b/tinker-sample-android/gradle.properties
@@ -17,4 +17,4 @@
 # http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
 # org.gradle.parallel=true
 
-TINKER_VERSION=1.7.3
+TINKER_VERSION=1.7.11
