diff --git a/tinker-android/tinker-android-anno/src/main/java/com/tencent/tinker/anno/AnnotationProcessor.java b/tinker-android/tinker-android-anno/src/main/java/com/tencent/tinker/anno/AnnotationProcessor.java
index 533a1c3c..813c7467 100644
--- a/tinker-android/tinker-android-anno/src/main/java/com/tencent/tinker/anno/AnnotationProcessor.java
+++ b/tinker-android/tinker-android-anno/src/main/java/com/tencent/tinker/anno/AnnotationProcessor.java
@@ -96,7 +96,12 @@ private void processDefaultLifeCycle(Set<? extends Element> elements) {
                 .replaceAll("%TINKER_LOAD_VERIFY_FLAG%", "" + ca.loadVerifyFlag());
 
             try {
+                //processingEnv：注释处理工具框架将提供一个具有实现此接口的对象的注释 processor，因此 processor 可以使用该框架提供的设施来编写新文件、报告错误消息并查找其他实用工具。
+                //processingEnv.getFiler() 返回用来创建新源、类或辅助文件的 Filer。
+                //processingEnv.getFiler().createSourceFile(CharSequence name, Element... originatingElements)：
+                //创建一个新的源文件，并返回一个对象以允许写入它。文件的名称和路径（相对于类文件的根目录输出位置）基于将写入的类型名称
                 JavaFileObject fileObject = processingEnv.getFiler().createSourceFile(applicationPackageName + "." + applicationClassName);
+                //打印出的log为： 注: Creating file:/C:/Users/lenovo/Desktop/TinkerSourceCode/tinker/tinker_souce_android/build/generated/source/apt/debug/com/tinker/tinker_souce_android/app/SampleApplication.java
                 processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE, "Creating " + fileObject.toUri());
                 Writer writer = fileObject.openWriter();
                 try {
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerLoader.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerLoader.java
index 2c517745..c0b85083 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerLoader.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerLoader.java
@@ -72,6 +72,7 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, bo
             ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_DIRECTORY_NOT_EXIST);
             return;
         }
+        //patchDirectoryPath==== /data/data/com.tinker.tinker_souce_android/tinker
         String patchDirectoryPath = patchDirectoryFile.getAbsolutePath();
 
         //check patch directory whether exist
@@ -90,12 +91,14 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, bo
             ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_INFO_NOT_EXIST);
             return;
         }
+        //tinker/info.lock
         //old = 641e634c5b8f1649c75caf73794acbdf
         //new = 2c150d8560334966952678930ba67fa8
         File patchInfoLockFile = SharePatchFileUtil.getPatchInfoLockFile(patchDirectoryPath);
 
         patchInfo = SharePatchInfo.readAndCheckPropertyWithLock(patchInfoFile, patchInfoLockFile);
         if (patchInfo == null) {
+            Log.w(TAG, "tryLoadPatchFiles:onPatchInfoCorrupted : patchInfo == null");
             ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_INFO_CORRUPTED);
             return;
         }
@@ -126,7 +129,7 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, bo
             return;
         }
 
-        //patch-641e634c
+        //patch-2c150d85
         String patchName = SharePatchFileUtil.getPatchVersionDirectory(version);
         if (patchName == null) {
             Log.w(TAG, "tryLoadPatchFiles:patchName is null");
@@ -134,7 +137,7 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, bo
             ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_VERSION_DIRECTORY_NOT_EXIST);
             return;
         }
-        //tinker/patch.info/patch-641e634c
+        //tinker/patch-2c150d85
         String patchVersionDirectory = patchDirectoryPath + "/" + patchName;
         File patchVersionDirectoryFile = new File(patchVersionDirectory);
 
@@ -145,7 +148,7 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, bo
             return;
         }
 
-        //tinker/patch.info/patch-641e634c/patch-641e634c.apk
+        //tinker/patch-2c150d85/patch-2c150d85.apk
         File patchVersionFile = new File(patchVersionDirectoryFile.getAbsolutePath(), SharePatchFileUtil.getPatchVersionFile(version));
 
         if (!SharePatchFileUtil.isLegalFile(patchVersionFile)) {
@@ -156,7 +159,7 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, bo
         }
 
         ShareSecurityCheck securityCheck = new ShareSecurityCheck(app);
-
+        //主要是检查base和patch里面的tinkerID是否相同
         int returnCode = ShareTinkerInternals.checkTinkerPackage(app, tinkerFlag, patchVersionFile, securityCheck);
         if (returnCode != ShareConstants.ERROR_PACKAGE_CHECK_OK) {
             Log.w(TAG, "tryLoadPatchFiles:checkTinkerPackage");
@@ -170,7 +173,8 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, bo
         final boolean isEnabledForDex = ShareTinkerInternals.isTinkerEnabledForDex(tinkerFlag);
 
         if (isEnabledForDex) {
-            //tinker/patch.info/patch-641e634c/dex
+            //tinker/patch-2c150d85/dex
+            //2017/1/17 18:33 分析断点
             boolean dexCheck = TinkerDexLoader.checkComplete(patchVersionDirectory, securityCheck, resultIntent);
             if (!dexCheck) {
                 //file not found, do not load patch
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerUncaughtHandler.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerUncaughtHandler.java
index 8471914c..d2e7a2b9 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerUncaughtHandler.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerUncaughtHandler.java
@@ -62,6 +62,7 @@ public void uncaughtException(Thread thread, Throwable ex) {
                 }
                 PrintWriter pw = null;
                 try {
+                    //记录崩溃错误信息到crashFile文件中
                     pw = new PrintWriter(new FileWriter(crashFile, false));
                     pw.println("process:" + ShareTinkerInternals.getProcessName(this.context));
                     pw.println(ShareTinkerInternals.getExceptionCauseString(ex));
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/TinkerApplication.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/TinkerApplication.java
index bcdab701..f0939a51 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/TinkerApplication.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/TinkerApplication.java
@@ -72,6 +72,7 @@
 
     private ApplicationLike applicationLike = null;
 
+    //从开机到现在的毫秒数（手机睡眠(sleep)的时间也包括在内）
     private long applicationStartElapsedTime;
     private long applicationStartMillisTime;
 
@@ -99,6 +100,11 @@ protected TinkerApplication(int tinkerFlags, String delegateClassName) {
         this(tinkerFlags, delegateClassName, TinkerLoader.class.getName(), false);
     }
 
+    /**
+     * 通过反射构造ApplicationLike
+     *
+     * @return
+     */
     private ApplicationLike createDelegate() {
         try {
             // Use reflection to create the delegate so it doesn't need to go into the primary dex.
@@ -125,13 +131,18 @@ private synchronized void ensureDelegate() {
      * here since {@link android.app.Application#onCreate} will not have yet been called.
      */
     private void onBaseContextAttached(Context base) {
+        //从开机到现在的毫秒数（手机睡眠(sleep)的时间也包括在内）
         applicationStartElapsedTime = SystemClock.elapsedRealtime();
         applicationStartMillisTime = System.currentTimeMillis();
+        //加载tinker 这里时机是在重写{@link Application#attachBaseContext}中
         loadTinker();
+        //反射创建代理ApplicationLike
         ensureDelegate();
+        //在代理中执行重写Application#attachBaseContext
         applicationLike.onBaseContextAttached(base);
         //reset save mode
         if (useSafeMode) {
+            //将启动次数写入SP中 这个是第一次 为 0
             String processName = ShareTinkerInternals.getProcessName(this);
             String preferName = ShareConstants.TINKER_OWN_PREFERENCE_CONFIG + processName;
             SharedPreferences sp = getSharedPreferences(preferName, Context.MODE_PRIVATE);
@@ -142,7 +153,9 @@ private void onBaseContextAttached(Context base) {
     @Override
     protected void attachBaseContext(Context base) {
         super.attachBaseContext(base);
+        //方法设置处理程序时调用线程突然终止默认由于未捕获到异常，并没有其他的处理程序被定义为该线程
         Thread.setDefaultUncaughtExceptionHandler(new TinkerUncaughtHandler(this));
+        //主要是加载补丁和代理Like调用
         onBaseContextAttached(base);
     }
 
@@ -158,6 +171,7 @@ private void loadTinker() {
 
             Method loadMethod = tinkerLoadClass.getMethod(TINKER_LOADER_METHOD, TinkerApplication.class, int.class, boolean.class);
             Constructor<?> constructor = tinkerLoadClass.getConstructor();
+            //反射执行TinkerLoader的tryLoad(TinkerApplication app, int tinkerFlag, boolean tinkerLoadVerifyFlag)方法
             tinkerResultIntent = (Intent) loadMethod.invoke(constructor.newInstance(), this, tinkerFlags, tinkerLoadVerifyFlag);
         } catch (Throwable e) {
             //has exception, put exception error code
@@ -176,6 +190,8 @@ public void onCreate() {
     @Override
     public void onTerminate() {
         super.onTerminate();
+        //当终止应用程序对象时调用，不保证一定被调用，当程序是被内核终止以便为其他应用程序释放资源，那
+        //么将不会提醒，并且不调用应用程序的对象的onTerminate方法而直接终止进程
         if (applicationLike != null) {
             applicationLike.onTerminate();
         }
@@ -184,6 +200,8 @@ public void onTerminate() {
     @Override
     public void onLowMemory() {
         super.onLowMemory();
+        //当后台程序已经终止资源还匮乏时会调用这个方法。好的应用程序一般会在这个方法里面释放一些不必
+        //要的资源来应付当后台程序已经终止，前台应用程序内存还不够时的情况。
         if (applicationLike != null) {
             applicationLike.onLowMemory();
         }
@@ -201,6 +219,7 @@ public void onTrimMemory(int level) {
     @Override
     public void onConfigurationChanged(Configuration newConfig) {
         super.onConfigurationChanged(newConfig);
+        //配置改变时触发这个方法
         if (applicationLike != null) {
             applicationLike.onConfigurationChanged(newConfig);
         }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareFileLockHelper.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareFileLockHelper.java
index 63c266a8..8f37c12c 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareFileLockHelper.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareFileLockHelper.java
@@ -45,7 +45,9 @@ private ShareFileLockHelper(File lockFile) throws IOException {
         while (numAttempts < MAX_LOCK_ATTEMPTS) {
             numAttempts++;
             try {
+                //获取对此通道的文件的独占锁定。
                 localFileLock = outputStream.getChannel().lock();
+                //第一次进入isGetLockSuccess=true 即跳出循环 线程不sleep
                 isGetLockSuccess = (localFileLock != null);
                 if (isGetLockSuccess) {
                     break;
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchInfo.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchInfo.java
index 71a96450..6964e213 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchInfo.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchInfo.java
@@ -59,11 +59,14 @@ public static SharePatchInfo readAndCheckPropertyWithLock(File pathInfoFile, Fil
         SharePatchInfo patchInfo;
         ShareFileLockHelper fileLock = null;
         try {
+            //读取patch信息进行锁定 在读取过程中不让其他线程来读取
             fileLock = ShareFileLockHelper.getFileLock(lockFile);
+            //读取patch信息并封装在SharePatchInfo类里面
             patchInfo = readAndCheckProperty(pathInfoFile);
         } catch (Exception e) {
             throw new TinkerRuntimeException("readAndCheckPropertyWithLock fail", e);
         } finally {
+            //读取完毕解锁
             try {
                 if (fileLock != null) {
                     fileLock.close();
@@ -105,6 +108,7 @@ public static boolean rewritePatchInfoFileWithLock(File pathInfoFile, SharePatch
     }
 
     private static SharePatchInfo readAndCheckProperty(File pathInfoFile) {
+        //只是验证old以及new是否是32为的MD5字符串 如果是 就是读取patch信息成功
         boolean isReadPatchSuccessful = false;
         int numAttempts = 0;
         String oldVer = null;
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareSecurityCheck.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareSecurityCheck.java
index 921984cb..8e6b55eb 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareSecurityCheck.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareSecurityCheck.java
@@ -66,7 +66,8 @@ public ShareSecurityCheck(Context context) {
 
     /**
      * Nullable
-     *
+     *得到assets/package_meta.txt里面的信息并且封装为map
+     *这个信息对应到AS.APP项目下的build的packageConfig设置的信息
      * @return HashMap<String, String>
      */
     public HashMap<String, String> getPackagePropertiesIfPresent() {
@@ -125,7 +126,9 @@ public boolean verifyPatchMetaSignature(File path) {
                 if (!name.endsWith(ShareConstants.META_SUFFIX)) {
                     continue;
                 }
+                //将APK里面meta.txt的信息存入metaContentMap中
                 metaContentMap.put(name, SharePatchFileUtil.loadDigestes(jarFile, jarEntry));
+                //验证是否签名
                 Certificate[] certs = jarEntry.getCertificates();
                 if (certs == null) {
                     return false;
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java
index 6024ba9c..3f304e29 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java
@@ -81,6 +81,9 @@ public static boolean isNullOrNil(final String object) {
 
     /**
      * thinker package check
+     * 主要是检查base里的tinkerID是否和patch中的tinkerId相同
+     * 都满足条件 tinkerID也相同就返回ShareConstants.ERROR_PACKAGE_CHECK_OK==0
+     *
      * @param context
      * @param tinkerFlag
      * @param patchFile
@@ -96,6 +99,10 @@ public static int checkTinkerPackage(Context context, int tinkerFlag, File patch
     }
     /**
      * check patch file signature and TINKER_ID
+     * 验证签名
+     * 取出补丁里面的assets/package_meta.txt信息
+     * BaseAPP里面Manifest中的TinkerId与package_meta.txt里面的TinkerId
+     * 进行对比 只有两个ID相同才能通过
      *
      * @param context
      * @param patchFile
@@ -103,15 +110,17 @@ public static int checkTinkerPackage(Context context, int tinkerFlag, File patch
      * @return
      */
     public static int checkSignatureAndTinkerID(Context context, File patchFile, ShareSecurityCheck securityCheck) {
+        //验证meta信息以及是否签名
         if (!securityCheck.verifyPatchMetaSignature(patchFile)) {
             return ShareConstants.ERROR_PACKAGE_CHECK_SIGNATURE_FAIL;
         }
-
+        //获取Manifest中的TinkerId
         String oldTinkerId = getManifestTinkerID(context);
         if (oldTinkerId == null) {
             return ShareConstants.ERROR_PACKAGE_CHECK_APK_TINKER_ID_NOT_FOUND;
         }
-
+        //得到assets/package_meta.txt里面的信息并且封装为map
+        //这个信息对应到AS.APP项目下的build的packageConfig设置的信息
         HashMap<String, String> properties = securityCheck.getPackagePropertiesIfPresent();
 
         if (properties == null) {
@@ -130,7 +139,16 @@ public static int checkSignatureAndTinkerID(Context context, File patchFile, Sha
     }
 
 
+    /**
+     * 再次检查 各种需要支持的修复类型
+     * 是否在补丁包里拥有meta信息
+     *
+     * @param securityCheck
+     * @param tinkerFlag 需要支持的修复类型 默认全部修复 即dex so res
+     * @return
+     */
     public static int checkPackageAndTinkerFlag(ShareSecurityCheck securityCheck, int tinkerFlag) {
+        //一般默认全部修复 就不检查meta信息是否冲突了 直接返回OK
         if (isTinkerEnabledAll(tinkerFlag)) {
             return ShareConstants.ERROR_PACKAGE_CHECK_OK;
         }
