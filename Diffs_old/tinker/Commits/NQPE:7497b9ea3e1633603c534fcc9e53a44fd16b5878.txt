diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/DefaultPatchListener.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/DefaultPatchListener.java
index 52651e30..8c306bae 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/DefaultPatchListener.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/DefaultPatchListener.java
@@ -40,16 +40,17 @@ public DefaultPatchListener(Context context) {
     /**
      * when we receive a patch, what would we do?
      * you can overwrite it
-     *
+     * 真正的补丁合成全量dex方法
      * @param path
      * @return
      */
     @Override
     public int onPatchReceived(String path) {
-
+        //检查下发的补丁文件是否合法
         int returnCode = patchCheck(path);
 
         if (returnCode == ShareConstants.ERROR_PATCH_OK) {
+            //重新开启一个服务进程来合成全量dex
             TinkerPatchService.runPatchService(context, path);
         } else {
             Tinker.with(context).getLoadReporter().onLoadPatchListenerReceiveFail(new File(path), returnCode);
@@ -58,6 +59,11 @@ public int onPatchReceived(String path) {
 
     }
 
+    /**
+     * 检查下发的补丁文件是否合法
+     * @param path
+     * @return
+     */
     protected int patchCheck(String path) {
         Tinker manager = Tinker.with(context);
         //check SharePreferences also
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/PatchListener.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/PatchListener.java
index 1f18c491..0d5b9ec1 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/PatchListener.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/PatchListener.java
@@ -17,6 +17,8 @@
 package com.tencent.tinker.lib.listener;
 
 /**
+ * 这个是下发补丁后进行合成全量dex的入口
+ * 实现在DefaultPatchListener类
  * Created by zhangshaowen on 16/3/14.
  */
 public interface PatchListener {
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/AbstractPatch.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/AbstractPatch.java
index 1cbe4025..b1ce02b0 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/AbstractPatch.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/AbstractPatch.java
@@ -21,6 +21,7 @@
 import com.tencent.tinker.lib.service.PatchResult;
 
 /**
+ * 真正的实现全量合成dex功能的函数入口 实现类UpgradePatch
  * Created by zhangshaowen on 16/3/15.
  */
 public abstract class AbstractPatch {
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java
index fa72d59b..b15d90fa 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java
@@ -60,6 +60,15 @@
     private static List<File> failOptDexFile = new Vector<>();
 
 
+    /**
+     * 全量合成dex入口
+     * @param manager
+     * @param checker
+     * @param context
+     * @param patchVersionDirectory
+     * @param patchFile
+     * @return
+     */
     protected static boolean tryRecoverDexFiles(Tinker manager, ShareSecurityCheck checker, Context context,
                                                 String patchVersionDirectory, File patchFile) {
         if (!manager.isEnabledForDex()) {
@@ -74,6 +83,7 @@ protected static boolean tryRecoverDexFiles(Tinker manager, ShareSecurityCheck c
         }
 
         long begin = SystemClock.elapsedRealtime();
+        //全量合成dex入口
         boolean result = patchDexExtractViaDexDiff(context, patchVersionDirectory, dexMeta, patchFile);
         long cost = SystemClock.elapsedRealtime() - begin;
         TinkerLog.i(TAG, "recover dex result:%b, cost:%d", result, cost);
@@ -118,14 +128,24 @@ protected static boolean waitDexOptFile() {
         return true;
     }
 
+    /**
+     * 全量合成dex入口
+     * @param context
+     * @param patchVersionDirectory
+     * @param meta
+     * @param patchFile
+     * @return
+     */
     private static boolean patchDexExtractViaDexDiff(Context context, String patchVersionDirectory, String meta, final File patchFile) {
+        ///data/data/tinker.sample.android/tinker/patch-xxxxxxxx/dex/
         String dir = patchVersionDirectory + "/" + DEX_PATH + "/";
 
         if (!extractDexDiffInternals(context, dir, meta, patchFile, TYPE_DEX)) {
             TinkerLog.w(TAG, "patch recover, extractDiffInternals fail");
             return false;
         }
-
+        //调用TinkerParallelDexOptimizer.optimizeAll对生成的全量dex进行optimize操作，生成odex文件。
+        //最终合成的文件会放到/data/data/${package_name}/tinker目录下。
         final Tinker manager = Tinker.with(context);
 
         File dexFiles = new File(dir);
@@ -237,10 +257,19 @@ private static boolean checkAllDexOptFile(ArrayList<File> files, int count) {
         return true;
     }
 
+    /**
+     *
+     * @param context
+     * @param dir
+     * @param meta
+     * @param patchFile
+     * @param type
+     * @return
+     */
     private static boolean extractDexDiffInternals(Context context, String dir, String meta, File patchFile, int type) {
         //parse
         ArrayList<ShareDexDiffPatchInfo> patchList = new ArrayList<>();
-
+        //将meta封装为对象
         ShareDexDiffPatchInfo.parseDexDiffPatchInfo(meta, patchList);
 
         if (patchList.isEmpty()) {
@@ -292,7 +321,7 @@ private static boolean extractDexDiffInternals(Context context, String dir, Stri
                     manager.getPatchReporter().onPatchPackageCheckFail(patchFile, BasePatchInternal.getMetaCorruptedCode(type));
                     return false;
                 }
-
+                ///data/data/tinker.sample.android/tinker/patch-xxxxxxxx/dex/classes.dex.jar
                 File extractedFile = new File(dir + info.realName);
 
                 //check file whether already exist
@@ -309,6 +338,7 @@ private static boolean extractDexDiffInternals(Context context, String dir, Stri
                     extractedFile.getParentFile().mkdirs();
                 }
 
+                //应该是拿到补丁里面的classes.dex以及Base.APP里面的classes.dex
                 ZipEntry patchFileEntry = patch.getEntry(patchRealPath);
                 ZipEntry rawApkFileEntry = apk.getEntry(patchRealPath);
 
@@ -320,6 +350,7 @@ private static boolean extractDexDiffInternals(Context context, String dir, Stri
                     }
 
                     //it is a new file, but maybe we need to repack the dex file
+                    //将补丁包中的name.dex复制进extractedFile中
                     if (!extractDexFile(patch, patchFileEntry, extractedFile, info)) {
                         TinkerLog.w(TAG, "Failed to extract raw patch file " + extractedFile.getPath());
                         manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type);
@@ -345,6 +376,7 @@ private static boolean extractDexDiffInternals(Context context, String dir, Stri
                         return false;
                     }
 
+                    //增量生成dex策略被否定了 这里采用全量的方式
                     // Small patched dex generating strategy was disabled, we copy full original dex directly now.
                     //patchDexFile(apk, patch, rawApkFileEntry, null, info, smallPatchInfoFile, extractedFile);
                     extractDexFile(apk, rawApkFileEntry, extractedFile, info);
@@ -380,7 +412,7 @@ private static boolean extractDexDiffInternals(Context context, String dir, Stri
                         manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type);
                         return false;
                     }
-
+                    //开始合成全量dex
                     patchDexFile(apk, patch, rawApkFileEntry, patchFileEntry, info, extractedFile);
 
                     if (!SharePatchFileUtil.verifyDexFileMd5(extractedFile, extractedFileMd5)) {
@@ -405,6 +437,7 @@ private static boolean extractDexDiffInternals(Context context, String dir, Stri
 
     /**
      * repack dex to jar
+     * 将zipFile中的entryFile复制进extractTo
      *
      * @param zipFile
      * @param entryFile
@@ -416,7 +449,7 @@ private static boolean extractDexDiffInternals(Context context, String dir, Stri
     private static boolean extractDexToJar(ZipFile zipFile, ZipEntry entryFile, File extractTo, String targetMd5) throws IOException {
         int numAttempts = 0;
         boolean isExtractionSuccessful = false;
-        while (numAttempts < MAX_EXTRACT_ATTEMPTS && !isExtractionSuccessful) {
+        while (numAttempts < MAX_EXTRACT_ATTEMPTS && !isExtractionSuccessful) {//两次重试机会
             numAttempts++;
 
             FileOutputStream fos = new FileOutputStream(extractTo);
@@ -468,6 +501,15 @@ private static boolean extractDexToJar(ZipFile zipFile, ZipEntry entryFile, File
 //        }
 //    }
 
+    /**
+     * 将zipFile中的entryFile复制进extractTo
+     * @param zipFile
+     * @param entryFile
+     * @param extractTo
+     * @param dexInfo
+     * @return
+     * @throws IOException
+     */
     private static boolean extractDexFile(ZipFile zipFile, ZipEntry entryFile, File extractTo, ShareDexDiffPatchInfo dexInfo) throws IOException {
         final String fileMd5 = ShareTinkerInternals.isVmArt() ? dexInfo.destMd5InArt : dexInfo.destMd5InDvm;
         final String rawName = dexInfo.rawName;
@@ -480,6 +522,7 @@ private static boolean extractDexFile(ZipFile zipFile, ZipEntry entryFile, File
     }
 
     /**
+     * 将补丁中dex和apk中dex进行对比 然后生成新的全量dex 放入patchedDexFile中
      * Generate patched dex file (May wrapped it by a jar if needed.)
      * @param baseApk
      *   OldApk.
@@ -525,11 +568,13 @@ private static void patchDexFile(
                             if (entry == null) {
                                 throw new TinkerRuntimeException("can't recognize zip dex format file:" + patchedDexFile.getAbsolutePath());
                             }
+                            //具体实现
                             new DexPatchApplier(zis, patchFileStream).executeAndSaveTo(zos);
                         } finally {
                             SharePatchFileUtil.closeQuietly(zis);
                         }
                     } else {
+                        //具体实现
                         new DexPatchApplier(oldDexStream, patchFileStream).executeAndSaveTo(zos);
                     }
                     zos.closeEntry();
@@ -537,6 +582,7 @@ private static void patchDexFile(
                     SharePatchFileUtil.closeQuietly(zos);
                 }
             } else {
+                //具体实现
                 new DexPatchApplier(oldDexStream, patchFileStream).executeAndSaveTo(patchedDexFile);
             }
         } finally {
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/UpgradePatch.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/UpgradePatch.java
index 72257dac..0e7d19be 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/UpgradePatch.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/UpgradePatch.java
@@ -87,7 +87,7 @@ public boolean tryPatch(Context context, String tempPatchPath, PatchResult patch
             }
 
             if (!SharePatchFileUtil.checkIfMd5Valid(patchMd5)) {
-                TinkerLog.e(TAG, "UpgradePatch tryPatch:onPatchVersionCheckFail md5 %s is valid", patchMd5);
+                TinkerLog.e(TAG, "UpgradePatch tryPatch:onPatchVersionCheckFail md5 %s is invalid", patchMd5);
                 manager.getPatchReporter().onPatchVersionCheckFail(patchFile, oldInfo, patchMd5);
                 return false;
             }
@@ -111,12 +111,13 @@ public boolean tryPatch(Context context, String tempPatchPath, PatchResult patch
         //don't delete dir for faster retry
 //        SharePatchFileUtil.deleteDir(patchVersionDirectory);
 
-        //copy file
+        //copy file /data/data/tinker.sample.android/tinker/patch-xxxxxxxx/patch-xxxxxxxx.apk
         File destPatchFile = new File(patchVersionDirectory + "/" + SharePatchFileUtil.getPatchVersionFile(patchMd5));
 
         try {
             // check md5 first
             if (!patchMd5.equals(SharePatchFileUtil.getMD5(destPatchFile))) {
+                //将外部的下发补丁包 copy进内部存储文件夹内
                 SharePatchFileUtil.copyFileUsingStream(patchFile, destPatchFile);
                 TinkerLog.w(TAG, "UpgradePatch copy patch file, src file: %s size: %d, dest file: %s size:%d", patchFile.getAbsolutePath(), patchFile.length(),
                     destPatchFile.getAbsolutePath(), destPatchFile.length());
@@ -128,6 +129,7 @@ public boolean tryPatch(Context context, String tempPatchPath, PatchResult patch
             return false;
         }
 
+        //开始真正的合成全量dex
         //we use destPatchFile instead of patchFile, because patchFile may be deleted during the patch process
         if (!DexDiffPatchInternal.tryRecoverDexFiles(manager, signatureCheck, context, patchVersionDirectory, destPatchFile)) {
             TinkerLog.e(TAG, "UpgradePatch tryPatch:new patch recover, try patch dex failed");
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/LoadReporter.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/LoadReporter.java
index 6ff69254..6842e4da 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/LoadReporter.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/LoadReporter.java
@@ -21,6 +21,9 @@
 import java.io.File;
 
 /**
+ * 这个接口主要做的事情为监听补丁的加载情况 具体实现在DefaultLoadReporter类
+ * 即 打开APP后 开始  查找合成之后全量补丁包->检查补丁合法性->安装补丁到classloader的pathlist的dex前置->加载结束 的过程
+ * 此接口不负责监听下发补丁的全量dex合成过程
  * Created by zhangshaowen on 16/3/10.
  */
 public interface LoadReporter {
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/PatchReporter.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/PatchReporter.java
index 7ba65da4..407667f4 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/PatchReporter.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/PatchReporter.java
@@ -27,7 +27,7 @@
 
 /**
  * Created by zhangshaowen on 16/3/14.
- *
+ * 补丁合成全量dex过程的监听接口 实现类在DefaultPatchReporter
  * means that it is a newly patch, we would default use {@link UpgradePatch}
  * to do the job
  */
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/TinkerPatchService.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/TinkerPatchService.java
index db7d4526..637d3542 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/TinkerPatchService.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/TinkerPatchService.java
@@ -35,6 +35,9 @@
 import java.io.File;
 
 /**
+ * 真正的补丁合成全量dex的服务
+ * 它的manifest注册在com.tencent.tinker.lib包下的AndroidManifest里面
+ * 最后会和APP的AndroidManifest合成最终的AndroidManifest
  * Created by zhangshaowen on 16/3/14.
  */
 public class TinkerPatchService extends IntentService {
@@ -49,6 +52,16 @@
 
     /**
      * Creates an IntentService.  Invoked by your subclass's constructor.
+     *
+     * Android中的Service是用于后台服务的，当应用程序被挂到后台的时候，
+     * 问了保证应用某些组件仍然可以工作而引入了Service这个概念，
+     * 那么这里面要强调的是Service不是独立的进程，也不是独立的线程，它
+     * 是依赖于应用程序的主线程的，也就是说，在更多时候不建议在Service中编写耗时的逻辑和操作，否则会引起ANR。
+
+     那么我们当我们编写的耗时逻辑，不得不被service来管理的时候，
+     就需要引入IntentService，IntentService是继承Service的，那么它包含了Service的全部特性，
+     当然也包含service的生命周期，那么与service不同的是，IntentService在执行onCreate操作的时候，
+     内部开了一个线程，去你执行你的耗时操作。
      */
     public TinkerPatchService() {
         super(TinkerPatchService.class.getSimpleName());
@@ -102,6 +115,7 @@ public static void setTinkerNotificationId(int id) {
     protected void onHandleIntent(Intent intent) {
         final Context context = getApplicationContext();
         Tinker tinker = Tinker.with(context);
+        //开始合成全量dex服务的监听回调
         tinker.getPatchReporter().onPatchServiceStart(intent);
 
         if (intent == null) {
@@ -119,13 +133,14 @@ protected void onHandleIntent(Intent intent) {
         boolean result;
         long cost;
         Throwable e = null;
-
+        //增加服务优先级 避免被kill
         increasingPriority();
         PatchResult patchResult = new PatchResult();
         try {
             if (upgradePatchProcessor == null) {
                 throw new TinkerRuntimeException("upgradePatchProcessor is null.");
             }
+            //原来这里面才是真正的合成全量dex的功能函数
             result = upgradePatchProcessor.tryPatch(context, path, patchResult);
         } catch (Throwable throwable) {
             e = throwable;
@@ -141,11 +156,14 @@ protected void onHandleIntent(Intent intent) {
         patchResult.rawPatchFilePath = path;
         patchResult.costTime = cost;
         patchResult.e = e;
-
+        //从合成全量dex完成后 启动通知合成结果的服务
         AbstractResultService.runResultService(context, patchResult, getPatchResultExtra(intent));
 
     }
 
+    /**
+     * 增加合成全量dex服务的优先级 避免被系统杀死
+     */
     private void increasingPriority() {
 //        if (Build.VERSION.SDK_INT > 24) {
 //            TinkerLog.i(TAG, "for Android 7.1, we just ignore increasingPriority job");
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerLoadResult.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerLoadResult.java
index 3b5b06f2..62daa393 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerLoadResult.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerLoadResult.java
@@ -68,6 +68,14 @@
 
     public long costTime;
 
+    /**
+     * 解析intentResult
+     * 处理loadCode的各种情况
+     * 并且将各种情况发送给tinker.getLoadReporter()的监听接口
+     * @param context
+     * @param intentResult
+     * @return
+     */
     public boolean parseTinkerResult(Context context, Intent intentResult) {
         Tinker tinker = Tinker.with(context);
         loadCode = ShareIntentUtil.getIntentReturnCode(intentResult);
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/TinkerServiceInternals.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/TinkerServiceInternals.java
index 0db959ee..bc3f7a49 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/TinkerServiceInternals.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/TinkerServiceInternals.java
@@ -122,9 +122,34 @@ public static boolean isInTinkerPatchServiceProcess(Context context) {
         return process.equals(service);
     }
 
+    /**
+     * PackageItemInfo类
+     说明： AndroidManifest.xml文件中所有节点的基类，提供了这些节点的基本信息：a label、icon、 meta-data。它并不
+     直接使用，而是由子类继承然后调用相应方法。
+     常用字段：
+     public int icon           获得该资源图片在R文件中的值 (对应于android:icon属性)
+     public int labelRes     获得该label在R文件中的值(对应于android:label属性)
+     public String name   获得该节点的name值 (对应于android:name属性)
+     public String packagename   获得该应用程序的包名 (对应于android：packagename属性)
+     常用方法：
+     Drawable  loadIcon(PackageManager pm)               获得当前应用程序的图像
+     CharSequence  loadLabel(PackageManager pm)     获得当前应用程序的label
+
+     ActivityInfo类  继承自 PackageItemInfo
+     说明： 获得应用程序中<activity/>或者 <receiver />节点的信息 。我们可以通过它来获取我们设置的任何属性，包括
+     theme 、launchMode、launchmode等
+     常用方法继承至PackageItemInfo类中的loadIcon()和loadLabel()
+
+     ServiceInfo 类
+     说明： 同ActivityInfo类似 ，同样继承自 PackageItemInfo，只不过它表示的是<service>节点信息。
+     * @param context
+     * @param serviceClass
+     * @return
+     */
     private static String getServiceProcessName(Context context, Class<? extends Service> serviceClass) {
         PackageManager packageManager = context.getPackageManager();
 
+        //ComponentName（组件名称）是用来打开其他应用程序中的Activity或服务的
         ComponentName component = new ComponentName(context, serviceClass);
         ServiceInfo serviceInfo;
         try {
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/DexPatchApplier.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/DexPatchApplier.java
index 1d9f7fef..69e5ce55 100644
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/DexPatchApplier.java
+++ b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/DexPatchApplier.java
@@ -108,6 +108,7 @@ public DexPatchApplier(
     public void executeAndSaveTo(OutputStream out) throws IOException {
         // Before executing, we should check if this patch can be applied to
         // old dex we passed in.
+        // 首先old apk的签名和patchfile所携带的old apk签名是否一致，不一致则抛出异常
         byte[] oldDexSign = this.oldDex.computeSignature(false);
         if (oldDexSign == null) {
             throw new IOException("failed to compute old dex's signature.");
@@ -128,6 +129,7 @@ public void executeAndSaveTo(OutputStream out) throws IOException {
 
         // Firstly, set sections' offset after patched, sort according to their offset so that
         // the dex lib of aosp can calculate section size.
+        // patchedDex是最终合成的dex，首先设定各个区域的偏移量
         TableOfContents patchedToc = this.patchedDex.getTableOfContents();
 
         patchedToc.header.off = 0;
@@ -176,6 +178,7 @@ public void executeAndSaveTo(OutputStream out) throws IOException {
         patchedToc.computeSizesFromOffsets();
 
         // Secondly, run patch algorithms according to sections' dependencies.
+        // 对每个区域进行patch操作
         this.stringDataSectionPatchAlg = new StringDataSectionPatchAlgorithm(
                 patchFile, oldDex, patchedDex, oldToPatchedIndexMap
         );
