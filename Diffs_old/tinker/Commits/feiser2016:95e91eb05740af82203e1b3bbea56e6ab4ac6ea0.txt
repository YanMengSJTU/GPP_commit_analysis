diff --git a/README.md b/README.md
index c8672ae3..ceec807a 100644
--- a/README.md
+++ b/README.md
@@ -1,12 +1,12 @@
 ## Tinker
 [![license](http://img.shields.io/badge/license-BSD3-brightgreen.svg?style=flat)](https://github.com/Tencent/tinker/blob/master/LICENSE)
-[![Release Version](https://img.shields.io/badge/release-1.9.9-red.svg)](https://github.com/Tencent/tinker/releases)
+[![Release Version](https://img.shields.io/badge/release-1.9.14-red.svg)](https://github.com/Tencent/tinker/releases)
 [![PRs Welcome](https://img.shields.io/badge/PRs-welcome-brightgreen.svg)](https://github.com/Tencent/tinker/pulls)
-[![WeChat Approved](https://img.shields.io/badge/Wechat_Approved-1.9.9-red.svg)](https://github.com/Tencent/tinker/wiki)
+[![WeChat Approved](https://img.shields.io/badge/Wechat_Approved-1.9.14-red.svg)](https://github.com/Tencent/tinker/wiki)
 
 Tinker is a hot-fix solution library for Android, it supports dex, library and resources update without reinstalling apk.
 
-![tinker.png](assets/tinker.png) 
+![tinker.png](assets/tinker.png)
 
 ## Getting started
 Add tinker-gradle-plugin as a dependency in your main `build.gradle` in the root of your project:
@@ -23,7 +23,7 @@ Then you need to "apply" the plugin and add dependencies by adding the following
 
 ```gradle
 dependencies {
-    //optional, help to generate the final application 
+    //optional, help to generate the final application
     provided('com.tencent.tinker:tinker-android-anno:1.9.1')
     //tinker's main Android lib
     compile('com.tencent.tinker:tinker-android-lib:1.9.1')
@@ -50,9 +50,9 @@ public class SampleApplication extends TinkerApplication {
         //dex only, library only, all support
         ShareConstants.TINKER_ENABLE_ALL,
         // This is passed as a string so the shell application does not
-        // have a binary dependency on your ApplicationLifeCycle class. 
+        // have a binary dependency on your ApplicationLifeCycle class.
         "tinker.sample.android.app.SampleApplicationLike");
-    }  
+    }
 }
 ```
 
@@ -62,7 +62,7 @@ Use `tinker-android-anno` to generate your `Application` is recommended, you jus
 @DefaultLifeCycle(
 application = "tinker.sample.android.app.SampleApplication",             //application name to generate
 flags = ShareConstants.TINKER_ENABLE_ALL)                                //tinkerFlags above
-public class SampleApplicationLike extends DefaultApplicationLike 
+public class SampleApplicationLike extends DefaultApplicationLike
 ```
 
 How to install tinker? learn more at the sample [SampleApplicationLike](https://github.com/Tencent/tinker/blob/master/tinker-sample-android/app/src/main/java/tinker/sample/android/app/SampleApplicationLike.java).
@@ -71,6 +71,29 @@ For proguard, we have already made the proguard config automatic, and tinker wil
 
 For more tinker configurations, learn more at the sample [app/build.gradle](https://github.com/Tencent/tinker/blob/master/tinker-sample-android/app/build.gradle).
 
+## Ark Support
+How to run tinker on the Ark?
+For gradle, add the following lines to your `app/build.gradle`. Otherwise, the default configure will be used.
+```gradle
+ark {
+   path = "xxx"                                        // path of patch
+   name = "xxx.apk"                                    // name of patch
+}
+```
+For tinker-cli, add the following lines to your `tinker_config.xml`. Otherwise, the default configure will be used.
+```xml
+<issue id="ark">
+   <path value="xxx"/>
+   <name value="xxx.apk"/>
+</issue>
+```
+The patch is built by Ark SDK and placed on the above path. Other operations are the same as before.
+
+How to make dex diff for Ark? Just use the following command:
+```buildconfig
+bash build_patch_dexdiff.sh old=xxx new=xxx
+```
+The path of old and new  must be absolute
 ## Known Issues
 There are some issues which Tinker can't dynamic update.
 
diff --git a/build.gradle b/build.gradle
index 4a70a310..5f40b5d9 100644
--- a/build.gradle
+++ b/build.gradle
@@ -10,6 +10,7 @@ buildscript {
         classpath 'com.android.tools.build:gradle:3.2.1'
         classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.6'
         classpath "com.github.dcendents:android-maven-gradle-plugin:2.1"
+        classpath "com.github.jengelman.gradle.plugins:shadow:4.0.4"
     }
 }
 
@@ -56,3 +57,5 @@ ext {
     BINTRAY_ORGANIZATION = "tinker"
 
 }
+
+apply from: rootProject.file('gradle/check.gradle')
\ No newline at end of file
diff --git a/checkstyle.xml b/checkstyle.xml
index a1436343..c34659dd 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -1,156 +1,392 @@
 <?xml version="1.0"?>
-<!--
-  Copyright (C) 2016 THL A29 Limited, a Tencent company.
-  Copyright (C) 2014 Square, Inc.
-
-  Licensed under the Apache License, Version 2.0 (the "License");
-  you may not use this file except in compliance with the License.
-  You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-  Unless required by applicable law or agreed to in writing, software
-  distributed under the License is distributed on an "AS IS" BASIS,
-  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  See the License for the specific language governing permissions and
-  limitations under the License.
-  -->
 <!DOCTYPE module PUBLIC
-    "-//Puppy Crawl//DTD Check Configuration 1.2//EN"
-    "http://www.puppycrawl.com/dtds/configuration_1_2.dtd">
-
-<module name="Checker">
-  <!--module name="NewlineAtEndOfFile"/-->
-  <module name="FileLength"/>
-  <module name="FileTabCharacter"/>
-  <module name="SuppressWarningsFilter"/>
-
-  <!-- Trailing spaces -->
-  <module name="RegexpSingleline">
-    <property name="format" value="\s+$"/>
-    <property name="message" value="Line has trailing spaces."/>
-  </module>
-
-  <!-- Space after 'for' and 'if' -->
-  <module name="RegexpSingleline">
-    <property name="format" value="^\s*(for|if)[^ ]\("/>
-    <property name="message" value="Space needed before opening parenthesis."/>
-  </module>
-
-  <!-- For each spacing -->
-  <module name="RegexpSingleline">
-    <property name="format" value="^\s*for \(.*?([^ ]:|:[^ ])"/>
-    <property name="message" value="Space needed around ':' character."/>
-  </module>
-
-  <module name="TreeWalker">
-    <!-- Checks for Javadoc comments.                     -->
-    <!-- See http://checkstyle.sf.net/config_javadoc.html -->
-    <!--module name="JavadocMethod"/-->
-    <!--module name="JavadocType"/-->
-    <!--module name="JavadocVariable"/-->
-    <!--module name="JavadocStyle"/-->
+    "-//Puppy Crawl//DTD Check Configuration 1.3//EN"
+    "http://checkstyle.sourceforge.net/dtds/configuration_1_3.dtd">
 
+<!--
+    Checkstyle configuration that checks the Google coding conventions from Google Java Style
+    that can be found at https://google.github.io/styleguide/javaguide.html.
+    Checkstyle is very configurable. Be sure to read the documentation at
+    http://checkstyle.sf.net (or in your downloaded distribution).
+    To completely disable a check, just comment it out or delete it from the file.
+    Authors: Max Vetrenko, Ruslan Diachenko, Roman Ivanov.
+    References:
+    'https://source.android.com/setup/contribute/code-style'
+    'https://google.github.io/styleguide/javaguide.html'
+    'https://github.com/checkstyle/checkstyle/tree/master/src/main/resources'
+ -->
 
-    <!-- Checks for Naming Conventions.                  -->
-    <!-- See http://checkstyle.sf.net/config_naming.html -->
-    <!--<module name="ConstantName"/>-->
-    <module name="LocalFinalVariableName"/>
-    <module name="LocalVariableName"/>
-    <module name="MemberName"/>
-    <module name="MethodName">
-      <property name="format" value="^[a-z][a-zA-Z0-9_]*$"/>
-    </module>
-    <module name="PackageName"/>
-    <module name="ParameterName"/>
-    <module name="StaticVariableName"/>
-    <module name="TypeName">
-      <property name="format" value="^[A-Z][a-zA-Z0-9_]*$"/>
+<module name="Checker">
+    <module name="SuppressionFilter">
+        <property name="file" default="suppressions.xml" value="${checkstyleSuppressionsPath}"/>
     </module>
-
-
-    <!-- Checks for imports                              -->
-    <!-- See http://checkstyle.sf.net/config_import.html -->
-    <module name="AvoidStarImport"/>
-    <module name="IllegalImport"/>
-    <module name="RedundantImport"/>
-    <module name="UnusedImports"/>
-
-
-    <!-- Checks for Size Violations.                    -->
-    <!-- See http://checkstyle.sf.net/config_sizes.html -->
-    <!--module name="LineLength"-->
-      <!--property name="max" value="100"/-->
-    <!--/module-->
-    <!--module name="MethodLength"/-->
-    <!--<module name="ParameterNumber"/>-->
-
+    <property name="charset" value="UTF-8"/>
+    <property name="severity" value="warning"/>
+    <!--<property name="localeLanguage" value="en"/>-->
+    <property name="fileExtensions" value="java"/>
     <!-- Checks for whitespace                               -->
     <!-- See http://checkstyle.sf.net/config_whitespace.html -->
-    <module name="GenericWhitespace"/>
-    <module name="EmptyForIteratorPad"/>
-    <module name="MethodParamPad"/>
+    <module name="FileTabCharacter">
+        <property name="eachLine" value="true"/>
+    </module>
+    <module name="NewlineAtEndOfFile">
+        <property name="severity" value="info"/>
+    </module>
+    <module name="FileLength">
+        <property name="severity" value="info"/>
+        <property name="max" value="1500"/>
+    </module>
 
+    <module name="TreeWalker">
+        <!-- 1. Source File Basic-->
+        <module name="OuterTypeFilename"/>
+        <module name="IllegalTokenText">
+            <property name="tokens" value="STRING_LITERAL, CHAR_LITERAL"/>
+            <property name="format"
+                      value="\\u00(09|0(a|A)|0(c|C)|0(d|D)|22|27|5(C|c))|\\(0(10|11|12|14|15|42|47)|134)"/>
+            <property name="message"
+                      value="Consider using special escape sequence instead of octal value or Unicode escaped value."/>
+        </module>
+        <module name="AvoidEscapedUnicodeCharacters">
+            <property name="allowEscapesForControlCharacters" value="true"/>
+            <property name="allowByTailComment" value="true"/>
+            <property name="allowNonPrintableEscapes" value="true"/>
+        </module>
 
-    <module name="NoWhitespaceAfter"/>
-    <module name="NoWhitespaceBefore"/>
-    <module name="OperatorWrap"/>
-    <module name="ParenPad"/>
-    <module name="TypecastParenPad"/>
-    <module name="WhitespaceAfter"/>
-    <module name="WhitespaceAround"/>
 
+        <!-- 2. Source File Structure -->
+        <module name="AvoidStarImport">
+            <property name="excludes"
+                      value="java.io,java.net,java.lang.Math,org.junit,org.junit.Assert"/>
+        </module>
+        <module name="IllegalImport"/>
+        <module name="RedundantImport"/>
+        <module name="UnusedImports"/>
+        <module name="OneTopLevelClass"/>
+        <module name="OverloadMethodsDeclarationOrder">
+            <property name="severity" value="ignore"/>
+        </module>
 
-    <!-- Modifier Checks                                    -->
-    <!-- See http://checkstyle.sf.net/config_modifiers.html -->
-    <!--module name="ModifierOrder"/-->
-    <module name="RedundantModifier"/>
 
+        <!-- 3. Formatting -->
+        <module name="LineLength">
+            <property name="severity" value="ignore"/>
+            <property name="max" value="200"/>
+            <property name="ignorePattern"
+                      value="^package.*|^import.*|a href|href|http://|https://|ftp://|^\{.*\}"/>
+        </module>
+        <module name="MethodLength">
+            <property name="max" value="300"/>
+        </module>
+        <module name="ParameterNumber">
+            <property name="severity" value="ignore"/>
+        </module>
+        <module name="NoLineWrap"/>
+        <module name="EmptyBlock">
+            <property name="option" value="TEXT"/>
+            <property name="tokens"
+                      value="LITERAL_TRY, LITERAL_FINALLY, LITERAL_IF, LITERAL_ELSE, LITERAL_SWITCH"/>
+        </module>
+        <module name="NeedBraces">
+            <property name="allowSingleLineStatement" value="true"/>
+        </module>
+        <module name="LeftCurly"/>
+        <module name="RightCurly">
+            <property name="id" value="RightCurlySame"/>
+            <property name="tokens"
+                      value="LITERAL_TRY, LITERAL_CATCH, LITERAL_FINALLY, LITERAL_IF, LITERAL_ELSE, LITERAL_DO"/>
+        </module>
+        <module name="RightCurly">
+            <property name="id" value="RightCurlyAlone"/>
+            <property name="option" value="alone"/>
+            <property name="tokens"
+                      value="CLASS_DEF, METHOD_DEF, CTOR_DEF, LITERAL_FOR, LITERAL_WHILE, STATIC_INIT, INSTANCE_INIT"/>
+        </module>
+        <module name="WhitespaceAfter"/>
+        <module name="WhitespaceAround">
+            <property name="allowEmptyConstructors" value="true"/>
+            <property name="allowEmptyLambdas" value="true"/>
+            <property name="allowEmptyMethods" value="true"/>
+            <property name="allowEmptyTypes" value="true"/>
+            <property name="allowEmptyLoops" value="true"/>
+            <message key="ws.notFollowed"
+                     value="WhitespaceAround: ''{0}'' is not followed by whitespace. Empty blocks may only be represented as '{}' when not part of a multi-block statement (4.1.3)"/>
+            <message key="ws.notPreceded"
+                     value="WhitespaceAround: ''{0}'' is not preceded with whitespace."/>
+        </module>
+        <module name="OneStatementPerLine">
+            <property name="severity" value="info"/>
+        </module>
+        <module name="MultipleVariableDeclarations">
+            <property name="severity" value="ignore"/>
+        </module>
+        <module name="ArrayTypeStyle"/>
+        <module name="ModifierOrder">
+            <property name="severity" value="ignore"/>
+        </module>
+        <module name="RedundantModifier">
+            <property name="severity" value="ignore"/>
+        </module>
+        <module name="EmptyLineSeparator">
+            <property name="severity" value="ignore"/>
+            <property name="allowNoEmptyLineBetweenFields" value="true"/>
+        </module>
+        <module name="SeparatorWrap">
+            <property name="id" value="SeparatorWrapDot"/>
+            <property name="tokens" value="DOT"/>
+            <property name="option" value="nl"/>
+        </module>
+        <module name="SeparatorWrap">
+            <property name="id" value="SeparatorWrapComma"/>
+            <property name="tokens" value="COMMA"/>
+            <property name="option" value="EOL"/>
+        </module>
+        <module name="SeparatorWrap">
+            <!-- ELLIPSIS is EOL until https://github.com/google/styleguide/issues/258 -->
+            <property name="id" value="SeparatorWrapEllipsis"/>
+            <property name="tokens" value="ELLIPSIS"/>
+            <property name="option" value="EOL"/>
+        </module>
+        <module name="SeparatorWrap">
+            <!-- ARRAY_DECLARATOR is EOL until https://github.com/google/styleguide/issues/259 -->
+            <property name="id" value="SeparatorWrapArrayDeclarator"/>
+            <property name="tokens" value="ARRAY_DECLARATOR"/>
+            <property name="option" value="EOL"/>
+        </module>
+        <module name="SeparatorWrap">
+            <property name="id" value="SeparatorWrapMethodRef"/>
+            <property name="tokens" value="METHOD_REF"/>
+            <property name="option" value="nl"/>
+        </module>
+        <module name="GenericWhitespace">
+            <message key="ws.followed"
+                     value="GenericWhitespace ''{0}'' is followed by whitespace."/>
+            <message key="ws.preceded"
+                     value="GenericWhitespace ''{0}'' is preceded with whitespace."/>
+            <message key="ws.illegalFollow"
+                     value="GenericWhitespace ''{0}'' should followed by whitespace."/>
+            <message key="ws.notPreceded"
+                     value="GenericWhitespace ''{0}'' is not preceded with whitespace."/>
+        </module>
+        <module name="Indentation">
+            <property name="severity" value="ignore"/>
+            <property name="basicOffset" value="4"/>
+            <property name="lineWrappingIndentation" value="8"/>
+        </module>
+        <module name="AbbreviationAsWordInName">
+            <property name="severity" value="ignore"/>
+        </module>
+        <module name="VariableDeclarationUsageDistance">
+            <property name="severity" value="ignore"/>
+            <property name="allowedDistance" value="4"/>
+        </module>
+        <module name="EmptyForIteratorPad"/>
+        <module name="MethodParamPad"/>
+        <module name="NoWhitespaceBefore">
+            <property name="tokens"
+                      value="COMMA, SEMI, POST_INC, POST_DEC, DOT, ELLIPSIS, METHOD_REF"/>
+            <property name="allowLineBreaks" value="true"/>
+        </module>
+        <module name="NoWhitespaceAfter"/>
+        <module name="ParenPad"/>
+        <module name="OperatorWrap">
+            <property name="option" value="NL"/>
+            <property name="tokens"
+                      value="BAND, BOR, BSR, BXOR, DIV, EQUAL, GE, GT, LAND, LE, LITERAL_INSTANCEOF, LOR, LT, MINUS, MOD, NOT_EQUAL, QUESTION, SL, SR, STAR, METHOD_REF "/>
+        </module>
+        <module name="CommentsIndentation">
+            <property name="severity" value="info"/>
+        </module>
+        <module name="AnnotationLocation">
+            <property name="id" value="AnnotationLocationMostCases"/>
+            <property name="tokens"
+                      value="CLASS_DEF, INTERFACE_DEF, ENUM_DEF, METHOD_DEF, CTOR_DEF"/>
+        </module>
+        <module name="AnnotationLocation">
+            <property name="id" value="AnnotationLocationVariables"/>
+            <property name="tokens" value="VARIABLE_DEF"/>
+            <property name="allowSamelineMultipleAnnotations" value="true"/>
+        </module>
 
-    <!-- Checks for blocks. You know, those {}'s         -->
-    <!-- See http://checkstyle.sf.net/config_blocks.html -->
-    <!--module name="AvoidNestedBlocks"/-->
-    <!--module name="EmptyBlock"/-->
-    <module name="LeftCurly"/>
-    <!--allow single line-->
-    <module name="NeedBraces">
-      <property name="allowSingleLineStatement" value="true"/>
-    </module>
 
-    <module name="RightCurly"/>
+        <!-- 4. Naming -->
+        <module name="MethodName">
+            <property name="severity" value="ignore"/>
+            <property name="format" value="^[a-z][a-z0-9][a-zA-Z0-9_]*$"/>
+            <message key="name.invalidPattern"
+                     value="Method name ''{0}'' must match pattern ''{1}''."/>
+        </module>
+        <module name="PackageName">
+            <property name="format" value="^[a-z]+(\.[a-z][a-z0-9]*)*$"/>
+            <message key="name.invalidPattern"
+                     value="Package name ''{0}'' must match pattern ''{1}''."/>
+        </module>
+        <module name="TypeName">
+            <property name="format" value="^[A-Z][a-zA-Z0-9_]*$"/>
+            <message key="name.invalidPattern"
+                     value="Type name ''{0}'' must match pattern ''{1}''."/>
+        </module>
+        <module name="MemberName">
+            <property name="severity" value="ignore"/>
+            <property name="format" value="^[a-z][a-z0-9][a-zA-Z0-9]*$"/>
+            <property name="applyToPublic" value="true"/>
+            <property name="applyToPackage" value="false"/>
+            <property name="applyToPrivate" value="false"/>
+            <property name="applyToProtected" value="false"/>
+            <message key="name.invalidPattern"
+                     value="Member name ''{0}'' must match pattern ''{1}''."/>
+        </module>
+        <module name="MemberName">
+            <property name="severity" value="ignore"/>
+            <property name="format" value="^m[A-Z][a-zA-Z0-9]*$"/>
+            <property name="applyToPublic" value="false"/>
+            <property name="applyToProtected" value="true"/>
+            <property name="applyToPackage" value="true"/>
+            <property name="applyToPrivate" value="true"/>
+            <message key="name.invalidPattern"
+                     value="Member name ''{0}'' must match pattern ''{1}''."/>
+        </module>
+        <module name="ParameterName">
+            <property name="severity" value="ignore"/>
+            <property name="format" value="^[a-z]([a-z0-9][a-zA-Z0-9]*)?$"/>
+            <message key="name.invalidPattern"
+                     value="Parameter name ''{0}'' must match pattern ''{1}''."/>
+        </module>
+        <module name="LambdaParameterName">
+            <property name="format" value="^[a-z]([a-z0-9][a-zA-Z0-9]*)?$"/>
+            <message key="name.invalidPattern"
+                     value="Lambda parameter name ''{0}'' must match pattern ''{1}''."/>
+        </module>
+        <module name="CatchParameterName">
+            <property name="format" value="^[a-z]([a-z0-9][a-zA-Z0-9]*)?$"/>
+            <message key="name.invalidPattern"
+                     value="Catch parameter name ''{0}'' must match pattern ''{1}''."/>
+        </module>
+        <module name="LocalVariableName">
+            <property name="severity" value="info"/>
+            <property name="tokens" value="VARIABLE_DEF"/>
+            <property name="format" value="^[a-z]([a-zA-Z0-9][a-zA-Z0-9]*)?$"/>
+            <message key="name.invalidPattern"
+                     value="Local variable name ''{0}'' must match pattern ''{1}''."/>
+        </module>
+        <module name="ClassTypeParameterName">
+            <property name="format" value="(^[A-Z][0-9]?)$|([A-Z][a-zA-Z0-9]*[T]$)"/>
+            <message key="name.invalidPattern"
+                     value="Class type name ''{0}'' must match pattern ''{1}''."/>
+        </module>
+        <module name="MethodTypeParameterName">
+            <property name="format" value="(^[A-Z][0-9]?)$|([A-Z][a-zA-Z0-9]*[T]$)"/>
+            <message key="name.invalidPattern"
+                     value="Method type name ''{0}'' must match pattern ''{1}''."/>
+        </module>
+        <module name="InterfaceTypeParameterName">
+            <property name="format" value="(^[A-Z][0-9]?)$|([A-Z][a-zA-Z0-9]*[T]$)"/>
+            <message key="name.invalidPattern"
+                     value="Interface type name ''{0}'' must match pattern ''{1}''."/>
+        </module>
+        <module name="ConstantName"/>
+        <module name="LocalFinalVariableName"/>
+        <module name="StaticVariableName"/>
 
 
-    <!-- Checks for common coding problems               -->
-    <!-- See http://checkstyle.sf.net/config_coding.html -->
-    <!--module name="AvoidInlineConditionals"/-->
-    <module name="CovariantEquals"/>
-    <module name="EmptyStatement"/>
-    <!--module name="EqualsAvoidNull"/-->
-    <!--<module name="EqualsHashCode"/>-->
-    <!--module name="HiddenField"/-->
-    <module name="IllegalInstantiation"/>
-    <!--<module name="InnerAssignment"/>-->
-    <!--module name="MagicNumber"/-->
-    <!--<module name="MissingSwitchDefault"/>-->
-    <!--<module name="RedundantThrows"/>-->
-    <module name="SimplifyBooleanExpression"/>
-    <module name="SimplifyBooleanReturn"/>
+        <!-- 5. Programming Practise -->
+        <module name="NoFinalizer"/>
+        <module name="EmptyCatchBlock">
+            <property name="exceptionVariableName" value="expected|ignored"/>
+        </module>
+        <module name="MissingSwitchDefault"/>
+        <module name="FallThrough"/>
+        <module name="UpperEll">
+        </module>
+        <!-- Checks for common coding problems               -->
+        <!-- See http://checkstyle.sf.net/config_coding.html -->
+        <!--<module name="AvoidInlineConditionals"/>-->
+        <module name="CovariantEquals"/>
+        <module name="EmptyStatement"/>
+        <!--<module name="EqualsAvoidNull"/>-->
+        <module name="EqualsHashCode"/>
+        <!--<module name="HiddenField"/>-->
+        <module name="IllegalInstantiation"/>
+        <!--<module name="InnerAssignment"/>-->
+        <!--<module name="MagicNumber"/>-->
+        <module name="SimplifyBooleanExpression"/>
+        <module name="SimplifyBooleanReturn"/>
+        <!-- Checks for class design                         -->
+        <!-- See http://checkstyle.sf.net/config_design.html -->
+        <!--<module name="DesignForExtension"/>-->
+        <!--<module name="FinalClass"/>-->
+        <!--<module name="HideUtilityClassConstructor"/>-->
+        <!--<module name="InterfaceIsType"/>-->
+        <!--<module name="VisibilityModifier"/>-->
+        <!-- Others -->
+        <module name="StringLiteralEquality"/>
+        <module name="NestedForDepth">
+            <property name="max" value="2"/>
+        </module>
+        <module name="NestedIfDepth">
+            <property name="max" value="3"/>
+        </module>
+        <module name="ReturnCount">
+            <property name="severity" value="ignore"/>
+            <property name="max" value="3"/>
+        </module>
+        <module name="NestedTryDepth ">
+            <property name="max" value="3"/>
+        </module>
+        <module name="SuperClone"/>
+        <module name="SuperFinalize"/>
+        <module name="UncommentedMain">
+            <property name="excludedClasses" value=".*[Application,Test]$"/>
+        </module>
 
-    <!-- Checks for class design                         -->
-    <!-- See http://checkstyle.sf.net/config_design.html -->
-    <!--module name="DesignForExtension"/-->
-    <!--module name="FinalClass"/-->
-    <!--<module name="HideUtilityClassConstructor"/>-->
-    <!--module name="InterfaceIsType"/-->
-    <!--module name="VisibilityModifier"/-->
+        <!-- 6. Javadoc -->
+        <module name="NonEmptyAtclauseDescription">
+            <property name="severity" value="ignore"/>
+        </module>
+        <module name="JavadocTagContinuationIndentation">
+            <property name="severity" value="ignore"/>
+        </module>
+        <module name="SummaryJavadoc">
+            <property name="severity" value="ignore"/>
+            <property name="forbiddenSummaryFragments"
+                      value="^@return the *|^This method returns |^A [{]@code [a-zA-Z0-9]+[}]( is a )"/>
+        </module>
+        <module name="JavadocParagraph">
+            <property name="severity" value="ignore"/>
+        </module>
+        <module name="AtclauseOrder">
+            <property name="severity" value="ignore"/>
+            <property name="tagOrder" value="@param, @return, @throws, @deprecated"/>
+            <property name="target"
+                      value="CLASS_DEF, INTERFACE_DEF, ENUM_DEF, METHOD_DEF, CTOR_DEF, VARIABLE_DEF"/>
+        </module>
+        <module name="JavadocMethod">
+            <property name="severity" value="ignore"/>
+            <property name="scope" value="public"/>
+            <property name="allowMissingParamTags" value="true"/>
+            <property name="allowMissingThrowsTags" value="true"/>
+            <property name="allowMissingReturnTag" value="true"/>
+            <property name="minLineCount" value="2"/>
+            <property name="allowedAnnotations" value="Override, Test"/>
+            <property name="allowThrowsTagsForSubclasses" value="true"/>
+        </module>
+        <module name="SingleLineJavadoc">
+            <property name="severity" value="ignore"/>
+            <property name="ignoreInlineTags" value="false"/>
+        </module>
 
 
-    <!-- Miscellaneous other checks.                   -->
-    <!-- See http://checkstyle.sf.net/config_misc.html -->
-    <module name="ArrayTypeStyle"/>
-    <!--module name="FinalParameters"/-->
-    <!--<module name="TodoComment"/>-->
-    <module name="UpperEll"/>
-    <module name="SuppressWarningsHolder"/>
-  </module>
+        <!-- *. Others -->
+        <module name="RegexpSinglelineJava">
+            <property name="severity" value="ignore"/>
+            <!-- . matches any character, so we need to
+                 escape it and use \. to match dots. -->
+            <property name="format" value="System\.(out)|(err)\.print(ln)?\("/>
+            <property name="ignoreComments" value="true"/>
+        </module>
+        <module name="Regexp">
+            <property name="format" value="System\.out\.println"/>
+            <property name="illegalPattern" value="true"/>
+        </module>
+    </module>
 </module>
\ No newline at end of file
diff --git a/gradle.properties b/gradle.properties
index bc5983db..f47ca243 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -16,5 +16,5 @@
 # This option should only be used with decoupled projects. More details, visit
 # http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
 # org.gradle.parallel=true
-VERSION_NAME_PREFIX=1.9.12
+VERSION_NAME_PREFIX=1.9.14
 VERSION_NAME_SUFFIX=
\ No newline at end of file
diff --git a/gradle/check.gradle b/gradle/check.gradle
index 4205d8b1..acd67658 100644
--- a/gradle/check.gradle
+++ b/gradle/check.gradle
@@ -1,20 +1,134 @@
-apply plugin: 'checkstyle'
+if (project == rootProject) {
+    task('checkAll') {
+        group 'verification'
+        doFirst {
+            logger.lifecycle 'Run checkAll task'
+        }
+        outputs.upToDateWhen { false }
+    }
+    task('checkIncremental') {
+        group 'verification'
+        doFirst {
+            logger.lifecycle 'Run checkIncremental task'
+        }
+        outputs.upToDateWhen { false }
+    }
+    return
+}
+
+
+// ----------
+// Changed Files
+// ----------
+def reportsDir = "${rootProject.buildDir}/reports/${project.name}"
+def projectHeader = project.path.replaceAll(':', '/').substring(1)
+
+logger.lifecycle "Analyze code of module '${project.path}':"
+logger.lifecycle "Reading changed files..."
 
+if (!project.ext.has('filesChanged')) {
+    project.ext.filesChanged = []
 
-checkstyle {
-    configFile rootProject.file('checkstyle.xml')
-    toolVersion '6.19'
-    ignoreFailures false
-    showViolations true
+    if ("jenkins" == System.env.BUILDER_MODEL) {
+        logger.lifecycle 'Check MR changed files'
+        def inputFile = 'changed_file_list.txt'
+        if (project.hasProperty('changed_files')) { inputFile = project.properties['changed_files'] }
+        def file = rootProject.file(inputFile)
+        if (file.exists()) {
+            file.eachLine {
+                if (it.startsWith(projectHeader)) project.ext.filesChanged << it
+            }
+        }
+    } else {
+        logger.lifecycle 'Check git-diff changed files'
+        String command = "git diff --name-only --diff-filter=ACMRTUXB ${projectHeader}"
+        String changeInfo = command.execute(null, rootProject.rootDir).text.trim()
+        if (changeInfo && !changeInfo.isEmpty()) {
+            project.ext.filesChanged = changeInfo.split("\n").toList()
+        }
+    }
 }
 
-task('checkstyle', type: Checkstyle) {
-    source 'src/main/java'
-    include '**/*.java'
-    classpath = files()
+if (filesChanged.size() == 0) {
+    logger.lifecycle "No files changed found, skip analyzing."
+} else {
+    logger.lifecycle "Files changed found:"
+    filesChanged.each { project.logger.lifecycle it }
+}
+
+
+// ----------
+// CheckStyle, :checkstyleAll, :checkstyleIncremental
+// ----------
+def checkStyleConfig = rootProject.file('checkstyle.xml')
+if (checkStyleConfig.exists()) {
+    if (!project.plugins.hasPlugin('checkstyle')) {
+        apply plugin: 'checkstyle'
+    }
+
+    checkstyle {
+        configFile checkStyleConfig
+        configProperties.checkstyleSuppressionsPath = rootProject.file("suppressions.xml").absolutePath
+        toolVersion '8.19'
+        ignoreFailures true
+        showViolations true
+    }
+
+    task('checkstyleAll', type: Checkstyle) {
+        group 'verification'
+        classpath = files()
+        source 'src/main'
+
+        include '**/*.java'
+        exclude '**/gen/**'
+        reports {
+            html { enabled = false }
+            xml {
+                enabled = true
+                destination file("$reportsDir/checkstyle.xml")
+            }
+        }
+        outputs.upToDateWhen { false }
+    }
+
+    if (filesChanged.size > 0) {
+        def task = task('checkstyleIncremental', type: Checkstyle) {
+            group 'verification'
+            classpath = files()
+            source 'src'
+
+            exclude '**/gen/**'
+            exclude '**/test/**'
+            exclude '**/*.gradle'
+            exclude '**/proto/*.java'
+            exclude '**/protobuf/*.java'
+            exclude '**/com/google/**/*.java'
+
+            for (String item: filesChanged) {
+                if (item.contains('src/')) {
+                    include "**/${item.substring(item.lastIndexOf('src/') + 'src/'.length())}"
+                }
+            }
+            reports {
+                html { enabled = false }
+                xml {
+                    enabled = true
+                    destination file("$reportsDir/checkstyle.xml")
+                }
+            }
+            outputs.upToDateWhen { false }
+        }
+    }
+
+    project.afterEvaluate {
+        tasks.findByName('checkstyleAll')?.with { rootProject.tasks.findByName('checkAll')?.finalizedBy(it) }
+        tasks.findByName('checkstyleIncremental')?.with { rootProject.tasks.findByName('checkIncremental')?.finalizedBy(it) }
+    }
+
+} else {
+    logger.lifecycle "Can not find CheckStyle config file, skip."
 }
 
-check.dependsOn('checkstyle')
 
 
 //apply plugin: 'pmd'
diff --git a/suppressions.xml b/suppressions.xml
new file mode 100644
index 00000000..198c7591
--- /dev/null
+++ b/suppressions.xml
@@ -0,0 +1,114 @@
+<?xml version="1.0"?>
+
+<!DOCTYPE suppressions PUBLIC
+    "-//Checkstyle//DTD SuppressionFilter Configuration 1.2//EN"
+    "https://checkstyle.org/dtds/suppressions_1_2.dtd">
+
+<suppressions>
+    <!-- can't split long messages between lines -->
+    <suppress checks="RegexpSingleline" files="google_checks\.xml" lines="42,83"/>
+
+    <suppress checks="FileLength"
+              files="TokenTypes.java|IndentationCheckTest.java"
+              lines="1"/>
+
+    <!-- illegal words are part of Javadoc -->
+    <suppress checks="TodoComment" files=".*TodoCommentCheck\.java"/>
+
+    <!-- 'Abstract' pattern is used to show it is checking for abstract class name -->
+    <suppress checks="AbstractClassNameCheck"
+              files="AbstractClassNameCheck.java"/>
+    <!-- test should be named as their main class -->
+    <suppress checks="AbstractClassNameCheck"
+              files="AbstractCheckTest.java|AbstractClassNameCheckTest.java|
+                     |AbstractTypeAwareCheckTest.java|AbstractJavadocCheckTest.java|
+                     |AbstractViolationReporterTest.java|AbstractFileSetCheckTest.java"/>
+
+    <!-- Tone down the checking for test code -->
+    <suppress checks="ExecutableStatementCount|JavaNCSS|BooleanExpressionComplexity|
+                      |NestedIfDepth|MethodLength"
+              files="[\\/]XdocsPagesTest\.java"/>
+
+    <suppress checks="JavadocPackage" files=".*[\\/]src[\\/](test|it)[\\/]"/>
+    <!-- we do not need javadocs in all classes except for *Support classes -->
+    <suppress checks="JavadocMethod" files=".*[\\/]src[\\/](test|it)[\\/].*(?&lt;!Support)\.java"/>
+    <!-- till https://github.com/checkstyle/checkstyle/issues/6336 -->
+    <suppress checks="JavadocMethod" files=".*AbstractIndentationTestSupport\.java"/>
+    <suppress checks="JavadocMethod" files=".*AbstractModuleTestSupport\.java"/>
+    <suppress checks="JavadocMethod" files=".*AbstractXpathTestSupport\.java"/>
+    <suppress checks="JavadocMethod" files=".*AbstractModuleTestSupport\.java"/>
+    <suppress checks="JavadocMethod" files=".*AbstractPathTestSupport\.java"/>
+    <suppress checks="JavadocMethod" files=".*AbstractXmlTestSupport\.java"/>
+
+    <!--The Check generates too many violations, fixing them will make code unmanageable.-->
+    <suppress checks="MagicNumber" files="(ParseTreeTablePresentation|MainFrame)\.java"/>
+
+    <!-- Methods that build fake AST are very long-->
+    <suppress checks="MethodLength" files=".*(Generated)?Java(doc)?TokenTypesTest\.java"/>
+    <suppress checks="ExecutableStatementCount"
+              files=".*(Generated)?Java(doc)?TokenTypesTest\.java"/>
+    <suppress checks="JavaNCSS" files=".*(Generated)?Java(doc)?TokenTypesTest\.java"/>
+    <suppress checks="ExecutableStatementCount" files=".*IllegalInstantiationCheckTest\.java"/>
+    <suppress checks="ExecutableStatementCount" files=".*Main\.java"/>
+
+    <!-- till https://github.com/checkstyle/checkstyle/issues/4983 -->
+    <suppress checks="MissingDeprecated" files=".*JavadocTokenTypes\.java"/>
+
+    <!-- Till https://github.com/checkstyle/checkstyle/issues/1854 -->
+    <suppress checks="TrailingComment"
+              files="(InnerAssignmentCheck\.java|OperatorWrapCheck\.java|
+                     |AbbreviationAsWordInNameCheckTest\.java)"/>
+
+    <!-- Fixing these cases will decrease code readability -->
+    <suppress checks="MultipleStringLiterals" files="JavadocStyleCheck\.java|XMLLogger\.java"/>
+
+    <!-- There are a lot of setters/getters in the Check.
+         A small number of methods is left for Check's logic -->
+    <suppress checks="MethodCount" files="[\\/]JavadocMethodCheck.java$"/>
+    <!-- Apart from a complex logic there is a lot of small methods for a better readability.  -->
+    <suppress checks="MethodCount" files="[\\/]CommentsIndentationCheck.java$"/>
+    <!--VisibilityModifierCheck has 7 options which require 7 additional methods (setters)-->
+    <suppress checks="MethodCount" files="[\\/]VisibilityModifierCheck.java$"/>
+    <!--RequireThisCheck has a hierarchy of nested classes which contains a lot of methods. -->
+    <suppress checks="MethodCount" files="[\\/]RequireThisCheck.java$"/>
+
+    <!-- we need that set of converters -->
+    <suppress checks="ClassDataAbstractionCoupling" files="AutomaticBean\.java"/>
+    <!-- they are aggregators of logic, usage a several of classes are ok -->
+    <suppress checks="ClassDataAbstractionCoupling"
+              files="(Checker|Main|CheckstyleAntTask|JavadocDetailNodeParser)\.java"/>
+    <suppress checks="ClassDataAbstractionCoupling"
+              files="(CheckerTest|AbstractModuleTestSupport|CheckstyleAntTaskTest|
+                     |TranslationCheckTest|LocalizedMessageTest|AbstractFileSetCheckTest|
+                     |AbstractCheckTest|AutomaticBeanTest)\.java"/>
+    <suppress checks="ClassDataAbstractionCoupling" files="PropertyCacheFileTest\.java"/>
+    <suppress checks="ClassDataAbstractionCoupling"
+              files="XpathFileGeneratorAuditListenerTest\.java"/>
+    <suppress checks="ClassFanOutComplexity" files="[\\/]Main\.java"/>
+    <suppress checks="ClassFanOutComplexity" files="CheckstyleAntTask\.java"/>
+    <suppress checks="ClassFanOutComplexity" files="CheckerTest\.java"/>
+    <suppress checks="ClassFanOutComplexity" files="Checker\.java"/>
+    <!-- a lot of GUI elements is OK -->
+    <suppress checks="ClassDataAbstractionCoupling" files="(TreeTable|MainFrame)\.java"/>
+
+    <!-- Should be fixed after moving
+    https://github.com/sevntu-checkstyle/sevntu.checkstyle/blob/master/sevntu-checks/src/main/java/com/github/sevntu/checkstyle/checks/coding/ReturnCountExtendedCheck.java
+    into the main repo, to allow skip guard sentences(or by topLinesToIgnoreCount) -->
+    <suppress checks="ReturnCount" files="(ConfigurationLoader|LambdaHandler)\.java"/>
+
+    <!-- HandlerFactory crosses allowed limit for executable statements -->
+    <suppress checks="ExecutableStatementCount" files="HandlerFactory\.java"/>
+
+    <suppress id="ImportControlTest" files="[\\/]powermock[\\/]" message=".* - org\.(powermock|mockito).*" />
+
+    <!-- Tinker -->
+    <suppress checks="OneStatementPerLine" files="Hex.java" lines="275,276,277,278"/>
+
+    <suppress checks="NewlineAtEndOfFile" />
+
+    <suppress checks="FallThrough" files="BuilderMutableMethodImplementation" />
+
+    <suppress checks="FileLength" />
+
+    <suppress checks="MethodLength" files="InstructionReader.java" />
+</suppressions>
\ No newline at end of file
diff --git a/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/Annotation.java b/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/Annotation.java
index 59d73fe5..d8858cd4 100644
--- a/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/Annotation.java
+++ b/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/Annotation.java
@@ -17,6 +17,7 @@
 package com.tencent.tinker.android.dex;
 
 import com.tencent.tinker.android.dex.TableOfContents.Section.Item;
+import com.tencent.tinker.android.dex.util.HashCodeHelper;
 
 import static com.tencent.tinker.android.dex.EncodedValueReader.ENCODED_ANNOTATION;
 
@@ -47,6 +48,19 @@ public int getTypeIndex() {
         return encodedAnnotation.compareTo(other.encodedAnnotation);
     }
 
+    @Override
+    public int hashCode() {
+        return HashCodeHelper.hash(visibility, encodedAnnotation);
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (!(obj instanceof Annotation)) {
+            return false;
+        }
+        return this.compareTo((Annotation) obj) == 0;
+    }
+
     @Override
     public int byteCountInDex() {
         return SizeOf.UBYTE + encodedAnnotation.byteCountInDex();
diff --git a/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/AnnotationSet.java b/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/AnnotationSet.java
index 16faedc7..fcd0ce31 100644
--- a/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/AnnotationSet.java
+++ b/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/AnnotationSet.java
@@ -19,6 +19,8 @@
 import com.tencent.tinker.android.dex.TableOfContents.Section;
 import com.tencent.tinker.android.dex.util.CompareUtils;
 
+import java.util.Arrays;
+
 /**
  * *** This file is NOT a part of AOSP. ***
  *
@@ -50,6 +52,19 @@ public int compareTo(AnnotationSet other) {
         return 0;
     }
 
+    @Override
+    public int hashCode() {
+        return Arrays.hashCode(annotationOffsets);
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (!(obj instanceof AnnotationSet)) {
+            return false;
+        }
+        return this.compareTo((AnnotationSet) obj) == 0;
+    }
+
     @Override
     public int byteCountInDex() {
         return SizeOf.UINT * (1 + annotationOffsets.length);
diff --git a/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/AnnotationSetRefList.java b/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/AnnotationSetRefList.java
index 6389c510..d5dccd69 100644
--- a/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/AnnotationSetRefList.java
+++ b/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/AnnotationSetRefList.java
@@ -19,6 +19,8 @@
 import com.tencent.tinker.android.dex.TableOfContents.Section;
 import com.tencent.tinker.android.dex.util.CompareUtils;
 
+import java.util.Arrays;
+
 /**
  * *** This file is NOT a part of AOSP. ***
  *
@@ -50,6 +52,19 @@ public int compareTo(AnnotationSetRefList other) {
         return 0;
     }
 
+    @Override
+    public int hashCode() {
+        return Arrays.hashCode(annotationSetRefItems);
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (!(obj instanceof AnnotationSetRefList)) {
+            return false;
+        }
+        return this.compareTo((AnnotationSetRefList) obj) == 0;
+    }
+
     @Override
     public int byteCountInDex() {
         return SizeOf.UINT * (1 + annotationSetRefItems.length);
diff --git a/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/AnnotationsDirectory.java b/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/AnnotationsDirectory.java
index e5bd1256..e32ae14b 100644
--- a/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/AnnotationsDirectory.java
+++ b/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/AnnotationsDirectory.java
@@ -18,6 +18,7 @@
 
 import com.tencent.tinker.android.dex.TableOfContents.Section;
 import com.tencent.tinker.android.dex.util.CompareUtils;
+import com.tencent.tinker.android.dex.util.HashCodeHelper;
 
 /**
  * *** This file is NOT a part of AOSP. ***
@@ -130,6 +131,20 @@ public int compareTo(AnnotationsDirectory other) {
         return 0;
     }
 
+    @Override
+    public int hashCode() {
+        return HashCodeHelper.hash(classAnnotationsOffset, fieldAnnotations, methodAnnotations,
+                parameterAnnotations);
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (!(obj instanceof AnnotationsDirectory)) {
+            return false;
+        }
+        return this.compareTo((AnnotationsDirectory) obj) == 0;
+    }
+
     @Override
     public int byteCountInDex() {
         return SizeOf.UINT * (4 + 2 * (fieldAnnotations.length + methodAnnotations.length + parameterAnnotations.length));
diff --git a/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/ClassData.java b/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/ClassData.java
index 4824957e..b1753a71 100644
--- a/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/ClassData.java
+++ b/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/ClassData.java
@@ -18,6 +18,7 @@
 
 import com.tencent.tinker.android.dex.TableOfContents.Section.Item;
 import com.tencent.tinker.android.dex.util.CompareUtils;
+import com.tencent.tinker.android.dex.util.HashCodeHelper;
 
 public final class ClassData extends Item<ClassData> {
     public Field[] staticFields;
@@ -52,6 +53,19 @@ public int compareTo(ClassData other) {
         return CompareUtils.aArrCompare(virtualMethods, other.virtualMethods);
     }
 
+    @Override
+    public int hashCode() {
+        return HashCodeHelper.hash(staticFields, instanceFields, directMethods, virtualMethods);
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (!(obj instanceof ClassData)) {
+            return false;
+        }
+        return this.compareTo((ClassData) obj) == 0;
+    }
+
     @Override
     public int byteCountInDex() {
         int res = Leb128.unsignedLeb128Size(staticFields.length);
@@ -106,6 +120,19 @@ public int compareTo(Field other) {
             }
             return CompareUtils.sCompare(accessFlags, other.accessFlags);
         }
+
+        @Override
+        public boolean equals(Object obj) {
+            if (!(obj instanceof Field)) {
+                return false;
+            }
+            return this.compareTo((Field) obj) == 0;
+        }
+
+        @Override
+        public int hashCode() {
+            return HashCodeHelper.hash(fieldIndex, accessFlags);
+        }
     }
 
     public static class Method implements Comparable<Method> {
@@ -131,5 +158,18 @@ public int compareTo(Method other) {
             }
             return CompareUtils.sCompare(codeOffset, other.codeOffset);
         }
+
+        @Override
+        public boolean equals(Object obj) {
+            if (!(obj instanceof Method)) {
+                return false;
+            }
+            return this.compareTo((Method) obj) == 0;
+        }
+
+        @Override
+        public int hashCode() {
+            return HashCodeHelper.hash(methodIndex, accessFlags, codeOffset);
+        }
     }
 }
diff --git a/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/ClassDef.java b/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/ClassDef.java
index c507324a..3d2d540b 100644
--- a/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/ClassDef.java
+++ b/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/ClassDef.java
@@ -17,6 +17,7 @@
 package com.tencent.tinker.android.dex;
 
 import com.tencent.tinker.android.dex.util.CompareUtils;
+import com.tencent.tinker.android.dex.util.HashCodeHelper;
 
 /**
  * A type definition.
@@ -81,6 +82,20 @@ public int compareTo(ClassDef other) {
         return CompareUtils.sCompare(staticValuesOffset, other.staticValuesOffset);
     }
 
+    @Override
+    public int hashCode() {
+        return HashCodeHelper.hash(typeIndex, accessFlags, supertypeIndex, interfacesOffset,
+                sourceFileIndex, annotationsOffset, classDataOffset, staticValuesOffset);
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (!(obj instanceof ClassDef)) {
+            return false;
+        }
+        return this.compareTo((ClassDef) obj) == 0;
+    }
+
     @Override
     public int byteCountInDex() {
         return SizeOf.CLASS_DEF_ITEM;
diff --git a/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/Code.java b/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/Code.java
index 4bb34b8a..3dcf47b1 100644
--- a/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/Code.java
+++ b/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/Code.java
@@ -18,6 +18,7 @@
 
 import com.tencent.tinker.android.dex.TableOfContents.Section.Item;
 import com.tencent.tinker.android.dex.util.CompareUtils;
+import com.tencent.tinker.android.dex.util.HashCodeHelper;
 
 public final class Code extends Item<Code> {
     public int registersSize;
@@ -69,6 +70,20 @@ public int compareTo(Code other) {
         return CompareUtils.aArrCompare(catchHandlers, other.catchHandlers);
     }
 
+    @Override
+    public int hashCode() {
+        return HashCodeHelper.hash(registersSize,
+                insSize, outsSize, debugInfoOffset, instructions, tries, catchHandlers);
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (!(obj instanceof Code)) {
+            return false;
+        }
+        return this.compareTo((Code) obj) == 0;
+    }
+
     @Override
     public int byteCountInDex() {
         int insnsSize = instructions.length;
diff --git a/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/DebugInfoItem.java b/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/DebugInfoItem.java
index aff6a336..2512cff9 100644
--- a/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/DebugInfoItem.java
+++ b/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/DebugInfoItem.java
@@ -18,6 +18,7 @@
 
 import com.tencent.tinker.android.dex.TableOfContents.Section.Item;
 import com.tencent.tinker.android.dex.util.CompareUtils;
+import com.tencent.tinker.android.dex.util.HashCodeHelper;
 
 /**
  * *** This file is NOT a part of AOSP. ***
@@ -63,6 +64,19 @@ public int compareTo(DebugInfoItem o) {
         return cmpRes;
     }
 
+    @Override
+    public int hashCode() {
+        return HashCodeHelper.hash(lineStart, parameterNames, infoSTM);
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (!(obj instanceof DebugInfoItem)) {
+            return false;
+        }
+        return this.compareTo((DebugInfoItem) obj) == 0;
+    }
+
     @Override
     public int byteCountInDex() {
         int byteCount = Leb128.unsignedLeb128Size(lineStart) + Leb128.unsignedLeb128Size(parameterNames.length);
diff --git a/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/EncodedValue.java b/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/EncodedValue.java
index 28105aca..131899be 100644
--- a/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/EncodedValue.java
+++ b/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/EncodedValue.java
@@ -19,6 +19,8 @@
 import com.tencent.tinker.android.dex.util.ByteInput;
 import com.tencent.tinker.android.dex.util.CompareUtils;
 
+import java.util.Arrays;
+
 import static com.tencent.tinker.android.dex.TableOfContents.Section.Item;
 
 /**
@@ -47,6 +49,19 @@ public byte readByte() {
         return CompareUtils.uArrCompare(data, other.data);
     }
 
+    @Override
+    public int hashCode() {
+        return Arrays.hashCode(data);
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (!(obj instanceof EncodedValue)) {
+            return false;
+        }
+        return this.compareTo((EncodedValue) obj) == 0;
+    }
+
     @Override
     public int byteCountInDex() {
         return SizeOf.UBYTE * data.length;
diff --git a/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/FieldId.java b/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/FieldId.java
index 40435348..808a772e 100644
--- a/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/FieldId.java
+++ b/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/FieldId.java
@@ -18,6 +18,7 @@
 
 import com.tencent.tinker.android.dex.TableOfContents.Section.Item;
 import com.tencent.tinker.android.dex.util.CompareUtils;
+import com.tencent.tinker.android.dex.util.HashCodeHelper;
 
 public final class FieldId extends Item<FieldId> {
     public int declaringClassIndex;
@@ -41,6 +42,19 @@ public int compareTo(FieldId other) {
         return CompareUtils.uCompare(typeIndex, other.typeIndex); // should always be 0
     }
 
+    @Override
+    public int hashCode() {
+        return HashCodeHelper.hash(declaringClassIndex, typeIndex, nameIndex);
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (!(obj instanceof FieldId)) {
+            return false;
+        }
+        return this.compareTo((FieldId) obj) == 0;
+    }
+
     @Override
     public int byteCountInDex() {
         return SizeOf.MEMBER_ID_ITEM;
diff --git a/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/MethodId.java b/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/MethodId.java
index fcb71ca9..b1a4a768 100644
--- a/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/MethodId.java
+++ b/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/MethodId.java
@@ -18,6 +18,7 @@
 
 import com.tencent.tinker.android.dex.TableOfContents.Section.Item;
 import com.tencent.tinker.android.dex.util.CompareUtils;
+import com.tencent.tinker.android.dex.util.HashCodeHelper;
 
 public final class MethodId extends Item<MethodId> {
     public int declaringClassIndex;
@@ -41,6 +42,19 @@ public int compareTo(MethodId other) {
         return CompareUtils.uCompare(protoIndex, other.protoIndex);
     }
 
+    @Override
+    public int hashCode() {
+        return HashCodeHelper.hash(declaringClassIndex, protoIndex, nameIndex);
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (!(obj instanceof MethodId)) {
+            return false;
+        }
+        return this.compareTo((MethodId) obj) == 0;
+    }
+
     @Override
     public int byteCountInDex() {
         return SizeOf.MEMBER_ID_ITEM;
diff --git a/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/ProtoId.java b/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/ProtoId.java
index c5a6bbe4..e89ab672 100644
--- a/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/ProtoId.java
+++ b/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/ProtoId.java
@@ -17,6 +17,7 @@
 package com.tencent.tinker.android.dex;
 
 import com.tencent.tinker.android.dex.util.CompareUtils;
+import com.tencent.tinker.android.dex.util.HashCodeHelper;
 
 public final class ProtoId extends TableOfContents.Section.Item<ProtoId> {
     public int shortyIndex;
@@ -43,6 +44,19 @@ public int compareTo(ProtoId other) {
     }
 
 
+    @Override
+    public int hashCode() {
+        return HashCodeHelper.hash(shortyIndex, returnTypeIndex, parametersOffset);
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (!(obj instanceof ProtoId)) {
+            return false;
+        }
+        return this.compareTo((ProtoId) obj) == 0;
+    }
+
     @Override
     public int byteCountInDex() {
         return SizeOf.PROTO_ID_ITEM;
diff --git a/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/StringData.java b/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/StringData.java
index 1f7848e0..5dbfa3a0 100644
--- a/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/StringData.java
+++ b/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/StringData.java
@@ -38,6 +38,19 @@ public int compareTo(StringData other) {
         return value.compareTo(other.value);
     }
 
+    @Override
+    public int hashCode() {
+        return value.hashCode();
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (!(obj instanceof StringData)) {
+            return false;
+        }
+        return this.compareTo((StringData) obj) == 0;
+    }
+
     @Override
     public int byteCountInDex() {
         try {
diff --git a/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/TableOfContents.java b/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/TableOfContents.java
index 7ad5e415..dcd231b5 100644
--- a/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/TableOfContents.java
+++ b/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/TableOfContents.java
@@ -423,6 +423,11 @@ public Item(int off) {
                 this.off = off;
             }
 
+            @Override
+            public int hashCode() {
+                return super.hashCode();
+            }
+
             @Override
             @SuppressWarnings("unchecked")
             public boolean equals(Object obj) {
diff --git a/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/TypeList.java b/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/TypeList.java
index f10d5db4..c7705c9d 100644
--- a/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/TypeList.java
+++ b/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/TypeList.java
@@ -19,6 +19,8 @@
 import com.tencent.tinker.android.dex.TableOfContents.Section.Item;
 import com.tencent.tinker.android.dex.util.CompareUtils;
 
+import java.util.Arrays;
+
 public final class TypeList extends Item<TypeList> {
     public static final TypeList EMPTY = new TypeList(0, Dex.EMPTY_SHORT_ARRAY);
 
@@ -33,6 +35,19 @@ public TypeList(int off, short[] types) {
         return CompareUtils.uArrCompare(types, other.types);
     }
 
+    @Override
+    public int hashCode() {
+        return Arrays.hashCode(types);
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (!(obj instanceof TypeList)) {
+            return false;
+        }
+        return this.compareTo((TypeList) obj) == 0;
+    }
+
     @Override
     public int byteCountInDex() {
         return SizeOf.UINT + types.length * SizeOf.USHORT;
diff --git a/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/util/HashCodeHelper.java b/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/util/HashCodeHelper.java
new file mode 100644
index 00000000..b458ab74
--- /dev/null
+++ b/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/util/HashCodeHelper.java
@@ -0,0 +1,50 @@
+package com.tencent.tinker.android.dex.util;
+
+import java.lang.reflect.Array;
+import java.util.Arrays;
+
+public final class HashCodeHelper {
+    public static int hash(Object... values) {
+        if (values == null || values.length == 0) {
+            return 0;
+        }
+        int result = 0;
+        for (Object v : values) {
+            if (v == null) {
+                continue;
+            }
+            if (v instanceof Number) {
+                result += v.hashCode();
+            } else if (v instanceof boolean[]) {
+                result += Arrays.hashCode((boolean[]) v);
+            } else if (v instanceof byte[]) {
+                result += Arrays.hashCode((byte[]) v);
+            } else if (v instanceof char[]) {
+                result += Arrays.hashCode((char[]) v);
+            } else if (v instanceof short[]) {
+                result += Arrays.hashCode((short[]) v);
+            } else if (v instanceof int[]) {
+                result += Arrays.hashCode((int[]) v);
+            } else if (v instanceof long[]) {
+                result += Arrays.hashCode((long[]) v);
+            } else if (v instanceof float[]) {
+                result += Arrays.hashCode((float[]) v);
+            } else if (v instanceof double[]) {
+                result += Arrays.hashCode((double[]) v);
+            } else if (v instanceof Object[]) {
+                result += Arrays.hashCode((Object[]) v);
+            } else if (v.getClass().isArray()) {
+                for (int i = 0; i < Array.getLength(v); ++i) {
+                    result += hash(Array.get(v, i));
+                }
+            } else {
+                result += v.hashCode();
+            }
+        }
+        return result;
+    }
+
+    private HashCodeHelper() {
+        throw new UnsupportedOperationException();
+    }
+}
diff --git a/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dx/instruction/InstructionReader.java b/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dx/instruction/InstructionReader.java
index de8ef5aa..4c60af29 100644
--- a/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dx/instruction/InstructionReader.java
+++ b/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dx/instruction/InstructionReader.java
@@ -392,6 +392,9 @@ public void accept(InstructionVisitor iv) throws EOFException {
                             codeIn.setBaseAddress(target + 1, currentAddress);
                             break;
                         }
+                        default: {
+                            break;
+                        }
                     }
 
                     iv.visitOneRegisterInsn(currentAddress, opcode, 0, InstructionCodec.INDEX_TYPE_NONE, target, 0L, a);
diff --git a/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dx/instruction/InstructionWriter.java b/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dx/instruction/InstructionWriter.java
index ea3ee8fa..f5838ff6 100644
--- a/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dx/instruction/InstructionWriter.java
+++ b/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dx/instruction/InstructionWriter.java
@@ -238,6 +238,9 @@ public void visitOneRegisterInsn(int currentAddress, int opcode, int index, int
                         codeOut.setBaseAddress(target, codeOut.cursor());
                         break;
                     }
+                    default: {
+                        break;
+                    }
                 }
 
                 int relativeTarget = InstructionCodec.getTarget(target, codeOut.cursor());
diff --git a/third-party/bsdiff-util/src/main/java/com/tencent/tinker/bsdiff/BSDiff.java b/third-party/bsdiff-util/src/main/java/com/tencent/tinker/bsdiff/BSDiff.java
index 545c7664..16d7e087 100644
--- a/third-party/bsdiff-util/src/main/java/com/tencent/tinker/bsdiff/BSDiff.java
+++ b/third-party/bsdiff-util/src/main/java/com/tencent/tinker/bsdiff/BSDiff.java
@@ -526,23 +526,23 @@ public static void bsdiff(File oldFile, File newFile, File diffFile) throws IOEx
         return diffBytes;
     }
 
-//    /**
-//     * Run JBDiff from the command line. Params: oldfile newfile difffile. diff
-//     * file will be created.
-//     */
-//    public static void main(String[] arg) throws IOException {
-//
-//        if (arg.length != 3) {
-//            System.err.println("usage example: java -Xmx250m JBDiff oldfile newfile patchfile\n");
-//            return;
-//        }
-//        File oldFile = new File(arg[0]);
-//        File newFile = new File(arg[1]);
-//        File diffFile = new File(arg[2]);
-//
-//        bsdiff(oldFile, newFile, diffFile);
-//
-//    }
+    //    /**
+    //     * Run JBDiff from the command line. Params: oldfile newfile difffile. diff
+    //     * file will be created.
+    //     */
+    //    public static void main(String[] arg) throws IOException {
+    //
+    //        if (arg.length != 3) {
+    //            System.err.println("usage example: java -Xmx250m JBDiff oldfile newfile patchfile\n");
+    //            return;
+    //        }
+    //        File oldFile = new File(arg[0]);
+    //        File newFile = new File(arg[1]);
+    //        File diffFile = new File(arg[2]);
+    //
+    //        bsdiff(oldFile, newFile, diffFile);
+    //
+    //    }
 
     private static class IntByRef {
         private int value;
diff --git a/third-party/bsdiff-util/src/main/java/com/tencent/tinker/bsdiff/BSPatch.java b/third-party/bsdiff-util/src/main/java/com/tencent/tinker/bsdiff/BSPatch.java
index e31e4fd6..6f9425ff 100644
--- a/third-party/bsdiff-util/src/main/java/com/tencent/tinker/bsdiff/BSPatch.java
+++ b/third-party/bsdiff-util/src/main/java/com/tencent/tinker/bsdiff/BSPatch.java
@@ -110,10 +110,10 @@ public static int patchLessMemory(RandomAccessFile oldFile, int oldsize, byte[]
             return RETURN_DIFF_FILE_ERR;
         }
 
-//        int commentLenPos = oldsize - extLen - 2;
-//        if (commentLenPos <= 2) {
-//            return RETURN_OLD_FILE_ERR;
-//        }
+        // int commentLenPos = oldsize - extLen - 2;
+        // if (commentLenPos <= 2) {
+        //     return RETURN_OLD_FILE_ERR;
+        // }
 
         DataInputStream diffIn = new DataInputStream(new ByteArrayInputStream(diffBuf, 0, diffSize));
 
@@ -167,10 +167,10 @@ public static int patchLessMemory(RandomAccessFile oldFile, int oldsize, byte[]
                     return RETURN_DIFF_FILE_ERR;
                 }
                 for (int i = 0; i < ctrl[0]; i++) {
-//                    if (oldpos + i == commentLenPos) {
-//                        oldBuffer[i] = 0;
-//                        oldBuffer[i + 1] = 0;
-//                    }
+                    // if (oldpos + i == commentLenPos) {
+                    //     oldBuffer[i] = 0;
+                    //     oldBuffer[i + 1] = 0;
+                    // }
 
                     if ((oldpos + i >= 0) && (oldpos + i < oldsize)) {
                         buffer[i] += oldBuffer[i];
@@ -178,8 +178,6 @@ public static int patchLessMemory(RandomAccessFile oldFile, int oldsize, byte[]
                 }
                 outStream.write(buffer);
 
-//            System.out.println(""+ctrl[0]+ ", " + ctrl[1]+ ", " + ctrl[2]);
-
                 newpos += ctrl[0];
                 oldpos += ctrl[0];
 
diff --git a/third-party/tinker-ziputils/src/main/java/com/tencent/tinker/ziputils/ziputil/Arrays.java b/third-party/tinker-ziputils/src/main/java/com/tencent/tinker/ziputils/ziputil/Arrays.java
index 373c33a6..368736b5 100644
--- a/third-party/tinker-ziputils/src/main/java/com/tencent/tinker/ziputils/ziputil/Arrays.java
+++ b/third-party/tinker-ziputils/src/main/java/com/tencent/tinker/ziputils/ziputil/Arrays.java
@@ -22,8 +22,8 @@
 public class Arrays {
     public static void checkOffsetAndCount(int arrayLength, int offset, int count) {
         if ((offset | count) < 0 || offset > arrayLength || arrayLength - offset < count) {
-//            throw new ArrayIndexOutOfBoundsException(arrayLength, offset,
-//                count);
+            // throw new ArrayIndexOutOfBoundsException(arrayLength, offset,
+            //     count);
             throw new ArrayIndexOutOfBoundsException(offset);
         }
     }
diff --git a/third-party/tinker-ziputils/src/main/java/com/tencent/tinker/ziputils/ziputil/TinkerZipEntry.java b/third-party/tinker-ziputils/src/main/java/com/tencent/tinker/ziputils/ziputil/TinkerZipEntry.java
index 8e275cf2..7b3c4b8e 100644
--- a/third-party/tinker-ziputils/src/main/java/com/tencent/tinker/ziputils/ziputil/TinkerZipEntry.java
+++ b/third-party/tinker-ziputils/src/main/java/com/tencent/tinker/ziputils/ziputil/TinkerZipEntry.java
@@ -459,4 +459,12 @@ public String toString() {
     public int hashCode() {
         return name.hashCode();
     }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (!(obj instanceof TinkerZipEntry)) {
+            return false;
+        }
+        return name.equals(((TinkerZipEntry) obj).name);
+    }
 }
diff --git a/third-party/tinker-ziputils/src/main/java/com/tencent/tinker/ziputils/ziputil/TinkerZipFile.java b/third-party/tinker-ziputils/src/main/java/com/tencent/tinker/ziputils/ziputil/TinkerZipFile.java
index e81d5f88..a92ee097 100644
--- a/third-party/tinker-ziputils/src/main/java/com/tencent/tinker/ziputils/ziputil/TinkerZipFile.java
+++ b/third-party/tinker-ziputils/src/main/java/com/tencent/tinker/ziputils/ziputil/TinkerZipFile.java
@@ -141,7 +141,7 @@ public TinkerZipFile(File file, int mode) throws IOException {
         }
         raf = new RandomAccessFile(filename, "r");
 
-         readCentralDir();
+        readCentralDir();
         // guard.open("close");
     }
 
diff --git a/third-party/tinker-ziputils/src/main/java/com/tencent/tinker/ziputils/ziputil/TinkerZipOutputStream.java b/third-party/tinker-ziputils/src/main/java/com/tencent/tinker/ziputils/ziputil/TinkerZipOutputStream.java
index 02bc9a3f..6f82843a 100644
--- a/third-party/tinker-ziputils/src/main/java/com/tencent/tinker/ziputils/ziputil/TinkerZipOutputStream.java
+++ b/third-party/tinker-ziputils/src/main/java/com/tencent/tinker/ziputils/ziputil/TinkerZipOutputStream.java
@@ -474,10 +474,10 @@ public void putNextEntry(TinkerZipEntry ze) throws IOException {
         writeIntAsUint16(out, flags);
         writeIntAsUint16(out, method);
 
-        //zhangshaowen edit here, we just want the same time and modDate
-//        if (currentEntry.getTime() == -1) {
-//            currentEntry.setTime(System.currentTimeMillis());
-//        }
+        // zhangshaowen edit here, we just want the same time and modDate
+        // if (currentEntry.getTime() == -1) {
+        //     currentEntry.setTime(System.currentTimeMillis());
+        // }
         writeIntAsUint16(out, currentEntry.time);
         writeIntAsUint16(out, currentEntry.modDate);
         if (method == STORED) {
diff --git a/tinker-android/tinker-android-anno/src/main/java/com/tencent/tinker/anno/AnnotationProcessor.java b/tinker-android/tinker-android-anno/src/main/java/com/tencent/tinker/anno/AnnotationProcessor.java
index 533a1c3c..29b63f26 100644
--- a/tinker-android/tinker-android-anno/src/main/java/com/tencent/tinker/anno/AnnotationProcessor.java
+++ b/tinker-android/tinker-android-anno/src/main/java/com/tencent/tinker/anno/AnnotationProcessor.java
@@ -82,8 +82,6 @@ private void processDefaultLifeCycle(Set<? extends Element> elements) {
                 loaderClassName = lifeCyclePackageName + loaderClassName;
             }
 
-            System.out.println("*");
-
             final InputStream is = AnnotationProcessor.class.getResourceAsStream(APPLICATION_TEMPLATE_PATH);
             final Scanner scanner = new Scanner(is);
             final String template = scanner.useDelimiter("\\A").next();
diff --git a/tinker-android/tinker-android-lib/build.gradle b/tinker-android/tinker-android-lib/build.gradle
index c91a8205..b78a36c8 100644
--- a/tinker-android/tinker-android-lib/build.gradle
+++ b/tinker-android/tinker-android-lib/build.gradle
@@ -16,8 +16,8 @@ android {
 dependencies {
     implementation fileTree(dir: 'libs', include: ['*.jar'])
     testImplementation 'junit:junit:4.12'
-    implementation "com.android.support:support-annotations:${rootProject.ext.supportLibVersion}"
-    implementation project(':tinker-android:tinker-android-loader')
+    api project(':tinker-android:tinker-android-loader')
+    compileOnly "com.android.support:support-annotations:${rootProject.ext.supportLibVersion}"
     api project(':tinker-commons')
 }
 
diff --git a/tinker-android/tinker-android-lib/src/main/AndroidManifest.xml b/tinker-android/tinker-android-lib/src/main/AndroidManifest.xml
index 9a1bf2b6..b65c036b 100644
--- a/tinker-android/tinker-android-lib/src/main/AndroidManifest.xml
+++ b/tinker-android/tinker-android-lib/src/main/AndroidManifest.xml
@@ -1,8 +1,13 @@
-<manifest package="com.tencent.tinker.lib"
-          xmlns:android="http://schemas.android.com/apk/res/android">
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.tencent.tinker.lib">
 
     <application>
-
+        <service
+            android:name=".service.TinkerPatchForeService"
+            android:enabled="true"
+            android:process=":patch"
+            android:exported="false"/>
         <!--
             Notice:
             Following service must run in the same process.
@@ -12,20 +17,17 @@
         <!-- ########################################################################### -->
         <service
             android:name=".service.TinkerPatchService"
-            android:permission="android.permission.BIND_JOB_SERVICE"
             android:exported="false"
-            android:process=":patch"/>
+            android:permission="android.permission.BIND_JOB_SERVICE"
+            android:process=":patch" />
         <service
             android:name=".service.TinkerPatchService$InnerService"
             android:exported="false"
-            android:process=":patch"/>
-        <!-- ########################################################################### -->
-
+            android:process=":patch" /> <!-- ########################################################################### -->
         <service
             android:name=".service.DefaultTinkerResultService"
-            android:permission="android.permission.BIND_JOB_SERVICE"
-            android:exported="false"/>
-
+            android:exported="false"
+            android:permission="android.permission.BIND_JOB_SERVICE" />
     </application>
 
-</manifest>
+</manifest>
\ No newline at end of file
diff --git a/tinker-android/tinker-android-lib/src/main/aidl/com/tencent/tinker/lib/IForeService.aidl b/tinker-android/tinker-android-lib/src/main/aidl/com/tencent/tinker/lib/IForeService.aidl
new file mode 100644
index 00000000..4e29a1ea
--- /dev/null
+++ b/tinker-android/tinker-android-lib/src/main/aidl/com/tencent/tinker/lib/IForeService.aidl
@@ -0,0 +1,7 @@
+// IForeService.aidl
+package com.tencent.tinker.lib;
+
+
+interface IForeService {
+    void startme();
+}
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/entry/TinkerApplicationInlineFence.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/entry/TinkerApplicationInlineFence.java
new file mode 100644
index 00000000..bb01d08a
--- /dev/null
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/entry/TinkerApplicationInlineFence.java
@@ -0,0 +1,282 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.entry;
+
+import android.app.Application;
+import android.content.Context;
+import android.content.Intent;
+import android.content.res.AssetManager;
+import android.content.res.Configuration;
+import android.content.res.Resources;
+import android.support.annotation.Keep;
+
+import com.tencent.tinker.loader.TinkerRuntimeException;
+import com.tencent.tinker.loader.app.ITinkerInlineFenceBridge;
+import com.tencent.tinker.loader.app.TinkerApplication;
+import com.tencent.tinker.loader.hotplug.ComponentHotplug;
+import com.tencent.tinker.loader.hotplug.UnsupportedEnvironmentException;
+
+import java.lang.reflect.Constructor;
+
+@Keep
+public final class TinkerApplicationInlineFence implements ITinkerInlineFenceBridge {
+    private final int mTinkerFlags;
+    private final String mDelegateClassName;
+    private final boolean mTinkerLoadVerifyFlag;
+
+    private final long mApplicationStartElapsedTime;
+    private final long mApplicationStartMillisTime;
+
+    private final Intent mTinkerResultIntent;
+
+    private ApplicationLike mApplicationLike = null;
+
+    public TinkerApplicationInlineFence(int tinkerFlags,
+                                        String delegateClassName,
+                                        boolean tinkerLoadVerifyFlag,
+                                        long applicationStartElapsedTime,
+                                        long applicationStartMillisTime,
+                                        Intent resultIntent) {
+        mTinkerFlags = tinkerFlags;
+        mDelegateClassName = delegateClassName;
+        mTinkerLoadVerifyFlag = tinkerLoadVerifyFlag;
+        mApplicationStartElapsedTime = applicationStartElapsedTime;
+        mApplicationStartMillisTime = applicationStartMillisTime;
+        mTinkerResultIntent = resultIntent;
+    }
+
+    private static void dummyThrowExceptionMethod() {
+        if (TinkerApplicationInlineFence.class.isPrimitive()) {
+            throw new RuntimeException();
+        }
+    }
+
+    private Object createDelegate(TinkerApplication app) {
+        try {
+            // Use reflection to create the delegate so it doesn't need to go into the primary dex.
+            // And we can also patch it
+            Class<?> delegateClass = Class.forName(mDelegateClassName, false, this.getClass().getClassLoader());
+            Constructor<?> constructor = delegateClass.getConstructor(Application.class, int.class, boolean.class,
+                    long.class, long.class, Intent.class);
+            return constructor.newInstance(app, mTinkerFlags, mTinkerLoadVerifyFlag,
+                    mApplicationStartElapsedTime, mApplicationStartMillisTime, mTinkerResultIntent);
+        } catch (Throwable e) {
+            throw new TinkerRuntimeException("createDelegate failed", e);
+        }
+    }
+
+    private synchronized void ensureDelegate(TinkerApplication app) {
+        if (mApplicationLike == null) {
+            mApplicationLike = (ApplicationLike) createDelegate(app);
+        }
+    }
+
+    @Keep
+    private void attachBaseContextImpl_$noinline$(TinkerApplication app, Context base) {
+        try {
+            dummyThrowExceptionMethod();
+        } finally {
+            ensureDelegate(app);
+            if (mApplicationLike != null) {
+                mApplicationLike.onBaseContextAttached(base);
+            }
+        }
+    }
+
+    @Override
+    public void attachBaseContext(TinkerApplication app, Context base) {
+        attachBaseContextImpl_$noinline$(app, base);
+    }
+
+    @Keep
+    private void onCreateImpl_$noinline$(TinkerApplication app) {
+        try {
+            ensureDelegate(app);
+            try {
+                ComponentHotplug.ensureComponentHotplugInstalled(app);
+            } catch (UnsupportedEnvironmentException e) {
+                throw new TinkerRuntimeException("failed to make sure that ComponentHotplug logic is fine.", e);
+            }
+            if (mApplicationLike != null) {
+                mApplicationLike.onCreate();
+            }
+        } catch (TinkerRuntimeException e) {
+            throw e;
+        } catch (Throwable thr) {
+            throw new TinkerRuntimeException(thr.getMessage(), thr);
+        }
+    }
+
+    @Override
+    public void onCreate(TinkerApplication app) {
+        onCreateImpl_$noinline$(app);
+    }
+
+    @Keep
+    private void onConfigurationChangedImpl_$noinline$(Configuration newConfig) {
+        try {
+            dummyThrowExceptionMethod();
+        } finally {
+            if (mApplicationLike != null) {
+                mApplicationLike.onConfigurationChanged(newConfig);
+            }
+        }
+    }
+
+    @Override
+    public void onConfigurationChanged(Configuration newConfig) {
+        onConfigurationChangedImpl_$noinline$(newConfig);
+    }
+
+    @Keep
+    private void onTrimMemoryImpl_$noinline$(int level) {
+        try {
+            dummyThrowExceptionMethod();
+        } finally {
+            if (mApplicationLike != null) {
+                mApplicationLike.onTrimMemory(level);
+            }
+        }
+    }
+
+    @Override
+    public void onTrimMemory(int level) {
+        onTrimMemoryImpl_$noinline$(level);
+    }
+
+    @Keep
+    private void onLowMemoryImpl_$noinline$() {
+        try {
+            dummyThrowExceptionMethod();
+        } finally {
+            if (mApplicationLike != null) {
+                mApplicationLike.onLowMemory();
+            }
+        }
+    }
+
+    @Override
+    public void onLowMemory() {
+        onLowMemoryImpl_$noinline$();
+    }
+
+    @Keep
+    private void onTerminateImpl_$noinline$() {
+        try {
+            dummyThrowExceptionMethod();
+        } finally {
+            if (mApplicationLike != null) {
+                mApplicationLike.onTerminate();
+            }
+        }
+    }
+
+    @Override
+    public void onTerminate() {
+        onTerminateImpl_$noinline$();
+    }
+
+    @Keep
+    private ClassLoader getClassLoaderImpl_$noinline$(ClassLoader cl) {
+        try {
+            dummyThrowExceptionMethod();
+        } finally {
+            if (mApplicationLike != null) {
+                return mApplicationLike.getClassLoader(cl);
+            } else {
+                return cl;
+            }
+        }
+    }
+
+    @Override
+    public ClassLoader getClassLoader(ClassLoader cl) {
+        return getClassLoaderImpl_$noinline$(cl);
+    }
+
+    @Keep
+    private Context getBaseContextImpl_$noinline$(Context base) {
+        try {
+            dummyThrowExceptionMethod();
+        } finally {
+            if (mApplicationLike != null) {
+                return mApplicationLike.getBaseContext(base);
+            } else {
+                return base;
+            }
+        }
+    }
+
+    @Override
+    public Context getBaseContext(Context base) {
+        return getBaseContextImpl_$noinline$(base);
+    }
+
+    @Keep
+    private AssetManager getAssetsImpl_$noinline$(AssetManager assets) {
+        try {
+            dummyThrowExceptionMethod();
+        } finally {
+            if (mApplicationLike != null) {
+                return mApplicationLike.getAssets(assets);
+            } else {
+                return assets;
+            }
+        }
+    }
+
+    @Override
+    public AssetManager getAssets(AssetManager assets) {
+        return getAssetsImpl_$noinline$(assets);
+    }
+
+    @Keep
+    private Resources getResourcesImpl_$noinline$(Resources res) {
+        try {
+            dummyThrowExceptionMethod();
+        } finally {
+            if (mApplicationLike != null) {
+                return mApplicationLike.getResources(res);
+            } else {
+                return res;
+            }
+        }
+    }
+
+    @Override
+    public Resources getResources(Resources res) {
+        return getResourcesImpl_$noinline$(res);
+    }
+
+    @Keep
+    private Object getSystemServiceImpl_$noinline$(String name, Object service) {
+        try {
+            dummyThrowExceptionMethod();
+        } finally {
+            if (mApplicationLike != null) {
+                return mApplicationLike.getSystemService(name, service);
+            } else {
+                return service;
+            }
+        }
+    }
+
+    @Override
+    public Object getSystemService(String name, Object service) {
+        return getSystemServiceImpl_$noinline$(name, service);
+    }
+}
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/library/TinkerLoadLibrary.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/library/TinkerLoadLibrary.java
index d2e86620..9ece0df5 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/library/TinkerLoadLibrary.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/library/TinkerLoadLibrary.java
@@ -144,23 +144,26 @@ public static boolean loadLibraryFromTinker(Context context, String relativePath
         //TODO we should add cpu abi, and the real path later
         if (tinker.isEnabledForNativeLib() && tinker.isTinkerLoaded()) {
             TinkerLoadResult loadResult = tinker.getTinkerLoadResultIfPresent();
-            if (loadResult.libs != null) {
-                for (String name : loadResult.libs.keySet()) {
-                    if (name.equals(relativeLibPath)) {
-                        String patchLibraryPath = loadResult.libraryDirectory + "/" + name;
-                        File library = new File(patchLibraryPath);
-                        if (library.exists()) {
-                            //whether we check md5 when load
-                            boolean verifyMd5 = tinker.isTinkerLoadVerify();
-                            if (verifyMd5 && !SharePatchFileUtil.verifyFileMd5(library, loadResult.libs.get(name))) {
-                                tinker.getLoadReporter().onLoadFileMd5Mismatch(library, ShareConstants.TYPE_LIBRARY);
-                            } else {
-                                System.load(patchLibraryPath);
-                                TinkerLog.i(TAG, "loadLibraryFromTinker success:" + patchLibraryPath);
-                                return true;
-                            }
-                        }
-                    }
+            if (loadResult.libs == null) {
+                return false;
+            }
+            for (String name : loadResult.libs.keySet()) {
+                if (!name.equals(relativeLibPath)) {
+                    continue;
+                }
+                String patchLibraryPath = loadResult.libraryDirectory + "/" + name;
+                File library = new File(patchLibraryPath);
+                if (!library.exists()) {
+                    continue;
+                }
+                //whether we check md5 when load
+                boolean verifyMd5 = tinker.isTinkerLoadVerify();
+                if (verifyMd5 && !SharePatchFileUtil.verifyFileMd5(library, loadResult.libs.get(name))) {
+                    tinker.getLoadReporter().onLoadFileMd5Mismatch(library, ShareConstants.TYPE_LIBRARY);
+                } else {
+                    System.load(patchLibraryPath);
+                    TinkerLog.i(TAG, "loadLibraryFromTinker success:" + patchLibraryPath);
+                    return true;
                 }
             }
         }
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/DefaultPatchListener.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/DefaultPatchListener.java
index 7feebcef..8aca7810 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/DefaultPatchListener.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/DefaultPatchListener.java
@@ -16,8 +16,14 @@
 
 package com.tencent.tinker.lib.listener;
 
+import android.content.ComponentName;
 import android.content.Context;
+import android.content.Intent;
+import android.content.ServiceConnection;
+import android.os.IBinder;
+import android.text.TextUtils;
 
+import com.tencent.tinker.lib.service.TinkerPatchForeService;
 import com.tencent.tinker.lib.service.TinkerPatchService;
 import com.tencent.tinker.lib.tinker.Tinker;
 import com.tencent.tinker.lib.tinker.TinkerLoadResult;
@@ -25,15 +31,19 @@
 import com.tencent.tinker.lib.util.UpgradePatchRetry;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
 import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
+import com.tencent.tinker.loader.shareutil.SharePatchInfo;
 import com.tencent.tinker.loader.shareutil.ShareTinkerInternals;
 
 import java.io.File;
 
+import static android.content.Context.BIND_AUTO_CREATE;
+
 /**
  * Created by zhangshaowen on 16/3/14.
  */
 public class DefaultPatchListener implements PatchListener {
     protected final Context context;
+    private ServiceConnection connection;
 
     public DefaultPatchListener(Context context) {
         this.context = context;
@@ -48,11 +58,11 @@ public DefaultPatchListener(Context context) {
      */
     @Override
     public int onPatchReceived(String path) {
-        File patchFile = new File(path);
-
-        int returnCode = patchCheck(path, SharePatchFileUtil.getMD5(patchFile));
-
+        final File patchFile = new File(path);
+        final String patchMD5 = SharePatchFileUtil.getMD5(patchFile);
+        final int returnCode = patchCheck(path, patchMD5);
         if (returnCode == ShareConstants.ERROR_PATCH_OK) {
+            runForgService();
             TinkerPatchService.runPatchService(context, path);
         } else {
             Tinker.with(context).getLoadReporter().onLoadPatchListenerReceiveFail(new File(path), returnCode);
@@ -60,14 +70,43 @@ public int onPatchReceived(String path) {
         return returnCode;
     }
 
+
+    private void runForgService() {
+        try {
+            connection = new ServiceConnection() {
+                @Override
+                public void onServiceConnected(ComponentName name, IBinder service) {
+                }
+
+                @Override
+                public void onServiceDisconnected(ComponentName name) {
+                    if (context != null && connection != null) {
+                        //Tinker在完成补丁后会尝试kill掉patch进程，如果不unbind会导致patch进程重启
+                        context.unbindService(connection);
+                    }
+                }
+
+                @Override
+                public void onBindingDied(ComponentName name) {
+                }
+            };
+            Intent innerForgIntent = new Intent(context, TinkerPatchForeService.class);
+            context.bindService(innerForgIntent, connection, BIND_AUTO_CREATE);
+        } catch (Throwable ex) {
+            //ignore forground service start error
+        }
+    }
+
     protected int patchCheck(String path, String patchMd5) {
-        Tinker manager = Tinker.with(context);
+        final Tinker manager = Tinker.with(context);
         //check SharePreferences also
         if (!manager.isTinkerEnabled() || !ShareTinkerInternals.isTinkerEnableWithSharedPreferences(context)) {
             return ShareConstants.ERROR_PATCH_DISABLE;
         }
-        File file = new File(path);
-
+        if (TextUtils.isEmpty(patchMd5)) {
+            return ShareConstants.ERROR_PATCH_NOTEXIST;
+        }
+        final File file = new File(path);
         if (!SharePatchFileUtil.isLegalFile(file)) {
             return ShareConstants.ERROR_PATCH_NOTEXIST;
         }
@@ -97,6 +136,21 @@ protected int patchCheck(String path, String patchMd5) {
             }
         }
 
+        // Hit if we have already applied patch but main process did not restart.
+        final String patchDirectory = manager.getPatchDirectory().getAbsolutePath();
+        File patchInfoLockFile = SharePatchFileUtil.getPatchInfoLockFile(patchDirectory);
+        File patchInfoFile = SharePatchFileUtil.getPatchInfoFile(patchDirectory);
+        try {
+            final SharePatchInfo currInfo = SharePatchInfo.readAndCheckPropertyWithLock(patchInfoFile, patchInfoLockFile);
+            if (currInfo != null && !ShareTinkerInternals.isNullOrNil(currInfo.newVersion) && !currInfo.isRemoveNewVersion) {
+                if (patchMd5.equals(currInfo.newVersion)) {
+                    return ShareConstants.ERROR_PATCH_ALREADY_APPLY;
+                }
+            }
+        } catch (Throwable ignored) {
+            // Ignored.
+        }
+
         if (!UpgradePatchRetry.getInstance(context).onPatchListenerCheck(patchMd5)) {
             return ShareConstants.ERROR_PATCH_RETRY_COUNT_LIMIT;
         }
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/ArkHotDiffPatchInternal.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/ArkHotDiffPatchInternal.java
new file mode 100644
index 00000000..d4640a63
--- /dev/null
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/ArkHotDiffPatchInternal.java
@@ -0,0 +1,110 @@
+/*
+ * Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the BSD 3-Clause License
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * the BSD 3-Clause License for more details.
+ */
+
+package com.tencent.tinker.lib.patch;
+
+import android.content.Context;
+
+import com.tencent.tinker.lib.tinker.Tinker;
+import com.tencent.tinker.lib.util.TinkerLog;
+import com.tencent.tinker.loader.TinkerRuntimeException;
+import com.tencent.tinker.loader.shareutil.ShareConstants;
+import com.tencent.tinker.loader.shareutil.ShareArkHotDiffPatchInfo;
+import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
+import com.tencent.tinker.loader.shareutil.ShareSecurityCheck;
+import com.tencent.tinker.loader.shareutil.ShareTinkerInternals;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipFile;
+
+public class ArkHotDiffPatchInternal extends BasePatchInternal {
+    private static final String TAG = "Tinker.ArkHotDiffPatchInternal";
+    private static ArrayList<ShareArkHotDiffPatchInfo> arkPatchList = new ArrayList<>();
+
+    protected static boolean tryRecoverArkHotLibrary(Tinker manager, ShareSecurityCheck checker, Context context,
+                                                     String patchVersionDirectory, File patchFile) {
+        String arkHotMeta = checker.getMetaContentMap().get(ARKHOT_META_FILE);
+        if (arkHotMeta == null) {
+            return true;
+        }
+
+        patchArkHotLibraryExtract(context, patchVersionDirectory, arkHotMeta, patchFile);
+
+        return true;
+    }
+
+    private static boolean extractArkHotLibrary(Context context, String dir, File patchFile, int type) {
+        Tinker manager = Tinker.with(context);
+        ZipFile patch = null;
+        try {
+            patch = new ZipFile(patchFile);
+
+            for (ShareArkHotDiffPatchInfo info : arkPatchList) {
+                final String path = info.path;
+                final String patchRealPath;
+                if (path.equals("")) {
+                    patchRealPath = info.name;
+                } else {
+                    patchRealPath = path + "/" + info.name;
+                }
+
+                final String md5 = info.patchMd5;
+                if (!SharePatchFileUtil.checkIfMd5Valid(md5)) {
+                    manager.getPatchReporter().onPatchPackageCheckFail(patchFile,
+                            BasePatchInternal.getMetaCorruptedCode(type));
+                    return false;
+                }
+
+                File extractedFile = new File(dir + info.name);
+                if (extractedFile.exists()) {
+                    if (md5.equals(SharePatchFileUtil.getMD5(extractedFile))) {
+                        continue;
+                    } else {
+                        extractedFile.delete();
+                    }
+                } else {
+                    extractedFile.getParentFile().mkdirs();
+                }
+
+                ZipEntry patchFileEntry = patch.getEntry(patchRealPath);
+                if (!extract(patch, patchFileEntry, extractedFile, md5, false)) {
+                    manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.name, type);
+                    return false;
+                }
+            }
+        } catch (IOException e) {
+            throw new TinkerRuntimeException("patch " + ShareTinkerInternals.getTypeString(type)
+                    + " extract failed (" + e.getMessage() + ").", e);
+        } finally {
+            SharePatchFileUtil.closeZip(patch);
+        }
+
+        return true;
+    }
+
+    private static boolean patchArkHotLibraryExtract(Context context, String patchVersionDirectory,
+                                                     String meta, File patchFile) {
+        String dir = patchVersionDirectory + "/" + ShareConstants.ARKHOTFIX_PATH + "/";
+
+        arkPatchList.clear();
+        ShareArkHotDiffPatchInfo.parseDiffPatchInfo(meta, arkPatchList);
+
+        if (!extractArkHotLibrary(context, dir, patchFile, TYPE_ARKHOT_SO)) {
+            return false;
+        }
+
+        return true;
+    }
+}
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/BasePatchInternal.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/BasePatchInternal.java
index 78c0e3be..17e5a2da 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/BasePatchInternal.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/BasePatchInternal.java
@@ -44,11 +44,13 @@
     protected static final String DEX_META_FILE        = ShareConstants.DEX_META_FILE;
     protected static final String SO_META_FILE         = ShareConstants.SO_META_FILE;
     protected static final String RES_META_FILE        = ShareConstants.RES_META_FILE;
+    protected static final String ARKHOT_META_FILE = ShareConstants.ARKHOT_META_FILE;
 
     protected static final int TYPE_DEX         = ShareConstants.TYPE_DEX;
-    protected static final int TYPE_Library     = ShareConstants.TYPE_LIBRARY;
+    protected static final int TYPE_LIBRARY     = ShareConstants.TYPE_LIBRARY;
     protected static final int TYPE_RESOURCE    = ShareConstants.TYPE_RESOURCE;
     protected static final int TYPE_CLASS_N_DEX = ShareConstants.TYPE_CLASS_N_DEX;
+    protected static final int TYPE_ARKHOT_SO = ShareConstants.TYPE_ARKHOT_SO;
 
 
     public static boolean extract(ZipFile zipFile, ZipEntry entryFile, File extractTo, String targetMd5, boolean isDex) throws IOException {
@@ -99,7 +101,7 @@ public static boolean extract(ZipFile zipFile, ZipEntry entryFile, File extractT
     public static int getMetaCorruptedCode(int type) {
         if (type == TYPE_DEX) {
             return ShareConstants.ERROR_PACKAGE_CHECK_DEX_META_CORRUPTED;
-        } else if (type == TYPE_Library) {
+        } else if (type == TYPE_LIBRARY) {
             return ShareConstants.ERROR_PACKAGE_CHECK_LIB_META_CORRUPTED;
         } else if (type == TYPE_RESOURCE) {
             return ShareConstants.ERROR_PACKAGE_CHECK_RESOURCE_META_CORRUPTED;
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/BsDiffPatchInternal.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/BsDiffPatchInternal.java
index 8a0b8a31..93f1fd1e 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/BsDiffPatchInternal.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/BsDiffPatchInternal.java
@@ -65,7 +65,7 @@ protected static boolean tryRecoverLibraryFiles(Tinker manager, ShareSecurityChe
 
     private static boolean patchLibraryExtractViaBsDiff(Context context, String patchVersionDirectory, String meta, File patchFile) {
         String dir = patchVersionDirectory + "/" + SO_PATH + "/";
-        return extractBsDiffInternals(context, dir, meta, patchFile, TYPE_Library);
+        return extractBsDiffInternals(context, dir, meta, patchFile, TYPE_LIBRARY);
     }
 
     private static boolean extractBsDiffInternals(Context context, String dir, String meta, File patchFile, int type) {
@@ -200,7 +200,6 @@ private static boolean extractBsDiffInternals(Context context, String dir, Strin
             }
 
         } catch (Throwable e) {
-//            e.printStackTrace();
             throw new TinkerRuntimeException("patch " + ShareTinkerInternals.getTypeString(type) + " extract failed (" + e.getMessage() + ").", e);
         } finally {
             SharePatchFileUtil.closeZip(apk);
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java
index d106fb81..5c2609cc 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java
@@ -175,10 +175,10 @@ private static boolean patchDexExtractViaDexDiff(Context context, String patchVe
         File dexFiles = new File(dir);
         File[] files = dexFiles.listFiles();
         List<File> legalFiles = new ArrayList<>();
-        // may have directory in android o
         if (files != null) {
             for (File file : files) {
                 final String fileName = file.getName();
+                // may have directory in android o
                 if (file.isFile()
                     &&  (fileName.endsWith(ShareConstants.DEX_SUFFIX)
                       || fileName.endsWith(ShareConstants.JAR_SUFFIX)
@@ -342,7 +342,7 @@ private static boolean dexOptimizeDexFiles(Context context, List<File> dexFiles,
 
             // try parallel dex optimizer
             TinkerDexOptimizer.optimizeAll(
-                    dexFiles, optimizeDexDirectoryFile,
+                context, dexFiles, optimizeDexDirectoryFile,
                 new TinkerDexOptimizer.ResultCallback() {
                     long startTime;
 
@@ -622,15 +622,15 @@ private static boolean extractDexToJar(ZipFile zipFile, ZipEntry entryFile, File
         return isExtractionSuccessful;
     }
 
-//    /**
-//     * reject dalvik vm, but sdk version is larger than 21
-//     */
-//    private static void checkVmArtProperty() {
-//        boolean art = ShareTinkerInternals.isVmArt();
-//        if (!art && Build.VERSION.SDK_INT >= 21) {
-//            throw new TinkerRuntimeException(ShareConstants.CHECK_VM_PROPERTY_FAIL + ", it is dalvik vm, but sdk version " + Build.VERSION.SDK_INT + " is larger than 21!");
-//        }
-//    }
+    // /**
+    //  * reject dalvik vm, but sdk version is larger than 21
+    //  */
+    // private static void checkVmArtProperty() {
+    //     boolean art = ShareTinkerInternals.isVmArt();
+    //     if (!art && Build.VERSION.SDK_INT >= 21) {
+    //         throw new TinkerRuntimeException(ShareConstants.CHECK_VM_PROPERTY_FAIL + ", it is dalvik vm, but sdk version " + Build.VERSION.SDK_INT + " is larger than 21!");
+    //     }
+    // }
 
     private static boolean extractDexFile(ZipFile zipFile, ZipEntry entryFile, File extractTo, ShareDexDiffPatchInfo dexInfo) throws IOException {
         final String fileMd5 = isVmArt ? dexInfo.destMd5InArt : dexInfo.destMd5InDvm;
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/ResDiffPatchInternal.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/ResDiffPatchInternal.java
index cfd9ebf9..f8162c6a 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/ResDiffPatchInternal.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/ResDiffPatchInternal.java
@@ -230,7 +230,6 @@ private static boolean extractResourceDiffInternals(Context context, String dir,
 
             TinkerLog.i(TAG, "final new resource file:%s, entry count:%d, size:%d", resOutput.getAbsolutePath(), totalEntryCount, resOutput.length());
         } catch (Throwable e) {
-//            e.printStackTrace();
             throw new TinkerRuntimeException("patch " + ShareTinkerInternals.getTypeString(type) +  " extract failed (" + e.getMessage() + ").", e);
         }
         return true;
@@ -302,7 +301,7 @@ private static boolean checkAndExtractResourceLargeFile(Context context, String
                 largeModeInfo.file = new File(tempFileDirtory, name);
                 SharePatchFileUtil.ensureFileDirectory(largeModeInfo.file);
 
-                //we do not check the intermediate files' md5 to save time, use check whether it is 32 length
+                // we do not check the intermediate files' md5 to save time, use check whether it is 32 length
                 if (!SharePatchFileUtil.checkIfMd5Valid(largeModeInfo.md5)) {
                     TinkerLog.w(TAG, "resource meta file md5 mismatch, type:%s, name: %s, md5: %s", ShareTinkerInternals.getTypeString(type), name, largeModeInfo.md5);
                     manager.getPatchReporter().onPatchPackageCheckFail(patchFile, BasePatchInternal.getMetaCorruptedCode(type));
@@ -331,7 +330,7 @@ private static boolean checkAndExtractResourceLargeFile(Context context, String
                     StreamUtil.closeQuietly(oldStream);
                     StreamUtil.closeQuietly(newStream);
                 }
-                //go go go bsdiff get the
+                // go go go bsdiff get the
                 if (!SharePatchFileUtil.verifyFileMd5(largeModeInfo.file, largeModeInfo.md5)) {
                     TinkerLog.w(TAG, "Failed to recover large modify file:%s", largeModeInfo.file.getPath());
                     SharePatchFileUtil.safeDeleteFile(largeModeInfo.file);
@@ -342,7 +341,6 @@ private static boolean checkAndExtractResourceLargeFile(Context context, String
             }
             TinkerLog.w(TAG, "success recover all large modify and store resources use time:%d", (System.currentTimeMillis() - start));
         } catch (Throwable e) {
-//            e.printStackTrace();
             throw new TinkerRuntimeException("patch " + ShareTinkerInternals.getTypeString(type) +  " extract failed (" + e.getMessage() + ").", e);
         } finally {
             SharePatchFileUtil.closeZip(apkFile);
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/UpgradePatch.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/UpgradePatch.java
index f60425de..bc87107e 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/UpgradePatch.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/UpgradePatch.java
@@ -22,6 +22,7 @@
 import com.tencent.tinker.lib.service.PatchResult;
 import com.tencent.tinker.lib.tinker.Tinker;
 import com.tencent.tinker.lib.util.TinkerLog;
+import com.tencent.tinker.lib.util.UpgradePatchRetry;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
 import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
 import com.tencent.tinker.loader.shareutil.SharePatchInfo;
@@ -30,6 +31,7 @@
 
 import java.io.File;
 import java.io.IOException;
+import java.util.Map;
 
 
 /**
@@ -80,6 +82,15 @@ public boolean tryPatch(Context context, String tempPatchPath, PatchResult patch
         File patchInfoLockFile = SharePatchFileUtil.getPatchInfoLockFile(patchDirectory);
         File patchInfoFile = SharePatchFileUtil.getPatchInfoFile(patchDirectory);
 
+        final Map<String, String> pkgProps = signatureCheck.getPackagePropertiesIfPresent();
+        if (pkgProps == null) {
+            TinkerLog.e(TAG, "UpgradePatch packageProperties is null, do we process a valid patch apk ?");
+            return false;
+        }
+
+        final String isProtectedAppStr = pkgProps.get(ShareConstants.PKGMETA_KEY_IS_PROTECTED_APP);
+        final boolean isProtectedApp = (isProtectedAppStr != null && !isProtectedAppStr.isEmpty() && !"0".equals(isProtectedAppStr));
+
         SharePatchInfo oldInfo = SharePatchInfo.readAndCheckPropertyWithLock(patchInfoFile, patchInfoLockFile);
 
         //it is a new patch, so we should not find a exist
@@ -93,6 +104,16 @@ public boolean tryPatch(Context context, String tempPatchPath, PatchResult patch
                 return false;
             }
 
+            if (!ShareTinkerInternals.isNullOrNil(oldInfo.newVersion) && oldInfo.newVersion.equals(patchMd5) && !oldInfo.isRemoveNewVersion) {
+                TinkerLog.e(TAG, "patch already applied, md5: %s", patchMd5);
+
+                // Reset patch apply retry count to let us be able to reapply without triggering
+                // patch apply disable when we apply it successfully previously.
+                UpgradePatchRetry.getInstance(context).onPatchResetMaxCheck(patchMd5);
+
+                return true;
+            }
+
             if (!SharePatchFileUtil.checkIfMd5Valid(patchMd5)) {
                 TinkerLog.e(TAG, "UpgradePatch tryPatch:onPatchVersionCheckFail md5 %s is valid", patchMd5);
                 manager.getPatchReporter().onPatchVersionCheckFail(patchFile, oldInfo, patchMd5);
@@ -101,14 +122,14 @@ public boolean tryPatch(Context context, String tempPatchPath, PatchResult patch
             // if it is interpret now, use changing flag to wait main process
             final String finalOatDir = oldInfo.oatDir.equals(ShareConstants.INTERPRET_DEX_OPTIMIZE_PATH)
                 ? ShareConstants.CHANING_DEX_OPTIMIZE_PATH : oldInfo.oatDir;
-            newInfo = new SharePatchInfo(oldInfo.oldVersion, patchMd5, false, Build.FINGERPRINT, finalOatDir);
+            newInfo = new SharePatchInfo(oldInfo.oldVersion, patchMd5, isProtectedApp, false, Build.FINGERPRINT, finalOatDir);
         } else {
-            newInfo = new SharePatchInfo("", patchMd5, false, Build.FINGERPRINT, ShareConstants.DEFAULT_DEX_OPTIMIZE_PATH);
+            newInfo = new SharePatchInfo("", patchMd5, isProtectedApp, false, Build.FINGERPRINT, ShareConstants.DEFAULT_DEX_OPTIMIZE_PATH);
         }
 
-        //it is a new patch, we first delete if there is any files
-        //don't delete dir for faster retry
-//        SharePatchFileUtil.deleteDir(patchVersionDirectory);
+        // it is a new patch, we first delete if there is any files
+        // don't delete dir for faster retry
+        // SharePatchFileUtil.deleteDir(patchVersionDirectory);
         final String patchName = SharePatchFileUtil.getPatchVersionDirectory(patchMd5);
 
         final String patchVersionDirectory = patchDirectory + "/" + patchName;
@@ -126,7 +147,6 @@ public boolean tryPatch(Context context, String tempPatchPath, PatchResult patch
                     destPatchFile.getAbsolutePath(), destPatchFile.length());
             }
         } catch (IOException e) {
-//            e.printStackTrace();
             TinkerLog.e(TAG, "UpgradePatch tryPatch:copy patch file fail from %s to %s", patchFile.getPath(), destPatchFile.getPath());
             manager.getPatchReporter().onPatchTypeExtractFail(patchFile, destPatchFile, patchFile.getName(), ShareConstants.TYPE_PATCH_FILE);
             return false;
@@ -138,6 +158,11 @@ public boolean tryPatch(Context context, String tempPatchPath, PatchResult patch
             return false;
         }
 
+        if (!ArkHotDiffPatchInternal.tryRecoverArkHotLibrary(manager, signatureCheck,
+                context, patchVersionDirectory, destPatchFile)) {
+            return false;
+        }
+
         if (!BsDiffPatchInternal.tryRecoverLibraryFiles(manager, signatureCheck, context, patchVersionDirectory, destPatchFile)) {
             TinkerLog.e(TAG, "UpgradePatch tryPatch:new patch recover, try patch library failed");
             return false;
@@ -160,6 +185,10 @@ public boolean tryPatch(Context context, String tempPatchPath, PatchResult patch
             return false;
         }
 
+        // Reset patch apply retry count to let us be able to reapply without triggering
+        // patch apply disable when we apply it successfully previously.
+        UpgradePatchRetry.getInstance(context).onPatchResetMaxCheck(patchMd5);
+
         TinkerLog.w(TAG, "UpgradePatch tryPatch: done, it is ok");
         return true;
     }
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultLoadReporter.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultLoadReporter.java
index 902c19c7..058c929b 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultLoadReporter.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultLoadReporter.java
@@ -92,15 +92,15 @@ public void onLoadPatchVersionChanged(String oldVersion, String newVersion, File
             return;
         }
 
-        // Unnecessary now. Since other processes are killed in TinkerLoader.
-//        TinkerLog.i(TAG, "onLoadPatchVersionChanged, try kill all other process");
-        // kill all other process to ensure that all process's code is the same.
-//        ShareTinkerInternals.killAllOtherProcess(context);
+        // // Unnecessary now. Since other processes are killed in TinkerLoader.
+        // TinkerLog.i(TAG, "onLoadPatchVersionChanged, try kill all other process");
+        // // kill all other process to ensure that all process's code is the same.
+        // ShareTinkerInternals.killAllOtherProcess(context);
 
         // reset retry count to 1, for interpret retry
         UpgradePatchRetry.getInstance(context).onPatchResetMaxCheck(newVersion);
 
-        //delete old patch files
+        // delete old patch files
         File[] files = patchDirectoryFile.listFiles();
         if (files != null) {
             for (File file : files) {
@@ -135,6 +135,8 @@ public void onLoadInterpret(int type, Throwable e) {
             case ShareConstants.TYPE_INTERPRET_OK:
                 TinkerLog.i(TAG, "patch loadReporter onLoadInterpret ok");
                 break;
+            default:
+                break;
         }
 
         retryPatch();
@@ -270,6 +272,8 @@ public void onLoadException(Throwable e, int errorCode) {
                 TinkerLog.i(TAG, "patch loadReporter onLoadException: patch load unknown exception: %s", e);
                 //exception can be caught, it is no need to disable Tinker with sharedPreference
                 break;
+            default:
+                break;
         }
         TinkerLog.e(TAG, "tinker load exception, welcome to submit issue to us: https://github.com/Tencent/tinker/issues");
         TinkerLog.printErrStackTrace(TAG, e, "tinker load exception");
@@ -337,10 +341,10 @@ public boolean retryPatch() {
                 TinkerInstaller.onReceiveUpgradePatch(context, patchVersionFile.getAbsolutePath());
                 return true;
             }
-//          else {
-//                TinkerLog.i(TAG, "repair retry exceed must max time, just clean");
-//                checkAndCleanPatch();
-//            }
+            // else {
+            //       TinkerLog.i(TAG, "repair retry exceed must max time, just clean");
+            //       checkAndCleanPatch();
+            // }
         }
 
         return false;
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultPatchReporter.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultPatchReporter.java
index b1421c48..e3d31fd2 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultPatchReporter.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultPatchReporter.java
@@ -197,10 +197,10 @@ public void onPatchException(File patchFile, Throwable e) {
         TinkerLog.i(TAG, "patchReporter onPatchException: patch exception path: %s, throwable: %s",
             patchFile.getAbsolutePath(), e.getMessage());
         TinkerLog.e(TAG, "tinker patch exception, welcome to submit issue to us: https://github.com/Tencent/tinker/issues");
-//        if (e.getMessage().contains(ShareConstants.CHECK_VM_PROPERTY_FAIL)) {
-//            ShareTinkerInternals.setTinkerDisableWithSharedPreferences(context);
-//            TinkerLog.i(TAG, "check vm property exception disable tinker forever with sp");
-//        }
+        // if (e.getMessage().contains(ShareConstants.CHECK_VM_PROPERTY_FAIL)) {
+        //     ShareTinkerInternals.setTinkerDisableWithSharedPreferences(context);
+        //     TinkerLog.i(TAG, "check vm property exception disable tinker forever with sp");
+        // }
         TinkerLog.printErrStackTrace(TAG, e, "tinker patch exception");
         //don't accept request any more!
         Tinker.with(context).setTinkerDisable();
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/AbstractResultService.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/AbstractResultService.java
index f3b0d073..721934a9 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/AbstractResultService.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/AbstractResultService.java
@@ -16,52 +16,41 @@
 
 package com.tencent.tinker.lib.service;
 
-import android.content.ComponentName;
+import android.app.IntentService;
 import android.content.Context;
 import android.content.Intent;
-import android.support.annotation.NonNull;
-import com.tencent.tinker.lib.util.TinkerJobIntentService;
 
 import com.tencent.tinker.lib.util.TinkerLog;
-import com.tencent.tinker.loader.BuildConfig;
 import com.tencent.tinker.loader.TinkerRuntimeException;
 import com.tencent.tinker.loader.shareutil.ShareIntentUtil;
 
 /**
  * Created by zhangshaowen on 16/3/14.
  */
-public abstract class AbstractResultService extends TinkerJobIntentService {
+public abstract class AbstractResultService extends IntentService {
     private static final String TAG = "Tinker.AbstractResultService";
-    private static final int JOB_ID = 0xf3f4f5f6;
 
     private static final String RESULT_EXTRA = "result_extra";
 
+    public AbstractResultService() {
+        super("TinkerResultService");
+    }
+
     public static void runResultService(Context context, PatchResult result, String resultServiceClass) {
         if (resultServiceClass == null) {
             throw new TinkerRuntimeException("resultServiceClass is null.");
         }
-        try {
-            if (!TinkerJobIntentService.class.isAssignableFrom(Class.forName(resultServiceClass))) {
-                throw new TinkerRuntimeException("on tinker version " + BuildConfig.TINKER_VERSION + " result service class must inherit from TinkerJobIntentService.");
-            }
-        } catch (ClassNotFoundException e) {
-            throw new TinkerRuntimeException("cannot find result service class: " + resultServiceClass, e);
-        }
         try {
             Intent intent = new Intent();
             intent.setClassName(context, resultServiceClass);
             intent.putExtra(RESULT_EXTRA, result);
-            enqueueWork(context, new ComponentName(context, resultServiceClass), JOB_ID, intent);
+            context.startService(intent);
         } catch (Throwable throwable) {
             TinkerLog.e(TAG, "run result service fail, exception:" + throwable);
         }
     }
 
     @Override
-    protected void onHandleWork(@NonNull Intent intent) {
-        onHandleIntent(intent);
-    }
-
     protected void onHandleIntent(Intent intent) {
         if (intent == null) {
             TinkerLog.e(TAG, "AbstractResultService received a null intent, ignoring.");
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/TinkerPatchForeService.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/TinkerPatchForeService.java
new file mode 100644
index 00000000..e6149eb1
--- /dev/null
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/TinkerPatchForeService.java
@@ -0,0 +1,23 @@
+package com.tencent.tinker.lib.service;
+
+import android.app.Service;
+import android.content.Intent;
+import android.os.IBinder;
+import android.os.RemoteException;
+
+import com.tencent.tinker.lib.IForeService;
+
+public class TinkerPatchForeService extends Service {
+    public TinkerPatchForeService() {
+    }
+
+    @Override
+    public IBinder onBind(Intent intent) {
+        return new IForeService.Stub() {
+            @Override
+            public void startme() throws RemoteException {
+                //占位使用，不做具体操作
+            }
+        };
+    }
+}
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/TinkerPatchService.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/TinkerPatchService.java
index d07c3143..1c2ff642 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/TinkerPatchService.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/TinkerPatchService.java
@@ -16,6 +16,7 @@
 
 package com.tencent.tinker.lib.service;
 
+import android.app.IntentService;
 import android.app.Notification;
 import android.app.Service;
 import android.content.Context;
@@ -23,10 +24,10 @@
 import android.os.Build;
 import android.os.IBinder;
 import android.os.SystemClock;
+import android.support.annotation.Nullable;
 
 import com.tencent.tinker.lib.patch.AbstractPatch;
 import com.tencent.tinker.lib.tinker.Tinker;
-import com.tencent.tinker.lib.util.TinkerJobIntentService;
 import com.tencent.tinker.lib.util.TinkerLog;
 import com.tencent.tinker.loader.TinkerRuntimeException;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
@@ -38,11 +39,9 @@
 /**
  * Created by zhangshaowen on 16/3/14.
  */
-public class TinkerPatchService extends TinkerJobIntentService {
+public class TinkerPatchService extends IntentService {
     private static final String TAG = "Tinker.TinkerPatchService";
 
-    private static final int JOB_ID = 0xf0f1f2f3;
-
     private static final String PATCH_PATH_EXTRA = "patch_path_extra";
     private static final String RESULT_CLASS_EXTRA = "patch_result_class";
 
@@ -50,13 +49,17 @@
     private static int notificationId = ShareConstants.TINKER_PATCH_SERVICE_NOTIFICATION;
     private static Class<? extends AbstractResultService> resultServiceClass = null;
 
+    public TinkerPatchService() {
+        super("TinkerPatchService");
+    }
+
     public static void runPatchService(final Context context, final String path) {
         TinkerLog.i(TAG, "run patch service...");
         Intent intent = new Intent(context, TinkerPatchService.class);
         intent.putExtra(PATCH_PATH_EXTRA, path);
         intent.putExtra(RESULT_CLASS_EXTRA, resultServiceClass.getName());
         try {
-            enqueueWork(context, TinkerPatchService.class, JOB_ID, intent);
+            context.startService(intent);
         } catch (Throwable thr) {
             TinkerLog.e(TAG, "run patch service fail, exception:" + thr);
         }
@@ -69,7 +72,7 @@ public static void setPatchProcessor(AbstractPatch upgradePatch, Class<? extends
         try {
             Class.forName(serviceClass.getName());
         } catch (ClassNotFoundException e) {
-//            e.printStackTrace();
+            TinkerLog.printErrStackTrace(TAG, e, "patch processor class not found.");
         }
     }
 
@@ -87,6 +90,12 @@ public static String getPatchResultExtra(Intent intent) {
         return ShareIntentUtil.getStringExtra(intent, RESULT_CLASS_EXTRA);
     }
 
+    @Override
+    protected void onHandleIntent(@Nullable Intent intent) {
+        increasingPriority();
+        doApplyPatch(this, intent);
+    }
+
     /**
      * set the tinker notification id you want
      * @param id
@@ -137,8 +146,8 @@ private static void doApplyPatch(Context context, Intent intent) {
         }
 
         cost = SystemClock.elapsedRealtime() - begin;
-        tinker.getPatchReporter().
-            onPatchResult(patchFile, result, cost);
+        tinker.getPatchReporter()
+                .onPatchResult(patchFile, result, cost);
 
         patchResult.isSuccess = result;
         patchResult.rawPatchFilePath = path;
@@ -150,12 +159,6 @@ private static void doApplyPatch(Context context, Intent intent) {
         sIsPatchApplying.set(false);
     }
 
-    @Override
-    protected void onHandleWork(Intent intent) {
-        increasingPriority();
-        doApplyPatch(this, intent);
-    }
-
     private void increasingPriority() {
         if (Build.VERSION.SDK_INT >= 26) {
             TinkerLog.i(TAG, "for system version >= Android O, we just ignore increasingPriority "
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerLoadResult.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerLoadResult.java
index 5828798b..3ded4f22 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerLoadResult.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerLoadResult.java
@@ -113,7 +113,8 @@ public boolean parseTinkerResult(Context context, Intent intentResult) {
                 resourceDirectory = new File(patchVersionDirectory, ShareConstants.RES_PATH);
                 resourceFile = new File(resourceDirectory, ShareConstants.RES_NAME);
             }
-            patchInfo = new SharePatchInfo(oldVersion, newVersion, false, Build.FINGERPRINT, oatDir);
+            final boolean isProtectedApp = ShareIntentUtil.getBooleanExtra(intentResult, ShareIntentUtil.INTENT_IS_PROTECTED_APP, false);
+            patchInfo = new SharePatchInfo(oldVersion, newVersion, isProtectedApp, false, Build.FINGERPRINT, oatDir);
             versionChanged = !(oldVersion.equals(newVersion));
         }
 
@@ -135,6 +136,8 @@ public boolean parseTinkerResult(Context context, Intent intentResult) {
                 case ShareConstants.ERROR_LOAD_PATCH_UNCAUGHT_EXCEPTION:
                     errorCode = ShareConstants.ERROR_LOAD_EXCEPTION_UNCAUGHT;
                     break;
+                default:
+                    break;
             }
             tinker.getLoadReporter().onLoadException(exception, errorCode);
             return false;
@@ -144,13 +147,12 @@ public boolean parseTinkerResult(Context context, Intent intentResult) {
             case ShareConstants.ERROR_LOAD_GET_INTENT_FAIL:
                 TinkerLog.e(TAG, "can't get the right intent return code");
                 throw new TinkerRuntimeException("can't get the right intent return code");
-//                    break;
             case ShareConstants.ERROR_LOAD_DISABLE:
                 TinkerLog.w(TAG, "tinker is disable, just return");
                 break;
-//            case ShareConstants.ERROR_LOAD_PATCH_NOT_SUPPORTED:
-//                TinkerLog.w(TAG, "tinker is not supported, just return");
-//                break;
+            // case ShareConstants.ERROR_LOAD_PATCH_NOT_SUPPORTED:
+            //     TinkerLog.w(TAG, "tinker is not supported, just return");
+            //     break;
             case ShareConstants.ERROR_LOAD_PATCH_DIRECTORY_NOT_EXIST:
             case ShareConstants.ERROR_LOAD_PATCH_INFO_NOT_EXIST:
                 TinkerLog.w(TAG, "can't find patch file, is ok, just return");
@@ -210,8 +212,8 @@ public boolean parseTinkerResult(Context context, Intent intentResult) {
                 } else {
                     TinkerLog.e(TAG, "patch dex file not found, but path is null!!!!");
                     throw new TinkerRuntimeException("patch dex file not found, but path is null!!!!");
-//                        tinker.getLoadReporter().onLoadFileNotFound(null,
-//                            ShareConstants.TYPE_DEX, false);
+                    // tinker.getLoadReporter().onLoadFileNotFound(null,
+                    //     ShareConstants.TYPE_DEX, false);
                 }
                 break;
             case ShareConstants.ERROR_LOAD_PATCH_VERSION_DEX_OPT_FILE_NOT_EXIST:
@@ -226,8 +228,8 @@ public boolean parseTinkerResult(Context context, Intent intentResult) {
                 } else {
                     TinkerLog.e(TAG, "patch dex opt file not found, but path is null!!!!");
                     throw new TinkerRuntimeException("patch dex opt file not found, but path is null!!!!");
-//                        tinker.getLoadReporter().onLoadFileNotFound(null,
-//                            ShareConstants.TYPE_DEX, false);
+                    // tinker.getLoadReporter().onLoadFileNotFound(null,
+                    //     ShareConstants.TYPE_DEX, false);
                 }
                 break;
             case ShareConstants.ERROR_LOAD_PATCH_VERSION_LIB_DIRECTORY_NOT_EXIST:
@@ -240,8 +242,8 @@ public boolean parseTinkerResult(Context context, Intent intentResult) {
                     TinkerLog.e(TAG, "patch lib file directory not found, warning why the path is null!!!!");
                     throw new TinkerRuntimeException("patch lib file directory not found, warning why the path is null!!!!");
 
-//                        tinker.getLoadReporter().onLoadFileNotFound(null,
-//                            ShareConstants.TYPE_LIBRARY, true);
+                    // tinker.getLoadReporter().onLoadFileNotFound(null,
+                    //     ShareConstants.TYPE_LIBRARY, true);
                 }
 
                 break;
@@ -256,8 +258,8 @@ public boolean parseTinkerResult(Context context, Intent intentResult) {
                 } else {
                     TinkerLog.e(TAG, "patch lib file not found, but path is null!!!!");
                     throw new TinkerRuntimeException("patch lib file not found, but path is null!!!!");
-//                        tinker.getLoadReporter().onLoadFileNotFound(null,
-//                            ShareConstants.TYPE_LIBRARY, false);
+                    // tinker.getLoadReporter().onLoadFileNotFound(null,
+                    //     ShareConstants.TYPE_LIBRARY, false);
                 }
                 break;
             case ShareConstants.ERROR_LOAD_PATCH_VERSION_DEX_CLASSLOADER_NULL:
@@ -320,7 +322,7 @@ public boolean parseTinkerResult(Context context, Intent intentResult) {
             case ShareConstants.ERROR_LOAD_OK:
                 TinkerLog.i(TAG, "oh yeah, tinker load all success");
                 tinker.setTinkerLoaded(true);
-                //get load dex
+                // get load dex
                 dexes = ShareIntentUtil.getIntentPatchDexPaths(intentResult);
                 libs = ShareIntentUtil.getIntentPatchLibsPaths(intentResult);
 
@@ -334,6 +336,8 @@ public boolean parseTinkerResult(Context context, Intent intentResult) {
                     tinker.getLoadReporter().onLoadPatchVersionChanged(oldVersion, newVersion, patchDirectory, patchVersionDirectory.getName());
                 }
                 return true;
+            default:
+                break;
         }
         return false;
 
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/TinkerJobIntentService.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/TinkerJobIntentService.java
deleted file mode 100644
index 63d0303b..00000000
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/TinkerJobIntentService.java
+++ /dev/null
@@ -1,677 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.tencent.tinker.lib.util;
-
-import android.Manifest;
-import android.annotation.TargetApi;
-import android.app.Service;
-import android.app.job.JobInfo;
-import android.app.job.JobParameters;
-import android.app.job.JobScheduler;
-import android.app.job.JobServiceEngine;
-import android.app.job.JobWorkItem;
-import android.content.ComponentName;
-import android.content.Context;
-import android.content.Intent;
-import android.content.pm.PackageManager;
-import android.os.AsyncTask;
-import android.os.Build;
-import android.os.IBinder;
-import android.os.PowerManager;
-import android.os.Process;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
-import android.support.annotation.RequiresApi;
-import android.util.Log;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-
-/**
- * This class is copied and renamed from JobIntentService in android support compat
- * library 28.0.0-alpha1. Some changes was made for adapting Tinker's specific usage.
- *
- * Since We can't get rid of the resources dependencies that android support compat library
- * has to include with, instead of hacking into the gradle dependency mechanism We choose to
- * copy what we need directly. Copy with renaming is to avoid conflicting when developers
- * happen to include android support compat library which has the same class in their App.
- *
- * Helper for processing work that has been enqueued for a job/service.  When running on
- * {@link android.os.Build.VERSION_CODES#O Android O} or later, the work will be dispatched
- * as a job via {@link android.app.job.JobScheduler#enqueue JobScheduler.enqueue}.  When running
- * on older versions of the platform, it will use
- * {@link android.content.Context#startService Context.startService}.
- *
- * <p>You must publish your subclass in your manifest for the system to interact with.  This
- * should be published as a {@link android.app.job.JobService}, as described for that class,
- * since on O and later platforms it will be executed that way.</p>
- *
- * <p>Use {@link #enqueueWork(Context, Class, int, Intent)} to enqueue new work to be
- * dispatched to and handled by your service.  It will be executed in
- * {@link #onHandleWork(Intent)}.</p>
- *
- * <p>You do not need to use {@link android.support.v4.content.WakefulBroadcastReceiver}
- * when using this class.  When running on {@link android.os.Build.VERSION_CODES#O Android O},
- * the JobScheduler will take care of wake locks for you (holding a wake lock from the time
- * you enqueue work until the job has been dispatched and while it is running).  When running
- * on previous versions of the platform, this wake lock handling is emulated in the class here
- * by directly calling the PowerManager; this means the application must request the
- * {@link android.Manifest.permission#WAKE_LOCK} permission.</p>
- *
- * <p>There are a few important differences in behavior when running on
- * {@link android.os.Build.VERSION_CODES#O Android O} or later as a Job vs. pre-O:</p>
- *
- * <ul>
- *     <li><p>When running as a pre-O service, the act of enqueueing work will generally start
- *     the service immediately, regardless of whether the device is dozing or in other
- *     conditions.  When running as a Job, it will be subject to standard JobScheduler
- *     policies for a Job with a {@link android.app.job.JobInfo.Builder#setOverrideDeadline(long)}
- *     of 0: the job will not run while the device is dozing, it may get delayed more than
- *     a service if the device is under strong memory pressure with lots of demand to run
- *     jobs.</p></li>
- *     <li><p>When running as a pre-O service, the normal service execution semantics apply:
- *     the service can run indefinitely, though the longer it runs the more likely the system
- *     will be to outright kill its process, and under memory pressure one should expect
- *     the process to be killed even of recently started services.  When running as a Job,
- *     the typical {@link android.app.job.JobService} execution time limit will apply, after
- *     which the job will be stopped (cleanly, not by killing the process) and rescheduled
- *     to continue its execution later.  Job are generally not killed when the system is
- *     under memory pressure, since the number of concurrent jobs is adjusted based on the
- *     memory state of the device.</p></li>
- * </ul>
- *
- * <p>Here is an example implementation of this class:</p>
- *
- * {@sample frameworks/support/samples/Support4Demos/src/main/java/com/example/android/supportv4/app/SimpleJobIntentService.java
- *      complete}
- */
-public abstract class TinkerJobIntentService extends Service {
-    static final String TAG = "TinkerJobIntentService";
-
-    static final boolean DEBUG = false;
-
-    CompatJobEngine mJobImpl;
-    WorkEnqueuer mCompatWorkEnqueuer;
-    CommandProcessor mCurProcessor;
-    boolean mInterruptIfStopped = false;
-    boolean mStopped = false;
-    boolean mDestroyed = false;
-
-    final ArrayList<CompatWorkItem> mCompatQueue;
-
-    static final Object sLock = new Object();
-    static final HashMap<ComponentName, WorkEnqueuer> sClassWorkEnqueuer = new HashMap<>();
-
-    /**
-     * Base class for the target service we can deliver work to and the implementation of
-     * how to deliver that work.
-     */
-    abstract static class WorkEnqueuer {
-        final ComponentName mComponentName;
-
-        boolean mHasJobId;
-        int mJobId;
-
-        WorkEnqueuer(Context context, ComponentName cn) {
-            mComponentName = cn;
-        }
-
-        void ensureJobId(int jobId) {
-            if (!mHasJobId) {
-                mHasJobId = true;
-                mJobId = jobId;
-            } else if (mJobId != jobId) {
-                throw new IllegalArgumentException("Given job ID " + jobId
-                        + " is different than previous " + mJobId);
-            }
-        }
-
-        abstract void enqueueWork(Intent work);
-
-        public void serviceStartReceived() {
-        }
-
-        public void serviceProcessingStarted() {
-        }
-
-        public void serviceProcessingFinished() {
-        }
-    }
-
-    /**
-     * Get rid of lint warnings about API levels.
-     */
-    interface CompatJobEngine {
-        IBinder compatGetBinder();
-        GenericWorkItem dequeueWork();
-    }
-
-    /**
-     * An implementation of WorkEnqueuer that works for pre-O (raw Service-based).
-     */
-    static final class CompatWorkEnqueuer extends WorkEnqueuer {
-        private final Context mContext;
-        private final PowerManager.WakeLock mLaunchWakeLock;
-        private final PowerManager.WakeLock mRunWakeLock;
-        boolean mLaunchingService;
-        boolean mServiceProcessing;
-
-        CompatWorkEnqueuer(Context context, ComponentName cn) {
-            super(context, cn);
-            mContext = context.getApplicationContext();
-            if (mContext.checkPermission(Manifest.permission.WAKE_LOCK, Process.myPid(), Process.myUid()) == PackageManager.PERMISSION_GRANTED) {
-                // Make wake locks.  We need two, because the launch wake lock wants to have
-                // a timeout, and the system does not do the right thing if you mix timeout and
-                // non timeout (or even changing the timeout duration) in one wake lock.
-                PowerManager pm = ((PowerManager) context.getSystemService(Context.POWER_SERVICE));
-                mLaunchWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, cn.getClassName() + ":launch");
-                mLaunchWakeLock.setReferenceCounted(false);
-                mRunWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, cn.getClassName() + ":run");
-                mRunWakeLock.setReferenceCounted(false);
-            } else {
-                TinkerLog.w(TAG, "it would be better to grant WAKE_LOCK permission to your app so that tinker can use WakeLock to keep system awake.");
-                mLaunchWakeLock = mRunWakeLock = null;
-            }
-        }
-
-        @Override
-        void enqueueWork(Intent work) {
-            Intent intent = new Intent(work);
-            intent.setComponent(mComponentName);
-            if (DEBUG) Log.d(TAG, "Starting service for work: " + work);
-            if (mContext.startService(intent) != null) {
-                synchronized (this) {
-                    if (!mLaunchingService) {
-                        mLaunchingService = true;
-                        if (!mServiceProcessing && mLaunchWakeLock != null) {
-                            // If the service is not already holding the wake lock for
-                            // itself, acquire it now to keep the system running until
-                            // we get this work dispatched.  We use a timeout here to
-                            // protect against whatever problem may cause it to not get
-                            // the work.
-                            mLaunchWakeLock.acquire(60 * 1000);
-                        }
-                    }
-                }
-            }
-        }
-
-        @Override
-        public void serviceStartReceived() {
-            synchronized (this) {
-                // Once we have started processing work, we can count whatever last
-                // enqueueWork() that happened as handled.
-                mLaunchingService = false;
-            }
-        }
-
-        @Override
-        public void serviceProcessingStarted() {
-            synchronized (this) {
-                // We hold the wake lock as long as the service is processing commands.
-                if (!mServiceProcessing) {
-                    mServiceProcessing = true;
-                    // Keep the device awake, but only for at most 10 minutes at a time
-                    // (Similar to JobScheduler.)
-                    if (mRunWakeLock != null) {
-                        mRunWakeLock.acquire(10 * 60 * 1000L);
-                    }
-                    if (mLaunchWakeLock != null) {
-                        mLaunchWakeLock.release();
-                    }
-                }
-            }
-        }
-
-        @Override
-        public void serviceProcessingFinished() {
-            synchronized (this) {
-                if (mServiceProcessing) {
-                    // If we are transitioning back to a wakelock with a timeout, do the same
-                    // as if we had enqueued work without the service running.
-                    if (mLaunchingService && mLaunchWakeLock != null) {
-                        mLaunchWakeLock.acquire(60 * 1000);
-                    }
-                    mServiceProcessing = false;
-                    if (mRunWakeLock != null) {
-                        mRunWakeLock.release();
-                    }
-                }
-            }
-        }
-    }
-
-    /**
-     * Implementation of a JobServiceEngine for interaction with TinkerJobIntentService.
-     */
-    @RequiresApi(26)
-    static final class JobServiceEngineImpl extends JobServiceEngine
-            implements TinkerJobIntentService.CompatJobEngine {
-        static final String TAG = "JobServiceEngineImpl";
-
-        static final boolean DEBUG = false;
-
-        final TinkerJobIntentService mService;
-        final Object mLock = new Object();
-        JobParameters mParams;
-
-        final class WrapperWorkItem implements TinkerJobIntentService.GenericWorkItem {
-            final JobWorkItem mJobWork;
-
-            WrapperWorkItem(JobWorkItem jobWork) {
-                mJobWork = jobWork;
-            }
-
-            @Override
-            public Intent getIntent() {
-                return mJobWork.getIntent();
-            }
-
-            @Override
-            public void complete() {
-                synchronized (mLock) {
-                    if (mParams != null) {
-                        mParams.completeWork(mJobWork);
-                    }
-                }
-            }
-        }
-
-        JobServiceEngineImpl(TinkerJobIntentService service) {
-            super(service);
-            mService = service;
-        }
-
-        @Override
-        public IBinder compatGetBinder() {
-            return getBinder();
-        }
-
-        @Override
-        public boolean onStartJob(JobParameters params) {
-            if (DEBUG) Log.d(TAG, "onStartJob: " + params);
-            mParams = params;
-            // We can now start dequeuing work!
-            mService.ensureProcessorRunningLocked(false);
-            return true;
-        }
-
-        @Override
-        public boolean onStopJob(JobParameters params) {
-            if (DEBUG) Log.d(TAG, "onStartJob: " + params);
-            boolean result = mService.doStopCurrentWork();
-            synchronized (mLock) {
-                // Once we return, the job is stopped, so its JobParameters are no
-                // longer valid and we should not be doing anything with them.
-                mParams = null;
-            }
-            return result;
-        }
-
-        /**
-         * Dequeue some work.
-         */
-        @Override
-        public TinkerJobIntentService.GenericWorkItem dequeueWork() {
-            JobWorkItem work;
-            synchronized (mLock) {
-                if (mParams == null) {
-                    return null;
-                }
-                try {
-                    work = mParams.dequeueWork();
-                } catch (Throwable thr) {
-                    Log.w(TAG, "exception occurred.", thr);
-                    work = null;
-                }
-            }
-            if (work != null) {
-                work.getIntent().setExtrasClassLoader(mService.getClassLoader());
-                return new WrapperWorkItem(work);
-            } else {
-                return null;
-            }
-        }
-    }
-
-    @RequiresApi(26)
-    static final class JobWorkEnqueuer extends TinkerJobIntentService.WorkEnqueuer {
-        private final JobInfo mJobInfo;
-        private final JobScheduler mJobScheduler;
-
-        JobWorkEnqueuer(Context context, ComponentName cn, int jobId) {
-            super(context, cn);
-            ensureJobId(jobId);
-            JobInfo.Builder b = new JobInfo.Builder(jobId, mComponentName);
-            mJobInfo = b.setOverrideDeadline(0).build();
-            mJobScheduler = (JobScheduler) context.getApplicationContext().getSystemService(
-                    Context.JOB_SCHEDULER_SERVICE);
-        }
-
-        @Override
-        void enqueueWork(Intent work) {
-            if (DEBUG) Log.d(TAG, "Enqueueing work: " + work);
-            mJobScheduler.enqueue(mJobInfo, new JobWorkItem(work));
-        }
-    }
-
-    /**
-     * Abstract definition of an item of work that is being dispatched.
-     */
-    interface GenericWorkItem {
-        Intent getIntent();
-        void complete();
-    }
-
-    /**
-     * An implementation of GenericWorkItem that dispatches work for pre-O platforms: intents
-     * received through a raw service's onStartCommand.
-     */
-    final class CompatWorkItem implements GenericWorkItem {
-        final Intent mIntent;
-        final int mStartId;
-
-        CompatWorkItem(Intent intent, int startId) {
-            mIntent = intent;
-            mStartId = startId;
-        }
-
-        @Override
-        public Intent getIntent() {
-            return mIntent;
-        }
-
-        @Override
-        public void complete() {
-            if (DEBUG) Log.d(TAG, "Stopping self: #" + mStartId);
-            stopSelf(mStartId);
-        }
-    }
-
-    /**
-     * This is a task to dequeue and process work in the background.
-     */
-    final class CommandProcessor extends AsyncTask<Void, Void, Void> {
-        @Override
-        protected Void doInBackground(Void... params) {
-            GenericWorkItem work;
-
-            if (DEBUG) Log.d(TAG, "Starting to dequeue work...");
-
-            while ((work = dequeueWork()) != null) {
-                if (DEBUG) Log.d(TAG, "Processing next work: " + work);
-                onHandleWork(work.getIntent());
-                if (DEBUG) Log.d(TAG, "Completing work: " + work);
-                work.complete();
-            }
-
-            if (DEBUG) Log.d(TAG, "Done processing work!");
-
-            return null;
-        }
-
-        @Override
-        protected void onCancelled(Void aVoid) {
-            processorFinished();
-        }
-
-        @Override
-        protected void onPostExecute(Void aVoid) {
-            processorFinished();
-        }
-    }
-
-    /**
-     * Default empty constructor.
-     */
-    public TinkerJobIntentService() {
-        if (Build.VERSION.SDK_INT >= 26) {
-            mCompatQueue = null;
-        } else {
-            mCompatQueue = new ArrayList<>();
-        }
-    }
-
-    @Override
-    public void onCreate() {
-        super.onCreate();
-        if (DEBUG) Log.d(TAG, "CREATING: " + this);
-        if (Build.VERSION.SDK_INT >= 26) {
-            mJobImpl = new JobServiceEngineImpl(this);
-            mCompatWorkEnqueuer = null;
-        } else {
-            mJobImpl = null;
-            ComponentName cn = new ComponentName(this, this.getClass());
-            mCompatWorkEnqueuer = getWorkEnqueuer(this, cn, false, 0);
-        }
-    }
-
-    /**
-     * Processes start commands when running as a pre-O service, enqueueing them to be
-     * later dispatched in {@link #onHandleWork(Intent)}.
-     */
-    @Override
-    public int onStartCommand(@Nullable Intent intent, int flags, int startId) {
-        if (mCompatQueue != null) {
-            mCompatWorkEnqueuer.serviceStartReceived();
-            if (DEBUG) Log.d(TAG, "Received compat start command #" + startId + ": " + intent);
-            synchronized (mCompatQueue) {
-                mCompatQueue.add(new CompatWorkItem(intent != null ? intent : new Intent(),
-                        startId));
-                ensureProcessorRunningLocked(true);
-            }
-            return START_REDELIVER_INTENT;
-        } else {
-            if (DEBUG) Log.d(TAG, "Ignoring start command: " + intent);
-            return START_NOT_STICKY;
-        }
-    }
-
-    /**
-     * Returns the IBinder for the {@link android.app.job.JobServiceEngine} when
-     * running as a JobService on O and later platforms.
-     */
-    @Override
-    public IBinder onBind(@NonNull Intent intent) {
-        if (mJobImpl != null) {
-            IBinder engine = mJobImpl.compatGetBinder();
-            if (DEBUG) Log.d(TAG, "Returning engine: " + engine);
-            return engine;
-        } else {
-            return null;
-        }
-    }
-
-    @Override
-    public void onDestroy() {
-        super.onDestroy();
-        if (mCompatQueue != null) {
-            synchronized (mCompatQueue) {
-                mDestroyed = true;
-                mCompatWorkEnqueuer.serviceProcessingFinished();
-            }
-        }
-    }
-
-    /**
-     * Call this to enqueue work for your subclass of {@link TinkerJobIntentService}.  This will
-     * either directly start the service (when running on pre-O platforms) or enqueue work
-     * for it as a job (when running on O and later).  In either case, a wake lock will be
-     * held for you to ensure you continue running.  The work you enqueue will ultimately
-     * appear at {@link #onHandleWork(Intent)}.
-     *
-     * @param context Context this is being called from.
-     * @param cls The concrete class the work should be dispatched to (this is the class that
-     * is published in your manifest).
-     * @param jobId A unique job ID for scheduling; must be the same value for all work
-     * enqueued for the same class.
-     * @param work The Intent of work to enqueue.
-     */
-    public static void enqueueWork(@NonNull Context context, @NonNull Class cls, int jobId,
-                                   @NonNull Intent work) {
-        enqueueWork(context, new ComponentName(context, cls), jobId, work);
-    }
-
-    /**
-     * Like {@link #enqueueWork(Context, Class, int, Intent)}, but supplies a ComponentName
-     * for the service to interact with instead of its class.
-     *
-     * @param context Context this is being called from.
-     * @param component The published ComponentName of the class this work should be
-     * dispatched to.
-     * @param jobId A unique job ID for scheduling; must be the same value for all work
-     * enqueued for the same class.
-     * @param work The Intent of work to enqueue.
-     */
-    public static void enqueueWork(@NonNull Context context, @NonNull ComponentName component,
-                                   int jobId, @NonNull Intent work) {
-        if (work == null) {
-            throw new IllegalArgumentException("work must not be null");
-        }
-        synchronized (sLock) {
-            WorkEnqueuer we = getWorkEnqueuer(context, component, true, jobId);
-            we.ensureJobId(jobId);
-            we.enqueueWork(work);
-        }
-    }
-
-    static WorkEnqueuer getWorkEnqueuer(Context context, ComponentName cn, boolean hasJobId,
-                                        int jobId) {
-        WorkEnqueuer we = sClassWorkEnqueuer.get(cn);
-        if (we == null) {
-            if (Build.VERSION.SDK_INT >= 26) {
-                if (!hasJobId) {
-                    throw new IllegalArgumentException("Can't be here without a job id");
-                }
-                we = new JobWorkEnqueuer(context, cn, jobId);
-            } else {
-                we = new CompatWorkEnqueuer(context, cn);
-            }
-            sClassWorkEnqueuer.put(cn, we);
-        }
-        return we;
-    }
-
-    /**
-     * Called serially for each work dispatched to and processed by the service.  This
-     * method is called on a background thread, so you can do long blocking operations
-     * here.  Upon returning, that work will be considered complete and either the next
-     * pending work dispatched here or the overall service destroyed now that it has
-     * nothing else to do.
-     *
-     * <p>Be aware that when running as a job, you are limited by the maximum job execution
-     * time and any single or total sequential items of work that exceeds that limit will
-     * cause the service to be stopped while in progress and later restarted with the
-     * last unfinished work.  (There is currently no limit on execution duration when
-     * running as a pre-O plain Service.)</p>
-     *
-     * @param intent The intent describing the work to now be processed.
-     */
-    protected abstract void onHandleWork(@NonNull Intent intent);
-
-    /**
-     * Control whether code executing in {@link #onHandleWork(Intent)} will be interrupted
-     * if the job is stopped.  By default this is false.  If called and set to true, any
-     * time {@link #onStopCurrentWork()} is called, the class will first call
-     * {@link AsyncTask#cancel(boolean) AsyncTask.cancel(true)} to interrupt the running
-     * task.
-     *
-     * @param interruptIfStopped Set to true to allow the system to interrupt actively
-     * running work.
-     */
-    public void setInterruptIfStopped(boolean interruptIfStopped) {
-        mInterruptIfStopped = interruptIfStopped;
-    }
-
-    /**
-     * Returns true if {@link #onStopCurrentWork()} has been called.  You can use this,
-     * while executing your work, to see if it should be stopped.
-     */
-    public boolean isStopped() {
-        return mStopped;
-    }
-
-    /**
-     * This will be called if the JobScheduler has decided to stop this job.  The job for
-     * this service does not have any constraints specified, so this will only generally happen
-     * if the service exceeds the job's maximum execution time.
-     *
-     * @return True to indicate to the JobManager whether you'd like to reschedule this work,
-     * false to drop this and all following work. Regardless of the value returned, your service
-     * must stop executing or the system will ultimately kill it.  The default implementation
-     * returns true, and that is most likely what you want to return as well (so no work gets
-     * lost).
-     */
-    public boolean onStopCurrentWork() {
-        return true;
-    }
-
-    boolean doStopCurrentWork() {
-        if (mCurProcessor != null) {
-            mCurProcessor.cancel(mInterruptIfStopped);
-        }
-        mStopped = true;
-        return onStopCurrentWork();
-    }
-
-    @TargetApi(11)
-    void ensureProcessorRunningLocked(boolean reportStarted) {
-        if (mCurProcessor == null) {
-            mCurProcessor = new CommandProcessor();
-            if (mCompatWorkEnqueuer != null && reportStarted) {
-                mCompatWorkEnqueuer.serviceProcessingStarted();
-            }
-            if (DEBUG) Log.d(TAG, "Starting processor: " + mCurProcessor);
-            mCurProcessor.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
-        }
-    }
-
-    void processorFinished() {
-        if (mCompatQueue != null) {
-            synchronized (mCompatQueue) {
-                mCurProcessor = null;
-                // The async task has finished, but we may have gotten more work scheduled in the
-                // meantime.  If so, we need to restart the new processor to execute it.  If there
-                // is no more work at this point, either the service is in the process of being
-                // destroyed (because we called stopSelf on the last intent started for it), or
-                // someone has already called startService with a new Intent that will be
-                // arriving shortly.  In either case, we want to just leave the service
-                // waiting -- either to get destroyed, or get a new onStartCommand() callback
-                // which will then kick off a new processor.
-                if (mCompatQueue != null && mCompatQueue.size() > 0) {
-                    ensureProcessorRunningLocked(false);
-                } else if (!mDestroyed) {
-                    mCompatWorkEnqueuer.serviceProcessingFinished();
-                }
-            }
-        }
-    }
-
-    GenericWorkItem dequeueWork() {
-        if (mJobImpl != null) {
-            return mJobImpl.dequeueWork();
-        } else {
-            synchronized (mCompatQueue) {
-                if (mCompatQueue.size() > 0) {
-                    return mCompatQueue.remove(0);
-                } else {
-                    return null;
-                }
-            }
-        }
-    }
-}
\ No newline at end of file
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/UpgradePatchRetry.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/UpgradePatchRetry.java
index c0e8ee8b..db76767f 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/UpgradePatchRetry.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/UpgradePatchRetry.java
@@ -46,7 +46,7 @@
 
     private static final String RETRY_FILE_MD5_PROPERTY = "md5";
     private static final String RETRY_COUNT_PROPERTY    = "times";
-    private static final int    RETRY_MAX_COUNT         = 5;
+    private static final int    RETRY_MAX_COUNT         = 20;
     private static UpgradePatchRetry sInstance;
     private boolean isRetryEnable = true;
     private File    retryInfoFile = null;
@@ -291,7 +291,6 @@ static void writeRetryProperty(File infoFile, RetryInfo info) {
                 outputStream = new FileOutputStream(infoFile, false);
                 newProperties.store(outputStream, null);
             } catch (Exception e) {
-//                e.printStackTrace();
                 TinkerLog.printErrStackTrace(TAG, e, "retry write property fail");
             } finally {
                 StreamUtil.closeQuietly(outputStream);
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AndroidNClassLoader.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AndroidNClassLoader.java
index 565c7f9a..2197e67b 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AndroidNClassLoader.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AndroidNClassLoader.java
@@ -29,6 +29,7 @@
 import java.lang.reflect.Field;
 import java.util.List;
 
+import dalvik.system.BaseDexClassLoader;
 import dalvik.system.DexFile;
 import dalvik.system.PathClassLoader;
 
@@ -40,19 +41,24 @@
     private static final String TAG = "Tinker.NClassLoader";
 
     private static Object oldDexPathListHolder = null;
-    private static String baseApkFullPath = null;
+    private static String packageName = "";
 
-    private final PathClassLoader originClassLoader;
-    private String applicationClassName;
+    private final ClassLoader originClassLoader;
+    private String applicationClassName = "";
 
-    private AndroidNClassLoader(String dexPath, PathClassLoader parent, Application application) {
+    private AndroidNClassLoader(String dexPath, ClassLoader parent, Application application) {
         super(dexPath, parent.getParent());
         originClassLoader = parent;
         String name = application.getClass().getName();
         if (name != null && !name.equals("android.app.Application")) {
             applicationClassName = name;
         }
-        baseApkFullPath = application.getPackageCodePath();
+        packageName = application.getPackageName();
+    }
+
+    private AndroidNClassLoader(String dexPath, ClassLoader parent) {
+        super(dexPath, parent);
+        originClassLoader = parent;
     }
 
     @SuppressWarnings("unchecked")
@@ -75,7 +81,10 @@ private static Object recreateDexPathList(Object originalDexPathList, ClassLoade
             if (dexFile == null || dexFile.getName() == null) {
                 continue;
             }
-            if (!dexFile.getName().equals(baseApkFullPath)) {
+            // Skip dexes which is not belong to our app.
+            // Then patched dexes would be injected in SystemClassLoaderAdder class.
+            final String dexFileName = dexFile.getName();
+            if (!dexFileName.contains("/" + packageName)) {
                 continue;
             }
             if (isFirstItem) {
@@ -106,7 +115,7 @@ private static Object recreateDexPathList(Object originalDexPathList, ClassLoade
         return dexPathListConstructor.newInstance(newDefiningContext, dexPath, libraryPath, null);
     }
 
-    private static AndroidNClassLoader createAndroidNClassLoader(PathClassLoader originalClassLoader, Application application) throws Exception {
+    private static AndroidNClassLoader createAndroidNClassLoader(BaseDexClassLoader originalClassLoader, Application application) throws Exception {
         //let all element ""
         final AndroidNClassLoader androidNClassLoader = new AndroidNClassLoader("",  originalClassLoader, application);
         final Field pathListField = ShareReflectUtil.findField(originalClassLoader, "pathList");
@@ -152,20 +161,27 @@ private static void reflectPackageInfoClassloader(Application application, Class
         Thread.currentThread().setContextClassLoader(reflectClassLoader);
     }
 
-    public static AndroidNClassLoader inject(PathClassLoader originClassLoader, Application application) throws Exception {
+    public static void triggerDex2Oat(Context context, String dexPath) {
+        final ClassLoader bootClassLoader = Context.class.getClassLoader();
+        new AndroidNClassLoader(dexPath, bootClassLoader);
+    }
+
+    public static AndroidNClassLoader inject(BaseDexClassLoader originClassLoader, Application application) throws Exception {
         AndroidNClassLoader classLoader = createAndroidNClassLoader(originClassLoader, application);
         reflectPackageInfoClassloader(application, classLoader);
         return classLoader;
     }
 
     public Class<?> findClass(String name) throws ClassNotFoundException {
-        // app class use default pathClassloader to load
+        // app class use default PathClassloader to load
         if (applicationClassName != null && applicationClassName.equals(name)) {
             return originClassLoader.loadClass(name);
         } else if (name != null && name.startsWith("com.tencent.tinker.loader.")
                 && !name.equals(SystemClassLoaderAdder.CHECK_DEX_CLASS)) {
             return originClassLoader.loadClass(name);
-        } else if (name != null && name.startsWith("org.apache.http.")) {
+        } else if (name != null &&  (name.startsWith("org.apache.commons.codec.")
+                                     || name.startsWith("org.apache.commons.logging.")
+                                     || name.startsWith("org.apache.http."))) {
             // Here's the whole story:
             //   Some app use apache wrapper library to access Apache utilities. Classes in apache wrapper
             //   library may be conflict with those preloaded in BootClassLoader.
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/SystemClassLoaderAdder.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/SystemClassLoaderAdder.java
index 17293f95..b1c4de5d 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/SystemClassLoaderAdder.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/SystemClassLoaderAdder.java
@@ -34,14 +34,13 @@
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Comparator;
-import java.util.Enumeration;
 import java.util.HashMap;
 import java.util.List;
 import java.util.ListIterator;
 import java.util.Map;
-import java.util.zip.ZipEntry;
 import java.util.zip.ZipFile;
 
+import dalvik.system.BaseDexClassLoader;
 import dalvik.system.DexFile;
 import dalvik.system.PathClassLoader;
 
@@ -55,14 +54,14 @@
     private static int sPatchDexCount = 0;
 
     @SuppressLint("NewApi")
-    public static void installDexes(Application application, PathClassLoader loader, File dexOptDir, List<File> files)
+    public static void installDexes(Application application, BaseDexClassLoader loader, File dexOptDir, List<File> files, boolean isProtectedApp)
         throws Throwable {
         Log.i(TAG, "installDexes dexOptDir: " + dexOptDir.getAbsolutePath() + ", dex size:" + files.size());
 
         if (!files.isEmpty()) {
             files = createSortedAdditionalPathEntries(files);
             ClassLoader classLoader = loader;
-            if (Build.VERSION.SDK_INT >= 24 && !checkIsProtectedApp(files)) {
+            if (Build.VERSION.SDK_INT >= 24 && !isProtectedApp) {
                 classLoader = AndroidNClassLoader.inject(loader, application);
             }
             //because in dalvik, if inner class is not the same classloader with it wrapper class.
@@ -88,6 +87,23 @@ public static void installDexes(Application application, PathClassLoader loader,
         }
     }
 
+    @SuppressLint("NewApi")
+    public static void installApk(PathClassLoader loader, List<File> files) throws Throwable {
+        if (!files.isEmpty()) {
+            files = createSortedAdditionalPathEntries(files);
+            ClassLoader classLoader = loader;
+            ArkHot.install(classLoader, files);
+            sPatchDexCount = files.size();
+            Log.i(TAG, "after loaded classloader: " + classLoader + ", dex size:" + sPatchDexCount);
+
+            if (!checkDexInstall(classLoader)) {
+                // reset patch dex
+//                SystemClassLoaderAdder.uninstallPatchDex(classLoader);
+//                throw new TinkerRuntimeException(ShareConstants.CHECK_DEX_INSTALL_FAIL);
+            }
+        }
+    }
+
     public static void uninstallPatchDex(ClassLoader classLoader) throws Throwable {
         if (sPatchDexCount <= 0) {
             return;
@@ -103,6 +119,7 @@ public static void uninstallPatchDex(ClassLoader classLoader) throws Throwable {
             try {
                 ShareReflectUtil.reduceFieldArray(classLoader, "mDexs", sPatchDexCount);
             } catch (Exception e) {
+                // Ignored.
             }
         }
     }
@@ -115,39 +132,6 @@ private static boolean checkDexInstall(ClassLoader classLoader) throws ClassNotF
         return isPatch;
     }
 
-    private static boolean checkIsProtectedApp(List<File> files) {
-        if (!files.isEmpty()) {
-            for (File file : files) {
-                if (file == null) {
-                    continue;
-                }
-                final String fileName = file.getName();
-                if (fileName.startsWith(ShareConstants.CHANGED_CLASSES_DEX_PREFIX)) {
-                    return true;
-                } else if (fileName.endsWith(ShareConstants.APK_SUFFIX) || file.getName().endsWith(ShareConstants.JAR_SUFFIX)) {
-                    ZipFile zf = null;
-                    try {
-                        zf = new ZipFile(file);
-                        final Enumeration<? extends ZipEntry> entries = zf.entries();
-                        while (entries.hasMoreElements()) {
-                            final ZipEntry entry = entries.nextElement();
-                            if (entry.getName().startsWith(ShareConstants.CHANGED_CLASSES_DEX_PREFIX)) {
-                                return true;
-                            }
-                        }
-                        return false;
-                    } catch (IOException e) {
-                        // Usually we shouldn't reach here.
-                        return false;
-                    } finally {
-                        SharePatchFileUtil.closeZip(zf);
-                    }
-                }
-            }
-        }
-        return false;
-    }
-
     private static List<File> createSortedAdditionalPathEntries(List<File> additionalPathEntries) {
         final List<File> result = new ArrayList<>(additionalPathEntries);
 
@@ -205,6 +189,27 @@ public int compare(File lhs, File rhs) {
         return result;
     }
 
+    /**
+     * Installer for platform huawei ark
+     */
+    private static final class ArkHot {
+        private static void install(ClassLoader loader, List<File> additionalClassPathEntries)
+                throws IllegalArgumentException, IllegalAccessException, NoSuchMethodException,
+                InvocationTargetException, IOException, ClassNotFoundException, SecurityException {
+            Class<?>  extendedClassLoaderHelper = ClassLoader.getSystemClassLoader()
+                    .getParent().loadClass("com.huawei.ark.classloader.ExtendedClassLoaderHelper");
+
+            for (File file : additionalClassPathEntries) {
+                String path = file.getCanonicalPath();
+                Method applyPatchMethod = extendedClassLoaderHelper.getDeclaredMethod(
+                        "applyPatch", ClassLoader.class, String.class);
+                applyPatchMethod.setAccessible(true);
+                applyPatchMethod.invoke(null, loader, path);
+                Log.i(TAG, "ArkHot install path = " + path);
+            }
+        }
+    }
+
     /**
      * Installer for platform versions 23.
      */
@@ -400,7 +405,7 @@ private static void install(ClassLoader loader, List<File> additionalClassPathEn
             try {
                 ShareReflectUtil.expandFieldArray(loader, "mDexs", extraDexs);
             } catch (Exception e) {
-
+                // Ignored.
             }
         }
     }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerArkHotLoader.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerArkHotLoader.java
new file mode 100644
index 00000000..7cf055e1
--- /dev/null
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerArkHotLoader.java
@@ -0,0 +1,171 @@
+/*
+ * Copyright (C) 2019-2019. Huawei Technologies Co., Ltd. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the BSD 3-Clause License
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * the BSD 3-Clause License for more details.
+ */
+
+package com.tencent.tinker.loader;
+
+import android.annotation.TargetApi;
+import android.content.Intent;
+import android.os.Build;
+import android.util.Log;
+
+import com.tencent.tinker.loader.app.TinkerApplication;
+import com.tencent.tinker.loader.shareutil.ShareArkHotDiffPatchInfo;
+import com.tencent.tinker.loader.shareutil.ShareConstants;
+import com.tencent.tinker.loader.shareutil.ShareIntentUtil;
+import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
+import com.tencent.tinker.loader.shareutil.ShareSecurityCheck;
+import com.tencent.tinker.loader.shareutil.ShareTinkerInternals;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+
+import dalvik.system.PathClassLoader;
+
+/**
+ * Created by  on 16/3/8.
+ * check the complete of the dex files
+ * pre-load patch dex files
+ */
+public class TinkerArkHotLoader {
+    private static final String TAG = "Tinker.TinkerArkHotLoader";
+
+    private static final String ARK_MEAT_FILE = ShareConstants.ARKHOT_META_FILE;
+    private static final String ARKHOT_PATH = ShareConstants.ARKHOTFIX_PATH;
+
+    // private static File testOptDexFile;
+    private static HashSet<ShareArkHotDiffPatchInfo> arkHotApkInfo = new HashSet<>();
+
+    private static boolean isArkHotRuning = ShareTinkerInternals.isArkHotRuning();
+
+    private TinkerArkHotLoader() {
+    }
+
+    /**
+     * Load tinker JARs and add them to
+     * the Application ClassLoader.
+     *
+     * @param application The application.
+     */
+    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
+    public static boolean loadTinkerArkHot(final TinkerApplication application, String directory, Intent intentResult) {
+        if (arkHotApkInfo.isEmpty()) {
+            Log.w(TAG, "there is no apk to load");
+            return true;
+        }
+
+        PathClassLoader classLoader = (PathClassLoader) TinkerArkHotLoader.class.getClassLoader();
+        if (classLoader != null) {
+            Log.i(TAG, "classloader: " + classLoader.toString());
+        } else {
+            Log.e(TAG, "classloader is null");
+            ShareIntentUtil.setIntentReturnCode(intentResult,
+                    ShareConstants.ERROR_LOAD_PATCH_VERSION_DEX_CLASSLOADER_NULL);
+            return false;
+        }
+        String apkPath = directory + "/" + ARKHOT_PATH + "/";
+
+        ArrayList<File> legalFiles = new ArrayList<>();
+
+        // verify merge classN.apk
+        if (isArkHotRuning && !arkHotApkInfo.isEmpty()) {
+            File classNFile = null;
+            classNFile = new File(apkPath + ShareConstants.ARKHOT_PATCH_NAME);
+            legalFiles.add(classNFile);
+        }
+
+        try {
+            // 加载Apk
+            SystemClassLoaderAdder.installApk(classLoader, legalFiles);
+        } catch (Throwable e) {
+            Log.e(TAG, "install dexes failed");
+            intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_EXCEPTION, e);
+            ShareIntentUtil.setIntentReturnCode(intentResult,
+                    ShareConstants.ERROR_LOAD_PATCH_VERSION_DEX_LOAD_EXCEPTION);
+            return false;
+        }
+
+        return true;
+    }
+
+    /**
+     * all the ark apk in meta file exist?
+     * fast check, only check whether exist
+     *
+     * @return boolean
+     */
+    public static boolean checkComplete(String directory, ShareSecurityCheck securityCheck, Intent intentResult) {
+        String meta = securityCheck.getMetaContentMap().get(ARK_MEAT_FILE);
+        if (meta == null) {
+            return true;
+        }
+        arkHotApkInfo.clear();
+
+        ArrayList<ShareArkHotDiffPatchInfo> allDexInfo = new ArrayList<>();
+        ShareArkHotDiffPatchInfo.parseDiffPatchInfo(meta, allDexInfo);
+
+        if (allDexInfo.isEmpty()) {
+            return true;
+        }
+
+        HashMap<String, String> apks = new HashMap<>(1);
+
+        for (ShareArkHotDiffPatchInfo info : allDexInfo) {
+            // for dalvik, ignore art support dex
+            if (!ShareArkHotDiffPatchInfo.checkDiffPatchInfo(info)) {
+                intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_PACKAGE_PATCH_CHECK,
+                        ShareConstants.ERROR_PACKAGE_CHECK_DEX_META_CORRUPTED);
+                ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_PACKAGE_CHECK_FAIL);
+                return false;
+            }
+            if (isArkHotRuning && ShareConstants.ARKHOT_PATCH_NAME.equals(info.name)) {
+                arkHotApkInfo.add(info);
+            }
+        }
+
+        if (isArkHotRuning
+                && !arkHotApkInfo.isEmpty()) {
+            apks.put(ShareConstants.ARKHOT_PATCH_NAME, "");
+        }
+        String apkDirectory = directory + "/" + ARKHOT_PATH + "/";
+
+        File dexDir = new File(apkDirectory);
+
+        if (!dexDir.exists() || !dexDir.isDirectory()) {
+            ShareIntentUtil.setIntentReturnCode(intentResult,
+                    ShareConstants.ERROR_LOAD_PATCH_VERSION_DEX_DIRECTORY_NOT_EXIST);
+            return false;
+        }
+
+        // fast check whether there is any dex files missing
+        for (String name : apks.keySet()) {
+            File apkFile = new File(apkDirectory + name);
+
+            if (!SharePatchFileUtil.isLegalFile(apkFile)) {
+                try {
+                    intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_MISSING_DEX_PATH, apkFile.getCanonicalPath());
+                } catch (IOException e) {
+                    e.printStackTrace();
+                }
+                ShareIntentUtil.setIntentReturnCode(intentResult,
+                        ShareConstants.ERROR_LOAD_PATCH_VERSION_DEX_FILE_NOT_EXIST);
+                return false;
+            }
+        }
+
+        // if is ok, add to result intent
+        intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_DEXES_PATH, apks);
+        return true;
+    }
+}
\ No newline at end of file
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerDexLoader.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerDexLoader.java
index e2690254..8a0be851 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerDexLoader.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerDexLoader.java
@@ -34,7 +34,7 @@
 import java.util.HashMap;
 import java.util.HashSet;
 
-import dalvik.system.PathClassLoader;
+import dalvik.system.BaseDexClassLoader;
 
 /**
  * Created by zhangshaowen on 16/3/8.
@@ -50,10 +50,10 @@
     private static final String DEFAULT_DEX_OPTIMIZE_PATH   = ShareConstants.DEFAULT_DEX_OPTIMIZE_PATH;
     private static final String INTERPRET_DEX_OPTIMIZE_PATH = ShareConstants.INTERPRET_DEX_OPTIMIZE_PATH;
 
-    private static final ArrayList<ShareDexDiffPatchInfo> loadDexList = new ArrayList<>();
+    private static final ArrayList<ShareDexDiffPatchInfo> LOAD_DEX_LIST = new ArrayList<>();
 
 
-    //    private static File testOptDexFile;
+    // private static File testOptDexFile;
     private static HashSet<ShareDexDiffPatchInfo> classNDexInfo = new HashSet<>();
 
     private static boolean isVmArt = ShareTinkerInternals.isVmArt();
@@ -68,13 +68,13 @@ private TinkerDexLoader() {
      * @param application The application.
      */
     @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
-    public static boolean loadTinkerJars(final TinkerApplication application, String directory, String oatDir, Intent intentResult, boolean isSystemOTA) {
-        if (loadDexList.isEmpty() && classNDexInfo.isEmpty()) {
+    public static boolean loadTinkerJars(final TinkerApplication application, String directory, String oatDir, Intent intentResult, boolean isSystemOTA, boolean isProtectedApp) {
+        if (LOAD_DEX_LIST.isEmpty() && classNDexInfo.isEmpty()) {
             Log.w(TAG, "there is no dex to load");
             return true;
         }
 
-        PathClassLoader classLoader = (PathClassLoader) TinkerDexLoader.class.getClassLoader();
+        BaseDexClassLoader classLoader = (BaseDexClassLoader) TinkerDexLoader.class.getClassLoader();
         if (classLoader != null) {
             Log.i(TAG, "classloader: " + classLoader.toString());
         } else {
@@ -86,7 +86,7 @@ public static boolean loadTinkerJars(final TinkerApplication application, String
 
         ArrayList<File> legalFiles = new ArrayList<>();
 
-        for (ShareDexDiffPatchInfo info : loadDexList) {
+        for (ShareDexDiffPatchInfo info : LOAD_DEX_LIST) {
             //for dalvik, ignore art support dex
             if (isJustArtSupportDex(info)) {
                 continue;
@@ -138,16 +138,16 @@ public static boolean loadTinkerJars(final TinkerApplication application, String
                 targetISA = ShareTinkerInternals.getCurrentInstructionSet();
             } catch (Throwable throwable) {
                 Log.i(TAG, "getCurrentInstructionSet fail:" + throwable);
-//                try {
-//                    targetISA = ShareOatUtil.getOatFileInstructionSet(testOptDexFile);
-//                } catch (Throwable throwable) {
+                // try {
+                //     targetISA = ShareOatUtil.getOatFileInstructionSet(testOptDexFile);
+                // } catch (Throwable throwable) {
                 // don't ota on the front
                 deleteOutOfDateOATFile(directory);
 
                 intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_INTERPRET_EXCEPTION, throwable);
                 ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_GET_OTA_INSTRUCTION_SET_EXCEPTION);
                 return false;
-//                }
+                // }
             }
 
             deleteOutOfDateOATFile(directory);
@@ -157,7 +157,7 @@ public static boolean loadTinkerJars(final TinkerApplication application, String
             optimizeDir = new File(directory + "/" + INTERPRET_DEX_OPTIMIZE_PATH);
 
             TinkerDexOptimizer.optimizeAll(
-                legalFiles, optimizeDir, true, targetISA,
+                application, legalFiles, optimizeDir, true, targetISA,
                 new TinkerDexOptimizer.ResultCallback() {
                     long start;
 
@@ -191,10 +191,9 @@ public void onFailed(File dexFile, File optimizedDir, Throwable thr) {
             }
         }
         try {
-            SystemClassLoaderAdder.installDexes(application, classLoader, optimizeDir, legalFiles);
+            SystemClassLoaderAdder.installDexes(application, classLoader, optimizeDir, legalFiles, isProtectedApp);
         } catch (Throwable e) {
             Log.e(TAG, "install dexes failed");
-//            e.printStackTrace();
             intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_EXCEPTION, e);
             ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_DEX_LOAD_EXCEPTION);
             return false;
@@ -215,7 +214,7 @@ public static boolean checkComplete(String directory, ShareSecurityCheck securit
         if (meta == null) {
             return true;
         }
-        loadDexList.clear();
+        LOAD_DEX_LIST.clear();
         classNDexInfo.clear();
 
         ArrayList<ShareDexDiffPatchInfo> allDexInfo = new ArrayList<>();
@@ -245,7 +244,7 @@ public static boolean checkComplete(String directory, ShareSecurityCheck securit
                 classNDexInfo.add(info);
             } else {
                 dexes.put(info.realName, getInfoMd5(info));
-                loadDexList.add(info);
+                LOAD_DEX_LIST.add(info);
             }
         }
 
@@ -287,10 +286,10 @@ public static boolean checkComplete(String directory, ShareSecurityCheck securit
                 ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_DEX_OPT_FILE_NOT_EXIST);
                 return false;
             }
-//            // find test dex
-//            if (dexOptFile.getName().startsWith(ShareConstants.TEST_DEX_NAME)) {
-//                testOptDexFile = dexOptFile;
-//            }
+            // // find test dex
+            // if (dexOptFile.getName().startsWith(ShareConstants.TEST_DEX_NAME)) {
+            //     testOptDexFile = dexOptFile;
+            // }
         }
 
         //if is ok, add to result intent
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerDexOptimizer.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerDexOptimizer.java
index 5d935d0d..1de09b23 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerDexOptimizer.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerDexOptimizer.java
@@ -16,11 +16,13 @@
 
 package com.tencent.tinker.loader;
 
+import android.content.Context;
 import android.os.Build;
 import android.util.Log;
 
 import com.tencent.tinker.loader.shareutil.ShareFileLockHelper;
 import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
+import com.tencent.tinker.loader.shareutil.ShareTinkerInternals;
 
 import java.io.File;
 import java.io.IOException;
@@ -53,37 +55,35 @@
      * @param cb
      * @return If all dexes are optimized successfully, return true. Otherwise return false.
      */
-    public static boolean optimizeAll(Collection<File> dexFiles, File optimizedDir, ResultCallback cb) {
-        return optimizeAll(dexFiles, optimizedDir, false, null, cb);
+    public static boolean optimizeAll(Context context, Collection<File> dexFiles, File optimizedDir, ResultCallback cb) {
+        return optimizeAll(context, dexFiles, optimizedDir, false, null, cb);
     }
 
-    public static boolean optimizeAll(Collection<File> dexFiles, File optimizedDir,
+    public static boolean optimizeAll(Context context, Collection<File> dexFiles, File optimizedDir,
                                       boolean useInterpretMode, String targetISA, ResultCallback cb) {
         ArrayList<File> sortList = new ArrayList<>(dexFiles);
-        // sort input dexFiles with its file length
+        // sort input dexFiles with its file length in reverse order.
         Collections.sort(sortList, new Comparator<File>() {
             @Override
             public int compare(File lhs, File rhs) {
-                long diffSize = lhs.length() - rhs.length();
-                if (diffSize > 0) {
+                final long lhsSize = lhs.length();
+                final long rhsSize = rhs.length();
+                if (lhsSize < rhsSize) {
                     return 1;
-                } else if (diffSize == 0) {
+                } else if (lhsSize == rhsSize) {
                     return 0;
                 } else {
                     return -1;
                 }
             }
         });
-        Collections.reverse(sortList);
         for (File dexFile : sortList) {
-            OptimizeWorker worker = new OptimizeWorker(dexFile, optimizedDir, useInterpretMode, targetISA, cb);
+            OptimizeWorker worker = new OptimizeWorker(context, dexFile, optimizedDir, useInterpretMode, targetISA, cb);
             if (!worker.run()) {
                 return false;
             }
         }
         return true;
-
-
     }
 
     public interface ResultCallback {
@@ -96,13 +96,14 @@ public int compare(File lhs, File rhs) {
 
     private static class OptimizeWorker {
         private static String targetISA = null;
-
+        private final Context        context;
         private final File           dexFile;
         private final File           optimizedDir;
         private final boolean        useInterpretMode;
         private final ResultCallback callback;
 
-        OptimizeWorker(File dexFile, File optimizedDir, boolean useInterpretMode, String targetISA, ResultCallback cb) {
+        OptimizeWorker(Context context, File dexFile, File optimizedDir, boolean useInterpretMode, String targetISA, ResultCallback cb) {
+            this.context = context;
             this.dexFile = dexFile;
             this.optimizedDir = optimizedDir;
             this.useInterpretMode = useInterpretMode;
@@ -110,12 +111,12 @@ public int compare(File lhs, File rhs) {
             this.targetISA = targetISA;
         }
 
-        public boolean run() {
+        boolean run() {
             try {
                 if (!SharePatchFileUtil.isLegalFile(dexFile)) {
                     if (callback != null) {
                         callback.onFailed(dexFile, optimizedDir,
-                            new IOException("dex file " + dexFile.getAbsolutePath() + " is not exist!"));
+                                new IOException("dex file " + dexFile.getAbsolutePath() + " is not exist!"));
                         return false;
                     }
                 }
@@ -123,10 +124,15 @@ public boolean run() {
                     callback.onStart(dexFile, optimizedDir);
                 }
                 String optimizedPath = SharePatchFileUtil.optimizedPathFor(this.dexFile, this.optimizedDir);
-                if (useInterpretMode) {
-                    interpretDex2Oat(dexFile.getAbsolutePath(), optimizedPath);
-                } else {
-                    DexFile.loadDex(dexFile.getAbsolutePath(), optimizedPath, 0);
+                if (!ShareTinkerInternals.isArkHotRuning()) {
+                    if (useInterpretMode) {
+                        interpretDex2Oat(dexFile.getAbsolutePath(), optimizedPath);
+                    } else if (Build.VERSION.SDK_INT >= 28
+                            || (Build.VERSION.SDK_INT >= 27 && Build.VERSION.PREVIEW_SDK_INT != 0)) {
+                        AndroidNClassLoader.triggerDex2Oat(context, dexFile.getAbsolutePath());
+                    } else {
+                        DexFile.loadDex(dexFile.getAbsolutePath(), optimizedPath, 0);
+                    }
                 }
                 if (callback != null) {
                     callback.onSuccess(dexFile, optimizedDir, new File(optimizedPath));
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerLoader.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerLoader.java
index 1473ae2f..a07bf782 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerLoader.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerLoader.java
@@ -50,6 +50,7 @@
      */
     @Override
     public Intent tryLoad(TinkerApplication app) {
+        Log.d(TAG, "tryLoad test test");
         Intent resultIntent = new Intent();
 
         long begin = SystemClock.elapsedRealtime();
@@ -108,6 +109,9 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, Intent resultInten
             return;
         }
 
+        final boolean isProtectedApp = patchInfo.isProtectedApp;
+        resultIntent.putExtra(ShareIntentUtil.INTENT_IS_PROTECTED_APP, isProtectedApp);
+
         String oldVersion = patchInfo.oldVersion;
         String newVersion = patchInfo.newVersion;
         String oatDex = patchInfo.oatDir;
@@ -138,8 +142,12 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, Intent resultInten
                 newVersion = oldVersion;
                 patchInfo.oldVersion = oldVersion;
                 patchInfo.newVersion = newVersion;
+                patchInfo.isRemoveNewVersion = false;
                 SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile, patchInfo, patchInfoLockFile);
                 ShareTinkerInternals.killProcessExceptMain(app);
+
+                ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_DIRECTORY_NOT_EXIST);
+                return;
             }
         }
 
@@ -205,8 +213,9 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, Intent resultInten
         resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_PACKAGE_CONFIG, securityCheck.getPackagePropertiesIfPresent());
 
         final boolean isEnabledForDex = ShareTinkerInternals.isTinkerEnabledForDex(tinkerFlag);
+        final boolean isArkHotRuning = ShareTinkerInternals.isArkHotRuning();
 
-        if (isEnabledForDex) {
+        if (!isArkHotRuning && isEnabledForDex) {
             //tinker/patch.info/patch-641e634c/dex
             boolean dexCheck = TinkerDexLoader.checkComplete(patchVersionDirectory, securityCheck, oatDex, resultIntent);
             if (!dexCheck) {
@@ -216,6 +225,17 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, Intent resultInten
             }
         }
 
+        final boolean isEnabledForArkHot = ShareTinkerInternals.isTinkerEnabledForArkHot(tinkerFlag);
+        if (isArkHotRuning && isEnabledForArkHot) {
+            boolean arkHotCheck = TinkerArkHotLoader.checkComplete(patchVersionDirectory, securityCheck, resultIntent);
+            if (!arkHotCheck) {
+                // file not found, do not load patch
+                Log.w(TAG, "tryLoadPatchFiles:dex check fail");
+                return;
+            }
+        }
+
+
         final boolean isEnabledForNativeLib = ShareTinkerInternals.isTinkerEnabledForNativeLib(tinkerFlag);
 
         if (isEnabledForNativeLib) {
@@ -248,27 +268,19 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, Intent resultInten
         resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_SYSTEM_OTA, isSystemOTA);
 
         //we should first try rewrite patch info file, if there is a error, we can't load jar
-        if (mainProcess && (versionChanged || oatModeChanged)) {
-            patchInfo.oldVersion = version;
-            patchInfo.oatDir = oatDex;
-
-            //update old version to new
-            if (!SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile, patchInfo, patchInfoLockFile)) {
-                ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_REWRITE_PATCH_INFO_FAIL);
-                Log.w(TAG, "tryLoadPatchFiles:onReWritePatchInfoCorrupted");
-                return;
+        if (mainProcess) {
+            if (versionChanged) {
+                patchInfo.oldVersion = version;
             }
-
-            Log.i(TAG, "tryLoadPatchFiles:success to rewrite patch info, kill other process.");
-            ShareTinkerInternals.killProcessExceptMain(app);
-
             if (oatModeChanged) {
+                patchInfo.oatDir = oatDex;
                 // delete interpret odex
                 // for android o, directory change. Fortunately, we don't need to support android o interpret mode any more
                 Log.i(TAG, "tryLoadPatchFiles:oatModeChanged, try to delete interpret optimize files");
                 SharePatchFileUtil.deleteDir(patchVersionDirectory + "/" + ShareConstants.INTERPRET_DEX_OPTIMIZE_PATH);
             }
         }
+
         if (!checkSafeModeCount(app)) {
             resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_EXCEPTION, new TinkerRuntimeException("checkSafeModeCount fail"));
             ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_UNCAUGHT_EXCEPTION);
@@ -277,8 +289,8 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, Intent resultInten
         }
 
         //now we can load patch jar
-        if (isEnabledForDex) {
-            boolean loadTinkerJars = TinkerDexLoader.loadTinkerJars(app, patchVersionDirectory, oatDex, resultIntent, isSystemOTA);
+        if (!isArkHotRuning && isEnabledForDex) {
+            boolean loadTinkerJars = TinkerDexLoader.loadTinkerJars(app, patchVersionDirectory, oatDex, resultIntent, isSystemOTA, isProtectedApp);
 
             if (isSystemOTA) {
                 // update fingerprint after load success
@@ -301,6 +313,14 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, Intent resultInten
             }
         }
 
+        if (isArkHotRuning && isEnabledForArkHot) {
+            boolean loadArkHotFixJars = TinkerArkHotLoader.loadTinkerArkHot(app, patchVersionDirectory, resultIntent);
+            if (!loadArkHotFixJars) {
+                Log.w(TAG, "tryLoadPatchFiles:onPatchLoadArkApkFail");
+                return;
+            }
+        }
+
         //now we can load patch resource
         if (isEnabledForResource) {
             boolean loadTinkerResources = TinkerResourceLoader.loadTinkerResources(app, patchVersionDirectory, resultIntent);
@@ -311,10 +331,23 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, Intent resultInten
         }
 
         // Init component hotplug support.
-        if (isEnabledForDex && isEnabledForResource) {
+        if ((isEnabledForDex || isEnabledForArkHot) && isEnabledForResource) {
             ComponentHotplug.install(app, securityCheck);
         }
 
+        // Before successfully exit, we should update stored version info and kill other process
+        // to make them load latest patch when we first applied newer one.
+        if (mainProcess && versionChanged) {
+            //update old version to new
+            if (!SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile, patchInfo, patchInfoLockFile)) {
+                ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_REWRITE_PATCH_INFO_FAIL);
+                Log.w(TAG, "tryLoadPatchFiles:onReWritePatchInfoCorrupted");
+                return;
+            }
+
+            ShareTinkerInternals.killProcessExceptMain(app);
+        }
+
         //all is ok!
         ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_OK);
         Log.i(TAG, "tryLoadPatchFiles: load end, ok!");
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java
index 8c363ca4..aece8d6a 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java
@@ -238,6 +238,7 @@ public static void monkeyPatchExistingResources(Context context, String external
                     publicSourceDirField.set(context.getApplicationInfo(), externalResourceFile);
                 }
             } catch (Throwable ignore) {
+                // Ignored.
             }
         }
 
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/ITinkerInlineFenceBridge.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/ITinkerInlineFenceBridge.java
new file mode 100644
index 00000000..af394bd1
--- /dev/null
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/ITinkerInlineFenceBridge.java
@@ -0,0 +1,46 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.loader.app;
+
+import android.content.Context;
+import android.content.res.AssetManager;
+import android.content.res.Configuration;
+import android.content.res.Resources;
+
+public interface ITinkerInlineFenceBridge {
+    void attachBaseContext(TinkerApplication app, Context base);
+
+    void onCreate(TinkerApplication app);
+
+    void onConfigurationChanged(Configuration newConfig);
+
+    void onTrimMemory(int level);
+
+    void onLowMemory();
+
+    void onTerminate();
+
+    ClassLoader getClassLoader(ClassLoader cl);
+
+    Context getBaseContext(Context base);
+
+    AssetManager getAssets(AssetManager assets);
+
+    Resources getResources(Resources res);
+
+    Object getSystemService(String name, Object service);
+}
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/TinkerApplication.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/TinkerApplication.java
index fb1b1d06..4f73994f 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/TinkerApplication.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/TinkerApplication.java
@@ -28,11 +28,8 @@
 import com.tencent.tinker.loader.TinkerLoader;
 import com.tencent.tinker.loader.TinkerRuntimeException;
 import com.tencent.tinker.loader.TinkerUncaughtHandler;
-import com.tencent.tinker.loader.hotplug.ComponentHotplug;
-import com.tencent.tinker.loader.hotplug.UnsupportedEnvironmentException;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
 import com.tencent.tinker.loader.shareutil.ShareIntentUtil;
-import com.tencent.tinker.loader.shareutil.ShareReflectUtil;
 import com.tencent.tinker.loader.shareutil.ShareTinkerInternals;
 
 import java.lang.reflect.Constructor;
@@ -40,23 +37,18 @@
 
 /**
  * Created by zhangshaowen on 16/3/8.
- * <p/>
- * A base class for implementing an Application that delegates to an {@link ApplicationLifeCycle}
- * instance. This is used in conjunction with secondary dex files so that the logic that would
- * normally live in the Application class is loaded after the secondary dexes are loaded.
  */
 public abstract class TinkerApplication extends Application {
-
-    //oh, we can use ShareConstants, because they are loader class and static final!
-    private static final int    TINKER_DISABLE         = ShareConstants.TINKER_DISABLE;
     private static final String INTENT_PATCH_EXCEPTION = ShareIntentUtil.INTENT_PATCH_EXCEPTION;
-    private static final String TINKER_LOADER_METHOD   = "tryLoad";
+    private static final String TINKER_LOADER_METHOD = "tryLoad";
+
     /**
      * tinkerFlags, which types is supported
      * dex only, library only, all support
      * default: TINKER_ENABLE_ALL
      */
-    private final int     tinkerFlags;
+    private final int tinkerFlags;
+
     /**
      * whether verify md5 when we load dex or lib
      * they store at data/data/package, and we had verity them at the :patch process.
@@ -64,31 +56,21 @@
      * default:false
      */
     private final boolean tinkerLoadVerifyFlag;
-    private final String  delegateClassName;
-    private final String  loaderClassName;
+    private final String delegateClassName;
+    private final String loaderClassName;
 
     /**
      * if we have load patch, we should use safe mode
      */
-    private       boolean useSafeMode;
-    private       Intent  tinkerResultIntent;
-
-    private Object applicationLike = null;
+    private boolean useSafeMode;
+    private Intent tinkerResultIntent;
 
-    private long applicationStartElapsedTime;
-    private long applicationStartMillisTime;
+    private ITinkerInlineFenceBridge mBridge = null;
 
-    /**
-     * current build.
-     */
     protected TinkerApplication(int tinkerFlags) {
         this(tinkerFlags, "com.tencent.tinker.entry.DefaultApplicationLike", TinkerLoader.class.getName(), false);
     }
 
-    /**
-     * @param delegateClassName The fully-qualified name of the {@link ApplicationLifeCycle} class
-     *                          that will act as the delegate for application lifecycle callbacks.
-     */
     protected TinkerApplication(int tinkerFlags, String delegateClassName,
                                 String loaderClassName, boolean tinkerLoadVerifyFlag) {
         this.tinkerFlags = tinkerFlags;
@@ -101,51 +83,51 @@ protected TinkerApplication(int tinkerFlags, String delegateClassName) {
         this(tinkerFlags, delegateClassName, TinkerLoader.class.getName(), false);
     }
 
-    private Object createDelegate() {
+    private void loadTinker() {
         try {
-            // Use reflection to create the delegate so it doesn't need to go into the primary dex.
-            // And we can also patch it
-            Class<?> delegateClass = Class.forName(delegateClassName, false, getClassLoader());
-            Constructor<?> constructor = delegateClass.getConstructor(Application.class, int.class, boolean.class,
-                long.class, long.class, Intent.class);
-            return constructor.newInstance(this, tinkerFlags, tinkerLoadVerifyFlag,
-                applicationStartElapsedTime, applicationStartMillisTime, tinkerResultIntent);
+            //reflect tinker loader, because loaderClass may be define by user!
+            Class<?> tinkerLoadClass = Class.forName(loaderClassName, false, TinkerApplication.class.getClassLoader());
+            Method loadMethod = tinkerLoadClass.getMethod(TINKER_LOADER_METHOD, TinkerApplication.class);
+            Constructor<?> constructor = tinkerLoadClass.getConstructor();
+            tinkerResultIntent = (Intent) loadMethod.invoke(constructor.newInstance(), this);
         } catch (Throwable e) {
-            throw new TinkerRuntimeException("createDelegate failed", e);
-        }
-    }
-
-    private synchronized void ensureDelegate() {
-        if (applicationLike == null) {
-            applicationLike = createDelegate();
+            //has exception, put exception error code
+            tinkerResultIntent = new Intent();
+            ShareIntentUtil.setIntentReturnCode(tinkerResultIntent, ShareConstants.ERROR_LOAD_PATCH_UNKNOWN_EXCEPTION);
+            tinkerResultIntent.putExtra(INTENT_PATCH_EXCEPTION, e);
         }
     }
 
-    private Method appLikeOnBaseContextAttached = null;
-
-    private void invokeAppLikeOnBaseContextAttached(Object appLike, Context base) throws TinkerRuntimeException {
+    private ITinkerInlineFenceBridge createInlineFence(int tinkerFlags,
+                                                       String delegateClassName,
+                                                       boolean tinkerLoadVerifyFlag,
+                                                       long applicationStartElapsedTime,
+                                                       long applicationStartMillisTime,
+                                                       Intent resultIntent) {
         try {
-            if (appLikeOnBaseContextAttached == null) {
-                appLikeOnBaseContextAttached = ShareReflectUtil.findMethod(applicationLike, "onBaseContextAttached", Context.class);
-            }
-            appLikeOnBaseContextAttached.invoke(appLike, base);
+            final Class<?> inlineFenceClazz = Class.forName(
+                    "com.tencent.tinker.entry.TinkerApplicationInlineFence",
+                    true, super.getClassLoader());
+            final Constructor<?> ctor = inlineFenceClazz.getConstructor(int.class, String.class,
+                    boolean.class, long.class, long.class, Intent.class);
+            ctor.setAccessible(true);
+            return (ITinkerInlineFenceBridge) ctor.newInstance(tinkerFlags, delegateClassName,
+                    tinkerLoadVerifyFlag, applicationStartElapsedTime,
+                    applicationStartMillisTime, resultIntent);
         } catch (Throwable thr) {
-            throw new TinkerRuntimeException("fail to invoke onBaseContextAttached of appLike.", thr);
+            throw new TinkerRuntimeException("fail to create inline fence instance.", thr);
         }
     }
 
-    /**
-     * Hook for sub-classes to run logic after the {@link Application#attachBaseContext} has been
-     * called but before the delegate is created. Implementors should be very careful what they do
-     * here since {@link android.app.Application#onCreate} will not have yet been called.
-     */
     private void onBaseContextAttached(Context base) {
         try {
-            applicationStartElapsedTime = SystemClock.elapsedRealtime();
-            applicationStartMillisTime = System.currentTimeMillis();
+            final long applicationStartElapsedTime = SystemClock.elapsedRealtime();
+            final long applicationStartMillisTime = System.currentTimeMillis();
             loadTinker();
-            ensureDelegate();
-            invokeAppLikeOnBaseContextAttached(applicationLike, base);
+            mBridge = createInlineFence(tinkerFlags, delegateClassName,
+                    tinkerLoadVerifyFlag, applicationStartElapsedTime, applicationStartMillisTime,
+                    tinkerResultIntent);
+            mBridge.attachBaseContext(this, base);
             //reset save mode
             if (useSafeMode) {
                 ShareTinkerInternals.setSafeModeCount(this, 0);
@@ -164,104 +146,27 @@ protected void attachBaseContext(Context base) {
         onBaseContextAttached(base);
     }
 
-    private void loadTinker() {
-        try {
-            //reflect tinker loader, because loaderClass may be define by user!
-            Class<?> tinkerLoadClass = Class.forName(loaderClassName, false, getClassLoader());
-            Method loadMethod = tinkerLoadClass.getMethod(TINKER_LOADER_METHOD, TinkerApplication.class);
-            Constructor<?> constructor = tinkerLoadClass.getConstructor();
-            tinkerResultIntent = (Intent) loadMethod.invoke(constructor.newInstance(), this);
-        } catch (Throwable e) {
-            //has exception, put exception error code
-            tinkerResultIntent = new Intent();
-            ShareIntentUtil.setIntentReturnCode(tinkerResultIntent, ShareConstants.ERROR_LOAD_PATCH_UNKNOWN_EXCEPTION);
-            tinkerResultIntent.putExtra(INTENT_PATCH_EXCEPTION, e);
-        }
-    }
-
-    private Method appLikeOnCreate = null;
-
-    private void invokeAppLikeOnCreate(Object appLike) throws TinkerRuntimeException {
-        try {
-            if (appLikeOnCreate == null) {
-                appLikeOnCreate = ShareReflectUtil.findMethod(applicationLike, "onCreate");
-            }
-            appLikeOnCreate.invoke(appLike);
-        } catch (Throwable thr) {
-            throw new TinkerRuntimeException("fail to invoke onCreate of appLike.", thr);
-        }
-    }
-
     @Override
     public void onCreate() {
         super.onCreate();
-        try {
-            ensureDelegate();
-            try {
-                ComponentHotplug.ensureComponentHotplugInstalled(this);
-            } catch (UnsupportedEnvironmentException e) {
-                throw new TinkerRuntimeException("failed to make sure that ComponentHotplug logic is fine.", e);
-            }
-            invokeAppLikeOnCreate(applicationLike);
-        } catch (TinkerRuntimeException e) {
-            throw e;
-        } catch (Throwable thr) {
-            throw new TinkerRuntimeException(thr.getMessage(), thr);
-        }
-    }
-
-    private Method appLikeOnTerminate = null;
-
-    private void invokeAppLikeOnTerminate(Object appLike) throws TinkerRuntimeException {
-        try {
-            if (appLikeOnTerminate == null) {
-                appLikeOnTerminate = ShareReflectUtil.findMethod(applicationLike, "onTerminate");
-            }
-            appLikeOnTerminate.invoke(appLike);
-        } catch (Throwable thr) {
-            throw new TinkerRuntimeException("fail to invoke onTerminate of appLike.", thr);
+        if (mBridge != null) {
+            mBridge.onCreate(this);
         }
     }
 
     @Override
     public void onTerminate() {
         super.onTerminate();
-        if (applicationLike != null) {
-            invokeAppLikeOnTerminate(applicationLike);
-        }
-    }
-
-    private Method appLikeOnLowMemory = null;
-
-    private void invokeAppLikeOnLowMemory(Object appLike) throws TinkerRuntimeException {
-        try {
-            if (appLikeOnLowMemory == null) {
-                appLikeOnLowMemory = ShareReflectUtil.findMethod(applicationLike, "onLowMemory");
-            }
-            appLikeOnLowMemory.invoke(appLike);
-        } catch (Throwable thr) {
-            throw new TinkerRuntimeException("fail to invoke onLowMemory of appLike.", thr);
+        if (mBridge != null) {
+            mBridge.onTerminate();
         }
     }
 
     @Override
     public void onLowMemory() {
         super.onLowMemory();
-        if (applicationLike != null) {
-            invokeAppLikeOnLowMemory(applicationLike);
-        }
-    }
-
-    private Method appLikeOnTrimMemory = null;
-
-    private void invokeAppLikeOnTrimMemory(Object appLike, int level) throws TinkerRuntimeException {
-        try {
-            if (appLikeOnTrimMemory == null) {
-                appLikeOnTrimMemory = ShareReflectUtil.findMethod(applicationLike, "onTrimMemory", int.class);
-            }
-            appLikeOnTrimMemory.invoke(appLike, level);
-        } catch (Throwable thr) {
-            throw new TinkerRuntimeException("fail to invoke onTrimMemory of appLike.", thr);
+        if (mBridge != null) {
+            mBridge.onLowMemory();
         }
     }
 
@@ -269,140 +174,47 @@ private void invokeAppLikeOnTrimMemory(Object appLike, int level) throws TinkerR
     @Override
     public void onTrimMemory(int level) {
         super.onTrimMemory(level);
-        if (applicationLike != null) {
-            invokeAppLikeOnTrimMemory(applicationLike, level);
-        }
-    }
-
-    private Method appLikeOnConfigurationChanged = null;
-
-    private void invokeAppLikeOnConfigurationChanged(Object appLike, Configuration newConfig) throws TinkerRuntimeException {
-        try {
-            if (appLikeOnConfigurationChanged == null) {
-                appLikeOnConfigurationChanged = ShareReflectUtil.findMethod(applicationLike, "onConfigurationChanged", Configuration.class);
-            }
-            appLikeOnConfigurationChanged.invoke(appLike, newConfig);
-        } catch (Throwable thr) {
-            throw new TinkerRuntimeException("fail to invoke onConfigurationChanged of appLike.", thr);
+        if (mBridge != null) {
+            mBridge.onTrimMemory(level);
         }
     }
 
     @Override
     public void onConfigurationChanged(Configuration newConfig) {
         super.onConfigurationChanged(newConfig);
-        if (applicationLike != null) {
-            invokeAppLikeOnConfigurationChanged(applicationLike, newConfig);
-        }
-    }
-
-    private Method appLikeGetResources = null;
-
-    private Resources invokeAppLikeGetResources(Object appLike, Resources resources) throws TinkerRuntimeException {
-        try {
-            if (appLikeGetResources == null) {
-                appLikeGetResources = ShareReflectUtil.findMethod(applicationLike, "getResources", Resources.class);
-            }
-            return (Resources) appLikeGetResources.invoke(appLike, resources);
-        } catch (Throwable thr) {
-            throw new TinkerRuntimeException("fail to invoke getResources of appLike.", thr);
+        if (mBridge != null) {
+            mBridge.onConfigurationChanged(newConfig);
         }
     }
 
     @Override
     public Resources getResources() {
-        Resources resources = super.getResources();
-        if (applicationLike != null) {
-            return invokeAppLikeGetResources(applicationLike, resources);
-        }
-        return resources;
-    }
-
-    private Method appLikeGetClassLoader = null;
-
-    private ClassLoader invokeAppLikeGetClassLoader(Object appLike, ClassLoader classLoader) throws TinkerRuntimeException {
-        try {
-            if (appLikeGetClassLoader == null) {
-                appLikeGetClassLoader = ShareReflectUtil.findMethod(applicationLike, "getClassLoader", ClassLoader.class);
-            }
-            return (ClassLoader) appLikeGetClassLoader.invoke(appLike, classLoader);
-        } catch (Throwable thr) {
-            throw new TinkerRuntimeException("fail to invoke getClassLoader of appLike.", thr);
-        }
+        final Resources resources = super.getResources();
+        return (mBridge != null ? mBridge.getResources(resources) : resources);
     }
 
     @Override
     public ClassLoader getClassLoader() {
-        ClassLoader classLoader = super.getClassLoader();
-        if (applicationLike != null) {
-            return invokeAppLikeGetClassLoader(applicationLike, classLoader);
-        }
-        return classLoader;
-    }
-
-    private Method appLikeGetAssets = null;
-
-    private AssetManager invokeAppLikeGetAssets(Object appLike, AssetManager assetManager) throws TinkerRuntimeException {
-        try {
-            if (appLikeGetAssets == null) {
-                appLikeGetAssets = ShareReflectUtil.findMethod(applicationLike, "getAssets", AssetManager.class);
-            }
-            return (AssetManager) appLikeGetAssets.invoke(appLike, assetManager);
-        } catch (Throwable thr) {
-            throw new TinkerRuntimeException("fail to invoke getAssets of appLike.", thr);
-        }
+        final ClassLoader classLoader = super.getClassLoader();
+        return (mBridge != null ? mBridge.getClassLoader(classLoader) : classLoader);
     }
 
     @Override
     public AssetManager getAssets() {
-        AssetManager assetManager = super.getAssets();
-        if (applicationLike != null) {
-            return invokeAppLikeGetAssets(applicationLike, assetManager);
-        }
-        return assetManager;
-    }
-
-    private Method appLikeGetSystemService = null;
-
-    private Object invokeAppLikeGetSystemService(Object appLike, String name, Object service) throws TinkerRuntimeException {
-        try {
-            if (appLikeGetSystemService == null) {
-                appLikeGetSystemService = ShareReflectUtil.findMethod(applicationLike, "getSystemService", String.class, Object.class);
-            }
-            return appLikeGetSystemService.invoke(appLike, name, service);
-        } catch (Throwable thr) {
-            throw new TinkerRuntimeException("fail to invoke getSystemService of appLike.", thr);
-        }
+        final AssetManager assetManager = super.getAssets();
+        return (mBridge != null ? mBridge.getAssets(assetManager) : assetManager);
     }
 
     @Override
     public Object getSystemService(String name) {
-        Object service = super.getSystemService(name);
-        if (applicationLike != null) {
-            return invokeAppLikeGetSystemService(applicationLike, name, service);
-        }
-        return service;
-    }
-
-    private Method appLikeGetBaseContext = null;
-
-    private Object invokeAppLikeGetBaseContext(Object appLike, Context base) throws TinkerRuntimeException {
-        try {
-            if (appLikeGetBaseContext == null) {
-                appLikeGetBaseContext = ShareReflectUtil.findMethod(applicationLike, "getBaseContext", Context.class);
-            }
-            return appLikeGetBaseContext.invoke(appLike, base);
-        } catch (Throwable thr) {
-            throw new TinkerRuntimeException("fail to invoke getBaseContext of appLike.", thr);
-        }
+        final Object service = super.getSystemService(name);
+        return (mBridge != null ? mBridge.getSystemService(name, service) : service);
     }
 
     @Override
     public Context getBaseContext() {
-        Context base = super.getBaseContext();
-        if (applicationLike != null) {
-            return (Context) invokeAppLikeGetBaseContext(applicationLike, base);
-        }
-        return base;
+        final Context base = super.getBaseContext();
+        return (mBridge != null ? mBridge.getBaseContext(base) : base);
     }
 
     public void setUseSafeMode(boolean useSafeMode) {
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/hotplug/IncrementComponentManager.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/hotplug/IncrementComponentManager.java
index 4aef786c..8aa5ae2f 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/hotplug/IncrementComponentManager.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/hotplug/IncrementComponentManager.java
@@ -44,8 +44,8 @@
     private static Context sContext = null;
     private static String sPackageName = null;
     private static volatile boolean sInitialized = false;
-    private static final Map<String, ActivityInfo> sClassNameToActivityInfoMap = new HashMap<>();
-    private static final Map<String, IntentFilter> sClassNameToIntentFilterMap = new HashMap<>();
+    private static final Map<String, ActivityInfo> CLASS_NAME_TO_ACTIVITY_INFO_MAP = new HashMap<>();
+    private static final Map<String, IntentFilter> CLASS_NAME_TO_INTENT_FILTER_MAP = new HashMap<>();
 
 
     private static abstract class AttrTranslator<T_RESULT> {
@@ -71,7 +71,7 @@ void onInit(Context context, int tagType, XmlPullParser parser) {
         abstract void onTranslate(Context context, int tagType, String attrName, String attrValue, T_RESULT result);
     }
 
-    private static final AttrTranslator<ActivityInfo> sActivityInfoAttrTranslator = new AttrTranslator<ActivityInfo>() {
+    private static final AttrTranslator<ActivityInfo> ACTIVITY_INFO_ATTR_TRANSLATOR = new AttrTranslator<ActivityInfo>() {
 
         @Override
         void onInit(Context context, int tagType, XmlPullParser parser) {
@@ -365,7 +365,7 @@ public static synchronized boolean init(Context context, ShareSecurityCheck chec
                         final String tagName = parser.getName();
                         if ("activity".equalsIgnoreCase(tagName)) {
                             final ActivityInfo aInfo = parseActivity(context, parser);
-                            sClassNameToActivityInfoMap.put(aInfo.name, aInfo);
+                            CLASS_NAME_TO_ACTIVITY_INFO_MAP.put(aInfo.name, aInfo);
                         } else if ("service".equalsIgnoreCase(tagName)) {
                             // TODO support service component.
                         } else if ("receiver".equalsIgnoreCase(tagName)) {
@@ -420,7 +420,7 @@ private static synchronized ActivityInfo parseActivity(Context context, XmlPullP
             aInfo.uiOptions = appInfo.uiOptions;
         }
 
-        sActivityInfoAttrTranslator.translate(context, TAG_ACTIVITY, parser, aInfo);
+        ACTIVITY_INFO_ATTR_TRANSLATOR.translate(context, TAG_ACTIVITY, parser, aInfo);
 
         final int outerDepth = parser.getDepth();
         while (true) {
@@ -532,7 +532,7 @@ private static synchronized void parseIntentFilter(Context context, String compo
             skipCurrentTag(parser);
         }
 
-        sClassNameToIntentFilterMap.put(componentName, intentFilter);
+        CLASS_NAME_TO_INTENT_FILTER_MAP.put(componentName, intentFilter);
     }
 
     private static synchronized void parseMetaData(Context context, ActivityInfo aInfo, XmlPullParser parser)
@@ -565,12 +565,12 @@ private static synchronized void ensureInitialized() {
 
     public static boolean isIncrementActivity(String className) {
         ensureInitialized();
-        return className != null && sClassNameToActivityInfoMap.containsKey(className);
+        return className != null && CLASS_NAME_TO_ACTIVITY_INFO_MAP.containsKey(className);
     }
 
     public static ActivityInfo queryActivityInfo(String className) {
         ensureInitialized();
-        return (className != null ? sClassNameToActivityInfoMap.get(className) : null);
+        return (className != null ? CLASS_NAME_TO_ACTIVITY_INFO_MAP.get(className) : null);
     }
 
     // TODO needs to support rest type of components.
@@ -585,12 +585,12 @@ public static ResolveInfo resolveIntent(Intent intent) {
         final ComponentName component = intent.getComponent();
         if (component != null) {
             final String compName = component.getClassName();
-            if (sClassNameToActivityInfoMap.containsKey(compName)) {
+            if (CLASS_NAME_TO_ACTIVITY_INFO_MAP.containsKey(compName)) {
                 bestComponentName = compName;
                 maxPriority = 0;
             }
         } else {
-            for (Map.Entry<String, IntentFilter> item : sClassNameToIntentFilterMap.entrySet()) {
+            for (Map.Entry<String, IntentFilter> item : CLASS_NAME_TO_INTENT_FILTER_MAP.entrySet()) {
                 final String componentName = item.getKey();
                 final IntentFilter intentFilter = item.getValue();
                 final int matchRes = intentFilter.match(intent.getAction(), intent.getType(),
@@ -610,7 +610,7 @@ public static ResolveInfo resolveIntent(Intent intent) {
         }
         if (bestComponentName != null) {
             final ResolveInfo result = new ResolveInfo();
-            result.activityInfo = sClassNameToActivityInfoMap.get(bestComponentName);
+            result.activityInfo = CLASS_NAME_TO_ACTIVITY_INFO_MAP.get(bestComponentName);
             result.filter = respFilter;
             result.match = bestMatchRes;
             result.priority = maxPriority;
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareArkHotDiffPatchInfo.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareArkHotDiffPatchInfo.java
new file mode 100644
index 00000000..e77fc7b0
--- /dev/null
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareArkHotDiffPatchInfo.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the BSD 3-Clause License
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * the BSD 3-Clause License for more details.
+ */
+
+package com.tencent.tinker.loader.shareutil;
+
+import java.util.ArrayList;
+
+public class ShareArkHotDiffPatchInfo {
+    public String path;
+    public String name;
+    public String patchMd5;
+
+    public ShareArkHotDiffPatchInfo(String path, String name, String md5) {
+        this.name = name;
+        this.patchMd5 = md5;
+        this.path = path;
+    }
+
+    public static void parseDiffPatchInfo(String meta, ArrayList<ShareArkHotDiffPatchInfo> diffList) {
+        if (meta == null || diffList == null) {
+            return;
+        }
+
+        String[] lines = meta.split("\n");
+        for (final String line : lines) {
+            if (line == null || line.length() <= 0) {
+                continue;
+            }
+
+            final String[] kv = line.split(",", 4);
+            if (kv == null || kv.length < 3) {
+                continue;
+            }
+
+            final String name = kv[0].trim();
+            final String path = kv[1].trim();
+            final String md5 = kv[2].trim();
+
+            ShareArkHotDiffPatchInfo arkDiffInfo = new ShareArkHotDiffPatchInfo(path, name, md5);
+            diffList.add(arkDiffInfo);
+        }
+    }
+
+    public static boolean checkDiffPatchInfo(ShareArkHotDiffPatchInfo info) {
+        if (info == null) {
+            return false;
+        }
+        String name = info.name;
+        String md5 = info.patchMd5;
+        if (name == null || name.length() <= 0 || md5 == null || md5.length() != ShareConstants.MD5_LENGTH) {
+            return false;
+        }
+        return true;
+    }
+
+    @Override
+    public String toString() {
+        StringBuffer sb = new StringBuffer();
+        sb.append(name);
+        sb.append(",");
+        sb.append(path);
+        sb.append(",");
+        sb.append(patchMd5);
+
+        return sb.toString();
+    }
+}
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareConstants.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareConstants.java
index ca92cf3b..03a32695 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareConstants.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareConstants.java
@@ -35,6 +35,9 @@
     public static final String TINKER_ID     = "TINKER_ID";
     public static final String NEW_TINKER_ID = "NEW_TINKER_ID";
 
+    // Please keep it synchronized with the one defined in TypedValue.
+    public static final String PKGMETA_KEY_IS_PROTECTED_APP = "is_protected_app";
+
     public static final String OLD_VERSION     = "old";
     public static final String NEW_VERSION     = "new";
     public static final String PATCH_BASE_NAME = "patch-";
@@ -48,23 +51,23 @@
 
     public static final String DEX_META_FILE               = "assets/dex_meta.txt";
     public static final String DEX_PATH                    = "dex";
+    public static final String ARKHOTFIX_PATH = "arkHot";
     public static final String DEFAULT_DEX_OPTIMIZE_PATH   = "odex";
     public static final String ANDROID_O_DEX_OPTIMIZE_PATH = "oat";
 
     public static final String INTERPRET_DEX_OPTIMIZE_PATH = "interpet";
     public static final String CHANING_DEX_OPTIMIZE_PATH   = "changing";
 
-    public static final Pattern CLASS_N_PATTERN = Pattern.compile("classes(?:[2-9]{0,1}|[1-9][0-9]+)\\.dex(\\.jar)?");
-
-
     public static final String DEX_SUFFIX  = ".dex";
     public static final String JAR_SUFFIX  = ".jar";
     public static final String APK_SUFFIX  = ".apk";
     public static final String ODEX_SUFFIX = ".odex";
 
     public static final String TEST_DEX_NAME            = "test.dex";
-    public static final String CHANGED_CLASSES_DEX_PREFIX = "changed_classes";
     public static final String CLASS_N_APK_NAME         = "tinker_classN.apk";
+    public static final String ARKHOT_PATCH_NAME = "patch.apk";
+
+    public static final Pattern CLASS_N_PATTERN = Pattern.compile("classes(?:[2-9]?|[1-9][0-9]+)\\.dex(\\.jar)?");
 
     public static final String CHECK_DEX_INSTALL_FAIL = "checkDexInstall failed";
     public static final String CHECK_RES_INSTALL_FAIL = "checkResInstall failed";
@@ -72,7 +75,7 @@
     public static final String CHECK_DEX_OAT_EXIST_FAIL  = "checkDexOptExist failed";
     public static final String CHECK_DEX_OAT_FORMAT_FAIL = "checkDexOptFormat failed";
 
-//    public static final String CHECK_VM_PROPERTY_FAIL = "checkVmArtProperty failed";
+    // public static final String CHECK_VM_PROPERTY_FAIL = "checkVmArtProperty failed";
 
 
     public static final String RES_META_FILE       = "assets/res_meta.txt";
@@ -88,6 +91,7 @@
     public static final String RES_PATTERN_TITLE   = "pattern:";
     public static final String RES_STORE_TITLE     = "store:";
 
+    public static final String ARKHOT_META_FILE = "assets/arkHot_meta.txt";
 
     public static final String DEXMODE_RAW = "raw";
     public static final String DEXMODE_JAR = "jar";
@@ -132,14 +136,16 @@
     public static final int TYPE_LIBRARY     = 5;
     public static final int TYPE_RESOURCE    = 6;
     public static final int TYPE_CLASS_N_DEX = 7;
+    public static final int TYPE_ARKHOT_SO = 8;
 
 
     public static final int TINKER_DISABLE             = 0x00;
     public static final int TINKER_DEX_MASK            = 0x01;
     public static final int TINKER_NATIVE_LIBRARY_MASK = 0x02;
     public static final int TINKER_RESOURCE_MASK       = 0x04;
-    public static final int TINKER_DEX_AND_LIBRARY     = TINKER_DEX_MASK | TINKER_NATIVE_LIBRARY_MASK;
-    public static final int TINKER_ENABLE_ALL          = TINKER_DEX_MASK | TINKER_NATIVE_LIBRARY_MASK | TINKER_RESOURCE_MASK;
+    public static final int TINKER_ARKHOT_MASK = 0x08;
+    public static final int TINKER_DEX_AND_LIBRARY     = TINKER_DEX_MASK | TINKER_NATIVE_LIBRARY_MASK | TINKER_ARKHOT_MASK;
+    public static final int TINKER_ENABLE_ALL          = TINKER_DEX_MASK | TINKER_NATIVE_LIBRARY_MASK | TINKER_RESOURCE_MASK | TINKER_ARKHOT_MASK;
 
     //load error code
     public static final int ERROR_LOAD_OK                                      = 0;
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareFileLockHelper.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareFileLockHelper.java
index 63c266a8..7f889e41 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareFileLockHelper.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareFileLockHelper.java
@@ -54,7 +54,6 @@ private ShareFileLockHelper(File lockFile) throws IOException {
                 Thread.sleep(LOCK_WAIT_EACH_TIME);
 
             } catch (Exception e) {
-//                e.printStackTrace();
                 saveException = e;
                 Log.e(TAG, "getInfoLock Thread failed time:" + LOCK_WAIT_EACH_TIME);
             }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareIntentUtil.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareIntentUtil.java
index fcb3bb56..87199f78 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareIntentUtil.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareIntentUtil.java
@@ -31,6 +31,7 @@
     public static final  String INTENT_RETURN_CODE               = "intent_return_code";
     public static final  String INTENT_PATCH_OLD_VERSION         = "intent_patch_old_version";
     public static final  String INTENT_PATCH_NEW_VERSION         = "intent_patch_new_version";
+    public static final  String INTENT_IS_PROTECTED_APP          = "intent_is_protected_app";
     public static final  String INTENT_PATCH_MISMATCH_DEX_PATH   = "intent_patch_mismatch_dex_path";
     public static final  String INTENT_PATCH_MISSING_DEX_PATH    = "intent_patch_missing_dex_path";
     public static final  String INTENT_PATCH_DEXES_PATH          = "intent_patch_dexes_path";
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchFileUtil.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchFileUtil.java
index 3b552ed9..54492403 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchFileUtil.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchFileUtil.java
@@ -177,8 +177,18 @@ public static final boolean isLegalFile(File file) {
      * @return
      */
     public static final boolean shouldAcceptEvenIfIllegal(File file) {
-        return ("vivo".equalsIgnoreCase(Build.MANUFACTURER) || "oppo".equalsIgnoreCase(Build.MANUFACTURER))
-                && (!file.exists() || file.length() == 0);
+        final boolean isSpecialManufacturer =
+                "vivo".equalsIgnoreCase(Build.MANUFACTURER)
+             || "oppo".equalsIgnoreCase(Build.MANUFACTURER);
+
+        final boolean isSpecialOSVer =
+                (Build.VERSION.SDK_INT >= 29)
+             || (Build.VERSION.SDK_INT >= 28 && Build.VERSION.PREVIEW_SDK_INT != 0)
+             || (ShareTinkerInternals.isArkHotRuning());
+
+        final boolean isFileIllegal = !file.exists() || file.length() == 0;
+
+        return (isSpecialManufacturer || isSpecialOSVer) && isFileIllegal;
     }
 
     /**
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchInfo.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchInfo.java
index f3f97074..f9b7ad6f 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchInfo.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchInfo.java
@@ -36,20 +36,23 @@
     public static final int    MAX_EXTRACT_ATTEMPTS  = ShareConstants.MAX_EXTRACT_ATTEMPTS;
     public static final String OLD_VERSION           = ShareConstants.OLD_VERSION;
     public static final String NEW_VERSION           = ShareConstants.NEW_VERSION;
+    public static final String IS_PROTECTED_APP      = ShareConstants.PKGMETA_KEY_IS_PROTECTED_APP;
     public static final String IS_REMOVE_NEW_VERSION = "is_remove_new_version";
     public static final String FINGER_PRINT          = "print";
     public static final String OAT_DIR               = "dir";
     public static final String DEFAULT_DIR   = ShareConstants.DEFAULT_DEX_OPTIMIZE_PATH;
     public String oldVersion;
     public String newVersion;
+    public boolean isProtectedApp;
     public boolean isRemoveNewVersion;
     public String fingerPrint;
     public String oatDir;
 
-    public SharePatchInfo(String oldVer, String newVew, boolean isRemoveNewVersion, String finger, String oatDir) {
+    public SharePatchInfo(String oldVer, String newVer, boolean isProtectedApp, boolean isRemoveNewVersion, String finger, String oatDir) {
         // TODO Auto-generated constructor stub
         this.oldVersion = oldVer;
-        this.newVersion = newVew;
+        this.newVersion = newVer;
+        this.isProtectedApp = isProtectedApp;
         this.isRemoveNewVersion = isRemoveNewVersion;
         this.fingerPrint = finger;
         this.oatDir = oatDir;
@@ -118,6 +121,7 @@ private static SharePatchInfo readAndCheckProperty(File pathInfoFile) {
         String oldVer = null;
         String newVer = null;
         String lastFingerPrint = null;
+        boolean isProtectedApp = false;
         boolean isRemoveNewVersion = false;
         String oatDir = null;
 
@@ -130,11 +134,13 @@ private static SharePatchInfo readAndCheckProperty(File pathInfoFile) {
                 properties.load(inputStream);
                 oldVer = properties.getProperty(OLD_VERSION);
                 newVer = properties.getProperty(NEW_VERSION);
-                isRemoveNewVersion = !"0".equals(properties.getProperty(IS_REMOVE_NEW_VERSION));
+                final String isProtectedAppStr = properties.getProperty(IS_PROTECTED_APP);
+                isProtectedApp = (isProtectedAppStr != null && !isProtectedAppStr.isEmpty() && !"0".equals(isProtectedAppStr));
+                final String isRemoveNewVersionStr = properties.getProperty(IS_REMOVE_NEW_VERSION);
+                isRemoveNewVersion = (isRemoveNewVersionStr != null && !isRemoveNewVersionStr.isEmpty() && !"0".equals(isRemoveNewVersionStr));
                 lastFingerPrint = properties.getProperty(FINGER_PRINT);
                 oatDir = properties.getProperty(OAT_DIR);
             } catch (IOException e) {
-//                e.printStackTrace();
                 Log.w(TAG, "read property failed, e:" + e);
             } finally {
                 SharePatchFileUtil.closeQuietly(inputStream);
@@ -154,7 +160,7 @@ private static SharePatchInfo readAndCheckProperty(File pathInfoFile) {
         }
 
         if (isReadPatchSuccessful) {
-            return new SharePatchInfo(oldVer, newVer, isRemoveNewVersion, lastFingerPrint, oatDir);
+            return new SharePatchInfo(oldVer, newVer, isProtectedApp, isRemoveNewVersion, lastFingerPrint, oatDir);
         }
 
         return null;
@@ -177,6 +183,8 @@ private static boolean rewritePatchInfoFile(File pathInfoFile, SharePatchInfo in
             + info.oldVersion
             + ", newVer:"
             + info.newVersion
+            + ", isProtectedApp:"
+            + (info.isProtectedApp ? 1 : 0)
             + ", isRemoveNewVersion:"
             + (info.isRemoveNewVersion ? 1 : 0)
             + ", fingerprint:"
@@ -198,6 +206,7 @@ private static boolean rewritePatchInfoFile(File pathInfoFile, SharePatchInfo in
             Properties newProperties = new Properties();
             newProperties.put(OLD_VERSION, info.oldVersion);
             newProperties.put(NEW_VERSION, info.newVersion);
+            newProperties.put(IS_PROTECTED_APP, (info.isProtectedApp ? "1" : "0"));
             newProperties.put(IS_REMOVE_NEW_VERSION, (info.isRemoveNewVersion ? "1" : "0"));
             newProperties.put(FINGER_PRINT, info.fingerPrint);
             newProperties.put(OAT_DIR, info.oatDir);
@@ -208,7 +217,6 @@ private static boolean rewritePatchInfoFile(File pathInfoFile, SharePatchInfo in
                 String comment = "from old version:" + info.oldVersion + " to new version:" + info.newVersion;
                 newProperties.store(outputStream, comment);
             } catch (Exception e) {
-//                e.printStackTrace();
                 Log.w(TAG, "write property failed, e:" + e);
             } finally {
                 SharePatchFileUtil.closeQuietly(outputStream);
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java
old mode 100644
new mode 100755
index 594e79b0..7e0fa6c0
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java
@@ -30,6 +30,7 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.PrintStream;
+import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.util.HashMap;
 import java.util.List;
@@ -43,12 +44,13 @@
  * Created by zhangshaowen on 16/3/10.
  */
 public class ShareTinkerInternals {
-    private static final String  TAG       = "Tinker.TinkerInternals";
-    private static final boolean VM_IS_ART = isVmArt(System.getProperty("java.vm.version"));
-    private static final boolean VM_IS_JIT = isVmJitInternal();
-
+    private static final String  TAG                   = "Tinker.TinkerInternals";
+    private static final boolean VM_IS_ART             = isVmArt(System.getProperty("java.vm.version"));
+    private static final boolean VM_IS_JIT             = isVmJitInternal();
     private static final String  PATCH_PROCESS_NAME    = ":patch";
+
     private static       Boolean isPatchProcess        = null;
+    private static       Boolean isARKHotRunning       = false;
     /**
      * or you may just hardcode them in your app
      */
@@ -64,6 +66,35 @@ public static boolean isVmJit() {
         return VM_IS_JIT && Build.VERSION.SDK_INT < 24;
     }
 
+    public static boolean isArkHotRuning() {
+        if (isARKHotRunning != null) {
+            return isARKHotRunning;
+        }
+        isARKHotRunning = false;
+        Class<?> arkApplicationInfo = null;
+        try {
+            arkApplicationInfo = ClassLoader.getSystemClassLoader()
+                .getParent().loadClass("com.huawei.ark.app.ArkApplicationInfo");
+            Method isRunningInArkHot = null;
+            isRunningInArkHot = arkApplicationInfo.getDeclaredMethod("isRunningInArk");
+            isRunningInArkHot.setAccessible(true);
+            isARKHotRunning = (Boolean) isRunningInArkHot.invoke(null);
+        } catch (ClassNotFoundException e) {
+            Log.i(TAG, "class not found exception");
+        } catch (NoSuchMethodException e) {
+            Log.i(TAG, "no such method exception");
+        } catch (SecurityException e) {
+            Log.i(TAG, "security exception");
+        } catch (IllegalAccessException e) {
+            Log.i(TAG, "illegal access exception");
+        } catch (InvocationTargetException e) {
+            Log.i(TAG, "invocation target exception");
+        } catch (IllegalArgumentException e) {
+            Log.i(TAG, "illegal argument exception");
+        }
+        return isARKHotRunning;
+    }
+
     public static boolean isAfterAndroidO() {
         return Build.VERSION.SDK_INT > 25;
     }
@@ -270,6 +301,10 @@ public static boolean isTinkerEnabledForResource(int flag) {
         return (flag & ShareConstants.TINKER_RESOURCE_MASK) != 0;
     }
 
+    public static boolean isTinkerEnabledForArkHot(int flag) {
+        return (flag & ShareConstants.TINKER_ARKHOT_MASK) != 0;
+    }
+
     public static String getTypeString(int type) {
         switch (type) {
             case ShareConstants.TYPE_DEX:
@@ -296,7 +331,7 @@ public static String getTypeString(int type) {
      */
     public static void setTinkerDisableWithSharedPreferences(Context context) {
         SharedPreferences sp = context.getSharedPreferences(ShareConstants.TINKER_SHARE_PREFERENCE_CONFIG, Context.MODE_MULTI_PROCESS);
-        String keyName = ShareConstants.TINKER_ENABLE_CONFIG_PREFIX + ShareConstants.TINKER_VERSION;
+        String keyName = getTinkerSwitchSPKey(context);
         sp.edit().putBoolean(keyName, false).commit();
     }
 
@@ -311,10 +346,18 @@ public static boolean isTinkerEnableWithSharedPreferences(Context context) {
             return false;
         }
         SharedPreferences sp = context.getSharedPreferences(ShareConstants.TINKER_SHARE_PREFERENCE_CONFIG, Context.MODE_MULTI_PROCESS);
-        String keyName = ShareConstants.TINKER_ENABLE_CONFIG_PREFIX + ShareConstants.TINKER_VERSION;
+        String keyName = getTinkerSwitchSPKey(context);
         return sp.getBoolean(keyName, true);
     }
 
+    private static String getTinkerSwitchSPKey(Context context) {
+        String tmpTinkerId = getManifestTinkerID(context);
+        if (isNullOrNil(tmpTinkerId)) {
+            tmpTinkerId = "@@";
+        }
+        return ShareConstants.TINKER_ENABLE_CONFIG_PREFIX + ShareConstants.TINKER_VERSION + "_" + tmpTinkerId;
+    }
+
     public static int getSafeModeCount(Context context) {
         String processName = ShareTinkerInternals.getProcessName(context);
         String preferName = ShareConstants.TINKER_OWN_PREFERENCE_CONFIG_PREFIX + processName;
@@ -492,6 +535,7 @@ private static String getProcessNameInternal(final Context context) {
                     in.close();
                 }
             } catch (Exception e) {
+                // Ignored.
             }
         }
 
diff --git a/tinker-build/tinker-patch-cli/build.gradle b/tinker-build/tinker-patch-cli/build.gradle
index f3fdb305..eccbf06c 100644
--- a/tinker-build/tinker-patch-cli/build.gradle
+++ b/tinker-build/tinker-patch-cli/build.gradle
@@ -1,4 +1,5 @@
 apply plugin: 'java-library'
+apply plugin: "com.github.johnrengelman.shadow"
 
 version rootProject.ext.VERSION_NAME
 group rootProject.ext.GROUP
@@ -15,17 +16,10 @@ jar {
         attributes 'Main-Class': 'com.tencent.tinker.patch.CliMain'
         attributes 'Manifest-Version': version
     }
-    from {
-        configurations.compileClasspath.collect { it.isDirectory() ? it : zipTree(it) }
-    } {
-        exclude "META-INF/*.SF"
-        exclude "META-INF/*.DSA"
-        exclude "META-INF/*.RSA"
-    }
 }
 
 // copy the jar to work directory
-task buildTinkerSdk(type: Copy, dependsOn: [build, jar]) {
+task buildTinkerSdk(type: Copy, dependsOn: [clean, shadowJar]) {
     group = "tinker"
     from('build/libs') {
         include '*.jar'
diff --git a/tinker-build/tinker-patch-cli/tool_maple/DexCmp.jar b/tinker-build/tinker-patch-cli/tool_maple/DexCmp.jar
new file mode 100644
index 00000000..e552ffa1
Binary files /dev/null and b/tinker-build/tinker-patch-cli/tool_maple/DexCmp.jar differ
diff --git a/tinker-build/tinker-patch-cli/tool_maple/build_patch_dexdiff.sh b/tinker-build/tinker-patch-cli/tool_maple/build_patch_dexdiff.sh
new file mode 100644
index 00000000..367416da
--- /dev/null
+++ b/tinker-build/tinker-patch-cli/tool_maple/build_patch_dexdiff.sh
@@ -0,0 +1,88 @@
+#!/bin/bash
+helpme()
+{
+    echo "Build patch zip"
+    echo "USAGE:"
+    echo "       ./build_patch_dexdiff.sh [old=old.apk path] [new=new.apk path]"
+    echo "EXAMPLE:"
+    echo "       ./build_patch_dexdiff.sh old=/old.apk new=/new.apk"
+    exit 1
+}
+
+parse_cmdline()
+{
+    while [[ -n "$1" ]]
+    do
+        OPTIONS=`echo "$1" | sed 's/\(.*\)=\(.*\)/\1/'`
+        PARAM=`echo "$1" | sed 's/.*=//'`
+        if [[ "$1" != *=* ]];then
+            helpme
+            CHECK_FLAG=0
+        fi
+        case "$OPTIONS" in
+        old)     OLD_APK_PATH=${PARAM};;
+        new)     NEW_APK_PATH=${PARAM};;
+        #please add extra parameter here!
+        *)  if [[ `echo "$1" | sed -n "/.*=/p"` ]];then
+                echo "Error, the pattem \"$OPTIONS=${PARAM}\" can not be recognized!!!"
+                helpme
+            fi
+            break;;
+        esac
+        shift
+    done
+    COMMAND_ARGS=$@
+}
+
+initParameter()
+{
+    OLD_FILE=`pwd`/old_file
+    NEW_FILE=`pwd`/new_file
+}
+
+dexdiff()
+{
+    mkdir ${OLD_FILE}
+    pushd ${OLD_FILE}
+    unzip -o ${OLD_APK_PATH} -d ${OLD_FILE}
+    OLD_DEX_COUNT=`ls | grep classes | wc -l`
+    OLD_DEX_SET=${OLD_FILE}/classes.dex
+    for count in `seq 2 ${OLD_DEX_COUNT}`
+    do
+        OLD_DEX_SET="${OLD_DEX_SET} ${OLD_FILE}/classes$count.dex"
+    done
+    popd
+
+    mkdir ${NEW_FILE}
+    pushd ${NEW_FILE}
+    unzip -o ${NEW_APK_PATH} -d ${NEW_FILE}
+    NEW_DEX_COUNT=`ls | grep classes | wc -l`
+    NEW_DEX_SET=${NEW_FILE}/classes.dex
+    for count in `seq 2 ${NEW_DEX_COUNT}`
+    do
+        NEW_DEX_SET="${NEW_DEX_SET} ${NEW_FILE}/classes$count.dex"
+    done
+    popd
+
+    dexcmp -n ${NEW_DEX_SET} -o ${OLD_DEX_SET} -f `pwd`/patch.dex
+}
+
+dexcmp()
+{
+    java -cp "./DexCmp.jar" "io.qivaz.dex.cmp.DexCmp" "$@"
+}
+
+zipPatch()
+{
+    zip -m0 patch.apk ./patch.dex
+    zip -m0 patch.apk ./new_file/classes.dex
+    for count in `seq 2 ${NEW_DEX_COUNT}`
+    do
+        zip -m0 patch.apk ./new_file/classes${count}.dex
+    done
+}
+
+parse_cmdline $@
+initParameter
+dexdiff
+zipPatch
diff --git a/tinker-build/tinker-patch-cli/tool_output/tinker_config.xml b/tinker-build/tinker-patch-cli/tool_output/tinker_config.xml
index f2220cbd..745e6535 100644
--- a/tinker-build/tinker-patch-cli/tool_output/tinker_config.xml
+++ b/tinker-build/tinker-patch-cli/tool_output/tinker_config.xml
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="UTF-8"?>
+ <?xml version="1.0" encoding="UTF-8"?>
 <!--command version is not recommended, you must add the tinker proguard file and multiDex keep file yourself-->
 <!--further, you must put TINKER_ID in your your AndroidManifest.xml such as <meta-data android:name="TINKER_ID" android:value="b168b32"/>-->
 <!--and you'd better use applymapping to build the patch apk-->
@@ -69,6 +69,11 @@
         <pattern value="lib/*/*.so"/>
     </issue>
 
+    <issue id="ark">
+        <path value="ark"/>
+        <name value="patch.apk"/>
+    </issue>
+
     <issue id="resource">
         <!--what resource in apk are expected to deal with tinkerPatch-->
         <!--it support * or ? pattern.-->
diff --git a/tinker-build/tinker-patch-gradle-plugin/build.gradle b/tinker-build/tinker-patch-gradle-plugin/build.gradle
index 0f646ed2..181cc173 100644
--- a/tinker-build/tinker-patch-gradle-plugin/build.gradle
+++ b/tinker-build/tinker-patch-gradle-plugin/build.gradle
@@ -10,7 +10,7 @@ dependencies {
 //    implementation fileTree(dir: 'libs', include: ['*.jar'])
     implementation project(':tinker-build:tinker-patch-lib')
     implementation 'com.google.gradle:osdetector-gradle-plugin:1.6.0'
-    implementation 'com.android.tools.build:gradle:3.2.1'
+    compileOnly 'com.android.tools.build:gradle:3.1.4'
 }
 
 repositories {
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/TinkerPatchPlugin.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/TinkerPatchPlugin.groovy
index ee61556b..c102dbf2 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/TinkerPatchPlugin.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/TinkerPatchPlugin.groovy
@@ -16,6 +16,7 @@
 
 package com.tencent.tinker.build.gradle
 
+import com.android.build.api.transform.Transform
 import com.tencent.tinker.build.gradle.extension.*
 import com.tencent.tinker.build.gradle.task.*
 import com.tencent.tinker.build.util.FileOperation
@@ -25,6 +26,11 @@ import org.gradle.api.GradleException
 import org.gradle.api.Plugin
 import org.gradle.api.Project
 import org.gradle.api.Task
+import org.gradle.api.file.FileCollection
+import org.jetbrains.annotations.NotNull
+
+import java.lang.reflect.Field
+import java.lang.reflect.Modifier
 
 /**
  * Registers the plugin's tasks.
@@ -34,31 +40,37 @@ import org.gradle.api.Task
 
 class TinkerPatchPlugin implements Plugin<Project> {
     public static final String TINKER_INTERMEDIATES = "build/intermediates/tinker_intermediates/"
+    public static final String ISSUE_URL = "https://github.com/Tencent/tinker/issues"
+
+    private Project mProject = null
 
     @Override
     public void apply(Project project) {
+        mProject = project
+
         //osdetector change its plugin name in 1.4.0
         try {
-            project.apply plugin: 'osdetector'
+            mProject.apply plugin: 'osdetector'
         } catch (Throwable e) {
-            project.apply plugin: 'com.google.osdetector'
+            mProject.apply plugin: 'com.google.osdetector'
         }
 
-        project.extensions.create('tinkerPatch', TinkerPatchExtension)
+        mProject.extensions.create('tinkerPatch', TinkerPatchExtension)
 
-        project.tinkerPatch.extensions.create('buildConfig', TinkerBuildConfigExtension, project)
+        mProject.tinkerPatch.extensions.create('buildConfig', TinkerBuildConfigExtension, mProject)
 
-        project.tinkerPatch.extensions.create('dex', TinkerDexExtension, project)
-        project.tinkerPatch.extensions.create('lib', TinkerLibExtension)
-        project.tinkerPatch.extensions.create('res', TinkerResourceExtension)
-        project.tinkerPatch.extensions.create('packageConfig', TinkerPackageConfigExtension, project)
-        project.tinkerPatch.extensions.create('sevenZip', TinkerSevenZipExtension, project)
+        mProject.tinkerPatch.extensions.create('dex', TinkerDexExtension, mProject)
+        mProject.tinkerPatch.extensions.create('lib', TinkerLibExtension)
+        mProject.tinkerPatch.extensions.create('res', TinkerResourceExtension)
+        mProject.tinkerPatch.extensions.create("arkHot", TinkerArkHotExtension)
+        mProject.tinkerPatch.extensions.create('packageConfig', TinkerPackageConfigExtension, mProject)
+        mProject.tinkerPatch.extensions.create('sevenZip', TinkerSevenZipExtension, mProject)
 
-        if (!project.plugins.hasPlugin('com.android.application')) {
+        if (!mProject.plugins.hasPlugin('com.android.application')) {
             throw new GradleException('generateTinkerApk: Android Application plugin required')
         }
 
-        def android = project.extensions.android
+        def android = mProject.extensions.android
 
         try {
             //close preDexLibraries
@@ -75,48 +87,48 @@ class TinkerPatchPlugin implements Plugin<Project> {
             //no preDexLibraries field, just continue
         }
 
-        project.afterEvaluate {
-            def configuration = project.tinkerPatch
+        mProject.afterEvaluate {
+            def configuration = mProject.tinkerPatch
 
             if (!configuration.tinkerEnable) {
-                project.logger.error("tinker tasks are disabled.")
+                mProject.logger.error("tinker tasks are disabled.")
                 return
             }
 
-            project.logger.error("----------------------tinker build warning ------------------------------------")
-            project.logger.error("tinker auto operation: ")
-            project.logger.error("excluding annotation processor and source template from app packaging. Enable dx jumboMode to reduce package size.")
-            project.logger.error("enable dx jumboMode to reduce package size.")
-            project.logger.error("disable preDexLibraries to prevent ClassDefNotFoundException when your app is booting.")
-            project.logger.error("disable archive dex mode so far for keeping dex apply.")
-            project.logger.error("")
-            project.logger.error("tinker will change your build configs:")
-            project.logger.error("we will add TINKER_ID=${configuration.buildConfig.tinkerId} in your build output manifest file build/intermediates/manifests/full/*")
-            project.logger.error("")
-            project.logger.error("if minifyEnabled is true")
+            mProject.logger.error("----------------------tinker build warning ------------------------------------")
+            mProject.logger.error("tinker auto operation: ")
+            mProject.logger.error("excluding annotation processor and source template from app packaging. Enable dx jumboMode to reduce package size.")
+            mProject.logger.error("enable dx jumboMode to reduce package size.")
+            mProject.logger.error("disable preDexLibraries to prevent ClassDefNotFoundException when your app is booting.")
+            mProject.logger.error("disable archive dex mode so far for keeping dex apply.")
+            mProject.logger.error("")
+            mProject.logger.error("tinker will change your build configs:")
+            mProject.logger.error("we will add TINKER_ID=${configuration.buildConfig.tinkerId} in your build output manifest file build/intermediates/manifests/full/*")
+            mProject.logger.error("")
+            mProject.logger.error("if minifyEnabled is true")
 
             String tempMappingPath = configuration.buildConfig.applyMapping
 
             if (FileOperation.isLegalFile(tempMappingPath)) {
-                project.logger.error("we will build ${project.getName()} apk with apply mapping file ${tempMappingPath}")
+                mProject.logger.error("we will build ${mProject.getName()} apk with apply mapping file ${tempMappingPath}")
             }
 
-            project.logger.error("you will find the gen proguard rule file at ${TinkerProguardConfigTask.PROGUARD_CONFIG_PATH}")
-            project.logger.error("and we will help you to put it in the proguardFiles.")
-            project.logger.error("")
-            project.logger.error("if multiDexEnabled is true")
-            project.logger.error("you will find the gen multiDexKeepProguard file at ${TinkerMultidexConfigTask.MULTIDEX_CONFIG_PATH}")
-            project.logger.error("and we will help you to put it in the MultiDexKeepProguardFile.")
-            project.logger.error("")
-            project.logger.error("if applyResourceMapping file is exist")
+            mProject.logger.error("you will find the gen proguard rule file at ${TinkerProguardConfigTask.PROGUARD_CONFIG_PATH}")
+            mProject.logger.error("and we will help you to put it in the proguardFiles.")
+            mProject.logger.error("")
+            mProject.logger.error("if multiDexEnabled is true")
+            mProject.logger.error("you will find the gen multiDexKeepProguard file at ${TinkerMultidexConfigTask.MULTIDEX_CONFIG_PATH}")
+            mProject.logger.error("and we will help you to put it in the MultiDexKeepProguardFile.")
+            mProject.logger.error("")
+            mProject.logger.error("if applyResourceMapping file is exist")
             String tempResourceMappingPath = configuration.buildConfig.applyResourceMapping
             if (FileOperation.isLegalFile(tempResourceMappingPath)) {
-                project.logger.error("we will build ${project.getName()} apk with resource R.txt ${tempResourceMappingPath} file")
+                mProject.logger.error("we will build ${mProject.getName()} apk with resource R.txt ${tempResourceMappingPath} file")
             } else {
-                project.logger.error("we will build ${project.getName()} apk with resource R.txt file")
+                mProject.logger.error("we will build ${mProject.getName()} apk with resource R.txt file")
             }
-            project.logger.error("if resources.arsc has changed, you should use applyResource mode to build the new apk!")
-            project.logger.error("-----------------------------------------------------------------")
+            mProject.logger.error("if resources.arsc has changed, you should use applyResource mode to build the new apk!")
+            mProject.logger.error("-----------------------------------------------------------------")
 
             android.applicationVariants.all { variant ->
 
@@ -124,7 +136,7 @@ class TinkerPatchPlugin implements Plugin<Project> {
                 def variantName = variant.name.capitalize()
                 def variantData = variant.variantData
 
-                def instantRunTask = getInstantRunTask(project, variantName)
+                def instantRunTask = getInstantRunTask(variantName)
                 if (instantRunTask != null) {
                     throw new GradleException(
                             "Tinker does not support instant run mode, please trigger build"
@@ -133,7 +145,7 @@ class TinkerPatchPlugin implements Plugin<Project> {
                     )
                 }
 
-                TinkerPatchSchemaTask tinkerPatchBuildTask = project.tasks.create("tinkerPatch${variantName}", TinkerPatchSchemaTask)
+                TinkerPatchSchemaTask tinkerPatchBuildTask = mProject.tasks.create("tinkerPatch${variantName}", TinkerPatchSchemaTask)
 
                 tinkerPatchBuildTask.signConfig = variantData.variantConfiguration.signingConfig
 
@@ -145,35 +157,62 @@ class TinkerPatchPlugin implements Plugin<Project> {
                 // Create a task to add a build TINKER_ID to AndroidManifest.xml
                 // This task must be called after "process${variantName}Manifest", since it
                 // requires that an AndroidManifest.xml exists in `build/intermediates`.
-                TinkerManifestTask manifestTask = project.tasks.create("tinkerProcess${variantName}Manifest", TinkerManifestTask)
+                TinkerManifestTask manifestTask = mProject.tasks.create("tinkerProcess${variantName}Manifest", TinkerManifestTask)
 
-                if (variantOutput.processManifest.properties['manifestOutputFile'] != null) {
-                    manifestTask.manifestPath = variantOutput.processManifest.manifestOutputFile
-                } else if (variantOutput.processResources.properties['manifestFile'] != null) {
+
+                if (variantOutput.metaClass.hasProperty(variantOutput, 'processResourcesProvider')) {
+                    manifestTask.manifestPath = variantOutput.processResourcesProvider.get().manifestFile
+                } else if (variantOutput.processResources.metaClass.hasProperty(variantOutput.processResources, 'manifestFile')) {
                     manifestTask.manifestPath = variantOutput.processResources.manifestFile
+                } else if (variantOutput.processManifest.metaClass.hasProperty(variantOutput.processManifest, 'manifestOutputFile')) {
+                    manifestTask.manifestPath = variantOutput.processManifest.manifestOutputFile
+                }
+
+
+                if (variantOutput.metaClass.hasProperty(variantOutput, 'processManifestProvider')) {
+                    manifestTask.mustRunAfter variantOutput.processManifestProvider.get()
+                } else {
+                    manifestTask.mustRunAfter variantOutput.processManifest
                 }
-                manifestTask.mustRunAfter variantOutput.processManifest
 
-                variantOutput.processResources.dependsOn manifestTask
+
+                if (variantOutput.metaClass.hasProperty(variantOutput, 'processResourcesProvider')) {
+                    variantOutput.processResourcesProvider.get().dependsOn manifestTask
+                } else {
+                    variantOutput.processResources.dependsOn manifestTask
+                }
 
                 //resource id
-                TinkerResourceIdTask applyResourceTask = project.tasks.create("tinkerProcess${variantName}ResourceId", TinkerResourceIdTask)
+                TinkerResourceIdTask applyResourceTask = mProject.tasks.create("tinkerProcess${variantName}ResourceId", TinkerResourceIdTask)
                 applyResourceTask.applicationId = variantData.getApplicationId()
                 applyResourceTask.variantName = variant.name
 
-                if (variantOutput.processResources.properties['resDir'] != null) {
-                    applyResourceTask.resDir = variantOutput.processResources.resDir
-                } else if (variantOutput.processResources.properties['inputResourcesDir'] != null) {
+
+                if (variantOutput.metaClass.hasProperty(variantOutput, 'processResourcesProvider')) {
+                    try {
+                        applyResourceTask.resDir = variantOutput.processResourcesProvider.get().inputResourcesDir.getAsFile().get()
+                    } catch (Exception e) {
+                        applyResourceTask.resDir = variantOutput.processResourcesProvider.get().inputResourcesDir.getFiles().first()
+                    }
+                } else if (variantOutput.processResources.metaClass.hasProperty(variantOutput.processResources, 'inputResourcesDir')) {
                     applyResourceTask.resDir = variantOutput.processResources.inputResourcesDir.getFiles().first()
+                } else if (variantOutput.processResources.metaClass.hasProperty(variantOutput.processResources, 'resDir')) {
+                    applyResourceTask.resDir = variantOutput.processResources.resDir
                 }
+
                 //let applyResourceTask run after manifestTask
                 applyResourceTask.mustRunAfter manifestTask
 
-                variantOutput.processResources.dependsOn applyResourceTask
+                if (variantOutput.metaClass.hasProperty(variantOutput, 'processResourcesProvider')) {
+                    variantOutput.processResourcesProvider.get().dependsOn applyResourceTask
+                } else {
+                    variantOutput.processResources.dependsOn applyResourceTask
+                }
+
                 // Fix issue-866.
                 // We found some case that applyResourceTask run after mergeResourcesTask, it caused 'applyResourceMapping' config not work.
                 // The task need merged resources to calculate ids.xml, it must depends on merge resources task.
-                def mergeResourcesTask = project.tasks.findByName("merge${variantName.capitalize()}Resources")
+                def mergeResourcesTask = mProject.tasks.findByName("merge${variantName.capitalize()}Resources")
                 applyResourceTask.dependsOn mergeResourcesTask
 
                 if (manifestTask.manifestPath == null || applyResourceTask.resDir == null) {
@@ -184,42 +223,67 @@ class TinkerPatchPlugin implements Plugin<Project> {
                 boolean proguardEnable = variant.getBuildType().buildType.minifyEnabled
 
                 if (proguardEnable) {
-                    TinkerProguardConfigTask proguardConfigTask = project.tasks.create("tinkerProcess${variantName}Proguard", TinkerProguardConfigTask)
+                    TinkerProguardConfigTask proguardConfigTask = mProject.tasks.create("tinkerProcess${variantName}Proguard", TinkerProguardConfigTask)
                     proguardConfigTask.applicationVariant = variant
                     proguardConfigTask.mustRunAfter manifestTask
 
-                    def proguardTask = getProguardTask(project, variantName)
-                    if (proguardTask != null) {
-                        proguardTask.dependsOn proguardConfigTask
-                    }
-
+                    def obfuscateTask = getObfuscateTask(variantName)
+                    obfuscateTask.dependsOn proguardConfigTask
                 }
 
                 // Add this multidex proguard settings file to the list
                 boolean multiDexEnabled = variantData.variantConfiguration.isMultiDexEnabled()
 
                 if (multiDexEnabled) {
-                    TinkerMultidexConfigTask multidexConfigTask = project.tasks.create("tinkerProcess${variantName}MultidexKeep", TinkerMultidexConfigTask)
+                    TinkerMultidexConfigTask multidexConfigTask = mProject.tasks.create("tinkerProcess${variantName}MultidexKeep", TinkerMultidexConfigTask)
                     multidexConfigTask.applicationVariant = variant
+                    multidexConfigTask.multiDexKeepProguard = getManifestMultiDexKeepProguard(variant)
                     multidexConfigTask.mustRunAfter manifestTask
 
                     // for java.io.FileNotFoundException: app/build/intermediates/multi-dex/release/manifest_keep.txt
                     // for gradle 3.x gen manifest_keep move to processResources task
-                    multidexConfigTask.mustRunAfter variantOutput.processResources
 
-                    def multidexTask = getMultiDexTask(project, variantName)
+                    if (variantOutput.metaClass.hasProperty(variantOutput, 'processResourcesProvider')) {
+                        multidexConfigTask.mustRunAfter variantOutput.processResourcesProvider.get()
+                    } else {
+                        multidexConfigTask.mustRunAfter variantOutput.processResources
+                    }
+
+
+                    def multidexTask = getMultiDexTask(variantName)
+                    def r8Task = getR8Task(variantName)
                     if (multidexTask != null) {
                         multidexTask.dependsOn multidexConfigTask
+                    } else if (multidexTask == null && r8Task != null) {
+                        r8Task.dependsOn multidexConfigTask
+                        Transform r8Transform = r8Task.getTransform()
+                        //R8 maybe forget to add multidex keep proguard file in agp 3.4.0, it's a agp bug!
+                        //If we don't do it, some classes will not keep in maindex such as loader's classes.
+                        //So tinker will not remove loader's classes, it will crashed in dalvik and will check TinkerTestDexLoad.isPatch failed in art.
+                        if (r8Transform.metaClass.hasProperty(r8Transform, "mainDexRulesFiles")) {
+                            File manifestMultiDexKeepProguard = getManifestMultiDexKeepProguard(variant)
+                            if (manifestMultiDexKeepProguard != null) {
+                                //see difference between mainDexRulesFiles and mainDexListFiles in https://developer.android.com/studio/build/multidex?hl=zh-cn
+                                FileCollection originalFiles = r8Transform.metaClass.getProperty(r8Transform, 'mainDexRulesFiles')
+                                if (!originalFiles.contains(manifestMultiDexKeepProguard)) {
+                                    FileCollection replacedFiles = mProject.files(originalFiles, manifestMultiDexKeepProguard)
+                                    mProject.logger.error("R8Transform original mainDexRulesFiles: ${originalFiles.files}")
+                                    mProject.logger.error("R8Transform replaced mainDexRulesFiles: ${replacedFiles.files}")
+                                    //it's final, use reflect to replace it.
+                                    replaceKotlinFinalField("com.android.build.gradle.internal.transforms.R8Transform", "mainDexRulesFiles", r8Transform, replacedFiles)
+                                }
+                            }
+                        }
                     }
-                    def collectMultiDexComponentsTask = getCollectMultiDexComponentsTask(project, variantName)
+                    def collectMultiDexComponentsTask = getCollectMultiDexComponentsTask(variantName)
                     if (collectMultiDexComponentsTask != null) {
                         multidexConfigTask.mustRunAfter collectMultiDexComponentsTask
                     }
                 }
 
                 if (configuration.buildConfig.keepDexApply
-                        && FileOperation.isLegalFile(project.tinkerPatch.oldApk)) {
-                    com.tencent.tinker.build.gradle.transform.ImmutableDexTransform.inject(project, variant)
+                        && FileOperation.isLegalFile(mProject.tinkerPatch.oldApk)) {
+                    com.tencent.tinker.build.gradle.transform.ImmutableDexTransform.inject(mProject, variant)
                 }
             }
         }
@@ -234,7 +298,24 @@ class TinkerPatchPlugin implements Plugin<Project> {
      * @param tinkerPatchBuildTask the task that tinker patch uses
      */
     void setPatchOutputFolder(configuration, output, variant, tinkerPatchBuildTask) {
-        File parentFile = output.outputFile
+        File parentFile = null
+
+        if (variant.metaClass.hasProperty(variant, 'packageApplicationProvider')) {
+            def packageAndroidArtifact = variant.packageApplicationProvider.get()
+            if (packageAndroidArtifact != null) {
+                try {
+                    parentFile = new File(packageAndroidArtifact.outputDirectory.getAsFile().get(), output.apkData.outputFileName)
+                } catch (Exception e) {
+                    parentFile = new File(packageAndroidArtifact.outputDirectory, output.apkData.outputFileName)
+                }
+            } else {
+                parentFile = output.mainOutputFile.outputFile
+            }
+        } else {
+            parentFile = output.outputFile
+        }
+
+
         String outputFolder = "${configuration.outputFolder}";
         if (!Utils.isNullOrNil(outputFolder)) {
             outputFolder = "${outputFolder}/${TypedValue.PATH_DEFAULT_OUTPUT}/${variant.dirName}"
@@ -258,7 +339,7 @@ class TinkerPatchPlugin implements Plugin<Project> {
             // To some extends, class not found means we are in lower version of android gradle
             // plugin, so just ignore that exception.
             if (!(thr instanceof ClassNotFoundException)) {
-                project.logger.error("reflectDexArchiveFlag error: ${thr.getMessage()}.")
+                mProject.logger.error("reflectDexArchiveFlag error: ${thr.getMessage()}.")
             }
         }
     }
@@ -282,28 +363,137 @@ class TinkerPatchPlugin implements Plugin<Project> {
             }
         }
 
-        tinkerPatchBuildTask.buildApkPath = output.outputFile
-        tinkerPatchBuildTask.dependsOn variant.assemble
+        if (variant.metaClass.hasProperty(variant, 'packageApplicationProvider')) {
+            def packageAndroidArtifact = variant.packageApplicationProvider.get()
+            if (packageAndroidArtifact != null) {
+                try {
+                    tinkerPatchBuildTask.buildApkPath = new File(packageAndroidArtifact.outputDirectory.getAsFile().get(), output.apkData.outputFileName)
+                } catch (Exception e) {
+                    tinkerPatchBuildTask.buildApkPath = new File(packageAndroidArtifact.outputDirectory, output.apkData.outputFileName)
+                }
+            } else {
+                tinkerPatchBuildTask.buildApkPath = output.mainOutputFile.outputFile
+            }
+        } else {
+            tinkerPatchBuildTask.buildApkPath = output.outputFile
+        }
+
+        if (variant.metaClass.hasProperty(variant, 'assembleProvider')) {
+            tinkerPatchBuildTask.dependsOn variant.assembleProvider.get()
+        } else {
+            tinkerPatchBuildTask.dependsOn variant.assemble
+        }
+
+
+    }
+
+    Task getMultiDexTask(String variantName) {
+        String multiDexTaskName = "multiDexList${variantName}"
+        String multiDexTaskTransformName = "transformClassesWithMultidexlistFor${variantName}"
+
+        def multiDexTask = mProject.tasks.findByName(multiDexTaskName)
+        if (multiDexTask == null) {
+            multiDexTask = mProject.tasks.findByName(multiDexTaskTransformName)
+        }
+
+        return multiDexTask
     }
 
-    Task getMultiDexTask(Project project, String variantName) {
-        String multiDexTaskName = "transformClassesWithMultidexlistFor${variantName}"
-        return project.tasks.findByName(multiDexTaskName)
+    Task getR8Task(String variantName) {
+        String r8TaskName = "transformClassesAndResourcesWithR8For${variantName}"
+        return mProject.tasks.findByName(r8TaskName)
     }
 
-    Task getProguardTask(Project project, String variantName) {
+    @NotNull
+    Task getObfuscateTask(String variantName) {
         String proguardTaskName = "transformClassesAndResourcesWithProguardFor${variantName}"
-        return project.tasks.findByName(proguardTaskName)
+        def proguard = mProject.tasks.findByName(proguardTaskName)
+        if (proguard != null) {
+            return proguard
+        }
+
+        String r8TaskName = "transformClassesAndResourcesWithR8For${variantName}"
+        def r8 = mProject.tasks.findByName(r8TaskName)
+        if (r8 != null) {
+            return r8
+        }
+
+        // in case that Google changes the task name in later versions
+        throw new GradleException(String.format("The minifyEnabled is enabled for '%s', but " +
+                "tinker cannot find the task, we have try '%s' and '%s'.\n" +
+                "Please submit issue to us: %s", variant,
+                proguardTaskName, r8TaskName, ISSUE_URL))
     }
 
-    Task getInstantRunTask(Project project, String variantName) {
+    Task getInstantRunTask(String variantName) {
         String instantRunTask = "transformClassesWithInstantRunFor${variantName}"
-        return project.tasks.findByName(instantRunTask)
+        return mProject.tasks.findByName(instantRunTask)
     }
 
-    Task getCollectMultiDexComponentsTask(Project project, String variantName) {
+    Task getCollectMultiDexComponentsTask(String variantName) {
         String collectMultiDexComponents = "collect${variantName}MultiDexComponents"
-        return project.tasks.findByName(collectMultiDexComponents)
+        return mProject.tasks.findByName(collectMultiDexComponents)
+    }
+
+    void replaceKotlinFinalField(String className, String filedName, Object instance, Object fieldValue) {
+        Field field = Class.forName(className).getDeclaredField(filedName)
+        Field modifiersField = Field.class.getDeclaredField("modifiers")
+        modifiersField.setAccessible(true)
+        modifiersField.setInt(field, field.getModifiers() & ~Modifier.FINAL)
+        field.setAccessible(true)
+        field.set(instance, fieldValue)
+    }
+
+    File getManifestMultiDexKeepProguard(def applicationVariant) {
+        File multiDexKeepProguard = null
+
+        try {
+            File file = applicationVariant.getVariantData().getScope().getArtifacts().getFinalProduct(
+                    Class.forName("com.android.build.gradle.internal.scope.InternalArtifactType")
+                            .getDeclaredField("LEGACY_MULTIDEX_AAPT_DERIVED_PROGUARD_RULES")
+                            .get(null)
+            ).getOrNull()?.getAsFile()
+            if (file != null && file.getName() != '__EMPTY_DIR__') {
+                multiDexKeepProguard = file
+            }
+        } catch (Throwable ignore) {
+        }
+
+        if (multiDexKeepProguard == null) {
+            try {
+                def buildableArtifact = applicationVariant.getVariantData().getScope().getArtifacts().getFinalArtifactFiles(
+                        Class.forName("com.android.build.gradle.internal.scope.InternalArtifactType")
+                                .getDeclaredField("LEGACY_MULTIDEX_AAPT_DERIVED_PROGUARD_RULES")
+                                .get(null)
+                )
+
+                //noinspection GroovyUncheckedAssignmentOfMemberOfRawType,UnnecessaryQualifiedReference
+                multiDexKeepProguard = com.google.common.collect.Iterators.getOnlyElement(buildableArtifact.iterator())
+            } catch (Throwable ignore) {
+
+            }
+        }
+
+        if (multiDexKeepProguard == null) {
+            try {
+                multiDexKeepProguard = applicationVariant.getVariantData().getScope().getManifestKeepListProguardFile()
+            } catch (Throwable ignore) {
+
+            }
+        }
+
+        if (multiDexKeepProguard == null) {
+            try {
+                multiDexKeepProguard = applicationVariant.getVariantData().getScope().getManifestKeepListFile()
+            } catch (Throwable ignore) {
+
+            }
+        }
+
+        if (multiDexKeepProguard == null) {
+            mProject.logger.error("can't get multiDexKeepProguard file")
+        }
+        return multiDexKeepProguard
     }
 
-}
+}
\ No newline at end of file
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerArkHotExtension.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerArkHotExtension.groovy
new file mode 100644
index 00000000..b14575fe
--- /dev/null
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerArkHotExtension.groovy
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the BSD 3-Clause License
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * the BSD 3-Clause License for more details.
+ */
+ 
+package com.tencent.tinker.build.gradle.extension
+
+public class TinkerArkHotExtension {
+    String path;
+    String name;
+
+    public TinkerArkHotExtension() {
+        path = "arkHot";
+        name = "patch.apk";
+    }
+
+    @Override
+    public String toString() {
+        """| path= ${path}
+           | name= ${name}
+         """.stripMargin()
+    }
+}
\ No newline at end of file
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerPatchExtension.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerPatchExtension.groovy
index 3b99a728..3ba63b8a 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerPatchExtension.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerPatchExtension.groovy
@@ -48,6 +48,42 @@ public class TinkerPatchExtension {
      */
     boolean ignoreWarning
 
+    /**
+     *
+     * Allow loader class existence in any class loader.
+     *
+     * This will suppress the exception like:
+     * <pre>
+     * loader classes are found in old secondary dex. Found classes: ...
+     * loader classes are found in new secondary dex. Found classes: ...
+     * </pre>
+     *
+     * <p>Since Android Gradle Plugin 3.3.0, there is no simply way to keep all loader classes in
+     * the primary dex file if your application's min sdk version is 21 or above. In this situation, you
+     * can turn the {@link #removeLoaderForAllDex} and {@link #allowLoaderInAnyDex} to true and
+     * tolerate the loader classes to exists in any dex file.
+     *
+     * <p>default: false
+     */
+    boolean allowLoaderInAnyDex
+
+    /**
+     * Whether to remove loader class for every dex file. When false, we will assume the loader
+     * class only exists in the main dex(classes.dex).
+     *
+     * <p>If the loader class may exists in any dex, you must set this to true. Otherwise, you patch will
+     * cause tinker runtime load failed. But this will cause a little increment on the size
+     * of the patch file.
+     *
+     * <p>Since Android Gradle Plugin 3.3.0, there is no simply way to keep all loader classes in
+     * the primary dex file if your application's min sdk version is 21 or above. In this situation, you
+     * can turn the {@link #removeLoaderForAllDex} and {@link #allowLoaderInAnyDex} to true and
+     * tolerate the loader classes to exists in any dex file.
+     *
+     * <p>default: false
+     */
+    boolean removeLoaderForAllDex
+
     /**
      * If sign the patch file with the android signConfig
      * default: true
@@ -65,6 +101,8 @@ public class TinkerPatchExtension {
         outputFolder = ""
         newApk = ""
         ignoreWarning = false
+        allowLoaderInAnyDex = false
+        removeLoaderForAllDex = false
         useSign = true
         tinkerEnable = true
     }
@@ -88,6 +126,7 @@ public class TinkerPatchExtension {
            | outputFolder = ${outputFolder}
            | newApk = ${newApk}
            | ignoreWarning = ${ignoreWarning}
+           | removeLoaderForAllDex = ${removeLoaderForAllDex}
            | tinkerEnable = ${tinkerEnable}
            | useSign = ${useSign}
         """.stripMargin()
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerMultidexConfigTask.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerMultidexConfigTask.groovy
index 73ef23fe..481ccef2 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerMultidexConfigTask.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerMultidexConfigTask.groovy
@@ -48,6 +48,7 @@ public class TinkerMultidexConfigTask extends DefaultTask {
 
 
     def applicationVariant
+    def multiDexKeepProguard
 
     public TinkerMultidexConfigTask() {
         group = 'tinker'
@@ -101,30 +102,6 @@ public class TinkerMultidexConfigTask extends DefaultTask {
             fr.close()
         }
 
-        File multiDexKeepProguard = null
-        try {
-            multiDexKeepProguard = applicationVariant.getVariantData().getScope().getManifestKeepListProguardFile()
-        } catch (Throwable ignore) {
-            try {
-                def buildableArtifact = applicationVariant.getVariantData().getScope().getArtifacts().getFinalArtifactFiles(
-                        Class.forName("com.android.build.gradle.internal.scope.InternalArtifactType")
-                                .getDeclaredField("LEGACY_MULTIDEX_AAPT_DERIVED_PROGUARD_RULES")
-                                .get(null)
-                )
-
-                //noinspection GroovyUncheckedAssignmentOfMemberOfRawType,UnnecessaryQualifiedReference
-                multiDexKeepProguard = com.google.common.collect.Iterators.getOnlyElement(buildableArtifact.iterator())
-            } catch (Throwable e) {
-
-            }
-            if (multiDexKeepProguard == null) {
-                try {
-                    multiDexKeepProguard = applicationVariant.getVariantData().getScope().getManifestKeepListFile()
-                } catch (Throwable e) {
-                    project.logger.error("can't find getManifestKeepListFile method, exception:${e}")
-                }
-            }
-        }
         if (multiDexKeepProguard == null) {
             project.logger.error("auto add multidex keep pattern fail, you can only copy ${file} to your own multiDex keep proguard file yourself.")
             return
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerPatchSchemaTask.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerPatchSchemaTask.groovy
index 584dd4b2..a4bc496e 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerPatchSchemaTask.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerPatchSchemaTask.groovy
@@ -15,6 +15,8 @@
  */
 
 package com.tencent.tinker.build.gradle.task
+
+import com.tencent.tinker.build.gradle.extension.TinkerPatchExtension
 import com.tencent.tinker.build.patch.InputParam
 import com.tencent.tinker.build.patch.Runner
 import org.gradle.api.DefaultTask
@@ -26,7 +28,7 @@ import org.gradle.api.tasks.TaskAction
  * @author zhangshaowen
  */
 public class TinkerPatchSchemaTask extends DefaultTask {
-    def configuration
+    TinkerPatchExtension configuration
     def android
     String buildApkPath
     String outputFolder
@@ -66,6 +68,8 @@ public class TinkerPatchSchemaTask extends DefaultTask {
                .setNewApk(buildApkPath)
                .setOutBuilder(outputFolder)
                .setIgnoreWarning(configuration.ignoreWarning)
+               .setAllowLoaderInAnyDex(configuration.allowLoaderInAnyDex)
+               .setRemoveLoaderForAllDex(configuration.removeLoaderForAllDex)
                .setDexFilePattern(new ArrayList<String>(configuration.dex.pattern))
                .setIsProtectedApp(configuration.buildConfig.isProtectedApp)
                .setIsComponentHotplugSupported(configuration.buildConfig.supportHotplugComponent)
@@ -81,6 +85,8 @@ public class TinkerPatchSchemaTask extends DefaultTask {
                .setConfigFields(new HashMap<String, String>(configuration.packageConfig.getFields()))
                .setSevenZipPath(configuration.sevenZip.path)
                .setUseSign(configuration.useSign)
+               .setArkHotPath(configuration.arkHot.path)
+               .setArkHotName(configuration.arkHot.name)
 
         InputParam inputParam = builder.create()
         Runner.gradleRun(inputParam);
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerResourceIdTask.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerResourceIdTask.groovy
index b119b357..79a8f02e 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerResourceIdTask.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerResourceIdTask.groovy
@@ -29,6 +29,8 @@ import org.gradle.api.Project
 import org.gradle.api.tasks.TaskAction
 import org.gradle.util.GFileUtils
 
+import java.lang.reflect.Field
+import java.lang.reflect.Modifier
 import java.util.regex.Matcher
 import java.util.regex.Pattern
 
@@ -130,19 +132,51 @@ public class TinkerResourceIdTask extends DefaultTask {
      * add --stable-ids param to aaptOptions's additionalParameters
      */
     List<String> addStableIdsFileToAdditionalParameters(def processAndroidResourceTask) {
-        def aaptOptions = processAndroidResourceTask.getAaptOptions()
+        def aaptOptions
+        try {
+            aaptOptions = processAndroidResourceTask.getAaptOptions()
+        } catch (Exception e) {
+            //agp 3.5.0+
+            aaptOptions = Class.forName("com.android.build.gradle.internal.res.LinkApplicationAndroidResourcesTask").metaClass.getProperty(processAndroidResourceTask, "aaptOptions")
+        }
         List<String> additionalParameters = new ArrayList<>()
         List<String> originalAdditionalParameters = aaptOptions.getAdditionalParameters()
         if (originalAdditionalParameters != null) {
             additionalParameters.addAll(originalAdditionalParameters)
         }
-        aaptOptions.setAdditionalParameters(additionalParameters)
+        replaceFinalField(aaptOptions.getClass().getName(), "additionalParameters", aaptOptions, additionalParameters)
         additionalParameters.add("--stable-ids")
         additionalParameters.add(project.file(RESOURCE_PUBLIC_TXT).getAbsolutePath())
         project.logger.error("tinker add additionalParameters --stable-ids ${project.file(RESOURCE_PUBLIC_TXT).getAbsolutePath()}")
         return additionalParameters
     }
 
+    /**
+     * replace final field
+     */
+    private static void replaceFinalField(String className, String fieldName, Object instance, Object fieldValue) {
+        final Class targetClazz = Class.forName(className)
+        Class currClazz = targetClazz
+        Field field = null
+        while (true) {
+            try {
+                field = currClazz.getDeclaredField(fieldName)
+                break
+            } catch (NoSuchFieldException e) {
+                if (currClazz.equals(Object.class)) {
+                    throw e
+                } else {
+                    currClazz = currClazz.getSuperclass()
+                }
+            }
+        }
+        Field modifiersField = Field.class.getDeclaredField("modifiers")
+        modifiersField.setAccessible(true)
+        modifiersField.setInt(field, field.getModifiers() & ~Modifier.FINAL)
+        field.setAccessible(true)
+        field.set(instance, fieldValue)
+    }
+
     /**
      * get real name for style type resources in R.txt by values files
      */
@@ -150,7 +184,17 @@ public class TinkerResourceIdTask extends DefaultTask {
         Map<String, String> styles = new HashMap<>()
         def mergeResourcesTask = project.tasks.findByName("merge${variantName.capitalize()}Resources")
         List<File> resDirCandidateList = new ArrayList<>()
-        resDirCandidateList.add(mergeResourcesTask.outputDir)
+        try {
+            def output = mergeResourcesTask.outputDir
+            if (output instanceof File) {
+                resDirCandidateList.add(output)
+            } else {
+                resDirCandidateList.add(output.getAsFile().get())
+            }
+        } catch (Exception ignore) {
+
+        }
+
         resDirCandidateList.add(new File(mergeResourcesTask.getIncrementalFolder(), "merged.dir"))
         resDirCandidateList.each {
             it.eachFileRecurse(FileType.FILES) {
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/transform/ImmutableDexTransform.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/transform/ImmutableDexTransform.groovy
index 92a35eaf..2f1f6f7e 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/transform/ImmutableDexTransform.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/transform/ImmutableDexTransform.groovy
@@ -20,7 +20,6 @@ import com.android.annotations.NonNull
 import com.android.build.api.transform.*
 import com.android.build.gradle.internal.pipeline.TransformManager
 import com.android.build.gradle.internal.pipeline.TransformTask
-import com.android.build.gradle.internal.transforms.DexTransform
 import com.google.common.base.Joiner
 import com.google.common.collect.Lists
 import com.tencent.tinker.android.dex.ClassDef
@@ -68,10 +67,10 @@ public class ImmutableDexTransform extends Transform {
 
     def variant
 
-    DexTransform dexTransform
+    def dexTransform
 
 
-    ImmutableDexTransform(Project project, def variant, DexTransform dexTransform) {
+    ImmutableDexTransform(Project project, def variant, def dexTransform) {
         this.dexTransform = dexTransform
         this.project = project
         this.variant = variant
@@ -127,7 +126,7 @@ public class ImmutableDexTransform extends Transform {
     @NonNull
     @Override
     public Map<String, Object> getParameterInputs() {
-       return dexTransform.getParameterInputs()
+        return dexTransform.getParameterInputs()
     }
 
     @Override
@@ -366,6 +365,11 @@ public class ImmutableDexTransform extends Transform {
             project.logger.warn("oldApk is illegal. we will not replace the dex transform.")
             return
         }
+        try {
+            Class.forName("com.android.build.gradle.internal.transforms.DexTransform")
+        } catch (ClassNotFoundException e) {
+            return
+        }
 
         project.getGradle().getTaskGraph().addTaskExecutionGraphListener(new TaskExecutionGraphListener() {
             @Override
@@ -375,11 +379,10 @@ public class ImmutableDexTransform extends Transform {
                         continue
                     }
                     if (task instanceof TransformTask && task.name.toLowerCase().contains(variant.name.toLowerCase())) {
-
-                        if (((TransformTask) task).getTransform() instanceof DexTransform && !(((TransformTask) task).getTransform() instanceof ImmutableDexTransform)) {
+                        if (((TransformTask) task).getTransform().getClass() == Class.forName("com.android.build.gradle.internal.transforms.DexTransform") && !(((TransformTask) task).getTransform() instanceof ImmutableDexTransform)) {
                             project.logger.warn("find dex transform. transform class: " + task.transform.getClass() + " . task name: " + task.name)
 
-                            DexTransform dexTransform = task.transform
+                            def dexTransform = task.transform
                             ImmutableDexTransform hookDexTransform = new ImmutableDexTransform(project,
                                     variant, dexTransform)
                             project.logger.info("variant name: " + variant.name)
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptResourceCollector.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptResourceCollector.java
index f4735892..503d4c3f 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptResourceCollector.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptResourceCollector.java
@@ -31,8 +31,8 @@
 public class AaptResourceCollector {
 
     private final Map<RType, Map<String, Set<ResourceDirectory>>> rTypeResourceDirectoryMap;
-    //private final Map<RType, List<ResourceDirectory>> rTypeIncreaseResourceDirectoryListMap;
-//  private final Map<RType, Map<ResourceDirectory,ResourceDirectory>> rTypeIncreaseResourceDirectoryMap;
+    // private final Map<RType, List<ResourceDirectory>> rTypeIncreaseResourceDirectoryListMap;
+    // private final Map<RType, Map<ResourceDirectory,ResourceDirectory>> rTypeIncreaseResourceDirectoryMap;
     private final Map<RType, ResourceIdEnumerator>                rTypeEnumeratorMap;
     private final Map<RDotTxtEntry, RDotTxtEntry>                 originalResourceMap;
     private final Map<RType, Set<RDotTxtEntry>>                   rTypeResourceMap;
@@ -44,8 +44,8 @@
 
     public AaptResourceCollector() {
         this.rTypeResourceDirectoryMap = new HashMap<RType, Map<String, Set<ResourceDirectory>>>();
-//      this.rTypeIncreaseResourceDirectoryListMap = new HashMap<RType, List<ResourceDirectory>>();
-//      this.rTypeIncreaseResourceDirectoryMap = new HashMap<RType, Map<ResourceDirectory,ResourceDirectory>>();
+        // this.rTypeIncreaseResourceDirectoryListMap = new HashMap<RType, List<ResourceDirectory>>();
+        // this.rTypeIncreaseResourceDirectoryMap = new HashMap<RType, Map<ResourceDirectory,ResourceDirectory>>();
         this.rTypeEnumeratorMap = new HashMap<RType, ResourceIdEnumerator>();
         this.rTypeResourceMap = new HashMap<RType, Set<RDotTxtEntry>>();
         this.rTypeIncreaseResourceMap = new HashMap<RType, Set<RDotTxtEntry>>();
@@ -53,7 +53,7 @@ public AaptResourceCollector() {
         this.sanitizeTypeMap = new HashMap<RType, HashMap<String, String>>();
         this.originalResourceMap = new HashMap<RDotTxtEntry, RDotTxtEntry>();
         this.ignoreIdSet = new HashSet<String>();
-        //attr type must 1
+        // attr type must 1
         this.currentTypeId = 2;
     }
 
@@ -65,7 +65,7 @@ public AaptResourceCollector(Map<RType, Set<RDotTxtEntry>> rTypeResourceMap) {
                 Entry<RType, Set<RDotTxtEntry>> entry = iterator.next();
                 RType rType = entry.getKey();
                 Set<RDotTxtEntry> set = entry.getValue();
-//              this.rTypeResourceMap.put(rType, new HashSet<RDotTxtEntry>(set));
+                // this.rTypeResourceMap.put(rType, new HashSet<RDotTxtEntry>(set));
                 for (RDotTxtEntry rDotTxtEntry : set) {
                     originalResourceMap.put(rDotTxtEntry, rDotTxtEntry);
                     ResourceIdEnumerator resourceIdEnumerator = null;
@@ -159,34 +159,34 @@ public void addResource(RType rType, IdType idType, String name, String idValue)
         }
         if (increaseResource) {
             increaseResourceSet.add(rDotTxtEntry);
-//addResourceDirectory(rType, name, resourceDirectory);
+            // addResourceDirectory(rType, name, resourceDirectory);
         }
     }
 
-//private void addResourceDirectory(RType rType,String name, ResourceDirectory resourceDirectory){
-//if(resourceDirectory!=null){
-//Map<ResourceDirectory, ResourceDirectory> resourceDirectoryMap=null;
-//List<ResourceDirectory> resourceDirectoryList=null;
-//if(this.rTypeIncreaseResourceDirectoryMap.containsKey(rType)){
-//resourceDirectoryMap=this.rTypeIncreaseResourceDirectoryMap.get(rType);
-//resourceDirectoryList=this.rTypeIncreaseResourceDirectoryListMap.get(rType);
-//}else{
-//resourceDirectoryMap=new HashMap<ResourceDirectory, ResourceDirectory>();
-//this.rTypeIncreaseResourceDirectoryMap.put(rType, resourceDirectoryMap);
-//resourceDirectoryList=new ArrayList<ResourceDirectory>();
-//this.rTypeIncreaseResourceDirectoryListMap.put(rType, resourceDirectoryList);
-//}
-//ResourceDirectory existResourceDirectory=null;
-//if(resourceDirectoryMap.containsKey(resourceDirectory)){
-//existResourceDirectory=resourceDirectoryMap.get(resourceDirectory);
-//}else{
-//existResourceDirectory=resourceDirectory;
-//resourceDirectoryMap.put(resourceDirectory, resourceDirectory);
-//resourceDirectoryList.add(existResourceDirectory);
-//}
-//existResourceDirectory.resourceEntrySet.add(new ResourceEntry(name,null));
-//}
-//}
+    // private void addResourceDirectory(RType rType, String name, ResourceDirectory resourceDirectory) {
+    //     if (resourceDirectory != null) {
+    //         Map<ResourceDirectory, ResourceDirectory> resourceDirectoryMap = null;
+    //         List<ResourceDirectory> resourceDirectoryList = null;
+    //         if (this.rTypeIncreaseResourceDirectoryMap.containsKey(rType)) {
+    //             resourceDirectoryMap = this.rTypeIncreaseResourceDirectoryMap.get(rType);
+    //             resourceDirectoryList = this.rTypeIncreaseResourceDirectoryListMap.get(rType);
+    //         } else {
+    //             resourceDirectoryMap = new HashMap<ResourceDirectory, ResourceDirectory>();
+    //             this.rTypeIncreaseResourceDirectoryMap.put(rType, resourceDirectoryMap);
+    //             resourceDirectoryList = new ArrayList<ResourceDirectory>();
+    //             this.rTypeIncreaseResourceDirectoryListMap.put(rType, resourceDirectoryList);
+    //         }
+    //         ResourceDirectory existResourceDirectory = null;
+    //         if (resourceDirectoryMap.containsKey(resourceDirectory)) {
+    //             existResourceDirectory = resourceDirectoryMap.get(resourceDirectory);
+    //         } else {
+    //             existResourceDirectory = resourceDirectory;
+    //             resourceDirectoryMap.put(resourceDirectory, resourceDirectory);
+    //             resourceDirectoryList.add(existResourceDirectory);
+    //         }
+    //         existResourceDirectory.resourceEntrySet.add(new ResourceEntry(name, null));
+    //     }
+    // }
 
     /**
      * is contain resource
@@ -316,12 +316,12 @@ public String getRawName(RType rType, String sanitizeName) {
         return rTypeResourceDirectoryMap;
     }
 
-///**
-// * @return the rTypeIncreaseResourceDirectoryListMap
-// */
-//public Map<RType, List<ResourceDirectory>> getRTypeIncreaseResourceDirectoryListMap() {
-//return rTypeIncreaseResourceDirectoryListMap;
-//}
+    // /**
+    // * @return the rTypeIncreaseResourceDirectoryListMap
+    // */
+    // public Map<RType, List<ResourceDirectory>> getRTypeIncreaseResourceDirectoryListMap() {
+    //     return rTypeIncreaseResourceDirectoryListMap;
+    // }
 
     void addIgnoreId(String name) {
         ignoreIdSet.add(name);
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptUtil.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptUtil.java
index 20f6b1ac..a439e416 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptUtil.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptUtil.java
@@ -243,6 +243,8 @@ public static void processValuesFile(String valuesFullFilename, AaptResourceColl
                 case ATTR://no sub item
                     resourceValue = nodeToString(node, true);
                     break;
+                default:
+                    break;
             }
             try {
                 addToResourceCollector(resourceCollector, new ResourceDirectory(directoryName, valuesFullFilename), node, rType, resourceValue);
@@ -287,9 +289,9 @@ public static void processXmlFile(String xmlFullFilename, List<RDotTxtEntry> ref
             }
             RType rType = RESOURCE_TYPES.get(rawRType);
 
-//if(!resourceCollector.isContainResource(rType, IdType.INT, sanitizeName(resourceCollector, name))){
-//throw new AaptUtilException("Not found reference '" + resourceName + "' in '" + xmlFullFilename + "'");
-//}
+            // if (!resourceCollector.isContainResource(rType, IdType.INT, sanitizeName(resourceCollector, name))) {
+            //     throw new AaptUtilException("Not found reference '" + resourceName + "' in '" + xmlFullFilename + "'");
+            // }
             references.add(new FakeRDotTxtEntry(IdType.INT, rType, sanitizeName(rType, resourceCollector, name)));
         }
     }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/FileUtil.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/FileUtil.java
index 97e1cb4c..474e9df6 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/FileUtil.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/FileUtil.java
@@ -103,26 +103,23 @@ public static boolean createFile(final String fullFilename) {
         queue.add(sourceDirectoryFile);
         while (!queue.isEmpty()) {
             File file = queue.poll();
-            boolean result = false;
-            if (!file.isHidden() || includeHidden) {
-                result = true;
+            if (file.isHidden() && !includeHidden) {
+                continue;
             }
-            if (result) {
-                if (file.isDirectory()) {
-                    File[] fileArray = file.listFiles();
-                    if (fileArray != null) {
-                        queue.addAll(Arrays.asList(fileArray));
-                    }
-                } else if (file.isFile()) {
-                    if (file.getName().toLowerCase().endsWith(fileSuffix.toLowerCase())) {
-                        if (isFindMatchFile) {
-                            list.add(file.getAbsolutePath() + somethingAppendToRear);
-                        } else {
-                            String parentPath = file.getParent();
-                            parentPath = parentPath + somethingAppendToRear;
-                            if (!list.contains(parentPath)) {
-                                list.add(parentPath);
-                            }
+            if (file.isDirectory()) {
+                File[] fileArray = file.listFiles();
+                if (fileArray != null) {
+                    queue.addAll(Arrays.asList(fileArray));
+                }
+            } else if (file.isFile()) {
+                if (file.getName().toLowerCase().endsWith(fileSuffix.toLowerCase())) {
+                    if (isFindMatchFile) {
+                        list.add(file.getAbsolutePath() + somethingAppendToRear);
+                    } else {
+                        String parentPath = file.getParent();
+                        parentPath = parentPath + somethingAppendToRear;
+                        if (!list.contains(parentPath)) {
+                            list.add(parentPath);
                         }
                     }
                 }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/Generator.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/Generator.java
index a1ce7585..1f5025bb 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/Generator.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/Generator.java
@@ -25,7 +25,7 @@
 
 public final class Generator {
 
-    private static final char[] characters                  = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'};
+    private static final char[] CHARACTERS = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'};
     private static final String FONT_FAMILY_TIMES_NEW_ROMAN = "Times New Roman";
 
     /**
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/PatchUtil.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/PatchUtil.java
index baf19107..41a596e5 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/PatchUtil.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/PatchUtil.java
@@ -111,16 +111,16 @@ public static void generatePublicResourceXml(AaptResourceCollector aaptResourceC
                 if (!rType.equals(RType.STYLEABLE)) {
                     Set<RDotTxtEntry> set = entry.getValue();
                     for (RDotTxtEntry rDotTxtEntry : set) {
-//                        if (rType.equals(RType.STYLE)) {
-                            String rawName = aaptResourceCollector.getRawName(rType, rDotTxtEntry.name);
-                            if (StringUtil.isBlank(rawName)) {
-//                                System.err.println("Blank?" + rDotTxtEntry.name);
-                                rawName = rDotTxtEntry.name;
-                            }
-                            publicWriter.println("<public type=\"" + rType + "\" name=\"" + rawName + "\" id=\"" + rDotTxtEntry.idValue.trim() + "\" />");
-//                        } else {
-//                            publicWriter.println("<public type=\"" + rType + "\" name=\"" + rDotTxtEntry.name + "\" id=\"" + rDotTxtEntry.idValue + "\" />");
-//                        }
+                        // if (rType.equals(RType.STYLE)) {
+                        String rawName = aaptResourceCollector.getRawName(rType, rDotTxtEntry.name);
+                        if (StringUtil.isBlank(rawName)) {
+                            // System.err.println("Blank?" + rDotTxtEntry.name);
+                            rawName = rDotTxtEntry.name;
+                        }
+                        publicWriter.println("<public type=\"" + rType + "\" name=\"" + rawName + "\" id=\"" + rDotTxtEntry.idValue.trim() + "\" />");
+                        // } else {
+                        //     publicWriter.println("<public type=\"" + rType + "\" name=\"" + rDotTxtEntry.name + "\" id=\"" + rDotTxtEntry.idValue + "\" />");
+                        // }
                     }
                     Set<String> ignoreIdSet = aaptResourceCollector.getIgnoreIdSet();
                     for (RDotTxtEntry rDotTxtEntry : set) {
@@ -129,7 +129,7 @@ public static void generatePublicResourceXml(AaptResourceCollector aaptResourceC
                         } else if (rType.equals(RType.STYLE)) {
 
                             if (rDotTxtEntry.name.indexOf(Constant.Symbol.UNDERLINE) > 0) {
-//idsWriter.println("<item type=\""+rType+"\" name=\""+(rDotTxtEntry.name.replace(Constant.Symbol.UNDERLINE, Constant.Symbol.DOT))+"\"/>");
+                                // idsWriter.println("<item type=\""+rType+"\" name=\""+(rDotTxtEntry.name.replace(Constant.Symbol.UNDERLINE, Constant.Symbol.DOT))+"\"/>");
                             }
                         }
                     }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/apkparser/AndroidParser.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/apkparser/AndroidParser.java
index 167a7490..af1fdc73 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/apkparser/AndroidParser.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/apkparser/AndroidParser.java
@@ -277,6 +277,8 @@ public InputSource resolveEntity(String publicId, String systemId) throws SAXExc
                                 NamedNodeMap attributes = child.getAttributes();
                                 metaDatas.put(getAttribute(attributes, "android:name"), getAttribute(attributes, "android:value"));
                                 break;
+                            default:
+                                break;
                         }
                     }
                 }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ApkDecoder.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ApkDecoder.java
index d099a697..315bec9a 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ApkDecoder.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ApkDecoder.java
@@ -45,6 +45,7 @@
     private final UniqueDexDiffDecoder dexPatchDecoder;
     private final BsDiffDecoder        soPatchDecoder;
     private final ResDiffDecoder       resPatchDecoder;
+    private final ArkHotDecoder arkHotDecoder;
 
     /**
      * if resource's file is also contain in dex or library pattern,
@@ -64,6 +65,8 @@ public ApkDecoder(Configuration config) throws IOException {
         dexPatchDecoder = new UniqueDexDiffDecoder(config, prePath + TypedValue.DEX_META_FILE, TypedValue.DEX_LOG_FILE);
         soPatchDecoder = new BsDiffDecoder(config, prePath + TypedValue.SO_META_FILE, TypedValue.SO_LOG_FILE);
         resPatchDecoder = new ResDiffDecoder(config, prePath + TypedValue.RES_META_TXT, TypedValue.RES_LOG_FILE);
+        arkHotDecoder = new ArkHotDecoder(config, prePath + TypedValue.ARKHOT_META_TXT);
+        Logger.d("config: " + config.mArkHotPatchPath + " " + config.mArkHotPatchName + prePath + TypedValue.ARKHOT_META_TXT);
         resDuplicateFiles = new ArrayList<>();
     }
 
@@ -87,9 +90,9 @@ private void unzipApkFiles(File oldFile, File newFile) throws IOException, Tinke
     }
 
     private void writeToLogFile(File oldFile, File newFile) throws IOException {
-        String line1 = "old apk: " + oldFile.getName() + ", size=" + FileOperation.getFileSizes(oldFile) + ", md5=" + MD5.getMD5(oldFile);
+        String line1 = "old apk1131: " + oldFile.getName() + ", size=" + FileOperation.getFileSizes(oldFile) + ", md5=" + MD5.getMD5(oldFile);
         String line2 = "new apk: " + newFile.getName() + ", size=" + FileOperation.getFileSizes(newFile) + ", md5=" + MD5.getMD5(newFile);
-        Logger.d("Analyze old and new apk files:");
+        Logger.d("Analyze old and new apk files1:");
         Logger.d(line1);
         Logger.d(line2);
         Logger.d("");
@@ -112,9 +115,9 @@ public boolean patch(File oldFile, File newFile) throws Exception {
 
         Files.walkFileTree(mNewApkDir.toPath(), new ApkFilesVisitor(config, mNewApkDir.toPath(), mOldApkDir.toPath(), dexPatchDecoder, soPatchDecoder, resPatchDecoder));
 
-        //get all duplicate resource file
+        // get all duplicate resource file
         for (File duplicateRes : resDuplicateFiles) {
-//            resPatchDecoder.patch(duplicateRes, null);
+            // resPatchDecoder.patch(duplicateRes, null);
             Logger.e("Warning: res file %s is also match at dex or library pattern, "
                 + "we treat it as unchanged in the new resource_out.zip", getRelativePathStringToOldFile(duplicateRes));
         }
@@ -123,11 +126,14 @@ public boolean patch(File oldFile, File newFile) throws Exception {
         dexPatchDecoder.onAllPatchesEnd();
         manifestDecoder.onAllPatchesEnd();
         resPatchDecoder.onAllPatchesEnd();
+        arkHotDecoder.onAllPatchesEnd();
 
         //clean resources
         dexPatchDecoder.clean();
         soPatchDecoder.clean();
         resPatchDecoder.clean();
+        arkHotDecoder.clean();
+
         return true;
     }
 
@@ -175,7 +181,6 @@ public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IO
                 try {
                     dexDecoder.patch(oldFile, file.toFile());
                 } catch (Exception e) {
-//                    e.printStackTrace();
                     throw new RuntimeException(e);
                 }
                 return FileVisitResult.CONTINUE;
@@ -188,7 +193,6 @@ public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IO
                 try {
                     soDecoder.patch(oldFile, file.toFile());
                 } catch (Exception e) {
-//                    e.printStackTrace();
                     throw new RuntimeException(e);
                 }
                 return FileVisitResult.CONTINUE;
@@ -197,7 +201,6 @@ public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IO
                 try {
                     resDecoder.patch(oldFile, file.toFile());
                 } catch (Exception e) {
-//                    e.printStackTrace();
                     throw new RuntimeException(e);
                 }
                 return FileVisitResult.CONTINUE;
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ArkHotDecoder.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ArkHotDecoder.java
new file mode 100644
index 00000000..f752a1d0
--- /dev/null
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ArkHotDecoder.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the BSD 3-Clause License
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * the BSD 3-Clause License for more details.
+ */
+
+package com.tencent.tinker.build.decoder;
+
+import com.tencent.tinker.build.info.InfoWriter;
+import com.tencent.tinker.build.patch.Configuration;
+import com.tencent.tinker.build.util.FileOperation;
+import com.tencent.tinker.build.util.MD5;
+import com.tencent.tinker.build.util.TinkerPatchException;
+
+import java.io.File;
+import java.io.IOException;
+
+public class ArkHotDecoder extends BaseDecoder {
+    private static final String ARKHOT_PATCH_NAME = "patch.apk";
+    private static final String ARKHOT_PATCH_PATH = "arkHot";
+
+    private final InfoWriter metaWriter;
+
+    public ArkHotDecoder(Configuration config, String metaPath) throws IOException {
+        super(config);
+
+        if (metaPath != null) {
+            metaWriter = new InfoWriter(config, config.mTempResultDir + File.separator + metaPath);
+        } else {
+            metaWriter = null;
+        }
+    }
+
+    @Override
+    public void clean() {
+        metaWriter.close();
+    }
+
+    @Override
+    public void onAllPatchesStart() {
+    }
+
+    @Override
+    public void onAllPatchesEnd() throws IOException, TinkerPatchException {
+        File patchFile = new File(config.mArkHotPatchPath + "/" + config.mArkHotPatchName);
+        if (!patchFile.exists()) {
+            return;
+        }
+        String md5 = MD5.getMD5(patchFile);
+
+        File dest = new File(config.mTempResultDir + "/" + ARKHOT_PATCH_PATH + "/" + ARKHOT_PATCH_NAME);
+        FileOperation.copyFileUsingStream(patchFile, dest);
+        writeMetaFile(md5);
+    }
+
+    @Override
+    public boolean patch(File oldFile, File newFile) {
+        return true;
+    }
+
+    private void writeMetaFile(String md5) {
+        if (metaWriter == null) {
+            return;
+        }
+
+        if (metaWriter != null) {
+            String path = ARKHOT_PATCH_PATH;
+            String fileName = ARKHOT_PATCH_NAME;
+
+            if (md5 == null) {
+                return;
+            }
+
+            String meta = fileName + "," + path  +  "," + md5;
+            metaWriter.writeLineToInfoFile(meta);
+        }
+    }
+}
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java
index 013a14f5..1712e489 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java
@@ -306,7 +306,12 @@ private void generateChangedClassesDexFile() throws IOException {
             }
 
             // Write constructed changed classes dex to file and record it in meta file.
-            final String changedDexName = CHANGED_CLASSES_DEX_NAME_PREFIX + changedDexId + ".dex";
+            String changedDexName = null;
+            if (changedDexId == 1) {
+                changedDexName = "classes.dex";
+            } else {
+                changedDexName = "classes" + changedDexId + ".dex";
+            }
             final File dest = new File(config.mTempResultDir + "/" + changedDexName);
             final FileDataStore fileDataStore = new FileDataStore(dest);
             dexBuilder.writeTo(fileDataStore);
@@ -394,8 +399,12 @@ private void logDexesToDexMeta() throws IOException {
                 if (realClassNDexFiles.contains(oldDexFile)) {
                     // Bugfix: However, if what we would copy directly is main dex, we should do an additional diff operation
                     // so that patch applier would help us remove all loader classes of it in runtime.
-                    if (dexName.equals(DexFormat.DEX_IN_JAR_NAME)) {
-                        Logger.d("\nDo additional diff on main dex to remove loader classes in it.");
+                    if (config.mRemoveLoaderForAllDex || dexName.equals(DexFormat.DEX_IN_JAR_NAME)) {
+                        if (config.mRemoveLoaderForAllDex) {
+                            Logger.d("\nDo additional diff on every dex to remove loader classes in it, because removeLoaderForAllDex = true");
+                        } else {
+                            Logger.d("\nDo additional diff on main dex to remove loader classes in it.");
+                        }
                         diffDexPairAndFillRelatedInfo(oldDexFile, newDexFile, relatedInfo);
                         logToDexMeta(newDexFile, oldDexFile, relatedInfo.dexDiffFile, relatedInfo.newOrFullPatchedMd5, relatedInfo.newOrFullPatchedMd5, relatedInfo.dexDiffMd5, relatedInfo.newOrFullPatchedCRC);
                     } else {
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ResDiffDecoder.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ResDiffDecoder.java
index 353ff790..8c6e49c8 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ResDiffDecoder.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ResDiffDecoder.java
@@ -271,6 +271,8 @@ private void writeResLog(File newFile, File oldFile, int mode) throws IOExceptio
                     log = "large modify resource: " + relative + ", oldSize=" + FileOperation.getFileSizes(oldFile) + ", newSize="
                         + FileOperation.getFileSizes(newFile);
                     break;
+                default:
+                    break;
             }
             logWriter.writeLineToInfoFile(log);
         }
@@ -460,12 +462,13 @@ private void getCompressMethodFromApk() {
             }
 
         } catch (Throwable throwable) {
-
+            // Ignored.
         } finally {
             if (zipFile != null) {
                 try {
                     zipFile.close();
                 } catch (IOException e) {
+                    // Ignored.
                 }
             }
         }
@@ -505,6 +508,8 @@ private void writeMetaFile(ArrayList<String> set, int mode) {
                 case TypedValue.STORED:
                     title = TypedValue.STORE_TITLE + set.size();
                     break;
+                default:
+                    break;
             }
             metaWriter.writeLineToInfoFile(title);
             for (String name : set) {
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/DexPatchGenerator.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/DexPatchGenerator.java
index 03fff09d..4137600e 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/DexPatchGenerator.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/DexPatchGenerator.java
@@ -587,6 +587,8 @@ private void writeResultToStream(OutputStream os) throws IOException {
                     newItemList.add(patchOperation.newItem);
                     break;
                 }
+                default:
+                    break;
             }
         }
 
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/DexSectionDiffAlgorithm.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/DexSectionDiffAlgorithm.java
index 75cd2e7f..ff8b36f7 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/DexSectionDiffAlgorithm.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/DexSectionDiffAlgorithm.java
@@ -364,6 +364,9 @@ public void execute() {
                     indexToReplaceOperationMap.put(patchOperation.index, patchOperation);
                     break;
                 }
+                default: {
+                    break;
+                }
             }
         }
     }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/ChangedClassesDexClassInfoCollector.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/ChangedClassesDexClassInfoCollector.java
index 6fb11914..d31ee1c0 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/ChangedClassesDexClassInfoCollector.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/ChangedClassesDexClassInfoCollector.java
@@ -45,7 +45,7 @@
 public class ChangedClassesDexClassInfoCollector {
     private static final String TAG = "ChangedClassesDexClassInfoCollector";
 
-    private static final DexPatcherLogger logger = new DexPatcherLogger();
+    private static final DexPatcherLogger LOGGER = new DexPatcherLogger();
     private final Set<String> excludedClassPatterns = new HashSet<>();
     private boolean includeRefererToRefererAffectedClasses = false;
 
@@ -61,7 +61,7 @@ public ChangedClassesDexClassInfoCollector clearExcludedClassPatterns() {
     }
 
     public ChangedClassesDexClassInfoCollector setLogger(DexPatcherLogger.IDexPatcherLogger loggerImpl) {
-        logger.setLoggerImpl(loggerImpl);
+        LOGGER.setLoggerImpl(loggerImpl);
         return this;
     }
 
@@ -77,7 +77,7 @@ public ChangedClassesDexClassInfoCollector setIncludeRefererToRefererAffectedCla
         DexClassesComparator dexClassCmptor = new DexClassesComparator("*");
         dexClassCmptor.setCompareMode(DexClassesComparator.COMPARE_MODE_NORMAL);
         dexClassCmptor.setIgnoredRemovedClassDescPattern(excludedClassPatterns);
-        dexClassCmptor.setLogger(logger.getLoggerImpl());
+        dexClassCmptor.setLogger(LOGGER.getLoggerImpl());
         dexClassCmptor.startCheck(oldDexGroup, newDexGroup);
 
         // So far we collected infos of all added, changed, and deleted classes.
@@ -88,7 +88,7 @@ public ChangedClassesDexClassInfoCollector setIncludeRefererToRefererAffectedCla
         for (DexClassInfo[] oldAndNewInfoPair : changedClassInfos) {
             final DexClassInfo newClassInfo = oldAndNewInfoPair[1];
 
-            logger.i(TAG, "Add class %s to changed classes dex.", newClassInfo.classDesc);
+            LOGGER.i(TAG, "Add class %s to changed classes dex.", newClassInfo.classDesc);
             result.add(newClassInfo);
         }
 
@@ -109,7 +109,7 @@ public ChangedClassesDexClassInfoCollector setIncludeRefererToRefererAffectedCla
             for (DexClassInfo oldClassInfo : oldClassInfos) {
                 if (!classDescsInResult.contains(oldClassInfo.classDesc)
                         && isClassReferToAnyClasses(oldClassInfo, referrerAffectedChangedClassDescs)) {
-                    logger.i(TAG, "Add class %s in old dex to changed classes dex since it is affected by modified referee.", oldClassInfo.classDesc);
+                    LOGGER.i(TAG, "Add class %s in old dex to changed classes dex since it is affected by modified referee.", oldClassInfo.classDesc);
                     result.add(oldClassInfo);
                 }
             }
@@ -221,10 +221,13 @@ private void processIndexByType(int index, int indexType) {
                     refInfoInLog = "invoking method: " + getMethodProtoTypeStr(methodId);
                     break;
                 }
+                default: {
+                    break;
+                }
             }
             if (typeName != null && refereeClassDescs.contains(typeName)) {
                 MethodId methodId = owner.methodIds().get(method.methodIndex);
-                logger.i(
+                LOGGER.i(
                         TAG,
                         "Method %s in class %s referenced referrer-affected class %s by %s",
                         getMethodProtoTypeStr(methodId),
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/info/PatchInfoGen.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/info/PatchInfoGen.java
index cd2d4b01..b7055172 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/info/PatchInfoGen.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/info/PatchInfoGen.java
@@ -64,8 +64,15 @@ private void addTinkerID() throws IOException, ParseException {
         }
     }
 
+    private void addProtectedAppFlag() {
+        // If user happens to specify a value with this key, just override it for logic correctness.
+        config.mPackageFields.put(TypedValue.PKGMETA_KEY_IS_PROTECTED_APP, config.mIsProtectedApp ? "1" : "0");
+    }
+
     public void gen() throws Exception {
         addTinkerID();
+        addProtectedAppFlag();
+
         Properties newProperties = new Properties();
         for (String key : config.mPackageFields.keySet()) {
             newProperties.put(key, config.mPackageFields.get(key));
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/Configuration.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/Configuration.java
index dc655158..dccffff6 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/Configuration.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/Configuration.java
@@ -52,6 +52,7 @@
     protected static final String DEX_ISSUE = "dex";
     protected static final String SO_ISSUE  = "lib";
     protected static final String RES_ISSUE = "resource";
+    protected static final String ARKHOT_ISSUE = "arkHot";
 
     protected static final String SIGN_ISSUE           = "sign";
     protected static final String PACKAGE_CONFIG_ISSUE = "packageConfig";
@@ -62,6 +63,8 @@
     protected static final String ATTR_NAME  = "name";
 
     protected static final String ATTR_IGNORE_WARNING            = "ignoreWarning";
+    protected static final String ATTR_ALLOW_LOADER_IN_ANY_DEX   = "allowLoaderInAnyDex";
+    protected static final String ATTR_REMOVE_LOADER_FOR_ALL_DEX = "removeLoaderForAllDex";
     protected static final String ATTR_IS_PROTECTED_APP          = "isProtectedApp";
     protected static final String ATTR_SUPPORT_HOTPLUG_COMPONENT = "supportHotplugComponent";
     protected static final String ATTR_USE_SIGN                  = "useSign";
@@ -72,6 +75,9 @@
     protected static final String ATTR_IGNORE_CHANGE_WARNING     = "ignoreChangeWarning";
     protected static final String ATTR_RES_LARGE_MOD             = "largeModSize";
 
+    protected static final String ATTR_ARKHOT_PATH = "path";
+    protected static final String ATTR_ARKHOT_NAME = "name";
+
     protected static final String ATTR_LOADER       = "loader";
     protected static final String ATTR_CONFIG_FIELD = "configField";
 
@@ -88,7 +94,9 @@
     public File    mOldApkFile;
     public File    mNewApkFile;
     public boolean mIgnoreWarning;
+    public boolean mAllowLoaderInAnyDex;
     public boolean mIsProtectedApp;
+    public boolean mRemoveLoaderForAllDex;
     public boolean mSupportHotplugComponent;
     /**
      * lib config
@@ -141,6 +149,11 @@
 
     public boolean mUsingGradle;
 
+    /**
+     * ark patch
+     */
+    public String mArkHotPatchPath;
+    public String mArkHotPatchName;
 
     /**
      * use by command line with xml config
@@ -232,6 +245,10 @@ public Configuration(InputParam param) throws IOException, TinkerPatchException
 
         mIgnoreWarning = param.ignoreWarning;
 
+        mAllowLoaderInAnyDex = param.allowLoaderInAnyDex;
+
+        mRemoveLoaderForAllDex= param.removeLoaderForAllDex;
+
         mIsProtectedApp = param.isProtectedApp;
 
         mSupportHotplugComponent = param.supportHotplugComponent;
@@ -247,6 +264,8 @@ public Configuration(InputParam param) throws IOException, TinkerPatchException
         createTempDirectory();
         checkInputPatternParameter();
 
+        mArkHotPatchName = param.arkHotPatchName;
+        mArkHotPatchPath = param.arkHotPatchPath;
     }
 
     @Override
@@ -257,6 +276,8 @@ public String toString() {
         sb.append("newApk:" + mNewApkPath + "\n");
         sb.append("outputFolder:" + mOutFolder + "\n");
         sb.append("isIgnoreWarning:" + mIgnoreWarning + "\n");
+        sb.append("isAllowLoaderClassInAnyDex:" + mAllowLoaderInAnyDex + "\n");
+        sb.append("isRemoveLoaderForAllDex:" + mRemoveLoaderForAllDex + "\n");
         sb.append("isProtectedApp:" + mIsProtectedApp + "\n");
         sb.append("7-ZipPath:" + mSevenZipPath + "\n");
         sb.append("useSignAPk:" + mUseSignAPk + "\n");
@@ -300,6 +321,7 @@ public String toString() {
         }
         sb.append("largeModSize:" + mLargeModSize + "kb\n");
         sb.append("useApplyResource:" + mUseApplyResource + "\n");
+        sb.append("ArkHot: "  + mArkHotPatchPath + " / " + mArkHotPatchName + "\n");
         return sb.toString();
     }
 
@@ -414,6 +436,8 @@ public InputSource resolveEntity(String publicId, String systemId) throws SAXExc
                     if (mUseSignAPk) {
                         readSignFromXml(node);
                     }
+                } else if (id.equals(ARKHOT_ISSUE)) {
+                    readArkHotPropertyFromXml(node);
                 } else {
                     System.err.println("unknown issue " + id);
                 }
@@ -439,6 +463,10 @@ private void readPropertyFromXml(Node node) throws IOException {
                     }
                     if (tagName.equals(ATTR_IGNORE_WARNING)) {
                         mIgnoreWarning = value.equals("true");
+                    } else if (tagName.equals(ATTR_ALLOW_LOADER_IN_ANY_DEX)) {
+                        mAllowLoaderInAnyDex = value.equals("true");
+                    } else if (tagName.equals(ATTR_REMOVE_LOADER_FOR_ALL_DEX)) {
+                        mRemoveLoaderForAllDex = value.equals("true");
                     } else if (tagName.equals(ATTR_IS_PROTECTED_APP)) {
                         mIsProtectedApp = value.equals("true");
                     } else if (tagName.equals(ATTR_SUPPORT_HOTPLUG_COMPONENT)) {
@@ -460,6 +488,29 @@ private void readPropertyFromXml(Node node) throws IOException {
         }
     }
 
+    private void readArkHotPropertyFromXml(Node node) throws IOException {
+        NodeList childNodes = node.getChildNodes();
+        if (childNodes.getLength() > 0) {
+            for (int j = 0, n = childNodes.getLength(); j < n; j++) {
+                Node child = childNodes.item(j);
+                if (child.getNodeType() == Node.ELEMENT_NODE) {
+                    Element check = (Element) child;
+                    String tagName = check.getTagName();
+
+                    String value = check.getAttribute(ATTR_VALUE);
+                    if (tagName.equals(ATTR_ARKHOT_PATH)) {
+                        mArkHotPatchPath = value;
+                        mArkHotPatchPath.trim();
+                    } else if (tagName.equals(ATTR_ARKHOT_NAME)) {
+                        mArkHotPatchName = value;
+                        mArkHotPatchName.trim();
+                    } else {
+                        System.err.println("unknown dex tag " + tagName);
+                    }
+                }
+            }
+        }
+    }
 
     private void readSignFromXml(Node node) throws IOException {
         if (mSignatureFile != null) {
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/InputParam.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/InputParam.java
index cb2becd3..590d14c3 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/InputParam.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/InputParam.java
@@ -35,6 +35,8 @@
     public final String  storealias;
     public final String  storepass;
     public final boolean ignoreWarning;
+    public final boolean allowLoaderInAnyDex;
+    public final boolean removeLoaderForAllDex;
     public final boolean isProtectedApp;
     public final boolean supportHotplugComponent;
     public final boolean useSign;
@@ -80,33 +82,43 @@
      */
     public final String                  sevenZipPath;
 
+    /**
+     * TinkerPatch ark
+     */
+    public final String arkHotPatchPath;
+    public final String arkHotPatchName;
+
     private InputParam(
-        String oldApk,
-        String newApk,
-        String outFolder,
-        File signFile,
-        String keypass,
-        String storealias,
-        String storepass,
-        boolean ignoreWarning,
-        boolean isProtectedApp,
-        boolean supportHotplugComponent,
-        boolean useSign,
-
-        ArrayList<String> dexFilePattern,
-        ArrayList<String> dexLoaderPattern,
-        ArrayList<String> dexIgnoreChangeLoaderPattern,
-
-        String dexMode,
-        ArrayList<String> soFilePattern,
-        ArrayList<String> resourceFilePattern,
-        ArrayList<String> resourceIgnoreChangePattern,
-        ArrayList<String> resourceIgnoreChangeWarningPattern,
-        int largeModSize,
-        boolean useApplyResource,
-        HashMap<String, String> configFields,
-
-        String sevenZipPath
+            String oldApk,
+            String newApk,
+            String outFolder,
+            File signFile,
+            String keypass,
+            String storealias,
+            String storepass,
+            boolean ignoreWarning,
+            boolean allowLoaderInAnyDex,
+            boolean removeLoaderForAllDex,
+            boolean isProtectedApp,
+            boolean supportHotplugComponent,
+            boolean useSign,
+
+            ArrayList<String> dexFilePattern,
+            ArrayList<String> dexLoaderPattern,
+            ArrayList<String> dexIgnoreChangeLoaderPattern,
+
+            String dexMode,
+            ArrayList<String> soFilePattern,
+            ArrayList<String> resourceFilePattern,
+            ArrayList<String> resourceIgnoreChangePattern,
+            ArrayList<String> resourceIgnoreChangeWarningPattern,
+            int largeModSize,
+            boolean useApplyResource,
+            HashMap<String, String> configFields,
+
+        String sevenZipPath,
+        String arkHotPatchPath,
+        String arkHotPatchName
     ) {
         this.oldApk = oldApk;
         this.newApk = newApk;
@@ -116,6 +128,8 @@ private InputParam(
         this.storealias = storealias;
         this.storepass = storepass;
         this.ignoreWarning = ignoreWarning;
+        this.allowLoaderInAnyDex = allowLoaderInAnyDex;
+        this.removeLoaderForAllDex = removeLoaderForAllDex;
         this.isProtectedApp = isProtectedApp;
         this.supportHotplugComponent = supportHotplugComponent;
         this.useSign = useSign;
@@ -135,6 +149,8 @@ private InputParam(
         this.configFields = configFields;
 
         this.sevenZipPath = sevenZipPath;
+        this.arkHotPatchPath = arkHotPatchPath;
+        this.arkHotPatchName = arkHotPatchName;
     }
 
     public static class Builder {
@@ -149,6 +165,8 @@ private InputParam(
         private String  storealias;
         private String  storepass;
         private boolean ignoreWarning;
+        private boolean allowLoaderInAnyDex;
+        private boolean removeLoaderForAllDex;
         private boolean isProtectedApp;
         private boolean isComponentHotplugSupported;
         private boolean useSign;
@@ -194,6 +212,12 @@ private InputParam(
          */
         private String                  sevenZipPath;
 
+        /**
+         * tinkerPatch ark
+         */
+        private String arkHotPatchPath;
+        private String arkHotPatchName;
+
 
         public Builder() {
         }
@@ -273,6 +297,16 @@ public Builder setIgnoreWarning(boolean ignoreWarning) {
             return this;
         }
 
+        public Builder setAllowLoaderInAnyDex(boolean allowLoaderInAnyDex) {
+            this.allowLoaderInAnyDex = allowLoaderInAnyDex;
+            return this;
+        }
+
+        public Builder setRemoveLoaderForAllDex(boolean removeLoaderForAllDex){
+            this.removeLoaderForAllDex = removeLoaderForAllDex;
+            return this;
+        }
+
         public Builder setIsProtectedApp(boolean isProtectedApp) {
             this.isProtectedApp = isProtectedApp;
             return this;
@@ -313,6 +347,16 @@ public Builder setUseSign(boolean useSign) {
             return this;
         }
 
+        public Builder setArkHotPath(String path) {
+            this.arkHotPatchPath = path;
+            return this;
+        }
+
+        public Builder setArkHotName(String name) {
+            this.arkHotPatchName = name;
+            return this;
+        }
+
         public InputParam create() {
             return new InputParam(
                     oldApk,
@@ -323,6 +367,8 @@ public InputParam create() {
                     storealias,
                     storepass,
                     ignoreWarning,
+                    allowLoaderInAnyDex,
+                    removeLoaderForAllDex,
                     isProtectedApp,
                     isComponentHotplugSupported,
                     useSign,
@@ -337,7 +383,9 @@ public InputParam create() {
                     largeModSize,
                     useApplyResource,
                     configFields,
-                    sevenZipPath
+                    sevenZipPath,
+                    arkHotPatchPath,
+                    arkHotPatchName
             );
         }
     }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/DexClassesComparator.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/DexClassesComparator.java
index 5c2eb055..1b2eaa07 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/DexClassesComparator.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/DexClassesComparator.java
@@ -289,6 +289,9 @@ public void startCheck(DexGroup oldDexGroup, DexGroup newDexGroup) {
                     }
                     break;
                 }
+                default: {
+                    break;
+                }
             }
         }
     }
@@ -1475,6 +1478,11 @@ public boolean equals(Object obj) {
             }
             return owner.computeSignature(false).equals(other.owner.computeSignature(false));
         }
+
+        @Override
+        public int hashCode() {
+            return owner.computeSignature(false).hashCode();
+        }
     }
 
     public static final class DexGroup {
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/ExcludedClassModifiedChecker.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/ExcludedClassModifiedChecker.java
index 444ca396..43bd09fd 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/ExcludedClassModifiedChecker.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/ExcludedClassModifiedChecker.java
@@ -190,10 +190,22 @@ public void checkIfExcludedClassWasModifiedInNewDex(File oldFile, File newFile)
                     );
                 }
                 case STMCODE_ERROR_LOADER_CLASS_FOUND_IN_SECONDARY_OLD_DEX: {
-                    throw new TinkerPatchException("loader classes are found in old secondary dex. Found classes: " + Utils.collectionToString(oldClassesDescToCheck));
+                    final String msg = "loader classes are found in old secondary dex. Found classes: " + Utils.collectionToString(oldClassesDescToCheck);
+                    if (config.mAllowLoaderInAnyDex) {
+                        Logger.d(msg);
+                        return;
+                    } else {
+                        throw new TinkerPatchException(msg);
+                    }
                 }
                 case STMCODE_ERROR_LOADER_CLASS_FOUND_IN_SECONDARY_NEW_DEX: {
-                    throw new TinkerPatchException("loader classes are found in new secondary dex. Found classes: " + Utils.collectionToString(newClassesDescToCheck));
+                    final String msg = "loader classes are found in new secondary dex. Found classes: " + Utils.collectionToString(newClassesDescToCheck);
+                    if (config.mAllowLoaderInAnyDex) {
+                        Logger.d(msg);
+                        return;
+                    } else {
+                        throw new TinkerPatchException(msg);
+                    }
                 }
                 case STMCODE_ERROR_LOADER_CLASS_CHANGED: {
                     String msg =
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/FileOperation.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/FileOperation.java
index 30f4b083..cf064300 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/FileOperation.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/FileOperation.java
@@ -252,15 +252,15 @@ private static void zipFile(File resFile, ZipOutputStream zipout, String rootpat
                 rootpath = rootpath.replace("\\", "/");
             }
             ZipEntry entry = new ZipEntry(rootpath);
-//            if (compressMethod == ZipEntry.DEFLATED) {
+            // if (compressMethod == ZipEntry.DEFLATED) {
             entry.setMethod(ZipEntry.DEFLATED);
-//            } else {
-//                entry.setMethod(ZipEntry.STORED);
-//                entry.setSize(fileContents.length);
-//                final CRC32 checksumCalculator = new CRC32();
-//                checksumCalculator.update(fileContents);
-//                entry.setCrc(checksumCalculator.getValue());
-//            }
+            // } else {
+            //     entry.setMethod(ZipEntry.STORED);
+            //     entry.setSize(fileContents.length);
+            //     final CRC32 checksumCalculator = new CRC32();
+            //     checksumCalculator.update(fileContents);
+            //     entry.setCrc(checksumCalculator.getValue());
+            // }
             zipout.putNextEntry(entry);
             zipout.write(fileContents);
             zipout.flush();
@@ -375,7 +375,6 @@ public static boolean sevenZipInputDir(File inputDir, File outputFile, Configura
             while (reader.readLine() != null) {
             }
         } catch (IOException e) {
-//            e.printStackTrace();
             FileOperation.deleteFile(outputFile);
             Logger.e("7a patch file failed, you should set the zipArtifact, or set the path directly");
             return false;
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/TypedValue.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/TypedValue.java
index 56413803..46e0f44e 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/TypedValue.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/TypedValue.java
@@ -36,12 +36,16 @@
     public static final String DEX_TEMP_PATCH_DIR = "tempPatchedDexes";
     public static final String RES_LOG_FILE       = "res_log.txt";
     public static final String RES_META_TXT       = "res_meta.txt";
+    public static final String ARKHOT_META_TXT = "arkHot_meta.txt";
 
     public static final String FILE_ASSETS = "assets";
 
     public static final String TINKER_ID     = "TINKER_ID";
     public static final String NEW_TINKER_ID = "NEW_TINKER_ID";
 
+    // Please keep it synchronized with the one defined in ShareConstants.
+    public static final String PKGMETA_KEY_IS_PROTECTED_APP = "is_protected_app";
+
     public static final String PACKAGE_META_FILE = "package_meta.txt";
 
     // Please keep it synchronized with the other one defined in 'EnvConsts' class
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/Utils.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/Utils.java
index 924e60cc..70977b12 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/Utils.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/Utils.java
@@ -25,12 +25,10 @@
 import com.tencent.tinker.ziputils.ziputil.TinkerZipUtil;
 
 import java.io.BufferedOutputStream;
-import java.io.BufferedReader;
 import java.io.Closeable;
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
-import java.io.InputStreamReader;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Enumeration;
@@ -239,32 +237,4 @@ public static void closeQuietly(Closeable closeable) {
             e.printStackTrace();
         }
     }
-
-    public static void exec(ArrayList<String> args, File path) throws RuntimeException, IOException, InterruptedException {
-        ProcessBuilder ps = new ProcessBuilder(args);
-        ps.redirectErrorStream(true);
-        if (path != null) {
-            ps.directory(path);
-        }
-        Process pr = ps.start();
-        BufferedReader ins = null;
-        try {
-            ins = new BufferedReader(new InputStreamReader(pr.getInputStream()));
-            String line;
-            while ((line = ins.readLine()) != null) {
-                System.out.println(line);
-            }
-            if (pr.waitFor() != 0) {
-                throw new RuntimeException("exec cmd failed! args: " + args);
-            }
-        } finally {
-            try {
-                pr.destroy();
-            } catch (Throwable ignored) {
-                // Ignored.
-            }
-            StreamUtil.closeQuietly(ins);
-        }
-    }
-
 }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/org/jf/dexlib2/builder/BuilderMutableMethodImplementation.java b/tinker-build/tinker-patch-lib/src/main/java/org/jf/dexlib2/builder/BuilderMutableMethodImplementation.java
index 71e6168d..51345984 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/org/jf/dexlib2/builder/BuilderMutableMethodImplementation.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/org/jf/dexlib2/builder/BuilderMutableMethodImplementation.java
@@ -502,6 +502,9 @@ private void fixInstructions() {
                         ((BuilderSwitchPayload) targetInstruction).referrer = location;
                         break;
                     }
+                    default: {
+                        break;
+                    }
                 }
             }
         }
@@ -568,6 +571,9 @@ private void fixInstructions() {
                             }
                             break;
                         }
+                        default: {
+                            break;
+                        }
                     }
                 }
             }
@@ -608,8 +614,7 @@ private int mapCodeAddressToIndex(int codeAddress) {
         } else {
             do {
                 index++;
-            }
-            while (index < instructionList.size() && instructionList.get(index).codeAddress <= codeAddress);
+            } while (index < instructionList.size() && instructionList.get(index).codeAddress <= codeAddress);
             return index - 1;
         }
     }
diff --git a/tinker-sample-android/app/build.gradle b/tinker-sample-android/app/build.gradle
index ceac928a..2a02d5a8 100644
--- a/tinker-sample-android/app/build.gradle
+++ b/tinker-sample-android/app/build.gradle
@@ -47,8 +47,8 @@ def gitSha() {
 def javaVersion = JavaVersion.VERSION_1_7
 
 android {
-    compileSdkVersion 26
-    buildToolsVersion '26.0.2'
+    compileSdkVersion 28
+    buildToolsVersion '28.0.3'
 
     compileOptions {
         sourceCompatibility javaVersion
@@ -133,6 +133,10 @@ android {
             jniLibs.srcDirs = ['libs']
         }
     }
+
+    packagingOptions {
+        exclude "/META-INF/**"
+    }
 }
 
 def bakPath = file("${buildDir}/bakApk/")
@@ -148,11 +152,11 @@ ext {
 
     //for normal build
     //old apk file to build patch apk
-    tinkerOldApkPath = "${bakPath}/app-debug-1018-17-32-47.apk"
+    tinkerOldApkPath = "${bakPath}/app-debug-0424-15-02-56.apk"
     //proguard mapping file to build patch apk
     tinkerApplyMappingPath = "${bakPath}/app-debug-1018-17-32-47-mapping.txt"
     //resource R.txt to build patch apk, must input if there is resource changed
-    tinkerApplyResourcePath = "${bakPath}/app-debug-1018-17-32-47-R.txt"
+    tinkerApplyResourcePath = "${bakPath}/app-debug-0424-15-02-56-R.txt"
 
     //only use for build all flavor, if not, just ignore this field
     tinkerBuildFlavorDirectory = "${bakPath}/app-1018-17-32-47"
@@ -414,7 +418,22 @@ if (buildWithTinker()) {
                         def newFileNamePrefix = hasFlavors ? "${fileNamePrefix}" : "${fileNamePrefix}-${date}"
 
                         def destPath = hasFlavors ? file("${bakPath}/${project.name}-${date}/${variant.flavorName}") : bakPath
-                        from variant.outputs.first().outputFile
+
+                        if (variant.metaClass.hasProperty(variant, 'packageApplicationProvider')) {
+                            def packageAndroidArtifact = variant.packageApplicationProvider.get()
+                            if (packageAndroidArtifact != null) {
+                                try {
+                                    from new File(packageAndroidArtifact.outputDirectory.getAsFile().get(), variant.outputs.first().apkData.outputFileName)
+                                } catch (Exception e) {
+                                    from new File(packageAndroidArtifact.outputDirectory, variant.outputs.first().apkData.outputFileName)
+                                }
+                            } else {
+                                from variant.outputs.first().mainOutputFile.outputFile
+                            }
+                        } else {
+                            from variant.outputs.first().outputFile
+                        }
+
                         into destPath
                         rename { String fileName ->
                             fileName.replace("${fileNamePrefix}.apk", "${newFileNamePrefix}.apk")
@@ -427,6 +446,7 @@ if (buildWithTinker()) {
                         }
 
                         from "${buildDir}/intermediates/symbols/${variant.dirName}/R.txt"
+                        from "${buildDir}/intermediates/symbol_list/${variant.dirName}/R.txt"
                         into destPath
                         rename { String fileName ->
                             fileName.replace("R.txt", "${newFileNamePrefix}-R.txt")
diff --git a/tinker-sample-android/app/src/main/AndroidManifest.xml b/tinker-sample-android/app/src/main/AndroidManifest.xml
index 9676eb94..02385cc7 100644
--- a/tinker-sample-android/app/src/main/AndroidManifest.xml
+++ b/tinker-sample-android/app/src/main/AndroidManifest.xml
@@ -2,8 +2,6 @@
 <manifest package="tinker.sample.android"
           xmlns:android="http://schemas.android.com/apk/res/android">
 
-    <uses-sdk android:minSdkVersion="15" android:targetSdkVersion="22"/>
-
     <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
     <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
 
@@ -14,6 +12,7 @@
         android:theme="@style/AppTheme">
         <service
             android:name=".service.SampleResultService"
+            android:permission="android.permission.BIND_JOB_SERVICE"
             android:exported="false"/>
 
         <activity android:name=".app.MainActivity">
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/app/MainActivity.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/app/MainActivity.java
index 6bc8122b..a849a605 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/app/MainActivity.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/app/MainActivity.java
@@ -16,11 +16,16 @@
 
 package tinker.sample.android.app;
 
+import android.Manifest;
 import android.app.AlertDialog;
 import android.content.Context;
+import android.content.pm.PackageManager;
 import android.graphics.Typeface;
+import android.os.Build;
 import android.os.Bundle;
 import android.os.Environment;
+import android.support.v4.app.ActivityCompat;
+import android.support.v4.content.ContextCompat;
 import android.support.v7.app.AppCompatActivity;
 import android.util.Log;
 import android.util.TypedValue;
@@ -42,6 +47,8 @@
 public class MainActivity extends AppCompatActivity {
     private static final String TAG = "Tinker.MainActivity";
 
+    private TextView mTvMessage = null;
+
     @Override
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
@@ -51,6 +58,10 @@ protected void onCreate(Bundle savedInstanceState) {
         Log.e(TAG, "i am on onCreate string:" + getResources().getString(R.string.test_resource));
 //        Log.e(TAG, "i am on patch onCreate");
 
+        mTvMessage = findViewById(R.id.tv_message);
+
+        askForRequiredPermissions();
+
         Button loadPatchButton = (Button) findViewById(R.id.loadPatch);
 
         loadPatchButton.setOnClickListener(new View.OnClickListener() {
@@ -107,6 +118,26 @@ public void onClick(View v) {
         });
     }
 
+    private void askForRequiredPermissions() {
+        if (Build.VERSION.SDK_INT < 23) {
+            return;
+        }
+        if (!hasRequiredPermissions()) {
+            ActivityCompat.requestPermissions(this, new String[] {Manifest.permission.READ_EXTERNAL_STORAGE}, 0);
+        }
+    }
+
+    private boolean hasRequiredPermissions() {
+        if (Build.VERSION.SDK_INT >= 16) {
+            final int res = ContextCompat.checkSelfPermission(this.getApplicationContext(), Manifest.permission.READ_EXTERNAL_STORAGE);
+            return res == PackageManager.PERMISSION_GRANTED;
+        } else {
+            // When SDK_INT is below 16, READ_EXTERNAL_STORAGE will also be granted if WRITE_EXTERNAL_STORAGE is granted.
+            final int res = ContextCompat.checkSelfPermission(this.getApplicationContext(), Manifest.permission.WRITE_EXTERNAL_STORAGE);
+            return res == PackageManager.PERMISSION_GRANTED;
+        }
+    }
+
     public boolean showInfo(Context context) {
         // add more Build Info
         final StringBuilder sb = new StringBuilder();
@@ -157,6 +188,13 @@ protected void onResume() {
         super.onResume();
         Utils.setBackground(false);
 
+        if (hasRequiredPermissions()) {
+            mTvMessage.setVisibility(View.GONE);
+        } else {
+            mTvMessage.setText(R.string.msg_no_permissions);
+            mTvMessage.setTextColor(getResources().getColor(android.R.color.holo_red_dark));
+            mTvMessage.setVisibility(View.VISIBLE);
+        }
     }
 
     @Override
diff --git a/tinker-sample-android/app/src/main/res/layout/activity_main.xml b/tinker-sample-android/app/src/main/res/layout/activity_main.xml
index e7d4180a..6c4a5fbc 100644
--- a/tinker-sample-android/app/src/main/res/layout/activity_main.xml
+++ b/tinker-sample-android/app/src/main/res/layout/activity_main.xml
@@ -13,15 +13,26 @@
         android:id="@+id/textView"
         android:layout_width="wrap_content"
         android:layout_height="wrap_content"
+        android:layout_alignParentLeft="true"
+        android:layout_alignParentStart="true"
         android:text="Sample patch!"/>
 
+    <TextView
+        android:id="@+id/tv_message"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_below="@+id/textView"
+        android:layout_alignParentStart="true"
+        android:layout_alignParentLeft="true"
+        android:visibility="gone" />
+
     <Button
         android:id="@+id/loadPatch"
         android:layout_width="wrap_content"
         android:layout_height="wrap_content"
         android:layout_alignParentLeft="true"
         android:layout_alignParentStart="true"
-        android:layout_below="@+id/textView"
+        android:layout_below="@+id/tv_message"
         android:text="load patch"/>
 
     <Button
diff --git a/tinker-sample-android/app/src/main/res/values/strings.xml b/tinker-sample-android/app/src/main/res/values/strings.xml
index d2b63d1e..03d6cfd7 100644
--- a/tinker-sample-android/app/src/main/res/values/strings.xml
+++ b/tinker-sample-android/app/src/main/res/values/strings.xml
@@ -1,5 +1,8 @@
 <resources>
     <string name="app_name">tinker-sample-android</string>
     <string name="test_resource">I am in the base apk</string>
+
+    <string name="msg_no_permissions">Please grant external storage accessing permissions to this app. Otherwise patch loading may be failed.</string>
+
     <!--<string name="test_resource">I am in the patch apk</string>-->
 </resources>
diff --git a/tinker-sample-android/build.gradle b/tinker-sample-android/build.gradle
index c424ee6a..c2e0918e 100644
--- a/tinker-sample-android/build.gradle
+++ b/tinker-sample-android/build.gradle
@@ -3,10 +3,7 @@ buildscript {
     repositories {
         mavenLocal()
         jcenter()
-        maven {
-            url 'https://maven.google.com/'
-            name 'Google'
-        }
+        google()
     }
     dependencies {
         if (project.hasProperty('GRADLE_3') && GRADLE_3.equalsIgnoreCase('TRUE')) {
@@ -29,10 +26,7 @@ allprojects {
     repositories {
         mavenLocal()
         jcenter()
-        maven {
-            url 'https://maven.google.com/'
-            name 'Google'
-        }
+        google()
     }
 }
 
diff --git a/tinker-sample-android/gradle.properties b/tinker-sample-android/gradle.properties
index 0da4d094..1868a251 100644
--- a/tinker-sample-android/gradle.properties
+++ b/tinker-sample-android/gradle.properties
@@ -10,15 +10,15 @@
 # Specifies the JVM arguments used for the daemon process.
 # The setting is particularly useful for tweaking memory settings.
 # Default value: -Xmx10248m -XX:MaxPermSize=256m
- org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=1024m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8
+org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=1024m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8
 
 # When configured, Gradle will run in incubating parallel mode.
 # This option should only be used with decoupled projects. More details, visit
 # http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
 # org.gradle.parallel=true
 
-TINKER_VERSION=1.9.11
+TINKER_VERSION=1.9.14
 GRADLE_3=true
 
-#android.enableAapt2=false
+android.enableAapt2=false
 #tinker.aapt2.public=false
