diff --git a/README.md b/README.md
index fb0500be..f219bd83 100644
--- a/README.md
+++ b/README.md
@@ -1,8 +1,8 @@
 ## Tinker
 [![license](http://img.shields.io/badge/license-BSD3-brightgreen.svg?style=flat)](https://github.com/Tencent/tinker/blob/master/LICENSE)
-[![Release Version](https://img.shields.io/badge/release-1.9.1-red.svg)](https://github.com/Tencent/tinker/releases)
+[![Release Version](https://img.shields.io/badge/release-1.9.5-red.svg)](https://github.com/Tencent/tinker/releases)
 [![PRs Welcome](https://img.shields.io/badge/PRs-welcome-brightgreen.svg)](https://github.com/Tencent/tinker/pulls)
-[![WeChat Approved](https://img.shields.io/badge/Wechat_Approved-1.9.0-red.svg)](https://github.com/Tencent/tinker/wiki)
+[![WeChat Approved](https://img.shields.io/badge/Wechat_Approved-1.9.5-red.svg)](https://github.com/Tencent/tinker/wiki)
 
 Tinker is a hot-fix solution library for Android, it supports dex, library and resources update without reinstalling apk.
 
diff --git a/gradle.properties b/gradle.properties
index 51b25818..072deecb 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -16,5 +16,5 @@
 # This option should only be used with decoupled projects. More details, visit
 # http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
 # org.gradle.parallel=true
-VERSION_NAME_PREFIX=1.9.2
+VERSION_NAME_PREFIX=1.9.6
 VERSION_NAME_SUFFIX=
\ No newline at end of file
diff --git a/gradle/android-artifacts.gradle b/gradle/android-artifacts.gradle
index cd4ded81..584ca11a 100644
--- a/gradle/android-artifacts.gradle
+++ b/gradle/android-artifacts.gradle
@@ -83,6 +83,26 @@ publishing {
             // Tell maven to prepare the generated "*.aar" file for publishing
             artifact("$buildDir/outputs/aar/${project.getName()}-release.aar")
             artifact androidJavadocsJar
+            pom.withXml {
+                def dependenciesNode = asNode().appendNode('dependencies')
+                configurations.compile.allDependencies.each {
+                    if (it.group != null && it.name != null) {
+                        def dependencyNode = dependenciesNode.appendNode('dependency')
+                        dependencyNode.appendNode('groupId', it.group)
+                        dependencyNode.appendNode('artifactId', it.name)
+                        dependencyNode.appendNode('version', it.version)
+
+                        if (it.excludeRules.size() > 0) {
+                            def exclusionsNode = dependencyNode.appendNode('exclusions')
+                            it.excludeRules.each { rule ->
+                                def exclusionNode = exclusionsNode.appendNode('exclusion')
+                                exclusionNode.appendNode('groupId', rule.group)
+                                exclusionNode.appendNode('artifactId', rule.module)
+                            }
+                        }
+                    }
+                }
+            }
         }
     }
 }
diff --git a/tinker-android/tinker-android-lib/src/main/AndroidManifest.xml b/tinker-android/tinker-android-lib/src/main/AndroidManifest.xml
index da7ffb48..b03a6d56 100644
--- a/tinker-android/tinker-android-lib/src/main/AndroidManifest.xml
+++ b/tinker-android/tinker-android-lib/src/main/AndroidManifest.xml
@@ -2,17 +2,24 @@
           xmlns:android="http://schemas.android.com/apk/res/android">
 
     <application>
+
         <service
-            android:name=".service.TinkerPatchService"
+            android:name=".service.TinkerPatchService$IntentServiceRunner"
             android:exported="false"
             android:process=":patch"/>
         <service
-            android:name=".service.TinkerPatchService$InnerService"
+            android:name=".service.TinkerPatchService$IntentServiceRunner$InnerService"
+            android:exported="false"
+            android:process=":patch"/>
+        <service
+            android:name=".service.TinkerPatchService$JobServiceRunner"
+            android:permission="android.permission.BIND_JOB_SERVICE"
             android:exported="false"
             android:process=":patch"/>
         <service
             android:name=".service.DefaultTinkerResultService"
             android:exported="false"/>
+
     </application>
 
 </manifest>
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/library/TinkerLoadLibrary.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/library/TinkerLoadLibrary.java
index 26f7d4c2..029d49be 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/library/TinkerLoadLibrary.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/library/TinkerLoadLibrary.java
@@ -20,18 +20,23 @@
 import android.os.Build;
 
 import com.tencent.tinker.lib.tinker.Tinker;
+import com.tencent.tinker.lib.tinker.TinkerApplicationHelper;
+import com.tencent.tinker.lib.tinker.TinkerInstaller;
 import com.tencent.tinker.lib.tinker.TinkerLoadResult;
 import com.tencent.tinker.lib.util.TinkerLog;
 import com.tencent.tinker.loader.TinkerRuntimeException;
+import com.tencent.tinker.loader.app.ApplicationLike;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
 import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
 import com.tencent.tinker.loader.shareutil.ShareReflectUtil;
+import com.tencent.tinker.loader.shareutil.ShareTinkerInternals;
 
 import java.io.File;
 import java.io.IOException;
 import java.lang.reflect.Field;
 import java.lang.reflect.Method;
 import java.util.ArrayList;
+import java.util.Iterator;
 import java.util.List;
 
 /**
@@ -54,11 +59,29 @@ public static void loadArmLibrary(Context context, String libName) {
         }
 
         Tinker tinker = Tinker.with(context);
+
         if (tinker.isEnabledForNativeLib()) {
             if (TinkerLoadLibrary.loadLibraryFromTinker(context, "lib/armeabi", libName)) {
                 return;
             }
+        }
+        System.loadLibrary(libName);
+    }
 
+    /**
+     * The same as {@link #loadArmLibrary(Context, String)} but it can be called before
+     * calling {@link TinkerInstaller#install}
+     * @param appLike
+     * @param libName
+     */
+    public static void loadArmLibraryWithoutTinkerInstalled(ApplicationLike appLike, String libName) {
+        if (libName == null || libName.isEmpty() || appLike == null) {
+            throw new TinkerRuntimeException("libName or appLike is null!");
+        }
+        if (TinkerApplicationHelper.isTinkerEnableForNativeLib(appLike)) {
+            if (TinkerApplicationHelper.loadLibraryFromTinker(appLike, "lib/armeabi", libName)) {
+                return;
+            }
         }
         System.loadLibrary(libName);
     }
@@ -84,6 +107,24 @@ public static void loadArmV7Library(Context context, String libName) {
         System.loadLibrary(libName);
     }
 
+    /**
+     * The same as {@link #loadArmV7Library(Context, String)} but it can be called before
+     * calling {@link TinkerInstaller#install}
+     * @param appLike
+     * @param libName
+     */
+    public static void loadArmV7LibraryWithoutTinkerInstalled(ApplicationLike appLike, String libName) {
+        if (libName == null || libName.isEmpty() || appLike == null) {
+            throw new TinkerRuntimeException("libName or appLike is null!");
+        }
+        if (TinkerApplicationHelper.isTinkerEnableForNativeLib(appLike)) {
+            if (TinkerApplicationHelper.loadLibraryFromTinker(appLike, "lib/armeabi-v7a", libName)) {
+                return;
+            }
+        }
+        System.loadLibrary(libName);
+    }
+
     /**
      * sample usage for native library
      *
@@ -133,37 +174,96 @@ public static boolean loadLibraryFromTinker(Context context, String relativePath
      * @param context
      * @param currentABI
      */
-    public static void installNavitveLibraryABI(Context context, String currentABI) {
+    public static boolean installNavitveLibraryABI(Context context, String currentABI) {
         Tinker tinker = Tinker.with(context);
         if (!tinker.isTinkerLoaded()) {
             TinkerLog.i(TAG, "tinker is not loaded, just return");
-            return;
+            return false;
         }
         TinkerLoadResult loadResult = tinker.getTinkerLoadResultIfPresent();
         if (loadResult.libs == null) {
             TinkerLog.i(TAG, "tinker libs is null, just return");
-            return;
+            return false;
         }
         File soDir = new File(loadResult.libraryDirectory, "lib/" + currentABI);
         if (!soDir.exists()) {
             TinkerLog.e(TAG, "current libraryABI folder is not exist, path: %s", soDir.getPath());
-            return;
+            return false;
         }
         ClassLoader classLoader = context.getClassLoader();
         if (classLoader == null) {
             TinkerLog.e(TAG, "classloader is null");
-            return;
+            return false;
         }
         TinkerLog.i(TAG, "before hack classloader:" + classLoader.toString());
 
         try {
             installNativeLibraryPath(classLoader, soDir);
+            return true;
         } catch (Throwable throwable) {
             TinkerLog.e(TAG, "installNativeLibraryPath fail:" + throwable);
+            return false;
+        } finally {
+            TinkerLog.i(TAG, "after hack classloader:" + classLoader.toString());
         }
-        TinkerLog.i(TAG, "after hack classloader:" + classLoader.toString());
     }
 
+    /**
+     * The same as {@link #installNavitveLibraryABI(Context, String)} but it can be called before
+     * calling {@link TinkerInstaller#install}
+     * @param appLike
+     * @param currentABI
+     * @return
+     */
+    public static boolean installNativeLibraryABIWithoutTinkerInstalled(ApplicationLike appLike, String currentABI) {
+        final String currentVersion = TinkerApplicationHelper.getCurrentVersion(appLike);
+        if (ShareTinkerInternals.isNullOrNil(currentVersion)) {
+            TinkerLog.e(TAG, "failed to get current patch version.");
+            return false;
+        }
+
+        final File patchDirectory = SharePatchFileUtil.getPatchDirectory(appLike.getApplication());
+        if (patchDirectory == null) {
+            TinkerLog.e(TAG, "failed to get current patch directory.");
+            return false;
+        }
+
+        File patchVersionDirectory = new File(patchDirectory.getAbsolutePath() + "/" + SharePatchFileUtil.getPatchVersionDirectory(currentVersion));
+        File libPath = new File(patchVersionDirectory.getAbsolutePath() + "/lib/lib/" + currentABI);
+        if (!libPath.exists()) {
+            TinkerLog.e(TAG, "tinker lib path [%s] is not exists.", libPath);
+            return false;
+        }
+
+        final ClassLoader classLoader = appLike.getApplication().getClassLoader();
+        if (classLoader == null) {
+            TinkerLog.e(TAG, "classloader is null");
+            return false;
+        } else {
+            TinkerLog.i(TAG, "before hack classloader:" + classLoader.toString());
+            try {
+                final Method installNativeLibraryPathMethod =
+                        TinkerLoadLibrary.class.getDeclaredMethod("installNativeLibraryPath", ClassLoader.class, File.class);
+                installNativeLibraryPathMethod.setAccessible(true);
+                installNativeLibraryPathMethod.invoke(null, classLoader, libPath);
+                return true;
+            } catch (Throwable thr) {
+                TinkerLog.e(TAG, "installNativeLibraryPath fail:" + libPath + ", thr: " + thr);
+                return false;
+            } finally {
+                TinkerLog.i(TAG, "after hack classloader:" + classLoader.toString());
+            }
+        }
+    }
+
+    /**
+     * All version of install logic obey the following strategies:
+     *   1. If path of {@code folder} is not injected into the classloader, inject it to the
+     *   beginning of pathList in the classloader.
+     *
+     *   2. Otherwise remove path of {@code folder} first, then re-inject it to the
+     *   beginning of pathList in the classloader.
+     */
     private static void installNativeLibraryPath(ClassLoader classLoader, File folder)
         throws Throwable {
         if (folder == null || !folder.exists()) {
@@ -176,7 +276,6 @@ private static void installNativeLibraryPath(ClassLoader classLoader, File folde
             || Build.VERSION.SDK_INT > 25) {
             try {
                 V25.install(classLoader, folder);
-                return;
             } catch (Throwable throwable) {
                 // install fail, try to treat it as v23
                 // some preview N version may go here
@@ -205,12 +304,28 @@ private static void installNativeLibraryPath(ClassLoader classLoader, File folde
         private static void install(ClassLoader classLoader, File folder)  throws Throwable {
             String addPath = folder.getPath();
             Field pathField = ShareReflectUtil.findField(classLoader, "libPath");
-            StringBuilder libPath = new StringBuilder((String) pathField.get(classLoader));
-            libPath.append(':').append(addPath);
-            pathField.set(classLoader, libPath.toString());
+            final String origLibPaths = (String) pathField.get(classLoader);
+            final String[] origLibPathSplit = origLibPaths.split(":");
+            final StringBuilder newLibPaths = new StringBuilder(addPath);
+
+            for (String origLibPath : origLibPathSplit) {
+                if (origLibPath == null || addPath.equals(origLibPath)) {
+                    continue;
+                }
+                newLibPaths.append(':').append(origLibPath);
+            }
+            pathField.set(classLoader, newLibPaths.toString());
 
-            Field libraryPathElementsFiled = ShareReflectUtil.findField(classLoader, "libraryPathElements");
-            List<String> libraryPathElements = (List<String>) libraryPathElementsFiled.get(classLoader);
+            final Field libraryPathElementsFiled = ShareReflectUtil.findField(classLoader, "libraryPathElements");
+            final List<String> libraryPathElements = (List<String>) libraryPathElementsFiled.get(classLoader);
+            final Iterator<String> libPathElementIt = libraryPathElements.iterator();
+            while (libPathElementIt.hasNext()) {
+                final String libPath = libPathElementIt.next();
+                if (addPath.equals(libPath)) {
+                    libPathElementIt.remove();
+                    break;
+                }
+            }
             libraryPathElements.add(0, addPath);
             libraryPathElementsFiled.set(classLoader, libraryPathElements);
         }
@@ -218,56 +333,101 @@ private static void install(ClassLoader classLoader, File folder)  throws Throwa
 
     private static final class V14 {
         private static void install(ClassLoader classLoader, File folder)  throws Throwable {
-            Field pathListField = ShareReflectUtil.findField(classLoader, "pathList");
-            Object dexPathList = pathListField.get(classLoader);
+            final Field pathListField = ShareReflectUtil.findField(classLoader, "pathList");
+            final Object dexPathList = pathListField.get(classLoader);
+
+            final Field nativeLibDirField = ShareReflectUtil.findField(dexPathList, "nativeLibraryDirectories");
+            final File[] origNativeLibDirs = (File[]) nativeLibDirField.get(dexPathList);
 
-            ShareReflectUtil.expandFieldArray(dexPathList, "nativeLibraryDirectories", new File[]{folder});
+            final List<File> newNativeLibDirList = new ArrayList<>(origNativeLibDirs.length + 1);
+            newNativeLibDirList.add(folder);
+            for (File origNativeLibDir : origNativeLibDirs) {
+                if (!folder.equals(origNativeLibDir)) {
+                    newNativeLibDirList.add(origNativeLibDir);
+                }
+            }
+            nativeLibDirField.set(dexPathList, newNativeLibDirList.toArray(new File[0]));
         }
     }
 
     private static final class V23 {
         private static void install(ClassLoader classLoader, File folder)  throws Throwable {
-            Field pathListField = ShareReflectUtil.findField(classLoader, "pathList");
-            Object dexPathList = pathListField.get(classLoader);
-
-            Field nativeLibraryDirectories = ShareReflectUtil.findField(dexPathList, "nativeLibraryDirectories");
-
-            List<File> libDirs = (List<File>) nativeLibraryDirectories.get(dexPathList);
-            libDirs.add(0, folder);
-            Field systemNativeLibraryDirectories =
-                ShareReflectUtil.findField(dexPathList, "systemNativeLibraryDirectories");
-            List<File> systemLibDirs = (List<File>) systemNativeLibraryDirectories.get(dexPathList);
-            Method makePathElements =
-                ShareReflectUtil.findMethod(dexPathList, "makePathElements", List.class, File.class, List.class);
-            ArrayList<IOException> suppressedExceptions = new ArrayList<>();
-            libDirs.addAll(systemLibDirs);
-            Object[] elements = (Object[]) makePathElements.
-                invoke(dexPathList, libDirs, null, suppressedExceptions);
-            Field nativeLibraryPathElements = ShareReflectUtil.findField(dexPathList, "nativeLibraryPathElements");
-            nativeLibraryPathElements.setAccessible(true);
+            final Field pathListField = ShareReflectUtil.findField(classLoader, "pathList");
+            final Object dexPathList = pathListField.get(classLoader);
+
+            final Field nativeLibraryDirectories = ShareReflectUtil.findField(dexPathList, "nativeLibraryDirectories");
+
+            List<File> origLibDirs = (List<File>) nativeLibraryDirectories.get(dexPathList);
+            if (origLibDirs == null) {
+                origLibDirs = new ArrayList<>(2);
+            }
+            final Iterator<File> libDirIt = origLibDirs.iterator();
+            while (libDirIt.hasNext()) {
+                final File libDir = libDirIt.next();
+                if (folder.equals(libDir)) {
+                    libDirIt.remove();
+                    break;
+                }
+            }
+            origLibDirs.add(0, folder);
+
+            final Field systemNativeLibraryDirectories = ShareReflectUtil.findField(dexPathList, "systemNativeLibraryDirectories");
+            List<File> origSystemLibDirs = (List<File>) systemNativeLibraryDirectories.get(dexPathList);
+            if (origSystemLibDirs == null) {
+                origSystemLibDirs = new ArrayList<>(2);
+            }
+
+            final List<File> newLibDirs = new ArrayList<>(origLibDirs.size() + origSystemLibDirs.size() + 1);
+            newLibDirs.addAll(origLibDirs);
+            newLibDirs.addAll(origSystemLibDirs);
+
+            final Method makeElements = ShareReflectUtil.findMethod(dexPathList,
+                    "makePathElements", List.class, File.class, List.class);
+            final ArrayList<IOException> suppressedExceptions = new ArrayList<>();
+
+            final Object[] elements = (Object[]) makeElements.invoke(dexPathList, newLibDirs, null, suppressedExceptions);
+
+            final Field nativeLibraryPathElements = ShareReflectUtil.findField(dexPathList, "nativeLibraryPathElements");
             nativeLibraryPathElements.set(dexPathList, elements);
         }
     }
 
     private static final class V25 {
         private static void install(ClassLoader classLoader, File folder)  throws Throwable {
-            Field pathListField = ShareReflectUtil.findField(classLoader, "pathList");
-            Object dexPathList = pathListField.get(classLoader);
-
-            Field nativeLibraryDirectories = ShareReflectUtil.findField(dexPathList, "nativeLibraryDirectories");
-
-            List<File> libDirs = (List<File>) nativeLibraryDirectories.get(dexPathList);
-            libDirs.add(0, folder);
-            Field systemNativeLibraryDirectories =
-                    ShareReflectUtil.findField(dexPathList, "systemNativeLibraryDirectories");
-            List<File> systemLibDirs = (List<File>) systemNativeLibraryDirectories.get(dexPathList);
-            Method makePathElements =
-                    ShareReflectUtil.findMethod(dexPathList, "makePathElements", List.class);
-            libDirs.addAll(systemLibDirs);
-            Object[] elements = (Object[]) makePathElements.
-                    invoke(dexPathList, libDirs);
-            Field nativeLibraryPathElements = ShareReflectUtil.findField(dexPathList, "nativeLibraryPathElements");
-            nativeLibraryPathElements.setAccessible(true);
+            final Field pathListField = ShareReflectUtil.findField(classLoader, "pathList");
+            final Object dexPathList = pathListField.get(classLoader);
+
+            final Field nativeLibraryDirectories = ShareReflectUtil.findField(dexPathList, "nativeLibraryDirectories");
+
+            List<File> origLibDirs = (List<File>) nativeLibraryDirectories.get(dexPathList);
+            if (origLibDirs == null) {
+                origLibDirs = new ArrayList<>(2);
+            }
+            final Iterator<File> libDirIt = origLibDirs.iterator();
+            while (libDirIt.hasNext()) {
+                final File libDir = libDirIt.next();
+                if (folder.equals(libDir)) {
+                    libDirIt.remove();
+                    break;
+                }
+            }
+            origLibDirs.add(0, folder);
+
+            final Field systemNativeLibraryDirectories = ShareReflectUtil.findField(dexPathList, "systemNativeLibraryDirectories");
+            List<File> origSystemLibDirs = (List<File>) systemNativeLibraryDirectories.get(dexPathList);
+            if (origSystemLibDirs == null) {
+                origSystemLibDirs = new ArrayList<>(2);
+            }
+
+            final List<File> newLibDirs = new ArrayList<>(origLibDirs.size() + origSystemLibDirs.size() + 1);
+            newLibDirs.addAll(origLibDirs);
+            newLibDirs.addAll(origSystemLibDirs);
+
+            final Method makeElements = ShareReflectUtil.findMethod(dexPathList, "makePathElements", List.class);
+
+            final Object[] elements = (Object[]) makeElements.invoke(dexPathList, newLibDirs);
+
+            final Field nativeLibraryPathElements = ShareReflectUtil.findField(dexPathList, "nativeLibraryPathElements");
             nativeLibraryPathElements.set(dexPathList, elements);
         }
     }
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java
index eb1b83e5..9c29ebfc 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java
@@ -59,8 +59,9 @@
 public class DexDiffPatchInternal extends BasePatchInternal {
     protected static final String TAG = "Tinker.DexDiffPatchInternal";
 
-    protected static final int WAIT_ASYN_OAT_TIME = 15 * 1000;
-    protected static final int MAX_WAIT_COUNT     = 30;
+    protected static final int WAIT_ASYN_OAT_TIME = 10 * 1000;
+    protected static final int MAX_WAIT_COUNT     = 120;
+
 
     private static ArrayList<File>                      optFiles      = new ArrayList<>();
     private static ArrayList<ShareDexDiffPatchInfo>     patchList     = new ArrayList<>();
@@ -93,7 +94,7 @@ protected static boolean waitAndCheckDexOptFile(File patchFile, Tinker manager)
             return true;
         }
         // should use patch list size
-        int size = patchList.size() * 8;
+        int size = patchList.size() * 30;
         if (size > MAX_WAIT_COUNT) {
             size = MAX_WAIT_COUNT;
         }
@@ -271,7 +272,7 @@ private static boolean mergeClassNDexFiles(final Context context, final File pat
                     }
                 } else {
                     TinkerZipEntry dexZipEntry = new TinkerZipEntry(info.rawName);
-                    TinkerZipUtil.extractLargeModifyFile(dexZipEntry, dexFile, Long.parseLong(info.newDexCrC), out);
+                    TinkerZipUtil.extractLargeModifyFile(dexZipEntry, dexFile, Long.parseLong(info.newOrPatchedDexCrC), out);
                 }
 
             }
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/TinkerPatchService.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/TinkerPatchService.java
index db7d4526..0cc63add 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/TinkerPatchService.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/TinkerPatchService.java
@@ -16,55 +16,105 @@
 
 package com.tencent.tinker.lib.service;
 
+import android.annotation.TargetApi;
 import android.app.IntentService;
 import android.app.Notification;
 import android.app.Service;
+import android.app.job.JobInfo;
+import android.app.job.JobParameters;
+import android.app.job.JobScheduler;
+import android.app.job.JobService;
+import android.content.ComponentName;
 import android.content.Context;
 import android.content.Intent;
+import android.os.AsyncTask;
 import android.os.Build;
+import android.os.Handler;
 import android.os.IBinder;
+import android.os.Looper;
+import android.os.PersistableBundle;
 import android.os.SystemClock;
+import android.support.annotation.Nullable;
 
 import com.tencent.tinker.lib.patch.AbstractPatch;
 import com.tencent.tinker.lib.tinker.Tinker;
 import com.tencent.tinker.lib.util.TinkerLog;
+import com.tencent.tinker.lib.util.TinkerServiceInternals;
 import com.tencent.tinker.loader.TinkerRuntimeException;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
 import com.tencent.tinker.loader.shareutil.ShareIntentUtil;
 
 import java.io.File;
+import java.lang.ref.WeakReference;
+import java.util.concurrent.TimeUnit;
 
 /**
  * Created by zhangshaowen on 16/3/14.
  */
-public class TinkerPatchService extends IntentService {
+public class TinkerPatchService {
     private static final String TAG = "Tinker.TinkerPatchService";
 
-    private static final String        PATCH_PATH_EXTRA      = "patch_path_extra";
-    private static final String        RESULT_CLASS_EXTRA    = "patch_result_class";
+    private static final String PATCH_PATH_EXTRA = "patch_path_extra";
+    private static final String RESULT_CLASS_EXTRA = "patch_result_class";
+    private static final int MIN_SDKVER_TO_USE_JOBSCHEDULER = 26;
 
-    private static       AbstractPatch upgradePatchProcessor = null;
-    private static       int                                    notificationId       = ShareConstants.TINKER_PATCH_SERVICE_NOTIFICATION;
-    private static       Class<? extends AbstractResultService> resultServiceClass   = null;
+    private static AbstractPatch upgradePatchProcessor = null;
+    private static int notificationId = ShareConstants.TINKER_PATCH_SERVICE_NOTIFICATION;
+    private static Class<? extends AbstractResultService> resultServiceClass = null;
+    private static Handler mHandler = new Handler(Looper.getMainLooper());
 
-    /**
-     * Creates an IntentService.  Invoked by your subclass's constructor.
-     */
-    public TinkerPatchService() {
-        super(TinkerPatchService.class.getSimpleName());
-    }
-
-    public static void runPatchService(Context context, String path) {
+    public static void runPatchService(final Context context, final String path) {
         try {
-            Intent intent = new Intent(context, TinkerPatchService.class);
-            intent.putExtra(PATCH_PATH_EXTRA, path);
-            intent.putExtra(RESULT_CLASS_EXTRA, resultServiceClass.getName());
-            context.startService(intent);
+            if (Build.VERSION.SDK_INT < MIN_SDKVER_TO_USE_JOBSCHEDULER) {
+                runPatchServiceByIntentService(context, path);
+            } else {
+                if (!runPatchServiceByJobScheduler(context, path)) {
+                    TinkerLog.e(TAG, "start patch job service fail, try to fallback to intent service.");
+                    mHandler.postDelayed(new Runnable() {
+                        @Override
+                        public void run() {
+                            // This method will tell us whether the intent service or the job scheduler
+                            // is running.
+                            TinkerLog.i(TAG, "fallback: prepare trying to run patch service by intent service.");
+                            if (!TinkerServiceInternals.isTinkerPatchServiceRunning(context)) {
+                                runPatchServiceByIntentService(context, path);
+                            }
+                        }
+                    }, TimeUnit.SECONDS.toMillis(3));
+                }
+            }
         } catch (Throwable throwable) {
             TinkerLog.e(TAG, "start patch service fail, exception:" + throwable);
         }
     }
 
+    private static void runPatchServiceByIntentService(Context context, String path) {
+        TinkerLog.i(TAG, "run patch service by intent service.");
+        Intent intent = new Intent(context, IntentServiceRunner.class);
+        intent.putExtra(PATCH_PATH_EXTRA, path);
+        intent.putExtra(RESULT_CLASS_EXTRA, resultServiceClass.getName());
+        context.startService(intent);
+    }
+
+    @TargetApi(21)
+    private static boolean runPatchServiceByJobScheduler(Context context, String path) {
+        TinkerLog.i(TAG, "run patch service by job scheduler.");
+        final JobInfo.Builder jobInfoBuilder = new JobInfo.Builder(
+                1, new ComponentName(context, JobServiceRunner.class)
+        );
+        final PersistableBundle extras = new PersistableBundle();
+        extras.putString(PATCH_PATH_EXTRA, path);
+        extras.putString(RESULT_CLASS_EXTRA, resultServiceClass.getName());
+        jobInfoBuilder.setExtras(extras);
+        jobInfoBuilder.setOverrideDeadline(5);
+        final JobScheduler jobScheduler = (JobScheduler) context.getSystemService(Context.JOB_SCHEDULER_SERVICE);
+        if (jobScheduler == null) {
+            TinkerLog.e(TAG, "jobScheduler is null.");
+            return false;
+        }
+        return (jobScheduler.schedule(jobInfoBuilder.build()) == JobScheduler.RESULT_SUCCESS);
+    }
+
     public static void setPatchProcessor(AbstractPatch upgradePatch, Class<? extends AbstractResultService> serviceClass) {
         upgradePatchProcessor = upgradePatch;
         resultServiceClass = serviceClass;
@@ -90,6 +140,14 @@ public static String getPatchResultExtra(Intent intent) {
         return ShareIntentUtil.getStringExtra(intent, RESULT_CLASS_EXTRA);
     }
 
+    public static Class<? extends Service> getRealRunnerClass() {
+        if (Build.VERSION.SDK_INT < MIN_SDKVER_TO_USE_JOBSCHEDULER) {
+            return IntentServiceRunner.class;
+        } else {
+            return JobServiceRunner.class;
+        }
+    }
+
     /**
      * set the tinker notification id you want
      * @param id
@@ -98,9 +156,7 @@ public static void setTinkerNotificationId(int id) {
         notificationId = id;
     }
 
-    @Override
-    protected void onHandleIntent(Intent intent) {
-        final Context context = getApplicationContext();
+    private static void doApplyPatch(Context context, Intent intent) {
         Tinker tinker = Tinker.with(context);
         tinker.getPatchReporter().onPatchServiceStart(intent);
 
@@ -120,7 +176,6 @@ protected void onHandleIntent(Intent intent) {
         long cost;
         Throwable e = null;
 
-        increasingPriority();
         PatchResult patchResult = new PatchResult();
         try {
             if (upgradePatchProcessor == null) {
@@ -143,57 +198,134 @@ protected void onHandleIntent(Intent intent) {
         patchResult.e = e;
 
         AbstractResultService.runResultService(context, patchResult, getPatchResultExtra(intent));
-
     }
 
-    private void increasingPriority() {
+    public static class IntentServiceRunner extends IntentService {
+
+        public IntentServiceRunner() {
+            super("TinkerPatchService");
+        }
+
+        @Override
+        protected void onHandleIntent(@Nullable Intent intent) {
+            increasingPriority();
+            doApplyPatch(getApplicationContext(), intent);
+        }
+
+        private void increasingPriority() {
 //        if (Build.VERSION.SDK_INT > 24) {
 //            TinkerLog.i(TAG, "for Android 7.1, we just ignore increasingPriority job");
 //            return;
 //        }
-        TinkerLog.i(TAG, "try to increase patch process priority");
-        try {
-            Notification notification = new Notification();
-            if (Build.VERSION.SDK_INT < 18) {
-                startForeground(notificationId, notification);
-            } else {
-                startForeground(notificationId, notification);
-                // start InnerService
-                startService(new Intent(this, InnerService.class));
+            if (Build.VERSION.SDK_INT >= 26) {
+                TinkerLog.i(TAG, "for system version >= Android O, we just ignore increasingPriority "
+                        + "job to avoid crash or toasts.");
+                return;
             }
-        } catch (Throwable e) {
-            TinkerLog.i(TAG, "try to increase patch process priority error:" + e);
-        }
-    }
 
-    /**
-     * I don't want to do this, believe me
-     */
-    //InnerService
-    public static class InnerService extends Service {
-        @Override
-        public void onCreate() {
-            super.onCreate();
+            if ("ZUK".equals(Build.MANUFACTURER)) {
+                TinkerLog.i(TAG, "for ZUK device, we just ignore increasingPriority "
+                        + "job to avoid crash.");
+                return;
+            }
+
+            TinkerLog.i(TAG, "try to increase patch process priority");
             try {
-                startForeground(notificationId, new Notification());
+                Notification notification = new Notification();
+                if (Build.VERSION.SDK_INT < 18) {
+                    startForeground(notificationId, notification);
+                } else {
+                    startForeground(notificationId, notification);
+                    // start InnerService
+                    startService(new Intent(this, InnerService.class));
+                }
             } catch (Throwable e) {
-                TinkerLog.e(TAG, "InnerService set service for push exception:%s.", e);
+                TinkerLog.i(TAG, "try to increase patch process priority error:" + e);
+            }
+        }
+
+        /**
+         * I don't want to do this, believe me
+         */
+        //InnerService
+        public static class InnerService extends Service {
+            @Override
+            public void onCreate() {
+                super.onCreate();
+                try {
+                    startForeground(notificationId, new Notification());
+                } catch (Throwable e) {
+                    TinkerLog.e(TAG, "InnerService set service for push exception:%s.", e);
+                }
+                // kill
+                stopSelf();
+            }
+
+            @Override
+            public void onDestroy() {
+                stopForeground(true);
+                super.onDestroy();
+            }
+
+            @Override
+            public IBinder onBind(Intent intent) {
+                return null;
             }
-            // kill
-            stopSelf();
         }
+    }
+
+    @TargetApi(Build.VERSION_CODES.LOLLIPOP)
+    public static class JobServiceRunner extends JobService {
+        private JobAsyncTask mTask = null;
 
         @Override
-        public void onDestroy() {
-            stopForeground(true);
-            super.onDestroy();
+        public boolean onStartJob(JobParameters params) {
+            mTask = new JobAsyncTask(this);
+            mTask.execute(params);
+            return true;
         }
 
         @Override
-        public IBinder onBind(Intent intent) {
-            return null;
+        public boolean onStopJob(JobParameters params) {
+            TinkerLog.w(TAG, "Stopping TinkerPatchJob service.");
+            if (mTask != null) {
+                mTask.cancel(true);
+                mTask = null;
+            }
+            return false;
         }
-    }
 
+        private static class JobAsyncTask extends AsyncTask<JobParameters, Void, Void> {
+            private final WeakReference<JobService> mHolderRef;
+
+            JobAsyncTask(JobService holder) {
+                mHolderRef = new WeakReference<>(holder);
+            }
+
+            @Override
+            protected Void doInBackground(JobParameters... paramsList) {
+                final JobParameters params = paramsList[0];
+                final PersistableBundle extras = params.getExtras();
+                final Intent paramIntent = new Intent();
+                paramIntent.putExtra(PATCH_PATH_EXTRA, extras.getString(PATCH_PATH_EXTRA));
+                paramIntent.putExtra(RESULT_CLASS_EXTRA, extras.getString(RESULT_CLASS_EXTRA));
+                final JobService holder = mHolderRef.get();
+                if (holder == null) {
+                    TinkerLog.e(TAG, "unexpected case: holder job service is null.");
+                    return null;
+                }
+                doApplyPatch(holder.getApplicationContext(), paramIntent);
+                notifyFinished(params);
+                return null;
+            }
+
+            private void notifyFinished(JobParameters params) {
+                final JobService holder = mHolderRef.get();
+                if (holder != null) {
+                    holder.jobFinished(params, false);
+                }
+            }
+        }
+    }
 }
 
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerApplicationHelper.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerApplicationHelper.java
index a64b331f..f00941ef 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerApplicationHelper.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerApplicationHelper.java
@@ -303,42 +303,51 @@ public static boolean loadLibraryFromTinker(ApplicationLike applicationLike, Str
         String relativeLibPath = relativePath + "/" + libname;
 
         //TODO we should add cpu abi, and the real path later
-        if (TinkerApplicationHelper.isTinkerEnableForNativeLib(applicationLike)
-            && TinkerApplicationHelper.isTinkerLoadSuccess(applicationLike)) {
-            HashMap<String, String> loadLibraries = TinkerApplicationHelper.getLoadLibraryAndMd5(applicationLike);
-            if (loadLibraries != null) {
-                String currentVersion = TinkerApplicationHelper.getCurrentVersion(applicationLike);
-                if (ShareTinkerInternals.isNullOrNil(currentVersion)) {
-                    return false;
-                }
-                File patchDirectory = SharePatchFileUtil.getPatchDirectory(applicationLike.getApplication());
-                if (patchDirectory == null) {
-                    return false;
-                }
-                File patchVersionDirectory = new File(patchDirectory.getAbsolutePath() + "/" + SharePatchFileUtil.getPatchVersionDirectory(currentVersion));
-                String libPrePath = patchVersionDirectory.getAbsolutePath() + "/" + ShareConstants.SO_PATH;
-
-                for (Map.Entry<String, String> libEntry : loadLibraries.entrySet()) {
-                    final String name = libEntry.getKey();
-                    if (name.equals(relativeLibPath)) {
-                        String patchLibraryPath = libPrePath + "/" + name;
-                        File library = new File(patchLibraryPath);
-                        if (library.exists()) {
-                            //whether we check md5 when load
-                            boolean verifyMd5 = applicationLike.getTinkerLoadVerifyFlag();
-                            if (verifyMd5 && !SharePatchFileUtil.verifyFileMd5(library, loadLibraries.get(name))) {
-                                //do not report, because tinker is not install
-                                TinkerLog.i(TAG, "loadLibraryFromTinker md5mismatch fail:" + patchLibraryPath);
-                            } else {
-                                System.load(patchLibraryPath);
-                                TinkerLog.i(TAG, "loadLibraryFromTinker success:" + patchLibraryPath);
-                                return true;
-                            }
-                        }
-                    }
-                }
+        if (!TinkerApplicationHelper.isTinkerEnableForNativeLib(applicationLike)) {
+            return false;
+        }
+        if (!TinkerApplicationHelper.isTinkerEnableForNativeLib(applicationLike)) {
+            return false;
+        }
+
+        final HashMap<String, String> loadLibraries = TinkerApplicationHelper.getLoadLibraryAndMd5(applicationLike);
+        if (loadLibraries == null) {
+            return false;
+        }
+
+        final String currentVersion = TinkerApplicationHelper.getCurrentVersion(applicationLike);
+        if (ShareTinkerInternals.isNullOrNil(currentVersion)) {
+            return false;
+        }
+        final File patchDirectory = SharePatchFileUtil.getPatchDirectory(applicationLike.getApplication());
+        if (patchDirectory == null) {
+            return false;
+        }
+        final File patchVersionDirectory = new File(patchDirectory.getAbsolutePath() + "/" + SharePatchFileUtil.getPatchVersionDirectory(currentVersion));
+        final String libPrePath = patchVersionDirectory.getAbsolutePath() + "/" + ShareConstants.SO_PATH;
+
+        for (Map.Entry<String, String> libEntry : loadLibraries.entrySet()) {
+            final String name = libEntry.getKey();
+            if (!name.equals(relativeLibPath)) {
+                continue;
+            }
+            final String patchLibraryPath = libPrePath + "/" + name;
+            final File library = new File(patchLibraryPath);
+            if (!library.exists()) {
+                continue;
+            }
+            //whether we check md5 when load
+            final boolean verifyMd5 = applicationLike.getTinkerLoadVerifyFlag();
+            if (verifyMd5 && !SharePatchFileUtil.verifyFileMd5(library, loadLibraries.get(name))) {
+                //do not report, because tinker is not install
+                TinkerLog.i(TAG, "loadLibraryFromTinker md5mismatch fail:" + patchLibraryPath);
+            } else {
+                System.load(patchLibraryPath);
+                TinkerLog.i(TAG, "loadLibraryFromTinker success:" + patchLibraryPath);
+                return true;
             }
         }
+
         return false;
     }
 }
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/TinkerServiceInternals.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/TinkerServiceInternals.java
index 0db959ee..870f46a1 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/TinkerServiceInternals.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/TinkerServiceInternals.java
@@ -98,7 +98,7 @@ public static String getTinkerPatchServiceName(final Context context) {
             return patchServiceProcessName;
         }
         //may be null, and you may like to hardcode instead
-        String serviceName = TinkerServiceInternals.getServiceProcessName(context, TinkerPatchService.class);
+        String serviceName = TinkerServiceInternals.getServiceProcessName(context, TinkerPatchService.getRealRunnerClass());
         if (serviceName == null) {
             return null;
         }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AndroidNClassLoader.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AndroidNClassLoader.java
index aa156098..d4235cb8 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AndroidNClassLoader.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AndroidNClassLoader.java
@@ -19,6 +19,7 @@
 import android.annotation.TargetApi;
 import android.app.Application;
 import android.content.Context;
+import android.content.res.Resources;
 import android.os.Build;
 
 import com.tencent.tinker.loader.shareutil.ShareReflectUtil;
@@ -38,6 +39,8 @@
 class AndroidNClassLoader extends PathClassLoader {
     private static final String TAG = "Tinker.NClassLoader";
 
+    private static Object oldDexPathListHolder = null;
+
     private final PathClassLoader originClassLoader;
     private String applicationClassName;
 
@@ -51,7 +54,11 @@ private AndroidNClassLoader(String dexPath, PathClassLoader parent, Application
     }
 
     @SuppressWarnings("unchecked")
-    private static Object recreateDexPathList(Object originalDexPathList, ClassLoader newDefiningContext) throws Exception {
+    private static Object recreateDexPathList(Object originalDexPathList, ClassLoader newDefiningContext, boolean createEmptyOne) throws Exception {
+        final Constructor<?> dexPathListConstructor = ShareReflectUtil.findConstructor(originalDexPathList, ClassLoader.class, String.class, String.class, File.class);
+        if (createEmptyOne) {
+            return dexPathListConstructor.newInstance(newDefiningContext, "", null, null);
+        }
         final Field dexElementsField = ShareReflectUtil.findField(originalDexPathList, "dexElements");
         final Object[] dexElements = (Object[]) dexElementsField.get(originalDexPathList);
         final Field nativeLibraryDirectoriesField = ShareReflectUtil.findField(originalDexPathList, "nativeLibraryDirectories");
@@ -91,8 +98,6 @@ private static Object recreateDexPathList(Object originalDexPathList, ClassLoade
         }
 
         final String libraryPath = libraryPathBuilder.toString();
-
-        final Constructor<?> dexPathListConstructor = ShareReflectUtil.findConstructor(originalDexPathList, ClassLoader.class, String.class, String.class, File.class);
         return dexPathListConstructor.newInstance(newDefiningContext, dexPath, libraryPath, null);
     }
 
@@ -105,25 +110,40 @@ private static AndroidNClassLoader createAndroidNClassLoader(PathClassLoader ori
         // To avoid 'dex file register with multiple classloader' exception on Android O, we must keep old
         // dexPathList in original classloader so that after the newly loaded base dex was bound to
         // AndroidNClassLoader we can still load class in base dex from original classloader.
-
-        Object newPathList = recreateDexPathList(originPathList, androidNClassLoader);
+        Object newPathList = recreateDexPathList(originPathList, androidNClassLoader, false);
 
         // Update new classloader's pathList.
         pathListField.set(androidNClassLoader, newPathList);
 
+        // Recreate old dexPathList.
+        oldDexPathListHolder = originPathList;
+        Object emptyOldPathList = recreateDexPathList(originPathList, originalClassLoader, true);
+        pathListField.set(originalClassLoader, emptyOldPathList);
+        Object recreatedOldPathList = recreateDexPathList(originPathList, originalClassLoader, false);
+        pathListField.set(originalClassLoader, recreatedOldPathList);
+
         return androidNClassLoader;
     }
 
     private static void reflectPackageInfoClassloader(Application application, ClassLoader reflectClassLoader) throws Exception {
-        String defBase = "mBase";
-        String defPackageInfo = "mPackageInfo";
-        String defClassLoader = "mClassLoader";
+        Context baseContext = (Context) ShareReflectUtil.findField(application, "mBase").get(application);
+        Object basePackageInfo = ShareReflectUtil.findField(baseContext, "mPackageInfo").get(baseContext);
+        ShareReflectUtil.findField(basePackageInfo, "mClassLoader").set(basePackageInfo, reflectClassLoader);
+
+        // There's compatibility risk here when omit these hacking logic.
+        // However I still have no idea about how to solve it without touching the Android P's
+        // dark greylist API.
+        if (Build.VERSION.SDK_INT < 27) {
+            Resources res = application.getResources();
+            ShareReflectUtil.findField(res, "mClassLoader").set(res, reflectClassLoader);
+
+            Object drawableInflater = ShareReflectUtil.findField(res, "mDrawableInflater").get(res);
+            if (drawableInflater != null) {
+                ShareReflectUtil.findField(drawableInflater, "mClassLoader").set(drawableInflater, reflectClassLoader);
+            }
+        }
 
-        Context baseContext = (Context) ShareReflectUtil.findField(application, defBase).get(application);
-        Object basePackageInfo = ShareReflectUtil.findField(baseContext, defPackageInfo).get(baseContext);
-        Field classLoaderField = ShareReflectUtil.findField(basePackageInfo, defClassLoader);
         Thread.currentThread().setContextClassLoader(reflectClassLoader);
-        classLoaderField.set(basePackageInfo, reflectClassLoader);
     }
 
     public static AndroidNClassLoader inject(PathClassLoader originClassLoader, Application application) throws Exception {
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerDexOptimizer.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerDexOptimizer.java
index bd06f78b..5d935d0d 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerDexOptimizer.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerDexOptimizer.java
@@ -35,6 +35,7 @@
 
 import dalvik.system.DexFile;
 
+
 /**
  * Created by tangyinsheng on 2016/11/15.
  */
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java
index 6d640c36..4d263801 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java
@@ -30,7 +30,6 @@
 
 import java.io.InputStream;
 import java.lang.ref.WeakReference;
-import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
 import java.lang.reflect.Method;
 import java.util.Collection;
@@ -39,36 +38,37 @@
 
 import static android.os.Build.VERSION.SDK_INT;
 import static android.os.Build.VERSION_CODES.KITKAT;
+import static com.tencent.tinker.loader.shareutil.ShareReflectUtil.findConstructor;
+import static com.tencent.tinker.loader.shareutil.ShareReflectUtil.findField;
+import static com.tencent.tinker.loader.shareutil.ShareReflectUtil.findMethod;
 
 /**
  * Created by zhangshaowen on 16/9/21.
  * Thanks for Android Fragmentation
  */
 class TinkerResourcePatcher {
-    private static final String TAG               = "Tinker.ResourcePatcher";
+    private static final String TAG = "Tinker.ResourcePatcher";
     private static final String TEST_ASSETS_VALUE = "only_use_to_test_tinker_resource.txt";
-//    private static final String MIUI_RESOURCE_CLASSNAME = "android.content.res.MiuiResources";
 
     // original object
-    private static Collection<WeakReference<Resources>> references            = null;
-    private static Object                               currentActivityThread = null;
-    private static AssetManager                         newAssetManager       = null;
-    //    private static ArrayMap<?, WeakReference<?>>         resourceImpls            = null;
+    private static Collection<WeakReference<Resources>> references = null;
+    private static Object currentActivityThread = null;
+    private static AssetManager newAssetManager = null;
 
     // method
-    private static Method addAssetPathMethod       = null;
+    private static Method addAssetPathMethod = null;
     private static Method ensureStringBlocksMethod = null;
 
     // field
-    private static Field assetsFiled           = null;
-    private static Field resourcesImplFiled    = null;
-    private static Field resDir                = null;
-    private static Field packagesFiled         = null;
+    private static Field assetsFiled = null;
+    private static Field resourcesImplFiled = null;
+    private static Field resDir = null;
+    private static Field packagesFiled = null;
     private static Field resourcePackagesFiled = null;
-    private static Field publicSourceDirField  = null;
-
-//    private static boolean isMiuiSystem = false;
+    private static Field publicSourceDirField = null;
+    private static Field stringBlocksField = null;
 
+    @SuppressWarnings("unchecked")
     public static void isResourceCanPatch(Context context) throws Throwable {
         //   - Replace mResDir to point to the external resource file instead of the .apk. This is
         //     used as the asset path for new Resources objects.
@@ -86,86 +86,73 @@ public static void isResourceCanPatch(Context context) throws Throwable {
             loadedApkClass = Class.forName("android.app.ActivityThread$PackageInfo");
         }
 
-
-        resDir = loadedApkClass.getDeclaredField("mResDir");
-        resDir.setAccessible(true);
-        packagesFiled = activityThread.getDeclaredField("mPackages");
-        packagesFiled.setAccessible(true);
-
-        resourcePackagesFiled = activityThread.getDeclaredField("mResourcePackages");
-        resourcePackagesFiled.setAccessible(true);
-
-        // Create a new AssetManager instance and point it to the resources
-        AssetManager assets = context.getAssets();
-        // Baidu os
-        if (assets.getClass().getName().equals("android.content.res.BaiduAssetManager")) {
-            Class baiduAssetManager = Class.forName("android.content.res.BaiduAssetManager");
-            newAssetManager = (AssetManager) baiduAssetManager.getConstructor().newInstance();
-        } else {
-            newAssetManager = AssetManager.class.getConstructor().newInstance();
+        resDir = findField(loadedApkClass, "mResDir");
+        packagesFiled = findField(activityThread, "mPackages");
+        if (Build.VERSION.SDK_INT < 27) {
+            resourcePackagesFiled = findField(activityThread, "mResourcePackages");
         }
 
-        addAssetPathMethod = AssetManager.class.getDeclaredMethod("addAssetPath", String.class);
-        addAssetPathMethod.setAccessible(true);
+        // Create a new AssetManager instance and point it to the resources
+        final AssetManager assets = context.getAssets();
+        addAssetPathMethod = findMethod(assets, "addAssetPath", String.class);
 
         // Kitkat needs this method call, Lollipop doesn't. However, it doesn't seem to cause any harm
         // in L, so we do it unconditionally.
-        ensureStringBlocksMethod = AssetManager.class.getDeclaredMethod("ensureStringBlocks");
-        ensureStringBlocksMethod.setAccessible(true);
+        stringBlocksField = findField(assets, "mStringBlocks");
+        ensureStringBlocksMethod = findMethod(assets, "ensureStringBlocks");
+
+        // Use class fetched from instance to avoid some ROMs that use customized AssetManager
+        // class. (e.g. Baidu OS)
+        newAssetManager = (AssetManager) findConstructor(assets).newInstance();
 
         // Iterate over all known Resources objects
         if (SDK_INT >= KITKAT) {
             //pre-N
             // Find the singleton instance of ResourcesManager
-            Class<?> resourcesManagerClass = Class.forName("android.app.ResourcesManager");
-            Method mGetInstance = resourcesManagerClass.getDeclaredMethod("getInstance");
-            mGetInstance.setAccessible(true);
-            Object resourcesManager = mGetInstance.invoke(null);
+            final Class<?> resourcesManagerClass = Class.forName("android.app.ResourcesManager");
+            final Method mGetInstance = findMethod(resourcesManagerClass, "getInstance");
+            final Object resourcesManager = mGetInstance.invoke(null);
             try {
-                Field fMActiveResources = resourcesManagerClass.getDeclaredField("mActiveResources");
-                fMActiveResources.setAccessible(true);
-                ArrayMap<?, WeakReference<Resources>> activeResources19 =
-                    (ArrayMap<?, WeakReference<Resources>>) fMActiveResources.get(resourcesManager);
+                Field fMActiveResources = findField(resourcesManagerClass, "mActiveResources");
+                final ArrayMap<?, WeakReference<Resources>> activeResources19 =
+                        (ArrayMap<?, WeakReference<Resources>>) fMActiveResources.get(resourcesManager);
                 references = activeResources19.values();
             } catch (NoSuchFieldException ignore) {
                 // N moved the resources to mResourceReferences
-                Field mResourceReferences = resourcesManagerClass.getDeclaredField("mResourceReferences");
-                mResourceReferences.setAccessible(true);
+                final Field mResourceReferences = findField(resourcesManagerClass, "mResourceReferences");
                 references = (Collection<WeakReference<Resources>>) mResourceReferences.get(resourcesManager);
             }
         } else {
-            Field fMActiveResources = activityThread.getDeclaredField("mActiveResources");
-            fMActiveResources.setAccessible(true);
-            HashMap<?, WeakReference<Resources>> activeResources7 =
-                (HashMap<?, WeakReference<Resources>>) fMActiveResources.get(currentActivityThread);
+            final Field fMActiveResources = findField(activityThread, "mActiveResources");
+            final HashMap<?, WeakReference<Resources>> activeResources7 =
+                    (HashMap<?, WeakReference<Resources>>) fMActiveResources.get(currentActivityThread);
             references = activeResources7.values();
         }
         // check resource
         if (references == null) {
             throw new IllegalStateException("resource references is null");
         }
+
+        final Resources resources = context.getResources();
+
         // fix jianGuo pro has private field 'mAssets' with Resource
         // try use mResourcesImpl first
         if (SDK_INT >= 24) {
             try {
                 // N moved the mAssets inside an mResourcesImpl field
-                resourcesImplFiled = Resources.class.getDeclaredField("mResourcesImpl");
-                resourcesImplFiled.setAccessible(true);
+                resourcesImplFiled = findField(resources, "mResourcesImpl");
             } catch (Throwable ignore) {
                 // for safety
-                assetsFiled = Resources.class.getDeclaredField("mAssets");
-                assetsFiled.setAccessible(true);
+                assetsFiled = findField(resources, "mAssets");
             }
         } else {
-            assetsFiled = Resources.class.getDeclaredField("mAssets");
-            assetsFiled.setAccessible(true);
+            assetsFiled = findField(resources, "mAssets");
         }
-//        final Resources resources = context.getResources();
-//        isMiuiSystem = resources != null && MIUI_RESOURCE_CLASSNAME.equals(resources.getClass().getName());
 
         try {
-            publicSourceDirField = ShareReflectUtil.findField(ApplicationInfo.class, "publicSourceDir");
+            publicSourceDirField = findField(ApplicationInfo.class, "publicSourceDir");
         } catch (NoSuchFieldException ignore) {
+            // Ignored.
         }
     }
 
@@ -179,20 +166,30 @@ public static void monkeyPatchExistingResources(Context context, String external
             return;
         }
 
-        for (Field field : new Field[]{packagesFiled, resourcePackagesFiled}) {
-            Object value = field.get(currentActivityThread);
+        final ApplicationInfo appInfo = context.getApplicationInfo();
+
+        final Field[] packagesFields;
+        if (Build.VERSION.SDK_INT < 27) {
+            packagesFields = new Field[]{packagesFiled, resourcePackagesFiled};
+        } else {
+            packagesFields = new Field[]{packagesFiled};
+        }
+        for (Field field : packagesFields) {
+            final Object value = field.get(currentActivityThread);
 
             for (Map.Entry<String, WeakReference<?>> entry
-                : ((Map<String, WeakReference<?>>) value).entrySet()) {
-                Object loadedApk = entry.getValue().get();
+                    : ((Map<String, WeakReference<?>>) value).entrySet()) {
+                final Object loadedApk = entry.getValue().get();
                 if (loadedApk == null) {
                     continue;
                 }
-                if (externalResourceFile != null) {
+                final String resDirPath = (String) resDir.get(loadedApk);
+                if (appInfo.sourceDir.equals(resDirPath)) {
                     resDir.set(loadedApk, externalResourceFile);
                 }
             }
         }
+
         // Create a new AssetManager instance and point it to the resources installed under
         if (((Integer) addAssetPathMethod.invoke(newAssetManager, externalResourceFile)) == 0) {
             throw new IllegalStateException("Could not create new AssetManager");
@@ -200,28 +197,29 @@ public static void monkeyPatchExistingResources(Context context, String external
 
         // Kitkat needs this method call, Lollipop doesn't. However, it doesn't seem to cause any harm
         // in L, so we do it unconditionally.
+        stringBlocksField.set(newAssetManager, null);
         ensureStringBlocksMethod.invoke(newAssetManager);
 
         for (WeakReference<Resources> wr : references) {
-            Resources resources = wr.get();
-            //pre-N
-            if (resources != null) {
-                // Set the AssetManager of the Resources instance to our brand new one
-                try {
-                    assetsFiled.set(resources, newAssetManager);
-                } catch (Throwable ignore) {
-                    // N
-                    Object resourceImpl = resourcesImplFiled.get(resources);
-                    // for Huawei HwResourcesImpl
-                    Field implAssets = ShareReflectUtil.findField(resourceImpl, "mAssets");
-                    implAssets.setAccessible(true);
-                    implAssets.set(resourceImpl, newAssetManager);
-                }
+            final Resources resources = wr.get();
+            if (resources == null) {
+                continue;
+            }
+            // Set the AssetManager of the Resources instance to our brand new one
+            try {
+                //pre-N
+                assetsFiled.set(resources, newAssetManager);
+            } catch (Throwable ignore) {
+                // N
+                final Object resourceImpl = resourcesImplFiled.get(resources);
+                // for Huawei HwResourcesImpl
+                final Field implAssets = findField(resourceImpl, "mAssets");
+                implAssets.set(resourceImpl, newAssetManager);
+            }
 
-                clearPreloadTypedArrayIssue(resources);
+            clearPreloadTypedArrayIssue(resources);
 
-                resources.updateConfiguration(resources.getConfiguration(), resources.getDisplayMetrics());
-            }
+            resources.updateConfiguration(resources.getConfiguration(), resources.getDisplayMetrics());
         }
 
         // Handle issues caused by WebView on Android N.
@@ -250,23 +248,20 @@ public static void monkeyPatchExistingResources(Context context, String external
     private static void clearPreloadTypedArrayIssue(Resources resources) {
         // Perform this trick not only in Miui system since we can't predict if any other
         // manufacturer would do the same modification to Android.
-//        if (!isMiuiSystem) {
-//            return;
-//        }
+        // if (!isMiuiSystem) {
+        //     return;
+        // }
         Log.w(TAG, "try to clear typedArray cache!");
         // Clear typedArray cache.
         try {
-            Field typedArrayPoolField = ShareReflectUtil.findField(Resources.class, "mTypedArrayPool");
-
+            final Field typedArrayPoolField = findField(Resources.class, "mTypedArrayPool");
             final Object origTypedArrayPool = typedArrayPoolField.get(resources);
-
-            Field poolField = ShareReflectUtil.findField(origTypedArrayPool, "mPool");
-
-            final Constructor<?> typedArrayConstructor = origTypedArrayPool.getClass().getConstructor(int.class);
-            typedArrayConstructor.setAccessible(true);
-            final int poolSize = ((Object[]) poolField.get(origTypedArrayPool)).length;
-            final Object newTypedArrayPool = typedArrayConstructor.newInstance(poolSize);
-            typedArrayPoolField.set(resources, newTypedArrayPool);
+            final Method acquireMethod = findMethod(origTypedArrayPool, "acquire");
+            while (true) {
+                if (acquireMethod.invoke(origTypedArrayPool) == null) {
+                    break;
+                }
+            }
         } catch (Throwable ignored) {
             Log.e(TAG, "clearPreloadTypedArrayIssue failed, ignore error: " + ignored);
         }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/hotplug/ComponentHotplug.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/hotplug/ComponentHotplug.java
index e98b2d37..95d1a805 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/hotplug/ComponentHotplug.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/hotplug/ComponentHotplug.java
@@ -1,6 +1,7 @@
 package com.tencent.tinker.loader.hotplug;
 
 import android.content.Context;
+import android.os.Build;
 import android.os.Handler;
 import android.util.Log;
 
@@ -10,6 +11,7 @@
 import com.tencent.tinker.loader.hotplug.handler.PMSInterceptHandler;
 import com.tencent.tinker.loader.hotplug.interceptor.HandlerMessageInterceptor;
 import com.tencent.tinker.loader.hotplug.interceptor.ServiceBinderInterceptor;
+import com.tencent.tinker.loader.hotplug.interceptor.TinkerHackInstrumentation;
 import com.tencent.tinker.loader.shareutil.ShareReflectUtil;
 import com.tencent.tinker.loader.shareutil.ShareSecurityCheck;
 
@@ -26,6 +28,7 @@
     private static ServiceBinderInterceptor sAMSInterceptor;
     private static ServiceBinderInterceptor sPMSInterceptor;
     private static HandlerMessageInterceptor sMHMessageInterceptor;
+    private static TinkerHackInstrumentation sTinkerHackInstrumentation;
 
     public synchronized static void install(TinkerApplication app, ShareSecurityCheck checker) throws UnsupportedEnvironmentException {
         if (!sInstalled) {
@@ -33,13 +36,17 @@ public synchronized static void install(TinkerApplication app, ShareSecurityChec
                 if (IncrementComponentManager.init(app, checker)) {
                     sAMSInterceptor = new ServiceBinderInterceptor(app, EnvConsts.ACTIVITY_MANAGER_SRVNAME, new AMSInterceptHandler(app));
                     sPMSInterceptor = new ServiceBinderInterceptor(app, EnvConsts.PACKAGE_MANAGER_SRVNAME, new PMSInterceptHandler());
-
-                    final Handler mH = fetchMHInstance(app);
-                    sMHMessageInterceptor = new HandlerMessageInterceptor(mH, new MHMessageHandler(app));
-
                     sAMSInterceptor.install();
                     sPMSInterceptor.install();
-                    sMHMessageInterceptor.install();
+
+                    if (Build.VERSION.SDK_INT < 27) {
+                        final Handler mH = fetchMHInstance(app);
+                        sMHMessageInterceptor = new HandlerMessageInterceptor(mH, new MHMessageHandler(app));
+                        sMHMessageInterceptor.install();
+                    } else {
+                        sTinkerHackInstrumentation = TinkerHackInstrumentation.create(app);
+                        sTinkerHackInstrumentation.install();
+                    }
 
                     sInstalled = true;
 
@@ -59,7 +66,11 @@ public synchronized static void ensureComponentHotplugInstalled(TinkerApplicatio
             try {
                 sAMSInterceptor.install();
                 sPMSInterceptor.install();
-                sMHMessageInterceptor.install();
+                if (Build.VERSION.SDK_INT < 27) {
+                    sMHMessageInterceptor.install();
+                } else {
+                    sTinkerHackInstrumentation.install();
+                }
             } catch (Throwable thr) {
                 uninstall();
                 throw new UnsupportedEnvironmentException(thr);
@@ -88,7 +99,11 @@ public synchronized static void uninstall()  {
             try {
                 sAMSInterceptor.uninstall();
                 sPMSInterceptor.uninstall();
-                sMHMessageInterceptor.uninstall();
+                if (Build.VERSION.SDK_INT < 27) {
+                    sMHMessageInterceptor.uninstall();
+                } else {
+                    sTinkerHackInstrumentation.uninstall();
+                }
             } catch (Throwable thr) {
                 Log.e(TAG, "exception when uninstall.", thr);
             }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/hotplug/handler/AMSInterceptHandler.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/hotplug/handler/AMSInterceptHandler.java
index 8dc7faf9..b9d91fb5 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/hotplug/handler/AMSInterceptHandler.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/hotplug/handler/AMSInterceptHandler.java
@@ -9,6 +9,7 @@
 import android.content.pm.ResolveInfo;
 import android.content.res.Resources;
 import android.content.res.TypedArray;
+import android.os.Build;
 
 import com.tencent.tinker.loader.hotplug.ActivityStubManager;
 import com.tencent.tinker.loader.hotplug.EnvConsts;
@@ -30,12 +31,15 @@
     private static final int INTENT_SENDER_ACTIVITY;
 
     static {
-        int val = 0;
-        try {
-            val = (int) ShareReflectUtil.findField(ActivityManager.class, "INTENT_SENDER_ACTIVITY").get(null);
-        } catch (Throwable thr) {
-            thr.printStackTrace();
-            val = 2;
+        // Hardcoded Value.
+        int val = 2;
+        if (Build.VERSION.SDK_INT < 27) {
+            try {
+                val = (int) ShareReflectUtil.findField(ActivityManager.class, "INTENT_SENDER_ACTIVITY").get(null);
+            } catch (Throwable thr) {
+                thr.printStackTrace();
+                val = 2;
+            }
         }
         INTENT_SENDER_ACTIVITY = val;
     }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/hotplug/handler/MHMessageHandler.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/hotplug/handler/MHMessageHandler.java
index 3959b408..e798c0cc 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/hotplug/handler/MHMessageHandler.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/hotplug/handler/MHMessageHandler.java
@@ -5,6 +5,7 @@
 import android.content.ContextWrapper;
 import android.content.Intent;
 import android.content.pm.ActivityInfo;
+import android.os.Build;
 import android.os.IBinder;
 import android.os.Message;
 import android.util.Log;
@@ -30,13 +31,16 @@
     private static final int LAUNCH_ACTIVITY;
 
     static {
-        int launchActivity = 0;
-        try {
-            final Class<?> hClazz = Class.forName("android.app.ActivityThread$H");
-            launchActivity = ShareReflectUtil.findField(hClazz, "LAUNCH_ACTIVITY").getInt(null);
-        } catch (Throwable thr) {
-            // Fallback to default value.
-            launchActivity = 100;
+        // Hardcoded Value.
+        int launchActivity = 100;
+        if (Build.VERSION.SDK_INT < 27) {
+            try {
+                final Class<?> hClazz = Class.forName("android.app.ActivityThread$H");
+                launchActivity = ShareReflectUtil.findField(hClazz, "LAUNCH_ACTIVITY").getInt(null);
+            } catch (Throwable thr) {
+                // Fallback to default value.
+                launchActivity = 100;
+            }
         }
         LAUNCH_ACTIVITY = launchActivity;
     }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/hotplug/interceptor/TinkerHackInstrumentation.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/hotplug/interceptor/TinkerHackInstrumentation.java
new file mode 100644
index 00000000..acf22e2e
--- /dev/null
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/hotplug/interceptor/TinkerHackInstrumentation.java
@@ -0,0 +1,156 @@
+package com.tencent.tinker.loader.hotplug.interceptor;
+
+import android.app.Activity;
+import android.app.Application;
+import android.app.Instrumentation;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.ActivityInfo;
+import android.os.Bundle;
+import android.os.IBinder;
+import android.os.PersistableBundle;
+import android.util.Log;
+
+import com.tencent.tinker.loader.TinkerRuntimeException;
+import com.tencent.tinker.loader.hotplug.EnvConsts;
+import com.tencent.tinker.loader.hotplug.IncrementComponentManager;
+import com.tencent.tinker.loader.shareutil.ShareIntentUtil;
+import com.tencent.tinker.loader.shareutil.ShareReflectUtil;
+
+import java.lang.reflect.Field;
+
+/**
+ * Created by tangyinsheng on 2018/3/9.
+ */
+public class TinkerHackInstrumentation extends Instrumentation {
+    private static final String TAG = "Tinker.Instrumentation";
+
+    private final Instrumentation mOriginal;
+    private final Object mActivityThread;
+    private final Field mInstrumentationField;
+
+    public static TinkerHackInstrumentation create(Context context) {
+        try {
+            final Object activityThread = ShareReflectUtil.getActivityThread(context, null);
+            final Field mInstrumentationField = ShareReflectUtil.findField(activityThread, "mInstrumentation");
+            final Instrumentation original = (Instrumentation) mInstrumentationField.get(activityThread);
+            if (original instanceof TinkerHackInstrumentation) {
+                return (TinkerHackInstrumentation) original;
+            }
+            return new TinkerHackInstrumentation(original, activityThread, mInstrumentationField);
+        } catch (Throwable thr) {
+            throw new TinkerRuntimeException("see next stacktrace", thr);
+        }
+    }
+
+    public void install() throws IllegalAccessException {
+        if (mInstrumentationField.get(mActivityThread) instanceof TinkerHackInstrumentation) {
+            Log.w(TAG, "already installed, skip rest logic.");
+        } else {
+            mInstrumentationField.set(mActivityThread, this);
+        }
+    }
+
+    public void uninstall() throws IllegalAccessException {
+        mInstrumentationField.set(mActivityThread, mOriginal);
+    }
+
+    private TinkerHackInstrumentation(Instrumentation original, Object activityThread, Field instrumentationField) throws TinkerRuntimeException {
+        mOriginal = original;
+        mActivityThread = activityThread;
+        mInstrumentationField = instrumentationField;
+        try {
+            copyAllFields(original);
+        } catch (Throwable thr) {
+            throw new TinkerRuntimeException(thr.getMessage(), thr);
+        }
+    }
+
+    @Override
+    public Activity newActivity(Class<?> clazz, Context context, IBinder token, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, Object lastNonConfigurationInstance) throws InstantiationException, IllegalAccessException {
+        processIntent(context.getClassLoader(), intent);
+        return super.newActivity(clazz, context, token, application, intent, info, title, parent, id, lastNonConfigurationInstance);
+    }
+
+    @Override
+    public Activity newActivity(ClassLoader cl, String className, Intent intent) throws InstantiationException, IllegalAccessException, ClassNotFoundException {
+        if (processIntent(cl, intent)) {
+            return super.newActivity(cl, intent.getComponent().getClassName(), intent);
+        } else {
+            return super.newActivity(cl, className, intent);
+        }
+    }
+
+    @Override
+    public void callActivityOnCreate(Activity activity, Bundle icicle) {
+        if (activity != null) {
+            final ActivityInfo targetAInfo = IncrementComponentManager.queryActivityInfo(activity.getClass().getName());
+            if (targetAInfo != null) {
+                fixActivityParams(activity, targetAInfo);
+            }
+        }
+        super.callActivityOnCreate(activity, icicle);
+    }
+
+    @Override
+    public void callActivityOnCreate(Activity activity, Bundle icicle, PersistableBundle persistentState) {
+        if (activity != null) {
+            final ActivityInfo targetAInfo = IncrementComponentManager.queryActivityInfo(activity.getClass().getName());
+            if (targetAInfo != null) {
+                fixActivityParams(activity, targetAInfo);
+            }
+        }
+        super.callActivityOnCreate(activity, icicle, persistentState);
+    }
+
+    @Override
+    public void callActivityOnNewIntent(Activity activity, Intent intent) {
+        if (activity != null) {
+            processIntent(activity.getClass().getClassLoader(), intent);
+        }
+        super.callActivityOnNewIntent(activity, intent);
+    }
+
+    private boolean processIntent(ClassLoader cl, Intent intent) {
+        if (intent == null) {
+            return false;
+        }
+        ShareIntentUtil.fixIntentClassLoader(intent, cl);
+        final ComponentName oldComponent = intent.getParcelableExtra(EnvConsts.INTENT_EXTRA_OLD_COMPONENT);
+        if (oldComponent == null) {
+            Log.w(TAG, "oldComponent was null, start " + intent.getComponent() + " next.");
+            return false;
+        }
+        final String oldComponentName = oldComponent.getClassName();
+        final ActivityInfo targetAInfo = IncrementComponentManager.queryActivityInfo(oldComponentName);
+        if (targetAInfo == null) {
+            Log.e(TAG, "Failed to query target activity's info,"
+                    + " perhaps the target is not hotpluged component. Target: " + oldComponentName);
+            return false;
+        }
+        intent.setComponent(oldComponent);
+        intent.removeExtra(EnvConsts.INTENT_EXTRA_OLD_COMPONENT);
+        return true;
+    }
+
+    private void fixActivityParams(Activity target, ActivityInfo targetAInfo) {
+        target.setRequestedOrientation(targetAInfo.screenOrientation);
+        target.setTheme(targetAInfo.theme);
+        try {
+            final Field aInfoField = ShareReflectUtil.findField(target, "mActivityInfo");
+            aInfoField.set(target, targetAInfo);
+        } catch (Throwable thr) {
+            throw new TinkerRuntimeException("see next stacktrace.", thr);
+        }
+    }
+
+    private void copyAllFields(Instrumentation src) throws IllegalAccessException {
+        final Field[] fields = Instrumentation.class.getDeclaredFields();
+        for (int i = 0; i < fields.length; ++i) {
+            fields[i].setAccessible(true);
+            final Object value = fields[i].get(src);
+            fields[i].set(this, value);
+        }
+    }
+}
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareDexDiffPatchInfo.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareDexDiffPatchInfo.java
index 80b1d88f..221657a4 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareDexDiffPatchInfo.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareDexDiffPatchInfo.java
@@ -28,7 +28,7 @@
     public final String destMd5InDvm;
     public final String destMd5InArt;
     public final String oldDexCrC;
-    public final String newDexCrC;
+    public final String newOrPatchedDexCrC;
 
     public final String dexDiffMd5;
 
@@ -45,7 +45,7 @@
 
 
     public ShareDexDiffPatchInfo(String name, String path, String destMd5InDvm, String destMd5InArt,
-                                 String dexDiffMd5, String oldDexCrc, String newDexCrC, String dexMode) {
+                                 String dexDiffMd5, String oldDexCrc, String newOrPatchedDexCrC, String dexMode) {
         // TODO Auto-generated constructor stub
         this.rawName = name;
         this.path = path;
@@ -53,7 +53,7 @@ public ShareDexDiffPatchInfo(String name, String path, String destMd5InDvm, Stri
         this.destMd5InArt = destMd5InArt;
         this.dexDiffMd5 = dexDiffMd5;
         this.oldDexCrC = oldDexCrc;
-        this.newDexCrC = newDexCrC;
+        this.newOrPatchedDexCrC = newOrPatchedDexCrC;
         this.dexMode = dexMode;
         if (dexMode.equals(ShareConstants.DEXMODE_JAR)) {
             this.isJarMode = true;
@@ -127,7 +127,7 @@ public String toString() {
         sb.append(",");
         sb.append(oldDexCrC);
         sb.append(",");
-        sb.append(newDexCrC);
+        sb.append(newOrPatchedDexCrC);
         sb.append(",");
         sb.append(dexDiffMd5);
         sb.append(",");
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareIntentUtil.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareIntentUtil.java
index 5fe80960..fcb3bb56 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareIntentUtil.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareIntentUtil.java
@@ -17,11 +17,9 @@
 package com.tencent.tinker.loader.shareutil;
 
 import android.content.Intent;
-import android.os.Bundle;
 import android.util.Log;
 
 import java.io.Serializable;
-import java.lang.reflect.Field;
 import java.util.ArrayList;
 import java.util.HashMap;
 
@@ -195,16 +193,9 @@ public static long getLongExtra(Intent intent, String name, long defaultValue) {
 
     public static void fixIntentClassLoader(Intent intent, ClassLoader cl) {
         try {
-            final Field mExtrasField = ShareReflectUtil.findField(Intent.class, "mExtras");
-            Bundle extra = (Bundle) mExtrasField.get(intent);
-            if (extra == null) {
-                extra = new Bundle();
-                mExtrasField.set(intent, extra);
-            }
+            intent.setExtrasClassLoader(cl);
         } catch (Throwable thr) {
             thr.printStackTrace();
-        } finally {
-            intent.setExtrasClassLoader(cl);
         }
     }
 }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchFileUtil.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchFileUtil.java
index c6ecb5e7..535f021d 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchFileUtil.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchFileUtil.java
@@ -275,7 +275,7 @@ public static boolean verifyDexFileMd5(File file, String entryName, String md5)
             return false;
         }
         //if it is not the raw dex, we check the stream instead
-        String fileMd5;
+        String fileMd5 = "";
 
         if (isRawDexFile(file.getName())) {
             fileMd5 = getMD5(file);
@@ -298,7 +298,6 @@ public static boolean verifyDexFileMd5(File file, String entryName, String md5)
                 } finally {
                     closeQuietly(is);
                 }
-                fileMd5 = getMD5(dexJar.getInputStream(classesDex));
             } catch (Throwable e) {
                 Log.e(TAG, "Bad dex jar file: " + file.getAbsolutePath(), e);
                 return false;
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java
index 2316a727..2c14b29c 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java
@@ -108,7 +108,7 @@ public static ShareDexDiffPatchInfo changeTestDexToClassN(ShareDexDiffPatchInfo
                 newName = "classes.dex";
             }
             return new ShareDexDiffPatchInfo(newName, rawDexInfo.path, rawDexInfo.destMd5InDvm, rawDexInfo.destMd5InArt,
-                rawDexInfo.dexDiffMd5, rawDexInfo.oldDexCrC, rawDexInfo.newDexCrC, rawDexInfo.dexMode);
+                rawDexInfo.dexDiffMd5, rawDexInfo.oldDexCrC, rawDexInfo.newOrPatchedDexCrC, rawDexInfo.dexMode);
         }
 
         return null;
diff --git a/tinker-build/tinker-patch-cli/tool_output/tinker_config.xml b/tinker-build/tinker-patch-cli/tool_output/tinker_config.xml
index 41d46696..f2220cbd 100644
--- a/tinker-build/tinker-patch-cli/tool_output/tinker_config.xml
+++ b/tinker-build/tinker-patch-cli/tool_output/tinker_config.xml
@@ -83,6 +83,8 @@
         <!--it support * or ? pattern.-->
         <!--Such as I want assets/meta.txt use the base.apk version whatever it is change ir not.-->
         <ignoreChange value="assets/sample_meta.txt"/>
+        <!--ignore any warning caused by add, delete or modify changes on resources specified by this pattern.-->
+        <ignoreChangeWarning value="" />
         <!--default 100kb-->
         <!--for modify resource, if it is larger than 'largeModSize'-->
         <!--we would like to use bsdiff algorithm to reduce patch file size-->
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerResourceExtension.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerResourceExtension.groovy
index bdff32c6..b01b2544 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerResourceExtension.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerResourceExtension.groovy
@@ -36,6 +36,12 @@ public class TinkerResourceExtension {
      */
     Iterable<String> ignoreChange
 
+    /**
+     * the resource file ignoreChangeWarning patterns, ignore any warning caused by add, delete or
+     * modify resource change.
+     */
+    Iterable<String> ignoreChangeWarning
+
     /**
      * default 100kb
      * for modify resource, if it is larger than 'largeModSize'
@@ -46,6 +52,7 @@ public class TinkerResourceExtension {
     public TinkerResourceExtension() {
         pattern = []
         ignoreChange = []
+        ignoreChangeWarning = []
         largeModSize = 100
     }
     void checkParameter() {
@@ -58,6 +65,7 @@ public class TinkerResourceExtension {
     public String toString() {
         """| pattern = ${pattern}
            | exclude = ${ignoreChange}
+           | ignoreWarning = ${ignoreChangeWarning}
            | largeModSize = ${largeModSize}kb
         """.stripMargin()
     }
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerPatchSchemaTask.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerPatchSchemaTask.groovy
index 6a674fda..584dd4b2 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerPatchSchemaTask.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerPatchSchemaTask.groovy
@@ -75,6 +75,7 @@ public class TinkerPatchSchemaTask extends DefaultTask {
                .setSoFilePattern(new ArrayList<String>(configuration.lib.pattern))
                .setResourceFilePattern(new ArrayList<String>(configuration.res.pattern))
                .setResourceIgnoreChangePattern(new ArrayList<String>(configuration.res.ignoreChange))
+               .setResourceIgnoreChangeWarningPattern(new ArrayList<String>(configuration.res.ignoreChangeWarning))
                .setResourceLargeModSize(configuration.res.largeModSize)
                .setUseApplyResource(configuration.buildConfig.usingResourceMapping)
                .setConfigFields(new HashMap<String, String>(configuration.packageConfig.getFields()))
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptUtil.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptUtil.java
index 4ee01229..56675bcb 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptUtil.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptUtil.java
@@ -51,7 +51,7 @@
 
     private static final XPathExpression ANDROID_ID_USAGE = createExpression("//@*[starts-with(., '@') and " + "not(starts-with(., '@+')) and " + "not(starts-with(., '@android:')) and " + "not(starts-with(., '@null'))]");
 
-    private static final XPathExpression ANDROID_ID_DEFINITION = createExpression("//@*[starts-with(., '@+') and " + "not(starts-with(., '@+android:id'))]");
+    private static final XPathExpression ANDROID_ID_DEFINITION = createExpression("//@*[starts-with(., '@+') and " + "not(starts-with(., '@+android:id')) and " + "not(starts-with(., '@+id/android:'))]");
 
     private static final Map<String, RType> RESOURCE_TYPES = getResourceTypes();
     private static final List<String>       IGNORED_TAGS   = Arrays.asList("eat-comment", "skip");
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java
index 8c78db62..712876d6 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java
@@ -362,7 +362,7 @@ private void logDexesToDexMeta() throws IOException {
             final String dexName = getRelativeDexName(oldDexFile, newDexFile);
             final RelatedInfo relatedInfo = dexNameToRelatedInfoMap.get(dexName);
             if (!relatedInfo.oldMd5.equals(relatedInfo.newMd5)) {
-                logToDexMeta(newDexFile, oldDexFile, relatedInfo.dexDiffFile, relatedInfo.newOrFullPatchedMd5, relatedInfo.newOrFullPatchedMd5, relatedInfo.dexDiffMd5);
+                logToDexMeta(newDexFile, oldDexFile, relatedInfo.dexDiffFile, relatedInfo.newOrFullPatchedMd5, relatedInfo.newOrFullPatchedMd5, relatedInfo.dexDiffMd5, relatedInfo.newOrFullPatchedCRC);
             } else {
                 // For class N dexes, if new dex is the same as old dex, we should log it as 'copy directly'
                 // in dex meta to fix problems in Art environment.
@@ -372,9 +372,9 @@ private void logDexesToDexMeta() throws IOException {
                     if (dexName.equals(DexFormat.DEX_IN_JAR_NAME)) {
                         Logger.d("\nDo additional diff on main dex to remove loader classes in it.");
                         diffDexPairAndFillRelatedInfo(oldDexFile, newDexFile, relatedInfo);
-                        logToDexMeta(newDexFile, oldDexFile, relatedInfo.dexDiffFile, relatedInfo.newOrFullPatchedMd5, relatedInfo.newOrFullPatchedMd5, relatedInfo.dexDiffMd5);
+                        logToDexMeta(newDexFile, oldDexFile, relatedInfo.dexDiffFile, relatedInfo.newOrFullPatchedMd5, relatedInfo.newOrFullPatchedMd5, relatedInfo.dexDiffMd5, relatedInfo.newOrFullPatchedCRC);
                     } else {
-                        logToDexMeta(newDexFile, oldDexFile, null, "0", relatedInfo.oldMd5, "0");
+                        logToDexMeta(newDexFile, oldDexFile, null, "0", relatedInfo.oldMd5, "0", relatedInfo.newOrFullPatchedCRC);
                     }
                 }
             }
@@ -382,7 +382,7 @@ private void logDexesToDexMeta() throws IOException {
     }
 
     @SuppressWarnings("NewApi")
-    private void generatePatchedDexInfoFile() {
+    private void generatePatchedDexInfoFile() throws IOException {
         // Generate dex diff out and full patched dex if a pair of dex is different.
         for (AbstractMap.SimpleEntry<File, File> oldAndNewDexFilePair : oldAndNewDexFilePairList) {
             File oldFile = oldAndNewDexFilePair.getKey();
@@ -397,6 +397,7 @@ private void generatePatchedDexInfoFile() {
                 // can analyze which class of this dex should be kept in small patch.
                 relatedInfo.newOrFullPatchedFile = newFile;
                 relatedInfo.newOrFullPatchedMd5 = relatedInfo.newMd5;
+                relatedInfo.newOrFullPatchedCRC = FileOperation.getFileCrc32(newFile);
             }
         }
     }
@@ -451,6 +452,7 @@ private void diffDexPairAndFillRelatedInfo(File oldDexFile, File newDexFile, Rel
 
             relatedInfo.newOrFullPatchedFile = tempFullPatchedDexFile;
             relatedInfo.newOrFullPatchedMd5 = MD5.getMD5(tempFullPatchedDexFile);
+            relatedInfo.newOrFullPatchedCRC = FileOperation.getFileCrc32(tempFullPatchedDexFile);
         } catch (Exception e) {
             e.printStackTrace();
             throw new TinkerPatchException(
@@ -576,7 +578,8 @@ private boolean isDexNameMatchesClassNPattern(String dexName) {
 
     private void copyNewDexAndLogToDexMeta(File newFile, String newMd5, File output) throws IOException {
         FileOperation.copyFileUsingStream(newFile, output);
-        logToDexMeta(newFile, null, null, newMd5, newMd5, "0");
+        final long newFileCrc = FileOperation.getFileCrc32(newFile);
+        logToDexMeta(newFile, null, null, newMd5, newMd5, "0", newFileCrc);
     }
 
     private void checkDexChange(Dex originDex, Dex newDex) {
@@ -622,8 +625,8 @@ private void checkDexChange(Dex originDex, Dex newDex) {
     /**
      * Construct dex meta-info and write it to meta file and log.
      *
-     * @param newOrFullPatchedFile
-     * New dex file or full patched dex file.
+     * @param newFile
+     * New dex file.
      * @param oldFile
      * Old dex file.
      * @param dexDiffFile
@@ -634,18 +637,20 @@ private void checkDexChange(Dex originDex, Dex newDex) {
      * Md5 of output dex in dvm environment, could be small patched dex md5 or new dex.
      * @param dexDiffMd5
      * Md5 of dex patch info file.
+     * @param newOrFullPatchedCrc
+     * CRC32 of new dex or full patched dex.
      *
      * @throws IOException
      */
-    protected void logToDexMeta(File newOrFullPatchedFile, File oldFile, File dexDiffFile, String destMd5InDvm, String destMd5InArt, String dexDiffMd5) throws IOException {
+    protected void logToDexMeta(File newFile, File oldFile, File dexDiffFile, String destMd5InDvm, String destMd5InArt, String dexDiffMd5, long newOrFullPatchedCrc) {
         if (metaWriter == null && logWriter == null) {
             return;
         }
-        String parentRelative = getParentRelativePathStringToNewFile(newOrFullPatchedFile);
-        String relative = getRelativePathStringToNewFile(newOrFullPatchedFile);
+        String parentRelative = getParentRelativePathStringToNewFile(newFile);
+        String relative = getRelativePathStringToNewFile(newFile);
 
         if (metaWriter != null) {
-            String fileName = newOrFullPatchedFile.getName();
+            String fileName = newFile.getName();
             String dexMode = "jar";
             if (config.mDexRaw) {
                 dexMode = "raw";
@@ -665,9 +670,8 @@ protected void logToDexMeta(File newOrFullPatchedFile, File oldFile, File dexDif
                 }
             }
 
-            String newCrc = FileOperation.getZipEntryCrc(config.mNewApkFile, relative);
             String meta = fileName + "," + parentRelative + "," + destMd5InDvm + ","
-                + destMd5InArt + "," + dexDiffMd5 + "," + oldCrc + "," + newCrc + "," + dexMode;
+                + destMd5InArt + "," + dexDiffMd5 + "," + oldCrc + "," + newOrFullPatchedCrc + "," + dexMode;
 
             Logger.d("DexDecoder:write meta file data: %s", meta);
             metaWriter.writeLineToInfoFile(meta);
@@ -675,7 +679,7 @@ protected void logToDexMeta(File newOrFullPatchedFile, File oldFile, File dexDif
 
         if (logWriter != null) {
             String log = relative + ", oldSize=" + FileOperation.getFileSizes(oldFile) + ", newSize="
-                + FileOperation.getFileSizes(newOrFullPatchedFile) + ", diffSize=" + FileOperation.getFileSizes(dexDiffFile);
+                + FileOperation.getFileSizes(newFile) + ", diffSize=" + FileOperation.getFileSizes(dexDiffFile);
 
             logWriter.writeLineToInfoFile(log);
         }
@@ -748,9 +752,16 @@ private void ensureDirectoryExist(File dir) {
         /**
          * This field could be one of the following value:
          *  fullPatchedDex md5, if old dex and new dex are different;
-         *  newDex md5, if new dex is marked to be copied directly;
+         *  newDex md5, if new dex is marked to be copied directly.
          */
         String newOrFullPatchedMd5 = "0";
+        /**
+         * This field is used to generate class-N dex jar on app runtime.
+         * It could be one of the following value:
+         *  CRC32 of full patched dex, if old dex and new dex are different;
+         *  CRC32 of new dex, if new dex is marked to be copied directly.
+         */
+        long newOrFullPatchedCRC = 0;
     }
 
     private final class DexPatcherLoggerBridge implements IDexPatcherLogger {
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ResDiffDecoder.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ResDiffDecoder.java
index 872f3a3b..353ff790 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ResDiffDecoder.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ResDiffDecoder.java
@@ -35,11 +35,21 @@
 import java.nio.file.SimpleFileVisitor;
 import java.nio.file.attribute.BasicFileAttributes;
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.HashMap;
 import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
 import java.util.zip.ZipEntry;
 import java.util.zip.ZipFile;
 
+import tinker.net.dongliu.apk.parser.ApkParser;
+import tinker.net.dongliu.apk.parser.struct.ResourceValue;
+import tinker.net.dongliu.apk.parser.struct.resource.ResourceEntry;
+import tinker.net.dongliu.apk.parser.struct.resource.ResourcePackage;
+import tinker.net.dongliu.apk.parser.struct.resource.Type;
+
 /**
  * Created by zhangshaowen on 16/8/8.
  */
@@ -58,6 +68,9 @@
     private HashMap<String, LargeModeInfo> largeModifiedMap;
     private ArrayList<String>              deletedSet;
 
+    private ApkParser                      newApkParser;
+    private Set<String>                    newApkAnimResNames;
+
     public ResDiffDecoder(Configuration config, String metaPath, String logPath) throws IOException {
         super(config);
 
@@ -78,12 +91,20 @@ public ResDiffDecoder(Configuration config, String metaPath, String logPath) thr
         largeModifiedMap = new HashMap<>();
         deletedSet = new ArrayList<>();
         storedSet = new ArrayList<>();
+
+        newApkParser = new ApkParser(config.mNewApkFile);
+        newApkAnimResNames = new HashSet<>();
     }
 
     @Override
     public void clean() {
         metaWriter.close();
         logWriter.close();
+        try {
+            newApkParser.close();
+        } catch (Throwable ignored) {
+            // Ignored.
+        }
     }
 
     /**
@@ -100,6 +121,45 @@ private boolean checkLargeModFile(File file) {
         return false;
     }
 
+    @Override
+    public void onAllPatchesStart() throws IOException, TinkerPatchException {
+        newApkParser.parseResourceTable();
+        final Map<String, ResourcePackage> newApkResPkgNameMap = newApkParser.getResourceTable().getPackageNameMap();
+        do {
+            if (newApkResPkgNameMap == null) {
+                break;
+            }
+
+            final ResourcePackage newApkResPackage = newApkResPkgNameMap.get(newApkParser.getApkMeta().getPackageName());
+            if (newApkResPackage == null) {
+                break;
+            }
+
+            final Map<String, List<Type>> newApkResTypesNameMap = newApkResPackage.getTypesNameMap();
+            if (newApkResTypesNameMap == null) {
+                break;
+            }
+
+            final List<Type> newApkAnimResTypes = newApkResTypesNameMap.get("anim");
+            if (newApkAnimResTypes == null) {
+                break;
+            }
+
+            for (Type animType : newApkAnimResTypes) {
+                for (ResourceEntry value : animType.getResourceEntryNameHashMap().values()) {
+                    if (value == null) {
+                        continue;
+                    }
+                    final ResourceValue resValue = value.getValue();
+                    if (resValue == null) {
+                        continue;
+                    }
+                    newApkAnimResNames.add(resValue.toStringValue());
+                }
+            }
+        } while (false);
+    }
+
     @Override
     public boolean patch(File oldFile, File newFile) throws IOException, TinkerPatchException {
         String name = getRelativePathStringToNewFile(newFile);
@@ -216,11 +276,6 @@ private void writeResLog(File newFile, File oldFile, int mode) throws IOExceptio
         }
     }
 
-    @Override
-    public void onAllPatchesStart() throws IOException, TinkerPatchException {
-
-    }
-
     private void addAssetsFileForTestResource() throws IOException {
         File dest = new File(config.mTempResultDir + "/" + TEST_RESOURCE_ASSETS_PATH);
         FileOperation.copyResourceUsingStream(TEST_RESOURCE_NAME, dest);
@@ -282,6 +337,12 @@ public void onAllPatchesEnd() throws IOException, TinkerPatchException {
         removeIgnoreChangeFile(addedSet);
         removeIgnoreChangeFile(largeModifiedSet);
 
+        // after ignore-changes resource files are being removed, we now check if there's any anim
+        // resources in added and modified files.
+        checkIfSpecificResWasAnimRes(addedSet);
+        checkIfSpecificResWasAnimRes(modifiedSet);
+        checkIfSpecificResWasAnimRes(largeModifiedSet);
+
         // last add test res in assets for user cannot ignore it;
         addAssetsFileForTestResource();
 
@@ -337,6 +398,51 @@ public void onAllPatchesEnd() throws IOException, TinkerPatchException {
 
     }
 
+    private void checkIfSpecificResWasAnimRes(Collection<String> specificFileNames) {
+        final Set<String> changedAnimResNames = new HashSet<>();
+        for (String resFileName : specificFileNames) {
+            String resName = resFileName;
+            int lastPathSepPos = resFileName.lastIndexOf('/');
+            if (lastPathSepPos < 0) {
+                lastPathSepPos = resFileName.lastIndexOf('\\');
+            }
+            if (lastPathSepPos >= 0) {
+                resName = resName.substring(lastPathSepPos + 1);
+            }
+            final int firstDotPos = resName.indexOf('.');
+            if (firstDotPos >= 0) {
+                resName = resName.substring(0, firstDotPos);
+            }
+            if (newApkAnimResNames.contains(resName)) {
+                if (Utils.isStringMatchesPatterns(resFileName, config.mResIgnoreChangeWarningPattern)) {
+                    Logger.d("\nAnimation resource: " + resFileName
+                            + " was changed, but it's filtered by ignoreChangeWarning pattern, just ignore.\n");
+                } else {
+                    changedAnimResNames.add(resFileName);
+                }
+            }
+        }
+        if (!changedAnimResNames.isEmpty()) {
+            if (config.mIgnoreWarning) {
+                //ignoreWarning, just log
+                Logger.e("Warning:ignoreWarning is true, but we found animation resource is changed. "
+                        + "Please check if any one was used in 'overridePendingTransition' which may leads to crash. "
+                        + "If all of them were not used in that method, just add them into 'res { ignoreChangeWarning }' option.\n"
+                        + "related res: " + changedAnimResNames + "\n");
+            } else {
+                Logger.e("Warning:ignoreWarning is false, but we found animation resource is changed. "
+                        + "Please check if any one was used in 'overridePendingTransition' which may leads to crash. "
+                        + "If all of them were not used in that method, just add them into 'res { ignoreChangeWarning }' option.\n"
+                        + "related res: " + changedAnimResNames + "\n");
+                throw new TinkerPatchException(
+                        "ignoreWarning is false, but we found animation resource is changed. "
+                        + "Please check if any one was used in 'overridePendingTransition' which may leads to crash. "
+                        + "If all of them were not used in that method, just add them into 'res { ignoreChangeWarning }' option.\n"
+                        + "related res: " + changedAnimResNames);
+            }
+        }
+    }
+
     private void getCompressMethodFromApk() {
         ZipFile zipFile = null;
         try {
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/Configuration.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/Configuration.java
index fe5c30a3..6ddbfe70 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/Configuration.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/Configuration.java
@@ -69,6 +69,7 @@
     protected static final String ATTR_DEX_MODE                  = "dexMode";
     protected static final String ATTR_PATTERN                   = "pattern";
     protected static final String ATTR_IGNORE_CHANGE             = "ignoreChange";
+    protected static final String ATTR_IGNORE_CHANGE_WARNING     = "ignoreChangeWarning";
     protected static final String ATTR_RES_LARGE_MOD             = "largeModSize";
 
     protected static final String ATTR_LOADER       = "loader";
@@ -106,6 +107,7 @@
      */
     public HashSet<Pattern> mResFilePattern;
     public HashSet<Pattern> mResIgnoreChangePattern;
+    public HashSet<Pattern> mResIgnoreChangeWarningPattern;
     public HashSet<String>  mResRawPattern;
     public int              mLargeModSize;
     /**
@@ -154,6 +156,7 @@ public Configuration(File config, File outputFile, File oldApkFile, File newApkF
         mResFilePattern = new HashSet<>();
         mResRawPattern = new HashSet<>();
         mResIgnoreChangePattern = new HashSet<>();
+        mResIgnoreChangeWarningPattern = new HashSet<>();
 
         mPackageFields = new HashMap<>();
         mOutFolder = outputFile.getAbsolutePath();
@@ -184,6 +187,7 @@ public Configuration(InputParam param) throws IOException, TinkerPatchException
         mResFilePattern = new HashSet<>();
         mResRawPattern = new HashSet<>();
         mResIgnoreChangePattern = new HashSet<>();
+        mResIgnoreChangeWarningPattern = new HashSet<>();
 
         mPackageFields = new HashMap<>();
 
@@ -203,6 +207,10 @@ public Configuration(InputParam param) throws IOException, TinkerPatchException
         for (String item : param.resourceIgnoreChangePattern) {
             addToPatterns(item, mResIgnoreChangePattern);
         }
+
+        for (String item : param.resourceIgnoreChangeWarningPattern) {
+            addToPatterns(item, mResIgnoreChangeWarningPattern);
+        }
         mLargeModSize = param.largeModSize;
         //only gradle have the param
         mUseApplyResource = param.useApplyResource;
@@ -287,6 +295,9 @@ public String toString() {
         for (Pattern name : mResIgnoreChangePattern) {
             sb.append("resIgnore change:" + name.toString() + "\n");
         }
+        for (Pattern name : mResIgnoreChangeWarningPattern) {
+            sb.append("resIgnore change warning:" + name.toString() + "\n");
+        }
         sb.append("largeModSize:" + mLargeModSize + "kb\n");
         sb.append("useApplyResource:" + mUseApplyResource + "\n");
         return sb.toString();
@@ -557,6 +568,8 @@ private void readResPatternsFromXml(Node node) throws IOException {
                         addToPatterns(value, mResFilePattern);
                     } else if (tagName.equals(ATTR_IGNORE_CHANGE)) {
                         addToPatterns(value, mResIgnoreChangePattern);
+                    } else if (tagName.equals(ATTR_IGNORE_CHANGE_WARNING)) {
+                        addToPatterns(value, mResIgnoreChangeWarningPattern);
                     } else if (tagName.equals(ATTR_RES_LARGE_MOD)) {
                         mLargeModSize = Integer.valueOf(value);
                     } else {
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/InputParam.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/InputParam.java
index 31976019..cb2becd3 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/InputParam.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/InputParam.java
@@ -59,6 +59,10 @@
      * tinkerPath.resource ignoreChange
      */
     public final ArrayList<String>       resourceIgnoreChangePattern;
+    /**
+     * tinkerPatch.resource ignoreChangeWarning
+     */
+    public final ArrayList<String>       resourceIgnoreChangeWarningPattern;
     /**
      * tinkerPath.resource largeModSize
      */
@@ -97,6 +101,7 @@ private InputParam(
         ArrayList<String> soFilePattern,
         ArrayList<String> resourceFilePattern,
         ArrayList<String> resourceIgnoreChangePattern,
+        ArrayList<String> resourceIgnoreChangeWarningPattern,
         int largeModSize,
         boolean useApplyResource,
         HashMap<String, String> configFields,
@@ -123,6 +128,7 @@ private InputParam(
         this.soFilePattern = soFilePattern;
         this.resourceFilePattern = resourceFilePattern;
         this.resourceIgnoreChangePattern = resourceIgnoreChangePattern;
+        this.resourceIgnoreChangeWarningPattern = resourceIgnoreChangeWarningPattern;
         this.largeModSize = largeModSize;
         this.useApplyResource = useApplyResource;
 
@@ -167,6 +173,10 @@ private InputParam(
          * tinkerPath.resource ignoreChange
          */
         private ArrayList<String>       resourceIgnoreChangePattern;
+        /**
+         * tinkerPatch.resource ignoreChangeWarning
+         */
+        private ArrayList<String>       resourceIgnoreChangeWarningPattern;
         /**
          * tinkerPath.resource largeModSize
          */
@@ -213,6 +223,11 @@ public Builder setResourceIgnoreChangePattern(ArrayList<String> resourceIgnoreCh
             return this;
         }
 
+        public Builder setResourceIgnoreChangeWarningPattern(ArrayList<String> resourceIgnoreChangeWarningPattern) {
+            this.resourceIgnoreChangeWarningPattern = resourceIgnoreChangeWarningPattern;
+            return this;
+        }
+
         public Builder setResourceLargeModSize(int largeModSize) {
             this.largeModSize = largeModSize;
             return this;
@@ -318,6 +333,7 @@ public InputParam create() {
                     soFilePattern,
                     resourceFilePattern,
                     resourceIgnoreChangePattern,
+                    resourceIgnoreChangeWarningPattern,
                     largeModSize,
                     useApplyResource,
                     configFields,
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/ExcludedClassModifiedChecker.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/ExcludedClassModifiedChecker.java
index 1ed5a31c..444ca396 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/ExcludedClassModifiedChecker.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/ExcludedClassModifiedChecker.java
@@ -90,7 +90,7 @@ public void checkIfExcludedClassWasModifiedInNewDex(File oldFile, File newFile)
                  * 2. Primary new dex is missing.
                  * 3. There are not any loader classes in primary old dex.
                  * 4. There are some new loader classes added in new primary dex.
-                 * 5. Loader classes in old primary dex are modified, deleted in new primary dex.
+                 * 5. Loader classes in old primary dex are modified in new primary dex.
                  * 6. Loader classes are found in secondary old dexes.
                  * 7. Loader classes are found in secondary new dexes.
                  */
@@ -112,7 +112,7 @@ public void checkIfExcludedClassWasModifiedInNewDex(File oldFile, File newFile)
                             if (deletedClassInfos.isEmpty() && changedClassInfosMap.isEmpty() && !addedClassInfos.isEmpty()) {
                                 stmCode = STMCODE_ERROR_LOADER_CLASS_NOT_IN_PRIMARY_OLD_DEX;
                             } else {
-                                if (deletedClassInfos.isEmpty() && addedClassInfos.isEmpty()) {
+                                if (addedClassInfos.isEmpty()) {
                                     // class descriptor is completely matches, see if any contents changes.
                                     ArrayList<String> removeClasses = new ArrayList<>();
                                     for (String classname : changedClassInfosMap.keySet()) {
@@ -185,10 +185,8 @@ public void checkIfExcludedClassWasModifiedInNewDex(File oldFile, File newFile)
                 }
                 case STMCODE_ERROR_LOADER_CLASS_IN_PRIMARY_DEX_MISMATCH: {
                     throw new TinkerPatchException(
-                        "loader classes in old primary dex are mismatched to those in new primary dex, \n"
-                            + "if deleted classes is not empty, check if your dex division strategy is fine. \n"
-                            + "added classes: " + Utils.collectionToString(addedClassInfos) + "\n"
-                            + "deleted classes: " + Utils.collectionToString(deletedClassInfos)
+                        "there's loader classes added in new primary dex, such these changes will not take effect.\n"
+                            + "added classes: " + Utils.collectionToString(addedClassInfos)
                     );
                 }
                 case STMCODE_ERROR_LOADER_CLASS_FOUND_IN_SECONDARY_OLD_DEX: {
@@ -199,7 +197,7 @@ public void checkIfExcludedClassWasModifiedInNewDex(File oldFile, File newFile)
                 }
                 case STMCODE_ERROR_LOADER_CLASS_CHANGED: {
                     String msg =
-                        "some loader class has been changed in new dex."
+                        "some loader class has been changed in new primary dex."
                             + " Such these changes will not take effect!!"
                             + " related classes: "
                             + Utils.collectionToString(changedClassInfosMap.keySet());
diff --git a/tinker-sample-android/app/build.gradle b/tinker-sample-android/app/build.gradle
index 1790e7ce..9b662d29 100644
--- a/tinker-sample-android/app/build.gradle
+++ b/tinker-sample-android/app/build.gradle
@@ -13,13 +13,6 @@ dependencies {
         //use to test multiDex
 //    implementation group: 'com.google.guava', name: 'guava', version: '19.0'
 //    implementation "org.scala-lang:scala-library:2.11.7"
-
-        //use for local maven test
-//        implementation("com.tencent.tinker:tinker-android-loader:${TINKER_VERSION}") { changing = true }
-//        implementation("com.tencent.tinker:aosp-dexutils:${TINKER_VERSION}") { changing = true }
-//        implementation("com.tencent.tinker:bsdiff-util:${TINKER_VERSION}") { changing = true }
-//        implementation("com.tencent.tinker:tinker-ziputils:${TINKER_VERSION}") { changing = true }
-//        implementation("com.tencent.tinker:tinker-commons:${TINKER_VERSION}") { changing = true }
     } else {
         compile fileTree(dir: 'libs', include: ['*.jar'])
         testCompile 'junit:junit:4.12'
@@ -32,13 +25,6 @@ dependencies {
         //use to test multiDex
 //    compile group: 'com.google.guava', name: 'guava', version: '19.0'
 //    compile "org.scala-lang:scala-library:2.11.7"
-
-        //use for local maven test
-//        compile("com.tencent.tinker:tinker-android-loader:${TINKER_VERSION}") { changing = true }
-//        compile("com.tencent.tinker:aosp-dexutils:${TINKER_VERSION}") { changing = true }
-//        compile("com.tencent.tinker:bsdiff-util:${TINKER_VERSION}") { changing = true }
-//        compile("com.tencent.tinker:tinker-ziputils:${TINKER_VERSION}") { changing = true }
-//        compile("com.tencent.tinker:tinker-commons:${TINKER_VERSION}") { changing = true }
     }
 }
 
@@ -185,7 +171,7 @@ def getTinkerIdValue() {
 }
 
 def buildWithTinker() {
-    return hasProperty("TINKER_ENABLE") ? TINKER_ENABLE : ext.tinkerEnabled
+    return hasProperty("TINKER_ENABLE") ? Boolean.parseBoolean(TINKER_ENABLE) : ext.tinkerEnabled
 }
 
 def getTinkerBuildFlavorDirectory() {
diff --git a/tinker-sample-android/build.gradle b/tinker-sample-android/build.gradle
index 35bd3a36..c055f5fa 100644
--- a/tinker-sample-android/build.gradle
+++ b/tinker-sample-android/build.gradle
@@ -7,7 +7,7 @@ buildscript {
     }
     dependencies {
         if (project.hasProperty('GRADLE_3') && GRADLE_3.equalsIgnoreCase('TRUE')) {
-            classpath 'com.android.tools.build:gradle:3.0.0-rc2'
+            classpath 'com.android.tools.build:gradle:3.1.0-alpha06'
         } else {
             classpath 'com.android.tools.build:gradle:2.3.3'
         }
diff --git a/tinker-sample-android/gradle.properties b/tinker-sample-android/gradle.properties
index 31d743c1..d71a66a0 100644
--- a/tinker-sample-android/gradle.properties
+++ b/tinker-sample-android/gradle.properties
@@ -17,5 +17,5 @@
 # http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
 # org.gradle.parallel=true
 
-TINKER_VERSION=1.9.2
+TINKER_VERSION=1.9.6
 GRADLE_3=true
\ No newline at end of file
diff --git a/tinker-sample-android/gradle/wrapper/gradle-wrapper.properties b/tinker-sample-android/gradle/wrapper/gradle-wrapper.properties
index be4d6574..b08c4560 100644
--- a/tinker-sample-android/gradle/wrapper/gradle-wrapper.properties
+++ b/tinker-sample-android/gradle/wrapper/gradle-wrapper.properties
@@ -3,4 +3,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.4-rc-3-all.zip
