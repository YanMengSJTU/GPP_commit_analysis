diff --git a/build.gradle b/build.gradle
index 41297d17..2ecc6432 100644
--- a/build.gradle
+++ b/build.gradle
@@ -8,6 +8,7 @@ buildscript {
         classpath 'com.android.tools.build:gradle:2.2.0'
         classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.6'
         classpath "com.github.dcendents:android-maven-gradle-plugin:1.4.1"
+        classpath('com.tencent.tinker:tinker-patch-gradle-plugin:1.7.7') {changing = true }
     }
 }
 
diff --git a/settings.gradle b/settings.gradle
index ed01852c..823a2758 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -1,4 +1,4 @@
-include ':tinker-commons'
+include ':tinker-commons', ':tinker_souce_android'
 include ':tinker-android:tinker-android-loader'
 include ':tinker-android:tinker-android-lib'
 include ':tinker-android:tinker-android-anno'
diff --git a/tinker-build/tinker-patch-gradle-plugin/build.gradle b/tinker-build/tinker-patch-gradle-plugin/build.gradle
index fa4fb4e2..8031963b 100644
--- a/tinker-build/tinker-patch-gradle-plugin/build.gradle
+++ b/tinker-build/tinker-patch-gradle-plugin/build.gradle
@@ -17,6 +17,8 @@ repositories {
     mavenCentral()
 }
 
+
+
 sourceSets {
     main {
         groovy {
@@ -32,3 +34,13 @@ sourceSets {
 apply from: rootProject.file('gradle/java-artifacts.gradle')
 apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
 
+//group='com.tencent.tinker'
+//version='1.7.7'
+//
+//uploadArchives {
+//    repositories {
+//        mavenDeployer {
+//            repository(url: uri('../repo'))
+//        }
+//    }
+//}
diff --git a/tinker-sample-android/app/build.gradle b/tinker-sample-android/app/build.gradle
index ef2dae82..a8255e1a 100644
--- a/tinker-sample-android/app/build.gradle
+++ b/tinker-sample-android/app/build.gradle
@@ -138,14 +138,14 @@ ext {
 
     //for normal build
     //old apk file to build patch apk
-    tinkerOldApkPath = "${bakPath}/app-debug-1018-17-32-47.apk"
-    //proguard mapping file to build patch apk
-    tinkerApplyMappingPath = "${bakPath}/app-debug-1018-17-32-47-mapping.txt"
+    tinkerOldApkPath = "${bakPath}/app-debug-0116-11-03-11.apk"
     //resource R.txt to build patch apk, must input if there is resource changed
-    tinkerApplyResourcePath = "${bakPath}/app-debug-1018-17-32-47-R.txt"
+    tinkerApplyResourcePath = "${bakPath}/app-debug-0116-11-03-11-R.txt"
 
+    //proguard mapping file to build patch apk
+    tinkerApplyMappingPath = "${bakPath}/app-debug-1018-17-32-47-mapping.txt"
     //only use for build all flavor, if not, just ignore this field
-    tinkerBuildFlavorDirectory = "${bakPath}/app-1018-17-32-47"
+//    tinkerBuildFlavorDirectory = "${bakPath}/app-1018-17-32-47"
 }
 
 
@@ -162,7 +162,7 @@ def getApplyResourceMappingPath() {
 }
 
 def getTinkerIdValue() {
-    return hasProperty("TINKER_ID") ? TINKER_ID : gitSha()
+    return hasProperty("TINKER_ID") ? TINKER_ID : 20170116
 }
 
 def buildWithTinker() {
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/app/MainActivity.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/app/MainActivity.java
index 6bc8122b..2cad14ac 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/app/MainActivity.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/app/MainActivity.java
@@ -49,7 +49,7 @@ protected void onCreate(Bundle savedInstanceState) {
         Log.e(TAG, "i am on onCreate classloader:" + MainActivity.class.getClassLoader().toString());
         //test resource change
         Log.e(TAG, "i am on onCreate string:" + getResources().getString(R.string.test_resource));
-//        Log.e(TAG, "i am on patch onCreate");
+        Log.e(TAG, "i am on patch onCreate");
 
         Button loadPatchButton = (Button) findViewById(R.id.loadPatch);
 
@@ -99,6 +99,8 @@ public void onClick(View v) {
 
         Button buildInfoButton = (Button) findViewById(R.id.showInfo);
 
+        buildInfoButton.setText("修改后的show info");
+
         buildInfoButton.setOnClickListener(new View.OnClickListener() {
             @Override
             public void onClick(View v) {
diff --git a/tinker_souce_android/.gitignore b/tinker_souce_android/.gitignore
new file mode 100644
index 00000000..796b96d1
--- /dev/null
+++ b/tinker_souce_android/.gitignore
@@ -0,0 +1 @@
+/build
diff --git a/tinker_souce_android/build.gradle b/tinker_souce_android/build.gradle
new file mode 100644
index 00000000..3b31f298
--- /dev/null
+++ b/tinker_souce_android/build.gradle
@@ -0,0 +1,478 @@
+apply plugin: 'com.android.application'
+
+
+
+dependencies {
+    compile fileTree(include: ['*.jar'], dir: 'libs')
+    testCompile 'junit:junit:4.12'
+    compile 'com.android.support:appcompat-v7:23.1.1'
+    //    compile("com.tencent.tinker:tinker-android-lib:${TINKER_VERSION}") { changing = true }
+    //    provided("com.tencent.tinker:tinker-android-anno:${TINKER_VERSION}") { changing = true }
+    compile 'com.android.support:multidex:1.0.1'
+    //use to test multiDex
+    //    compile group: 'com.google.guava', name: 'guava', version: '19.0'
+    //    compile "org.scala-lang:scala-library:2.11.7"
+    //use for local maven test
+    //    compile("com.tencent.tinker:tinker-android-loader:${TINKER_VERSION}") { changing = true }
+    //    compile("com.tencent.tinker:aosp-dexutils:${TINKER_VERSION}") { changing = true }
+    //    compile("com.tencent.tinker:bsdiff-util:${TINKER_VERSION}") { changing = true }
+    //    compile("com.tencent.tinker:tinker-commons:${TINKER_VERSION}") { changing = true }
+    provided project(':tinker-android:tinker-android-anno')
+    compile project(':third-party:aosp-dexutils')
+    compile project(':third-party:bsdiff-util')
+    compile project(':tinker-android:tinker-android-lib')
+    compile project(':tinker-android:tinker-android-loader')
+    compile project(':tinker-commons')
+
+}
+
+def gitSha() {
+    try {
+        String gitRev = 'git rev-parse --short HEAD'.execute(null, project.rootDir).text.trim()
+        if (gitRev == null) {
+            throw new GradleException("can't get git rev, you should add git to system path or just input test value, such as 'testTinkerId'")
+        }
+        return gitRev
+    } catch (Exception e) {
+        throw new GradleException("can't get git rev, you should add git to system path or just input test value, such as 'testTinkerId'")
+    }
+}
+
+def javaVersion = JavaVersion.VERSION_1_7
+
+android {
+    compileSdkVersion 23
+    buildToolsVersion "23.0.2"
+
+    compileOptions {
+        sourceCompatibility javaVersion
+        targetCompatibility javaVersion
+    }
+    //recommend
+    dexOptions {
+        jumboMode = true
+    }
+
+    signingConfigs {
+        config {
+            storeFile file("./keystore/sign.jks")
+            storePassword "123456"
+            keyAlias "tinker"
+            keyPassword "123456"
+        }
+    }
+//    signingConfigs {
+//        release {
+//            try {
+//                storeFile file("./keystore/sign.jks")
+//                storePassword "123456"
+//                keyAlias "tinker"
+//                keyPassword "123456"
+//            } catch (ex) {
+//                throw new InvalidUserDataException(ex.toString())
+//            }
+//        }
+//
+//        debug {
+//            storeFile file("./keystore/sign.jks")
+//        }
+//    }
+
+    defaultConfig {
+        applicationId "com.tinker.tinker_souce_android"
+        minSdkVersion 10
+        targetSdkVersion 22
+        versionCode 1
+        versionName "1.0.0"
+        /**
+         * you can use multiDex and install it in your ApplicationLifeCycle implement
+         */
+        multiDexEnabled true
+        /**
+         * buildConfig can change during patch!
+         * we can use the newly value when patch
+         */
+        buildConfigField "String", "MESSAGE", "\"I am the base apk\""
+//        buildConfigField "String", "MESSAGE", "\"I am the patch apk\""
+        /**
+         * client version would update with patch
+         * so we can get the newly git version easily!
+         */
+        buildConfigField "String", "TINKER_ID", "\"${getTinkerIdValue()}\""
+        buildConfigField "String", "PLATFORM",  "\"all\""
+    }
+
+//    aaptOptions{
+//        cruncherEnabled false
+//    }
+
+//    //use to test flavors support
+//    productFlavors {
+//        flavor1 {
+//            applicationId 'tinker.sample.android.flavor1'
+//        }
+//
+//        flavor2 {
+//            applicationId 'tinker.sample.android.flavor2'
+//        }
+//    }
+
+//    buildTypes {
+//        release {
+//            minifyEnabled false
+//            signingConfig signingConfigs.release
+//            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
+//        }
+//        debug {
+//            debuggable true
+//            minifyEnabled false
+//            signingConfig signingConfigs.debug
+//        }
+//    }
+    buildTypes {
+        release {
+            minifyEnabled false
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
+            signingConfig signingConfigs.config
+        }
+        debug {
+            signingConfig signingConfigs.config
+        }
+    }
+    sourceSets {
+        main {
+            jniLibs.srcDirs = ['libs']
+        }
+    }
+}
+
+def bakPath = file("${buildDir}/bakApk/")
+
+/**
+ * you can use assembleRelease to build you base apk
+ * use tinkerPatchRelease -POLD_APK=  -PAPPLY_MAPPING=  -PAPPLY_RESOURCE= to build patch
+ * add apk from the build/bakApk
+ */
+ext {
+    //for some reason, you may want to ignore tinkerBuild, such as instant run debug build?
+    tinkerEnabled = true
+
+    //for normal build
+    //old apk file to build patch apk
+    tinkerOldApkPath = "${bakPath}/tinker_souce_android-debug-0116-17-36-53.apk"
+    //resource R.txt to build patch apk, must input if there is resource changed
+    tinkerApplyResourcePath = "${bakPath}/tinker_souce_android-debug-0116-17-36-53-R.txt"
+
+    //proguard mapping file to build patch apk
+    tinkerApplyMappingPath = "${bakPath}/app-debug-1018-17-32-47-mapping.txt"
+    //only use for build all flavor, if not, just ignore this field
+//    tinkerBuildFlavorDirectory = "${bakPath}/app-1018-17-32-47"
+}
+
+
+def getOldApkPath() {
+    return hasProperty("OLD_APK") ? OLD_APK : ext.tinkerOldApkPath
+}
+
+def getApplyMappingPath() {
+    return hasProperty("APPLY_MAPPING") ? APPLY_MAPPING : ext.tinkerApplyMappingPath
+}
+
+def getApplyResourceMappingPath() {
+    return hasProperty("APPLY_RESOURCE") ? APPLY_RESOURCE : ext.tinkerApplyResourcePath
+}
+
+def getTinkerIdValue() {
+    return hasProperty("TINKER_ID") ? TINKER_ID : 20170116
+}
+
+def buildWithTinker() {
+    return hasProperty("TINKER_ENABLE") ? TINKER_ENABLE : ext.tinkerEnabled
+}
+
+def getTinkerBuildFlavorDirectory() {
+    return ext.tinkerBuildFlavorDirectory
+}
+
+//buildscript {
+//    repositories {
+//        maven {
+//            url uri('../tinker-build/repo')
+//        }
+//    }
+//    dependencies {
+//        classpath 'com.tencent.tinker:tinker-patch-gradle-plugin:1.7.7'
+//    }
+//}
+if (buildWithTinker()) {
+    apply plugin: 'com.tencent.tinker.patch'
+
+    tinkerPatch {
+        /**
+         * necessary，default 'null'
+         * the old apk path, use to diff with the new apk to build
+         * add apk from the build/bakApk
+         */
+        oldApk = getOldApkPath()
+        /**
+         * optional，default 'false'
+         * there are some cases we may get some warnings
+         * if ignoreWarning is true, we would just assert the patch process
+         * case 1: minSdkVersion is below 14, but you are using dexMode with raw.
+         *         it must be crash when load.
+         * case 2: newly added Android Component in AndroidManifest.xml,
+         *         it must be crash when load.
+         * case 3: loader classes in dex.loader{} are not keep in the main dex,
+         *         it must be let tinker not work.
+         * case 4: loader classes in dex.loader{} changes,
+         *         loader classes is ues to load patch dex. it is useless to change them.
+         *         it won't crash, but these changes can't effect. you may ignore it
+         * case 5: resources.arsc has changed, but we don't use applyResourceMapping to build
+         */
+        ignoreWarning = false
+
+        /**
+         * optional，default 'true'
+         * whether sign the patch file
+         * if not, you must do yourself. otherwise it can't check success during the patch loading
+         * we will use the sign config with your build type
+         */
+        useSign = true
+
+        /**
+         * optional，default 'true'
+         * whether use tinker to build
+         */
+        tinkerEnable = buildWithTinker()
+
+        /**
+         * Warning, applyMapping will affect the normal android build!
+         */
+        buildConfig {
+            /**
+             * optional，default 'null'
+             * if we use tinkerPatch to build the patch apk, you'd better to apply the old
+             * apk mapping file if minifyEnabled is enable!
+             * Warning:
+             * you must be careful that it will affect the normal assemble build!
+             */
+            applyMapping = getApplyMappingPath()
+            /**
+             * optional，default 'null'
+             * It is nice to keep the resource id from R.txt file to reduce java changes
+             */
+            applyResourceMapping = getApplyResourceMappingPath()
+
+            /**
+             * necessary，default 'null'
+             * because we don't want to check the base apk with md5 in the runtime(it is slow)
+             * tinkerId is use to identify the unique base apk when the patch is tried to apply.
+             * we can use git rev, svn rev or simply versionCode.
+             * we will gen the tinkerId in your manifest automatic
+             */
+            tinkerId = getTinkerIdValue()
+
+            /**
+             * if keepDexApply is true, class in which dex refer to the old apk.
+             * open this can reduce the dex diff file size.
+             */
+            keepDexApply = false
+        }
+
+        dex {
+            /**
+             * optional，default 'jar'
+             * only can be 'raw' or 'jar'. for raw, we would keep its original format
+             * for jar, we would repack dexes with zip format.
+             * if you want to support below 14, you must use jar
+             * or you want to save rom or check quicker, you can use raw mode also
+             */
+            dexMode = "jar"
+
+            /**
+             * necessary，default '[]'
+             * what dexes in apk are expected to deal with tinkerPatch
+             * it support * or ? pattern.
+             */
+            pattern = ["classes*.dex",
+                       "assets/secondary-dex-?.jar"]
+            /**
+             * necessary，default '[]'
+             * Warning, it is very very important, loader classes can't change with patch.
+             * thus, they will be removed from patch dexes.
+             * you must put the following class into main dex.
+             * Simply, you should add your own application {@code tinker.sample.android.SampleApplication}
+             * own tinkerLoader, and the classes you use in them
+             *
+             */
+            loader = [
+                    //use sample, let BaseBuildInfo unchangeable with tinker
+                    "tinker.sample.android.app.BaseBuildInfo"
+            ]
+        }
+
+        lib {
+            /**
+             * optional，default '[]'
+             * what library in apk are expected to deal with tinkerPatch
+             * it support * or ? pattern.
+             * for library in assets, we would just recover them in the patch directory
+             * you can get them in TinkerLoadResult with Tinker
+             */
+            pattern = ["lib/armeabi/*.so"]
+        }
+
+        res {
+            /**
+             * optional，default '[]'
+             * what resource in apk are expected to deal with tinkerPatch
+             * it support * or ? pattern.
+             * you must include all your resources in apk here,
+             * otherwise, they won't repack in the new apk resources.
+             */
+            pattern = ["res/*", "assets/*", "resources.arsc", "AndroidManifest.xml"]
+
+            /**
+             * optional，default '[]'
+             * the resource file exclude patterns, ignore add, delete or modify resource change
+             * it support * or ? pattern.
+             * Warning, we can only use for files no relative with resources.arsc
+             */
+            ignoreChange = ["assets/sample_meta.txt"]
+
+            /**
+             * default 100kb
+             * for modify resource, if it is larger than 'largeModSize'
+             * we would like to use bsdiff algorithm to reduce patch file size
+             */
+            largeModSize = 100
+        }
+
+        packageConfig {
+            /**
+             * optional，default 'TINKER_ID, TINKER_ID_VALUE' 'NEW_TINKER_ID, NEW_TINKER_ID_VALUE'
+             * package meta file gen. path is assets/package_meta.txt in patch file
+             * you can use securityCheck.getPackageProperties() in your ownPackageCheck method
+             * or TinkerLoadResult.getPackageConfigByName
+             * we will get the TINKER_ID from the old apk manifest for you automatic,
+             * other config files (such as patchMessage below)is not necessary
+             */
+            configField("patchMessage", "tinker is sample to use")
+            /**
+             * just a sample case, you can use such as sdkVersion, brand, channel...
+             * you can parse it in the SamplePatchListener.
+             * Then you can use patch conditional!
+             */
+            configField("platform", "all")
+            /**
+             * patch version via packageConfig
+             */
+            configField("patchVersion", "1.0")
+        }
+        //or you can add config filed outside, or get meta value from old apk
+        //project.tinkerPatch.packageConfig.configField("test1", project.tinkerPatch.packageConfig.getMetaDataFromOldApk("Test"))
+        //project.tinkerPatch.packageConfig.configField("test2", "sample")
+
+        /**
+         * if you don't use zipArtifact or path, we just use 7za to try
+         */
+        sevenZip {
+            /**
+             * optional，default '7za'
+             * the 7zip artifact path, it will use the right 7za with your platform
+             */
+            zipArtifact = "com.tencent.mm:SevenZip:1.1.10"
+            /**
+             * optional，default '7za'
+             * you can specify the 7za path yourself, it will overwrite the zipArtifact value
+             */
+//        path = "/usr/local/bin/7za"
+        }
+    }
+
+    List<String> flavors = new ArrayList<>();
+    project.android.productFlavors.each {flavor ->
+        flavors.add(flavor.name)
+    }
+    boolean hasFlavors = flavors.size() > 0
+    /**
+     * bak apk and mapping
+     */
+    android.applicationVariants.all { variant ->
+        /**
+         * task type, you want to bak
+         */
+        def taskName = variant.name
+        def date = new Date().format("MMdd-HH-mm-ss")
+
+        tasks.all {
+            if ("assemble${taskName.capitalize()}".equalsIgnoreCase(it.name)) {
+
+                it.doLast {
+                    copy {
+                        def fileNamePrefix = "${project.name}-${variant.baseName}"
+                        def newFileNamePrefix = hasFlavors ? "${fileNamePrefix}" : "${fileNamePrefix}-${date}"
+
+                        def destPath = hasFlavors ? file("${bakPath}/${project.name}-${date}/${variant.flavorName}") : bakPath
+                        from variant.outputs.outputFile
+                        into destPath
+                        rename { String fileName ->
+                            fileName.replace("${fileNamePrefix}.apk", "${newFileNamePrefix}.apk")
+                        }
+
+                        from "${buildDir}/outputs/mapping/${variant.dirName}/mapping.txt"
+                        into destPath
+                        rename { String fileName ->
+                            fileName.replace("mapping.txt", "${newFileNamePrefix}-mapping.txt")
+                        }
+
+                        from "${buildDir}/intermediates/symbols/${variant.dirName}/R.txt"
+                        into destPath
+                        rename { String fileName ->
+                            fileName.replace("R.txt", "${newFileNamePrefix}-R.txt")
+                        }
+                    }
+                }
+            }
+        }
+    }
+    project.afterEvaluate {
+        //sample use for build all flavor for one time
+        if (hasFlavors) {
+            task(tinkerPatchAllFlavorRelease) {
+                group = 'tinker'
+                def originOldPath = getTinkerBuildFlavorDirectory()
+                for (String flavor : flavors) {
+                    def tinkerTask = tasks.getByName("tinkerPatch${flavor.capitalize()}Release")
+                    dependsOn tinkerTask
+                    def preAssembleTask = tasks.getByName("process${flavor.capitalize()}ReleaseManifest")
+                    preAssembleTask.doFirst {
+                        String flavorName = preAssembleTask.name.substring(7, 8).toLowerCase() + preAssembleTask.name.substring(8, preAssembleTask.name.length() - 15)
+                        project.tinkerPatch.oldApk = "${originOldPath}/${flavorName}/${project.name}-${flavorName}-release.apk"
+                        project.tinkerPatch.buildConfig.applyMapping = "${originOldPath}/${flavorName}/${project.name}-${flavorName}-release-mapping.txt"
+                        project.tinkerPatch.buildConfig.applyResourceMapping = "${originOldPath}/${flavorName}/${project.name}-${flavorName}-release-R.txt"
+
+                    }
+
+                }
+            }
+
+            task(tinkerPatchAllFlavorDebug) {
+                group = 'tinker'
+                def originOldPath = getTinkerBuildFlavorDirectory()
+                for (String flavor : flavors) {
+                    def tinkerTask = tasks.getByName("tinkerPatch${flavor.capitalize()}Debug")
+                    dependsOn tinkerTask
+                    def preAssembleTask = tasks.getByName("process${flavor.capitalize()}DebugManifest")
+                    preAssembleTask.doFirst {
+                        String flavorName = preAssembleTask.name.substring(7, 8).toLowerCase() + preAssembleTask.name.substring(8, preAssembleTask.name.length() - 13)
+                        project.tinkerPatch.oldApk = "${originOldPath}/${flavorName}/${project.name}-${flavorName}-debug.apk"
+                        project.tinkerPatch.buildConfig.applyMapping = "${originOldPath}/${flavorName}/${project.name}-${flavorName}-debug-mapping.txt"
+                        project.tinkerPatch.buildConfig.applyResourceMapping = "${originOldPath}/${flavorName}/${project.name}-${flavorName}-debug-R.txt"
+                    }
+
+                }
+            }
+        }
+    }
+}
diff --git a/tinker_souce_android/keystore/sign.jks b/tinker_souce_android/keystore/sign.jks
new file mode 100644
index 00000000..be3e170a
Binary files /dev/null and b/tinker_souce_android/keystore/sign.jks differ
diff --git a/tinker_souce_android/proguard-rules.pro b/tinker_souce_android/proguard-rules.pro
new file mode 100644
index 00000000..00fd6e78
--- /dev/null
+++ b/tinker_souce_android/proguard-rules.pro
@@ -0,0 +1,17 @@
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in D:\AndroidStudio\sdk/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the proguardFiles
+# directive in build.gradle.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
diff --git a/tinker_souce_android/src/androidTest/java/com/tinker/tinker_souce_android/ApplicationTest.java b/tinker_souce_android/src/androidTest/java/com/tinker/tinker_souce_android/ApplicationTest.java
new file mode 100644
index 00000000..c28a6b86
--- /dev/null
+++ b/tinker_souce_android/src/androidTest/java/com/tinker/tinker_souce_android/ApplicationTest.java
@@ -0,0 +1,13 @@
+package com.tinker.tinker_souce_android;
+
+import android.app.Application;
+import android.test.ApplicationTestCase;
+
+/**
+ * <a href="http://d.android.com/tools/testing/testing_android.html">Testing Fundamentals</a>
+ */
+public class ApplicationTest extends ApplicationTestCase<Application> {
+    public ApplicationTest() {
+        super(Application.class);
+    }
+}
\ No newline at end of file
diff --git a/tinker_souce_android/src/main/AndroidManifest.xml b/tinker_souce_android/src/main/AndroidManifest.xml
new file mode 100644
index 00000000..90bc517d
--- /dev/null
+++ b/tinker_souce_android/src/main/AndroidManifest.xml
@@ -0,0 +1,29 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.tinker.tinker_souce_android">
+
+    <uses-sdk android:minSdkVersion="15" android:targetSdkVersion="22"/>
+
+    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
+    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
+
+    <application
+        android:name=".app.SampleApplication"
+        android:icon="@mipmap/ic_launcher"
+        android:label="@string/app_name"
+        android:theme="@style/AppTheme">
+        <service
+            android:name=".service.SampleResultService"
+            android:exported="false"/>
+
+        <activity android:name=".app.MainActivity">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN"/>
+
+                <category android:name="android.intent.category.LAUNCHER"/>
+            </intent-filter>
+        </activity>
+
+    </application>
+
+</manifest>
\ No newline at end of file
diff --git a/tinker_souce_android/src/main/java/com/tinker/tinker_souce_android/Log/MyLogImp.java b/tinker_souce_android/src/main/java/com/tinker/tinker_souce_android/Log/MyLogImp.java
new file mode 100644
index 00000000..a8b3e3b8
--- /dev/null
+++ b/tinker_souce_android/src/main/java/com/tinker/tinker_souce_android/Log/MyLogImp.java
@@ -0,0 +1,96 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tinker.tinker_souce_android.Log;
+
+import android.util.Log;
+
+import com.tencent.tinker.lib.util.TinkerLog;
+
+/**
+ * Created by zhangshaowen on 16/6/3.
+ */
+public class MyLogImp implements TinkerLog.TinkerLogImp {
+    private static final String TAG = "Tinker.MyLogImp";
+
+    public static final int LEVEL_VERBOSE = 0;
+    public static final int LEVEL_DEBUG   = 1;
+    public static final int LEVEL_INFO    = 2;
+    public static final int LEVEL_WARNING = 3;
+    public static final int LEVEL_ERROR   = 4;
+    public static final int LEVEL_NONE    = 5;
+    private static int level = LEVEL_VERBOSE;
+
+    public static int getLogLevel() {
+        return level;
+    }
+
+    public static void setLevel(final int level) {
+        MyLogImp.level = level;
+        Log.w(TAG, "new log level: " + level);
+
+    }
+
+    @Override
+    public void v(String s, String s1, Object... objects) {
+        if (level <= LEVEL_VERBOSE) {
+            final String log = objects == null ? s1 : String.format(s1, objects);
+            Log.v(s, log);
+        }
+    }
+
+    @Override
+    public void i(String s, String s1, Object... objects) {
+        if (level <= LEVEL_INFO) {
+            final String log = objects == null ? s1 : String.format(s1, objects);
+            Log.i(s, log);
+        }
+    }
+
+    @Override
+    public void w(String s, String s1, Object... objects) {
+        if (level <= LEVEL_WARNING) {
+            final String log = objects == null ? s1 : String.format(s1, objects);
+            Log.w(s, log);
+        }
+    }
+
+    @Override
+    public void d(String s, String s1, Object... objects) {
+        if (level <= LEVEL_DEBUG) {
+            final String log = objects == null ? s1 : String.format(s1, objects);
+            Log.d(s, log);
+        }
+    }
+
+    @Override
+    public void e(String s, String s1, Object... objects) {
+        if (level <= LEVEL_ERROR) {
+            final String log = objects == null ? s1 : String.format(s1, objects);
+            Log.e(s, log);
+        }
+    }
+
+    @Override
+    public void printErrStackTrace(String s, Throwable throwable, String s1, Object... objects) {
+        String log = objects == null ? s1 : String.format(s1, objects);
+        if (log == null) {
+            log = "";
+        }
+        log = log + "  " + Log.getStackTraceString(throwable);
+        Log.e(s, log);
+    }
+}
diff --git a/tinker_souce_android/src/main/java/com/tinker/tinker_souce_android/app/BaseBuildInfo.java b/tinker_souce_android/src/main/java/com/tinker/tinker_souce_android/app/BaseBuildInfo.java
new file mode 100644
index 00000000..15c2a6ff
--- /dev/null
+++ b/tinker_souce_android/src/main/java/com/tinker/tinker_souce_android/app/BaseBuildInfo.java
@@ -0,0 +1,29 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tinker.tinker_souce_android.app;
+
+
+import com.tinker.tinker_souce_android.BuildConfig;
+
+/**
+ * Created by zhangshaowen on 16/6/30.
+ * we add BaseBuildInfo to loader pattern, so it won't change with patch!
+ */
+public class BaseBuildInfo {
+    public static String TEST_MESSAGE = "I won't change with tinker patch!";
+    public static String BASE_TINKER_ID = BuildConfig.TINKER_ID;
+}
diff --git a/tinker_souce_android/src/main/java/com/tinker/tinker_souce_android/app/BuildInfo.java b/tinker_souce_android/src/main/java/com/tinker/tinker_souce_android/app/BuildInfo.java
new file mode 100644
index 00000000..5671afbe
--- /dev/null
+++ b/tinker_souce_android/src/main/java/com/tinker/tinker_souce_android/app/BuildInfo.java
@@ -0,0 +1,38 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tinker.tinker_souce_android.app;
+
+
+import com.tinker.tinker_souce_android.BuildConfig;
+
+/**
+ * Created by zhangshaowen on 16/6/30.
+ * we use BuildInfo instead of {@link BuildInfo} to make less change
+ */
+public class BuildInfo {
+    /**
+     * they are not final, so they won't change with the BuildConfig values!
+     */
+    public static boolean DEBUG        = BuildConfig.DEBUG;
+    public static String  VERSION_NAME = BuildConfig.VERSION_NAME;
+    public static int     VERSION_CODE = BuildConfig.VERSION_CODE;
+
+    public static String MESSAGE       = BuildConfig.MESSAGE;
+    public static String TINKER_ID     = BuildConfig.TINKER_ID;
+    public static String PLATFORM      = BuildConfig.PLATFORM;
+
+}
diff --git a/tinker_souce_android/src/main/java/com/tinker/tinker_souce_android/app/MainActivity.java b/tinker_souce_android/src/main/java/com/tinker/tinker_souce_android/app/MainActivity.java
new file mode 100644
index 00000000..295a3533
--- /dev/null
+++ b/tinker_souce_android/src/main/java/com/tinker/tinker_souce_android/app/MainActivity.java
@@ -0,0 +1,169 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tinker.tinker_souce_android.app;
+
+import android.app.AlertDialog;
+import android.content.Context;
+import android.graphics.Typeface;
+import android.os.Bundle;
+import android.os.Environment;
+import android.support.v7.app.AppCompatActivity;
+import android.util.Log;
+import android.util.TypedValue;
+import android.view.Gravity;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.Button;
+import android.widget.TextView;
+
+import com.tencent.tinker.lib.library.TinkerLoadLibrary;
+import com.tencent.tinker.lib.tinker.Tinker;
+import com.tencent.tinker.lib.tinker.TinkerInstaller;
+import com.tencent.tinker.loader.shareutil.ShareConstants;
+import com.tencent.tinker.loader.shareutil.ShareTinkerInternals;
+import com.tinker.tinker_souce_android.R;
+import com.tinker.tinker_souce_android.util.Utils;
+
+
+public class MainActivity extends AppCompatActivity {
+    private static final String TAG = "Tinker.MainActivity";
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_main);
+        Log.e(TAG, "i am on onCreate classloader:" + MainActivity.class.getClassLoader().toString());
+        //test resource change
+        Log.e(TAG, "i am on onCreate string:" + getResources().getString(R.string.test_resource));
+//        Log.e(TAG, "i am on patch onCreate");
+
+        Button loadPatchButton = (Button) findViewById(R.id.loadPatch);
+
+        loadPatchButton.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                TinkerInstaller.onReceiveUpgradePatch(getApplicationContext(), Environment.getExternalStorageDirectory().getAbsolutePath() + "/patch_signed_7zip.apk");
+            }
+        });
+
+        Button loadLibraryButton = (Button) findViewById(R.id.loadLibrary);
+
+        loadLibraryButton.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                // #method 1, hack classloader library path
+                TinkerLoadLibrary.installNavitveLibraryABI(getApplicationContext(), "armeabi");
+                System.loadLibrary("stlport_shared");
+
+                // #method 2, for lib/armeabi, just use TinkerInstaller.loadLibrary
+//                TinkerLoadLibrary.loadArmLibrary(getApplicationContext(), "stlport_shared");
+
+                // #method 3, load tinker patch library directly
+//                TinkerInstaller.loadLibraryFromTinker(getApplicationContext(), "assets/x86", "stlport_shared");
+
+            }
+        });
+
+        Button cleanPatchButton = (Button) findViewById(R.id.cleanPatch);
+
+        cleanPatchButton.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                Tinker.with(getApplicationContext()).cleanPatch();
+            }
+        });
+
+        Button killSelfButton = (Button) findViewById(R.id.killSelf);
+
+        killSelfButton.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                ShareTinkerInternals.killAllOtherProcess(getApplicationContext());
+                android.os.Process.killProcess(android.os.Process.myPid());
+            }
+        });
+
+        Button buildInfoButton = (Button) findViewById(R.id.showInfo);
+
+        buildInfoButton.setText("show info");
+
+        buildInfoButton.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                showInfo(MainActivity.this);
+            }
+        });
+    }
+
+    public boolean showInfo(Context context) {
+        // add more Build Info
+        final StringBuilder sb = new StringBuilder();
+        Tinker tinker = Tinker.with(getApplicationContext());
+        if (tinker.isTinkerLoaded()) {
+            sb.append(String.format("[patch is loaded] \n"));
+            sb.append(String.format("[buildConfig TINKER_ID] %s \n", BuildInfo.TINKER_ID));
+            sb.append(String.format("[buildConfig BASE_TINKER_ID] %s \n", BaseBuildInfo.BASE_TINKER_ID));
+
+            sb.append(String.format("[buildConfig MESSSAGE] %s \n", BuildInfo.MESSAGE));
+            sb.append(String.format("[TINKER_ID] %s \n", tinker.getTinkerLoadResultIfPresent().getPackageConfigByName(ShareConstants.TINKER_ID)));
+            sb.append(String.format("[packageConfig patchMessage] %s \n", tinker.getTinkerLoadResultIfPresent().getPackageConfigByName("patchMessage")));
+            sb.append(String.format("[TINKER_ID Rom Space] %d k \n", tinker.getTinkerRomSpace()));
+
+        } else {
+            sb.append(String.format("[patch is not loaded] \n"));
+            sb.append(String.format("[buildConfig TINKER_ID] %s \n", BuildInfo.TINKER_ID));
+            sb.append(String.format("[buildConfig BASE_TINKER_ID] %s \n", BaseBuildInfo.BASE_TINKER_ID));
+
+            sb.append(String.format("[buildConfig MESSSAGE] %s \n", BuildInfo.MESSAGE));
+            sb.append(String.format("[TINKER_ID] %s \n", ShareTinkerInternals.getManifestTinkerID(getApplicationContext())));
+        }
+        sb.append(String.format("[BaseBuildInfo Message] %s \n", BaseBuildInfo.TEST_MESSAGE));
+
+        final TextView v = new TextView(context);
+        v.setText(sb);
+        v.setGravity(Gravity.LEFT | Gravity.CENTER_VERTICAL);
+        v.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 10);
+        v.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT));
+        v.setTextColor(0xFF000000);
+        v.setTypeface(Typeface.MONOSPACE);
+        final int padding = 16;
+        v.setPadding(padding, padding, padding, padding);
+
+        final AlertDialog.Builder builder = new AlertDialog.Builder(context);
+        builder.setCancelable(true);
+        builder.setView(v);
+        final AlertDialog alert = builder.create();
+        alert.show();
+        return true;
+    }
+
+    @Override
+    protected void onResume() {
+        Log.e(TAG, "i am on onResume");
+//        Log.e(TAG, "i am on patch onResume");
+
+        super.onResume();
+        Utils.setBackground(false);
+
+    }
+
+    @Override
+    protected void onPause() {
+        super.onPause();
+        Utils.setBackground(true);
+    }
+}
diff --git a/tinker_souce_android/src/main/java/com/tinker/tinker_souce_android/app/SampleApplicationLike.java b/tinker_souce_android/src/main/java/com/tinker/tinker_souce_android/app/SampleApplicationLike.java
new file mode 100644
index 00000000..d3f134fd
--- /dev/null
+++ b/tinker_souce_android/src/main/java/com/tinker/tinker_souce_android/app/SampleApplicationLike.java
@@ -0,0 +1,105 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tinker.tinker_souce_android.app;
+
+import android.annotation.TargetApi;
+import android.app.Application;
+import android.content.Context;
+import android.content.Intent;
+import android.os.Build;
+import android.support.multidex.MultiDex;
+
+import com.tencent.tinker.anno.DefaultLifeCycle;
+import com.tencent.tinker.lib.tinker.Tinker;
+import com.tencent.tinker.lib.tinker.TinkerInstaller;
+import com.tencent.tinker.loader.app.ApplicationLifeCycle;
+import com.tencent.tinker.loader.app.DefaultApplicationLike;
+import com.tencent.tinker.loader.shareutil.ShareConstants;
+import com.tinker.tinker_souce_android.Log.MyLogImp;
+import com.tinker.tinker_souce_android.util.SampleApplicationContext;
+import com.tinker.tinker_souce_android.util.TinkerManager;
+
+
+/**
+ * because you can not use any other class in your application, we need to
+ * move your implement of Application to {@link ApplicationLifeCycle}
+ * As Application, all its direct reference class should be in the main dex.
+ *
+ * We use tinker-android-anno to make sure all your classes can be patched.
+ *
+ * application: if it is start with '.', we will add SampleApplicationLifeCycle's package name
+ *
+ * flags:
+ * TINKER_ENABLE_ALL: support dex, lib and resource
+ * TINKER_DEX_MASK: just support dex
+ * TINKER_NATIVE_LIBRARY_MASK: just support lib
+ * TINKER_RESOURCE_MASK: just support resource
+ *
+ * loaderClass: define the tinker loader class, we can just use the default TinkerLoader
+ *
+ * loadVerifyFlag: whether check files' md5 on the load time, defualt it is false.
+ *
+ * Created by zhangshaowen on 16/3/17.
+ */
+@SuppressWarnings("unused")
+@DefaultLifeCycle(application = "com.tinker.tinker_souce_android.app.SampleApplication",
+                  flags = ShareConstants.TINKER_ENABLE_ALL,
+                  loadVerifyFlag = false)
+public class SampleApplicationLike extends DefaultApplicationLike {
+    private static final String TAG = "Tinker.SampleApplicationLike";
+
+    public SampleApplicationLike(Application application, int tinkerFlags, boolean tinkerLoadVerifyFlag,
+                                 long applicationStartElapsedTime, long applicationStartMillisTime, Intent tinkerResultIntent) {
+        super(application, tinkerFlags, tinkerLoadVerifyFlag, applicationStartElapsedTime, applicationStartMillisTime, tinkerResultIntent);
+    }
+
+    /**
+     * install multiDex before install tinker
+     * so we don't need to put the tinker lib classes in the main dex
+     *
+     * @param base
+     */
+    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
+    @Override
+    public void onBaseContextAttached(Context base) {
+        super.onBaseContextAttached(base);
+        //you must install multiDex whatever tinker is installed!
+        MultiDex.install(base);
+
+        SampleApplicationContext.application = getApplication();
+        SampleApplicationContext.context = getApplication();
+        TinkerManager.setTinkerApplicationLike(this);
+
+        TinkerManager.initFastCrashProtect();
+        //should set before tinker is installed
+        TinkerManager.setUpgradeRetryEnable(true);
+
+        //optional set logIml, or you can use default debug log
+        TinkerInstaller.setLogIml(new MyLogImp());
+
+        //installTinker after load multiDex
+        //or you can put com.tencent.tinker.** to main dex
+        TinkerManager.installTinker(this);
+        Tinker tinker = Tinker.with(getApplication());
+    }
+
+    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
+    public void registerActivityLifecycleCallbacks(Application.ActivityLifecycleCallbacks callback) {
+        getApplication().registerActivityLifecycleCallbacks(callback);
+    }
+
+}
diff --git a/tinker_souce_android/src/main/java/com/tinker/tinker_souce_android/crash/SampleUncaughtExceptionHandler.java b/tinker_souce_android/src/main/java/com/tinker/tinker_souce_android/crash/SampleUncaughtExceptionHandler.java
new file mode 100644
index 00000000..b73df256
--- /dev/null
+++ b/tinker_souce_android/src/main/java/com/tinker/tinker_souce_android/crash/SampleUncaughtExceptionHandler.java
@@ -0,0 +1,142 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tinker.tinker_souce_android.crash;
+
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.os.SystemClock;
+
+import com.tencent.tinker.lib.tinker.TinkerApplicationHelper;
+import com.tencent.tinker.lib.util.TinkerLog;
+import com.tencent.tinker.loader.app.ApplicationLike;
+import com.tencent.tinker.loader.shareutil.ShareConstants;
+import com.tencent.tinker.loader.shareutil.ShareTinkerInternals;
+import com.tinker.tinker_souce_android.reporter.SampleTinkerReport;
+import com.tinker.tinker_souce_android.util.TinkerManager;
+import com.tinker.tinker_souce_android.util.Utils;
+
+/**
+ * optional, use dynamic configuration is better way
+ * for native crash,
+ * <p/>
+ * Created by zhangshaowen on 16/7/3.
+ * tinker's crash is caught by {@code LoadReporter.onLoadException}
+ * use {@code TinkerApplicationHelper} api, no need to install tinker!
+ */
+public class SampleUncaughtExceptionHandler implements Thread.UncaughtExceptionHandler {
+    private static final String TAG = "Tinker.SampleUncaughtExHandler";
+
+    private final Thread.UncaughtExceptionHandler ueh;
+    private static final long   QUICK_CRASH_ELAPSE  = 10 * 1000;
+    public static final  int    MAX_CRASH_COUNT     = 3;
+    private static final String DALVIK_XPOSED_CRASH = "Class ref in pre-verified class resolved to unexpected implementation";
+
+    public SampleUncaughtExceptionHandler() {
+        ueh = Thread.getDefaultUncaughtExceptionHandler();
+    }
+
+    @Override
+    public void uncaughtException(Thread thread, Throwable ex) {
+        TinkerLog.e(TAG, "uncaughtException:" + ex.getMessage());
+        tinkerFastCrashProtect();
+        tinkerPreVerifiedCrashHandler(ex);
+        ueh.uncaughtException(thread, ex);
+    }
+
+    /**
+     * Such as Xposed, if it try to load some class before we load from patch files.
+     * With dalvik, it will crash with "Class ref in pre-verified class resolved to unexpected implementation".
+     * With art, it may crash at some times. But we can't know the actual crash type.
+     * If it use Xposed, we can just clean patch or mention user to uninstall it.
+     */
+    private void tinkerPreVerifiedCrashHandler(Throwable ex) {
+        Throwable throwable = ex;
+        boolean isXposed = false;
+        while (throwable != null) {
+            if (!isXposed) {
+                isXposed = Utils.isXposedExists(throwable);
+            }
+            if (isXposed) {
+                //method 1
+                ApplicationLike applicationLike = TinkerManager.getTinkerApplicationLike();
+                if (applicationLike == null || applicationLike.getApplication() == null) {
+                    return;
+                }
+
+                if (!TinkerApplicationHelper.isTinkerLoadSuccess(applicationLike)) {
+                    return;
+                }
+                boolean isCausedByXposed = false;
+                //for art, we can't know the actually crash type
+                //just ignore art
+                if (throwable instanceof IllegalAccessError && throwable.getMessage().contains(DALVIK_XPOSED_CRASH)) {
+                    //for dalvik, we know the actual crash type
+                    isCausedByXposed = true;
+                }
+
+                if (isCausedByXposed) {
+                    SampleTinkerReport.onXposedCrash();
+                    TinkerLog.e(TAG, "have xposed: just clean tinker");
+                    //kill all other process to ensure that all process's code is the same.
+                    ShareTinkerInternals.killAllOtherProcess(applicationLike.getApplication());
+
+                    TinkerApplicationHelper.cleanPatch(applicationLike);
+                    ShareTinkerInternals.setTinkerDisableWithSharedPreferences(applicationLike.getApplication());
+                    return;
+                }
+            }
+            throwable = throwable.getCause();
+        }
+    }
+
+    /**
+     * if tinker is load, and it crash more than MAX_CRASH_COUNT, then we just clean patch.
+     */
+    private boolean tinkerFastCrashProtect() {
+        ApplicationLike applicationLike = TinkerManager.getTinkerApplicationLike();
+
+        if (applicationLike == null || applicationLike.getApplication() == null) {
+            return false;
+        }
+        if (!TinkerApplicationHelper.isTinkerLoadSuccess(applicationLike)) {
+            return false;
+        }
+
+        final long elapsedTime = SystemClock.elapsedRealtime() - applicationLike.getApplicationStartElapsedTime();
+        //this process may not install tinker, so we use TinkerApplicationHelper api
+        if (elapsedTime < QUICK_CRASH_ELAPSE) {
+            String currentVersion = TinkerApplicationHelper.getCurrentVersion(applicationLike);
+            if (ShareTinkerInternals.isNullOrNil(currentVersion)) {
+                return false;
+            }
+
+            SharedPreferences sp = applicationLike.getApplication().getSharedPreferences(ShareConstants.TINKER_SHARE_PREFERENCE_CONFIG, Context.MODE_MULTI_PROCESS);
+            int fastCrashCount = sp.getInt(currentVersion, 0) + 1;
+            if (fastCrashCount >= MAX_CRASH_COUNT) {
+                SampleTinkerReport.onFastCrashProtect();
+                TinkerApplicationHelper.cleanPatch(applicationLike);
+                TinkerLog.e(TAG, "tinker has fast crash more than %d, we just clean patch!", fastCrashCount);
+                return true;
+            } else {
+                sp.edit().putInt(currentVersion, fastCrashCount).commit();
+                TinkerLog.e(TAG, "tinker has fast crash %d times", fastCrashCount);
+            }
+        }
+
+        return false;
+    }
+}
diff --git a/tinker_souce_android/src/main/java/com/tinker/tinker_souce_android/reporter/SampleLoadReporter.java b/tinker_souce_android/src/main/java/com/tinker/tinker_souce_android/reporter/SampleLoadReporter.java
new file mode 100644
index 00000000..e3dc722d
--- /dev/null
+++ b/tinker_souce_android/src/main/java/com/tinker/tinker_souce_android/reporter/SampleLoadReporter.java
@@ -0,0 +1,141 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tinker.tinker_souce_android.reporter;
+
+import android.content.Context;
+import android.os.Looper;
+import android.os.MessageQueue;
+
+import com.tencent.tinker.lib.reporter.DefaultLoadReporter;
+import com.tencent.tinker.lib.tinker.Tinker;
+import com.tencent.tinker.lib.tinker.TinkerInstaller;
+import com.tencent.tinker.lib.util.TinkerLog;
+import com.tencent.tinker.loader.shareutil.ShareConstants;
+import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
+import com.tencent.tinker.loader.shareutil.ShareTinkerInternals;
+import com.tinker.tinker_souce_android.util.UpgradePatchRetry;
+
+import java.io.File;
+
+
+/**
+ * optional, you can just use DefaultLoadReporter
+ * Created by zhangshaowen on 16/4/13.
+ */
+public class SampleLoadReporter extends DefaultLoadReporter {
+    private final static String TAG = "Tinker.SampleLoadReporter";
+
+    public SampleLoadReporter(Context context) {
+        super(context);
+    }
+
+    @Override
+    public void onLoadPatchListenerReceiveFail(final File patchFile, int errorCode) {
+        super.onLoadPatchListenerReceiveFail(patchFile, errorCode);
+        SampleTinkerReport.onTryApplyFail(errorCode);
+    }
+
+    @Override
+    public void onLoadResult(File patchDirectory, int loadCode, long cost) {
+        super.onLoadResult(patchDirectory, loadCode, cost);
+        switch (loadCode) {
+            case ShareConstants.ERROR_LOAD_OK:
+                SampleTinkerReport.onLoaded(cost);
+                break;
+        }
+        Looper.getMainLooper().myQueue().addIdleHandler(new MessageQueue.IdleHandler() {
+            @Override public boolean queueIdle() {
+                UpgradePatchRetry.getInstance(context).onPatchRetryLoad();
+                return false;
+            }
+        });
+    }
+    @Override
+    public void onLoadException(Throwable e, int errorCode) {
+        super.onLoadException(e, errorCode);
+        switch (errorCode) {
+            case ShareConstants.ERROR_LOAD_EXCEPTION_UNCAUGHT:
+                String uncaughtString = SharePatchFileUtil.checkTinkerLastUncaughtCrash(context);
+                if (!ShareTinkerInternals.isNullOrNil(uncaughtString)) {
+                    File laseCrashFile = SharePatchFileUtil.getPatchLastCrashFile(context);
+                    SharePatchFileUtil.safeDeleteFile(laseCrashFile);
+                    // found really crash reason
+                    TinkerLog.e(TAG, "tinker uncaught real exception:" + uncaughtString);
+                }
+                break;
+        }
+        SampleTinkerReport.onLoadException(e, errorCode);
+    }
+
+    @Override
+    public void onLoadFileMd5Mismatch(File file, int fileType) {
+        super.onLoadFileMd5Mismatch(file, fileType);
+        SampleTinkerReport.onLoadFileMisMatch(fileType);
+    }
+
+    /**
+     * try to recover patch oat file
+     * @param file
+     * @param fileType
+     * @param isDirectory
+     */
+    @Override
+    public void onLoadFileNotFound(File file, int fileType, boolean isDirectory) {
+        TinkerLog.i(TAG, "patch loadReporter onLoadFileNotFound: patch file not found: %s, fileType:%d, isDirectory:%b",
+            file.getAbsolutePath(), fileType, isDirectory);
+
+        // only try to recover opt file
+        // check dex opt file at last, some phone such as VIVO/OPPO like to change dex2oat to interpreted
+        if (fileType == ShareConstants.TYPE_DEX_OPT) {
+            Tinker tinker = Tinker.with(context);
+            //we can recover at any process except recover process
+            if (tinker.isMainProcess()) {
+                File patchVersionFile = tinker.getTinkerLoadResultIfPresent().patchVersionFile;
+                if (patchVersionFile != null) {
+                    if (UpgradePatchRetry.getInstance(context).onPatchListenerCheck(SharePatchFileUtil.getMD5(patchVersionFile))) {
+                        TinkerLog.i(TAG, "try to repair oat file on patch process");
+                        TinkerInstaller.onReceiveUpgradePatch(context, patchVersionFile.getAbsolutePath());
+                    } else {
+                        TinkerLog.i(TAG, "repair retry exceed must max time, just clean");
+                        checkAndCleanPatch();
+                    }
+                }
+            }
+        } else {
+            checkAndCleanPatch();
+        }
+        SampleTinkerReport.onLoadFileNotFound(fileType);
+    }
+
+    @Override
+    public void onLoadPackageCheckFail(File patchFile, int errorCode) {
+        super.onLoadPackageCheckFail(patchFile, errorCode);
+        SampleTinkerReport.onLoadPackageCheckFail(errorCode);
+    }
+
+    @Override
+    public void onLoadPatchInfoCorrupted(String oldVersion, String newVersion, File patchInfoFile) {
+        super.onLoadPatchInfoCorrupted(oldVersion, newVersion, patchInfoFile);
+        SampleTinkerReport.onLoadInfoCorrupted();
+    }
+
+    @Override
+    public void onLoadPatchVersionChanged(String oldVersion, String newVersion, File patchDirectoryFile, String currentPatchName) {
+        super.onLoadPatchVersionChanged(oldVersion, newVersion, patchDirectoryFile, currentPatchName);
+    }
+
+}
diff --git a/tinker_souce_android/src/main/java/com/tinker/tinker_souce_android/reporter/SamplePatchListener.java b/tinker_souce_android/src/main/java/com/tinker/tinker_souce_android/reporter/SamplePatchListener.java
new file mode 100644
index 00000000..ab069422
--- /dev/null
+++ b/tinker_souce_android/src/main/java/com/tinker/tinker_souce_android/reporter/SamplePatchListener.java
@@ -0,0 +1,123 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tinker.tinker_souce_android.reporter;
+
+import android.app.ActivityManager;
+import android.content.Context;
+import android.content.SharedPreferences;
+
+import com.tencent.tinker.lib.listener.DefaultPatchListener;
+import com.tencent.tinker.lib.tinker.Tinker;
+import com.tencent.tinker.lib.tinker.TinkerLoadResult;
+import com.tencent.tinker.lib.util.TinkerLog;
+import com.tencent.tinker.loader.shareutil.ShareConstants;
+import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
+import com.tencent.tinker.loader.shareutil.ShareTinkerInternals;
+import com.tinker.tinker_souce_android.app.BuildInfo;
+import com.tinker.tinker_souce_android.crash.SampleUncaughtExceptionHandler;
+import com.tinker.tinker_souce_android.util.UpgradePatchRetry;
+import com.tinker.tinker_souce_android.util.Utils;
+
+import java.io.File;
+import java.util.Properties;
+
+
+/**
+ * Created by zhangshaowen on 16/4/30.
+ * optional, you can just use DefaultPatchListener
+ * we can check whatever you want whether we actually send a patch request
+ * such as we can check rom space or apk channel
+ */
+public class SamplePatchListener extends DefaultPatchListener {
+    private static final String TAG = "Tinker.SamplePatchListener";
+
+    protected static final long NEW_PATCH_RESTRICTION_SPACE_SIZE_MIN = 60 * 1024 * 1024;
+
+    private final int maxMemory;
+
+    public SamplePatchListener(Context context) {
+        super(context);
+        maxMemory = ((ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE)).getMemoryClass();
+        TinkerLog.i(TAG, "application maxMemory:" + maxMemory);
+    }
+
+    /**
+     * because we use the defaultCheckPatchReceived method
+     * the error code define by myself should after {@code ShareConstants.ERROR_RECOVER_INSERVICE
+     *
+     * @param path
+     * @param newPatch
+     * @return
+     */
+    @Override
+    public int patchCheck(String path) {
+        File patchFile = new File(path);
+        TinkerLog.i(TAG, "receive a patch file: %s, file size:%d", path, SharePatchFileUtil.getFileOrDirectorySize(patchFile));
+        int returnCode = super.patchCheck(path);
+
+        if (returnCode == ShareConstants.ERROR_PATCH_OK) {
+            returnCode = Utils.checkForPatchRecover(NEW_PATCH_RESTRICTION_SPACE_SIZE_MIN, maxMemory);
+        }
+
+        if (returnCode == ShareConstants.ERROR_PATCH_OK) {
+            String patchMd5 = SharePatchFileUtil.getMD5(patchFile);
+            SharedPreferences sp = context.getSharedPreferences(ShareConstants.TINKER_SHARE_PREFERENCE_CONFIG, Context.MODE_MULTI_PROCESS);
+            //optional, only disable this patch file with md5
+            int fastCrashCount = sp.getInt(patchMd5, 0);
+            if (fastCrashCount >= SampleUncaughtExceptionHandler.MAX_CRASH_COUNT) {
+                returnCode = Utils.ERROR_PATCH_CRASH_LIMIT;
+            } else {
+                //for upgrade patch, version must be not the same
+                //for repair patch, we won't has the tinker load flag
+                Tinker tinker = Tinker.with(context);
+
+                if (tinker.isTinkerLoaded()) {
+                    TinkerLoadResult tinkerLoadResult = tinker.getTinkerLoadResultIfPresent();
+                    if (tinkerLoadResult != null) {
+                        String currentVersion = tinkerLoadResult.currentVersion;
+                        if (patchMd5.equals(currentVersion)) {
+                            returnCode = Utils.ERROR_PATCH_ALREADY_APPLY;
+                        }
+                    }
+                }
+            }
+            //check whether retry so many times
+            if (returnCode == ShareConstants.ERROR_PATCH_OK) {
+                returnCode = UpgradePatchRetry.getInstance(context).onPatchListenerCheck(patchMd5)
+                    ? ShareConstants.ERROR_PATCH_OK : Utils.ERROR_PATCH_RETRY_COUNT_LIMIT;
+            }
+        }
+        // Warning, it is just a sample case, you don't need to copy all of these
+        // Interception some of the request
+        if (returnCode == ShareConstants.ERROR_PATCH_OK) {
+            Properties properties = ShareTinkerInternals.fastGetPatchPackageMeta(patchFile);
+            if (properties == null) {
+                returnCode = Utils.ERROR_PATCH_CONDITION_NOT_SATISFIED;
+            } else {
+                String platform = properties.getProperty(Utils.PLATFORM);
+                TinkerLog.i(TAG, "get platform:" + platform);
+                // check patch platform require
+                if (platform == null || !platform.equals(BuildInfo.PLATFORM)) {
+                    returnCode = Utils.ERROR_PATCH_CONDITION_NOT_SATISFIED;
+                }
+            }
+        }
+
+        SampleTinkerReport.onTryApply(returnCode == ShareConstants.ERROR_PATCH_OK);
+        return returnCode;
+    }
+}
diff --git a/tinker_souce_android/src/main/java/com/tinker/tinker_souce_android/reporter/SamplePatchReporter.java b/tinker_souce_android/src/main/java/com/tinker/tinker_souce_android/reporter/SamplePatchReporter.java
new file mode 100644
index 00000000..4eae0d4d
--- /dev/null
+++ b/tinker_souce_android/src/main/java/com/tinker/tinker_souce_android/reporter/SamplePatchReporter.java
@@ -0,0 +1,87 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tinker.tinker_souce_android.reporter;
+
+import android.content.Context;
+import android.content.Intent;
+
+import com.tencent.tinker.lib.reporter.DefaultPatchReporter;
+import com.tencent.tinker.loader.shareutil.SharePatchInfo;
+import com.tinker.tinker_souce_android.util.UpgradePatchRetry;
+
+import java.io.File;
+
+
+/**
+ * optional, you can just use DefaultPatchReporter
+ * Created by zhangshaowen on 16/4/8.
+ */
+public class SamplePatchReporter extends DefaultPatchReporter {
+    public SamplePatchReporter(Context context) {
+        super(context);
+    }
+
+    @Override
+    public void onPatchServiceStart(Intent intent) {
+        super.onPatchServiceStart(intent);
+        SampleTinkerReport.onApplyPatchServiceStart();
+        UpgradePatchRetry.getInstance(context).onPatchServiceStart(intent);
+    }
+
+    @Override
+    public void onPatchDexOptFail(File patchFile, File dexFile, String optDirectory, String dexName, Throwable t) {
+        super.onPatchDexOptFail(patchFile, dexFile, optDirectory, dexName, t);
+        SampleTinkerReport.onApplyDexOptFail(t);
+    }
+
+    @Override
+    public void onPatchException(File patchFile, Throwable e) {
+        super.onPatchException(patchFile, e);
+        SampleTinkerReport.onApplyCrash(e);
+    }
+
+    @Override
+    public void onPatchInfoCorrupted(File patchFile, String oldVersion, String newVersion) {
+        super.onPatchInfoCorrupted(patchFile, oldVersion, newVersion);
+        SampleTinkerReport.onApplyInfoCorrupted();
+    }
+
+    @Override
+    public void onPatchPackageCheckFail(File patchFile, int errorCode) {
+        super.onPatchPackageCheckFail(patchFile, errorCode);
+        SampleTinkerReport.onApplyPackageCheckFail(errorCode);
+    }
+
+    @Override
+    public void onPatchResult(File patchFile, boolean success, long cost) {
+        super.onPatchResult(patchFile, success, cost);
+        SampleTinkerReport.onApplied(cost, success);
+        UpgradePatchRetry.getInstance(context).onPatchServiceResult();
+    }
+
+    @Override
+    public void onPatchTypeExtractFail(File patchFile, File extractTo, String filename, int fileType) {
+        super.onPatchTypeExtractFail(patchFile, extractTo, filename, fileType);
+        SampleTinkerReport.onApplyExtractFail(fileType);
+    }
+
+    @Override
+    public void onPatchVersionCheckFail(File patchFile, SharePatchInfo oldPatchInfo, String patchFileVersion) {
+        super.onPatchVersionCheckFail(patchFile, oldPatchInfo, patchFileVersion);
+        SampleTinkerReport.onApplyVersionCheckFail();
+    }
+}
diff --git a/tinker_souce_android/src/main/java/com/tinker/tinker_souce_android/reporter/SampleTinkerReport.java b/tinker_souce_android/src/main/java/com/tinker/tinker_souce_android/reporter/SampleTinkerReport.java
new file mode 100644
index 00000000..ce109146
--- /dev/null
+++ b/tinker_souce_android/src/main/java/com/tinker/tinker_souce_android/reporter/SampleTinkerReport.java
@@ -0,0 +1,520 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tinker.tinker_souce_android.reporter;
+
+import com.tencent.tinker.lib.util.TinkerLog;
+import com.tencent.tinker.loader.shareutil.ShareConstants;
+import com.tencent.tinker.loader.shareutil.ShareTinkerInternals;
+import com.tinker.tinker_souce_android.util.Utils;
+
+
+/**
+ * a simple tinker data reporter
+ * Created by zhangshaowen on 16/9/17.
+ */
+public class SampleTinkerReport {
+    private static final String TAG = "Tinker.SampleTinkerReport";
+
+    // KEY - PV
+    public static final int KEY_REQUEST                   = 0;
+    public static final int KEY_DOWNLOAD                  = 1;
+    public static final int KEY_TRY_APPLY                 = 2;
+    public static final int KEY_TRY_APPLY_SUCCESS         = 3;
+    public static final int KEY_APPLIED_START             = 4;
+    public static final int KEY_APPLIED                   = 5;
+    public static final int KEY_LOADED                    = 6;
+    public static final int KEY_CRASH_FAST_PROTECT        = 7;
+    public static final int KEY_CRASH_CAUSE_XPOSED_DALVIK = 8;
+    public static final int KEY_CRASH_CAUSE_XPOSED_ART    = 9;
+    public static final int KEY_APPLY_WITH_RETRY          = 10;
+
+    //Key -- try apply detail
+    public static final int KEY_TRY_APPLY_UPGRADE                 = 70;
+    public static final int KEY_TRY_APPLY_DISABLE                 = 71;
+    public static final int KEY_TRY_APPLY_RUNNING                 = 72;
+    public static final int KEY_TRY_APPLY_INSERVICE               = 73;
+    public static final int KEY_TRY_APPLY_NOT_EXIST               = 74;
+    public static final int KEY_TRY_APPLY_GOOGLEPLAY              = 75;
+    public static final int KEY_TRY_APPLY_ROM_SPACE               = 76;
+    public static final int KEY_TRY_APPLY_ALREADY_APPLY           = 77;
+    public static final int KEY_TRY_APPLY_MEMORY_LIMIT            = 78;
+    public static final int KEY_TRY_APPLY_CRASH_LIMIT             = 79;
+    public static final int KEY_TRY_APPLY_CONDITION_NOT_SATISFIED = 80;
+
+    //Key -- apply detail
+    public static final int KEY_APPLIED_UPGRADE      = 100;
+    public static final int KEY_APPLIED_UPGRADE_FAIL = 101;
+
+    public static final int KEY_APPLIED_EXCEPTION                               = 120;
+    public static final int KEY_APPLIED_DEXOPT                                  = 121;
+    public static final int KEY_APPLIED_INFO_CORRUPTED                          = 122;
+    //package check
+    public static final int KEY_APPLIED_PACKAGE_CHECK_SIGNATURE                 = 150;
+    public static final int KEY_APPLIED_PACKAGE_CHECK_DEX_META                  = 151;
+    public static final int KEY_APPLIED_PACKAGE_CHECK_LIB_META                  = 152;
+    public static final int KEY_APPLIED_PACKAGE_CHECK_APK_TINKER_ID_NOT_FOUND   = 153;
+    public static final int KEY_APPLIED_PACKAGE_CHECK_PATCH_TINKER_ID_NOT_FOUND = 154;
+    public static final int KEY_APPLIED_PACKAGE_CHECK_META_NOT_FOUND            = 155;
+    public static final int KEY_APPLIED_PACKAGE_CHECK_TINKER_ID_NOT_EQUAL       = 156;
+    public static final int KEY_APPLIED_PACKAGE_CHECK_RES_META                  = 157;
+    public static final int KEY_APPLIED_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT    = 158;
+
+    //version check
+    public static final int KEY_APPLIED_VERSION_CHECK                           = 180;
+    //extract error
+    public static final int KEY_APPLIED_PATCH_FILE_EXTRACT                      = 181;
+    public static final int KEY_APPLIED_DEX_EXTRACT                             = 182;
+    public static final int KEY_APPLIED_LIB_EXTRACT                             = 183;
+    public static final int KEY_APPLIED_RESOURCE_EXTRACT                        = 184;
+    //cost time
+    public static final int KEY_APPLIED_SUCC_COST_5S_LESS                       = 200;
+    public static final int KEY_APPLIED_SUCC_COST_10S_LESS                      = 201;
+    public static final int KEY_APPLIED_SUCC_COST_30S_LESS                      = 202;
+    public static final int KEY_APPLIED_SUCC_COST_60S_LESS                      = 203;
+    public static final int KEY_APPLIED_SUCC_COST_OTHER                         = 204;
+
+    public static final int KEY_APPLIED_FAIL_COST_5S_LESS  = 205;
+    public static final int KEY_APPLIED_FAIL_COST_10S_LESS = 206;
+    public static final int KEY_APPLIED_FAIL_COST_30S_LESS = 207;
+    public static final int KEY_APPLIED_FAIL_COST_60S_LESS = 208;
+    public static final int KEY_APPLIED_FAIL_COST_OTHER    = 209;
+
+
+    // KEY -- load detail
+    public static final int KEY_LOADED_UNKNOWN_EXCEPTION        = 250;
+    public static final int KEY_LOADED_UNCAUGHT_EXCEPTION       = 251;
+    public static final int KEY_LOADED_EXCEPTION_DEX            = 252;
+    public static final int KEY_LOADED_EXCEPTION_DEX_CHECK      = 253;
+    public static final int KEY_LOADED_EXCEPTION_RESOURCE       = 254;
+    public static final int KEY_LOADED_EXCEPTION_RESOURCE_CHECK = 255;
+
+
+    public static final int KEY_LOADED_MISMATCH_DEX       = 300;
+    public static final int KEY_LOADED_MISMATCH_LIB       = 301;
+    public static final int KEY_LOADED_MISMATCH_RESOURCE  = 302;
+    public static final int KEY_LOADED_MISSING_DEX        = 303;
+    public static final int KEY_LOADED_MISSING_LIB        = 304;
+    public static final int KEY_LOADED_MISSING_PATCH_FILE = 305;
+    public static final int KEY_LOADED_MISSING_PATCH_INFO = 306;
+    public static final int KEY_LOADED_MISSING_DEX_OPT    = 307;
+    public static final int KEY_LOADED_MISSING_RES        = 308;
+    public static final int KEY_LOADED_INFO_CORRUPTED     = 309;
+
+    //load package check
+    public static final int KEY_LOADED_PACKAGE_CHECK_SIGNATURE                 = 350;
+    public static final int KEY_LOADED_PACKAGE_CHECK_DEX_META                  = 351;
+    public static final int KEY_LOADED_PACKAGE_CHECK_LIB_META                  = 352;
+    public static final int KEY_LOADED_PACKAGE_CHECK_APK_TINKER_ID_NOT_FOUND   = 353;
+    public static final int KEY_LOADED_PACKAGE_CHECK_PATCH_TINKER_ID_NOT_FOUND = 354;
+    public static final int KEY_LOADED_PACKAGE_CHECK_TINKER_ID_NOT_EQUAL       = 355;
+    public static final int KEY_LOADED_PACKAGE_CHECK_PACKAGE_META_NOT_FOUND    = 356;
+    public static final int KEY_LOADED_PACKAGE_CHECK_RES_META                  = 357;
+    public static final int KEY_LOADED_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT    = 358;
+
+
+    public static final int KEY_LOADED_SUCC_COST_500_LESS  = 400;
+    public static final int KEY_LOADED_SUCC_COST_1000_LESS = 401;
+    public static final int KEY_LOADED_SUCC_COST_3000_LESS = 402;
+    public static final int KEY_LOADED_SUCC_COST_5000_LESS = 403;
+    public static final int KEY_LOADED_SUCC_COST_OTHER     = 404;
+
+    interface Reporter {
+        void onReport(int key);
+
+        void onReport(String message);
+    }
+
+    private static Reporter reporter = null;
+
+    public void setReporter(Reporter reporter) {
+        this.reporter = reporter;
+    }
+
+    public static void onTryApply(boolean success) {
+        if (reporter == null) {
+            return;
+        }
+        reporter.onReport(KEY_TRY_APPLY);
+
+        reporter.onReport(KEY_TRY_APPLY_UPGRADE);
+
+        if (success) {
+            reporter.onReport(KEY_TRY_APPLY_SUCCESS);
+        }
+    }
+
+    public static void onTryApplyFail(int errorCode) {
+        if (reporter == null) {
+            return;
+        }
+        switch (errorCode) {
+            case ShareConstants.ERROR_PATCH_NOTEXIST:
+                reporter.onReport(KEY_TRY_APPLY_NOT_EXIST);
+                break;
+            case ShareConstants.ERROR_PATCH_DISABLE:
+                reporter.onReport(KEY_TRY_APPLY_DISABLE);
+                break;
+            case ShareConstants.ERROR_PATCH_INSERVICE:
+                reporter.onReport(KEY_TRY_APPLY_INSERVICE);
+                break;
+            case ShareConstants.ERROR_PATCH_RUNNING:
+                reporter.onReport(KEY_TRY_APPLY_RUNNING);
+                break;
+            case Utils.ERROR_PATCH_ROM_SPACE:
+                reporter.onReport(KEY_TRY_APPLY_ROM_SPACE);
+                break;
+            case Utils.ERROR_PATCH_GOOGLEPLAY_CHANNEL:
+                reporter.onReport(KEY_TRY_APPLY_GOOGLEPLAY);
+                break;
+            case Utils.ERROR_PATCH_ALREADY_APPLY:
+                reporter.onReport(KEY_TRY_APPLY_ALREADY_APPLY);
+                break;
+            case Utils.ERROR_PATCH_CRASH_LIMIT:
+                reporter.onReport(KEY_TRY_APPLY_CRASH_LIMIT);
+                break;
+            case Utils.ERROR_PATCH_MEMORY_LIMIT:
+                reporter.onReport(KEY_TRY_APPLY_MEMORY_LIMIT);
+                break;
+            case Utils.ERROR_PATCH_CONDITION_NOT_SATISFIED:
+                reporter.onReport(KEY_TRY_APPLY_CONDITION_NOT_SATISFIED);
+                break;
+        }
+    }
+
+    public static void onLoadPackageCheckFail(int errorCode) {
+        if (reporter == null) {
+            return;
+        }
+        switch (errorCode) {
+            case ShareConstants.ERROR_PACKAGE_CHECK_SIGNATURE_FAIL:
+                reporter.onReport(KEY_LOADED_PACKAGE_CHECK_SIGNATURE);
+                break;
+            case ShareConstants.ERROR_PACKAGE_CHECK_DEX_META_CORRUPTED:
+                reporter.onReport(KEY_LOADED_PACKAGE_CHECK_DEX_META);
+                break;
+            case ShareConstants.ERROR_PACKAGE_CHECK_LIB_META_CORRUPTED:
+                reporter.onReport(KEY_LOADED_PACKAGE_CHECK_LIB_META);
+                break;
+            case ShareConstants.ERROR_PACKAGE_CHECK_PATCH_TINKER_ID_NOT_FOUND:
+                reporter.onReport(KEY_LOADED_PACKAGE_CHECK_PATCH_TINKER_ID_NOT_FOUND);
+                break;
+            case ShareConstants.ERROR_PACKAGE_CHECK_APK_TINKER_ID_NOT_FOUND:
+                reporter.onReport(KEY_LOADED_PACKAGE_CHECK_APK_TINKER_ID_NOT_FOUND);
+                break;
+            case ShareConstants.ERROR_PACKAGE_CHECK_TINKER_ID_NOT_EQUAL:
+                reporter.onReport(KEY_LOADED_PACKAGE_CHECK_TINKER_ID_NOT_EQUAL);
+
+                break;
+            case ShareConstants.ERROR_PACKAGE_CHECK_PACKAGE_META_NOT_FOUND:
+                reporter.onReport(KEY_LOADED_PACKAGE_CHECK_PACKAGE_META_NOT_FOUND);
+                break;
+            case ShareConstants.ERROR_PACKAGE_CHECK_RESOURCE_META_CORRUPTED:
+                reporter.onReport(KEY_LOADED_PACKAGE_CHECK_RES_META);
+                break;
+            case ShareConstants.ERROR_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT:
+                reporter.onReport(KEY_LOADED_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT);
+                break;
+        }
+    }
+
+    public static void onLoaded(long cost) {
+        if (reporter == null) {
+            return;
+        }
+        reporter.onReport(KEY_LOADED);
+
+        if (cost < 0L) {
+            TinkerLog.e(TAG, "hp_report report load cost failed, invalid cost");
+            return;
+        }
+
+        if (cost <= 500) {
+            reporter.onReport(KEY_LOADED_SUCC_COST_500_LESS);
+        } else if (cost <= 1000) {
+            reporter.onReport(KEY_LOADED_SUCC_COST_1000_LESS);
+        } else if (cost <= 3000) {
+            reporter.onReport(KEY_LOADED_SUCC_COST_3000_LESS);
+        } else if (cost <= 5000) {
+            reporter.onReport(KEY_LOADED_SUCC_COST_5000_LESS);
+        } else {
+            reporter.onReport(KEY_LOADED_SUCC_COST_OTHER);
+        }
+    }
+
+    public static void onLoadInfoCorrupted() {
+        if (reporter == null) {
+            return;
+        }
+        reporter.onReport(KEY_LOADED_INFO_CORRUPTED);
+    }
+
+    public static void onLoadFileNotFound(int fileType) {
+        if (reporter == null) {
+            return;
+        }
+        switch (fileType) {
+            case ShareConstants.TYPE_DEX_OPT:
+                reporter.onReport(KEY_LOADED_MISSING_DEX_OPT);
+                break;
+            case ShareConstants.TYPE_DEX:
+                reporter.onReport(KEY_LOADED_MISSING_DEX);
+                break;
+            case ShareConstants.TYPE_LIBRARY:
+                reporter.onReport(KEY_LOADED_MISSING_LIB);
+                break;
+            case ShareConstants.TYPE_PATCH_FILE:
+                reporter.onReport(KEY_LOADED_MISSING_PATCH_FILE);
+                break;
+            case ShareConstants.TYPE_PATCH_INFO:
+                reporter.onReport(KEY_LOADED_MISSING_PATCH_INFO);
+                break;
+            case ShareConstants.TYPE_RESOURCE:
+                reporter.onReport(KEY_LOADED_MISSING_RES);
+                break;
+        }
+    }
+
+    public static void onLoadFileMisMatch(int fileType) {
+        if (reporter == null) {
+            return;
+        }
+        switch (fileType) {
+            case ShareConstants.TYPE_DEX:
+                reporter.onReport(KEY_LOADED_MISMATCH_DEX);
+                break;
+            case ShareConstants.TYPE_LIBRARY:
+                reporter.onReport(KEY_LOADED_MISMATCH_LIB);
+                break;
+            case ShareConstants.TYPE_RESOURCE:
+                reporter.onReport(KEY_LOADED_MISMATCH_RESOURCE);
+                break;
+        }
+    }
+
+    public static void onLoadException(Throwable throwable, int errorCode) {
+        if (reporter == null) {
+            return;
+        }
+        boolean isCheckFail = false;
+        switch (errorCode) {
+            case ShareConstants.ERROR_LOAD_EXCEPTION_DEX:
+                if (throwable.getMessage().contains(ShareConstants.CHECK_DEX_INSTALL_FAIL)) {
+                    reporter.onReport(KEY_LOADED_EXCEPTION_DEX_CHECK);
+                    isCheckFail = true;
+                    TinkerLog.e(TAG, "tinker dex check fail:" + throwable.getMessage());
+                } else {
+                    reporter.onReport(KEY_LOADED_EXCEPTION_DEX);
+                    TinkerLog.e(TAG, "tinker dex reflect fail:" + throwable.getMessage());
+                }
+                break;
+            case ShareConstants.ERROR_LOAD_EXCEPTION_RESOURCE:
+                if (throwable.getMessage().contains(ShareConstants.CHECK_RES_INSTALL_FAIL)) {
+                    reporter.onReport(KEY_LOADED_EXCEPTION_RESOURCE_CHECK);
+                    isCheckFail = true;
+                    TinkerLog.e(TAG, "tinker res check fail:" + throwable.getMessage());
+                } else {
+                    reporter.onReport(KEY_LOADED_EXCEPTION_RESOURCE);
+                    TinkerLog.e(TAG, "tinker res reflect fail:" + throwable.getMessage());
+                }
+                break;
+            case ShareConstants.ERROR_LOAD_EXCEPTION_UNCAUGHT:
+                reporter.onReport(KEY_LOADED_UNCAUGHT_EXCEPTION);
+                break;
+            case ShareConstants.ERROR_LOAD_EXCEPTION_UNKNOWN:
+                reporter.onReport(KEY_LOADED_UNKNOWN_EXCEPTION);
+                break;
+        }
+        //reporter exception, for dex check fail, we don't need to report stacktrace
+        if (!isCheckFail) {
+            reporter.onReport("Tinker Exception:load tinker occur exception " + Utils.getExceptionCauseString(throwable));
+        }
+    }
+
+    public static void onApplyPatchServiceStart() {
+        if (reporter == null) {
+            return;
+        }
+        reporter.onReport(KEY_APPLIED_START);
+    }
+
+    public static void onApplyDexOptFail(Throwable throwable) {
+        if (reporter == null) {
+            return;
+        }
+        reporter.onReport(KEY_APPLIED_DEXOPT);
+        reporter.onReport("Tinker Exception:apply tinker occur exception " + Utils.getExceptionCauseString(throwable));
+    }
+
+    public static void onApplyInfoCorrupted() {
+        if (reporter == null) {
+            return;
+        }
+        reporter.onReport(KEY_APPLIED_INFO_CORRUPTED);
+    }
+
+    public static void onApplyVersionCheckFail() {
+        if (reporter == null) {
+            return;
+        }
+        reporter.onReport(KEY_APPLIED_VERSION_CHECK);
+    }
+
+    public static void onApplyExtractFail(int fileType) {
+        if (reporter == null) {
+            return;
+        }
+        switch (fileType) {
+            case ShareConstants.TYPE_DEX:
+                reporter.onReport(KEY_APPLIED_DEX_EXTRACT);
+                break;
+            case ShareConstants.TYPE_LIBRARY:
+                reporter.onReport(KEY_APPLIED_LIB_EXTRACT);
+                break;
+            case ShareConstants.TYPE_PATCH_FILE:
+                reporter.onReport(KEY_APPLIED_PATCH_FILE_EXTRACT);
+                break;
+            case ShareConstants.TYPE_RESOURCE:
+                reporter.onReport(KEY_APPLIED_RESOURCE_EXTRACT);
+                break;
+        }
+    }
+
+    public static void onApplied(long cost, boolean success) {
+        if (reporter == null) {
+            return;
+        }
+        if (success) {
+            reporter.onReport(KEY_APPLIED);
+        }
+
+        if (success) {
+            reporter.onReport(KEY_APPLIED_UPGRADE);
+        } else {
+            reporter.onReport(KEY_APPLIED_UPGRADE_FAIL);
+        }
+
+        TinkerLog.i(TAG, "hp_report report apply cost = %d", cost);
+
+        if (cost < 0L) {
+            TinkerLog.e(TAG, "hp_report report apply cost failed, invalid cost");
+            return;
+        }
+
+        if (cost <= 5000) {
+            if (success) {
+                reporter.onReport(KEY_APPLIED_SUCC_COST_5S_LESS);
+            } else {
+                reporter.onReport(KEY_APPLIED_FAIL_COST_5S_LESS);
+            }
+        } else if (cost <= 10 * 1000) {
+            if (success) {
+                reporter.onReport(KEY_APPLIED_SUCC_COST_10S_LESS);
+            } else {
+                reporter.onReport(KEY_APPLIED_FAIL_COST_10S_LESS);
+            }
+        } else if (cost <= 30 * 1000) {
+            if (success) {
+                reporter.onReport(KEY_APPLIED_SUCC_COST_30S_LESS);
+            } else {
+                reporter.onReport(KEY_APPLIED_FAIL_COST_30S_LESS);
+            }
+        } else if (cost <= 60 * 1000) {
+            if (success) {
+                reporter.onReport(KEY_APPLIED_SUCC_COST_60S_LESS);
+            } else {
+                reporter.onReport(KEY_APPLIED_FAIL_COST_60S_LESS);
+            }
+        } else {
+            if (success) {
+                reporter.onReport(KEY_APPLIED_SUCC_COST_OTHER);
+            } else {
+                reporter.onReport(KEY_APPLIED_FAIL_COST_OTHER);
+            }
+        }
+    }
+
+    public static void onApplyPackageCheckFail(int errorCode) {
+        if (reporter == null) {
+            return;
+        }
+        TinkerLog.i(TAG, "hp_report package check failed, error = %d", errorCode);
+
+        switch (errorCode) {
+            case ShareConstants.ERROR_PACKAGE_CHECK_SIGNATURE_FAIL:
+                reporter.onReport(KEY_APPLIED_PACKAGE_CHECK_SIGNATURE);
+                break;
+            case ShareConstants.ERROR_PACKAGE_CHECK_DEX_META_CORRUPTED:
+                reporter.onReport(KEY_APPLIED_PACKAGE_CHECK_DEX_META);
+                break;
+            case ShareConstants.ERROR_PACKAGE_CHECK_LIB_META_CORRUPTED:
+                reporter.onReport(KEY_APPLIED_PACKAGE_CHECK_LIB_META);
+                break;
+            case ShareConstants.ERROR_PACKAGE_CHECK_PATCH_TINKER_ID_NOT_FOUND:
+                reporter.onReport(KEY_APPLIED_PACKAGE_CHECK_PATCH_TINKER_ID_NOT_FOUND);
+                break;
+            case ShareConstants.ERROR_PACKAGE_CHECK_APK_TINKER_ID_NOT_FOUND:
+                reporter.onReport(KEY_APPLIED_PACKAGE_CHECK_APK_TINKER_ID_NOT_FOUND);
+                break;
+            case ShareConstants.ERROR_PACKAGE_CHECK_TINKER_ID_NOT_EQUAL:
+                reporter.onReport(KEY_APPLIED_PACKAGE_CHECK_TINKER_ID_NOT_EQUAL);
+                break;
+            case ShareConstants.ERROR_PACKAGE_CHECK_PACKAGE_META_NOT_FOUND:
+                reporter.onReport(KEY_APPLIED_PACKAGE_CHECK_META_NOT_FOUND);
+                break;
+            case ShareConstants.ERROR_PACKAGE_CHECK_RESOURCE_META_CORRUPTED:
+                reporter.onReport(KEY_APPLIED_PACKAGE_CHECK_RES_META);
+                break;
+            case ShareConstants.ERROR_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT:
+                reporter.onReport(KEY_APPLIED_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT);
+                break;
+        }
+    }
+
+    public static void onApplyCrash(Throwable throwable) {
+        if (reporter == null) {
+            return;
+        }
+        reporter.onReport(KEY_APPLIED_EXCEPTION);
+        reporter.onReport("Tinker Exception:apply tinker occur exception " + Utils.getExceptionCauseString(throwable));
+    }
+
+    public static void onFastCrashProtect() {
+        if (reporter == null) {
+            return;
+        }
+        reporter.onReport(KEY_CRASH_FAST_PROTECT);
+    }
+
+    public static void onXposedCrash() {
+        if (reporter == null) {
+            return;
+        }
+        if (ShareTinkerInternals.isVmArt()) {
+            reporter.onReport(KEY_CRASH_CAUSE_XPOSED_ART);
+        } else {
+            reporter.onReport(KEY_CRASH_CAUSE_XPOSED_DALVIK);
+        }
+    }
+
+    public static void onReportRetryPatch() {
+        if (reporter == null) {
+            return;
+        }
+        reporter.onReport(KEY_APPLY_WITH_RETRY);
+    }
+
+}
diff --git a/tinker_souce_android/src/main/java/com/tinker/tinker_souce_android/service/SampleResultService.java b/tinker_souce_android/src/main/java/com/tinker/tinker_souce_android/service/SampleResultService.java
new file mode 100644
index 00000000..e8c4b813
--- /dev/null
+++ b/tinker_souce_android/src/main/java/com/tinker/tinker_souce_android/service/SampleResultService.java
@@ -0,0 +1,131 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tinker.tinker_souce_android.service;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.os.Handler;
+import android.os.Looper;
+import android.widget.Toast;
+
+import com.tencent.tinker.lib.service.DefaultTinkerResultService;
+import com.tencent.tinker.lib.service.PatchResult;
+import com.tencent.tinker.lib.util.TinkerLog;
+import com.tencent.tinker.lib.util.TinkerServiceInternals;
+import com.tinker.tinker_souce_android.util.Utils;
+
+import java.io.File;
+
+
+/**
+ * optional, you can just use DefaultTinkerResultService
+ * we can restart process when we are at background or screen off
+ * Created by zhangshaowen on 16/4/13.
+ */
+public class SampleResultService extends DefaultTinkerResultService {
+    private static final String TAG = "Tinker.SampleResultService";
+
+
+    @Override
+    public void onPatchResult(final PatchResult result) {
+        if (result == null) {
+            TinkerLog.e(TAG, "SampleResultService received null result!!!!");
+            return;
+        }
+        TinkerLog.i(TAG, "SampleResultService receive result: %s", result.toString());
+
+        //first, we want to kill the recover process
+        TinkerServiceInternals.killTinkerPatchServiceProcess(getApplicationContext());
+
+        Handler handler = new Handler(Looper.getMainLooper());
+        handler.post(new Runnable() {
+            @Override
+            public void run() {
+                if (result.isSuccess) {
+                    Toast.makeText(getApplicationContext(), "patch success, please restart process", Toast.LENGTH_LONG).show();
+                } else {
+                    Toast.makeText(getApplicationContext(), "patch fail, please check reason", Toast.LENGTH_LONG).show();
+                }
+            }
+        });
+        // is success and newPatch, it is nice to delete the raw file, and restart at once
+        // for old patch, you can't delete the patch file
+        if (result.isSuccess) {
+            deleteRawPatchFile(new File(result.rawPatchFilePath));
+
+            //not like TinkerResultService, I want to restart just when I am at background!
+            //if you have not install tinker this moment, you can use TinkerApplicationHelper api
+            if (checkIfNeedKill(result)) {
+                if (Utils.isBackground()) {
+                    TinkerLog.i(TAG, "it is in background, just restart process");
+                    restartProcess();
+                } else {
+                    //we can wait process at background, such as onAppBackground
+                    //or we can restart when the screen off
+                    TinkerLog.i(TAG, "tinker wait screen to restart process");
+                    new ScreenState(getApplicationContext(), new ScreenState.IOnScreenOff() {
+                        @Override
+                        public void onScreenOff() {
+                            restartProcess();
+                        }
+                    });
+                }
+            } else {
+                TinkerLog.i(TAG, "I have already install the newly patch version!");
+            }
+        }
+    }
+
+    /**
+     * you can restart your process through service or broadcast
+     */
+    private void restartProcess() {
+        TinkerLog.i(TAG, "app is background now, i can kill quietly");
+        //you can send service or broadcast intent to restart your process
+        android.os.Process.killProcess(android.os.Process.myPid());
+    }
+
+    static class ScreenState {
+        interface IOnScreenOff {
+            void onScreenOff();
+        }
+
+        ScreenState(Context context, final IOnScreenOff onScreenOffInterface) {
+            IntentFilter filter = new IntentFilter();
+            filter.addAction(Intent.ACTION_SCREEN_OFF);
+            context.registerReceiver(new BroadcastReceiver() {
+
+                @Override
+                public void onReceive(Context context, Intent in) {
+                    String action = in == null ? "" : in.getAction();
+                    TinkerLog.i(TAG, "ScreenReceiver action [%s] ", action);
+                    if (Intent.ACTION_SCREEN_OFF.equals(action)) {
+
+                        context.unregisterReceiver(this);
+
+                        if (onScreenOffInterface != null) {
+                            onScreenOffInterface.onScreenOff();
+                        }
+                    }
+                }
+            }, filter);
+        }
+    }
+
+}
diff --git a/tinker_souce_android/src/main/java/com/tinker/tinker_souce_android/util/SampleApplicationContext.java b/tinker_souce_android/src/main/java/com/tinker/tinker_souce_android/util/SampleApplicationContext.java
new file mode 100644
index 00000000..15992371
--- /dev/null
+++ b/tinker_souce_android/src/main/java/com/tinker/tinker_souce_android/util/SampleApplicationContext.java
@@ -0,0 +1,28 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tinker.tinker_souce_android.util;
+
+import android.app.Application;
+import android.content.Context;
+
+/**
+ * Created by zhangshaowen on 16/8/9.
+ */
+public class SampleApplicationContext {
+    public static Application application = null;
+    public static Context context = null;
+}
diff --git a/tinker_souce_android/src/main/java/com/tinker/tinker_souce_android/util/TinkerManager.java b/tinker_souce_android/src/main/java/com/tinker/tinker_souce_android/util/TinkerManager.java
new file mode 100644
index 00000000..793ff28b
--- /dev/null
+++ b/tinker_souce_android/src/main/java/com/tinker/tinker_souce_android/util/TinkerManager.java
@@ -0,0 +1,103 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tinker.tinker_souce_android.util;
+
+import com.tencent.tinker.lib.listener.PatchListener;
+import com.tencent.tinker.lib.patch.AbstractPatch;
+import com.tencent.tinker.lib.patch.UpgradePatch;
+import com.tencent.tinker.lib.reporter.LoadReporter;
+import com.tencent.tinker.lib.reporter.PatchReporter;
+import com.tencent.tinker.lib.tinker.TinkerInstaller;
+import com.tencent.tinker.lib.util.TinkerLog;
+import com.tencent.tinker.loader.app.ApplicationLike;
+import com.tinker.tinker_souce_android.crash.SampleUncaughtExceptionHandler;
+import com.tinker.tinker_souce_android.reporter.SampleLoadReporter;
+import com.tinker.tinker_souce_android.reporter.SamplePatchListener;
+import com.tinker.tinker_souce_android.reporter.SamplePatchReporter;
+import com.tinker.tinker_souce_android.service.SampleResultService;
+
+
+/**
+ * Created by zhangshaowen on 16/7/3.
+ */
+public class TinkerManager {
+    private static final String TAG = "Tinker.TinkerManager";
+
+    private static ApplicationLike                applicationLike;
+    private static SampleUncaughtExceptionHandler uncaughtExceptionHandler;
+    private static boolean isInstalled = false;
+
+    public static void setTinkerApplicationLike(ApplicationLike appLike) {
+        applicationLike = appLike;
+    }
+
+    public static ApplicationLike getTinkerApplicationLike() {
+        return applicationLike;
+    }
+
+    public static void initFastCrashProtect() {
+        if (uncaughtExceptionHandler == null) {
+            uncaughtExceptionHandler = new SampleUncaughtExceptionHandler();
+            Thread.setDefaultUncaughtExceptionHandler(uncaughtExceptionHandler);
+        }
+    }
+
+    public static void setUpgradeRetryEnable(boolean enable) {
+        UpgradePatchRetry.getInstance(applicationLike.getApplication()).setRetryEnable(enable);
+    }
+
+
+    /**
+     * all use default class, simply Tinker install method
+     */
+    public static void sampleInstallTinker(ApplicationLike appLike) {
+        if (isInstalled) {
+            TinkerLog.w(TAG, "install tinker, but has installed, ignore");
+            return;
+        }
+        TinkerInstaller.install(appLike);
+        isInstalled = true;
+
+    }
+
+    /**
+     * you can specify all class you want.
+     * sometimes, you can only install tinker in some process you want!
+     *
+     * @param appLike
+     */
+    public static void installTinker(ApplicationLike appLike) {
+        if (isInstalled) {
+            TinkerLog.w(TAG, "install tinker, but has installed, ignore");
+            return;
+        }
+        //or you can just use DefaultLoadReporter
+        LoadReporter loadReporter = new SampleLoadReporter(appLike.getApplication());
+        //or you can just use DefaultPatchReporter
+        PatchReporter patchReporter = new SamplePatchReporter(appLike.getApplication());
+        //or you can just use DefaultPatchListener
+        PatchListener patchListener = new SamplePatchListener(appLike.getApplication());
+        //you can set your own upgrade patch if you need
+        AbstractPatch upgradePatchProcessor = new UpgradePatch();
+
+        TinkerInstaller.install(appLike,
+            loadReporter, patchReporter, patchListener,
+            SampleResultService.class, upgradePatchProcessor);
+
+        isInstalled = true;
+    }
+}
diff --git a/tinker_souce_android/src/main/java/com/tinker/tinker_souce_android/util/UpgradePatchRetry.java b/tinker_souce_android/src/main/java/com/tinker/tinker_souce_android/util/UpgradePatchRetry.java
new file mode 100644
index 00000000..2f20fde9
--- /dev/null
+++ b/tinker_souce_android/src/main/java/com/tinker/tinker_souce_android/util/UpgradePatchRetry.java
@@ -0,0 +1,276 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tinker.tinker_souce_android.util;
+
+import android.content.Context;
+import android.content.Intent;
+
+import com.tencent.tinker.lib.service.TinkerPatchService;
+import com.tencent.tinker.lib.tinker.Tinker;
+import com.tencent.tinker.lib.tinker.TinkerInstaller;
+import com.tencent.tinker.lib.util.TinkerLog;
+import com.tencent.tinker.lib.util.TinkerServiceInternals;
+import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
+import com.tinker.tinker_souce_android.reporter.SampleTinkerReport;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.util.Properties;
+
+
+/**
+ * optional
+ * tinker :patch process may killed by some reason, we can retry it to increase upgrade success rate
+ * if patch file is at sdcard, copy it to dataDir first. because some software may delete it.
+ *
+ * Created by zhangshaowen on 16/7/3.
+ */
+public class UpgradePatchRetry {
+    private static final String TAG = "Tinker.UpgradePatchRetry";
+
+    private static final String RETRY_INFO_NAME = "patch.retry";
+    private static final String TEMP_PATCH_NAME = "temp.apk";
+
+    private static final String RETRY_FILE_MD5_PROPERTY = "md5";
+    private static final String RETRY_COUNT_PROPERTY    = "times";
+    private static final int    RETRY_MAX_COUNT         = 4;
+
+
+    private boolean isRetryEnable = false;
+    private File    retryInfoFile = null;
+    private File    tempPatchFile = null;
+
+    private Context context = null;
+    private static UpgradePatchRetry sInstance;
+
+    /**
+     * you must set after tinker has installed
+     *
+     * @param context
+     */
+    public UpgradePatchRetry(Context context) {
+        this.context = context;
+        retryInfoFile = new File(SharePatchFileUtil.getPatchTempDirectory(context), RETRY_INFO_NAME);
+        tempPatchFile = new File(SharePatchFileUtil.getPatchTempDirectory(context), TEMP_PATCH_NAME);
+    }
+
+    public static UpgradePatchRetry getInstance(Context context) {
+        if (sInstance == null) {
+            sInstance = new UpgradePatchRetry(context);
+        }
+        return sInstance;
+    }
+
+    public void onPatchRetryLoad() {
+        if (!isRetryEnable) {
+            TinkerLog.w(TAG, "onPatchRetryLoad retry disabled, just return");
+            return;
+        }
+        Tinker tinker = Tinker.with(context);
+        //only retry on main process
+        if (!tinker.isMainProcess()) {
+            TinkerLog.w(TAG, "onPatchRetryLoad retry is not main process, just return");
+            return;
+        }
+
+        if (!retryInfoFile.exists()) {
+            TinkerLog.w(TAG, "onPatchRetryLoad retry info not exist, just return");
+            return;
+        }
+
+        if (TinkerServiceInternals.isTinkerPatchServiceRunning(context)) {
+            TinkerLog.w(TAG, "onPatchRetryLoad tinker service is running, just return");
+            return;
+        }
+        //must use temp file
+        String path = tempPatchFile.getAbsolutePath();
+        if (path == null || !new File(path).exists()) {
+            TinkerLog.w(TAG, "onPatchRetryLoad patch file: %s is not exist, just return", path);
+            return;
+        }
+        TinkerLog.w(TAG, "onPatchRetryLoad patch file: %s is exist, retry to patch", path);
+        TinkerInstaller.onReceiveUpgradePatch(context, path);
+        SampleTinkerReport.onReportRetryPatch();
+    }
+
+    public void onPatchServiceStart(Intent intent) {
+        if (!isRetryEnable) {
+            TinkerLog.w(TAG, "onPatchServiceStart retry disabled, just return");
+            return;
+        }
+
+        if (intent == null) {
+            TinkerLog.e(TAG, "onPatchServiceStart intent is null, just return");
+            return;
+        }
+
+        String path = TinkerPatchService.getPatchPathExtra(intent);
+
+        if (path == null) {
+            TinkerLog.w(TAG, "onPatchServiceStart patch path is null, just return");
+            return;
+        }
+
+        RetryInfo retryInfo;
+        File patchFile = new File(path);
+
+        String patchMd5 = SharePatchFileUtil.getMD5(patchFile);
+        if (patchMd5 == null) {
+            TinkerLog.w(TAG, "onPatchServiceStart patch md5 is null, just return");
+            return;
+        }
+
+        if (retryInfoFile.exists()) {
+            retryInfo = RetryInfo.readRetryProperty(retryInfoFile);
+            if (retryInfo.md5 == null || retryInfo.times == null || !patchMd5.equals(retryInfo.md5)) {
+                copyToTempFile(patchFile);
+                retryInfo.md5 = patchMd5;
+                retryInfo.times = "1";
+            } else {
+                int nowTimes = Integer.parseInt(retryInfo.times);
+                if (nowTimes >= RETRY_MAX_COUNT) {
+                    SharePatchFileUtil.safeDeleteFile(tempPatchFile);
+                    TinkerLog.w(TAG, "onPatchServiceStart retry more than max count, delete retry info file!");
+                    return;
+                } else {
+                    retryInfo.times = String.valueOf(nowTimes + 1);
+                }
+            }
+
+        } else {
+            copyToTempFile(patchFile);
+            retryInfo = new RetryInfo(patchMd5, "1");
+        }
+
+        RetryInfo.writeRetryProperty(retryInfoFile, retryInfo);
+    }
+
+    public boolean onPatchListenerCheck(String md5) {
+        if (!isRetryEnable) {
+            TinkerLog.w(TAG, "onPatchListenerCheck retry disabled, just return");
+            return true;
+        }
+        if (!retryInfoFile.exists()) {
+            TinkerLog.w(TAG, "onPatchListenerCheck retry file is not exist, just return");
+            return true;
+        }
+        if (md5 == null) {
+            TinkerLog.w(TAG, "onPatchListenerCheck md5 is null, just return");
+            return true;
+        }
+        RetryInfo retryInfo = RetryInfo.readRetryProperty(retryInfoFile);
+        if (md5.equals(retryInfo.md5)) {
+            int nowTimes = Integer.parseInt(retryInfo.times);
+            if (nowTimes >= RETRY_MAX_COUNT) {
+                TinkerLog.w(TAG, "onPatchListenerCheck, retry count %d must exceed than max retry count", nowTimes);
+                SharePatchFileUtil.safeDeleteFile(tempPatchFile);
+                return false;
+            }
+        }
+        return true;
+    }
+    /**
+     * if we receive any result, we can delete the temp retry info file
+     */
+    public void onPatchServiceResult() {
+        if (!isRetryEnable) {
+            TinkerLog.w(TAG, "onPatchServiceResult retry disabled, just return");
+            return;
+        }
+
+        //delete temp patch file
+        if (tempPatchFile.exists()) {
+            SharePatchFileUtil.safeDeleteFile(tempPatchFile);
+        }
+    }
+
+    public void setRetryEnable(boolean enable) {
+        isRetryEnable = enable;
+    }
+
+
+    private void copyToTempFile(File patchFile) {
+        if (patchFile.getAbsolutePath().equals(tempPatchFile.getAbsolutePath())) {
+            return;
+        }
+        TinkerLog.w(TAG, "try copy file: %s to %s", patchFile.getAbsolutePath(), tempPatchFile.getAbsolutePath());
+
+        try {
+            SharePatchFileUtil.copyFileUsingStream(patchFile, tempPatchFile);
+        } catch (IOException e) {
+            TinkerLog.e(TAG, "fail to copy file: %s to %s", patchFile.getAbsolutePath(), tempPatchFile.getAbsolutePath());
+        }
+    }
+
+    static class RetryInfo {
+        String md5;
+        String times;
+
+        RetryInfo(String md5, String times) {
+            this.md5 = md5;
+            this.times = times;
+        }
+
+        static RetryInfo readRetryProperty(File infoFile) {
+            String md5 = null;
+            String times = null;
+
+            Properties properties = new Properties();
+            FileInputStream inputStream = null;
+            try {
+                inputStream = new FileInputStream(infoFile);
+                properties.load(inputStream);
+                md5 = properties.getProperty(RETRY_FILE_MD5_PROPERTY);
+                times = properties.getProperty(RETRY_COUNT_PROPERTY);
+            } catch (IOException e) {
+                TinkerLog.e(TAG, "fail to readRetryProperty:" + e);
+            } finally {
+                SharePatchFileUtil.closeQuietly(inputStream);
+            }
+
+            return new RetryInfo(md5, times);
+        }
+
+        static void writeRetryProperty(File infoFile, RetryInfo info) {
+            if (info == null) {
+                return;
+            }
+
+            File parentFile = infoFile.getParentFile();
+            if (!parentFile.exists()) {
+                parentFile.mkdirs();
+            }
+
+            Properties newProperties = new Properties();
+            newProperties.put(RETRY_FILE_MD5_PROPERTY, info.md5);
+            newProperties.put(RETRY_COUNT_PROPERTY, info.times);
+            FileOutputStream outputStream = null;
+            try {
+                outputStream = new FileOutputStream(infoFile, false);
+                newProperties.store(outputStream, null);
+            } catch (Exception e) {
+//                e.printStackTrace();
+                TinkerLog.printErrStackTrace(TAG, e, "retry write property fail");
+            } finally {
+                SharePatchFileUtil.closeQuietly(outputStream);
+            }
+
+        }
+    }
+}
diff --git a/tinker_souce_android/src/main/java/com/tinker/tinker_souce_android/util/Utils.java b/tinker_souce_android/src/main/java/com/tinker/tinker_souce_android/util/Utils.java
new file mode 100644
index 00000000..79d801d1
--- /dev/null
+++ b/tinker_souce_android/src/main/java/com/tinker/tinker_souce_android/util/Utils.java
@@ -0,0 +1,157 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tinker.tinker_souce_android.util;
+
+import android.os.Environment;
+import android.os.StatFs;
+
+import com.tencent.tinker.loader.shareutil.ShareConstants;
+
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.IOException;
+import java.io.PrintStream;
+
+/**
+ * Created by zhangshaowen on 16/4/7.
+ */
+public class Utils {
+
+    /**
+     * the error code define by myself
+     * should after {@code ShareConstants.ERROR_PATCH_INSERVICE
+     */
+    public static final int ERROR_PATCH_GOOGLEPLAY_CHANNEL      = -5;
+    public static final int ERROR_PATCH_ROM_SPACE               = -6;
+    public static final int ERROR_PATCH_MEMORY_LIMIT            = -7;
+    public static final int ERROR_PATCH_ALREADY_APPLY           = -8;
+    public static final int ERROR_PATCH_CRASH_LIMIT             = -9;
+    public static final int ERROR_PATCH_RETRY_COUNT_LIMIT       = -10;
+    public static final int ERROR_PATCH_CONDITION_NOT_SATISFIED = -11;
+
+    public static final String PLATFORM = "platform";
+
+    public static final int MIN_MEMORY_HEAP_SIZE = 45;
+
+    private static boolean background = false;
+
+    public static boolean isGooglePlay() {
+        return false;
+    }
+
+    public static boolean isBackground() {
+        return background;
+    }
+
+    public static void setBackground(boolean back) {
+        background = back;
+    }
+
+    public static int checkForPatchRecover(long roomSize, int maxMemory) {
+        if (Utils.isGooglePlay()) {
+            return Utils.ERROR_PATCH_GOOGLEPLAY_CHANNEL;
+        }
+        if (maxMemory < MIN_MEMORY_HEAP_SIZE) {
+            return Utils.ERROR_PATCH_MEMORY_LIMIT;
+        }
+        //or you can mention user to clean their rom space!
+        if (!checkRomSpaceEnough(roomSize)) {
+            return Utils.ERROR_PATCH_ROM_SPACE;
+        }
+
+        return ShareConstants.ERROR_PATCH_OK;
+    }
+
+    public static boolean isXposedExists(Throwable thr) {
+        StackTraceElement[] stackTraces = thr.getStackTrace();
+        for (StackTraceElement stackTrace : stackTraces) {
+            final String clazzName = stackTrace.getClassName();
+            if (clazzName != null && clazzName.contains("de.robv.android.xposed.XposedBridge")) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    @Deprecated
+    public static boolean checkRomSpaceEnough(long limitSize) {
+        long allSize;
+        long availableSize = 0;
+        try {
+            File data = Environment.getDataDirectory();
+            StatFs sf = new StatFs(data.getPath());
+            availableSize = (long) sf.getAvailableBlocks() * (long) sf.getBlockSize();
+            allSize = (long) sf.getBlockCount() * (long) sf.getBlockSize();
+        } catch (Exception e) {
+            allSize = 0;
+        }
+
+        if (allSize != 0 && availableSize > limitSize) {
+            return true;
+        }
+        return false;
+    }
+
+    public static String getExceptionCauseString(final Throwable ex) {
+        final ByteArrayOutputStream bos = new ByteArrayOutputStream();
+        final PrintStream ps = new PrintStream(bos);
+
+        try {
+            // print directly
+            Throwable t = ex;
+            while (t.getCause() != null) {
+                t = t.getCause();
+            }
+            t.printStackTrace(ps);
+            return toVisualString(bos.toString());
+        } finally {
+            try {
+                bos.close();
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+    }
+
+    private static String toVisualString(String src) {
+        boolean cutFlg = false;
+
+        if (null == src) {
+            return null;
+        }
+
+        char[] chr = src.toCharArray();
+        if (null == chr) {
+            return null;
+        }
+
+        int i = 0;
+        for (; i < chr.length; i++) {
+            if (chr[i] > 127) {
+                chr[i] = 0;
+                cutFlg = true;
+                break;
+            }
+        }
+
+        if (cutFlg) {
+            return new String(chr, 0, i);
+        } else {
+            return src;
+        }
+    }
+}
diff --git a/tinker_souce_android/src/main/res/layout/activity_main.xml b/tinker_souce_android/src/main/res/layout/activity_main.xml
new file mode 100644
index 00000000..e7d4180a
--- /dev/null
+++ b/tinker_souce_android/src/main/res/layout/activity_main.xml
@@ -0,0 +1,60 @@
+<?xml version="1.0" encoding="utf-8"?>
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+                xmlns:tools="http://schemas.android.com/tools"
+                android:layout_width="match_parent"
+                android:layout_height="match_parent"
+                android:paddingBottom="@dimen/activity_vertical_margin"
+                android:paddingLeft="@dimen/activity_horizontal_margin"
+                android:paddingRight="@dimen/activity_horizontal_margin"
+                android:paddingTop="@dimen/activity_vertical_margin"
+                tools:context=".app.MainActivity">
+
+    <TextView
+        android:id="@+id/textView"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:text="Sample patch!"/>
+
+    <Button
+        android:id="@+id/loadPatch"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_alignParentLeft="true"
+        android:layout_alignParentStart="true"
+        android:layout_below="@+id/textView"
+        android:text="load patch"/>
+
+    <Button
+        android:id="@+id/loadLibrary"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_alignParentLeft="true"
+        android:layout_alignParentStart="true"
+        android:layout_below="@+id/loadPatch"
+        android:text="load library"/>
+
+    <Button
+        android:id="@+id/cleanPatch"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_alignParentLeft="true"
+        android:layout_alignParentStart="true"
+        android:layout_below="@+id/loadLibrary"
+        android:text="clean patch"/>
+    <Button
+        android:id="@+id/killSelf"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_alignParentLeft="true"
+        android:layout_alignParentStart="true"
+        android:layout_below="@+id/cleanPatch"
+        android:text="kill self"/>
+    <Button
+        android:id="@+id/showInfo"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_alignParentLeft="true"
+        android:layout_alignParentStart="true"
+        android:layout_below="@+id/killSelf"
+        android:text="show info"/>
+</RelativeLayout>
diff --git a/tinker_souce_android/src/main/res/mipmap-hdpi/ic_launcher.png b/tinker_souce_android/src/main/res/mipmap-hdpi/ic_launcher.png
new file mode 100644
index 00000000..cde69bcc
Binary files /dev/null and b/tinker_souce_android/src/main/res/mipmap-hdpi/ic_launcher.png differ
diff --git a/tinker_souce_android/src/main/res/mipmap-mdpi/ic_launcher.png b/tinker_souce_android/src/main/res/mipmap-mdpi/ic_launcher.png
new file mode 100644
index 00000000..c133a0cb
Binary files /dev/null and b/tinker_souce_android/src/main/res/mipmap-mdpi/ic_launcher.png differ
diff --git a/tinker_souce_android/src/main/res/mipmap-xhdpi/ic_launcher.png b/tinker_souce_android/src/main/res/mipmap-xhdpi/ic_launcher.png
new file mode 100644
index 00000000..bfa42f0e
Binary files /dev/null and b/tinker_souce_android/src/main/res/mipmap-xhdpi/ic_launcher.png differ
diff --git a/tinker_souce_android/src/main/res/mipmap-xxhdpi/ic_launcher.png b/tinker_souce_android/src/main/res/mipmap-xxhdpi/ic_launcher.png
new file mode 100644
index 00000000..324e72cd
Binary files /dev/null and b/tinker_souce_android/src/main/res/mipmap-xxhdpi/ic_launcher.png differ
diff --git a/tinker_souce_android/src/main/res/mipmap-xxxhdpi/ic_launcher.png b/tinker_souce_android/src/main/res/mipmap-xxxhdpi/ic_launcher.png
new file mode 100644
index 00000000..aee44e13
Binary files /dev/null and b/tinker_souce_android/src/main/res/mipmap-xxxhdpi/ic_launcher.png differ
diff --git a/tinker_souce_android/src/main/res/values-w820dp/dimens.xml b/tinker_souce_android/src/main/res/values-w820dp/dimens.xml
new file mode 100644
index 00000000..63fc8164
--- /dev/null
+++ b/tinker_souce_android/src/main/res/values-w820dp/dimens.xml
@@ -0,0 +1,6 @@
+<resources>
+    <!-- Example customization of dimensions originally defined in res/values/dimens.xml
+         (such as screen margins) for screens with more than 820dp of available width. This
+         would include 7" and 10" devices in landscape (~960dp and ~1280dp respectively). -->
+    <dimen name="activity_horizontal_margin">64dp</dimen>
+</resources>
diff --git a/tinker_souce_android/src/main/res/values/colors.xml b/tinker_souce_android/src/main/res/values/colors.xml
new file mode 100644
index 00000000..3ab3e9cb
--- /dev/null
+++ b/tinker_souce_android/src/main/res/values/colors.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <color name="colorPrimary">#3F51B5</color>
+    <color name="colorPrimaryDark">#303F9F</color>
+    <color name="colorAccent">#FF4081</color>
+</resources>
diff --git a/tinker_souce_android/src/main/res/values/dimens.xml b/tinker_souce_android/src/main/res/values/dimens.xml
new file mode 100644
index 00000000..47c82246
--- /dev/null
+++ b/tinker_souce_android/src/main/res/values/dimens.xml
@@ -0,0 +1,5 @@
+<resources>
+    <!-- Default screen margins, per the Android Design guidelines. -->
+    <dimen name="activity_horizontal_margin">16dp</dimen>
+    <dimen name="activity_vertical_margin">16dp</dimen>
+</resources>
diff --git a/tinker_souce_android/src/main/res/values/strings.xml b/tinker_souce_android/src/main/res/values/strings.xml
new file mode 100644
index 00000000..d2b63d1e
--- /dev/null
+++ b/tinker_souce_android/src/main/res/values/strings.xml
@@ -0,0 +1,5 @@
+<resources>
+    <string name="app_name">tinker-sample-android</string>
+    <string name="test_resource">I am in the base apk</string>
+    <!--<string name="test_resource">I am in the patch apk</string>-->
+</resources>
diff --git a/tinker_souce_android/src/main/res/values/styles.xml b/tinker_souce_android/src/main/res/values/styles.xml
new file mode 100644
index 00000000..391ec9ae
--- /dev/null
+++ b/tinker_souce_android/src/main/res/values/styles.xml
@@ -0,0 +1,10 @@
+<resources>
+    <!-- Base application theme. -->
+    <style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
+        <!-- Customize your theme here. -->
+        <item name="colorPrimary">@color/colorPrimary</item>
+        <item name="colorPrimaryDark">@color/colorPrimaryDark</item>
+        <item name="colorAccent">@color/colorAccent</item>
+    </style>
+
+</resources>
diff --git a/tinker_souce_android/src/test/java/com/tinker/tinker_souce_android/ExampleUnitTest.java b/tinker_souce_android/src/test/java/com/tinker/tinker_souce_android/ExampleUnitTest.java
new file mode 100644
index 00000000..0aa2f6de
--- /dev/null
+++ b/tinker_souce_android/src/test/java/com/tinker/tinker_souce_android/ExampleUnitTest.java
@@ -0,0 +1,15 @@
+package com.tinker.tinker_souce_android;
+
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+/**
+ * To work on unit tests, switch the Test Artifact in the Build Variants view.
+ */
+public class ExampleUnitTest {
+    @Test
+    public void addition_isCorrect() throws Exception {
+        assertEquals(4, 2 + 2);
+    }
+}
\ No newline at end of file
