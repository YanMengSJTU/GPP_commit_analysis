diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 13bc8569..29ace9c5 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -1,8 +1,8 @@
 # Contributing to Tinker
 Welcome to [report Issues](https://github.com/Tencent/tinker/issues) or [pull requests](https://github.com/Tencent/tinker/pulls). It's recommended to read the following Contributing Guide first before contributing. 
 
-## issues
-We use Git Issues to track public bugs and feature requests.
+## Issues
+We use Github Issues to track public bugs and feature requests.
 
 ### Search Known Issues First
 Please search the existing issues to see if any similar issue or feature request has already been filed. You should make sure your issue isn't redundant.
@@ -11,24 +11,24 @@ Please search the existing issues to see if any similar issue or feature request
 If you open an issue, the more information the better. Such as detailed description, screenshot or video of your problem, logcat or code blocks for your crash.
 
 ## Pull Requests
-We strongly welcome your pull request to make tinker better. 
+We strongly welcome your pull request to make Tinker better. 
 
 ### Branch Management
-There are three main branch here:
+There are three main branches here:
 
 1. `master` branch.
-	1. It is the latest (pre-)release branch. We use `master` for tag, with version number `1.1.0`, `1.2.0`, `1.3.0`...
+	1. It is the latest (pre-)release branch. We use `master` for tags, with version number `1.1.0`, `1.2.0`, `1.3.0`...
 	2. **Don't submit any PR on `master` branch.**
 2. `dev` branch. 
-	1. It is our stable developing branch. After full testing, `dev` will publish to `master` branch for the next release.
+	1. It is our stable developing branch. After full testing, `dev` will be merged to `master` branch for the next release.
 	2. **You are recommended to submit bugfix or feature PR on `dev` branch.**
 3. `hotfix` branch. 
 	1. It is the latest tag version for hot fix. If we accept your pull request, we may just tag with version number `1.1.1`, `1.2.3`.
 	2. **Only submit urgent PR on `hotfix` branch for next specific release.**
 
-Normal bugfix or feature request should submit on `dev` branch. After full testing, we will merge them on `master` branch for the next release. 
+Normal bugfix or feature request should be submitted to `dev` branch. After full testing, we will merge them to `master` branch for the next release. 
 
-If you have some urgent bugfix on a published version, but the `master` branch have already far away with the latest tag version, you can submit a PR on hotfix. And it will be cherry picked to `dev` branch if it is possible.
+If you have some urgent bugfixes on a published version, but the `master` branch have already far away with the latest tag version, you can submit a PR on hotfix. And it will be cherry picked to `dev` branch if it is possible.
 
 ```
 master
diff --git a/README.md b/README.md
index 3b477062..df1d78f7 100644
--- a/README.md
+++ b/README.md
@@ -1,7 +1,8 @@
 ## Tinker
 [![license](http://img.shields.io/badge/license-BSD3-brightgreen.svg?style=flat)](https://github.com/Tencent/tinker/blob/master/LICENSE)
-[![Release Version](https://img.shields.io/badge/release-1.6.1-red.svg)](https://github.com/Tencent/tinker/releases) 
+[![Release Version](https://img.shields.io/badge/release-1.7.1-red.svg)](https://github.com/Tencent/tinker/releases) 
 [![PRs Welcome](https://img.shields.io/badge/PRs-welcome-brightgreen.svg)](https://github.com/Tencent/tinker/pulls)
+[![WeChat Approved](https://img.shields.io/badge/Wechat_Approved-1.6.2-red.svg)](https://github.com/Tencent/tinker/wiki)
 
 Tinker is a hot-fix solution library for Android, it supports dex, library and resources update without reinstalling apk.
 
@@ -13,7 +14,7 @@ Add tinker-gradle-plugin as a dependency in your main `build.gradle` in the root
 ```gradle
 buildscript {
     dependencies {
-        classpath ('com.tencent.tinker:tinker-patch-gradle-plugin:1.6.1')
+        classpath ('com.tencent.tinker:tinker-patch-gradle-plugin:1.7.1')
     }
 }
 ```
@@ -23,9 +24,9 @@ Then you need to "apply" the plugin and add dependencies by adding the following
 ```gradle
 dependencies {
     //optional, help to generate the final application 
-    compile('com.tencent.tinker:tinker-android-anno:1.6.1')
+    provided('com.tencent.tinker:tinker-android-anno:1.7.1')
     //tinker's main Android lib
-    compile('com.tencent.tinker:tinker-android-lib:1.6.1') 
+    compile('com.tencent.tinker:tinker-android-lib:1.7.1') 
 }
 ...
 ...
@@ -50,7 +51,7 @@ public class SampleApplication extends TinkerApplication {
         ShareConstants.TINKER_ENABLE_ALL,
         // This is passed as a string so the shell application does not
         // have a binary dependency on your ApplicationLifeCycle class. 
-        "tinker.sample.android.SampleApplicationLike");
+        "tinker.sample.android.app.SampleApplicationLike");
     }  
 }
 ```
@@ -73,8 +74,8 @@ For more tinker configurations, learn more at the sample [app/build.gradle](http
 ## Known Issues
 There are some issues which Tinker can't dynamic update.
 
-1. Update AndroidManifest.xml, such as add Android Component.
-2. Do not support some Samsung models with os version android-19.
+1. Can't update AndroidManifest.xml, such as add Android Component.
+2. Do not support some Samsung models with os version android-21.
 3. Due to Google Play Developer Distribution Agreement, we can't dynamic update our apk.
 
 ## Support
diff --git a/build.gradle b/build.gradle
index ebce8fe2..143ac207 100644
--- a/build.gradle
+++ b/build.gradle
@@ -5,9 +5,9 @@ buildscript {
         jcenter()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:2.1.0'
+        classpath 'com.android.tools.build:gradle:2.2.0'
         classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.6'
-        classpath "com.github.dcendents:android-maven-gradle-plugin:1.3"
+        classpath "com.github.dcendents:android-maven-gradle-plugin:1.4.1"
     }
 }
 
diff --git a/gradle.properties b/gradle.properties
index d2485317..7cbb55f4 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -16,5 +16,5 @@
 # This option should only be used with decoupled projects. More details, visit
 # http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
 # org.gradle.parallel=true
-VERSION_NAME_PREFIX=1.6.1
+VERSION_NAME_PREFIX=1.7.2
 VERSION_NAME_SUFFIX=
\ No newline at end of file
diff --git a/gradle/android-artifacts.gradle b/gradle/android-artifacts.gradle
index 7235ec5a..47735f09 100644
--- a/gradle/android-artifacts.gradle
+++ b/gradle/android-artifacts.gradle
@@ -1,6 +1,12 @@
 apply plugin: 'maven-publish'
 apply plugin: 'com.github.dcendents.android-maven'
 
+android {
+    compileOptions {
+        sourceCompatibility rootProject.ext.javaVersion
+        targetCompatibility rootProject.ext.javaVersion
+    }
+}
 version = version
 group = GROUP
 
diff --git a/gradle/java-artifacts.gradle b/gradle/java-artifacts.gradle
index 0bbd9769..9b8b6e3b 100644
--- a/gradle/java-artifacts.gradle
+++ b/gradle/java-artifacts.gradle
@@ -1,5 +1,8 @@
 apply plugin: 'maven-publish'
 
+sourceCompatibility = rootProject.ext.javaVersion
+targetCompatibility = rootProject.ext.javaVersion
+
 task sourcesJar(type: Jar) {
     from sourceSets.main.java.srcDirs
     classifier = 'sources'
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 7d05de32..dbdc05d2 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -2,4 +2,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.11-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.14.1-all.zip
diff --git a/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dx/instruction/InstructionComparator.java b/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dx/instruction/InstructionComparator.java
index b90bac22..a2651b9d 100644
--- a/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dx/instruction/InstructionComparator.java
+++ b/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dx/instruction/InstructionComparator.java
@@ -21,6 +21,8 @@
 import com.tencent.tinker.android.dx.util.Hex;
 
 import java.io.EOFException;
+import java.util.HashSet;
+import java.util.Set;
 
 /**
  * *** This file is NOT a part of AOSP. ***
@@ -30,8 +32,14 @@
 public abstract class InstructionComparator {
     private final InstructionHolder[] insnHolders1;
     private final InstructionHolder[] insnHolders2;
+    private final Set<String> visitedInsnAddrPairs;
+    private final short[] insns1;
+    private final short[] insns2;
 
     public InstructionComparator(short[] insns1, short[] insns2) {
+        this.insns1 = insns1;
+        this.insns2 = insns2;
+
         if (insns1 != null) {
             ShortArrayCodeInput codeIn1 = new ShortArrayCodeInput(insns1);
             this.insnHolders1 = readInstructionsIntoHolders(codeIn1, insns1.length);
@@ -44,6 +52,7 @@ public InstructionComparator(short[] insns1, short[] insns2) {
         } else {
             this.insnHolders2 = null;
         }
+        visitedInsnAddrPairs = new HashSet<>();
     }
 
     private InstructionHolder[] readInstructionsIntoHolders(ShortArrayCodeInput in, int length) {
@@ -189,6 +198,8 @@ public void visitFillArrayDataPayloadInsn(int currentAddress, int opcode, Object
     }
 
     public final boolean compare() {
+        this.visitedInsnAddrPairs.clear();
+
         if (this.insnHolders1 == null && this.insnHolders2 == null) {
             return true;
         }
@@ -275,7 +286,16 @@ public boolean isSameInstruction(int insnAddress1, int insnAddress2) {
             case InstructionCodec.INSN_FORMAT_22T:
             case InstructionCodec.INSN_FORMAT_30T:
             case InstructionCodec.INSN_FORMAT_31T: {
-                return isSameInstruction(insnHolder1.target, insnHolder2.target);
+                final String addrPairStr = insnAddress1 + "-" + insnAddress2;
+                if (this.visitedInsnAddrPairs.add(addrPairStr)) {
+                    // If we haven't compared target insns, following the control flow
+                    // and do further compare.
+                    return isSameInstruction(insnHolder1.target, insnHolder2.target);
+                } else {
+                    // If we have already compared target insns, here we can return
+                    // true directly.
+                    return true;
+                }
             }
             case InstructionCodec.INSN_FORMAT_21C:
             case InstructionCodec.INSN_FORMAT_22C:
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/DefaultPatchListener.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/DefaultPatchListener.java
index f0f3055f..b4cf11d0 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/DefaultPatchListener.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/DefaultPatchListener.java
@@ -60,7 +60,7 @@ public int onPatchReceived(String path, boolean isUpgrade) {
 
     protected int patchCheck(String path, boolean isUpgrade) {
         Tinker manager = Tinker.with(context);
-        //check SharePrefenences also
+        //check SharePreferences also
         if (!manager.isTinkerEnabled() || !ShareTinkerInternals.isTinkerEnableWithSharedPreferences(context)) {
             return ShareConstants.ERROR_PATCH_DISABLE;
         }
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java
index 936b50a6..03ba6974 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java
@@ -149,21 +149,20 @@ private static boolean extractDexDiffInternals(Context context, String dir, Stri
             if (ShareTinkerInternals.isVmArt()) {
                 File extractedFile = new File(dir + ShareConstants.DEX_SMALLPATCH_INFO_FILE);
                 ZipEntry smallPatchInfoEntry = patch.getEntry(ShareConstants.DEX_SMALLPATCH_INFO_FILE);
-                if (smallPatchInfoEntry == null) {
-                    TinkerLog.w(TAG, "small patch info is not exists, bad patch package?");
-                    manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, ShareConstants.DEX_SMALLPATCH_INFO_FILE, type, isUpgradePatch);
-                    return false;
-                }
-                InputStream smallPatchInfoIs = null;
-                try {
-                    smallPatchInfoIs = patch.getInputStream(smallPatchInfoEntry);
-                    smallPatchInfoFile = new SmallPatchedDexItemFile(smallPatchInfoIs);
-                } catch (Throwable e) {
-                    TinkerLog.w(TAG, "failed to read small patched info. reason: " + e.getMessage());
-                    manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, ShareConstants.DEX_SMALLPATCH_INFO_FILE, type, isUpgradePatch);
-                    return false;
-                } finally {
-                    SharePatchFileUtil.closeQuietly(smallPatchInfoIs);
+                if (smallPatchInfoEntry != null) {
+                    InputStream smallPatchInfoIs = null;
+                    try {
+                        smallPatchInfoIs = patch.getInputStream(smallPatchInfoEntry);
+                        smallPatchInfoFile = new SmallPatchedDexItemFile(smallPatchInfoIs);
+                    } catch (Throwable e) {
+                        TinkerLog.w(TAG, "failed to read small patched info. reason: " + e.getMessage());
+                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, ShareConstants.DEX_SMALLPATCH_INFO_FILE, type, isUpgradePatch);
+                        return false;
+                    } finally {
+                        SharePatchFileUtil.closeQuietly(smallPatchInfoIs);
+                    }
+                } else {
+                    TinkerLog.w(TAG, "small patch info is not exists, it's ok now.");
                 }
             }
 
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/RepairPatch.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/RepairPatch.java
index f9910f82..48a7395b 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/RepairPatch.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/RepairPatch.java
@@ -59,7 +59,7 @@ public boolean tryPatch(Context context, String tempPatchPath, PatchResult patch
         ShareSecurityCheck signatureCheck = new ShareSecurityCheck(context);
 
 
-        int returnCode = ShareTinkerInternals.checkSignatureAndTinkerID(context, patchFile, signatureCheck);
+        int returnCode = ShareTinkerInternals.checkTinkerPackage(context, manager.getTinkerFlags(), patchFile, signatureCheck);
         if (returnCode != ShareConstants.ERROR_PACKAGE_CHECK_OK) {
             TinkerLog.e(TAG, "RepairPatch tryPatch:onPatchPackageCheckFail");
             manager.getPatchReporter().onPatchPackageCheckFail(patchFile, false, returnCode);
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/UpgradePatch.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/UpgradePatch.java
index 3a91e09f..bdbcd9ba 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/UpgradePatch.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/UpgradePatch.java
@@ -56,7 +56,7 @@ public boolean tryPatch(Context context, String tempPatchPath, PatchResult patch
         //check the signature, we should create a new checker
         ShareSecurityCheck signatureCheck = new ShareSecurityCheck(context);
 
-        int returnCode = ShareTinkerInternals.checkSignatureAndTinkerID(context, patchFile, signatureCheck);
+        int returnCode = ShareTinkerInternals.checkTinkerPackage(context, manager.getTinkerFlags(), patchFile, signatureCheck);
         if (returnCode != ShareConstants.ERROR_PACKAGE_CHECK_OK) {
             TinkerLog.e(TAG, "UpgradePatch tryPatch:onPatchPackageCheckFail");
             manager.getPatchReporter().onPatchPackageCheckFail(patchFile, true, returnCode);
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultLoadReporter.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultLoadReporter.java
index f955477d..7fe4c3e1 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultLoadReporter.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultLoadReporter.java
@@ -216,7 +216,13 @@ public void onLoadException(Throwable e, int errorCode) {
                 TinkerLog.i(TAG, "dex exception disable tinker forever with sp");
                 break;
             case ShareConstants.ERROR_LOAD_EXCEPTION_RESOURCE:
-                TinkerLog.i(TAG, "patch load resource exception: %s", e);
+                if (e.getMessage().contains(ShareConstants.CHECK_RES_INSTALL_FAIL)) {
+                    TinkerLog.e(TAG, "tinker res check fail:" + e.getMessage());
+                } else {
+                    TinkerLog.i(TAG, "patch load resource exception: %s", e);
+                }
+                ShareTinkerInternals.setTinkerDisableWithSharedPreferences(context);
+                TinkerLog.i(TAG, "res exception disable tinker forever with sp");
                 break;
             case ShareConstants.ERROR_LOAD_EXCEPTION_UNCAUGHT:
                 TinkerLog.i(TAG, "patch load unCatch exception: %s", e);
@@ -225,8 +231,10 @@ public void onLoadException(Throwable e, int errorCode) {
                 break;
             case ShareConstants.ERROR_LOAD_EXCEPTION_UNKNOWN:
                 TinkerLog.i(TAG, "patch load unknown exception: %s", e);
+                //exception can be caught, it is no need to disable Tinker with sharedPreference
                 break;
         }
+        TinkerLog.e(TAG, "tinker load exception, welcome to submit issue to us: https://github.com/Tencent/tinker/issues");
         TinkerLog.printErrStackTrace(TAG, e, "tinker load exception");
 
         Tinker.with(context).setTinkerDisable();
@@ -246,6 +254,7 @@ public void onLoadException(Throwable e, int errorCode) {
      *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_PATCH_TINKER_ID_NOT_FOUND}       can't find TINKER_PATCH in patch meta file
      *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_TINKER_ID_NOT_EQUAL}             apk and patch's TINKER_PATCH value is not equal
      *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_RESOURCE_META_CORRUPTED}         resource meta file's format check fail
+     *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT}          some patch file type is not supported for current tinkerFlag
      */
     @Override
     public void onLoadPackageCheckFail(File patchFile, int errorCode) {
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultPatchReporter.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultPatchReporter.java
index c1717c41..f0e813f3 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultPatchReporter.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultPatchReporter.java
@@ -69,6 +69,7 @@ public void onPatchServiceStart(Intent intent) {
      *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_PATCH_TINKER_ID_NOT_FOUND}       can't find TINKER_PATCH in patch meta file
      *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_TINKER_ID_NOT_EQUAL}             apk and patch's TINKER_PATCH value is not equal
      *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_RESOURCE_META_CORRUPTED}         resource meta file's format check fail
+     *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT}          some patch file type is not supported for current tinkerFlag
      */
     @Override
     public void onPatchPackageCheckFail(File patchFile, boolean isUpgradePatch, int errorCode) {
@@ -179,6 +180,7 @@ public void onPatchInfoCorrupted(File patchFile, String oldVersion, String newVe
     @Override
     public void onPatchException(File patchFile, Throwable e, boolean isUpgradePatch) {
         TinkerLog.i(TAG, "patchReporter: patch exception path:%s, throwable:%s, isUpgrade:%b", patchFile.getAbsolutePath(), e.getMessage(), isUpgradePatch);
+        TinkerLog.e(TAG, "tinker patch exception, welcome to submit issue to us: https://github.com/Tencent/tinker/issues");
         TinkerLog.printErrStackTrace(TAG, e, "tinker patch exception");
         //don't accept request any more!
         Tinker.with(context).setTinkerDisable();
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/LoadReporter.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/LoadReporter.java
index 67f4c7aa..5ca258a9 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/LoadReporter.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/LoadReporter.java
@@ -134,6 +134,7 @@
      *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_PATCH_TINKER_ID_NOT_FOUND}       can't find TINKER_PATCH in patch meta file
      *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_TINKER_ID_NOT_EQUAL}             apk and patch's TINKER_PATCH value is not equal
      *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_RESOURCE_META_CORRUPTED}         resource meta file's format check fail
+     *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT}          some patch file type is not supported for current tinkerFlag
      */
     void onLoadPackageCheckFail(File patchFile, int errorCode);
 
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/PatchReporter.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/PatchReporter.java
index dbc5860c..e9ac07d2 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/PatchReporter.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/PatchReporter.java
@@ -59,6 +59,7 @@
      *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_PATCH_TINKER_ID_NOT_FOUND}       can't find TINKER_PATCH in patch meta file
      *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_TINKER_ID_NOT_EQUAL}             apk and patch's TINKER_PATCH value is not equal
      *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_RESOURCE_META_CORRUPTED}         resource meta file's format check fail
+     *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT}          some patch file type is not supported for current tinkerFlag
      */
     void onPatchPackageCheckFail(File patchFile, boolean isUpgradePatch, int errorCode);
 
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/TinkerPatchService.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/TinkerPatchService.java
index 75f254af..12281e2c 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/TinkerPatchService.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/TinkerPatchService.java
@@ -149,6 +149,10 @@ protected void onHandleIntent(Intent intent) {
     }
 
     private void increasingPriority() {
+        if (Build.VERSION.SDK_INT > 24) {
+            TinkerLog.i(TAG, "for Android 7.1, we just ignore increasingPriority job");
+            return;
+        }
         TinkerLog.i(TAG, "try to increase patch process priority");
         Notification notification = new Notification();
         if (Build.VERSION.SDK_INT < 18) {
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/Tinker.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/Tinker.java
index 4d5be29c..8e46e2e7 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/Tinker.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/Tinker.java
@@ -46,23 +46,25 @@
 public class Tinker {
     private static final String TAG = "Tinker.Tinker";
 
-    private static Tinker        sInstance;
-    private static boolean installed = false;
-    final          Context       context;
+    private static Tinker sInstance;
+    private static boolean sInstalled = false;
+
+    final Context       context;
     /**
      * data dir, such as /data/data/tinker.sample.android/tinker
      */
-    final          File          patchDirectory;
-    final          PatchListener listener;
-    final          LoadReporter  loadReporter;
-    final          PatchReporter patchReporter;
-    final          File          patchInfoFile;
-    final          boolean       isMainProcess;
-    final          boolean       isPatchProcess;
+    final File          patchDirectory;
+    final PatchListener listener;
+    final LoadReporter  loadReporter;
+    final PatchReporter patchReporter;
+    final File          patchInfoFile;
+    final boolean       isMainProcess;
+    final boolean       isPatchProcess;
     /**
      * same with {@code TinkerApplication.tinkerLoadVerifyFlag}
      */
-    final boolean tinkerLoadVerifyFlag;
+    final boolean       tinkerLoadVerifyFlag;
+
     /**
      * same with {@code TinkerApplication.tinkerFlags}
      */
@@ -71,7 +73,7 @@
     /**
      * whether load patch success
      */
-    private        boolean loaded    = false;
+    private boolean loaded = false;
 
     private Tinker(Context context, int tinkerFlags, LoadReporter loadReporter, PatchReporter patchReporter,
                    PatchListener listener, File patchDirectory, File patchInfoFile,
@@ -96,7 +98,7 @@ private Tinker(Context context, int tinkerFlags, LoadReporter loadReporter, Patc
      * @return the Tinker object
      */
     public static Tinker with(Context context) {
-        if (!installed) {
+        if (!sInstalled) {
             throw new TinkerRuntimeException("you must install tinker before get tinker sInstance");
         }
         if (sInstance == null) {
@@ -133,7 +135,7 @@ public static void create(Tinker tinker) {
     public void install(Intent intentResult, Class<? extends AbstractResultService> serviceClass,
                         AbstractPatch upgradePatch, AbstractPatch repairPatch
     ) {
-        installed = true;
+        sInstalled = true;
         AbstractResultService.setResultServiceClass(serviceClass);
         TinkerPatchService.setPatchProcessor(upgradePatch, repairPatch);
 
@@ -156,6 +158,7 @@ public void install(Intent intentResult, Class<? extends AbstractResultService>
 
     /**
      * set tinkerPatchServiceNotificationId
+     *
      * @param id
      */
     public void setPatchServiceNotificationId(int id) {
@@ -212,7 +215,7 @@ public void setTinkerLoaded(boolean isLoaded) {
     }
 
     public boolean isTinkerInstalled() {
-        return installed;
+        return sInstalled;
     }
 
     public boolean isTinkerLoadVerify() {
@@ -243,6 +246,11 @@ public PatchListener getPatchListener() {
         return listener;
     }
 
+
+    public int getTinkerFlags() {
+        return tinkerFlags;
+    }
+
     /**
      * clean all patch files
      */
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AndroidNClassLoader.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AndroidNClassLoader.java
index 795eea17..7fc6a66b 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AndroidNClassLoader.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AndroidNClassLoader.java
@@ -21,8 +21,16 @@
 import android.content.Context;
 import android.os.Build;
 
+import com.tencent.tinker.loader.shareutil.ShareReflectUtil;
+
+import java.io.File;
+import java.io.IOException;
 import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.List;
 
+import dalvik.system.DexFile;
 import dalvik.system.PathClassLoader;
 
 /**
@@ -30,6 +38,7 @@
  */
 @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
 class AndroidNClassLoader extends PathClassLoader {
+    static ArrayList<DexFile> oldDexFiles = new ArrayList<>();
     PathClassLoader originClassLoader;
 
     private AndroidNClassLoader(String dexPath, PathClassLoader parent) {
@@ -40,33 +49,32 @@ private AndroidNClassLoader(String dexPath, PathClassLoader parent) {
     private static AndroidNClassLoader createAndroidNClassLoader(PathClassLoader original) throws Exception {
         //let all element ""
         AndroidNClassLoader androidNClassLoader = new AndroidNClassLoader("",  original);
-        Field originPathList = findField(original, "pathList");
+        Field originPathList = ShareReflectUtil.findField(original, "pathList");
         Object originPathListObject = originPathList.get(original);
         //should reflect definingContext also
-        Field originClassloader = findField(originPathListObject, "definingContext");
+        Field originClassloader = ShareReflectUtil.findField(originPathListObject, "definingContext");
         originClassloader.set(originPathListObject, androidNClassLoader);
         //copy pathList
-        Field pathListField = findField(androidNClassLoader, "pathList");
+        Field pathListField = ShareReflectUtil.findField(androidNClassLoader, "pathList");
         //just use PathClassloader's pathList
         pathListField.set(androidNClassLoader, originPathListObject);
-        return androidNClassLoader;
-    }
 
-    private static Field findField(Object instance, String name) throws NoSuchFieldException {
-        for (Class<?> clazz = instance.getClass(); clazz != null; clazz = clazz.getSuperclass()) {
-            try {
-                Field field = clazz.getDeclaredField(name);
-
-                if (!field.isAccessible()) {
-                    field.setAccessible(true);
-                }
-
-                return field;
-            } catch (NoSuchFieldException e) {
-                // ignore and search next
-            }
+        //we must recreate dexFile due to dexCache
+        List<File> additionalClassPathEntries = new ArrayList<>();
+        Field dexElement = ShareReflectUtil.findField(originPathListObject, "dexElements");
+        Object[] originDexElements = (Object[]) dexElement.get(originPathListObject);
+        for (Object element : originDexElements) {
+            DexFile dexFile = (DexFile) ShareReflectUtil.findField(element, "dexFile").get(element);
+            additionalClassPathEntries.add(new File(dexFile.getName()));
+            //protect for java.lang.AssertionError: Failed to close dex file in finalizer.
+            oldDexFiles.add(dexFile);
         }
-        throw new NoSuchFieldException("Field " + name + " not found in " + instance.getClass());
+        Method makePathElements = ShareReflectUtil.findMethod(originPathListObject, "makePathElements", List.class, File.class,
+            List.class);
+        ArrayList<IOException> suppressedExceptions = new ArrayList<>();
+        Object[] newDexElements = (Object[]) makePathElements.invoke(originPathListObject, additionalClassPathEntries, null, suppressedExceptions);
+        dexElement.set(originPathListObject, newDexElements);
+        return androidNClassLoader;
     }
 
     private static void reflectPackageInfoClassloader(Application application, ClassLoader reflectClassLoader) throws Exception {
@@ -74,9 +82,9 @@ private static void reflectPackageInfoClassloader(Application application, Class
         String defPackageInfo = "mPackageInfo";
         String defClassLoader = "mClassLoader";
 
-        Context baseContext = (Context) findField(application, defBase).get(application);
-        Object basePackageInfo = findField(baseContext, defPackageInfo).get(baseContext);
-        Field classLoaderField = findField(basePackageInfo, defClassLoader);
+        Context baseContext = (Context) ShareReflectUtil.findField(application, defBase).get(application);
+        Object basePackageInfo = ShareReflectUtil.findField(baseContext, defPackageInfo).get(baseContext);
+        Field classLoaderField = ShareReflectUtil.findField(basePackageInfo, defClassLoader);
         Thread.currentThread().setContextClassLoader(reflectClassLoader);
         classLoaderField.set(basePackageInfo, reflectClassLoader);
     }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/SystemClassLoaderAdder.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/SystemClassLoaderAdder.java
index 88b67135..6678afa3 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/SystemClassLoaderAdder.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/SystemClassLoaderAdder.java
@@ -48,6 +48,7 @@
     private static final String CHECK_DEX_CLASS = "com.tencent.tinker.loader.TinkerTestDexLoad";
     private static final String CHECK_DEX_FIELD = "isPatch";
 
+    private static int sPatchDexCount = 0;
 
     @SuppressLint("NewApi")
     public static void installDexes(Application application, PathClassLoader loader, File dexOptDir, List<File> files)
@@ -69,15 +70,38 @@ public static void installDexes(Application application, PathClassLoader loader,
             } else {
                 V4.install(classLoader, files, dexOptDir);
             }
+            //install done
+            sPatchDexCount = files.size();
 
-            if (!checkDexInstall()) {
+            if (!checkDexInstall(classLoader)) {
+                //reset patch dex
+                SystemClassLoaderAdder.uninstallPatchDex(classLoader);
                 throw new TinkerRuntimeException(ShareConstants.CHECK_DEX_INSTALL_FAIL);
             }
         }
     }
 
-    private static boolean checkDexInstall() throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException {
-        Class<?> clazz = Class.forName(CHECK_DEX_CLASS);
+    public static void uninstallPatchDex(ClassLoader classLoader) throws Throwable {
+        if (sPatchDexCount <= 0) {
+            return;
+        }
+        if (Build.VERSION.SDK_INT >= 14) {
+            Field pathListField = ShareReflectUtil.findField(classLoader, "pathList");
+            Object dexPathList = pathListField.get(classLoader);
+            ShareReflectUtil.reduceFieldArray(dexPathList, "dexElements", sPatchDexCount);
+        } else {
+            ShareReflectUtil.reduceFieldArray(classLoader, "mPaths", sPatchDexCount);
+            ShareReflectUtil.reduceFieldArray(classLoader, "mFiles", sPatchDexCount);
+            ShareReflectUtil.reduceFieldArray(classLoader, "mZips", sPatchDexCount);
+            try {
+                ShareReflectUtil.reduceFieldArray(classLoader, "mDexs", sPatchDexCount);
+            } catch (Exception e) {
+            }
+        }
+    }
+
+    private static boolean checkDexInstall(ClassLoader classLoader) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException {
+        Class<?> clazz = Class.forName(CHECK_DEX_CLASS, true, classLoader);
         Field filed = ShareReflectUtil.findField(clazz, CHECK_DEX_FIELD);
         boolean isPatch = (boolean) filed.get(null);
         Log.w(TAG, "checkDexInstall result:" + isPatch);
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerDexLoader.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerDexLoader.java
index b700a1b8..2d8ed266 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerDexLoader.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerDexLoader.java
@@ -99,7 +99,7 @@ public static boolean loadTinkerJars(Application application, boolean tinkerLoad
                         file.getAbsolutePath());
                     return false;
                 }
-                Log.i(TAG, "verify dex file:" + file.getPath() + ", md5 use time: " + (System.currentTimeMillis() - start));
+                Log.i(TAG, "verify dex file:" + file.getPath() + " md5, use time: " + (System.currentTimeMillis() - start));
             }
             legalFiles.add(file);
         }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerLoader.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerLoader.java
index 7b1853f3..adfb88f7 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerLoader.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerLoader.java
@@ -152,9 +152,9 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, bo
 
         ShareSecurityCheck securityCheck = new ShareSecurityCheck(app);
 
-        int returnCode = ShareTinkerInternals.checkSignatureAndTinkerID(app, patchVersionFile, securityCheck);
-        if (returnCode != 0) {
-            Log.w(TAG, "tryLoadPatchFiles:checkSignatureAndTinkerID");
+        int returnCode = ShareTinkerInternals.checkTinkerPackage(app, tinkerFlag, patchVersionFile, securityCheck);
+        if (returnCode != ShareConstants.ERROR_PACKAGE_CHECK_OK) {
+            Log.w(TAG, "tryLoadPatchFiles:checkTinkerPackage");
             resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_PACKAGE_PATCH_CHECK, returnCode);
             ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_PACKAGE_CHECK_FAIL);
             return;
@@ -224,7 +224,7 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, bo
 
         //now we can load patch resource
         if (isEnabledForResource) {
-            boolean loadTinkerResources = TinkerResourceLoader.loadTinkerResources(tinkerLoadVerifyFlag, patchVersionDirectory, resultIntent);
+            boolean loadTinkerResources = TinkerResourceLoader.loadTinkerResources(app, tinkerLoadVerifyFlag, patchVersionDirectory, resultIntent);
             if (!loadTinkerResources) {
                 Log.w(TAG, "tryLoadPatchFiles:onPatchLoadResourcesFail");
                 return;
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourceLoader.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourceLoader.java
index 3976ffe5..b46d5940 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourceLoader.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourceLoader.java
@@ -32,44 +32,50 @@
  * Created by liangwenxiang on 2016/4/14.
  */
 public class TinkerResourceLoader {
-
     protected static final String RESOURCE_META_FILE = ShareConstants.RES_META_FILE;
     protected static final String RESOURCE_FILE      = ShareConstants.RES_NAME;
     protected static final String RESOURCE_PATH      = ShareConstants.RES_PATH;
     private static final String TAG = "Tinker.ResourceLoader";
     private static ShareResPatchInfo resPatchInfo = new ShareResPatchInfo();
 
-
     private TinkerResourceLoader() {
     }
 
     /**
      * Load tinker resources
      */
-    public static boolean loadTinkerResources(boolean tinkerLoadVerifyFlag, String directory, Intent intentResult) {
+    public static boolean loadTinkerResources(Context context, boolean tinkerLoadVerifyFlag, String directory, Intent intentResult) {
         if (resPatchInfo == null || resPatchInfo.resArscMd5 == null) {
             return true;
         }
         String resourceString = directory + "/" + RESOURCE_PATH +  "/" + RESOURCE_FILE;
         File resourceFile = new File(resourceString);
+        long start = System.currentTimeMillis();
 
         if (tinkerLoadVerifyFlag) {
-            long start = System.currentTimeMillis();
             if (!SharePatchFileUtil.checkResourceArscMd5(resourceFile, resPatchInfo.resArscMd5)) {
                 Log.e(TAG, "Failed to load resource file, path: " + resourceFile.getPath() + ", expect md5: " + resPatchInfo.resArscMd5);
                 ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_RESOURCE_MD5_MISMATCH);
                 return false;
             }
-            Log.i(TAG, "verify resource file:" + resourceFile.getPath() + ", md5 use time: " + (System.currentTimeMillis() - start));
+            Log.i(TAG, "verify resource file:" + resourceFile.getPath() + " md5, use time: " + (System.currentTimeMillis() - start));
         }
         try {
-            TinkerResourcePatcher.monkeyPatchExistingResources(resourceString);
+            TinkerResourcePatcher.monkeyPatchExistingResources(context, resourceString);
+            Log.i(TAG, "monkeyPatchExistingResources resource file:" + resourceString + ", use time: " + (System.currentTimeMillis() - start));
         } catch (Throwable e) {
-            Log.e(TAG, "install resources failed", e);
+            Log.e(TAG, "install resources failed");
+            //remove patch dex if resource is installed failed
+            try {
+                SystemClassLoaderAdder.uninstallPatchDex(context.getClassLoader());
+            } catch (Throwable throwable) {
+                Log.e(TAG, "uninstallPatchDex failed", e);
+            }
             intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_EXCEPTION, e);
             ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_RESOURCE_LOAD_EXCEPTION);
             return false;
         }
+
         return true;
     }
 
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java
index 81aaa4e0..56f1c0f8 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java
@@ -20,27 +20,59 @@
 import android.content.res.AssetManager;
 import android.content.res.Resources;
 import android.util.ArrayMap;
+import android.util.Log;
+
+import com.tencent.tinker.loader.shareutil.ShareConstants;
+import com.tencent.tinker.loader.shareutil.ShareReflectUtil;
 
 import java.lang.ref.WeakReference;
 import java.lang.reflect.Field;
 import java.lang.reflect.Method;
 import java.util.Collection;
 import java.util.HashMap;
+import java.util.Map;
 
 import static android.os.Build.VERSION.SDK_INT;
 import static android.os.Build.VERSION_CODES.KITKAT;
 
 class TinkerResourcePatcher {
+    private static final String TAG               = "Tinker.ResourcePatcher";
+    private static final String TEST_ASSETS_VALUE = "only_use_to_test_tinker_resource.txt";
+
     // original value
     private static Collection<WeakReference<Resources>> references;
-
     private static AssetManager newAssetManager          = null;
     private static Method       addAssetPathMethod       = null;
     private static Method       ensureStringBlocksMethod = null;
     private static Field        assetsFiled              = null;
-    private static Field        resourcesImplFiled      = null;
+    private static Field        resourcesImplFiled       = null;
+    private static Field        resDir                   = null;
+    private static Field        packagesFiled            = null;
+    private static Field        resourcePackagesFiled    = null;
 
     public static void isResourceCanPatch(Context context) throws Throwable {
+        //   - Replace mResDir to point to the external resource file instead of the .apk. This is
+        //     used as the asset path for new Resources objects.
+        //   - Set Application#mLoadedApk to the found LoadedApk instance
+
+        // Find the ActivityThread instance for the current thread
+        Class<?> activityThread = Class.forName("android.app.ActivityThread");
+        // API version 8 has PackageInfo, 10 has LoadedApk. 9, I don't know.
+        Class<?> loadedApkClass;
+        try {
+            loadedApkClass = Class.forName("android.app.LoadedApk");
+        } catch (ClassNotFoundException e) {
+            loadedApkClass = Class.forName("android.app.ActivityThread$PackageInfo");
+        }
+        Field mApplication = loadedApkClass.getDeclaredField("mApplication");
+        mApplication.setAccessible(true);
+        resDir = loadedApkClass.getDeclaredField("mResDir");
+        resDir.setAccessible(true);
+        packagesFiled = activityThread.getDeclaredField("mPackages");
+        packagesFiled.setAccessible(true);
+
+        resourcePackagesFiled = activityThread.getDeclaredField("mResourcePackages");
+        resourcePackagesFiled.setAccessible(true);
         /*
         (Note: the resource directory is *also* inserted into the loadedApk in
         monkeyPatchApplication)
@@ -74,7 +106,15 @@ public static void isResourceCanPatch(Context context) throws Throwable {
         */
         // Create a new AssetManager instance and point it to the resources installed under
         // /sdcard
-        newAssetManager = AssetManager.class.getConstructor().newInstance();
+        AssetManager assets = context.getAssets();
+        // Baidu os
+        if (assets.getClass().getName().equals("android.content.res.BaiduAssetManager")) {
+            Class baiduAssetManager = Class.forName("android.content.res.BaiduAssetManager");
+            newAssetManager = (AssetManager) baiduAssetManager.getConstructor().newInstance();
+        } else {
+            newAssetManager = AssetManager.class.getConstructor().newInstance();
+        }
+
         addAssetPathMethod = AssetManager.class.getDeclaredMethod("addAssetPath", String.class);
         addAssetPathMethod.setAccessible(true);
 
@@ -105,7 +145,6 @@ public static void isResourceCanPatch(Context context) throws Throwable {
                 references = (Collection<WeakReference<Resources>>) mResourceReferences.get(resourcesManager);
             }
         } else {
-            Class<?> activityThread = Class.forName("android.app.ActivityThread");
             Field fMActiveResources = activityThread.getDeclaredField("mActiveResources");
             fMActiveResources.setAccessible(true);
             Object thread = getActivityThread(context, activityThread);
@@ -128,14 +167,30 @@ public static void isResourceCanPatch(Context context) throws Throwable {
         }
     }
 
-    public static void monkeyPatchExistingResources(String externalResourceFile) throws Throwable {
+    public static void monkeyPatchExistingResources(Context context, String externalResourceFile) throws Throwable {
         if (externalResourceFile == null) {
             return;
         }
+        // Find the ActivityThread instance for the current thread
+        Class<?> activityThread = Class.forName("android.app.ActivityThread");
+        Object currentActivityThread = getActivityThread(context, activityThread);
+
+        for (Field field : new Field[]{packagesFiled, resourcePackagesFiled}) {
+            Object value = field.get(currentActivityThread);
 
+            for (Map.Entry<String, WeakReference<?>> entry
+                : ((Map<String, WeakReference<?>>) value).entrySet()) {
+                Object loadedApk = entry.getValue().get();
+                if (loadedApk == null) {
+                    continue;
+                }
+                if (externalResourceFile != null) {
+                    resDir.set(loadedApk, externalResourceFile);
+                }
+            }
+        }
         // Create a new AssetManager instance and point it to the resources installed under
         // /sdcard
-
         if (((Integer) addAssetPathMethod.invoke(newAssetManager, externalResourceFile)) == 0) {
             throw new IllegalStateException("Could not create new AssetManager");
         }
@@ -152,9 +207,10 @@ public static void monkeyPatchExistingResources(String externalResourceFile) thr
                 try {
                     assetsFiled.set(resources, newAssetManager);
                 } catch (Throwable ignore) {
-                    //N
+                    // N
                     Object resourceImpl = resourcesImplFiled.get(resources);
-                    Field implAssets = resourceImpl.getClass().getDeclaredField("mAssets");
+                    // for Huawei HwResourcesImpl
+                    Field implAssets = ShareReflectUtil.findField(resourceImpl, "mAssets");
                     implAssets.setAccessible(true);
                     implAssets.set(resourceImpl, newAssetManager);
                 }
@@ -162,6 +218,21 @@ public static void monkeyPatchExistingResources(String externalResourceFile) thr
                 resources.updateConfiguration(resources.getConfiguration(), resources.getDisplayMetrics());
             }
         }
+
+        if (!checkResUpdate(context)) {
+            throw new TinkerRuntimeException(ShareConstants.CHECK_RES_INSTALL_FAIL);
+        }
+    }
+
+    private static boolean checkResUpdate(Context context) {
+        try {
+            Log.e(TAG, "checkResUpdate success, found test resource assets file " + TEST_ASSETS_VALUE);
+            context.getAssets().open(TEST_ASSETS_VALUE);
+        } catch (Throwable e) {
+            Log.e(TAG, "checkResUpdate failed, can't find test resource assets file " + TEST_ASSETS_VALUE + " e:" + e.getMessage());
+            return false;
+        }
+        return true;
     }
 
     private static Object getActivityThread(Context context,
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareConstants.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareConstants.java
index b7f1f9f5..e3db652f 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareConstants.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareConstants.java
@@ -47,7 +47,9 @@
     public static final String DEX_OPTIMIZE_PATH        = "odex";
     public static final String DEX_SUFFIX               = ".dex";
     public static final String JAR_SUFFIX               = ".jar";
+
     public static final String CHECK_DEX_INSTALL_FAIL = "checkDexInstall failed";
+    public static final String CHECK_RES_INSTALL_FAIL = "checkResInstall failed";
 
     public static final String RES_META_FILE       = "assets/res_meta.txt";
     public static final String RES_ARSC            = "resources.arsc";
@@ -166,5 +168,5 @@
     public static final int ERROR_PACKAGE_CHECK_PATCH_TINKER_ID_NOT_FOUND = -6;
     public static final int ERROR_PACKAGE_CHECK_TINKER_ID_NOT_EQUAL       = -7;
     public static final int ERROR_PACKAGE_CHECK_RESOURCE_META_CORRUPTED   = -8;
-
+    public static final int ERROR_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT    = -9;
 }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareReflectUtil.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareReflectUtil.java
index 28f0295a..f27a5e0b 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareReflectUtil.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareReflectUtil.java
@@ -125,4 +125,33 @@ public static void expandFieldArray(Object instance, String fieldName, Object[]
         jlrField.set(instance, combined);
     }
 
+    /**
+     * Replace the value of a field containing a non null array, by a new array containing the
+     * elements of the original array plus the elements of extraElements.
+     *
+     * @param instance      the instance whose field is to be modified.
+     * @param fieldName     the field to modify.
+     */
+    public static void reduceFieldArray(Object instance, String fieldName, int reduceSize)
+        throws NoSuchFieldException, IllegalArgumentException, IllegalAccessException {
+        if (reduceSize <= 0) {
+            return;
+        }
+
+        Field jlrField = findField(instance, fieldName);
+
+        Object[] original = (Object[]) jlrField.get(instance);
+        int finalLength = original.length - reduceSize;
+
+        if (finalLength <= 0) {
+            return;
+        }
+
+        Object[] combined = (Object[]) Array.newInstance(original.getClass().getComponentType(), finalLength);
+
+        System.arraycopy(original, reduceSize, combined, 0, finalLength);
+
+        jlrField.set(instance, combined);
+    }
+
 }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java
index 404bbdcd..aba789cc 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java
@@ -57,6 +57,21 @@ public static boolean isNullOrNil(final String object) {
         return false;
     }
 
+    /**
+     * thinker package check
+     * @param context
+     * @param tinkerFlag
+     * @param patchFile
+     * @param securityCheck
+     * @return
+     */
+    public static int checkTinkerPackage(Context context, int tinkerFlag, File patchFile, ShareSecurityCheck securityCheck) {
+        int returnCode = checkSignatureAndTinkerID(context, patchFile, securityCheck);
+        if (returnCode == ShareConstants.ERROR_PACKAGE_CHECK_OK) {
+            returnCode = checkPackageAndTinkerFlag(securityCheck, tinkerFlag);
+        }
+        return returnCode;
+    }
     /**
      * check patch file signature and TINKER_ID
      *
@@ -91,6 +106,31 @@ public static int checkSignatureAndTinkerID(Context context, File patchFile, Sha
         return ShareConstants.ERROR_PACKAGE_CHECK_OK;
     }
 
+
+    public static int checkPackageAndTinkerFlag(ShareSecurityCheck securityCheck, int tinkerFlag) {
+        if (isTinkerEnabledAll(tinkerFlag)) {
+            return ShareConstants.ERROR_PACKAGE_CHECK_OK;
+        }
+        HashMap<String, String> metaContentMap = securityCheck.getMetaContentMap();
+        //check dex
+        boolean dexEnable = isTinkerEnabledForDex(tinkerFlag);
+        if (!dexEnable && metaContentMap.containsKey(ShareConstants.DEX_META_FILE)) {
+            return ShareConstants.ERROR_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT;
+        }
+        //check native library
+        boolean nativeEnable = isTinkerEnabledForNativeLib(tinkerFlag);
+        if (!nativeEnable && metaContentMap.containsKey(ShareConstants.SO_META_FILE)) {
+            return ShareConstants.ERROR_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT;
+        }
+        //check resource
+        boolean resEnable = isTinkerEnabledForResource(tinkerFlag);
+        if (!resEnable && metaContentMap.containsKey(ShareConstants.RES_META_FILE)) {
+            return ShareConstants.ERROR_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT;
+        }
+
+        return ShareConstants.ERROR_PACKAGE_CHECK_OK;
+    }
+
     /**
      * not like {@cod ShareSecurityCheck.getPackagePropertiesIfPresent}
      * we don't check Signatures or other files, we just get the package meta's properties directly
diff --git a/tinker-build/tinker-patch-cli/src/main/java/com/tencent/tinker/patch/CliMain.java b/tinker-build/tinker-patch-cli/src/main/java/com/tencent/tinker/patch/CliMain.java
index 37dbf0b1..8df97a5e 100644
--- a/tinker-build/tinker-patch-cli/src/main/java/com/tencent/tinker/patch/CliMain.java
+++ b/tinker-build/tinker-patch-cli/src/main/java/com/tencent/tinker/patch/CliMain.java
@@ -92,6 +92,9 @@ private void run(String[] args) {
             if (oldApkFile == null || newApkFile == null) {
                 Logger.e("Missing old apk or new apk file argument");
                 goToError();
+            } else if (!oldApkFile.exists() || !newApkFile.exists()) {
+                Logger.e("Old apk or new apk file does not exist");
+                goToError();
             }
 
             if (outputFile == null) {
diff --git a/tinker-build/tinker-patch-cli/tool_output/tinker_config.xml b/tinker-build/tinker-patch-cli/tool_output/tinker_config.xml
index f62489f0..de0c6c99 100644
--- a/tinker-build/tinker-patch-cli/tool_output/tinker_config.xml
+++ b/tinker-build/tinker-patch-cli/tool_output/tinker_config.xml
@@ -82,6 +82,12 @@
         <!--or TinkerLoadResult.getPackageConfigByName-->
         <!--you must add TINKER_ID with the old apk manifest's meta TINKER_ID value-->
         <!--other config files (such as patchMessage below)is not necessary-->
+
+        <!--For sample project or any projects that copy SamplePatchListener directory,-->
+        <!--platform config field is necessary, or an error code ERROR_PATCH_CONDITION_NOT_SATISFIED(-10)-->
+        <!--will be thrown.-->
+        <configField name="platform" value="all"/>
+
         <configField name="patchMessage" value="classes.dex"/>
     </issue>
 
diff --git a/tinker-build/tinker-patch-cli/tool_output/tinker_proguard.pro b/tinker-build/tinker-patch-cli/tool_output/tinker_proguard.pro
index 23c74455..e4ef8030 100644
--- a/tinker-build/tinker-patch-cli/tool_output/tinker_proguard.pro
+++ b/tinker-build/tinker-patch-cli/tool_output/tinker_proguard.pro
@@ -26,6 +26,6 @@
 }
 
 #your dex.loader pattern here
--keep class com.tencent.tinker.loader.*
+-keep class com.tencent.tinker.loader.**
 -keep class tinker.sample.android.app.SampleApplication
 
diff --git a/tinker-build/tinker-patch-gradle-plugin/build.gradle b/tinker-build/tinker-patch-gradle-plugin/build.gradle
index d07a0497..fa4fb4e2 100644
--- a/tinker-build/tinker-patch-gradle-plugin/build.gradle
+++ b/tinker-build/tinker-patch-gradle-plugin/build.gradle
@@ -10,6 +10,7 @@ dependencies {
 //    compile fileTree(dir: 'libs', include: ['*.jar'])
     compile project(':tinker-build:tinker-patch-lib')
     compile 'com.google.gradle:osdetector-gradle-plugin:1.2.1'
+    compile 'com.android.tools.build:gradle:2.1.0'
 }
 
 repositories {
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/TinkerPatchPlugin.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/TinkerPatchPlugin.groovy
index fe44cea2..8f539a16 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/TinkerPatchPlugin.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/TinkerPatchPlugin.groovy
@@ -16,23 +16,15 @@
 
 package com.tencent.tinker.build.gradle
 
-import com.tencent.tinker.build.gradle.extension.TinkerBuildConfigExtension
-import com.tencent.tinker.build.gradle.extension.TinkerDexExtension
-import com.tencent.tinker.build.gradle.extension.TinkerLibExtension
-import com.tencent.tinker.build.gradle.extension.TinkerPackageConfigExtension
-import com.tencent.tinker.build.gradle.extension.TinkerPatchExtension
-import com.tencent.tinker.build.gradle.extension.TinkerResourceExtension
-import com.tencent.tinker.build.gradle.extension.TinkerSevenZipExtension
-import com.tencent.tinker.build.gradle.task.TinkerManifestTask
-import com.tencent.tinker.build.gradle.task.TinkerMultidexConfigTask
-import com.tencent.tinker.build.gradle.task.TinkerPatchSchemaTask
-import com.tencent.tinker.build.gradle.task.TinkerProguardConfigTask
-import com.tencent.tinker.build.gradle.task.TinkerResourceIdTask
+import com.tencent.tinker.build.gradle.extension.*
+import com.tencent.tinker.build.gradle.task.*
+import com.tencent.tinker.build.gradle.transform.AuxiliaryInjectTransform
 import com.tencent.tinker.build.util.FileOperation
 import com.tencent.tinker.build.util.TypedValue
 import org.gradle.api.GradleException
 import org.gradle.api.Plugin
 import org.gradle.api.Project
+import org.gradle.api.UnknownTaskException
 
 /**
  * Registers the plugin's tasks.
@@ -59,6 +51,8 @@ class TinkerPatchPlugin implements Plugin<Project> {
 
         def configuration = project.tinkerPatch
 
+        project.android.registerTransform(new AuxiliaryInjectTransform(project))
+
         project.afterEvaluate {
             if (!project.plugins.hasPlugin('com.android.application')) {
                 throw new GradleException('generateTinkerApk: Android Application plugin required')
@@ -70,10 +64,16 @@ class TinkerPatchPlugin implements Plugin<Project> {
             android.packagingOptions.exclude("TinkerAnnoApplication.tmpl")
             //open jumboMode
             android.dexOptions.jumboMode = true
+            //close preDexLibraries
+            try {
+                android.dexOptions.preDexLibraries = false
+            } catch (Throwable e) {
+                //no preDexLibraries field, just continue
+            }
 
             project.logger.error("----------------------tinker build warning ------------------------------------")
             project.logger.error("tinker will change your build configs:")
-            project.logger.error("we will add TINDER_ID=${configuration.buildConfig.tinkerId} in your build output manifest file build/intermediates/manifests/full/*")
+            project.logger.error("we will add TINKER_ID=${configuration.buildConfig.tinkerId} in your build output manifest file build/intermediates/manifests/full/*")
             project.logger.error("")
             project.logger.error("if minifyEnabled is true")
 
@@ -105,10 +105,23 @@ class TinkerPatchPlugin implements Plugin<Project> {
                 def variantOutput = variant.outputs.first()
                 def variantName = variant.name.capitalize()
 
+                try {
+                    def instantRunTask = project.tasks.getByName("transformClassesWithInstantRunFor${variantName}")
+                    if (instantRunTask) {
+                        throw new GradleException(
+                                "Tinker does not support instant run mode, please trigger build"
+                                        + " by assemble${variantName} or disable instant run"
+                                        + " in 'File->Settings...'."
+                        )
+                    }
+                } catch (UnknownTaskException e) {
+                    // Not in instant run mode, continue.
+                }
+
                 TinkerPatchSchemaTask tinkerPatchBuildTask = project.tasks.create("tinkerPatch${variantName}", TinkerPatchSchemaTask)
                 tinkerPatchBuildTask.dependsOn variant.assemble
 
-                tinkerPatchBuildTask.signconfig = variant.apkVariantData.variantConfiguration.signingConfig
+                tinkerPatchBuildTask.signConfig = variant.apkVariantData.variantConfiguration.signingConfig
 
                 variant.outputs.each { output ->
                     tinkerPatchBuildTask.buildApkPath = output.outputFile
@@ -125,6 +138,14 @@ class TinkerPatchPlugin implements Plugin<Project> {
 
                 variantOutput.processResources.dependsOn manifestTask
 
+                //resource id
+                TinkerResourceIdTask applyResourceTask = project.tasks.create("tinkerProcess${variantName}ResourceId", TinkerResourceIdTask)
+                applyResourceTask.resDir = variantOutput.processResources.resDir
+                //let applyResourceTask run after manifestTask
+                applyResourceTask.mustRunAfter manifestTask
+
+                variantOutput.processResources.dependsOn applyResourceTask
+
                 // Add this proguard settings file to the list
                 boolean proguardEnable = variant.getBuildType().buildType.minifyEnabled
 
@@ -142,14 +163,7 @@ class TinkerPatchPlugin implements Plugin<Project> {
                     multidexConfigTask.applicationVariant = variant
                     variantOutput.packageApplication.dependsOn multidexConfigTask
                 }
-//                if (tempResourceFile != null && tempResourceFile.exists() && tempResourceFile.isFile()) {
-                    TinkerResourceIdTask applyResourceTask = project.tasks.create("tinkerProcess${variantName}ResourceId", TinkerResourceIdTask)
-                    applyResourceTask.resDir = variantOutput.processResources.resDir
-                    variantOutput.processResources.dependsOn applyResourceTask
-//                }
-//                else {
-//                    project.logger.error("apply resource mapping file ${resourceMappingFile} is not exist, just ignore")
-//                }
+
             }
         }
 
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerDexExtension.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerDexExtension.groovy
index 2add6dc0..0bab55fe 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerDexExtension.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerDexExtension.groovy
@@ -31,6 +31,19 @@ public class TinkerDexExtension {
      * default: raw, keep the orginal file type
      */
     String dexMode;
+
+    /**
+     * If mUsePreGeneratedPatchDex was enabled, tinker framework would generate
+     * a dex file including all added and changed classes instead of patch info file.
+     *
+     * You can make this mode enabled if you're using any dex encrypting solutions or
+     * maintaining patches that suitable for multi-channel base packages.
+     *
+     * Notice that although you use this mode, proguard mappings should still be applied
+     * to base package and all patched packages.
+     */
+    boolean usePreGeneratedPatchDex
+
     /**
      * the dex file patterns, which dex or jar files will be deal to gen patch
      * such as [classes.dex, classes-*.dex, assets/multiDex/*.jar]
@@ -48,6 +61,7 @@ public class TinkerDexExtension {
         dexMode = "jar"
         pattern = []
         loader = []
+        usePreGeneratedPatchDex = false
         this.project = project
     }
 
@@ -60,6 +74,7 @@ public class TinkerDexExtension {
     @Override
     public String toString() {
         """| dexMode = ${dexMode}
+           | usePreGeneratedPatchDex = ${usePreGeneratedPatchDex}
            | pattern = ${pattern}
            | loader = ${loader}
         """.stripMargin()
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerPackageConfigExtension.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerPackageConfigExtension.groovy
index fbf9221a..4ed81b94 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerPackageConfigExtension.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerPackageConfigExtension.groovy
@@ -16,7 +16,7 @@
 
 package com.tencent.tinker.build.gradle.extension
 
-import com.tencent.tinker.build.apkparser.AndroidManifest
+import com.tencent.tinker.build.apkparser.AndroidParser
 import org.gradle.api.GradleException
 import org.gradle.api.Project
 
@@ -32,7 +32,7 @@ public class TinkerPackageConfigExtension {
      */
     private Map<String, String> fields
     private Project project;
-    private AndroidManifest androidManifest;
+    private AndroidParser androidManifest;
 
 
     public TinkerPackageConfigExtension(project) {
@@ -57,7 +57,7 @@ public class TinkerPackageConfigExtension {
                         String.format("old apk file %s is not exist, you can set the value directly!", oldPakFile)
                 )
             }
-            androidManifest = AndroidManifest.getAndroidManifest(oldPakFile);
+            androidManifest = AndroidParser.getAndroidManifest(oldPakFile);
         }
     }
 
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerPatchExtension.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerPatchExtension.groovy
index 81210332..17ec5b63 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerPatchExtension.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerPatchExtension.groovy
@@ -31,7 +31,7 @@ public class TinkerPatchExtension {
     String oldApk
 
     /**
-     * if there is loader class changes,
+     * If there is loader class changes,
      * or Activity, Service, Receiver, Provider change, it will terminal
      * if ignoreWarning is false
      * default: false
@@ -39,7 +39,7 @@ public class TinkerPatchExtension {
     boolean ignoreWarning
 
     /**
-     * if sign the patch file with the android signConfig
+     * If sign the patch file with the android signConfig
      * default: true
      */
     boolean useSign
@@ -53,9 +53,14 @@ public class TinkerPatchExtension {
     void checkParameter() {
         if (oldApk == null) {
             throw new GradleException("old apk is null, you must set the correct old apk value!")
-        } else if (!new File(oldApk).exists()) {
+        }
+        File apk = new File(oldApk)
+        if (!apk.exists()) {
             throw new GradleException("old apk ${oldApk} is not exist, you must set the correct old apk value!")
+        } else if (!apk.isFile()) {
+            throw new GradleException("old apk ${oldApk} is a directory, you must set the correct old apk value!")
         }
+
     }
 
     @Override
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerManifestTask.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerManifestTask.groovy
index 0b60c831..50af6687 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerManifestTask.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerManifestTask.groovy
@@ -46,7 +46,8 @@ public class TinkerManifestTask extends DefaultTask {
         project.logger.error("tinker add ${tinkerValue} to your AndroidManifest.xml ${manifestPath}")
 
         def ns = new Namespace("http://schemas.android.com/apk/res/android", "android")
-        def xml = new XmlParser().parse(manifestPath)
+
+        def xml = new XmlParser().parse(new InputStreamReader(new FileInputStream(manifestPath), "utf-8"))
 
         def application = xml.application[0]
         if (application) {
@@ -63,8 +64,7 @@ public class TinkerManifestTask extends DefaultTask {
             application.appendNode('meta-data', [(ns.name): TINKER_ID, (ns.value): tinkerValue])
 
             // Write the manifest file
-            def writer = new FileWriter(manifestPath)
-            def printer = new XmlNodePrinter(new PrintWriter(writer))
+            def printer = new XmlNodePrinter(new PrintWriter(manifestPath, "utf-8"))
             printer.preserveWhitespace = true
             printer.print(xml)
         }
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerMultidexConfigTask.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerMultidexConfigTask.groovy
index a7384fa7..edc22e81 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerMultidexConfigTask.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerMultidexConfigTask.groovy
@@ -16,6 +16,7 @@
 
 package com.tencent.tinker.build.gradle.task
 
+import com.tencent.tinker.build.auxiliaryclass.AuxiliaryClassInjector
 import com.tencent.tinker.build.gradle.TinkerPatchPlugin
 import org.gradle.api.DefaultTask
 import org.gradle.api.tasks.TaskAction
@@ -39,7 +40,7 @@ public class TinkerMultidexConfigTask extends DefaultTask {
                     "\n" +
                     "-keep public class * extends com.tencent.tinker.loader.app.TinkerApplication {\n" +
                     "    *;\n" +
-                    "}"
+                    "}\n"
 
 
     def applicationVariant
@@ -61,6 +62,7 @@ public class TinkerMultidexConfigTask extends DefaultTask {
 
         fr.write(MULTIDEX_CONFIG_SETTINGS)
         fr.write("\n")
+
         //unlike proguard, if loader endwith *, we must change to **
         fr.write("#your dex.loader patterns here\n")
         Iterable<String> loader = project.extensions.tinkerPatch.dex.loader
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerPatchSchemaTask.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerPatchSchemaTask.groovy
index 4b7cc559..8ae768d3 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerPatchSchemaTask.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerPatchSchemaTask.groovy
@@ -30,7 +30,7 @@ public class TinkerPatchSchemaTask extends DefaultTask {
     def android
     String buildApkPath
     String outputFolder
-    def signconfig
+    def signConfig
 
     public TinkerPatchSchemaTask() {
         description = 'Assemble Tinker Patch'
@@ -54,13 +54,13 @@ public class TinkerPatchSchemaTask extends DefaultTask {
 
         InputParam.Builder builder = new InputParam.Builder()
         if (configuration.useSign) {
-            if (signconfig == null) {
-                throw new GradleException("can't the get signconfig for ${taskName} build")
+            if (signConfig == null) {
+                throw new GradleException("can't the get signConfig for ${taskName} build")
             }
-            builder.setSignFile(signconfig.storeFile)
-                    .setKeypass(signconfig.keyPassword)
-                    .setStorealias(signconfig.keyAlias)
-                    .setStorepass(signconfig.storePassword)
+            builder.setSignFile(signConfig.storeFile)
+                    .setKeypass(signConfig.keyPassword)
+                    .setStorealias(signConfig.keyAlias)
+                    .setStorepass(signConfig.storePassword)
 
         }
 
@@ -68,6 +68,7 @@ public class TinkerPatchSchemaTask extends DefaultTask {
                .setNewApk(buildApkPath)
                .setOutBuilder(outputFolder)
                .setIgnoreWarning(configuration.ignoreWarning)
+               .setUsePreGeneratedPatchDex(configuration.dex.usePreGeneratedPatchDex)
                .setDexFilePattern(configuration.dex.pattern)
                .setDexLoaderPattern(configuration.dex.loader)
                .setDexMode(configuration.dex.dexMode)
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerProguardConfigTask.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerProguardConfigTask.groovy
index c0f9e0d0..8528b265 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerProguardConfigTask.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerProguardConfigTask.groovy
@@ -16,6 +16,7 @@
 
 package com.tencent.tinker.build.gradle.task
 
+import com.tencent.tinker.build.auxiliaryclass.AuxiliaryClassInjector
 import com.tencent.tinker.build.gradle.TinkerPatchPlugin
 import com.tencent.tinker.build.util.FileOperation
 import org.gradle.api.DefaultTask
@@ -31,6 +32,7 @@ public class TinkerProguardConfigTask extends DefaultTask {
     static final String PROGUARD_CONFIG_SETTINGS =
             "-keepattributes *Annotation* \n" +
                     "-dontwarn com.tencent.tinker.anno.AnnotationProcessor \n" +
+                    "-dontwarn ${AuxiliaryClassInjector.NOT_EXISTS_CLASSNAME} \n" +
                     "-keep @com.tencent.tinker.anno.DefaultLifeCycle public class *\n" +
                     "-keep public class * extends android.app.Application {\n" +
                     "    *;\n" +
@@ -86,10 +88,29 @@ public class TinkerProguardConfigTask extends DefaultTask {
         }
 
         fr.write(PROGUARD_CONFIG_SETTINGS)
+
+        // Write additional rules to keep <init> and <clinit>
+        if (project.tinkerPatch.dex.usePreGeneratedPatchDex) {
+            def additionalKeptRules =
+                            "-keep class ${AuxiliaryClassInjector.NOT_EXISTS_CLASSNAME} { \n" +
+                            '    *; \n' +
+                            '}\n' +
+                            '\n' +
+                            '-keepclassmembers class * { \n' +
+                            '    <init>(...); \n' +
+                            '    static void <clinit>(...); \n' +
+                            '}\n'
+            fr.write(additionalKeptRules)
+            fr.write('\n')
+        }
+
         fr.write("#your dex.loader patterns here\n")
         //they will removed when apply
         Iterable<String> loader = project.extensions.tinkerPatch.dex.loader
         for (String pattern : loader) {
+            if (pattern.endsWith("*") && !pattern.endsWith("**")) {
+                pattern += "*"
+            }
             fr.write("-keep class " + pattern)
             fr.write("\n")
         }
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerResourceIdTask.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerResourceIdTask.groovy
index 4e51c6a0..ba6c2c75 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerResourceIdTask.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerResourceIdTask.groovy
@@ -23,7 +23,6 @@ import com.tencent.tinker.build.aapt.RDotTxtEntry
 import com.tencent.tinker.build.gradle.TinkerPatchPlugin
 import com.tencent.tinker.build.util.FileOperation
 import org.gradle.api.DefaultTask
-import org.gradle.api.Project
 import org.gradle.api.tasks.TaskAction
 
 /**
@@ -43,24 +42,24 @@ public class TinkerResourceIdTask extends DefaultTask {
 
     @TaskAction
     def applyResourceId() {
+        String resourceMappingFile = project.extensions.tinkerPatch.buildConfig.applyResourceMapping
+
         // Parse the public.xml and ids.xml
+        if (!FileOperation.isLegalFile(resourceMappingFile)) {
+            project.logger.error("apply resource mapping file ${resourceMappingFile} is illegal, just ignore")
+            return
+        }
         String idsXml = resDir + "/values/ids.xml";
         String publicXml = resDir + "/values/public.xml";
         FileOperation.deleteFile(idsXml);
         FileOperation.deleteFile(publicXml);
         List<String> resourceDirectoryList = new ArrayList<String>()
         resourceDirectoryList.add(resDir)
-        Map<RDotTxtEntry.RType, Set<RDotTxtEntry>> rTypeResourceMap = null
 
-        String resourceMappingFile = project.extensions.tinkerPatch.buildConfig.applyResourceMapping
+        project.logger.error("we build ${project.getName()} apk with apply resource mapping file ${resourceMappingFile}")
+        project.extensions.tinkerPatch.buildConfig.usingResourceMapping = true
+        Map<RDotTxtEntry.RType, Set<RDotTxtEntry>> rTypeResourceMap = PatchUtil.readRTxt(resourceMappingFile)
 
-        if (FileOperation.isLegalFile(resourceMappingFile)) {
-            project.logger.error("we build ${project.getName()} apk with apply resource mapping file ${resourceMappingFile}")
-            project.extensions.tinkerPatch.buildConfig.usingResourceMapping = true
-            rTypeResourceMap = PatchUtil.readRTxt(resourceMappingFile);
-        } else {
-            project.logger.error("apply resource mapping file ${resourceMappingFile} is illegal, just ignore")
-        }
         AaptResourceCollector aaptResourceCollector = AaptUtil.collectResource(resourceDirectoryList, rTypeResourceMap)
         PatchUtil.generatePublicResourceXml(aaptResourceCollector, idsXml, publicXml)
         File publicFile = new File(publicXml)
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/transform/AuxiliaryInjectTransform.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/transform/AuxiliaryInjectTransform.groovy
new file mode 100644
index 00000000..c1a929b0
--- /dev/null
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/transform/AuxiliaryInjectTransform.groovy
@@ -0,0 +1,344 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.build.gradle.transform
+
+import com.android.build.api.transform.*
+import com.google.common.collect.ImmutableSet
+import com.google.common.io.Files
+import com.tencent.tinker.build.auxiliaryclass.AuxiliaryClassInjector
+import com.tencent.tinker.build.auxiliaryclass.AuxiliaryClassInjector.ProcessJarCallback
+import com.tencent.tinker.build.util.MD5
+import groovy.io.FileType
+import groovy.xml.Namespace
+import org.gradle.api.Project
+
+/**
+ * Transform for calling AuxiliaryClassInjector.
+ *
+ * @author tangyinsheng
+ */
+public class AuxiliaryInjectTransform extends Transform {
+    private static final String TRANSFORM_NAME = 'AuxiliaryInject'
+
+    private final Project project
+
+    private boolean isEnabled = false
+
+    def applicationVariants
+
+    /* ****** Variant related parameters start ****** */
+
+    boolean isInitialized = false
+    def manifestFile = null
+    def appClassName = ''
+    def appClassPathName = ''
+
+    /* ******  Variant related parameters end  ****** */
+
+    public AuxiliaryInjectTransform(Project project) {
+        this.project = project
+
+        project.afterEvaluate {
+            this.isEnabled = project.tinkerPatch.dex.usePreGeneratedPatchDex
+
+            this.applicationVariants = project.android.applicationVariants
+        }
+    }
+
+    @Override
+    String getName() {
+        return TRANSFORM_NAME
+    }
+
+    @Override
+    Set<QualifiedContent.ContentType> getInputTypes() {
+        return ImmutableSet.of(QualifiedContent.DefaultContentType.CLASSES)
+    }
+
+    @Override
+    Set<QualifiedContent.Scope> getScopes() {
+        return ImmutableSet.of(
+                QualifiedContent.Scope.PROJECT,
+                QualifiedContent.Scope.SUB_PROJECTS,
+                QualifiedContent.Scope.PROJECT_LOCAL_DEPS,
+                QualifiedContent.Scope.SUB_PROJECTS_LOCAL_DEPS,
+                QualifiedContent.Scope.EXTERNAL_LIBRARIES
+        )
+    }
+
+    @Override
+    boolean isIncremental() {
+        return true
+    }
+
+    private String getTaskNamePrefix(Transform transform) {
+        StringBuilder sb = new StringBuilder(100);
+        sb.append("transform");
+
+        Iterator<QualifiedContent.ContentType> iterator = transform.getInputTypes().iterator();
+        // there's always at least one
+        sb.append(iterator.next().name().toLowerCase(Locale.getDefault()).capitalize());
+        while (iterator.hasNext()) {
+            sb.append("And").append(
+                    iterator.next().name().toLowerCase(Locale.getDefault()).capitalize());
+        }
+
+        sb.append("With").append(transform.getName().capitalize()).append("For");
+
+        return sb.toString();
+    }
+
+    private String decapitalize(String src) {
+        char[] chars = src.toCharArray()
+        chars[0] += (char) 32
+        return new String(chars)
+    }
+
+    private void initVariantRelatedParamsIfNeeded(String variantName) {
+        if (this.isInitialized) {
+            return
+        }
+
+        // Get manifest file path.
+        this.applicationVariants.any { variant ->
+            if (variant.name.equals(variantName)) {
+                def variantOutput = variant.outputs.first()
+                this.manifestFile = variantOutput.processManifest.manifestOutputFile
+                return true  // break out.
+            }
+        }
+
+        // Get application classname from manifest file.
+        if (this.manifestFile != null) {
+            def parsedManifest = new XmlParser().parse(
+                    new InputStreamReader(new FileInputStream(this.manifestFile), "utf-8"))
+            def androidTag = new Namespace(
+                    'http://schemas.android.com/apk/res/android', 'android')
+            this.appClassName = parsedManifest.application[0].attribute(androidTag.name)
+
+            if (this.appClassName != null && this.appClassName.length() > 0) {
+                this.appClassPathName = this.appClassName.replace('.', '/') + '.class'
+            }
+        }
+
+        this.isInitialized = true
+    }
+
+    @Override
+    public void transform(TransformInvocation transformInvocation) throws TransformException, InterruptedException, IOException {
+        String variantName = decapitalize(transformInvocation.context.path.split(getTaskNamePrefix(this))[1])
+        initVariantRelatedParamsIfNeeded(variantName)
+
+        def dirInputs = new HashSet<>()
+        def jarInputs = new HashSet<>()
+
+        // Collecting inputs.
+        transformInvocation.inputs.each { input ->
+            input.directoryInputs.each { dirInput ->
+                dirInputs.add(dirInput)
+            }
+            input.jarInputs.each { jarInput ->
+                jarInputs.add(jarInput)
+            }
+        }
+
+        if (!this.isEnabled) {
+            printMsgLog("PreGeneratedPatchDex mode is disabled, skip transforming.")
+        }
+
+        if (!dirInputs.isEmpty() || !jarInputs.isEmpty()) {
+            File dirOutput = transformInvocation.outputProvider.getContentLocation(
+                    "classes", getOutputTypes(), getScopes(), Format.DIRECTORY)
+            if (!dirOutput.exists()) {
+                dirOutput.mkdirs()
+            }
+
+            if (!dirInputs.isEmpty()) {
+                dirInputs.each { dirInput ->
+                    if (transformInvocation.incremental) {
+                        dirInput.changedFiles.each { entry ->
+                            File fileInput = entry.getKey()
+                            File fileOutput = new File(fileInput.getAbsolutePath().replace(
+                                    dirInput.file.getAbsolutePath(), dirOutput.getAbsolutePath()))
+                            if (!fileOutput.exists()) {
+                                fileOutput.getParentFile().mkdirs()
+                            }
+                            final String relativeInputClassPath =
+                                    dirInput.file.toPath().relativize(fileInput.toPath())
+                                            .toString().replace('\\', '/')
+
+                            Status fileStatus = entry.getValue()
+                            switch(fileStatus) {
+                                case Status.ADDED:
+                                case Status.CHANGED:
+                                    if (fileInput.isDirectory()) {
+                                        return // continue.
+                                    }
+
+                                    // If disabled or not a class file, skip transforming them.
+                                    if (!this.isEnabled || !fileInput.getName().endsWith('.class')) {
+                                        Files.copy(fileInput, fileOutput)
+                                    } else {
+                                        // Skip application class.
+                                        if (relativeInputClassPath.equals(this.appClassPathName)) {
+                                            printWarnLog('Skipping Application class: %s',
+                                                    relativeInputClassPath)
+                                            Files.copy(fileInput, fileOutput)
+                                        } else {
+                                            printMsgLog('Processing %s file %s',
+                                                    fileStatus,
+                                                    relativeInputClassPath)
+                                            AuxiliaryClassInjector.processClass(fileInput, fileOutput)
+                                        }
+                                    }
+                                    break
+                                case Status.REMOVED:
+                                    // Print log if it's enabled only.
+                                    if (this.isEnabled) {
+                                        printMsgLog('Removing %s file %s from result.', fileStatus,
+                                                dirOutput.toPath().relativize(fileOutput.toPath()).toString())
+                                    }
+
+                                    if (fileOutput.exists()) {
+                                        if (fileOutput.isDirectory()) {
+                                            fileOutput.deleteDir()
+                                        } else {
+                                            fileOutput.delete()
+                                        }
+                                    }
+                                    break
+                            }
+                        }
+                    } else {
+                        if (dirOutput.exists()) {
+                            dirOutput.deleteDir()
+                        }
+
+                        dirInput.file.traverse(type: FileType.FILES) { fileInput ->
+                            File fileOutput = new File(fileInput.getAbsolutePath().replace(dirInput.file.getAbsolutePath(), dirOutput.getAbsolutePath()))
+                            if (!fileOutput.exists()) {
+                                fileOutput.getParentFile().mkdirs()
+                            }
+                            final String relativeInputClassPath =
+                                    dirInput.file.toPath().relativize(fileInput.toPath())
+                                            .toString().replace('\\', '/')
+
+                            // If disabled or not a class file, skip transforming them.
+                            if (!this.isEnabled || !fileInput.getName().endsWith('.class')) {
+                                Files.copy(fileInput, fileOutput)
+                            } else {
+                                // Skip application class.
+                                if (relativeInputClassPath.equals(this.appClassPathName)) {
+                                    printWarnLog('Skipping Application class: %s',
+                                            relativeInputClassPath)
+                                    Files.copy(fileInput, fileOutput)
+                                } else {
+                                    printMsgLog('Processing %s file %s',
+                                            Status.ADDED,
+                                            relativeInputClassPath)
+                                    AuxiliaryClassInjector.processClass(fileInput, fileOutput)
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+
+            if (!jarInputs.isEmpty()) {
+                jarInputs.each { jarInput ->
+                    File jarInputFile = jarInput.file
+                    File jarOutputFile = transformInvocation.outputProvider.getContentLocation(
+                            getUniqueHashName(jarInputFile), getOutputTypes(), getScopes(), Format.JAR
+                    )
+                    if (!jarOutputFile.exists()) {
+                        jarOutputFile.getParentFile().mkdirs()
+                    }
+
+                    switch (jarInput.status) {
+                        case Status.NOTCHANGED:
+                            if (transformInvocation.incremental) {
+                                break
+                            }
+                        case Status.ADDED:
+                        case Status.CHANGED:
+                            // Print log if it's enabled only.
+                            if (this.isEnabled) {
+                                printMsgLog('Processing %s file %s',
+                                        transformInvocation.incremental ? jarInput.status : Status.ADDED,
+                                        jarInputFile)
+                            }
+
+                            AuxiliaryClassInjector.processJar(jarInputFile, jarOutputFile, new ProcessJarCallback() {
+                                @Override
+                                boolean onProcessClassEntry(String entryName) {
+                                    // If disabled or not a class file, skip transforming them.
+                                    if (!this.isEnabled || !entryName.endsWith('.class')) {
+                                        return false
+                                    } else {
+                                        // Skip application class.
+                                        if (entryName.equals(AuxiliaryInjectTransform.this.appClassPathName)) {
+                                            return false
+                                        } else {
+                                            return true;
+                                        }
+                                    }
+                                }
+                            })
+                            break
+                        case Status.REMOVED:
+                            // Print log if it's enabled only.
+                            if (this.isEnabled) {
+                                printMsgLog('Removing %s file %s from result.', fileStatus,
+                                        jarOutputFile)
+                            }
+
+                            if (jarOutputFile.exists()) {
+                                jarOutputFile.delete()
+                            }
+                            break
+                    }
+                }
+            }
+        }
+    }
+
+    private String getUniqueHashName(File fileInput) {
+        final String fileInputName = fileInput.getName()
+        if (fileInput.isDirectory()) {
+            return fileInputName
+        }
+        final String parentDirPath = fileInput.getParentFile().getAbsolutePath()
+        final String pathMD5 = MD5.getMessageDigest(parentDirPath.getBytes())
+        final int extSepPos = fileInputName.lastIndexOf('.')
+        final String fileInputNamePrefix =
+                (extSepPos >= 0 ? fileInputName.substring(0, extSepPos) : fileInputName)
+        return fileInputNamePrefix + '_' + pathMD5
+    }
+
+    private void printMsgLog(String fmt, Object... vals) {
+        final String title = TRANSFORM_NAME.capitalize()
+        this.project.logger.lifecycle("[{}] {}", title,
+                (vals == null || vals.length == 0 ? fmt : String.format(fmt, vals)))
+    }
+
+    private void printWarnLog(String fmt, Object... vals) {
+        final String title = TRANSFORM_NAME.capitalize()
+        this.project.logger.warn("[{}] {}", title,
+                (vals == null || vals.length == 0 ? fmt : String.format(fmt, vals)))
+    }
+}
+
diff --git a/tinker-build/tinker-patch-lib/build.gradle b/tinker-build/tinker-patch-lib/build.gradle
index f0443dce..ddb4e9b4 100644
--- a/tinker-build/tinker-patch-lib/build.gradle
+++ b/tinker-build/tinker-patch-lib/build.gradle
@@ -9,8 +9,10 @@ group rootProject.ext.GROUP
 dependencies {
     compile fileTree(dir: 'libs', include: ['*.jar'])
     compile project(':tinker-commons')
-    compile group: 'net.dongliu', name: 'apk-parser', version: '2.1.2'
+    compile group: 'com.tencent.mm', name: 'apk-parser-lib', version: '1.0.0'
     compile group: 'com.google.guava', name: 'guava', version: '11.0.2'
+    compile group: 'org.smali', name: 'dexlib2', version: '2.1.3'
+    compile group: 'org.ow2.asm', name: 'asm-all', version: '5.0.4'
 }
 
 sourceSets {
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptResourceCollector.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptResourceCollector.java
index 97bc68c4..2682965c 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptResourceCollector.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptResourceCollector.java
@@ -38,7 +38,7 @@
     private final Map<RType, Set<RDotTxtEntry>>                   rTypeResourceMap;
     private final Map<RType, Set<RDotTxtEntry>>                   rTypeIncreaseResourceMap;
     private final Map<String, Set<String>>                        duplicateResourceMap;
-    private final Map<String, String>                             sanitizeNameMap;
+    private final Map<RType, HashMap<String, String>>             sanitizeTypeMap;
     private final Set<String>                                     ignoreIdSet;
     private       int                                             currentTypeId;
 
@@ -50,7 +50,7 @@ public AaptResourceCollector() {
         this.rTypeResourceMap = new HashMap<RType, Set<RDotTxtEntry>>();
         this.rTypeIncreaseResourceMap = new HashMap<RType, Set<RDotTxtEntry>>();
         this.duplicateResourceMap = new HashMap<String, Set<String>>();
-        this.sanitizeNameMap = new HashMap<String, String>();
+        this.sanitizeTypeMap = new HashMap<RType, HashMap<String, String>>();
         this.originalResourceMap = new HashMap<RDotTxtEntry, RDotTxtEntry>();
         this.ignoreIdSet = new HashSet<String>();
         //attr type must 1
@@ -260,9 +260,16 @@ void addRTypeResourceName(RType rType, String resourceName, String resourceValue
         }
     }
 
-    void putSanitizeName(String sanitizeName, String rawName) {
-        if (!this.sanitizeNameMap.containsKey(sanitizeName)) {
-            this.sanitizeNameMap.put(sanitizeName, rawName);
+    void putSanitizeName(RType rType, String sanitizeName, String rawName) {
+        HashMap<String, String> sanitizeNameMap;
+        if (!sanitizeTypeMap.containsKey(rType)) {
+            sanitizeNameMap = new HashMap<>();
+            sanitizeTypeMap.put(rType, sanitizeNameMap);
+        } else {
+            sanitizeNameMap = sanitizeTypeMap.get(rType);
+        }
+        if (!sanitizeNameMap.containsKey(sanitizeName)) {
+            sanitizeNameMap.put(sanitizeName, rawName);
         }
     }
 
@@ -272,8 +279,11 @@ void putSanitizeName(String sanitizeName, String rawName) {
      * @param sanitizeName
      * @return String
      */
-    public String getRawName(String sanitizeName) {
-        return this.sanitizeNameMap.get(sanitizeName);
+    public String getRawName(RType rType, String sanitizeName) {
+        if (!sanitizeTypeMap.containsKey(rType)) {
+            return null;
+        }
+        return this.sanitizeTypeMap.get(rType).get(sanitizeName);
     }
 
     /**
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptUtil.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptUtil.java
index 2a2695c0..8e058f76 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptUtil.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptUtil.java
@@ -78,7 +78,7 @@ public static AaptResourceCollector collectResource(List<String> resourceDirecto
         return collectResource(resourceDirectoryList, null);
     }
 
-    public static AaptResourceCollector collectResource(List<String> resourceDirectoryList, Map<RType, Set<com.tencent.tinker.build.aapt.RDotTxtEntry>> rTypeResourceMap) {
+    public static AaptResourceCollector collectResource(List<String> resourceDirectoryList, Map<RType, Set<RDotTxtEntry>> rTypeResourceMap) {
         AaptResourceCollector resourceCollector = new AaptResourceCollector(rTypeResourceMap);
         List<com.tencent.tinker.build.aapt.RDotTxtEntry> references = new ArrayList<com.tencent.tinker.build.aapt.RDotTxtEntry>();
         for (String resourceDirectory : resourceDirectoryList) {
@@ -98,7 +98,7 @@ public static AaptResourceCollector collectResource(List<String> resourceDirecto
         return resourceCollector;
     }
 
-    public static void processXmlFilesForIds(String resourceDirectory, List<com.tencent.tinker.build.aapt.RDotTxtEntry> references, AaptResourceCollector resourceCollector) throws Exception {
+    public static void processXmlFilesForIds(String resourceDirectory, List<RDotTxtEntry> references, AaptResourceCollector resourceCollector) throws Exception {
         List<String> xmlFullFilenameList = FileUtil.findMatchFile(resourceDirectory, Constant.Symbol.DOT + Constant.File.XML);
         if (xmlFullFilenameList != null) {
             for (String xmlFullFilename : xmlFullFilenameList) {
@@ -170,7 +170,7 @@ public static void processFileNamesInDirectory(String resourceDirectory, AaptRes
 
                 RType rType = RESOURCE_TYPES.get(directoryName);
                 resourceCollector.addIntResourceIfNotPresent(rType, resourceName);
-                com.tencent.tinker.build.aapt.ResourceDirectory resourceDirectoryBean = new com.tencent.tinker.build.aapt.ResourceDirectory(file.getParentFile().getName(), file.getAbsolutePath());
+                ResourceDirectory resourceDirectoryBean = new ResourceDirectory(file.getParentFile().getName(), file.getAbsolutePath());
                 resourceCollector.addRTypeResourceName(rType, resourceName, null, resourceDirectoryBean);
             }
         }
@@ -244,14 +244,14 @@ public static void processValuesFile(String valuesFullFilename, AaptResourceColl
                     break;
             }
             try {
-                addToResourceCollector(resourceCollector, new com.tencent.tinker.build.aapt.ResourceDirectory(directoryName, valuesFullFilename), node, rType, resourceValue);
+                addToResourceCollector(resourceCollector, new ResourceDirectory(directoryName, valuesFullFilename), node, rType, resourceValue);
             } catch (Exception e) {
                 throw new AaptUtilException(e.getMessage() + ",Process file error:" + valuesFullFilename, e);
             }
         }
     }
 
-    public static void processXmlFile(String xmlFullFilename, List<com.tencent.tinker.build.aapt.RDotTxtEntry> references, AaptResourceCollector resourceCollector) throws IOException, XPathExpressionException {
+    public static void processXmlFile(String xmlFullFilename, List<RDotTxtEntry> references, AaptResourceCollector resourceCollector) throws IOException, XPathExpressionException {
         Document document = JavaXmlUtil.parse(xmlFullFilename);
         NodeList nodesWithIds = (NodeList) ANDROID_ID_DEFINITION.evaluate(document, XPathConstants.NODESET);
         for (int i = 0; i < nodesWithIds.getLength(); i++) {
@@ -267,7 +267,9 @@ public static void processXmlFile(String xmlFullFilename, List<com.tencent.tinke
         for (int i = 0; i < nodesUsingIds.getLength(); i++) {
             String resourceName = nodesUsingIds.item(i).getNodeValue();
             int slashPosition = resourceName.indexOf('/');
-
+            if (slashPosition < 0) {
+                continue;
+            }
             String rawRType = resourceName.substring(1, slashPosition);
             String name = resourceName.substring(slashPosition + 1);
 
@@ -282,12 +284,12 @@ public static void processXmlFile(String xmlFullFilename, List<com.tencent.tinke
 //if(!resourceCollector.isContainResource(rType, IdType.INT, sanitizeName(resourceCollector, name))){
 //throw new AaptUtilException("Not found reference '" + resourceName + "' in '" + xmlFullFilename + "'");
 //}
-            references.add(new com.tencent.tinker.build.aapt.FakeRDotTxtEntry(IdType.INT, rType, sanitizeName(resourceCollector, name)));
+            references.add(new FakeRDotTxtEntry(IdType.INT, rType, sanitizeName(rType, resourceCollector, name)));
         }
     }
 
-    private static void addToResourceCollector(AaptResourceCollector resourceCollector, com.tencent.tinker.build.aapt.ResourceDirectory resourceDirectory, Node node, RType rType, String resourceValue) {
-        String resourceName = sanitizeName(resourceCollector, extractNameAttribute(node));
+    private static void addToResourceCollector(AaptResourceCollector resourceCollector, ResourceDirectory resourceDirectory, Node node, RType rType, String resourceValue) {
+        String resourceName = sanitizeName(rType, resourceCollector, extractNameAttribute(node));
         resourceCollector.addRTypeResourceName(rType, resourceName, resourceValue, resourceDirectory);
         if (rType.equals(RType.STYLEABLE)) {
 
@@ -298,7 +300,7 @@ private static void addToResourceCollector(AaptResourceCollector resourceCollect
                 }
 
                 String rawAttrName = extractNameAttribute(attrNode);
-                String attrName = sanitizeName(resourceCollector, rawAttrName);
+                String attrName = sanitizeName(rType, resourceCollector, rawAttrName);
                 resourceCollector.addResource(RType.STYLEABLE, IdType.INT, String.format("%s_%s", resourceName, attrName), Integer.toString(count++));
 
                 if (!rawAttrName.startsWith("android:")) {
@@ -313,9 +315,9 @@ private static void addToResourceCollector(AaptResourceCollector resourceCollect
         }
     }
 
-    private static String sanitizeName(AaptResourceCollector resourceCollector, String rawName) {
+    private static String sanitizeName(RType rType, AaptResourceCollector resourceCollector, String rawName) {
         String sanitizeName = rawName.replaceAll("[.:]", "_");
-        resourceCollector.putSanitizeName(sanitizeName, rawName);
+        resourceCollector.putSanitizeName(rType, sanitizeName, rawName);
         return sanitizeName;
     }
 
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/PatchUtil.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/PatchUtil.java
index 6f4a0cc1..af195a50 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/PatchUtil.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/PatchUtil.java
@@ -117,7 +117,7 @@ public static void generatePublicResourceXml(AaptResourceCollector aaptResourceC
                     Set<RDotTxtEntry> set = entry.getValue();
                     for (RDotTxtEntry rDotTxtEntry : set) {
 //                        if (rType.equals(RType.STYLE)) {
-                            String rawName = aaptResourceCollector.getRawName(rDotTxtEntry.name);
+                            String rawName = aaptResourceCollector.getRawName(rType, rDotTxtEntry.name);
                             if (StringUtil.isBlank(rawName)) {
 //                                System.err.println("Blank?" + rDotTxtEntry.name);
                                 rawName = rDotTxtEntry.name;
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/apkparser/AndroidManifest.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/apkparser/AndroidParser.java
similarity index 60%
rename from tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/apkparser/AndroidManifest.java
rename to tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/apkparser/AndroidParser.java
index ea63940f..b417847d 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/apkparser/AndroidManifest.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/apkparser/AndroidParser.java
@@ -16,9 +16,14 @@
 
 package com.tencent.tinker.build.apkparser;
 
+import com.tencent.tinker.build.patch.Configuration;
+
 import net.dongliu.apk.parser.ApkParser;
 import net.dongliu.apk.parser.bean.ApkMeta;
 import net.dongliu.apk.parser.exception.ParserException;
+import net.dongliu.apk.parser.struct.StringPool;
+import net.dongliu.apk.parser.struct.resource.ResourceTable;
+import net.dongliu.apk.parser.utils.ParseUtils;
 
 import org.w3c.dom.Document;
 import org.w3c.dom.NamedNodeMap;
@@ -27,7 +32,9 @@
 
 import java.io.ByteArrayInputStream;
 import java.io.File;
+import java.io.FileOutputStream;
 import java.io.IOException;
+import java.nio.ByteBuffer;
 import java.text.ParseException;
 import java.util.ArrayList;
 import java.util.HashMap;
@@ -39,7 +46,7 @@
 /**
  * Created by zhangshaowen on 16/5/5.
  */
-public class AndroidManifest {
+public class AndroidParser {
     public static final int TYPE_SERVICE            = 1;
     public static final int TYPE_ACTIVITY           = 2;
     public static final int TYPE_BROADCAST_RECEIVER = 3;
@@ -55,15 +62,79 @@
     public final HashMap<String, String> metaDatas = new HashMap<>();
 
 
-    public AndroidManifest(ApkMeta apkMeta, String xml) throws ParserException {
+    public AndroidParser(ApkMeta apkMeta, String xml) throws ParserException {
         this.apkMeta = apkMeta;
         this.xml = xml;
         parse();
     }
 
-    public static AndroidManifest getAndroidManifest(File file) throws IOException, ParseException {
+    public static boolean resourceTableLogicalChange(Configuration config) throws IOException {
+        ApkParser parser = new ApkParser(config.mOldApkFile);
+        ApkParser newParser = new ApkParser(config.mNewApkFile);
+        parser.parseResourceTable();
+        newParser.parseResourceTable();
+        return parser.getResourceTable().equals(newParser.getResourceTable());
+    }
+
+    public static void editResourceTableString(String from, String to, File originFile, File destFile) throws IOException {
+        if (from == null || to == null) {
+            return;
+        }
+        if (!originFile.exists()) {
+            throw new RuntimeException("origin resources.arsc is not exist, path:" + originFile.getPath());
+        }
+
+        if (from.length() != to.length()) {
+            throw new RuntimeException("only support the same string length now!");
+        }
+        ApkParser parser = new ApkParser();
+        parser.parseResourceTable(originFile);
+        ResourceTable resourceTable = parser.getResourceTable();
+        StringPool stringPool = resourceTable.getStringPool();
+        ByteBuffer buffer = resourceTable.getBuffers();
+        byte[] array = buffer.array();
+        int length = stringPool.getPool().length;
+        boolean found = false;
+        for (int i = 0; i < length; i++) {
+            String value = stringPool.get(i);
+            if (value.equals(from)) {
+                found = true;
+                long offset = stringPool.getPoolOffsets().get(i);
+                //length
+                offset += 2;
+                byte[] tempByte;
+                if (stringPool.isUtf8()) {
+                    tempByte = to.getBytes(ParseUtils.charsetUTF8);
+                    if (to.length() != tempByte.length) {
+                        throw new RuntimeException(String.format(
+                            "editResourceTableString length is different, name %d, tempByte %d\n", to.length(), tempByte.length));
+                    }
+                } else {
+                    tempByte = to.getBytes(ParseUtils.charsetUTF16);
+                    if ((to.length() * 2) != tempByte.length) {
+                        throw new RuntimeException(String.format(
+                            "editResourceTableString length is different, name %d, tempByte %d\n", to.length(), tempByte.length));
+                    }
+                }
+                System.arraycopy(tempByte, 0, array, (int) offset, tempByte.length);
+            }
+        }
+        if (!found) {
+            throw new RuntimeException("can't found string:" + from + " in the resources.arsc file's string pool!");
+        }
+
+        //write array to file
+        FileOutputStream fileOutputStream = new FileOutputStream(destFile);
+        try {
+            fileOutputStream.write(array);
+        } finally {
+            fileOutputStream.close();
+        }
+    }
+
+    public static AndroidParser getAndroidManifest(File file) throws IOException, ParseException {
         ApkParser apkParser = new ApkParser(file);
-        AndroidManifest androidManifest = new AndroidManifest(apkParser.getApkMeta(), apkParser.getManifestXml());
+        AndroidParser androidManifest = new AndroidParser(apkParser.getApkMeta(), apkParser.getManifestXml());
         return androidManifest;
     }
 
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/auxiliaryclass/AuxiliaryClassInjectAdapter.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/auxiliaryclass/AuxiliaryClassInjectAdapter.java
new file mode 100644
index 00000000..6cd7200d
--- /dev/null
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/auxiliaryclass/AuxiliaryClassInjectAdapter.java
@@ -0,0 +1,150 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.build.auxiliaryclass;
+
+import org.objectweb.asm.ClassVisitor;
+import org.objectweb.asm.ClassWriter;
+import org.objectweb.asm.Label;
+import org.objectweb.asm.MethodVisitor;
+import org.objectweb.asm.Opcodes;
+import org.objectweb.asm.Type;
+
+/**
+ * Created by tangyinsheng on 2016/10/10.
+ */
+
+public final class AuxiliaryClassInjectAdapter extends ClassVisitor {
+    private final String auxiliaryClassDesc;
+    private boolean isClInitExists;
+    private boolean isInitExists;
+    private boolean isTargetClass;
+    private boolean isInjected;
+
+    public AuxiliaryClassInjectAdapter(String auxiliaryClassName, ClassWriter cw) {
+        super(Opcodes.ASM5, cw);
+        this.auxiliaryClassDesc = fastClassNameToDesc(auxiliaryClassName);
+    }
+
+    private String fastClassNameToDesc(String className) {
+        if (className.startsWith("L") && className.endsWith(";")) {
+            return className;
+        }
+        if ("boolean".equals(className)) {
+            return "Z";
+        } else
+        if ("byte".equals(className)) {
+            return "B";
+        } else
+        if ("char".equals(className)) {
+            return "C";
+        } else
+        if ("short".equals(className)) {
+            return "S";
+        } else
+        if ("int".equals(className)) {
+            return "I";
+        } else
+        if ("long".equals(className)) {
+            return "J";
+        } else
+        if ("float".equals(className)) {
+            return "F";
+        } else
+        if ("double".equals(className)) {
+            return "D";
+        } else {
+            className = className.replace('.', '/');
+            return "L" + className + ";";
+        }
+    }
+
+    @Override
+    public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {
+        super.visit(version, access, name, signature, superName, interfaces);
+        this.isClInitExists = false;
+        this.isInitExists = false;
+        this.isTargetClass = ((access & Opcodes.ACC_INTERFACE) == 0);
+        this.isInjected = false;
+    }
+
+    @Override
+    public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {
+        MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);
+        if (mv != null && this.isTargetClass && !this.isInjected) {
+            if ("<clinit>".equals(name)) {
+                this.isClInitExists = true;
+                this.isInjected = true;
+                mv = new InjectImplMethodVisitor(mv);
+            } else
+            if ("<init>".equals(name)) {
+                this.isInitExists = true;
+                this.isInjected = true;
+                mv = new InjectImplMethodVisitor(mv);
+            }
+        }
+        return mv;
+    }
+
+    @Override
+    public void visitEnd() {
+        // If method <clinit> and <init> are not found, we should generate a <clinit>.
+        if (!this.isClInitExists && !this.isInitExists) {
+            MethodVisitor mv = super.visitMethod(Opcodes.ACC_STATIC, "<clinit>", "()V", null, null);
+            mv.visitCode();
+            mv.visitMethodInsn(Opcodes.INVOKESTATIC, "java/lang/System", "lineSeparator", "()Ljava/lang/String;", false);
+            Label lblSkipInvalidInsn = new Label();
+            mv.visitJumpInsn(Opcodes.IFNONNULL, lblSkipInvalidInsn);
+            mv.visitLdcInsn(Type.getType(this.auxiliaryClassDesc));
+            mv.visitVarInsn(Opcodes.ASTORE, 0);
+            mv.visitLabel(lblSkipInvalidInsn);
+            mv.visitInsn(Opcodes.RETURN);
+            mv.visitMaxs(1, 1);
+            mv.visitEnd();
+        }
+        super.visitEnd();
+    }
+
+    private class InjectImplMethodVisitor extends MethodVisitor {
+        InjectImplMethodVisitor(MethodVisitor mv) {
+            super(Opcodes.ASM5, mv);
+        }
+
+        @Override
+        public void visitInsn(int opcode) {
+            if (opcode == Opcodes.RETURN) {
+                super.visitMethodInsn(Opcodes.INVOKESTATIC, "java/lang/System", "lineSeparator", "()Ljava/lang/String;", false);
+                Label lblSkipInvalidInsn = new Label();
+                super.visitJumpInsn(Opcodes.IFNONNULL, lblSkipInvalidInsn);
+                super.visitLdcInsn(Type.getType(AuxiliaryClassInjectAdapter.this.auxiliaryClassDesc));
+                super.visitVarInsn(Opcodes.ASTORE, 0);
+                super.visitLabel(lblSkipInvalidInsn);
+            }
+            super.visitInsn(opcode);
+        }
+
+        @Override
+        public void visitMaxs(int maxStack, int maxLocals) {
+            if (maxStack < 1) {
+                maxStack = 1;
+            }
+            if (maxLocals < 1) {
+                maxLocals = 1;
+            }
+            super.visitMaxs(maxStack, maxLocals);
+        }
+    }
+}
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/auxiliaryclass/AuxiliaryClassInjector.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/auxiliaryclass/AuxiliaryClassInjector.java
new file mode 100644
index 00000000..a74cfea6
--- /dev/null
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/auxiliaryclass/AuxiliaryClassInjector.java
@@ -0,0 +1,153 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.build.auxiliaryclass;
+
+import com.tencent.tinker.commons.ziputil.Streams;
+
+import org.objectweb.asm.ClassReader;
+import org.objectweb.asm.ClassWriter;
+
+import java.io.BufferedInputStream;
+import java.io.BufferedOutputStream;
+import java.io.Closeable;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.nio.charset.Charset;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipInputStream;
+import java.util.zip.ZipOutputStream;
+
+/**
+ * Created by tangyinsheng on 2016/10/9.
+ */
+
+public final class AuxiliaryClassInjector {
+    // The descriptor of this class is so strange so that we hope no one
+    // would happen to create a class named the same as it.
+    public static final String NOT_EXISTS_CLASSNAME
+            = "tInKEr.pReVEnT.PrEVErIfIEd.STuBCLaSS";
+
+    public interface ProcessJarCallback {
+        boolean onProcessClassEntry(String entryName);
+    }
+
+    public static void processClass(File classIn, File classOut) throws IOException {
+        InputStream is = null;
+        OutputStream os = null;
+        try {
+            is = new BufferedInputStream(new FileInputStream(classIn));
+            os = new BufferedOutputStream(new FileOutputStream(classOut));
+            processClass(is, os);
+        } finally {
+            closeQuietly(os);
+            closeQuietly(is);
+        }
+    }
+
+    public static void processJar(File jarIn, File jarOut, ProcessJarCallback cb) throws IOException {
+        try {
+            processJarHelper(jarIn, jarOut, cb, Charset.forName("UTF-8"), Charset.forName("UTF-8"));
+        } catch (IllegalArgumentException e) {
+            if ("MALFORMED".equals(e.getMessage())) {
+                processJarHelper(jarIn, jarOut, cb, Charset.forName("GBK"), Charset.forName("UTF-8"));
+            } else {
+                throw e;
+            }
+        }
+    }
+
+    @SuppressWarnings("NewApi")
+    private static void processJarHelper(File jarIn, File jarOut, ProcessJarCallback cb, Charset charsetIn, Charset charsetOut) throws IOException {
+        ZipInputStream zis = null;
+        ZipOutputStream zos = null;
+        try {
+            zis = new ZipInputStream(new BufferedInputStream(new FileInputStream(jarIn)), charsetIn);
+            zos = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(jarOut)), charsetOut);
+            ZipEntry entryIn = null;
+            Map<String, Integer> processedEntryNamesMap = new HashMap<>();
+            while ((entryIn = zis.getNextEntry()) != null) {
+                final String entryName = entryIn.getName();
+                ZipEntry entryOut = new ZipEntry(entryIn);
+                entryOut.setCompressedSize(-1);
+                if (!processedEntryNamesMap.containsKey(entryName)) {
+                    zos.putNextEntry(entryOut);
+                    if (!entryIn.isDirectory()) {
+                        if (entryName.endsWith(".class")) {
+                            if (cb == null || cb.onProcessClassEntry(entryName)) {
+                                processClass(zis, zos);
+                            } else {
+                                Streams.copy(zis, zos);
+                            }
+                        } else {
+                            Streams.copy(zis, zos);
+                        }
+                    }
+                    zos.closeEntry();
+                    processedEntryNamesMap.put(entryName, 1);
+                } else {
+                    int duplicateCount = processedEntryNamesMap.get(entryName);
+                    final String wrapperJarName
+                            = jarOut.getName().substring(0, jarOut.getName().lastIndexOf(".jar"))
+                            + "_dup_ew_" + duplicateCount + ".jar";
+                    File wrapperJarOut = new File(jarOut.getParentFile(), wrapperJarName);
+                    wrapEntryByJar(entryOut, zis, wrapperJarOut);
+                    processedEntryNamesMap.put(entryName, duplicateCount + 1);
+                }
+            }
+        } finally {
+            closeQuietly(zos);
+            closeQuietly(zis);
+        }
+    }
+
+    private static void wrapEntryByJar(ZipEntry ze, InputStream eData, File jarOut) throws IOException {
+        ZipOutputStream zos = null;
+        try {
+            zos = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(jarOut)));
+            zos.putNextEntry(ze);
+            Streams.copy(eData, zos);
+            zos.closeEntry();
+        } finally {
+            closeQuietly(zos);
+        }
+    }
+
+    private static void processClass(InputStream classIn, OutputStream classOut) throws IOException {
+        ClassReader cr = new ClassReader(classIn);
+        ClassWriter cw = new ClassWriter(0);
+        AuxiliaryClassInjectAdapter aia = new AuxiliaryClassInjectAdapter(NOT_EXISTS_CLASSNAME, cw);
+        cr.accept(aia, 0);
+        classOut.write(cw.toByteArray());
+        classOut.flush();
+    }
+
+    private static void closeQuietly(Closeable target) {
+        if (target != null) {
+            try {
+                target.close();
+            } catch (Exception e) {
+                // Ignored.
+            }
+        }
+    }
+}
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/builder/PatchBuilder.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/builder/PatchBuilder.java
index df530e96..a607da74 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/builder/PatchBuilder.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/builder/PatchBuilder.java
@@ -23,7 +23,11 @@
 import com.tencent.tinker.build.util.TypedValue;
 
 import java.io.File;
+import java.io.FileInputStream;
 import java.io.IOException;
+import java.security.Key;
+import java.security.KeyStore;
+import java.util.ArrayList;
 
 /**
  * @author zhangshaowen
@@ -44,7 +48,7 @@ public PatchBuilder(Configuration config) {
         this.sevenZipOutPutDir = new File(config.mOutFolder, TypedValue.OUT_7ZIP_FILE_PATH);
     }
 
-    public void buildPatch() throws IOException, InterruptedException {
+    public void buildPatch() throws Exception {
         final File resultDir = config.mTempResultDir;
         if (!resultDir.exists()) {
             throw new IOException(String.format(
@@ -54,7 +58,7 @@ public void buildPatch() throws IOException, InterruptedException {
         if (resultDir.listFiles().length == 0) {
             return;
         }
-        generalUnsignedApk(unSignedApk);
+        generateUnsignedApk(unSignedApk);
         signApk(unSignedApk, signedApk);
 
         use7zApk(signedApk, signedWith7ZipApk, sevenZipOutPutDir);
@@ -79,32 +83,65 @@ public void buildPatch() throws IOException, InterruptedException {
 
     }
 
+    private String getSignatureAlgorithm() throws Exception {
+        FileInputStream fileIn = new FileInputStream(config.mSignatureFile);
+        KeyStore keyStore = KeyStore.getInstance("JKS");
+        keyStore.load(fileIn, config.mStorePass.toCharArray());
+        Key key = keyStore.getKey(config.mStoreAlias, config.mKeyPass.toCharArray());
+        String keyAlgorithm = key.getAlgorithm();
+        String signatureAlgorithm;
+        if (keyAlgorithm.equalsIgnoreCase("DSA")) {
+            signatureAlgorithm = "SHA1withDSA";
+        } else if (keyAlgorithm.equalsIgnoreCase("RSA")) {
+            signatureAlgorithm = "SHA1withRSA";
+        } else if (keyAlgorithm.equalsIgnoreCase("EC")) {
+            signatureAlgorithm = "SHA1withECDSA";
+        } else {
+            throw new RuntimeException("private key is not a DSA or "
+                + "RSA key");
+        }
+        return signatureAlgorithm;
+    }
+
     /**
      * @param input  unsigned file input
      * @param output signed file output
      * @throws IOException
      * @throws InterruptedException
      */
-    private void signApk(File input, File output) throws IOException, InterruptedException {
+    private void signApk(File input, File output) throws Exception {
         //sign apk
         if (config.mUseSignAPk) {
             Logger.d("Signing apk: %s", output.getName());
+            String signatureAlgorithm = getSignatureAlgorithm();
+            Logger.d("Signing key algorithm is %s", signatureAlgorithm);
+
             if (output.exists()) {
                 output.delete();
             }
-            String cmd = "jarsigner -sigalg MD5withRSA -digestalg SHA1 -keystore " + config.mSignatureFile
-                + " -storepass " + config.mStorePass
-                + " -keypass " + config.mKeyPass
-                + " -signedjar " + output.getAbsolutePath()
-                + " " + input.getAbsolutePath()
-                + " " + config.mStoreAlias;
-            Process pro = Runtime.getRuntime().exec(cmd);
-            //destroy the stream
-            pro.waitFor();
-            pro.destroy();
-
+            ArrayList<String> command = new ArrayList<>();
+            command.add("jarsigner");
+            // issue https://github.com/Tencent/tinker/issues/118
+            command.add("-sigalg");
+            command.add(signatureAlgorithm);
+            command.add("-digestalg");
+            command.add("SHA1");
+            command.add("-keystore");
+            command.add(config.mSignatureFile.getAbsolutePath());
+            command.add("-storepass");
+            command.add(config.mStorePass);
+            command.add("-keypass");
+            command.add(config.mKeyPass);
+            command.add("-signedjar");
+            command.add(output.getAbsolutePath());
+            command.add(input.getAbsolutePath());
+            command.add(config.mStoreAlias);
+
+            Process process = new ProcessBuilder(command).start();
+            process.waitFor();
+            process.destroy();
             if (!output.exists()) {
-                throw new IOException("Can't Generate signed APK. Please check your sign info is correct.");
+                throw new IOException("Can't Generate signed APK. Please check if your sign info is correct.");
             }
         }
     }
@@ -113,8 +150,8 @@ private void signApk(File input, File output) throws IOException, InterruptedExc
      * @param output unsigned apk file output
      * @throws IOException
      */
-    private void generalUnsignedApk(File output) throws IOException {
-        Logger.d("General unsigned apk: %s", output.getName());
+    private void generateUnsignedApk(File output) throws IOException {
+        Logger.d("Generate unsigned apk: %s", output.getName());
         final File tempOutDir = config.mTempResultDir;
         if (!tempOutDir.exists()) {
             throw new IOException(String.format(
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java
index 6c366f00..0a298879 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java
@@ -17,11 +17,14 @@
 package com.tencent.tinker.build.decoder;
 
 
+import com.google.common.io.Files;
+
 import com.tencent.tinker.android.dex.ClassDef;
 import com.tencent.tinker.android.dex.Dex;
 import com.tencent.tinker.android.dex.DexFormat;
 import com.tencent.tinker.android.dx.util.Hex;
 import com.tencent.tinker.build.dexpatcher.DexPatchGenerator;
+import com.tencent.tinker.build.dexpatcher.util.SmallDexClassInfoCollector;
 import com.tencent.tinker.build.dexpatcher.util.SmallDexPatchGenerator;
 import com.tencent.tinker.build.info.InfoWriter;
 import com.tencent.tinker.build.patch.Configuration;
@@ -39,6 +42,17 @@
 import com.tencent.tinker.commons.dexpatcher.DexPatcherLogger.IDexPatcherLogger;
 import com.tencent.tinker.commons.dexpatcher.struct.SmallPatchedDexItemFile;
 
+import org.jf.dexlib2.Opcodes;
+import org.jf.dexlib2.builder.BuilderMutableMethodImplementation;
+import org.jf.dexlib2.dexbacked.DexBackedDexFile;
+import org.jf.dexlib2.iface.DexFile;
+import org.jf.dexlib2.iface.Field;
+import org.jf.dexlib2.iface.Method;
+import org.jf.dexlib2.writer.builder.BuilderField;
+import org.jf.dexlib2.writer.builder.BuilderMethod;
+import org.jf.dexlib2.writer.builder.DexBuilder;
+import org.jf.dexlib2.writer.io.FileDataStore;
+
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
@@ -56,7 +70,9 @@
  * Created by zhangshaowen on 2016/3/23.
  */
 public class DexDiffDecoder extends BaseDecoder {
-    private static final String TEST_DEX_PATH = "test.dex";
+    private static final String TEST_DEX_NAME = "test.dex";
+    private static final String PREGENERATED_PATCH_DEX_NAME = "changed_classes.dex";
+
     private final InfoWriter logWriter;
     private final InfoWriter metaWriter;
 
@@ -141,15 +157,19 @@ public boolean patch(final File oldFile, final File newFile) throws IOException,
         //new add file
         if (oldFile == null || !oldFile.exists() || oldFile.length() == 0) {
             hasDexChanged = true;
-            copyNewDexAndMarkInMeta(newFile, newMd5, dexDiffOut);
-            return true;
+            if (!config.mUsePreGeneratedPatchDex) {
+                copyNewDexAndMarkInMeta(newFile, newMd5, dexDiffOut);
+                return true;
+            }
         }
 
         final String oldMd5 = MD5.getMD5(oldFile);
 
-        if (!oldMd5.equals(newMd5)) {
+        if ((oldMd5 != null && !oldMd5.equals(newMd5)) || (oldMd5 == null && newMd5 != null)) {
             hasDexChanged = true;
-            checkAddedOrDeletedClasses(oldFile, newFile);
+            if (oldMd5 != null) {
+                checkAddedOrDeletedClasses(oldFile, newFile);
+            }
         }
 
         RelatedInfo relatedInfo = new RelatedInfo();
@@ -159,13 +179,12 @@ public boolean patch(final File oldFile, final File newFile) throws IOException,
         // collect current old dex file and corresponding new dex file for further processing.
         oldAndNewDexFilePairList.add(new AbstractMap.SimpleEntry<>(oldFile, newFile));
 
-        final String dexName = oldFile.getName();
+        final String dexName = (oldFile != null ? oldFile.getName() : newFile.getName());
         dexNameToRelatedInfoMap.put(dexName, relatedInfo);
 
         return true;
     }
 
-    @SuppressWarnings("NewApi")
     @Override
     public void onAllPatchesEnd() throws Exception {
         if (!hasDexChanged) {
@@ -173,9 +192,125 @@ public void onAllPatchesEnd() throws Exception {
             return;
         }
 
-        File tempFullPatchDexPath = new File(config.mOutFolder + File.separator + TypedValue.DEX_TEMP_PATCH_DIR + File.separator + "full");
+        if (config.mUsePreGeneratedPatchDex) {
+            generateStubModePatchDex();
+        } else {
+            generatePatchInfoFile();
+        }
+    }
+
+    @SuppressWarnings("NewApi")
+    private void generateStubModePatchDex() throws IOException {
+        List<File> oldDexList = new ArrayList<>();
+        List<File> newDexList = new ArrayList<>();
+        for (AbstractMap.SimpleEntry<File, File> oldAndNewDexFilePair : oldAndNewDexFilePairList) {
+            File oldDexFile = oldAndNewDexFilePair.getKey();
+            File newDexFile = oldAndNewDexFilePair.getValue();
+            if (oldDexFile != null) {
+                oldDexList.add(oldDexFile);
+            }
+            if (newDexFile != null) {
+                newDexList.add(newDexFile);
+            }
+        }
+
+        DexGroup oldDexGroup = DexGroup.wrap(oldDexList);
+        DexGroup newDexGroup = DexGroup.wrap(newDexList);
+
+        SmallDexClassInfoCollector smallDexClassInfoCollector = new SmallDexClassInfoCollector();
+        smallDexClassInfoCollector.setLoaderClassPatterns(config.mDexLoaderPattern);
+        smallDexClassInfoCollector.setLogger(this.dexPatcherLoggerBridge);
+
+        Set<DexClassInfo> classInfosInPatchedDex =
+                smallDexClassInfoCollector.doCollect(oldDexGroup, newDexGroup);
+
+        // So far we have got all infos of classes we need to include in stub mode patch dex.
+        // Now construct the stub mode patch dex.
+        final Set<String> classDescsInPatchedDex = new HashSet<>();
+        Set<Dex> newDexes = new HashSet<>();
+
+        DexBuilder dexBuilder = DexBuilder.makeDexBuilder(Opcodes.forApi(15));
+
+        for (DexClassInfo classInfo : classInfosInPatchedDex) {
+            classDescsInPatchedDex.add(classInfo.classDesc);
+            newDexes.add(classInfo.owner);
+        }
+
+        for (Dex newDex : newDexes) {
+            DexFile dexFile = new DexBackedDexFile(Opcodes.forApi(15), newDex.getBytes());
+            for (org.jf.dexlib2.iface.ClassDef parsedClassDef : dexFile.getClasses()) {
+                if (classDescsInPatchedDex.contains(parsedClassDef.getType())) {
+                    List<BuilderField> builderFields = new ArrayList<>();
+                    for (Field parsedField : parsedClassDef.getFields()) {
+                        BuilderField builderField = dexBuilder.internField(
+                                parsedField.getDefiningClass(),
+                                parsedField.getName(),
+                                parsedField.getType(),
+                                parsedField.getAccessFlags(),
+                                parsedField.getInitialValue(),
+                                parsedField.getAnnotations()
+                        );
+                        builderFields.add(builderField);
+                    }
+                    List<BuilderMethod> builderMethods = new ArrayList<>();
+                    for (Method parsedMethod : parsedClassDef.getMethods()) {
+                        BuilderMethod builderMethod = dexBuilder.internMethod(
+                                parsedMethod.getDefiningClass(),
+                                parsedMethod.getName(),
+                                parsedMethod.getParameters(),
+                                parsedMethod.getReturnType(),
+                                parsedMethod.getAccessFlags(),
+                                parsedMethod.getAnnotations(),
+                                new BuilderMutableMethodImplementation(
+                                        dexBuilder, parsedMethod.getImplementation()
+                                )
+                        );
+                        builderMethods.add(builderMethod);
+                    }
+
+                    dexBuilder.internClassDef(
+                            parsedClassDef.getType(),
+                            parsedClassDef.getAccessFlags(),
+                            parsedClassDef.getSuperclass(),
+                            parsedClassDef.getInterfaces(),
+                            parsedClassDef.getSourceFile(),
+                            parsedClassDef.getAnnotations(),
+                            builderFields,
+                            builderMethods
+                    );
+                }
+            }
+        }
+
+        // Write constructed stub mode patch dex to file and record it in meta file.
+        final String dexMode = config.mDexRaw ? "raw" : "jar";
+        final File dest = new File(config.mTempResultDir + "/" + PREGENERATED_PATCH_DEX_NAME);
+
+        FileDataStore fileDataStore = new FileDataStore(dest);
+        dexBuilder.writeTo(fileDataStore);
+
+        final File tempPreGeneratedPatchDexPath = new File(config.mOutFolder + File.separator + TypedValue.DEX_TEMP_PATCH_DIR + File.separator + "pre-generated");
+        ensureDirectoryExist(tempPreGeneratedPatchDexPath);
+        Files.copy(dest, new File(tempPreGeneratedPatchDexPath, PREGENERATED_PATCH_DEX_NAME));
+
+        final String md5 = MD5.getMD5(dest);
+
+        String meta = PREGENERATED_PATCH_DEX_NAME + "," + "" + "," + md5 + "," + md5 + "," + 0
+                        + "," + 0 + "," + dexMode;
+
+        Logger.d("\nPre-generated patch dex: %s, size:%d", dest.getAbsolutePath(), dest.length());
+        Logger.d("DexDecoder:write pre-generated patch dex meta file data: %s", meta);
+
+        metaWriter.writeLineToInfoFile(meta);
+
+        addTestDex();
+    }
+
+    @SuppressWarnings("NewApi")
+    private void generatePatchInfoFile() throws IOException {
+        File tempFullPatchDexPath = new File(config.mOutFolder + File.separator + TypedValue.DEX_TEMP_PATCH_DIR + File.separator + "dalvik");
         ensureDirectoryExist(tempFullPatchDexPath);
-        File tempSmallPatchDexPath = new File(config.mOutFolder + File.separator + TypedValue.DEX_TEMP_PATCH_DIR + File.separator + "small");
+        File tempSmallPatchDexPath = new File(config.mOutFolder + File.separator + TypedValue.DEX_TEMP_PATCH_DIR + File.separator + "art");
         ensureDirectoryExist(tempSmallPatchDexPath);
 
         // Generate dex diff out and full patched dex if a pair of dex is different.
@@ -386,7 +521,7 @@ public void onAllPatchesEnd() throws Exception {
         Set<String> movedCrossFilesClassDescs = deletedClassDescs;
         if (!movedCrossFilesClassDescs.isEmpty()) {
             Logger.e("Warning:Class Moved. Some classes are just moved from one dex to another. "
-                + "This behavior may leads to unnecessary enlargement of patch file. you should try to check them:");
+                    + "This behavior may leads to unnecessary enlargement of patch file. you should try to check them:");
 
             for (String classDesc : movedCrossFilesClassDescs) {
                 StringBuilder sb = new StringBuilder();
@@ -524,14 +659,14 @@ private void addTestDex() throws IOException {
             dexMode = "raw";
         }
 
-        final InputStream is = DexDiffDecoder.class.getResourceAsStream("/" + TEST_DEX_PATH);
+        final InputStream is = DexDiffDecoder.class.getResourceAsStream("/" + TEST_DEX_NAME);
         String md5 = MD5.getMD5(is, 1024);
         is.close();
 
-        String meta = TEST_DEX_PATH + "," + "" + "," + md5 + "," + md5 + "," + 0 + "," + 0 + "," + dexMode;
+        String meta = TEST_DEX_NAME + "," + "" + "," + md5 + "," + md5 + "," + 0 + "," + 0 + "," + dexMode;
 
-        File dest = new File(config.mTempResultDir + "/" + TEST_DEX_PATH);
-        FileOperation.copyResourceUsingStream(TEST_DEX_PATH, dest);
+        File dest = new File(config.mTempResultDir + "/" + TEST_DEX_NAME);
+        FileOperation.copyResourceUsingStream(TEST_DEX_NAME, dest);
         Logger.d("\nAdd test install result dex: %s, size:%d", dest.getAbsolutePath(), dest.length());
         Logger.d("DexDecoder:write test dex meta file data: %s", meta);
 
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ManifestDecoder.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ManifestDecoder.java
index d21414ee..642b4482 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ManifestDecoder.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ManifestDecoder.java
@@ -17,7 +17,7 @@
 package com.tencent.tinker.build.decoder;
 
 
-import com.tencent.tinker.build.apkparser.AndroidManifest;
+import com.tencent.tinker.build.apkparser.AndroidParser;
 import com.tencent.tinker.build.patch.Configuration;
 import com.tencent.tinker.build.util.Logger;
 import com.tencent.tinker.build.util.TinkerPatchException;
@@ -42,8 +42,8 @@ public ManifestDecoder(Configuration config) throws IOException {
     public boolean patch(File oldFile, File newFile) throws IOException, TinkerPatchException {
         final boolean ignoreWarning = config.mIgnoreWarning;
         try {
-            AndroidManifest oldAndroidManifest = AndroidManifest.getAndroidManifest(oldFile);
-            AndroidManifest newAndroidManifest = AndroidManifest.getAndroidManifest(newFile);
+            AndroidParser oldAndroidManifest = AndroidParser.getAndroidManifest(oldFile);
+            AndroidParser newAndroidManifest = AndroidParser.getAndroidManifest(newFile);
             //check minSdkVersion
             int minSdkVersion = Integer.parseInt(oldAndroidManifest.apkMeta.getMinSdkVersion());
 
@@ -51,12 +51,12 @@ public boolean patch(File oldFile, File newFile) throws IOException, TinkerPatch
                 if (config.mDexRaw) {
                     if (ignoreWarning) {
                         //ignoreWarning, just log
-                        Logger.e("Warning:ignoreWarning is true, but your old apk's minSdkVersion %d is below 14, you should set the dexMode to 'jar', otherwise, it will be crash at some times", minSdkVersion);
+                        Logger.e("Warning:ignoreWarning is true, but your old apk's minSdkVersion %d is below 14, you should set the dexMode to 'jar', otherwise, it will crash at some time", minSdkVersion);
                     } else {
-                        Logger.e("Warning:ignoreWarning is false, but your old apk's minSdkVersion %d is below 14, you should set the dexMode to 'jar', otherwise, it will be crash at some times", minSdkVersion);
+                        Logger.e("Warning:ignoreWarning is false, but your old apk's minSdkVersion %d is below 14, you should set the dexMode to 'jar', otherwise, it will crash at some time", minSdkVersion);
 
                         throw new TinkerPatchException(
-                            String.format("ignoreWarning is false, but your old apk's minSdkVersion %d is below 14, you should set the dexMode to 'jar', otherwise, it will be crash at some times", minSdkVersion)
+                            String.format("ignoreWarning is false, but your old apk's minSdkVersion %d is below 14, you should set the dexMode to 'jar', otherwise, it will crash at some time", minSdkVersion)
                         );
                     }
                 }
@@ -76,11 +76,11 @@ public boolean patch(File oldFile, File newFile) throws IOException, TinkerPatch
                 }
                 if (!found) {
                     if (ignoreWarning) {
-                        Logger.e("Warning:ignoreWarning is true, but we found a new AndroidComponent %s, it will be crash at some times", newComponentName);
+                        Logger.e("Warning:ignoreWarning is true, but we found a new AndroidComponent %s, it will crash at some time", newComponentName);
                     } else {
-                        Logger.e("Warning:ignoreWarning is false, but we found a new AndroidComponent %s, it will be crash at some times", newComponentName);
+                        Logger.e("Warning:ignoreWarning is false, but we found a new AndroidComponent %s, it will crash at some time", newComponentName);
                         throw new TinkerPatchException(
-                            String.format("ignoreWarning is false, but we found a new AndroidComponent %s, it will be crash at some times", newComponentName)
+                            String.format("ignoreWarning is false, but we found a new AndroidComponent %s, it will crash at some time", newComponentName)
                         );
                     }
                 }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ResDiffDecoder.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ResDiffDecoder.java
index 193b41c1..9ec77664 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ResDiffDecoder.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ResDiffDecoder.java
@@ -17,6 +17,7 @@
 package com.tencent.tinker.build.decoder;
 
 import com.tencent.tinker.bsdiff.BSDiff;
+import com.tencent.tinker.build.apkparser.AndroidParser;
 import com.tencent.tinker.build.info.InfoWriter;
 import com.tencent.tinker.build.patch.Configuration;
 import com.tencent.tinker.build.util.FileOperation;
@@ -41,6 +42,8 @@
  * Created by zhangshaowen on 16/8/8.
  */
 public class ResDiffDecoder extends BaseDecoder {
+    private static final String TEST_RESOURCE_NAME        = "only_use_to_test_tinker_resource.txt";
+    private static final String TEST_RESOURCE_ASSETS_PATH = "assets/" + TEST_RESOURCE_NAME;
 
     private static final String TEMP_RES_ZIP  = "temp_res.zip";
     private static final String TEMP_RES_7ZIP = "temp_res_7ZIP.zip";
@@ -80,8 +83,8 @@ public void clean() {
     }
 
     private boolean checkLargeModFile(File file) {
-        long lenght = file.length();
-        if (lenght > config.mLargeModSize * TypedValue.K_BYTES) {
+        long length = file.length();
+        if (length > config.mLargeModSize * TypedValue.K_BYTES) {
             return true;
         }
         return false;
@@ -89,14 +92,16 @@ private boolean checkLargeModFile(File file) {
 
     @Override
     public boolean patch(File oldFile, File newFile) throws IOException, TinkerPatchException {
+        String name = getRelativeString(newFile);
+
         //actually, it won't go below
         if (newFile == null || !newFile.exists()) {
-            String name = getRelativeStringByOldDir(oldFile);
-            if (Utils.checkFileInPattern(config.mResIgnoreChangePattern, name)) {
-                Logger.e("found delete resource: " + name + " ,but it match ignore change pattern, just ignore!");
+            String relativeStringByOldDir = getRelativeStringByOldDir(oldFile);
+            if (Utils.checkFileInPattern(config.mResIgnoreChangePattern, relativeStringByOldDir)) {
+                Logger.e("found delete resource: " + relativeStringByOldDir + " ,but it match ignore change pattern, just ignore!");
                 return false;
             }
-            deletedSet.add(name);
+            deletedSet.add(relativeStringByOldDir);
             writeResLog(newFile, oldFile, TypedValue.DEL);
             return true;
         }
@@ -104,7 +109,6 @@ public boolean patch(File oldFile, File newFile) throws IOException, TinkerPatch
         File outputFile = getOutputPath(newFile).toFile();
 
         if (oldFile == null || !oldFile.exists()) {
-            String name = getRelativeString(newFile);
             if (Utils.checkFileInPattern(config.mResIgnoreChangePattern, name)) {
                 Logger.e("found add resource: " + name + " ,but it match ignore change pattern, just ignore!");
                 return false;
@@ -126,15 +130,25 @@ public boolean patch(File oldFile, File newFile) throws IOException, TinkerPatch
         if (oldMd5 != null && oldMd5.equals(newMd5)) {
             return false;
         }
-        String name = getRelativeString(newFile);
         if (Utils.checkFileInPattern(config.mResIgnoreChangePattern, name)) {
-            Logger.e("found modify resource: " + name + " ,but it match ignore change pattern, just ignore!");
+            Logger.d("found modify resource: " + name + ", but it match ignore change pattern, just ignore!");
             return false;
         }
         if (name.equals(TypedValue.RES_MANIFEST)) {
-            Logger.e("found modify resource: " + name + " ,but it is AndroidManifest.xml, just ignore!");
+            Logger.d("found modify resource: " + name + ", but it is AndroidManifest.xml, just ignore!");
             return false;
         }
+        if (name.equals(TypedValue.RES_ARSC)) {
+            if (AndroidParser.resourceTableLogicalChange(config)) {
+                Logger.d("found modify resource: " + name + ", but it is logically the same as original new resources.arsc, just ignore!");
+                return false;
+            }
+        }
+        dealWithModeFile(name, newMd5, oldFile, newFile, outputFile);
+        return true;
+    }
+
+    private boolean dealWithModeFile(String name, String newMd5, File oldFile, File newFile, File outputFile) throws IOException {
         if (checkLargeModFile(newFile)) {
             if (!outputFile.getParentFile().exists()) {
                 outputFile.getParentFile().mkdirs();
@@ -155,7 +169,7 @@ public boolean patch(File oldFile, File newFile) throws IOException, TinkerPatch
         modifiedSet.add(name);
         FileOperation.copyFileUsingStream(newFile, outputFile);
         writeResLog(newFile, oldFile, TypedValue.MOD);
-        return true;
+        return false;
     }
 
     private void writeResLog(File newFile, File oldFile, int mode) throws IOException {
@@ -197,6 +211,16 @@ public void onAllPatchesStart() throws IOException, TinkerPatchException {
 
     }
 
+    private void addAssetsFileForTestResource() throws IOException {
+        File dest = new File(config.mTempResultDir + "/" + TEST_RESOURCE_ASSETS_PATH);
+        FileOperation.copyResourceUsingStream(TEST_RESOURCE_NAME, dest);
+        addedSet.add(TEST_RESOURCE_ASSETS_PATH);
+        Logger.d("Add Test resource file: " + TEST_RESOURCE_ASSETS_PATH);
+        String log = "add test resource: " + TEST_RESOURCE_ASSETS_PATH + ", oldSize=" + 0 + ", newSize="
+            + FileOperation.getFileSizes(dest);
+        logWriter.writeLineToInfoFile(log);
+    }
+
     @Override
     public void onAllPatchesEnd() throws IOException, TinkerPatchException {
         //only there is only deleted set, we just ignore
@@ -211,12 +235,13 @@ public void onAllPatchesEnd() throws IOException, TinkerPatchException {
             throw new TinkerPatchException("resource must contain AndroidManifest.xml pattern");
         }
 
+        addAssetsFileForTestResource();
+
         //check gradle build
         if (config.mUsingGradle) {
+            final boolean ignoreWarning = config.mIgnoreWarning;
             final boolean resourceArscChanged = modifiedSet.contains(TypedValue.RES_ARSC)
                 || largeModifiedSet.contains(TypedValue.RES_ARSC);
-            final boolean ignoreWarning = config.mIgnoreWarning;
-
             if (resourceArscChanged && !config.mUseApplyResource) {
                 if (ignoreWarning) {
                     //ignoreWarning, just log
@@ -259,9 +284,9 @@ public void onAllPatchesEnd() throws IOException, TinkerPatchException {
         String resZipMd5 = Utils.genResOutputFile(extractToZip, tempResZip, config,
             addedSet, modifiedSet, deletedSet, largeModifiedSet, largeModifiedMap);
 
-        Logger.e("final normal zip resource: %s, size=%d, md5=%s", extractToZip.getName(), extractToZip.length(), resZipMd5);
+        Logger.e("Final normal zip resource: %s, size=%d, md5=%s", extractToZip.getName(), extractToZip.length(), resZipMd5);
         logWriter.writeLineToInfoFile(
-            String.format("final normal zip resource: %s, size=%d, md5=%s", extractToZip.getName(), extractToZip.length(), resZipMd5)
+            String.format("Final normal zip resource: %s, size=%d, md5=%s", extractToZip.getName(), extractToZip.length(), resZipMd5)
         );
         //delete temp file
         FileOperation.deleteFile(tempResZip);
@@ -279,9 +304,9 @@ public void onAllPatchesEnd() throws IOException, TinkerPatchException {
                     addedSet, modifiedSet, deletedSet, largeModifiedSet, largeModifiedMap);
                 //delete temp file
                 FileOperation.deleteFile(tempRes7Zip);
-                Logger.e("final 7zip resource: %s, size=%d, md5=%s", extractTo7Zip.getName(), extractTo7Zip.length(), res7zipMd5);
+                Logger.e("Final 7zip resource: %s, size=%d, md5=%s", extractTo7Zip.getName(), extractTo7Zip.length(), res7zipMd5);
                 logWriter.writeLineToInfoFile(
-                    String.format("final 7zip resource: %s, size=%d, md5=%s", extractTo7Zip.getName(), extractTo7Zip.length(), res7zipMd5)
+                    String.format("Final 7zip resource: %s, size=%d, md5=%s", extractTo7Zip.getName(), extractTo7Zip.length(), res7zipMd5)
                 );
             }
         }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/DexPatchGenerator.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/DexPatchGenerator.java
index 8bbe973b..d058b2d0 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/DexPatchGenerator.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/DexPatchGenerator.java
@@ -547,173 +547,129 @@ private void writeResultToStream(OutputStream os) throws IOException {
         buffer.writeInt(firstChunkOffset);
         buffer.position(firstChunkOffset);
 
-        new PatchOperationsWriter<StringData>(this.stringDataSectionDiffAlg.getPatchOperationList()) {
-            @Override
-            protected void writeItem(DexDataBuffer buffer, StringData item) {
-                buffer.writeStringData(item);
-            }
-        }.writeToBuffer(buffer);
-
-        new PatchOperationsWriter<Integer>(this.typeIdSectionDiffAlg.getPatchOperationList()) {
-            @Override
-            protected void writeItem(DexDataBuffer buffer, Integer item) {
-                buffer.writeInt(item);
-            }
-        }.writeToBuffer(buffer);
-
-        new PatchOperationsWriter<TypeList>(this.typeListSectionDiffAlg.getPatchOperationList()) {
-            @Override
-            protected void writeItem(DexDataBuffer buffer, TypeList item) {
-                buffer.writeTypeList(item);
-            }
-        }.writeToBuffer(buffer);
-
-        new PatchOperationsWriter<ProtoId>(this.protoIdSectionDiffAlg.getPatchOperationList()) {
-            @Override
-            protected void writeItem(DexDataBuffer buffer, ProtoId item) {
-                buffer.writeProtoId(item);
-            }
-        }.writeToBuffer(buffer);
-
-        new PatchOperationsWriter<FieldId>(this.fieldIdSectionDiffAlg.getPatchOperationList()) {
-            @Override
-            protected void writeItem(DexDataBuffer buffer, FieldId item) {
-                buffer.writeFieldId(item);
-            }
-        }.writeToBuffer(buffer);
-
-        new PatchOperationsWriter<MethodId>(this.methodIdSectionDiffAlg.getPatchOperationList()) {
-            @Override
-            protected void writeItem(DexDataBuffer buffer, MethodId item) {
-                buffer.writeMethodId(item);
-            }
-        }.writeToBuffer(buffer);
-
-        new PatchOperationsWriter<Annotation>(this.annotationSectionDiffAlg.getPatchOperationList()) {
-            @Override
-            protected void writeItem(DexDataBuffer buffer, Annotation item) {
-                buffer.writeAnnotation(item);
-            }
-        }.writeToBuffer(buffer);
-
-        new PatchOperationsWriter<AnnotationSet>(this.annotationSetSectionDiffAlg.getPatchOperationList()) {
-            @Override
-            protected void writeItem(DexDataBuffer buffer, AnnotationSet item) {
-                buffer.writeAnnotationSet(item);
-            }
-        }.writeToBuffer(buffer);
-
-        new PatchOperationsWriter<AnnotationSetRefList>(this.annotationSetRefListSectionDiffAlg.getPatchOperationList()) {
-            @Override
-            protected void writeItem(DexDataBuffer buffer, AnnotationSetRefList item) {
-                buffer.writeAnnotationSetRefList(item);
-            }
-        }.writeToBuffer(buffer);
-
-        new PatchOperationsWriter<AnnotationsDirectory>(this.annotationsDirectorySectionDiffAlg.getPatchOperationList()) {
-            @Override
-            protected void writeItem(DexDataBuffer buffer, AnnotationsDirectory item) {
-                buffer.writeAnnotationsDirectory(item);
-            }
-        }.writeToBuffer(buffer);
-
-        new PatchOperationsWriter<DebugInfoItem>(this.debugInfoSectionDiffAlg.getPatchOperationList()) {
-            @Override
-            protected void writeItem(DexDataBuffer buffer, DebugInfoItem item) {
-                buffer.writeDebugInfoItem(item);
-            }
-        }.writeToBuffer(buffer);
-
-        new PatchOperationsWriter<Code>(this.codeSectionDiffAlg.getPatchOperationList()) {
-            @Override
-            protected void writeItem(DexDataBuffer buffer, Code item) {
-                buffer.writeCode(item);
-            }
-        }.writeToBuffer(buffer);
-
-        new PatchOperationsWriter<ClassData>(this.classDataSectionDiffAlg.getPatchOperationList()) {
-            @Override
-            protected void writeItem(DexDataBuffer buffer, ClassData item) {
-                buffer.writeClassData(item);
-            }
-        }.writeToBuffer(buffer);
-
-        new PatchOperationsWriter<EncodedValue>(this.encodedArraySectionDiffAlg.getPatchOperationList()) {
-            @Override
-            protected void writeItem(DexDataBuffer buffer, EncodedValue item) {
-                buffer.writeEncodedArray(item);
-            }
-        }.writeToBuffer(buffer);
-
-        new PatchOperationsWriter<ClassDef>(this.classDefSectionDiffAlg.getPatchOperationList()) {
-            @Override
-            protected void writeItem(DexDataBuffer buffer, ClassDef item) {
-                buffer.writeClassDef(item);
-            }
-        }.writeToBuffer(buffer);
+        writePatchOperations(buffer, this.stringDataSectionDiffAlg.getPatchOperationList());
+        writePatchOperations(buffer, this.typeIdSectionDiffAlg.getPatchOperationList());
+        writePatchOperations(buffer, this.typeListSectionDiffAlg.getPatchOperationList());
+        writePatchOperations(buffer, this.protoIdSectionDiffAlg.getPatchOperationList());
+        writePatchOperations(buffer, this.fieldIdSectionDiffAlg.getPatchOperationList());
+        writePatchOperations(buffer, this.methodIdSectionDiffAlg.getPatchOperationList());
+        writePatchOperations(buffer, this.annotationSectionDiffAlg.getPatchOperationList());
+        writePatchOperations(buffer, this.annotationSetSectionDiffAlg.getPatchOperationList());
+        writePatchOperations(buffer, this.annotationSetRefListSectionDiffAlg.getPatchOperationList());
+        writePatchOperations(buffer, this.annotationsDirectorySectionDiffAlg.getPatchOperationList());
+        writePatchOperations(buffer, this.debugInfoSectionDiffAlg.getPatchOperationList());
+        writePatchOperations(buffer, this.codeSectionDiffAlg.getPatchOperationList());
+        writePatchOperations(buffer, this.classDataSectionDiffAlg.getPatchOperationList());
+        writePatchOperations(buffer, this.encodedArraySectionDiffAlg.getPatchOperationList());
+        writePatchOperations(buffer, this.classDefSectionDiffAlg.getPatchOperationList());
 
         byte[] bufferData = buffer.array();
         os.write(bufferData);
         os.flush();
     }
 
-    private abstract class PatchOperationsWriter<T> {
-        private final List<PatchOperation<T>> patchOperationList;
-
-        PatchOperationsWriter(List<PatchOperation<T>> patchOperationList) {
-            this.patchOperationList = patchOperationList;
-        }
-
-        protected abstract void writeItem(DexDataBuffer buffer, T item);
-
-        public final void writeToBuffer(DexDataBuffer buffer) {
-            List<Integer> delOpIndexList = new ArrayList<>(patchOperationList.size());
-            List<Integer> addOpIndexList = new ArrayList<>(patchOperationList.size());
-            List<Integer> replaceOpIndexList = new ArrayList<>(patchOperationList.size());
-            List<T> newItemList = new ArrayList<>(patchOperationList.size());
-
-            for (PatchOperation<T> patchOperation : patchOperationList) {
-                switch (patchOperation.op) {
-                    case PatchOperation.OP_DEL: {
-                        delOpIndexList.add(patchOperation.index);
-                        break;
-                    }
-                    case PatchOperation.OP_ADD: {
-                        addOpIndexList.add(patchOperation.index);
-                        newItemList.add(patchOperation.newItem);
-                        break;
-                    }
-                    case PatchOperation.OP_REPLACE: {
-                        replaceOpIndexList.add(patchOperation.index);
-                        newItemList.add(patchOperation.newItem);
-                        break;
-                    }
+    private <T extends Comparable<T>> void writePatchOperations(
+            DexDataBuffer buffer, List<PatchOperation<T>> patchOperationList
+    ) {
+        List<Integer> delOpIndexList = new ArrayList<>(patchOperationList.size());
+        List<Integer> addOpIndexList = new ArrayList<>(patchOperationList.size());
+        List<Integer> replaceOpIndexList = new ArrayList<>(patchOperationList.size());
+        List<T> newItemList = new ArrayList<>(patchOperationList.size());
+
+        for (PatchOperation<T> patchOperation : patchOperationList) {
+            switch (patchOperation.op) {
+                case PatchOperation.OP_DEL: {
+                    delOpIndexList.add(patchOperation.index);
+                    break;
+                }
+                case PatchOperation.OP_ADD: {
+                    addOpIndexList.add(patchOperation.index);
+                    newItemList.add(patchOperation.newItem);
+                    break;
+                }
+                case PatchOperation.OP_REPLACE: {
+                    replaceOpIndexList.add(patchOperation.index);
+                    newItemList.add(patchOperation.newItem);
+                    break;
                 }
             }
+        }
 
-            buffer.writeUleb128(delOpIndexList.size());
-            int lastIndex = 0;
-            for (Integer index : delOpIndexList) {
-                buffer.writeSleb128(index - lastIndex);
-                lastIndex = index;
-            }
+        buffer.writeUleb128(delOpIndexList.size());
+        int lastIndex = 0;
+        for (Integer index : delOpIndexList) {
+            buffer.writeSleb128(index - lastIndex);
+            lastIndex = index;
+        }
 
-            buffer.writeUleb128(addOpIndexList.size());
-            lastIndex = 0;
-            for (Integer index : addOpIndexList) {
-                buffer.writeSleb128(index - lastIndex);
-                lastIndex = index;
-            }
+        buffer.writeUleb128(addOpIndexList.size());
+        lastIndex = 0;
+        for (Integer index : addOpIndexList) {
+            buffer.writeSleb128(index - lastIndex);
+            lastIndex = index;
+        }
 
-            buffer.writeUleb128(replaceOpIndexList.size());
-            lastIndex = 0;
-            for (Integer index : replaceOpIndexList) {
-                buffer.writeSleb128(index - lastIndex);
-                lastIndex = index;
-            }
+        buffer.writeUleb128(replaceOpIndexList.size());
+        lastIndex = 0;
+        for (Integer index : replaceOpIndexList) {
+            buffer.writeSleb128(index - lastIndex);
+            lastIndex = index;
+        }
 
-            for (T newItem : newItemList) {
-                writeItem(buffer, newItem);
+        for (T newItem : newItemList) {
+            if (newItem instanceof StringData) {
+                buffer.writeStringData((StringData) newItem);
+            } else
+            if (newItem instanceof Integer) {
+                // TypeId item.
+                buffer.writeInt((Integer) newItem);
+            } else
+            if (newItem instanceof TypeList) {
+                buffer.writeTypeList((TypeList) newItem);
+            } else
+            if (newItem instanceof ProtoId) {
+                buffer.writeProtoId((ProtoId) newItem);
+            } else
+            if (newItem instanceof FieldId) {
+                buffer.writeFieldId((FieldId) newItem);
+            } else
+            if (newItem instanceof MethodId) {
+                buffer.writeMethodId((MethodId) newItem);
+            } else
+            if (newItem instanceof Annotation) {
+                buffer.writeAnnotation((Annotation) newItem);
+            } else
+            if (newItem instanceof AnnotationSet) {
+                buffer.writeAnnotationSet((AnnotationSet) newItem);
+            } else
+            if (newItem instanceof AnnotationSetRefList) {
+                buffer.writeAnnotationSetRefList(
+                        (AnnotationSetRefList) newItem
+                );
+            } else
+            if (newItem instanceof AnnotationsDirectory) {
+                buffer.writeAnnotationsDirectory(
+                        (AnnotationsDirectory) newItem
+                );
+            } else
+            if (newItem instanceof DebugInfoItem) {
+                buffer.writeDebugInfoItem((DebugInfoItem) newItem);
+            } else
+            if (newItem instanceof Code) {
+                buffer.writeCode((Code) newItem);
+            } else
+            if (newItem instanceof ClassData) {
+                buffer.writeClassData((ClassData) newItem);
+            } else
+            if (newItem instanceof EncodedValue) {
+                buffer.writeEncodedArray((EncodedValue) newItem);
+            } else
+            if (newItem instanceof ClassDef) {
+                buffer.writeClassDef((ClassDef) newItem);
+            } else {
+                throw new IllegalStateException(
+                        "Unknown item type: " + newItem.getClass()
+                );
             }
         }
     }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/DexSectionDiffAlgorithm.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/DexSectionDiffAlgorithm.java
index 9bf57a8e..9c3f9671 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/DexSectionDiffAlgorithm.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/DexSectionDiffAlgorithm.java
@@ -179,6 +179,16 @@ protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffse
 
     /**
      * Mark deleted index or offset in {@code indexMap}.
+     *
+     * Here we mark deleted item for such a case like this:
+     *   Item in DebugInfo section reference a string in StringData section
+     *   by index X, while in patched dex, the referenced string is removed.
+     *
+     * The {@code indexMap} must be aware of this case and return -1
+     * instead of the original value X.
+     *
+     * Further more, the special value -1 is not chosen by our inspiration but
+     * the definition of NO_INDEX in document of dex file format.
      */
     protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
         // Should override by subclass if needed.
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/ClassReferringInsnVisitor.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/ClassReferringInsnVisitor.java
new file mode 100644
index 00000000..af443b81
--- /dev/null
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/ClassReferringInsnVisitor.java
@@ -0,0 +1,136 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.build.dexpatcher.util;
+
+import com.tencent.tinker.android.dex.ClassData;
+import com.tencent.tinker.android.dex.Dex;
+import com.tencent.tinker.android.dex.FieldId;
+import com.tencent.tinker.android.dex.MethodId;
+import com.tencent.tinker.android.dex.ProtoId;
+import com.tencent.tinker.android.dx.instruction.InstructionCodec;
+import com.tencent.tinker.android.dx.instruction.InstructionVisitor;
+import com.tencent.tinker.commons.dexpatcher.DexPatcherLogger;
+
+import java.util.Collection;
+
+/**
+ * Created by tangyinsheng on 2016/10/8.
+ */
+
+public class ClassReferringInsnVisitor extends InstructionVisitor {
+    private static final String TAG = "ClassReferringInsnVisitor";
+
+    private final Dex methodOwner;
+    private final ClassData.Method method;
+    private final Collection<String> classDescsToCheck;
+    private final DexPatcherLogger logger;
+
+    public boolean isMethodReferencedToAnyProvidedClasses;
+
+    ClassReferringInsnVisitor(Dex methodOwner, ClassData.Method method, Collection<String> classDescsToCheck, DexPatcherLogger logger) {
+        super(null);
+        this.methodOwner = methodOwner;
+        this.method = method;
+        this.classDescsToCheck = classDescsToCheck;
+        this.logger = logger;
+        this.isMethodReferencedToAnyProvidedClasses = false;
+    }
+
+    @Override
+    public void visitZeroRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal) {
+        processIndexByType(index, indexType);
+    }
+
+    @Override
+    public void visitOneRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a) {
+        processIndexByType(index, indexType);
+    }
+
+    @Override
+    public void visitTwoRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int b) {
+        processIndexByType(index, indexType);
+    }
+
+    @Override
+    public void visitThreeRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int b, int c) {
+        processIndexByType(index, indexType);
+    }
+
+    @Override
+    public void visitFourRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int b, int c, int d) {
+        processIndexByType(index, indexType);
+    }
+
+    @Override
+    public void visitFiveRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int b, int c, int d, int e) {
+        processIndexByType(index, indexType);
+    }
+
+    @Override
+    public void visitRegisterRangeInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int registerCount) {
+        processIndexByType(index, indexType);
+    }
+
+    private void processIndexByType(int index, int indexType) {
+        String typeName = null;
+        String refInfoInLog = null;
+        switch (indexType) {
+            case InstructionCodec.INDEX_TYPE_TYPE_REF: {
+                typeName = methodOwner.typeNames().get(index);
+                refInfoInLog = "init class";
+                break;
+            }
+            case InstructionCodec.INDEX_TYPE_FIELD_REF: {
+                final FieldId fieldId = methodOwner.fieldIds().get(index);
+                typeName = methodOwner.typeNames().get(fieldId.declaringClassIndex);
+                refInfoInLog = "referencing to field: " + methodOwner.strings().get(fieldId.nameIndex);
+                break;
+            }
+            case InstructionCodec.INDEX_TYPE_METHOD_REF: {
+                final MethodId methodId = methodOwner.methodIds().get(index);
+                typeName = methodOwner.typeNames().get(methodId.declaringClassIndex);
+                refInfoInLog = "invoking method: " + getMethodProtoTypeStr(methodId);
+                break;
+            }
+        }
+        if (typeName != null && classDescsToCheck.contains(typeName)) {
+            MethodId methodId = methodOwner.methodIds().get(method.methodIndex);
+            logger.i(
+                    TAG,
+                    "Method %s in class %s referenced class %s by %s",
+                    getMethodProtoTypeStr(methodId),
+                    methodOwner.typeNames().get(methodId.declaringClassIndex),
+                    typeName,
+                    refInfoInLog
+            );
+            isMethodReferencedToAnyProvidedClasses = true;
+        }
+    }
+
+    private String getMethodProtoTypeStr(MethodId methodId) {
+        StringBuilder strBuilder = new StringBuilder();
+        strBuilder.append(methodOwner.strings().get(methodId.nameIndex));
+        ProtoId protoId = methodOwner.protoIds().get(methodId.protoIndex);
+        strBuilder.append('(');
+        short[] paramTypeIds = methodOwner.parameterTypeIndicesFromMethodId(methodId);
+        for (short typeId : paramTypeIds) {
+            strBuilder.append(methodOwner.typeNames().get(typeId));
+        }
+        strBuilder.append(')').append(methodOwner.typeNames().get(protoId.returnTypeIndex));
+        return strBuilder.toString();
+    }
+}
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/SmallDexClassInfoCollector.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/SmallDexClassInfoCollector.java
new file mode 100644
index 00000000..3a3a3428
--- /dev/null
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/SmallDexClassInfoCollector.java
@@ -0,0 +1,219 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.build.dexpatcher.util;
+
+import com.tencent.tinker.android.dex.ClassData;
+import com.tencent.tinker.android.dex.ClassDef;
+import com.tencent.tinker.android.dex.Code;
+import com.tencent.tinker.android.dex.Dex;
+import com.tencent.tinker.android.dx.instruction.InstructionReader;
+import com.tencent.tinker.android.dx.instruction.ShortArrayCodeInput;
+import com.tencent.tinker.build.util.DexClassesComparator;
+import com.tencent.tinker.build.util.DexClassesComparator.DexClassInfo;
+import com.tencent.tinker.build.util.DexClassesComparator.DexGroup;
+import com.tencent.tinker.commons.dexpatcher.DexPatcherLogger;
+
+import java.io.EOFException;
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.Set;
+
+/**
+ * Created by tangyinsheng on 2016/10/8.
+ */
+
+public final class SmallDexClassInfoCollector {
+    private static final String TAG = "SmallDexClassInfoCollector";
+
+    private static final DexPatcherLogger logger = new DexPatcherLogger();
+    private final Set<String> loaderClassPatterns = new HashSet<>();
+
+    public SmallDexClassInfoCollector setLoaderClassPatterns(Collection<String> loaderClassPatterns) {
+        this.loaderClassPatterns.clear();
+        this.loaderClassPatterns.addAll(loaderClassPatterns);
+        return this;
+    }
+
+    public SmallDexClassInfoCollector addLoaderClassPattern(String loaderClassPattern) {
+        this.loaderClassPatterns.add(loaderClassPattern);
+        return this;
+    }
+
+    public SmallDexClassInfoCollector clearLoaderClassPattern() {
+        this.loaderClassPatterns.clear();
+        return this;
+    }
+
+    public SmallDexClassInfoCollector setLogger(DexPatcherLogger.IDexPatcherLogger loggerImpl) {
+        this.logger.setLoggerImpl(loggerImpl);
+        return this;
+    }
+
+    // Collect target:
+    //  Added classes;
+    //  Changed classes;
+    //  Subclasses of referrer-affected changed classes;
+    //  Classes which refer to changed classes.
+    public Set<DexClassInfo> doCollect(DexGroup oldDexGroup, DexGroup newDexGroup) {
+        Set<DexClassInfo> classInfosInSmallDex = new HashSet<>();
+
+        DexClassesComparator dexClassesCmp = new DexClassesComparator("*");
+        dexClassesCmp.setIgnoredRemovedClassDescPattern(this.loaderClassPatterns);
+
+        dexClassesCmp.setCompareMode(DexClassesComparator.COMPARE_MODE_CAUSE_REF_CHANGE_ONLY);
+        dexClassesCmp.startCheck(oldDexGroup, newDexGroup);
+
+        Set<String> referrerAffectedChangedClassDescs
+                = dexClassesCmp.getChangedClassDescToInfosMap().keySet();
+
+        Set<String> referrerAffectedChangedClassesChainSet = new HashSet<>();
+        referrerAffectedChangedClassesChainSet.addAll(referrerAffectedChangedClassDescs);
+
+        // Add added classes to small patched dex.
+        Collection<DexClassInfo> addedClassInfos = dexClassesCmp.getAddedClassInfos();
+        for (DexClassInfo addClassInfo : addedClassInfos) {
+            logger.i(TAG, "Add class %s to small dex.", addClassInfo.classDesc);
+            classInfosInSmallDex.add(addClassInfo);
+        }
+
+        // Use normal mode to compare again, then we get all changed class infos.
+        dexClassesCmp.setCompareMode(DexClassesComparator.COMPARE_MODE_NORMAL);
+        dexClassesCmp.startCheck(oldDexGroup, newDexGroup);
+
+        Collection<DexClassInfo[]> changedOldNewClassInfos =
+                dexClassesCmp.getChangedClassDescToInfosMap().values();
+
+        // Add changed classes to small patched dex.
+        // changedOldNewClassInfo[1] means changedNewClassInfo
+        for (DexClassInfo[] changedOldNewClassInfo : changedOldNewClassInfos) {
+            logger.i(TAG, "Add class %s to small dex.", changedOldNewClassInfo[1].classDesc);
+            classInfosInSmallDex.add(changedOldNewClassInfo[1]);
+        }
+
+        Set<DexClassInfo> classInfosInNewDexGroup
+                = newDexGroup.getClassInfosInDexesWithDuplicateCheck();
+
+        Set<String> changedClassDescs = dexClassesCmp.getChangedClassDescToInfosMap().keySet();
+
+        // Add subclasses of referrer-affected changed classes to small patched dex.
+        // By the way, collect all subclasses to form referrer-affected changed classes chain.
+        for (DexClassInfo patchedClassInfo : classInfosInNewDexGroup) {
+            final String superClassDesc
+                    = patchedClassInfo.classDef.supertypeIndex == ClassDef.NO_INDEX
+                    ? ""
+                    : patchedClassInfo.owner.typeNames().get(patchedClassInfo.classDef.supertypeIndex);
+
+            if (referrerAffectedChangedClassesChainSet.contains(superClassDesc)) {
+                referrerAffectedChangedClassesChainSet.add(patchedClassInfo.classDesc);
+                logger.i(TAG, "Class %s is subclass of referrer-affected changed class %s.",
+                        patchedClassInfo.classDesc, superClassDesc);
+
+                logger.i(TAG, "Add class %s to small dex.", patchedClassInfo.classDesc);
+
+                classInfosInSmallDex.add(patchedClassInfo);
+            }
+        }
+
+        Set<String> classesToCheckReference = new HashSet<>();
+        classesToCheckReference.addAll(changedClassDescs);
+        classesToCheckReference.addAll(referrerAffectedChangedClassesChainSet);
+
+        Set<String> addedClassDescs = new HashSet<>();
+        for (DexClassInfo addedClassInfo : addedClassInfos) {
+            addedClassDescs.add(addedClassInfo.classDesc);
+        }
+
+        // Add classes which refer to changed classes and referrer-affected
+        // changed classes chain to small patched dex.
+        for (DexClassInfo patchedClassInfo : classInfosInNewDexGroup) {
+            if (!addedClassDescs.contains(patchedClassInfo.classDesc)
+             && !changedClassDescs.contains(patchedClassInfo.classDesc)) {
+                processMethodReference(
+                        patchedClassInfo,
+                        classesToCheckReference,
+                        classInfosInSmallDex
+                );
+            }
+        }
+
+        return classInfosInSmallDex;
+    }
+
+    private void processMethodReference(
+            DexClassInfo patchedClassInfo,
+            Set<String> classDescsToCheck,
+            Set<DexClassInfo> result
+    ) {
+        final ClassDef classDef = patchedClassInfo.classDef;
+        if (classDef.classDataOffset == ClassDef.NO_OFFSET) {
+            return;
+        }
+
+        ClassData patchedClassData
+                = patchedClassInfo.owner.readClassData(classDef);
+
+        boolean shouldAdd = isClassMethodReferenceToClasses(
+                patchedClassInfo.owner,
+                patchedClassData.directMethods,
+                classDescsToCheck
+        );
+
+        if (!shouldAdd) {
+            shouldAdd = isClassMethodReferenceToClasses(
+                    patchedClassInfo.owner,
+                    patchedClassData.virtualMethods,
+                    classDescsToCheck
+            );
+        }
+
+        if (shouldAdd) {
+            logger.i(TAG, "Add class %s to small dex.", patchedClassInfo.classDesc);
+            result.add(patchedClassInfo);
+        }
+    }
+
+    private boolean isClassMethodReferenceToClasses(
+            Dex owner,
+            ClassData.Method[] methods,
+            Collection<String> referredClassDescs
+    ) {
+        if (referredClassDescs.isEmpty() || methods == null || methods.length == 0) {
+            return false;
+        }
+
+        for (ClassData.Method method : methods) {
+            if (method.codeOffset == 0) {
+                continue;
+            }
+            Code code = owner.readCode(method);
+            ClassReferringInsnVisitor refInsnVisitor =
+                    new ClassReferringInsnVisitor(owner, method, referredClassDescs, logger);
+            InstructionReader insnReader =
+                    new InstructionReader(new ShortArrayCodeInput(code.instructions));
+            try {
+                insnReader.accept(refInsnVisitor);
+                if (refInsnVisitor.isMethodReferencedToAnyProvidedClasses) {
+                    return true;
+                }
+            } catch (EOFException e) {
+                throw new IllegalStateException(e);
+            }
+        }
+
+        return false;
+    }
+}
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/SmallDexPatchGenerator.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/SmallDexPatchGenerator.java
index dd805303..d56b2a1e 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/SmallDexPatchGenerator.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/SmallDexPatchGenerator.java
@@ -44,7 +44,6 @@
 import com.tencent.tinker.android.dx.instruction.ShortArrayCodeInput;
 import com.tencent.tinker.android.dx.util.Hex;
 import com.tencent.tinker.android.dx.util.IndexMap;
-import com.tencent.tinker.build.util.DexClassesComparator;
 import com.tencent.tinker.build.util.DexClassesComparator.DexClassInfo;
 import com.tencent.tinker.build.util.DexClassesComparator.DexGroup;
 import com.tencent.tinker.commons.dexpatcher.DexPatcherLogger;
@@ -737,104 +736,17 @@ private void writeDataChunk(
         }
     }
 
-    private boolean isClassMethodReferenceToRefAffectedClass(
-            Dex owner,
-            ClassData.Method[] methods,
-            Collection<String> affectedClassDescs
-    ) {
-        if (affectedClassDescs.isEmpty() || methods == null || methods.length == 0) {
-            return false;
-        }
-
-        for (ClassData.Method method : methods) {
-            if (method.codeOffset == 0) {
-                continue;
-            }
-            Code code = owner.readCode(method);
-            RefToRefAffectedClassInsnVisitor refInsnVisitor =
-                    new RefToRefAffectedClassInsnVisitor(owner, method, affectedClassDescs);
-            InstructionReader insnReader =
-                    new InstructionReader(new ShortArrayCodeInput(code.instructions));
-            try {
-                insnReader.accept(refInsnVisitor);
-                if (refInsnVisitor.isMethodReferencedToRefAffectedClass) {
-                    return true;
-                }
-            } catch (EOFException e) {
-                throw new IllegalStateException(e);
-            }
-        }
-
-        return false;
-    }
-
     private void collectItemIndicesFromDexGroup(
             DexGroup oldDexGroup,
             DexGroup patchedDexGroup
     ) {
-        DexClassesComparator dexClassesCmp = new DexClassesComparator("*");
-        dexClassesCmp.setCompareMode(DexClassesComparator.COMPARE_MODE_CAUSE_REF_CHANGE_ONLY);
-        dexClassesCmp.setIgnoredRemovedClassDescPattern(this.loaderClassPatterns);
-        dexClassesCmp.startCheck(oldDexGroup, patchedDexGroup);
-
-        Set<String> refAffectedClassDescs
-                = dexClassesCmp.getChangedClassDescToInfosMap().keySet();
-
-        Set<DexClassInfo> classInfosInPatchedDexGroup
-                = patchedDexGroup.getClassInfosInDexesWithDuplicateCheck();
-
-        Set<DexClassInfo> patchedClassInfosForItemIndexCollecting = new HashSet<>();
-
-        for (DexClassInfo patchedClassInfo : classInfosInPatchedDexGroup) {
-            if (patchedClassInfo.classDef.classDataOffset == 0) {
-                continue;
-            }
-            ClassData patchedClassData
-                    = patchedClassInfo.owner.readClassData(patchedClassInfo.classDef);
-
-            boolean shouldAdd = isClassMethodReferenceToRefAffectedClass(
-                    patchedClassInfo.owner,
-                    patchedClassData.directMethods,
-                    refAffectedClassDescs
-            );
-
-            if (!shouldAdd) {
-                shouldAdd = isClassMethodReferenceToRefAffectedClass(
-                        patchedClassInfo.owner,
-                        patchedClassData.virtualMethods,
-                        refAffectedClassDescs
-                );
-            }
-
-            if (shouldAdd) {
-                logger.i(TAG, "Add class %s to small patched dex.", patchedClassInfo.classDesc);
-                patchedClassInfosForItemIndexCollecting.add(patchedClassInfo);
-            }
-        }
-
-        // So far we get descriptors of classes we need to add additionally,
-        // while we still need to do a fully compare to collect added classes
-        // and replaced classes since they may use items in their owner dex which
-        // is not modified.
-        dexClassesCmp.setCompareMode(DexClassesComparator.COMPARE_MODE_NORMAL);
-        dexClassesCmp.startCheck(oldDexGroup, patchedDexGroup);
-
-        Collection<DexClassInfo> addedClassInfos = dexClassesCmp.getAddedClassInfos();
-        for (DexClassInfo addClassInfo : addedClassInfos) {
-            logger.i(TAG, "Add class %s to small patched dex.", addClassInfo.classDesc);
-            patchedClassInfosForItemIndexCollecting.add(addClassInfo);
-        }
-
-        Collection<DexClassInfo[]> changedOldPatchedClassInfos =
-                dexClassesCmp.getChangedClassDescToInfosMap().values();
+        SmallDexClassInfoCollector smallDexClassInfoCollector = new SmallDexClassInfoCollector();
+        smallDexClassInfoCollector.setLoaderClassPatterns(this.loaderClassPatterns);
+        smallDexClassInfoCollector.setLogger(this.logger.getLoggerImpl());
+        Set<DexClassInfo> patchedClassInfosForItemIndexCollecting =
+                smallDexClassInfoCollector.doCollect(oldDexGroup, patchedDexGroup);
 
-        // changedOldPatchedClassInfo[1] means changedPatchedClassInfo
-        for (DexClassInfo[] changedOldPatchedClassInfo : changedOldPatchedClassInfos) {
-            logger.i(TAG, "Add class %s to small patched dex.", changedOldPatchedClassInfo[1].classDesc);
-            patchedClassInfosForItemIndexCollecting.add(changedOldPatchedClassInfo[1]);
-        }
-
-        // Finally we collect all elements' indices of collected class.
+        // Collect all elements' indices of collected class.
 
         Map<Dex, OffsetToIndexConverter> dexToOffsetToIndexConverterMap = new HashMap<>();
 
@@ -1787,105 +1699,6 @@ public int simulate(int smallPatchBaseOffset) {
         }
     }
 
-    private class RefToRefAffectedClassInsnVisitor extends InstructionVisitor {
-        private final Dex methodOwner;
-        private final ClassData.Method method;
-        private final Collection<String> refAffectedClassDefs;
-        private boolean isMethodReferencedToRefAffectedClass;
-
-        RefToRefAffectedClassInsnVisitor(Dex methodOwner, ClassData.Method method, Collection<String> refAffectedClassDefs) {
-            super(null);
-            this.methodOwner = methodOwner;
-            this.method = method;
-            this.refAffectedClassDefs = refAffectedClassDefs;
-            this.isMethodReferencedToRefAffectedClass = false;
-        }
-
-        @Override
-        public void visitZeroRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal) {
-            processIndexByType(index, indexType);
-        }
-
-        @Override
-        public void visitOneRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a) {
-            processIndexByType(index, indexType);
-        }
-
-        @Override
-        public void visitTwoRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int b) {
-            processIndexByType(index, indexType);
-        }
-
-        @Override
-        public void visitThreeRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int b, int c) {
-            processIndexByType(index, indexType);
-        }
-
-        @Override
-        public void visitFourRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int b, int c, int d) {
-            processIndexByType(index, indexType);
-        }
-
-        @Override
-        public void visitFiveRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int b, int c, int d, int e) {
-            processIndexByType(index, indexType);
-        }
-
-        @Override
-        public void visitRegisterRangeInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int registerCount) {
-            processIndexByType(index, indexType);
-        }
-
-        private void processIndexByType(int index, int indexType) {
-            String typeName = null;
-            String refInfoInLog = null;
-            switch (indexType) {
-                case InstructionCodec.INDEX_TYPE_TYPE_REF: {
-                    typeName = methodOwner.typeNames().get(index);
-                    refInfoInLog = "init ref-changed class";
-                    break;
-                }
-                case InstructionCodec.INDEX_TYPE_FIELD_REF: {
-                    final FieldId fieldId = methodOwner.fieldIds().get(index);
-                    typeName = methodOwner.typeNames().get(fieldId.declaringClassIndex);
-                    refInfoInLog = "referencing to field: " + methodOwner.strings().get(fieldId.nameIndex);
-                    break;
-                }
-                case InstructionCodec.INDEX_TYPE_METHOD_REF: {
-                    final MethodId methodId = methodOwner.methodIds().get(index);
-                    typeName = methodOwner.typeNames().get(methodId.declaringClassIndex);
-                    refInfoInLog = "invoking method: " + getMethodProtoTypeStr(methodId);
-                    break;
-                }
-            }
-            if (typeName != null && refAffectedClassDefs.contains(typeName)) {
-                MethodId methodId = methodOwner.methodIds().get(method.methodIndex);
-                logger.i(
-                        TAG,
-                        "Method %s in class %s referenced ref-changed class %s by %s",
-                        getMethodProtoTypeStr(methodId),
-                        methodOwner.typeNames().get(methodId.declaringClassIndex),
-                        typeName,
-                        refInfoInLog
-                );
-                isMethodReferencedToRefAffectedClass = true;
-            }
-        }
-
-        private String getMethodProtoTypeStr(MethodId methodId) {
-            StringBuilder strBuilder = new StringBuilder();
-            strBuilder.append(methodOwner.strings().get(methodId.nameIndex));
-            ProtoId protoId = methodOwner.protoIds().get(methodId.protoIndex);
-            strBuilder.append('(');
-            short[] paramTypeIds = methodOwner.parameterTypeIndicesFromMethodId(methodId);
-            for (short typeId : paramTypeIds) {
-                strBuilder.append(methodOwner.typeNames().get(typeId));
-            }
-            strBuilder.append(')').append(methodOwner.typeNames().get(protoId.returnTypeIndex));
-            return strBuilder.toString();
-        }
-    }
-
     private class IndicesCollectorInsnVisitor extends InstructionVisitor {
         private final Dex ownerDex;
         private final OffsetToIndexConverter offsetToIndexConverter;
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/info/PatchInfoGen.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/info/PatchInfoGen.java
index a097f658..39ad80ef 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/info/PatchInfoGen.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/info/PatchInfoGen.java
@@ -16,7 +16,7 @@
 
 package com.tencent.tinker.build.info;
 
-import com.tencent.tinker.build.apkparser.AndroidManifest;
+import com.tencent.tinker.build.apkparser.AndroidParser;
 import com.tencent.tinker.build.patch.Configuration;
 import com.tencent.tinker.build.util.TinkerPatchException;
 import com.tencent.tinker.build.util.TypedValue;
@@ -41,7 +41,7 @@ public PatchInfoGen(Configuration config) {
 
     private void addTinkerID() throws IOException, ParseException {
         if (!config.mPackageFields.containsKey(TypedValue.TINKER_ID)) {
-            AndroidManifest oldAndroidManifest = AndroidManifest.getAndroidManifest(config.mOldApkFile);
+            AndroidParser oldAndroidManifest = AndroidParser.getAndroidManifest(config.mOldApkFile);
             String tinkerID = oldAndroidManifest.metaDatas.get(TypedValue.TINKER_ID);
 
             if (tinkerID == null) {
@@ -51,7 +51,7 @@ private void addTinkerID() throws IOException, ParseException {
         }
 
         if (!config.mPackageFields.containsKey(TypedValue.NEW_TINKER_ID)) {
-            AndroidManifest newAndroidManifest = AndroidManifest.getAndroidManifest(config.mNewApkFile);
+            AndroidParser newAndroidManifest = AndroidParser.getAndroidManifest(config.mNewApkFile);
             String tinkerID = newAndroidManifest.metaDatas.get(TypedValue.TINKER_ID);
 
             if (tinkerID == null) {
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/Configuration.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/Configuration.java
index 9b359eb5..e1823c93 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/Configuration.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/Configuration.java
@@ -83,6 +83,7 @@
     public File             mOldApkFile;
     public File             mNewApkFile;
     public boolean          mIgnoreWarning;
+    public boolean          mUsePreGeneratedPatchDex;
     /**
      * lib config
      */
@@ -213,6 +214,8 @@ public Configuration(InputParam param) throws IOException, TinkerPatchException
         mOutFolder = param.outFolder;
 
         mIgnoreWarning = param.ignoreWarning;
+        mUsePreGeneratedPatchDex = param.usePreGeneratedPatchDex;
+
         mSevenZipPath = param.sevenZipPath;
         mPackageFields = param.configFields;
 
@@ -234,6 +237,7 @@ public String toString() {
         sb.append("newApk:" + mNewApkPath + "\n");
         sb.append("outputFolder:" + mOutFolder + "\n");
         sb.append("isIgnoreWarning:" + mIgnoreWarning + "\n");
+        sb.append("isInsertStubMode:" + mUsePreGeneratedPatchDex + "\n");
         sb.append("7-ZipPath:" + mSevenZipPath + "\n");
         sb.append("useSignAPk:" + mUseSignAPk + "\n");
 
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/InputParam.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/InputParam.java
index 6a217f47..348f431a 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/InputParam.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/InputParam.java
@@ -35,6 +35,7 @@
     public final String  storealias;
     public final String  storepass;
     public final boolean ignoreWarning;
+    public final boolean usePreGeneratedPatchDex;
     public final boolean useSign;
 
     /**
@@ -81,6 +82,7 @@ private InputParam(
         String storealias,
         String storepass,
         boolean ignoreWarning,
+        boolean usePreGeneratedPatchDex,
         boolean useSign,
 
         ArrayList<String> dexFilePattern,
@@ -103,6 +105,7 @@ private InputParam(
         this.storealias = storealias;
         this.storepass = storepass;
         this.ignoreWarning = ignoreWarning;
+        this.usePreGeneratedPatchDex = usePreGeneratedPatchDex;
         this.useSign = useSign;
 
         this.dexFilePattern = dexFilePattern;
@@ -132,6 +135,7 @@ private InputParam(
         private String  storealias;
         private String  storepass;
         private boolean ignoreWarning;
+        private boolean usePreGeneratedPatchDex;
         private boolean useSign;
 
         /**
@@ -243,6 +247,11 @@ public Builder setIgnoreWarning(boolean ignoreWarning) {
             return this;
         }
 
+        public Builder setUsePreGeneratedPatchDex(boolean usePreGeneratedPatchDex) {
+            this.usePreGeneratedPatchDex = usePreGeneratedPatchDex;
+            return this;
+        }
+
         public Builder setDexLoaderPattern(ArrayList<String> dexLoaderPattern) {
             this.dexLoaderPattern = dexLoaderPattern;
             return this;
@@ -270,25 +279,26 @@ public Builder setUseSign(boolean useSign) {
 
         public InputParam create() {
             return new InputParam(
-                oldApk,
-                newApk,
-                outFolder,
-                signFile,
-                keypass,
-                storealias,
-                storepass,
-                ignoreWarning,
-                useSign,
-                dexFilePattern,
-                dexLoaderPattern,
-                dexMode,
-                soFilePattern,
-                resourceFilePattern,
-                resourceIgnoreChangePattern,
-                largeModSize,
-                useApplyResource,
-                configFields,
-                sevenZipPath
+                    oldApk,
+                    newApk,
+                    outFolder,
+                    signFile,
+                    keypass,
+                    storealias,
+                    storepass,
+                    ignoreWarning,
+                    usePreGeneratedPatchDex,
+                    useSign,
+                    dexFilePattern,
+                    dexLoaderPattern,
+                    dexMode,
+                    soFilePattern,
+                    resourceFilePattern,
+                    resourceIgnoreChangePattern,
+                    largeModSize,
+                    useApplyResource,
+                    configFields,
+                    sevenZipPath
             );
         }
     }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/DexClassesComparator.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/DexClassesComparator.java
index fe55d9a9..d0c99383 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/DexClassesComparator.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/DexClassesComparator.java
@@ -972,12 +972,12 @@ private boolean isSameEncodedValue(
             case EncodedValueReader.ENCODED_FLOAT: {
                 float oldFloat = oldAnnoReader.readFloat();
                 float newFloat = newAnnoReader.readFloat();
-                return oldFloat == newFloat;
+                return Float.compare(oldFloat, newFloat) == 0;
             }
             case EncodedValueReader.ENCODED_DOUBLE: {
                 double oldDouble = oldAnnoReader.readDouble();
                 double newDouble = newAnnoReader.readDouble();
-                return oldDouble == newDouble;
+                return Double.compare(oldDouble, newDouble) == 0;
             }
             case EncodedValueReader.ENCODED_STRING: {
                 int oldStringIdx = oldAnnoReader.readString();
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/Logger.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/Logger.java
index 965b87c8..777c3245 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/Logger.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/Logger.java
@@ -34,7 +34,9 @@ public static void initLogger(Configuration config) throws IOException {
     }
 
     public static void closeLogger() {
-        logWriter.close();
+        if (logWriter != null) {
+            logWriter.close();
+        }
     }
 
     public static void d(final String msg) {
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/TypedValue.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/TypedValue.java
index 4837f67a..13120a8d 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/TypedValue.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/TypedValue.java
@@ -70,4 +70,8 @@
     public static final String LARGE_MOD_TITLE = "large modify:";
     public static final String DEL_TITLE       = "delete:";
     public static final String PATTERN_TITLE   = "pattern:";
+
+    public static final String TEST_STRING_VALUE_A = "only use for test tinker resource: a";
+    public static final String TEST_STRING_VALUE_B = "only use for test tinker resource: b";
+
 }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/org/jf/dexlib2/builder/BuilderMutableMethodImplementation.java b/tinker-build/tinker-patch-lib/src/main/java/org/jf/dexlib2/builder/BuilderMutableMethodImplementation.java
new file mode 100644
index 00000000..620e5e43
--- /dev/null
+++ b/tinker-build/tinker-patch-lib/src/main/java/org/jf/dexlib2/builder/BuilderMutableMethodImplementation.java
@@ -0,0 +1,1142 @@
+/*
+ * Copyright 2013, Google Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ * copyright notice, this list of conditions and the following disclaimer
+ * in the documentation and/or other materials provided with the
+ * distribution.
+ *     * Neither the name of Google Inc. nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ * *** This file is NOT a part of DexLib2 project. ***
+ *
+ * Tricky ways for converting MethodImplementation in DexFile into the corresponding
+ * one in DexBuilder.
+ *
+ * If you pass null as DexBuilder, this class behavior the same as
+ * what {@link org.jf.dexlib2.builder.MutableMethodImplementation} would do.
+ */
+
+package org.jf.dexlib2.builder;
+
+import com.google.common.base.Function;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Sets;
+
+import org.jf.dexlib2.DebugItemType;
+import org.jf.dexlib2.Opcode;
+import org.jf.dexlib2.builder.debug.BuilderEndLocal;
+import org.jf.dexlib2.builder.debug.BuilderEpilogueBegin;
+import org.jf.dexlib2.builder.debug.BuilderLineNumber;
+import org.jf.dexlib2.builder.debug.BuilderPrologueEnd;
+import org.jf.dexlib2.builder.debug.BuilderRestartLocal;
+import org.jf.dexlib2.builder.debug.BuilderSetSourceFile;
+import org.jf.dexlib2.builder.debug.BuilderStartLocal;
+import org.jf.dexlib2.builder.instruction.BuilderArrayPayload;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction10t;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction10x;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction11n;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction11x;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction12x;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction20bc;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction20t;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction21c;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction21ih;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction21lh;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction21s;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction21t;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction22b;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction22c;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction22s;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction22t;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction22x;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction23x;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction25x;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction30t;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction31c;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction31i;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction31t;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction32x;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction35c;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction3rc;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction51l;
+import org.jf.dexlib2.builder.instruction.BuilderPackedSwitchPayload;
+import org.jf.dexlib2.builder.instruction.BuilderSparseSwitchPayload;
+import org.jf.dexlib2.iface.ExceptionHandler;
+import org.jf.dexlib2.iface.MethodImplementation;
+import org.jf.dexlib2.iface.TryBlock;
+import org.jf.dexlib2.iface.debug.DebugItem;
+import org.jf.dexlib2.iface.debug.EndLocal;
+import org.jf.dexlib2.iface.debug.LineNumber;
+import org.jf.dexlib2.iface.debug.RestartLocal;
+import org.jf.dexlib2.iface.debug.SetSourceFile;
+import org.jf.dexlib2.iface.debug.StartLocal;
+import org.jf.dexlib2.iface.instruction.Instruction;
+import org.jf.dexlib2.iface.instruction.SwitchElement;
+import org.jf.dexlib2.iface.instruction.formats.ArrayPayload;
+import org.jf.dexlib2.iface.instruction.formats.Instruction10t;
+import org.jf.dexlib2.iface.instruction.formats.Instruction10x;
+import org.jf.dexlib2.iface.instruction.formats.Instruction11n;
+import org.jf.dexlib2.iface.instruction.formats.Instruction11x;
+import org.jf.dexlib2.iface.instruction.formats.Instruction12x;
+import org.jf.dexlib2.iface.instruction.formats.Instruction20bc;
+import org.jf.dexlib2.iface.instruction.formats.Instruction20t;
+import org.jf.dexlib2.iface.instruction.formats.Instruction21c;
+import org.jf.dexlib2.iface.instruction.formats.Instruction21ih;
+import org.jf.dexlib2.iface.instruction.formats.Instruction21lh;
+import org.jf.dexlib2.iface.instruction.formats.Instruction21s;
+import org.jf.dexlib2.iface.instruction.formats.Instruction21t;
+import org.jf.dexlib2.iface.instruction.formats.Instruction22b;
+import org.jf.dexlib2.iface.instruction.formats.Instruction22c;
+import org.jf.dexlib2.iface.instruction.formats.Instruction22s;
+import org.jf.dexlib2.iface.instruction.formats.Instruction22t;
+import org.jf.dexlib2.iface.instruction.formats.Instruction22x;
+import org.jf.dexlib2.iface.instruction.formats.Instruction23x;
+import org.jf.dexlib2.iface.instruction.formats.Instruction25x;
+import org.jf.dexlib2.iface.instruction.formats.Instruction30t;
+import org.jf.dexlib2.iface.instruction.formats.Instruction31c;
+import org.jf.dexlib2.iface.instruction.formats.Instruction31i;
+import org.jf.dexlib2.iface.instruction.formats.Instruction31t;
+import org.jf.dexlib2.iface.instruction.formats.Instruction32x;
+import org.jf.dexlib2.iface.instruction.formats.Instruction35c;
+import org.jf.dexlib2.iface.instruction.formats.Instruction3rc;
+import org.jf.dexlib2.iface.instruction.formats.Instruction51l;
+import org.jf.dexlib2.iface.instruction.formats.PackedSwitchPayload;
+import org.jf.dexlib2.iface.instruction.formats.SparseSwitchPayload;
+import org.jf.dexlib2.iface.reference.Reference;
+import org.jf.dexlib2.iface.reference.StringReference;
+import org.jf.dexlib2.iface.reference.TypeReference;
+import org.jf.dexlib2.writer.builder.DexBuilder;
+import org.jf.util.ExceptionWithContext;
+
+import java.util.AbstractList;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
+
+/**
+ * Created by tangyinsheng on 2016/10/9.
+ */
+public class BuilderMutableMethodImplementation implements MethodImplementation {
+    private final DexBuilder dexBuilder;
+    private final int registerCount;
+    private final ArrayList<MethodLocation> instructionList = Lists.newArrayList(new MethodLocation(null, 0, 0));
+    private final ArrayList<BuilderTryBlock> tryBlocks = Lists.newArrayList();
+    private boolean fixInstructions = true;
+
+    public BuilderMutableMethodImplementation(DexBuilder dexBuilder, @Nonnull MethodImplementation methodImplementation) {
+        this.dexBuilder = dexBuilder;
+
+        this.registerCount = methodImplementation.getRegisterCount();
+
+        int codeAddress = 0;
+        int index = 0;
+
+        for (Instruction instruction : methodImplementation.getInstructions()) {
+            codeAddress += instruction.getCodeUnits();
+            index++;
+
+            instructionList.add(new MethodLocation(null, codeAddress, index));
+        }
+
+        final int[] codeAddressToIndex = new int[codeAddress + 1];
+        Arrays.fill(codeAddressToIndex, -1);
+
+        for (int i = 0; i < instructionList.size(); i++) {
+            codeAddressToIndex[instructionList.get(i).codeAddress] = i;
+        }
+
+        List<Task> switchPayloadTasks = Lists.newArrayList();
+        index = 0;
+        for (final Instruction instruction : methodImplementation.getInstructions()) {
+            final MethodLocation location = instructionList.get(index);
+            final Opcode opcode = instruction.getOpcode();
+            if (opcode == Opcode.PACKED_SWITCH_PAYLOAD || opcode == Opcode.SPARSE_SWITCH_PAYLOAD) {
+                switchPayloadTasks.add(new Task() {
+                    @Override
+                    public void perform() {
+                        convertAndSetInstruction(location, codeAddressToIndex, instruction);
+                    }
+                });
+            } else {
+                convertAndSetInstruction(location, codeAddressToIndex, instruction);
+            }
+            index++;
+        }
+
+        // the switch payload instructions must be converted last, so that any switch statements that refer to them
+        // have created the referring labels that we look for
+        for (Task switchPayloadTask : switchPayloadTasks) {
+            switchPayloadTask.perform();
+        }
+
+        for (DebugItem debugItem : methodImplementation.getDebugItems()) {
+            int debugCodeAddress = debugItem.getCodeAddress();
+            int locationIndex = mapCodeAddressToIndex(codeAddressToIndex, debugCodeAddress);
+            MethodLocation debugLocation = instructionList.get(locationIndex);
+            BuilderDebugItem builderDebugItem = convertDebugItem(debugItem);
+            debugLocation.getDebugItems().add(builderDebugItem);
+            builderDebugItem.location = debugLocation;
+        }
+
+        for (TryBlock<? extends ExceptionHandler> tryBlock : methodImplementation.getTryBlocks()) {
+            Label startLabel = newLabel(codeAddressToIndex, tryBlock.getStartCodeAddress());
+            Label endLabel = newLabel(codeAddressToIndex, tryBlock.getStartCodeAddress() + tryBlock.getCodeUnitCount());
+
+            for (ExceptionHandler exceptionHandler : tryBlock.getExceptionHandlers()) {
+                tryBlocks.add(new BuilderTryBlock(startLabel, endLabel,
+                        (TypeReference) convertReference(exceptionHandler.getExceptionTypeReference()),
+                        newLabel(codeAddressToIndex, exceptionHandler.getHandlerCodeAddress())));
+            }
+        }
+    }
+
+    public BuilderMutableMethodImplementation(int registerCount) {
+        this.dexBuilder = null;
+        this.registerCount = registerCount;
+    }
+
+    @Override
+    public int getRegisterCount() {
+        return registerCount;
+    }
+
+    @Nonnull
+    public List<BuilderInstruction> getInstructions() {
+        if (fixInstructions) {
+            fixInstructions();
+        }
+
+        return new AbstractList<BuilderInstruction>() {
+            @Override
+            public BuilderInstruction get(int i) {
+                if (i >= size()) {
+                    throw new IndexOutOfBoundsException();
+                }
+                if (fixInstructions) {
+                    fixInstructions();
+                }
+                return instructionList.get(i).instruction;
+            }
+
+            @Override
+            public int size() {
+                if (fixInstructions) {
+                    fixInstructions();
+                }
+                // don't include the last MethodLocation, which always has a null instruction
+                return instructionList.size() - 1;
+            }
+        };
+    }
+
+    @Nonnull
+    @Override
+    public List<BuilderTryBlock> getTryBlocks() {
+        if (fixInstructions) {
+            fixInstructions();
+        }
+        return Collections.unmodifiableList(tryBlocks);
+    }
+
+    @Nonnull
+    @Override
+    public Iterable<? extends DebugItem> getDebugItems() {
+        if (fixInstructions) {
+            fixInstructions();
+        }
+        return Iterables.concat(
+                Iterables.transform(instructionList, new Function<MethodLocation, Iterable<? extends DebugItem>>() {
+                    @Nullable
+                    @Override
+                    public Iterable<? extends DebugItem> apply(@Nullable MethodLocation input) {
+                        assert input != null;
+                        if (fixInstructions) {
+                            throw new IllegalStateException("This iterator was invalidated by a change to"
+                                + " this MutableMethodImplementation.");
+                        }
+                        return input.getDebugItems();
+                    }
+                }));
+    }
+
+    public void addCatch(@Nullable TypeReference type, @Nonnull Label from,
+                         @Nonnull Label to, @Nonnull Label handler) {
+        tryBlocks.add(new BuilderTryBlock(from, to, type, handler));
+    }
+
+    public void addCatch(@Nullable String type, @Nonnull Label from, @Nonnull Label to,
+                         @Nonnull Label handler) {
+        tryBlocks.add(new BuilderTryBlock(from, to, type, handler));
+    }
+
+    public void addCatch(@Nonnull Label from, @Nonnull Label to, @Nonnull Label handler) {
+        tryBlocks.add(new BuilderTryBlock(from, to, handler));
+    }
+
+    public void addInstruction(int index, BuilderInstruction instruction) {
+        // the end check here is intentially >= rather than >, because the list always includes an "empty"
+        // (null instruction) MethodLocation at the end. To add an instruction to the end of the list, the user would
+        // provide the index of this empty item, which would be size() - 1.
+        if (index >= instructionList.size()) {
+            throw new IndexOutOfBoundsException();
+        }
+
+        if (index == instructionList.size() - 1) {
+            addInstruction(instruction);
+            return;
+        }
+        int codeAddress = instructionList.get(index).getCodeAddress();
+        MethodLocation newLoc = new MethodLocation(instruction, codeAddress, index);
+        instructionList.add(index, newLoc);
+        instruction.location = newLoc;
+
+        codeAddress += instruction.getCodeUnits();
+
+        for (int i = index + 1; i < instructionList.size(); i++) {
+            MethodLocation location = instructionList.get(i);
+            location.index++;
+            location.codeAddress = codeAddress;
+            if (location.instruction != null) {
+                codeAddress += location.instruction.getCodeUnits();
+            } else {
+                // only the last MethodLocation should have a null instruction
+                assert i == instructionList.size() - 1;
+            }
+        }
+
+        this.fixInstructions = true;
+    }
+
+    public void addInstruction(@Nonnull BuilderInstruction instruction) {
+        MethodLocation last = instructionList.get(instructionList.size() - 1);
+        last.instruction = instruction;
+        instruction.location = last;
+
+        int nextCodeAddress = last.codeAddress + instruction.getCodeUnits();
+        instructionList.add(new MethodLocation(null, nextCodeAddress, instructionList.size()));
+
+        this.fixInstructions = true;
+    }
+
+    public void replaceInstruction(int index, @Nonnull BuilderInstruction replacementInstruction) {
+        if (index >= instructionList.size() - 1) {
+            throw new IndexOutOfBoundsException();
+        }
+
+        MethodLocation replaceLocation = instructionList.get(index);
+        replacementInstruction.location = replaceLocation;
+        BuilderInstruction old = replaceLocation.instruction;
+        assert old != null;
+        old.location = null;
+        replaceLocation.instruction = replacementInstruction;
+
+        // TODO: factor out index/address fix up loop
+        int codeAddress = replaceLocation.codeAddress + replaceLocation.instruction.getCodeUnits();
+        for (int i = index + 1; i < instructionList.size(); i++) {
+            MethodLocation location = instructionList.get(i);
+            location.codeAddress = codeAddress;
+
+            Instruction instruction = location.getInstruction();
+            if (instruction != null) {
+                codeAddress += instruction.getCodeUnits();
+            } else {
+                assert i == instructionList.size() - 1;
+            }
+        }
+
+        this.fixInstructions = true;
+    }
+
+    public void removeInstruction(int index) {
+        if (index >= instructionList.size() - 1) {
+            throw new IndexOutOfBoundsException();
+        }
+
+        MethodLocation toRemove = instructionList.get(index);
+        toRemove.instruction = null;
+        MethodLocation next = instructionList.get(index + 1);
+        toRemove.mergeInto(next);
+
+        instructionList.remove(index);
+        int codeAddress = toRemove.codeAddress;
+        for (int i = index; i < instructionList.size(); i++) {
+            MethodLocation location = instructionList.get(i);
+            location.index = i;
+            location.codeAddress = codeAddress;
+
+            Instruction instruction = location.getInstruction();
+            if (instruction != null) {
+                codeAddress += instruction.getCodeUnits();
+            } else {
+                assert i == instructionList.size() - 1;
+            }
+        }
+
+        this.fixInstructions = true;
+    }
+
+    public void swapInstructions(int index1, int index2) {
+        if (index1 >= instructionList.size() - 1 || index2 >= instructionList.size() - 1) {
+            throw new IndexOutOfBoundsException();
+        }
+        MethodLocation first = instructionList.get(index1);
+        MethodLocation second = instructionList.get(index2);
+
+        // only the last MethodLocation may have a null instruction
+        assert first.instruction != null;
+        assert second.instruction != null;
+
+        first.instruction.location = second;
+        second.instruction.location = first;
+
+        {
+            BuilderInstruction tmp = second.instruction;
+            second.instruction = first.instruction;
+            first.instruction = tmp;
+        }
+
+        if (index2 < index1) {
+            int tmp = index2;
+            index2 = index1;
+            index1 = tmp;
+        }
+
+        int codeAddress = first.codeAddress + first.instruction.getCodeUnits();
+        for (int i = index1 + 1; i <= index2; i++) {
+            MethodLocation location = instructionList.get(i);
+            location.codeAddress = codeAddress;
+
+            Instruction instruction = location.instruction;
+            assert instruction != null;
+            codeAddress += location.instruction.getCodeUnits();
+        }
+
+        this.fixInstructions = true;
+    }
+
+    @Nullable
+    private BuilderInstruction getFirstNonNop(int startIndex) {
+
+        for (int i = startIndex; i < instructionList.size() - 1; i++) {
+            BuilderInstruction instruction = instructionList.get(i).instruction;
+            assert instruction != null;
+            if (instruction.getOpcode() != Opcode.NOP) {
+                return instruction;
+            }
+        }
+        return null;
+    }
+
+    private void fixInstructions() {
+        HashSet<MethodLocation> payloadLocations = Sets.newHashSet();
+
+        for (MethodLocation location : instructionList) {
+            BuilderInstruction instruction = location.instruction;
+            if (instruction != null) {
+                switch (instruction.getOpcode()) {
+                    case SPARSE_SWITCH:
+                    case PACKED_SWITCH: {
+                        MethodLocation targetLocation =
+                                ((BuilderOffsetInstruction) instruction).getTarget().getLocation();
+                        BuilderInstruction targetInstruction = targetLocation.instruction;
+                        if (targetInstruction == null) {
+                            throw new IllegalStateException(String.format("Switch instruction at address/index "
+                                + "0x%x/%d points to the end of the method.", location.codeAddress, location.index));
+                        }
+
+                        if (targetInstruction.getOpcode() == Opcode.NOP) {
+                            targetInstruction = getFirstNonNop(targetLocation.index + 1);
+                        }
+                        if (targetInstruction == null || !(targetInstruction instanceof BuilderSwitchPayload)) {
+                            throw new IllegalStateException(String.format("Switch instruction at address/index "
+                                + "0x%x/%d does not refer to a payload instruction.",
+                                    location.codeAddress, location.index));
+                        }
+                        if ((instruction.opcode == Opcode.PACKED_SWITCH
+                            && targetInstruction.getOpcode() != Opcode.PACKED_SWITCH_PAYLOAD)
+                            || (instruction.opcode == Opcode.SPARSE_SWITCH
+                            && targetInstruction.getOpcode() != Opcode.SPARSE_SWITCH_PAYLOAD)) {
+                            throw new IllegalStateException(String.format("Switch instruction at address/index "
+                                + "0x%x/%d refers to the wrong type of payload instruction.",
+                                    location.codeAddress, location.index));
+                        }
+
+                        if (!payloadLocations.add(targetLocation)) {
+                            throw new IllegalStateException("Multiple switch instructions refer to the same payload. "
+                                + "This is not currently supported. Please file a bug :)");
+                        }
+
+                        ((BuilderSwitchPayload) targetInstruction).referrer = location;
+                        break;
+                    }
+                }
+            }
+        }
+
+        boolean madeChanges;
+        do {
+            madeChanges = false;
+
+            for (int index = 0; index < instructionList.size(); index++) {
+                MethodLocation location = instructionList.get(index);
+                BuilderInstruction instruction = location.instruction;
+                if (instruction != null) {
+                    switch (instruction.getOpcode()) {
+                        case GOTO: {
+                            int offset = ((BuilderOffsetInstruction) instruction).internalGetCodeOffset();
+                            if (offset < Byte.MIN_VALUE || offset > Byte.MAX_VALUE) {
+                                BuilderOffsetInstruction replacement;
+                                if (offset < Short.MIN_VALUE || offset > Short.MAX_VALUE) {
+                                    replacement = new BuilderInstruction30t(Opcode.GOTO_32,
+                                            ((BuilderOffsetInstruction) instruction).getTarget());
+                                } else {
+                                    replacement = new BuilderInstruction20t(Opcode.GOTO_16,
+                                            ((BuilderOffsetInstruction) instruction).getTarget());
+                                }
+                                replaceInstruction(location.index, replacement);
+                                madeChanges = true;
+                            }
+                            break;
+                        }
+                        case GOTO_16: {
+                            int offset = ((BuilderOffsetInstruction) instruction).internalGetCodeOffset();
+                            if (offset < Short.MIN_VALUE || offset > Short.MAX_VALUE) {
+                                BuilderOffsetInstruction replacement = new BuilderInstruction30t(Opcode.GOTO_32,
+                                        ((BuilderOffsetInstruction) instruction).getTarget());
+                                replaceInstruction(location.index, replacement);
+                                madeChanges = true;
+                            }
+                            break;
+                        }
+                        case SPARSE_SWITCH_PAYLOAD:
+                        case PACKED_SWITCH_PAYLOAD:
+                            if (((BuilderSwitchPayload) instruction).referrer == null) {
+                                // if the switch payload isn't referenced, just remove it
+                                removeInstruction(index);
+                                index--;
+                                madeChanges = true;
+                                break;
+                            }
+                            // intentional fall-through
+                        case ARRAY_PAYLOAD: {
+                            if ((location.codeAddress & 0x01) != 0) {
+                                int previousIndex = location.index - 1;
+                                MethodLocation previousLocation = instructionList.get(previousIndex);
+                                Instruction previousInstruction = previousLocation.instruction;
+                                assert previousInstruction != null;
+                                if (previousInstruction.getOpcode() == Opcode.NOP) {
+                                    removeInstruction(previousIndex);
+                                    index--;
+                                } else {
+                                    addInstruction(location.index, new BuilderInstruction10x(Opcode.NOP));
+                                    index++;
+                                }
+                                madeChanges = true;
+                            }
+                            break;
+                        }
+                    }
+                }
+            }
+        } while (madeChanges);
+
+        fixInstructions = false;
+    }
+
+    private int mapCodeAddressToIndex(@Nonnull int[] codeAddressToIndex, int codeAddress) {
+        int index;
+        do {
+            index = codeAddressToIndex[codeAddress];
+            if (index < 0) {
+                codeAddress--;
+            } else {
+                return index;
+            }
+        } while (true);
+    }
+
+    private int mapCodeAddressToIndex(int codeAddress) {
+        float avgCodeUnitsPerInstruction = 1.9f;
+
+        int index = (int) (codeAddress / avgCodeUnitsPerInstruction);
+        if (index >= instructionList.size()) {
+            index = instructionList.size() - 1;
+        }
+
+        MethodLocation guessedLocation = instructionList.get(index);
+
+        if (guessedLocation.codeAddress == codeAddress) {
+            return index;
+        } else if (guessedLocation.codeAddress > codeAddress) {
+            do {
+                index--;
+            } while (instructionList.get(index).codeAddress > codeAddress);
+            return index;
+        } else {
+            do {
+                index++;
+            }
+            while (index < instructionList.size() && instructionList.get(index).codeAddress <= codeAddress);
+            return index - 1;
+        }
+    }
+
+    @Nonnull
+    public Label newLabelForAddress(int codeAddress) {
+        if (codeAddress < 0 || codeAddress > instructionList.get(instructionList.size() - 1).codeAddress) {
+            throw new IndexOutOfBoundsException(String.format("codeAddress %d out of bounds", codeAddress));
+        }
+        MethodLocation referent = instructionList.get(mapCodeAddressToIndex(codeAddress));
+        return referent.addNewLabel();
+    }
+
+    @Nonnull
+    public Label newLabelForIndex(int instructionIndex) {
+        if (instructionIndex < 0 || instructionIndex >= instructionList.size()) {
+            throw new IndexOutOfBoundsException(String.format("instruction index %d out of bounds", instructionIndex));
+        }
+        MethodLocation referent = instructionList.get(instructionIndex);
+        return referent.addNewLabel();
+    }
+
+    @Nonnull
+    private Label newLabel(@Nonnull int[] codeAddressToIndex, int codeAddress) {
+        MethodLocation referent = instructionList.get(mapCodeAddressToIndex(codeAddressToIndex, codeAddress));
+        return referent.addNewLabel();
+    }
+
+    @Nonnull
+    public Label newSwitchPayloadReferenceLabel(@Nonnull MethodLocation switchLocation,
+                                                @Nonnull int[] codeAddressToIndex, int codeAddress) {
+        MethodLocation referent = instructionList.get(mapCodeAddressToIndex(codeAddressToIndex, codeAddress));
+        SwitchPayloadReferenceLabel label = new SwitchPayloadReferenceLabel();
+        label.switchLocation = switchLocation;
+        referent.getLabels().add(label);
+        return label;
+    }
+
+    private void setInstruction(@Nonnull MethodLocation location, @Nonnull BuilderInstruction instruction) {
+        location.instruction = instruction;
+        instruction.location = location;
+    }
+
+    private void convertAndSetInstruction(@Nonnull MethodLocation location, int[] codeAddressToIndex,
+                                          @Nonnull Instruction instruction) {
+        switch (instruction.getOpcode().format) {
+            case Format10t:
+                setInstruction(location, newBuilderInstruction10t(location.codeAddress,
+                        codeAddressToIndex,
+                        (Instruction10t) instruction));
+                return;
+            case Format10x:
+                setInstruction(location, newBuilderInstruction10x((Instruction10x) instruction));
+                return;
+            case Format11n:
+                setInstruction(location, newBuilderInstruction11n((Instruction11n) instruction));
+                return;
+            case Format11x:
+                setInstruction(location, newBuilderInstruction11x((Instruction11x) instruction));
+                return;
+            case Format12x:
+                setInstruction(location, newBuilderInstruction12x((Instruction12x) instruction));
+                return;
+            case Format20bc:
+                setInstruction(location, newBuilderInstruction20bc((Instruction20bc) instruction));
+                return;
+            case Format20t:
+                setInstruction(location, newBuilderInstruction20t(location.codeAddress,
+                        codeAddressToIndex,
+                        (Instruction20t) instruction));
+                return;
+            case Format21c:
+                setInstruction(location, newBuilderInstruction21c((Instruction21c) instruction));
+                return;
+            case Format21ih:
+                setInstruction(location, newBuilderInstruction21ih((Instruction21ih) instruction));
+                return;
+            case Format21lh:
+                setInstruction(location, newBuilderInstruction21lh((Instruction21lh) instruction));
+                return;
+            case Format21s:
+                setInstruction(location, newBuilderInstruction21s((Instruction21s) instruction));
+                return;
+            case Format21t:
+                setInstruction(location, newBuilderInstruction21t(location.codeAddress,
+                        codeAddressToIndex,
+                        (Instruction21t) instruction));
+                return;
+            case Format22b:
+                setInstruction(location, newBuilderInstruction22b((Instruction22b) instruction));
+                return;
+            case Format22c:
+                setInstruction(location, newBuilderInstruction22c((Instruction22c) instruction));
+                return;
+            case Format22s:
+                setInstruction(location, newBuilderInstruction22s((Instruction22s) instruction));
+                return;
+            case Format22t:
+                setInstruction(location, newBuilderInstruction22t(location.codeAddress,
+                        codeAddressToIndex,
+                        (Instruction22t) instruction));
+                return;
+            case Format22x:
+                setInstruction(location, newBuilderInstruction22x((Instruction22x) instruction));
+                return;
+            case Format23x:
+                setInstruction(location, newBuilderInstruction23x((Instruction23x) instruction));
+                return;
+            case Format25x:
+                setInstruction(location, newBuilderInstruction25x((Instruction25x) instruction));
+                return;
+            case Format30t:
+                setInstruction(location, newBuilderInstruction30t(location.codeAddress,
+                        codeAddressToIndex,
+                        (Instruction30t) instruction));
+                return;
+            case Format31c:
+                setInstruction(location, newBuilderInstruction31c((Instruction31c) instruction));
+                return;
+            case Format31i:
+                setInstruction(location, newBuilderInstruction31i((Instruction31i) instruction));
+                return;
+            case Format31t:
+                setInstruction(location, newBuilderInstruction31t(location, codeAddressToIndex,
+                        (Instruction31t) instruction));
+                return;
+            case Format32x:
+                setInstruction(location, newBuilderInstruction32x((Instruction32x) instruction));
+                return;
+            case Format35c:
+                setInstruction(location, newBuilderInstruction35c((Instruction35c) instruction));
+                return;
+            case Format3rc:
+                setInstruction(location, newBuilderInstruction3rc((Instruction3rc) instruction));
+                return;
+            case Format51l:
+                setInstruction(location, newBuilderInstruction51l((Instruction51l) instruction));
+                return;
+            case PackedSwitchPayload:
+                setInstruction(location,
+                        newBuilderPackedSwitchPayload(location, codeAddressToIndex, (PackedSwitchPayload) instruction));
+                return;
+            case SparseSwitchPayload:
+                setInstruction(location,
+                        newBuilderSparseSwitchPayload(location, codeAddressToIndex, (SparseSwitchPayload) instruction));
+                return;
+            case ArrayPayload:
+                setInstruction(location, newBuilderArrayPayload((ArrayPayload) instruction));
+                return;
+            default:
+                throw new ExceptionWithContext("Instruction format %s not supported", instruction.getOpcode().format);
+        }
+    }
+
+    @Nonnull
+    private BuilderInstruction10t newBuilderInstruction10t(int codeAddress, int[] codeAddressToIndex,
+                                                           @Nonnull Instruction10t instruction) {
+        return new BuilderInstruction10t(
+                instruction.getOpcode(),
+                newLabel(codeAddressToIndex, codeAddress + instruction.getCodeOffset()));
+    }
+
+    @Nonnull
+    private BuilderInstruction10x newBuilderInstruction10x(@Nonnull Instruction10x instruction) {
+        return new BuilderInstruction10x(
+                instruction.getOpcode());
+    }
+
+    @Nonnull
+    private BuilderInstruction11n newBuilderInstruction11n(@Nonnull Instruction11n instruction) {
+        return new BuilderInstruction11n(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getNarrowLiteral());
+    }
+
+    @Nonnull
+    private BuilderInstruction11x newBuilderInstruction11x(@Nonnull Instruction11x instruction) {
+        return new BuilderInstruction11x(
+                instruction.getOpcode(),
+                instruction.getRegisterA());
+    }
+
+    @Nonnull
+    private BuilderInstruction12x newBuilderInstruction12x(@Nonnull Instruction12x instruction) {
+        return new BuilderInstruction12x(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getRegisterB());
+    }
+
+    @Nonnull
+    private BuilderInstruction20bc newBuilderInstruction20bc(@Nonnull Instruction20bc instruction) {
+        return new BuilderInstruction20bc(
+                instruction.getOpcode(),
+                instruction.getVerificationError(),
+                convertReference(instruction.getReference()));
+    }
+
+    @Nonnull
+    private BuilderInstruction20t newBuilderInstruction20t(int codeAddress, int[] codeAddressToIndex,
+                                                           @Nonnull Instruction20t instruction) {
+        return new BuilderInstruction20t(
+                instruction.getOpcode(),
+                newLabel(codeAddressToIndex, codeAddress + instruction.getCodeOffset()));
+    }
+
+    @Nonnull
+    private BuilderInstruction21c newBuilderInstruction21c(@Nonnull Instruction21c instruction) {
+        return new BuilderInstruction21c(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                convertReference(instruction.getReference()));
+    }
+
+    @Nonnull
+    private BuilderInstruction21ih newBuilderInstruction21ih(@Nonnull Instruction21ih instruction) {
+        return new BuilderInstruction21ih(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getNarrowLiteral());
+    }
+
+    @Nonnull
+    private BuilderInstruction21lh newBuilderInstruction21lh(@Nonnull Instruction21lh instruction) {
+        return new BuilderInstruction21lh(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getWideLiteral());
+    }
+
+    @Nonnull
+    private BuilderInstruction21s newBuilderInstruction21s(@Nonnull Instruction21s instruction) {
+        return new BuilderInstruction21s(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getNarrowLiteral());
+    }
+
+    @Nonnull
+    private BuilderInstruction21t newBuilderInstruction21t(int codeAddress, int[] codeAddressToIndex,
+                                                           @Nonnull Instruction21t instruction) {
+        return new BuilderInstruction21t(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                newLabel(codeAddressToIndex, codeAddress + instruction.getCodeOffset()));
+    }
+
+    @Nonnull
+    private BuilderInstruction22b newBuilderInstruction22b(@Nonnull Instruction22b instruction) {
+        return new BuilderInstruction22b(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getRegisterB(),
+                instruction.getNarrowLiteral());
+    }
+
+    @Nonnull
+    private BuilderInstruction22c newBuilderInstruction22c(@Nonnull Instruction22c instruction) {
+        return new BuilderInstruction22c(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getRegisterB(),
+                convertReference(instruction.getReference()));
+    }
+
+    @Nonnull
+    private BuilderInstruction22s newBuilderInstruction22s(@Nonnull Instruction22s instruction) {
+        return new BuilderInstruction22s(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getRegisterB(),
+                instruction.getNarrowLiteral());
+    }
+
+    @Nonnull
+    private BuilderInstruction22t newBuilderInstruction22t(int codeAddress, int[] codeAddressToIndex,
+                                                           @Nonnull Instruction22t instruction) {
+        return new BuilderInstruction22t(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getRegisterB(),
+                newLabel(codeAddressToIndex, codeAddress + instruction.getCodeOffset()));
+    }
+
+    @Nonnull
+    private BuilderInstruction22x newBuilderInstruction22x(@Nonnull Instruction22x instruction) {
+        return new BuilderInstruction22x(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getRegisterB());
+    }
+
+    @Nonnull
+    private BuilderInstruction23x newBuilderInstruction23x(@Nonnull Instruction23x instruction) {
+        return new BuilderInstruction23x(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getRegisterB(),
+                instruction.getRegisterC());
+    }
+
+    @Nonnull
+    private BuilderInstruction30t newBuilderInstruction30t(int codeAddress, int[] codeAddressToIndex,
+                                                           @Nonnull Instruction30t instruction) {
+        return new BuilderInstruction30t(
+                instruction.getOpcode(),
+                newLabel(codeAddressToIndex, codeAddress + instruction.getCodeOffset()));
+    }
+
+    @Nonnull
+    private BuilderInstruction31c newBuilderInstruction31c(@Nonnull Instruction31c instruction) {
+        return new BuilderInstruction31c(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                convertReference(instruction.getReference()));
+    }
+
+    @Nonnull
+    private BuilderInstruction31i newBuilderInstruction31i(@Nonnull Instruction31i instruction) {
+        return new BuilderInstruction31i(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getNarrowLiteral());
+    }
+
+    @Nonnull
+    private BuilderInstruction31t newBuilderInstruction31t(@Nonnull MethodLocation location, int[] codeAddressToIndex,
+                                                           @Nonnull Instruction31t instruction) {
+        int codeAddress = location.getCodeAddress();
+        Label newLabel;
+        if (instruction.getOpcode() != Opcode.FILL_ARRAY_DATA) {
+            // if it's a sparse switch or packed switch
+            newLabel = newSwitchPayloadReferenceLabel(location, codeAddressToIndex, codeAddress + instruction.getCodeOffset());
+        } else {
+            newLabel = newLabel(codeAddressToIndex, codeAddress + instruction.getCodeOffset());
+        }
+        return new BuilderInstruction31t(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                newLabel);
+    }
+
+    @Nonnull
+    private BuilderInstruction32x newBuilderInstruction32x(@Nonnull Instruction32x instruction) {
+        return new BuilderInstruction32x(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getRegisterB());
+    }
+
+    @Nonnull
+    private BuilderInstruction35c newBuilderInstruction35c(@Nonnull Instruction35c instruction) {
+        return new BuilderInstruction35c(
+                instruction.getOpcode(),
+                instruction.getRegisterCount(),
+                instruction.getRegisterC(),
+                instruction.getRegisterD(),
+                instruction.getRegisterE(),
+                instruction.getRegisterF(),
+                instruction.getRegisterG(),
+                convertReference(instruction.getReference()));
+    }
+
+    @Nonnull
+    private BuilderInstruction25x newBuilderInstruction25x(@Nonnull Instruction25x instruction) {
+        return new BuilderInstruction25x(
+                instruction.getOpcode(),
+                instruction.getParameterRegisterCount(),
+                instruction.getRegisterFixedC(),
+                instruction.getRegisterParameterD(),
+                instruction.getRegisterParameterE(),
+                instruction.getRegisterParameterF(),
+                instruction.getRegisterParameterG());
+    }
+
+    @Nonnull
+    private BuilderInstruction3rc newBuilderInstruction3rc(@Nonnull Instruction3rc instruction) {
+        return new BuilderInstruction3rc(
+                instruction.getOpcode(),
+                instruction.getStartRegister(),
+                instruction.getRegisterCount(),
+                convertReference(instruction.getReference()));
+    }
+
+    @Nonnull
+    private BuilderInstruction51l newBuilderInstruction51l(@Nonnull Instruction51l instruction) {
+        return new BuilderInstruction51l(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getWideLiteral());
+    }
+
+    @Nullable
+    private MethodLocation findSwitchForPayload(@Nonnull MethodLocation payloadLocation) {
+        MethodLocation location = payloadLocation;
+        MethodLocation switchLocation = null;
+        do {
+            for (Label label : location.getLabels()) {
+                if (label instanceof SwitchPayloadReferenceLabel) {
+                    if (switchLocation != null) {
+                        throw new IllegalStateException("Multiple switch instructions refer to the same payload. "
+                            + "This is not currently supported. Please file a bug :)");
+                    }
+                    switchLocation = ((SwitchPayloadReferenceLabel) label).switchLocation;
+                }
+            }
+
+            // A switch instruction can refer to the payload instruction itself, or to a nop before the payload
+            // instruction.
+            // We need to search for all occurrences of a switch reference, so we can detect when multiple switch
+            // statements refer to the same payload
+            // TODO: confirm that it could refer to the first NOP in a series of NOPs preceding the payload
+            if (location.index == 0) {
+                return switchLocation;
+            }
+            location = instructionList.get(location.index - 1);
+            if (location.instruction == null || location.instruction.getOpcode() != Opcode.NOP) {
+                return switchLocation;
+            }
+        } while (true);
+    }
+
+    @Nonnull
+    private BuilderPackedSwitchPayload newBuilderPackedSwitchPayload(@Nonnull MethodLocation location,
+                                                                     @Nonnull int[] codeAddressToIndex,
+                                                                     @Nonnull PackedSwitchPayload instruction) {
+        List<? extends SwitchElement> switchElements = instruction.getSwitchElements();
+        if (switchElements.size() == 0) {
+            return new BuilderPackedSwitchPayload(0, null);
+        }
+
+        MethodLocation switchLocation = findSwitchForPayload(location);
+        int baseAddress;
+        if (switchLocation == null) {
+            baseAddress = 0;
+        } else {
+            baseAddress = switchLocation.codeAddress;
+        }
+
+        List<Label> labels = Lists.newArrayList();
+        for (SwitchElement element : switchElements) {
+            labels.add(newLabel(codeAddressToIndex, element.getOffset() + baseAddress));
+        }
+
+        return new BuilderPackedSwitchPayload(switchElements.get(0).getKey(), labels);
+    }
+
+    @Nonnull
+    private BuilderSparseSwitchPayload newBuilderSparseSwitchPayload(@Nonnull MethodLocation location,
+                                                                     @Nonnull int[] codeAddressToIndex,
+                                                                     @Nonnull SparseSwitchPayload instruction) {
+        List<? extends SwitchElement> switchElements = instruction.getSwitchElements();
+        if (switchElements.size() == 0) {
+            return new BuilderSparseSwitchPayload(null);
+        }
+
+        MethodLocation switchLocation = findSwitchForPayload(location);
+        int baseAddress;
+        if (switchLocation == null) {
+            baseAddress = 0;
+        } else {
+            baseAddress = switchLocation.codeAddress;
+        }
+
+        List<SwitchLabelElement> labelElements = Lists.newArrayList();
+        for (SwitchElement element : switchElements) {
+            labelElements.add(new SwitchLabelElement(element.getKey(),
+                    newLabel(codeAddressToIndex, element.getOffset() + baseAddress)));
+        }
+
+        return new BuilderSparseSwitchPayload(labelElements);
+    }
+
+    @Nonnull
+    private BuilderArrayPayload newBuilderArrayPayload(@Nonnull ArrayPayload instruction) {
+        return new BuilderArrayPayload(instruction.getElementWidth(), instruction.getArrayElements());
+    }
+
+    private Reference convertReference(@Nonnull Reference reference) {
+        if (reference != null && this.dexBuilder != null) {
+            return this.dexBuilder.internReference(reference);
+        } else {
+            return reference;
+        }
+    }
+
+    @Nonnull
+    private BuilderDebugItem convertDebugItem(@Nonnull DebugItem debugItem) {
+        switch (debugItem.getDebugItemType()) {
+            case DebugItemType.START_LOCAL: {
+                StartLocal startLocal = (StartLocal) debugItem;
+                return new BuilderStartLocal(startLocal.getRegister(),
+                        (StringReference) convertReference(startLocal.getNameReference()),
+                        (TypeReference) convertReference(startLocal.getTypeReference()),
+                        (StringReference) convertReference(startLocal.getSignatureReference()));
+            }
+            case DebugItemType.END_LOCAL: {
+                EndLocal endLocal = (EndLocal) debugItem;
+                return new BuilderEndLocal(endLocal.getRegister());
+            }
+            case DebugItemType.RESTART_LOCAL: {
+                RestartLocal restartLocal = (RestartLocal) debugItem;
+                return new BuilderRestartLocal(restartLocal.getRegister());
+            }
+            case DebugItemType.PROLOGUE_END:
+                return new BuilderPrologueEnd();
+            case DebugItemType.EPILOGUE_BEGIN:
+                return new BuilderEpilogueBegin();
+            case DebugItemType.LINE_NUMBER: {
+                LineNumber lineNumber = (LineNumber) debugItem;
+                return new BuilderLineNumber(lineNumber.getLineNumber());
+            }
+            case DebugItemType.SET_SOURCE_FILE: {
+                SetSourceFile setSourceFile = (SetSourceFile) debugItem;
+                return new BuilderSetSourceFile(
+                        (StringReference) convertReference(setSourceFile.getSourceFileReference())
+                );
+            }
+            default:
+                throw new ExceptionWithContext("Invalid debug item type: " + debugItem.getDebugItemType());
+        }
+    }
+
+    private interface Task {
+        void perform();
+    }
+
+    private static class SwitchPayloadReferenceLabel extends Label {
+        @Nonnull
+        public MethodLocation switchLocation;
+    }
+}
+
diff --git a/tinker-build/tinker-patch-lib/src/main/resources/only_use_to_test_tinker_resource.txt b/tinker-build/tinker-patch-lib/src/main/resources/only_use_to_test_tinker_resource.txt
new file mode 100644
index 00000000..dc9c715f
--- /dev/null
+++ b/tinker-build/tinker-patch-lib/src/main/resources/only_use_to_test_tinker_resource.txt
@@ -0,0 +1 @@
+#tinker resource changed
\ No newline at end of file
diff --git a/tinker-commons/build.gradle b/tinker-commons/build.gradle
index eb94594d..c6025027 100644
--- a/tinker-commons/build.gradle
+++ b/tinker-commons/build.gradle
@@ -5,6 +5,7 @@ group rootProject.ext.GROUP
 
 [compileJava, compileTestJava, javadoc]*.options*.encoding = 'UTF-8'
 
+
 dependencies {
     compile fileTree(dir: 'libs', include: ['*.jar'])
     compile project(':third-party:aosp-dexutils')
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/DexPatcherLogger.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/DexPatcherLogger.java
index 3ee24910..76b4ae65 100644
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/DexPatcherLogger.java
+++ b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/DexPatcherLogger.java
@@ -7,6 +7,10 @@
 public final class DexPatcherLogger {
     private IDexPatcherLogger loggerImpl = null;
 
+    public IDexPatcherLogger getLoggerImpl() {
+        return this.loggerImpl;
+    }
+
     public void setLoggerImpl(IDexPatcherLogger dexPatcherLogger) {
         this.loggerImpl = dexPatcherLogger;
     }
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/DexSectionPatchAlgorithm.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/DexSectionPatchAlgorithm.java
index 62b746f0..835ebd94 100644
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/DexSectionPatchAlgorithm.java
+++ b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/DexSectionPatchAlgorithm.java
@@ -75,7 +75,7 @@ public DexSectionPatchAlgorithm(
     }
 
     /**
-     * Get {@code Section} in {@code TableOfContents}.
+     * Get {@link TableOfContents.Section} from {@code dex}.
      */
     protected abstract TableOfContents.Section getTocSection(Dex dex);
 
@@ -105,6 +105,16 @@ protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffse
 
     /**
      * Mark deleted index or offset in {@code indexMap}.
+     *
+     * Here we mark deleted item for such a case like this:
+     *   Item in DebugInfo section reference a string in StringData section
+     *   by index X, while in patched dex, the referenced string is removed.
+     *
+     * The {@code indexMap} must be aware of this case and return -1
+     * instead of the original value X.
+     *
+     * Further more, the special value -1 is not chosen by our inspiration but
+     * the definition of NO_INDEX in document of dex file format.
      */
     protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
         // Should override by subclass if needed.
@@ -148,7 +158,7 @@ protected final boolean isPatchedItemInSmallPatchedDex(String oldDexSignStr, int
 
     /**
      * Adapter method for item's offset fetching, if an item is not
-     * inherited from {@code Item} (which means it is a simple item in dex section
+     * inherited from {@link TableOfContents.Section.Item} (which means it is a simple item in dex section
      * that doesn't need multiple members to describe), this method
      * return {@code index} instead.
      */
@@ -247,11 +257,21 @@ private void doFullPatch(
             } else
             if (Arrays.binarySearch(deletedIndices, oldIndex) >= 0) {
                 T skippedOldItem = nextItem(oldSection); // skip old item.
+                markDeletedIndexOrOffset(
+                        oldToFullPatchedIndexMap,
+                        oldIndex,
+                        getItemOffsetOrIndex(oldIndex, skippedOldItem)
+                );
                 ++oldIndex;
                 ++deletedItemCounter;
             } else
             if (Arrays.binarySearch(replacedIndices, oldIndex) >= 0) {
                 T skippedOldItem = nextItem(oldSection); // skip old item.
+                markDeletedIndexOrOffset(
+                        oldToFullPatchedIndexMap,
+                        oldIndex,
+                        getItemOffsetOrIndex(oldIndex, skippedOldItem)
+                );
                 ++oldIndex;
             } else
             if (oldIndex < oldItemCount) {
@@ -362,11 +382,21 @@ private void doSmallPatch(
             } else
             if (Arrays.binarySearch(deletedIndices, oldIndex) >= 0) {
                 T skippedOldItem = nextItem(oldSection); // skip old item.
+                markDeletedIndexOrOffset(
+                        oldToFullPatchedIndexMap,
+                        oldIndex,
+                        getItemOffsetOrIndex(oldIndex, skippedOldItem)
+                );
                 ++oldIndex;
                 ++deletedItemCounter;
             } else
             if (Arrays.binarySearch(replacedIndices, oldIndex) >= 0) {
                 T skippedOldItem = nextItem(oldSection); // skip old item.
+                markDeletedIndexOrOffset(
+                        oldToFullPatchedIndexMap,
+                        oldIndex,
+                        getItemOffsetOrIndex(oldIndex, skippedOldItem)
+                );
                 ++oldIndex;
             } else
             if (oldIndex < oldItemCount) {
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/struct/DexPatchFile.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/struct/DexPatchFile.java
index 1cb356f4..edbbc9ee 100644
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/struct/DexPatchFile.java
+++ b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/struct/DexPatchFile.java
@@ -17,7 +17,6 @@
 package com.tencent.tinker.commons.dexpatcher.struct;
 
 import com.tencent.tinker.android.dex.SizeOf;
-import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
 import com.tencent.tinker.android.dex.util.CompareUtils;
 import com.tencent.tinker.android.dex.util.FileUtils;
@@ -26,11 +25,7 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.nio.ByteBuffer;
-import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
 
 /**
  * Created by tangyinsheng on 2016/7/1.
@@ -106,116 +101,6 @@ private void init() {
         this.buffer.position(firstChunkOffset);
     }
 
-    private List<Integer> readDeltaIndiciesOrOffsets(int count) {
-        List<Integer> result = new ArrayList<>(count);
-        int lastVal = 0;
-        for (int i = 0; i < count; ++i) {
-            int delta = this.buffer.readSleb128();
-            lastVal = lastVal + delta;
-            result.add(lastVal);
-        }
-        return result;
-    }
-
-    private <T extends Comparable<T>> void readChunkData(
-            int sectionType, Set<Integer> deletedItemIndices, Map<Integer, T> indexToNewItemMap
-    ) {
-        int deletedItemCount = this.buffer.readUleb128();
-        List<Integer> deletedIndices = readDeltaIndiciesOrOffsets(deletedItemCount);
-        deletedItemIndices.addAll(deletedIndices);
-
-        int addedItemCount = this.buffer.readUleb128();
-        List<Integer> addedIndices = readDeltaIndiciesOrOffsets(addedItemCount);
-
-        int replacedItemCount = this.buffer.readUleb128();
-        List<Integer> replacedIndices = readDeltaIndiciesOrOffsets(replacedItemCount);
-
-        int addedIndexCursor = 0;
-        int replacedIndexCursor = 0;
-
-        while (addedIndexCursor < addedItemCount || replacedIndexCursor < replacedItemCount) {
-            if (addedIndexCursor >= addedItemCount) {
-                // rest items are all replaced item.
-                while (replacedIndexCursor < replacedItemCount) {
-                    T newItem = readItemBySectionType(sectionType);
-                    indexToNewItemMap.put(replacedIndexCursor, newItem);
-                    ++replacedIndexCursor;
-                }
-            } else
-            if (replacedIndexCursor >= replacedItemCount) {
-                // rest items are all added item.
-                while (addedIndexCursor < addedItemCount) {
-                    T newItem = readItemBySectionType(sectionType);
-                    indexToNewItemMap.put(addedIndexCursor, newItem);
-                    ++addedIndexCursor;
-                }
-            } else {
-                T newItem = readItemBySectionType(sectionType);
-                if (addedIndexCursor <= replacedIndexCursor) {
-                    indexToNewItemMap.put(addedIndexCursor, newItem);
-                    ++addedIndexCursor;
-                } else {
-                    indexToNewItemMap.put(replacedIndexCursor, newItem);
-                    ++replacedIndexCursor;
-                }
-            }
-        }
-    }
-
-    @SuppressWarnings("unchecked")
-    private <T extends Comparable<T>> T readItemBySectionType(int sectionType) {
-        switch (sectionType) {
-            case TableOfContents.SECTION_TYPE_TYPEIDS: {
-                return (T) (Integer) this.buffer.readInt();
-            }
-            case TableOfContents.SECTION_TYPE_PROTOIDS: {
-                return (T) this.buffer.readProtoId();
-            }
-            case TableOfContents.SECTION_TYPE_FIELDIDS: {
-                return (T) this.buffer.readFieldId();
-            }
-            case TableOfContents.SECTION_TYPE_METHODIDS: {
-                return (T) this.buffer.readMethodId();
-            }
-            case TableOfContents.SECTION_TYPE_CLASSDEFS: {
-                return (T) this.buffer.readClassDef();
-            }
-            case TableOfContents.SECTION_TYPE_STRINGDATAS: {
-                return (T) this.buffer.readStringData();
-            }
-            case TableOfContents.SECTION_TYPE_TYPELISTS: {
-                return (T) this.buffer.readTypeList();
-            }
-            case TableOfContents.SECTION_TYPE_ANNOTATIONS: {
-                return (T) this.buffer.readAnnotation();
-            }
-            case TableOfContents.SECTION_TYPE_ANNOTATIONSETS: {
-                return (T) this.buffer.readAnnotationSet();
-            }
-            case TableOfContents.SECTION_TYPE_ANNOTATIONSETREFLISTS: {
-                return (T) this.buffer.readAnnotationSetRefList();
-            }
-            case TableOfContents.SECTION_TYPE_ANNOTATIONSDIRECTORIES: {
-                return (T) this.buffer.readAnnotationsDirectory();
-            }
-            case TableOfContents.SECTION_TYPE_DEBUGINFOS: {
-                return (T) this.buffer.readDebugInfoItem();
-            }
-            case TableOfContents.SECTION_TYPE_CODES: {
-                return (T) this.buffer.readCode();
-            }
-            case TableOfContents.SECTION_TYPE_CLASSDATA: {
-                return (T) this.buffer.readClassData();
-            }
-            case TableOfContents.SECTION_TYPE_ENCODEDARRAYS: {
-                return (T) this.buffer.readEncodedArray();
-            }
-            default: {
-                return null;
-            }
-        }
-    }
-
     public short getVersion() {
         return version;
     }
diff --git a/tinker-sample-android/app/build.gradle b/tinker-sample-android/app/build.gradle
index 42fb28e3..516f6b4e 100644
--- a/tinker-sample-android/app/build.gradle
+++ b/tinker-sample-android/app/build.gradle
@@ -7,23 +7,25 @@ dependencies {
     testCompile 'junit:junit:4.12'
     compile "com.android.support:appcompat-v7:23.1.1"
     compile("com.tencent.tinker:tinker-android-lib:${TINKER_VERSION}") { changing = true }
-    compile("com.tencent.tinker:tinker-android-anno:${TINKER_VERSION}") { changing = true }
+    provided("com.tencent.tinker:tinker-android-anno:${TINKER_VERSION}") { changing = true }
+
     compile "com.android.support:multidex:1.0.1"
 
+    //use to test multiDex
+//    compile group: 'com.google.guava', name: 'guava', version: '19.0'
+//    compile "org.scala-lang:scala-library:2.11.7"
+
     //use for local maven test
 //    compile("com.tencent.tinker:tinker-android-loader:${TINKER_VERSION}") { changing = true }
 //    compile("com.tencent.tinker:aosp-dexutils:${TINKER_VERSION}") { changing = true }
 //    compile("com.tencent.tinker:bsdiff-util:${TINKER_VERSION}") { changing = true }
 //    compile("com.tencent.tinker:tinker-commons:${TINKER_VERSION}") { changing = true }
 
-    //use to test multiDex
-//    compile group: 'com.google.guava', name: 'guava', version: '19.0'
-//    compile "org.scala-lang:scala-library:2.11.7"
 }
 
 def gitSha() {
     try {
-        String gitRev = 'git rev-parse --short HEAD'.execute().text.trim()
+        String gitRev = 'git rev-parse --short HEAD'.execute(null, project.rootDir).text.trim()
         if (gitRev == null) {
             throw new GradleException("can't get git rev, you should add git to system path or just input test value, such as 'testTinkerId'")
         }
@@ -91,9 +93,14 @@ android {
          * client version would update with patch
          * so we can get the newly git version easily!
          */
-        buildConfigField "String", "CLIENTVERSION", "\"${gitSha()}\""
+        buildConfigField "String", "CLIENTVERSION", "\"${getTinkerIdValue()}\""
         buildConfigField "String", "PLATFORM",  "\"all\""
     }
+
+//    aaptOptions{
+//        cruncherEnabled false
+//    }
+
 //    //use to test flavors support
 //    productFlavors {
 //        flavor1 {
@@ -134,13 +141,17 @@ def bakPath = file("${buildDir}/bakApk/")
 ext {
     //for some reason, you may want to ignore tinkerBuild, such as instant run debug build?
     tinkerEnabled = true
-    //you should bak the following files
+
+    //for normal build
     //old apk file to build patch apk
-    tinkerOldApkPath = "${bakPath}/app-debug-0919-20-32-57.apk"
+    tinkerOldApkPath = "${bakPath}/app-debug-1018-17-32-47.apk"
     //proguard mapping file to build patch apk
-    tinkerApplyMappingPath = "${bakPath}/"
+    tinkerApplyMappingPath = "${bakPath}/app-debug-1018-17-32-47-mapping.txt"
     //resource R.txt to build patch apk, must input if there is resource changed
-    tinkerApplyResourcePath = "${bakPath}/"
+    tinkerApplyResourcePath = "${bakPath}/app-debug-1018-17-32-47-R.txt"
+
+    //only use for build all flavor, if not, just ignore this field
+    tinkerBuildFlavorDirectory = "${bakPath}/app-1018-17-32-47"
 }
 
 
@@ -164,6 +175,10 @@ def buildWithTinker() {
     return hasProperty("TINKER_ENABLE") ? TINKER_ENABLE : ext.tinkerEnabled
 }
 
+def getTinkerBuildFlavorDirectory() {
+    return ext.tinkerBuildFlavorDirectory
+}
+
 if (buildWithTinker()) {
     apply plugin: 'com.tencent.tinker.patch'
 
@@ -190,6 +205,7 @@ if (buildWithTinker()) {
          * case 5: resources.arsc has changed, but we don't use applyResourceMapping to build
          */
         ignoreWarning = false
+
         /**
          * optional，default 'true'
          * whether sign the patch file
@@ -235,6 +251,20 @@ if (buildWithTinker()) {
              * or you want to save rom or check quicker, you can use raw mode also
              */
             dexMode = "jar"
+            /**
+             * optional，default 'false'
+             * if usePreGeneratedPatchDex is true, tinker framework will generate auxiliary class
+             * and insert auxiliary instruction when compiling base package using
+             * assemble{Debug/Release} task to prevent class pre-verified issue in dvm.
+             * Besides, a real dex file contains necessary class will be generated and packed into
+             * patch package instead of any patch info files.
+             *
+             * Use this mode if you have to use any dex encryption solutions.
+             *
+             * Notice: If you change this value, please trigger clean task
+             * and regenerate base package.
+             */
+            usePreGeneratedPatchDex = false
             /**
              * necessary，default '[]'
              * what dexes in apk are expected to deal with tinkerPatch
@@ -252,7 +282,8 @@ if (buildWithTinker()) {
              *
              */
             loader = ["com.tencent.tinker.loader.*",
-                      "tinker.sample.android.SampleApplication",
+                      //warning, you must change it with your application
+                      "tinker.sample.android.app.SampleApplication",
                       //use sample, let BaseBuildInfo unchangeable with tinker
                       "tinker.sample.android.app.BaseBuildInfo"
             ]
@@ -311,7 +342,10 @@ if (buildWithTinker()) {
              * Then you can use patch conditional!
              */
             configField("platform", "all")
-
+            /**
+             * patch version via packageConfig
+             */
+            configField("patchVersion", "1.0")
         }
         //or you can add config filed outside, or get meta value from old apk
         //project.tinkerPatch.packageConfig.configField("test1", project.tinkerPatch.packageConfig.getMetaDataFromOldApk("Test"))
@@ -334,36 +368,87 @@ if (buildWithTinker()) {
         }
     }
 
-    /**
-    * task type, you want to bak
-    */
-    def taskName = "debug"
-
+    List<String> flavors = new ArrayList<>();
+    project.android.productFlavors.each {flavor ->
+        flavors.add(flavor.name)
+    }
+    boolean hasFlavors = flavors.size() > 0
     /**
     * bak apk and mapping
     */
-    tasks.all {
-        if ("assemble${taskName.capitalize()}".equalsIgnoreCase(it.name)) {
-            it.doLast {
-                copy {
-                    def date = new Date().format("MMdd-HH-mm-ss")
-                    from "${buildDir}/outputs/apk/${project.getName()}-${taskName}.apk"
-                    into bakPath
-                    rename { String fileName ->
-                        fileName.replace("${project.getName()}-${taskName}.apk", "${project.getName()}-${taskName}-${date}.apk")
+    android.applicationVariants.all { variant ->
+        /**
+         * task type, you want to bak
+         */
+        def taskName = variant.name
+        def date = new Date().format("MMdd-HH-mm-ss")
+
+        tasks.all {
+            if ("assemble${taskName.capitalize()}".equalsIgnoreCase(it.name)) {
+
+                it.doLast {
+                    copy {
+                        def fileNamePrefix = "${project.name}-${variant.baseName}"
+                        def newFileNamePrefix = hasFlavors ? "${fileNamePrefix}" : "${fileNamePrefix}-${date}"
+
+                        def destPath = hasFlavors ? file("${bakPath}/${project.name}-${date}/${variant.flavorName}") : bakPath
+                        from variant.outputs.outputFile
+                        into destPath
+                        rename { String fileName ->
+                            fileName.replace("${fileNamePrefix}.apk", "${newFileNamePrefix}.apk")
+                        }
+
+                        from "${buildDir}/outputs/mapping/${variant.dirName}/mapping.txt"
+                        into destPath
+                        rename { String fileName ->
+                            fileName.replace("mapping.txt", "${newFileNamePrefix}-mapping.txt")
+                        }
+
+                        from "${buildDir}/intermediates/symbols/${variant.dirName}/R.txt"
+                        into destPath
+                        rename { String fileName ->
+                            fileName.replace("R.txt", "${newFileNamePrefix}-R.txt")
+                        }
                     }
+                }
+            }
+        }
+    }
+    project.afterEvaluate {
+        //sample use for build all flavor for one time
+        if (hasFlavors) {
+            task(tinkerPatchAllFlavorRelease) {
+                group = 'tinker'
+                def originOldPath = getTinkerBuildFlavorDirectory()
+                for (String flavor : flavors) {
+                    def tinkerTask = tasks.getByName("tinkerPatch${flavor.capitalize()}Release")
+                    dependsOn tinkerTask
+                    def preAssembleTask = tasks.getByName("process${flavor.capitalize()}ReleaseManifest")
+                    preAssembleTask.doFirst {
+                        String flavorName = preAssembleTask.name.substring(7, 8).toLowerCase() + preAssembleTask.name.substring(8, preAssembleTask.name.length() - 15)
+                        project.tinkerPatch.oldApk = "${originOldPath}/${flavorName}/${project.name}-${flavorName}-release.apk"
+                        project.tinkerPatch.buildConfig.applyMapping = "${originOldPath}/${flavorName}/${project.name}-${flavorName}-release-mapping.txt"
+                        project.tinkerPatch.buildConfig.applyResourceMapping = "${originOldPath}/${flavorName}/${project.name}-${flavorName}-release-R.txt"
 
-                    from "${buildDir}/outputs/mapping/${taskName}/mapping.txt"
-                    into bakPath
-                    rename { String fileName ->
-                        fileName.replace("mapping.txt", "${project.getName()}-${taskName}-${date}-mapping.txt")
                     }
 
-                    from "${buildDir}/intermediates/symbols/${taskName}/R.txt"
-                    into bakPath
-                    rename { String fileName ->
-                        fileName.replace("R.txt", "${project.getName()}-${taskName}-${date}-R.txt")
+                }
+            }
+
+            task(tinkerPatchAllFlavorDebug) {
+                group = 'tinker'
+                def originOldPath = getTinkerBuildFlavorDirectory()
+                for (String flavor : flavors) {
+                    def tinkerTask = tasks.getByName("tinkerPatch${flavor.capitalize()}Debug")
+                    dependsOn tinkerTask
+                    def preAssembleTask = tasks.getByName("process${flavor.capitalize()}DebugManifest")
+                    preAssembleTask.doFirst {
+                        String flavorName = preAssembleTask.name.substring(7, 8).toLowerCase() + preAssembleTask.name.substring(8, preAssembleTask.name.length() - 13)
+                        project.tinkerPatch.oldApk = "${originOldPath}/${flavorName}/${project.name}-${flavorName}-debug.apk"
+                        project.tinkerPatch.buildConfig.applyMapping = "${originOldPath}/${flavorName}/${project.name}-${flavorName}-debug-mapping.txt"
+                        project.tinkerPatch.buildConfig.applyResourceMapping = "${originOldPath}/${flavorName}/${project.name}-${flavorName}-debug-R.txt"
                     }
+
                 }
             }
         }
diff --git a/tinker-sample-android/app/libs/armeabi/libstlport_shared.so b/tinker-sample-android/app/libs/armeabi/libstlport_shared.so
deleted file mode 100755
index 050818bb..00000000
Binary files a/tinker-sample-android/app/libs/armeabi/libstlport_shared.so and /dev/null differ
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SampleTinkerReport.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SampleTinkerReport.java
index 269f1066..9ec92dd2 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SampleTinkerReport.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SampleTinkerReport.java
@@ -74,6 +74,8 @@
     public static final int KEY_APPLIED_PACKAGE_CHECK_META_NOT_FOUND            = 155;
     public static final int KEY_APPLIED_PACKAGE_CHECK_TINKER_ID_NOT_EQUAL       = 156;
     public static final int KEY_APPLIED_PACKAGE_CHECK_RES_META                  = 157;
+    public static final int KEY_APPLIED_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT    = 158;
+
     //version check
     public static final int KEY_APPLIED_VERSION_CHECK                           = 180;
     //extract error
@@ -100,11 +102,13 @@
 
 
     // KEY -- load detail
-    public static final int KEY_LOADED_UNKNOWN_EXCEPTION   = 250;
-    public static final int KEY_LOADED_UNCAUGHT_EXCEPTION  = 251;
-    public static final int KEY_LOADED_EXCEPTION_DEX       = 252;
-    public static final int KEY_LOADED_EXCEPTION_DEX_CHECK = 253;
-    public static final int KEY_LOADED_EXCEPTION_RESOURCE  = 254;
+    public static final int KEY_LOADED_UNKNOWN_EXCEPTION        = 250;
+    public static final int KEY_LOADED_UNCAUGHT_EXCEPTION       = 251;
+    public static final int KEY_LOADED_EXCEPTION_DEX            = 252;
+    public static final int KEY_LOADED_EXCEPTION_DEX_CHECK      = 253;
+    public static final int KEY_LOADED_EXCEPTION_RESOURCE       = 254;
+    public static final int KEY_LOADED_EXCEPTION_RESOURCE_CEHCK = 255;
+
 
     public static final int KEY_LOADED_MISMATCH_DEX       = 300;
     public static final int KEY_LOADED_MISMATCH_LIB       = 301;
@@ -126,6 +130,8 @@
     public static final int KEY_LOADED_PACKAGE_CHECK_TINKER_ID_NOT_EQUAL       = 355;
     public static final int KEY_LOADED_PACKAGE_CHECK_PACKAGE_META_NOT_FOUND    = 356;
     public static final int KEY_LOADED_PACKAGE_CHECK_RES_META                  = 357;
+    public static final int KEY_LOADED_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT    = 358;
+
 
     public static final int KEY_LOADED_SUCC_COST_500_LESS  = 400;
     public static final int KEY_LOADED_SUCC_COST_1000_LESS = 401;
@@ -228,6 +234,9 @@ public static void onLoadPackageCheckFail(int errorCode) {
             case ShareConstants.ERROR_PACKAGE_CHECK_RESOURCE_META_CORRUPTED:
                 reporter.onReport(KEY_LOADED_PACKAGE_CHECK_RES_META);
                 break;
+            case ShareConstants.ERROR_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT:
+                reporter.onReport(KEY_LOADED_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT);
+                break;
         }
     }
 
@@ -309,12 +318,12 @@ public static void onLoadException(Throwable throwable, int errorCode) {
         if (reporter == null) {
             return;
         }
-        boolean isDexCheckFail = false;
+        boolean isCheckFail = false;
         switch (errorCode) {
             case ShareConstants.ERROR_LOAD_EXCEPTION_DEX:
                 if (throwable.getMessage().contains(ShareConstants.CHECK_DEX_INSTALL_FAIL)) {
                     reporter.onReport(KEY_LOADED_EXCEPTION_DEX_CHECK);
-                    isDexCheckFail = true;
+                    isCheckFail = true;
                     TinkerLog.e(TAG, "tinker dex check fail:" + throwable.getMessage());
                 } else {
                     reporter.onReport(KEY_LOADED_EXCEPTION_DEX);
@@ -322,7 +331,14 @@ public static void onLoadException(Throwable throwable, int errorCode) {
                 }
                 break;
             case ShareConstants.ERROR_LOAD_EXCEPTION_RESOURCE:
-                reporter.onReport(KEY_LOADED_EXCEPTION_RESOURCE);
+                if (throwable.getMessage().contains(ShareConstants.CHECK_RES_INSTALL_FAIL)) {
+                    reporter.onReport(KEY_LOADED_EXCEPTION_RESOURCE_CEHCK);
+                    isCheckFail = true;
+                    TinkerLog.e(TAG, "tinker res check fail:" + throwable.getMessage());
+                } else {
+                    reporter.onReport(KEY_LOADED_EXCEPTION_RESOURCE);
+                    TinkerLog.e(TAG, "tinker res reflect fail:" + throwable.getMessage());
+                }
                 break;
             case ShareConstants.ERROR_LOAD_EXCEPTION_UNCAUGHT:
                 reporter.onReport(KEY_LOADED_UNCAUGHT_EXCEPTION);
@@ -332,7 +348,7 @@ public static void onLoadException(Throwable throwable, int errorCode) {
                 break;
         }
         //reporter exception, for dex check fail, we don't need to report stacktrace
-        if (!isDexCheckFail) {
+        if (!isCheckFail) {
             reporter.onReport("Tinker Exception:load tinker occur exception " + Utils.getExceptionCauseString(throwable));
         }
     }
@@ -483,6 +499,9 @@ public static void onApplyPackageCheckFail(int errorCode) {
             case ShareConstants.ERROR_PACKAGE_CHECK_RESOURCE_META_CORRUPTED:
                 reporter.onReport(KEY_APPLIED_PACKAGE_CHECK_RES_META);
                 break;
+            case ShareConstants.ERROR_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT:
+                reporter.onReport(KEY_APPLIED_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT);
+                break;
         }
     }
 
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/util/UpgradePatchRetry.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/util/UpgradePatchRetry.java
index e3f8eefa..714749e6 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/util/UpgradePatchRetry.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/util/UpgradePatchRetry.java
@@ -149,6 +149,10 @@ public void onPatchServiceStart(Intent intent) {
         File patchFile = new File(path);
 
         String patchMd5 = SharePatchFileUtil.getMD5(patchFile);
+        if (patchMd5 == null) {
+            TinkerLog.w(TAG, "onPatchServiceStart patch md5 is null, just return");
+            return;
+        }
 
         if (retryInfoFile.exists()) {
             retryInfo = RetryInfo.readRetryProperty(retryInfoFile);
diff --git a/tinker-sample-android/build.gradle b/tinker-sample-android/build.gradle
index 7f8c6830..08af2ebf 100644
--- a/tinker-sample-android/build.gradle
+++ b/tinker-sample-android/build.gradle
@@ -5,7 +5,7 @@ buildscript {
         jcenter()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:2.1.0'
+        classpath 'com.android.tools.build:gradle:2.2.0'
         classpath "com.tencent.tinker:tinker-patch-gradle-plugin:${TINKER_VERSION}"
     }
 }
diff --git a/tinker-sample-android/gradle.properties b/tinker-sample-android/gradle.properties
index 27cc7999..e608e456 100644
--- a/tinker-sample-android/gradle.properties
+++ b/tinker-sample-android/gradle.properties
@@ -17,4 +17,4 @@
 # http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
 # org.gradle.parallel=true
 
-TINKER_VERSION=1.6.1
+TINKER_VERSION=1.7.2
diff --git a/tinker-sample-android/gradle/wrapper/gradle-wrapper.properties b/tinker-sample-android/gradle/wrapper/gradle-wrapper.properties
index c25cec52..86d6158a 100644
--- a/tinker-sample-android/gradle/wrapper/gradle-wrapper.properties
+++ b/tinker-sample-android/gradle/wrapper/gradle-wrapper.properties
@@ -3,4 +3,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.10-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.14.1-all.zip
