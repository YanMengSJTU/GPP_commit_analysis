diff --git a/README.md b/README.md
index 0ee3d075..cea57bd8 100644
--- a/README.md
+++ b/README.md
@@ -1,7 +1,8 @@
 ## Tinker
 [![license](http://img.shields.io/badge/license-BSD3-brightgreen.svg?style=flat)](https://github.com/Tencent/tinker/blob/master/LICENSE)
-[![Release Version](https://img.shields.io/badge/release-1.6.1-red.svg)](https://github.com/Tencent/tinker/releases) 
+[![Release Version](https://img.shields.io/badge/release-1.7.0-red.svg)](https://github.com/Tencent/tinker/releases) 
 [![PRs Welcome](https://img.shields.io/badge/PRs-welcome-brightgreen.svg)](https://github.com/Tencent/tinker/pulls)
+[![WeChat Approved](https://img.shields.io/badge/Wechat_Approved-1.6.2-red.svg)](https://github.com/Tencent/tinker/wiki)
 
 Tinker is a hot-fix solution library for Android, it supports dex, library and resources update without reinstalling apk.
 
@@ -13,7 +14,7 @@ Add tinker-gradle-plugin as a dependency in your main `build.gradle` in the root
 ```gradle
 buildscript {
     dependencies {
-        classpath ('com.tencent.tinker:tinker-patch-gradle-plugin:1.6.2')
+        classpath ('com.tencent.tinker:tinker-patch-gradle-plugin:1.7.0')
     }
 }
 ```
@@ -23,9 +24,9 @@ Then you need to "apply" the plugin and add dependencies by adding the following
 ```gradle
 dependencies {
     //optional, help to generate the final application 
-    compile('com.tencent.tinker:tinker-android-anno:1.6.2')
+    compile('com.tencent.tinker:tinker-android-anno:1.7.0')
     //tinker's main Android lib
-    compile('com.tencent.tinker:tinker-android-lib:1.6.2') 
+    compile('com.tencent.tinker:tinker-android-lib:1.7.0') 
 }
 ...
 ...
@@ -73,8 +74,8 @@ For more tinker configurations, learn more at the sample [app/build.gradle](http
 ## Known Issues
 There are some issues which Tinker can't dynamic update.
 
-1. Update AndroidManifest.xml, such as add Android Component.
-2. Do not support some Samsung models with os version android-19.
+1. Can't update AndroidManifest.xml, such as add Android Component.
+2. Do not support some Samsung models with os version android-21.
 3. Due to Google Play Developer Distribution Agreement, we can't dynamic update our apk.
 
 ## Support
diff --git a/gradle.properties b/gradle.properties
index e90a71f3..10b53050 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -16,5 +16,5 @@
 # This option should only be used with decoupled projects. More details, visit
 # http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
 # org.gradle.parallel=true
-VERSION_NAME_PREFIX=1.6.2
+VERSION_NAME_PREFIX=1.7.0
 VERSION_NAME_SUFFIX=
\ No newline at end of file
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java
index 936b50a6..03ba6974 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java
@@ -149,21 +149,20 @@ private static boolean extractDexDiffInternals(Context context, String dir, Stri
             if (ShareTinkerInternals.isVmArt()) {
                 File extractedFile = new File(dir + ShareConstants.DEX_SMALLPATCH_INFO_FILE);
                 ZipEntry smallPatchInfoEntry = patch.getEntry(ShareConstants.DEX_SMALLPATCH_INFO_FILE);
-                if (smallPatchInfoEntry == null) {
-                    TinkerLog.w(TAG, "small patch info is not exists, bad patch package?");
-                    manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, ShareConstants.DEX_SMALLPATCH_INFO_FILE, type, isUpgradePatch);
-                    return false;
-                }
-                InputStream smallPatchInfoIs = null;
-                try {
-                    smallPatchInfoIs = patch.getInputStream(smallPatchInfoEntry);
-                    smallPatchInfoFile = new SmallPatchedDexItemFile(smallPatchInfoIs);
-                } catch (Throwable e) {
-                    TinkerLog.w(TAG, "failed to read small patched info. reason: " + e.getMessage());
-                    manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, ShareConstants.DEX_SMALLPATCH_INFO_FILE, type, isUpgradePatch);
-                    return false;
-                } finally {
-                    SharePatchFileUtil.closeQuietly(smallPatchInfoIs);
+                if (smallPatchInfoEntry != null) {
+                    InputStream smallPatchInfoIs = null;
+                    try {
+                        smallPatchInfoIs = patch.getInputStream(smallPatchInfoEntry);
+                        smallPatchInfoFile = new SmallPatchedDexItemFile(smallPatchInfoIs);
+                    } catch (Throwable e) {
+                        TinkerLog.w(TAG, "failed to read small patched info. reason: " + e.getMessage());
+                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, ShareConstants.DEX_SMALLPATCH_INFO_FILE, type, isUpgradePatch);
+                        return false;
+                    } finally {
+                        SharePatchFileUtil.closeQuietly(smallPatchInfoIs);
+                    }
+                } else {
+                    TinkerLog.w(TAG, "small patch info is not exists, it's ok now.");
                 }
             }
 
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/RepairPatch.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/RepairPatch.java
index f9910f82..48a7395b 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/RepairPatch.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/RepairPatch.java
@@ -59,7 +59,7 @@ public boolean tryPatch(Context context, String tempPatchPath, PatchResult patch
         ShareSecurityCheck signatureCheck = new ShareSecurityCheck(context);
 
 
-        int returnCode = ShareTinkerInternals.checkSignatureAndTinkerID(context, patchFile, signatureCheck);
+        int returnCode = ShareTinkerInternals.checkTinkerPackage(context, manager.getTinkerFlags(), patchFile, signatureCheck);
         if (returnCode != ShareConstants.ERROR_PACKAGE_CHECK_OK) {
             TinkerLog.e(TAG, "RepairPatch tryPatch:onPatchPackageCheckFail");
             manager.getPatchReporter().onPatchPackageCheckFail(patchFile, false, returnCode);
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/UpgradePatch.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/UpgradePatch.java
index 3a91e09f..bdbcd9ba 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/UpgradePatch.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/UpgradePatch.java
@@ -56,7 +56,7 @@ public boolean tryPatch(Context context, String tempPatchPath, PatchResult patch
         //check the signature, we should create a new checker
         ShareSecurityCheck signatureCheck = new ShareSecurityCheck(context);
 
-        int returnCode = ShareTinkerInternals.checkSignatureAndTinkerID(context, patchFile, signatureCheck);
+        int returnCode = ShareTinkerInternals.checkTinkerPackage(context, manager.getTinkerFlags(), patchFile, signatureCheck);
         if (returnCode != ShareConstants.ERROR_PACKAGE_CHECK_OK) {
             TinkerLog.e(TAG, "UpgradePatch tryPatch:onPatchPackageCheckFail");
             manager.getPatchReporter().onPatchPackageCheckFail(patchFile, true, returnCode);
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultLoadReporter.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultLoadReporter.java
index f955477d..75b3a76c 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultLoadReporter.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultLoadReporter.java
@@ -216,7 +216,13 @@ public void onLoadException(Throwable e, int errorCode) {
                 TinkerLog.i(TAG, "dex exception disable tinker forever with sp");
                 break;
             case ShareConstants.ERROR_LOAD_EXCEPTION_RESOURCE:
-                TinkerLog.i(TAG, "patch load resource exception: %s", e);
+                if (e.getMessage().contains(ShareConstants.CHECK_RES_INSTALL_FAIL)) {
+                    TinkerLog.e(TAG, "tinker res check fail:" + e.getMessage());
+                } else {
+                    TinkerLog.i(TAG, "patch load resource exception: %s", e);
+                }
+                ShareTinkerInternals.setTinkerDisableWithSharedPreferences(context);
+                TinkerLog.i(TAG, "res exception disable tinker forever with sp");
                 break;
             case ShareConstants.ERROR_LOAD_EXCEPTION_UNCAUGHT:
                 TinkerLog.i(TAG, "patch load unCatch exception: %s", e);
@@ -225,6 +231,7 @@ public void onLoadException(Throwable e, int errorCode) {
                 break;
             case ShareConstants.ERROR_LOAD_EXCEPTION_UNKNOWN:
                 TinkerLog.i(TAG, "patch load unknown exception: %s", e);
+                //exception can be caught, it is no need to disable Tinker with sharedPreference
                 break;
         }
         TinkerLog.printErrStackTrace(TAG, e, "tinker load exception");
@@ -246,6 +253,7 @@ public void onLoadException(Throwable e, int errorCode) {
      *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_PATCH_TINKER_ID_NOT_FOUND}       can't find TINKER_PATCH in patch meta file
      *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_TINKER_ID_NOT_EQUAL}             apk and patch's TINKER_PATCH value is not equal
      *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_RESOURCE_META_CORRUPTED}         resource meta file's format check fail
+     *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT}          some patch file type is not supported for current tinkerFlag
      */
     @Override
     public void onLoadPackageCheckFail(File patchFile, int errorCode) {
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultPatchReporter.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultPatchReporter.java
index c1717c41..88a9a406 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultPatchReporter.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultPatchReporter.java
@@ -69,6 +69,7 @@ public void onPatchServiceStart(Intent intent) {
      *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_PATCH_TINKER_ID_NOT_FOUND}       can't find TINKER_PATCH in patch meta file
      *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_TINKER_ID_NOT_EQUAL}             apk and patch's TINKER_PATCH value is not equal
      *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_RESOURCE_META_CORRUPTED}         resource meta file's format check fail
+     *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT}          some patch file type is not supported for current tinkerFlag
      */
     @Override
     public void onPatchPackageCheckFail(File patchFile, boolean isUpgradePatch, int errorCode) {
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/LoadReporter.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/LoadReporter.java
index 67f4c7aa..5ca258a9 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/LoadReporter.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/LoadReporter.java
@@ -134,6 +134,7 @@
      *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_PATCH_TINKER_ID_NOT_FOUND}       can't find TINKER_PATCH in patch meta file
      *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_TINKER_ID_NOT_EQUAL}             apk and patch's TINKER_PATCH value is not equal
      *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_RESOURCE_META_CORRUPTED}         resource meta file's format check fail
+     *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT}          some patch file type is not supported for current tinkerFlag
      */
     void onLoadPackageCheckFail(File patchFile, int errorCode);
 
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/PatchReporter.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/PatchReporter.java
index dbc5860c..e9ac07d2 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/PatchReporter.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/PatchReporter.java
@@ -59,6 +59,7 @@
      *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_PATCH_TINKER_ID_NOT_FOUND}       can't find TINKER_PATCH in patch meta file
      *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_TINKER_ID_NOT_EQUAL}             apk and patch's TINKER_PATCH value is not equal
      *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_RESOURCE_META_CORRUPTED}         resource meta file's format check fail
+     *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT}          some patch file type is not supported for current tinkerFlag
      */
     void onPatchPackageCheckFail(File patchFile, boolean isUpgradePatch, int errorCode);
 
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/Tinker.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/Tinker.java
index 4d5be29c..8e46e2e7 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/Tinker.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/Tinker.java
@@ -46,23 +46,25 @@
 public class Tinker {
     private static final String TAG = "Tinker.Tinker";
 
-    private static Tinker        sInstance;
-    private static boolean installed = false;
-    final          Context       context;
+    private static Tinker sInstance;
+    private static boolean sInstalled = false;
+
+    final Context       context;
     /**
      * data dir, such as /data/data/tinker.sample.android/tinker
      */
-    final          File          patchDirectory;
-    final          PatchListener listener;
-    final          LoadReporter  loadReporter;
-    final          PatchReporter patchReporter;
-    final          File          patchInfoFile;
-    final          boolean       isMainProcess;
-    final          boolean       isPatchProcess;
+    final File          patchDirectory;
+    final PatchListener listener;
+    final LoadReporter  loadReporter;
+    final PatchReporter patchReporter;
+    final File          patchInfoFile;
+    final boolean       isMainProcess;
+    final boolean       isPatchProcess;
     /**
      * same with {@code TinkerApplication.tinkerLoadVerifyFlag}
      */
-    final boolean tinkerLoadVerifyFlag;
+    final boolean       tinkerLoadVerifyFlag;
+
     /**
      * same with {@code TinkerApplication.tinkerFlags}
      */
@@ -71,7 +73,7 @@
     /**
      * whether load patch success
      */
-    private        boolean loaded    = false;
+    private boolean loaded = false;
 
     private Tinker(Context context, int tinkerFlags, LoadReporter loadReporter, PatchReporter patchReporter,
                    PatchListener listener, File patchDirectory, File patchInfoFile,
@@ -96,7 +98,7 @@ private Tinker(Context context, int tinkerFlags, LoadReporter loadReporter, Patc
      * @return the Tinker object
      */
     public static Tinker with(Context context) {
-        if (!installed) {
+        if (!sInstalled) {
             throw new TinkerRuntimeException("you must install tinker before get tinker sInstance");
         }
         if (sInstance == null) {
@@ -133,7 +135,7 @@ public static void create(Tinker tinker) {
     public void install(Intent intentResult, Class<? extends AbstractResultService> serviceClass,
                         AbstractPatch upgradePatch, AbstractPatch repairPatch
     ) {
-        installed = true;
+        sInstalled = true;
         AbstractResultService.setResultServiceClass(serviceClass);
         TinkerPatchService.setPatchProcessor(upgradePatch, repairPatch);
 
@@ -156,6 +158,7 @@ public void install(Intent intentResult, Class<? extends AbstractResultService>
 
     /**
      * set tinkerPatchServiceNotificationId
+     *
      * @param id
      */
     public void setPatchServiceNotificationId(int id) {
@@ -212,7 +215,7 @@ public void setTinkerLoaded(boolean isLoaded) {
     }
 
     public boolean isTinkerInstalled() {
-        return installed;
+        return sInstalled;
     }
 
     public boolean isTinkerLoadVerify() {
@@ -243,6 +246,11 @@ public PatchListener getPatchListener() {
         return listener;
     }
 
+
+    public int getTinkerFlags() {
+        return tinkerFlags;
+    }
+
     /**
      * clean all patch files
      */
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AndroidNClassLoader.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AndroidNClassLoader.java
index 795eea17..7fc6a66b 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AndroidNClassLoader.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AndroidNClassLoader.java
@@ -21,8 +21,16 @@
 import android.content.Context;
 import android.os.Build;
 
+import com.tencent.tinker.loader.shareutil.ShareReflectUtil;
+
+import java.io.File;
+import java.io.IOException;
 import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.List;
 
+import dalvik.system.DexFile;
 import dalvik.system.PathClassLoader;
 
 /**
@@ -30,6 +38,7 @@
  */
 @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
 class AndroidNClassLoader extends PathClassLoader {
+    static ArrayList<DexFile> oldDexFiles = new ArrayList<>();
     PathClassLoader originClassLoader;
 
     private AndroidNClassLoader(String dexPath, PathClassLoader parent) {
@@ -40,33 +49,32 @@ private AndroidNClassLoader(String dexPath, PathClassLoader parent) {
     private static AndroidNClassLoader createAndroidNClassLoader(PathClassLoader original) throws Exception {
         //let all element ""
         AndroidNClassLoader androidNClassLoader = new AndroidNClassLoader("",  original);
-        Field originPathList = findField(original, "pathList");
+        Field originPathList = ShareReflectUtil.findField(original, "pathList");
         Object originPathListObject = originPathList.get(original);
         //should reflect definingContext also
-        Field originClassloader = findField(originPathListObject, "definingContext");
+        Field originClassloader = ShareReflectUtil.findField(originPathListObject, "definingContext");
         originClassloader.set(originPathListObject, androidNClassLoader);
         //copy pathList
-        Field pathListField = findField(androidNClassLoader, "pathList");
+        Field pathListField = ShareReflectUtil.findField(androidNClassLoader, "pathList");
         //just use PathClassloader's pathList
         pathListField.set(androidNClassLoader, originPathListObject);
-        return androidNClassLoader;
-    }
 
-    private static Field findField(Object instance, String name) throws NoSuchFieldException {
-        for (Class<?> clazz = instance.getClass(); clazz != null; clazz = clazz.getSuperclass()) {
-            try {
-                Field field = clazz.getDeclaredField(name);
-
-                if (!field.isAccessible()) {
-                    field.setAccessible(true);
-                }
-
-                return field;
-            } catch (NoSuchFieldException e) {
-                // ignore and search next
-            }
+        //we must recreate dexFile due to dexCache
+        List<File> additionalClassPathEntries = new ArrayList<>();
+        Field dexElement = ShareReflectUtil.findField(originPathListObject, "dexElements");
+        Object[] originDexElements = (Object[]) dexElement.get(originPathListObject);
+        for (Object element : originDexElements) {
+            DexFile dexFile = (DexFile) ShareReflectUtil.findField(element, "dexFile").get(element);
+            additionalClassPathEntries.add(new File(dexFile.getName()));
+            //protect for java.lang.AssertionError: Failed to close dex file in finalizer.
+            oldDexFiles.add(dexFile);
         }
-        throw new NoSuchFieldException("Field " + name + " not found in " + instance.getClass());
+        Method makePathElements = ShareReflectUtil.findMethod(originPathListObject, "makePathElements", List.class, File.class,
+            List.class);
+        ArrayList<IOException> suppressedExceptions = new ArrayList<>();
+        Object[] newDexElements = (Object[]) makePathElements.invoke(originPathListObject, additionalClassPathEntries, null, suppressedExceptions);
+        dexElement.set(originPathListObject, newDexElements);
+        return androidNClassLoader;
     }
 
     private static void reflectPackageInfoClassloader(Application application, ClassLoader reflectClassLoader) throws Exception {
@@ -74,9 +82,9 @@ private static void reflectPackageInfoClassloader(Application application, Class
         String defPackageInfo = "mPackageInfo";
         String defClassLoader = "mClassLoader";
 
-        Context baseContext = (Context) findField(application, defBase).get(application);
-        Object basePackageInfo = findField(baseContext, defPackageInfo).get(baseContext);
-        Field classLoaderField = findField(basePackageInfo, defClassLoader);
+        Context baseContext = (Context) ShareReflectUtil.findField(application, defBase).get(application);
+        Object basePackageInfo = ShareReflectUtil.findField(baseContext, defPackageInfo).get(baseContext);
+        Field classLoaderField = ShareReflectUtil.findField(basePackageInfo, defClassLoader);
         Thread.currentThread().setContextClassLoader(reflectClassLoader);
         classLoaderField.set(basePackageInfo, reflectClassLoader);
     }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/SystemClassLoaderAdder.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/SystemClassLoaderAdder.java
index 88b67135..5c20b80f 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/SystemClassLoaderAdder.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/SystemClassLoaderAdder.java
@@ -48,6 +48,7 @@
     private static final String CHECK_DEX_CLASS = "com.tencent.tinker.loader.TinkerTestDexLoad";
     private static final String CHECK_DEX_FIELD = "isPatch";
 
+    private static int sPatchDexCount = 0;
 
     @SuppressLint("NewApi")
     public static void installDexes(Application application, PathClassLoader loader, File dexOptDir, List<File> files)
@@ -70,14 +71,34 @@ public static void installDexes(Application application, PathClassLoader loader,
                 V4.install(classLoader, files, dexOptDir);
             }
 
-            if (!checkDexInstall()) {
+            if (!checkDexInstall(classLoader)) {
                 throw new TinkerRuntimeException(ShareConstants.CHECK_DEX_INSTALL_FAIL);
             }
+            sPatchDexCount = files.size();
         }
     }
 
-    private static boolean checkDexInstall() throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException {
-        Class<?> clazz = Class.forName(CHECK_DEX_CLASS);
+    public static void uninstallPatchDex(ClassLoader classLoader) throws Throwable {
+        if (sPatchDexCount <= 0) {
+            return;
+        }
+        if (Build.VERSION.SDK_INT >= 14) {
+            Field pathListField = ShareReflectUtil.findField(classLoader, "pathList");
+            Object dexPathList = pathListField.get(classLoader);
+            ShareReflectUtil.reduceFieldArray(dexPathList, "dexElements", sPatchDexCount);
+        } else {
+            ShareReflectUtil.reduceFieldArray(classLoader, "mPaths", sPatchDexCount);
+            ShareReflectUtil.reduceFieldArray(classLoader, "mFiles", sPatchDexCount);
+            ShareReflectUtil.reduceFieldArray(classLoader, "mZips", sPatchDexCount);
+            try {
+                ShareReflectUtil.reduceFieldArray(classLoader, "mDexs", sPatchDexCount);
+            } catch (Exception e) {
+            }
+        }
+    }
+
+    private static boolean checkDexInstall(ClassLoader classLoader) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException {
+        Class<?> clazz = Class.forName(CHECK_DEX_CLASS, true, classLoader);
         Field filed = ShareReflectUtil.findField(clazz, CHECK_DEX_FIELD);
         boolean isPatch = (boolean) filed.get(null);
         Log.w(TAG, "checkDexInstall result:" + isPatch);
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerLoader.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerLoader.java
index 7b1853f3..adfb88f7 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerLoader.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerLoader.java
@@ -152,9 +152,9 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, bo
 
         ShareSecurityCheck securityCheck = new ShareSecurityCheck(app);
 
-        int returnCode = ShareTinkerInternals.checkSignatureAndTinkerID(app, patchVersionFile, securityCheck);
-        if (returnCode != 0) {
-            Log.w(TAG, "tryLoadPatchFiles:checkSignatureAndTinkerID");
+        int returnCode = ShareTinkerInternals.checkTinkerPackage(app, tinkerFlag, patchVersionFile, securityCheck);
+        if (returnCode != ShareConstants.ERROR_PACKAGE_CHECK_OK) {
+            Log.w(TAG, "tryLoadPatchFiles:checkTinkerPackage");
             resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_PACKAGE_PATCH_CHECK, returnCode);
             ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_PACKAGE_CHECK_FAIL);
             return;
@@ -224,7 +224,7 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, bo
 
         //now we can load patch resource
         if (isEnabledForResource) {
-            boolean loadTinkerResources = TinkerResourceLoader.loadTinkerResources(tinkerLoadVerifyFlag, patchVersionDirectory, resultIntent);
+            boolean loadTinkerResources = TinkerResourceLoader.loadTinkerResources(app, tinkerLoadVerifyFlag, patchVersionDirectory, resultIntent);
             if (!loadTinkerResources) {
                 Log.w(TAG, "tryLoadPatchFiles:onPatchLoadResourcesFail");
                 return;
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourceLoader.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourceLoader.java
index 20ada863..b46d5940 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourceLoader.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourceLoader.java
@@ -32,21 +32,19 @@
  * Created by liangwenxiang on 2016/4/14.
  */
 public class TinkerResourceLoader {
-
     protected static final String RESOURCE_META_FILE = ShareConstants.RES_META_FILE;
     protected static final String RESOURCE_FILE      = ShareConstants.RES_NAME;
     protected static final String RESOURCE_PATH      = ShareConstants.RES_PATH;
     private static final String TAG = "Tinker.ResourceLoader";
     private static ShareResPatchInfo resPatchInfo = new ShareResPatchInfo();
 
-
     private TinkerResourceLoader() {
     }
 
     /**
      * Load tinker resources
      */
-    public static boolean loadTinkerResources(boolean tinkerLoadVerifyFlag, String directory, Intent intentResult) {
+    public static boolean loadTinkerResources(Context context, boolean tinkerLoadVerifyFlag, String directory, Intent intentResult) {
         if (resPatchInfo == null || resPatchInfo.resArscMd5 == null) {
             return true;
         }
@@ -63,14 +61,21 @@ public static boolean loadTinkerResources(boolean tinkerLoadVerifyFlag, String d
             Log.i(TAG, "verify resource file:" + resourceFile.getPath() + " md5, use time: " + (System.currentTimeMillis() - start));
         }
         try {
-            TinkerResourcePatcher.monkeyPatchExistingResources(resourceString);
+            TinkerResourcePatcher.monkeyPatchExistingResources(context, resourceString);
             Log.i(TAG, "monkeyPatchExistingResources resource file:" + resourceString + ", use time: " + (System.currentTimeMillis() - start));
         } catch (Throwable e) {
-            Log.e(TAG, "install resources failed", e);
+            Log.e(TAG, "install resources failed");
+            //remove patch dex if resource is installed failed
+            try {
+                SystemClassLoaderAdder.uninstallPatchDex(context.getClassLoader());
+            } catch (Throwable throwable) {
+                Log.e(TAG, "uninstallPatchDex failed", e);
+            }
             intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_EXCEPTION, e);
             ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_RESOURCE_LOAD_EXCEPTION);
             return false;
         }
+
         return true;
     }
 
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java
index 81aaa4e0..c21c327e 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java
@@ -20,6 +20,9 @@
 import android.content.res.AssetManager;
 import android.content.res.Resources;
 import android.util.ArrayMap;
+import android.util.Log;
+
+import com.tencent.tinker.loader.shareutil.ShareConstants;
 
 import java.lang.ref.WeakReference;
 import java.lang.reflect.Field;
@@ -31,9 +34,11 @@
 import static android.os.Build.VERSION_CODES.KITKAT;
 
 class TinkerResourcePatcher {
+    private static final String TAG = "Tinker.ResourcePatcher";
+    private static final String TEST_STRING_NAME  = "tinker_test_resource";
+    private static final String TEST_STRING_VALUE = "only use for test tinker resource: b";
     // original value
     private static Collection<WeakReference<Resources>> references;
-
     private static AssetManager newAssetManager          = null;
     private static Method       addAssetPathMethod       = null;
     private static Method       ensureStringBlocksMethod = null;
@@ -128,7 +133,7 @@ public static void isResourceCanPatch(Context context) throws Throwable {
         }
     }
 
-    public static void monkeyPatchExistingResources(String externalResourceFile) throws Throwable {
+    public static void monkeyPatchExistingResources(Context context, String externalResourceFile) throws Throwable {
         if (externalResourceFile == null) {
             return;
         }
@@ -162,8 +167,26 @@ public static void monkeyPatchExistingResources(String externalResourceFile) thr
                 resources.updateConfiguration(resources.getConfiguration(), resources.getDisplayMetrics());
             }
         }
+
+        if (!checkResUpdate(context)) {
+            throw new TinkerRuntimeException(ShareConstants.CHECK_RES_INSTALL_FAIL);
+        }
     }
 
+    private static boolean checkResUpdate(Context context) {
+        int testStringID = context.getResources().getIdentifier(TEST_STRING_NAME, "string", context.getPackageName());
+        if (testStringID > 0) {
+            String value = context.getString(testStringID);
+            Log.w(TAG, "checkResUpdate resource value:" + value);
+
+            if (!value.equals(TEST_STRING_VALUE)) {
+                return false;
+            }
+        } else  {
+            Log.e(TAG, "checkResUpdate resource id < 0 " + testStringID);
+        }
+        return true;
+    }
     private static Object getActivityThread(Context context,
                                             Class<?> activityThread) {
         try {
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareConstants.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareConstants.java
index b7f1f9f5..e3db652f 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareConstants.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareConstants.java
@@ -47,7 +47,9 @@
     public static final String DEX_OPTIMIZE_PATH        = "odex";
     public static final String DEX_SUFFIX               = ".dex";
     public static final String JAR_SUFFIX               = ".jar";
+
     public static final String CHECK_DEX_INSTALL_FAIL = "checkDexInstall failed";
+    public static final String CHECK_RES_INSTALL_FAIL = "checkResInstall failed";
 
     public static final String RES_META_FILE       = "assets/res_meta.txt";
     public static final String RES_ARSC            = "resources.arsc";
@@ -166,5 +168,5 @@
     public static final int ERROR_PACKAGE_CHECK_PATCH_TINKER_ID_NOT_FOUND = -6;
     public static final int ERROR_PACKAGE_CHECK_TINKER_ID_NOT_EQUAL       = -7;
     public static final int ERROR_PACKAGE_CHECK_RESOURCE_META_CORRUPTED   = -8;
-
+    public static final int ERROR_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT    = -9;
 }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareReflectUtil.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareReflectUtil.java
index 28f0295a..f27a5e0b 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareReflectUtil.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareReflectUtil.java
@@ -125,4 +125,33 @@ public static void expandFieldArray(Object instance, String fieldName, Object[]
         jlrField.set(instance, combined);
     }
 
+    /**
+     * Replace the value of a field containing a non null array, by a new array containing the
+     * elements of the original array plus the elements of extraElements.
+     *
+     * @param instance      the instance whose field is to be modified.
+     * @param fieldName     the field to modify.
+     */
+    public static void reduceFieldArray(Object instance, String fieldName, int reduceSize)
+        throws NoSuchFieldException, IllegalArgumentException, IllegalAccessException {
+        if (reduceSize <= 0) {
+            return;
+        }
+
+        Field jlrField = findField(instance, fieldName);
+
+        Object[] original = (Object[]) jlrField.get(instance);
+        int finalLength = original.length - reduceSize;
+
+        if (finalLength <= 0) {
+            return;
+        }
+
+        Object[] combined = (Object[]) Array.newInstance(original.getClass().getComponentType(), finalLength);
+
+        System.arraycopy(original, reduceSize, combined, 0, finalLength);
+
+        jlrField.set(instance, combined);
+    }
+
 }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java
index 3bbfec48..aba789cc 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java
@@ -57,6 +57,21 @@ public static boolean isNullOrNil(final String object) {
         return false;
     }
 
+    /**
+     * thinker package check
+     * @param context
+     * @param tinkerFlag
+     * @param patchFile
+     * @param securityCheck
+     * @return
+     */
+    public static int checkTinkerPackage(Context context, int tinkerFlag, File patchFile, ShareSecurityCheck securityCheck) {
+        int returnCode = checkSignatureAndTinkerID(context, patchFile, securityCheck);
+        if (returnCode == ShareConstants.ERROR_PACKAGE_CHECK_OK) {
+            returnCode = checkPackageAndTinkerFlag(securityCheck, tinkerFlag);
+        }
+        return returnCode;
+    }
     /**
      * check patch file signature and TINKER_ID
      *
@@ -93,6 +108,25 @@ public static int checkSignatureAndTinkerID(Context context, File patchFile, Sha
 
 
     public static int checkPackageAndTinkerFlag(ShareSecurityCheck securityCheck, int tinkerFlag) {
+        if (isTinkerEnabledAll(tinkerFlag)) {
+            return ShareConstants.ERROR_PACKAGE_CHECK_OK;
+        }
+        HashMap<String, String> metaContentMap = securityCheck.getMetaContentMap();
+        //check dex
+        boolean dexEnable = isTinkerEnabledForDex(tinkerFlag);
+        if (!dexEnable && metaContentMap.containsKey(ShareConstants.DEX_META_FILE)) {
+            return ShareConstants.ERROR_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT;
+        }
+        //check native library
+        boolean nativeEnable = isTinkerEnabledForNativeLib(tinkerFlag);
+        if (!nativeEnable && metaContentMap.containsKey(ShareConstants.SO_META_FILE)) {
+            return ShareConstants.ERROR_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT;
+        }
+        //check resource
+        boolean resEnable = isTinkerEnabledForResource(tinkerFlag);
+        if (!resEnable && metaContentMap.containsKey(ShareConstants.RES_META_FILE)) {
+            return ShareConstants.ERROR_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT;
+        }
 
         return ShareConstants.ERROR_PACKAGE_CHECK_OK;
     }
diff --git a/tinker-android/tinker-android-loader/src/main/res/values/strings.xml b/tinker-android/tinker-android-loader/src/main/res/values/strings.xml
new file mode 100644
index 00000000..4c563702
--- /dev/null
+++ b/tinker-android/tinker-android-loader/src/main/res/values/strings.xml
@@ -0,0 +1,3 @@
+<resources>
+    <string name="tinker_test_resource">only use for test tinker resource: a</string>
+</resources>
diff --git a/tinker-build/tinker-patch-cli/src/main/java/com/tencent/tinker/patch/CliMain.java b/tinker-build/tinker-patch-cli/src/main/java/com/tencent/tinker/patch/CliMain.java
index 37dbf0b1..8df97a5e 100644
--- a/tinker-build/tinker-patch-cli/src/main/java/com/tencent/tinker/patch/CliMain.java
+++ b/tinker-build/tinker-patch-cli/src/main/java/com/tencent/tinker/patch/CliMain.java
@@ -92,6 +92,9 @@ private void run(String[] args) {
             if (oldApkFile == null || newApkFile == null) {
                 Logger.e("Missing old apk or new apk file argument");
                 goToError();
+            } else if (!oldApkFile.exists() || !newApkFile.exists()) {
+                Logger.e("Old apk or new apk file does not exist");
+                goToError();
             }
 
             if (outputFile == null) {
diff --git a/tinker-build/tinker-patch-gradle-plugin/build.gradle b/tinker-build/tinker-patch-gradle-plugin/build.gradle
index d07a0497..c027fdaa 100644
--- a/tinker-build/tinker-patch-gradle-plugin/build.gradle
+++ b/tinker-build/tinker-patch-gradle-plugin/build.gradle
@@ -10,6 +10,7 @@ dependencies {
 //    compile fileTree(dir: 'libs', include: ['*.jar'])
     compile project(':tinker-build:tinker-patch-lib')
     compile 'com.google.gradle:osdetector-gradle-plugin:1.2.1'
+    compile 'com.android.tools.build:gradle-api:2.2.0'
 }
 
 repositories {
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/TinkerPatchPlugin.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/TinkerPatchPlugin.groovy
index 463e2993..7df0a589 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/TinkerPatchPlugin.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/TinkerPatchPlugin.groovy
@@ -16,24 +16,14 @@
 
 package com.tencent.tinker.build.gradle
 
-import com.tencent.tinker.build.gradle.extension.TinkerBuildConfigExtension
-import com.tencent.tinker.build.gradle.extension.TinkerDexExtension
-import com.tencent.tinker.build.gradle.extension.TinkerLibExtension
-import com.tencent.tinker.build.gradle.extension.TinkerPackageConfigExtension
-import com.tencent.tinker.build.gradle.extension.TinkerPatchExtension
-import com.tencent.tinker.build.gradle.extension.TinkerResourceExtension
-import com.tencent.tinker.build.gradle.extension.TinkerSevenZipExtension
-import com.tencent.tinker.build.gradle.task.TinkerManifestTask
-import com.tencent.tinker.build.gradle.task.TinkerMultidexConfigTask
-import com.tencent.tinker.build.gradle.task.TinkerPatchSchemaTask
-import com.tencent.tinker.build.gradle.task.TinkerProguardConfigTask
-import com.tencent.tinker.build.gradle.task.TinkerResourceIdTask
+import com.tencent.tinker.build.gradle.extension.*
+import com.tencent.tinker.build.gradle.task.*
+import com.tencent.tinker.build.gradle.transform.AuxiliaryInjectTransform
 import com.tencent.tinker.build.util.FileOperation
 import com.tencent.tinker.build.util.TypedValue
 import org.gradle.api.GradleException
 import org.gradle.api.Plugin
 import org.gradle.api.Project
-
 /**
  * Registers the plugin's tasks.
  *
@@ -59,6 +49,8 @@ class TinkerPatchPlugin implements Plugin<Project> {
 
         def configuration = project.tinkerPatch
 
+        project.android.registerTransform(new AuxiliaryInjectTransform(project))
+
         project.afterEvaluate {
             if (!project.plugins.hasPlugin('com.android.application')) {
                 throw new GradleException('generateTinkerApk: Android Application plugin required')
@@ -108,7 +100,7 @@ class TinkerPatchPlugin implements Plugin<Project> {
                 TinkerPatchSchemaTask tinkerPatchBuildTask = project.tasks.create("tinkerPatch${variantName}", TinkerPatchSchemaTask)
                 tinkerPatchBuildTask.dependsOn variant.assemble
 
-                tinkerPatchBuildTask.signconfig = variant.apkVariantData.variantConfiguration.signingConfig
+                tinkerPatchBuildTask.signConfig = variant.apkVariantData.variantConfiguration.signingConfig
 
                 variant.outputs.each { output ->
                     tinkerPatchBuildTask.buildApkPath = output.outputFile
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerDexExtension.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerDexExtension.groovy
index 2add6dc0..0bab55fe 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerDexExtension.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerDexExtension.groovy
@@ -31,6 +31,19 @@ public class TinkerDexExtension {
      * default: raw, keep the orginal file type
      */
     String dexMode;
+
+    /**
+     * If mUsePreGeneratedPatchDex was enabled, tinker framework would generate
+     * a dex file including all added and changed classes instead of patch info file.
+     *
+     * You can make this mode enabled if you're using any dex encrypting solutions or
+     * maintaining patches that suitable for multi-channel base packages.
+     *
+     * Notice that although you use this mode, proguard mappings should still be applied
+     * to base package and all patched packages.
+     */
+    boolean usePreGeneratedPatchDex
+
     /**
      * the dex file patterns, which dex or jar files will be deal to gen patch
      * such as [classes.dex, classes-*.dex, assets/multiDex/*.jar]
@@ -48,6 +61,7 @@ public class TinkerDexExtension {
         dexMode = "jar"
         pattern = []
         loader = []
+        usePreGeneratedPatchDex = false
         this.project = project
     }
 
@@ -60,6 +74,7 @@ public class TinkerDexExtension {
     @Override
     public String toString() {
         """| dexMode = ${dexMode}
+           | usePreGeneratedPatchDex = ${usePreGeneratedPatchDex}
            | pattern = ${pattern}
            | loader = ${loader}
         """.stripMargin()
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerPackageConfigExtension.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerPackageConfigExtension.groovy
index fbf9221a..4ed81b94 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerPackageConfigExtension.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerPackageConfigExtension.groovy
@@ -16,7 +16,7 @@
 
 package com.tencent.tinker.build.gradle.extension
 
-import com.tencent.tinker.build.apkparser.AndroidManifest
+import com.tencent.tinker.build.apkparser.AndroidParser
 import org.gradle.api.GradleException
 import org.gradle.api.Project
 
@@ -32,7 +32,7 @@ public class TinkerPackageConfigExtension {
      */
     private Map<String, String> fields
     private Project project;
-    private AndroidManifest androidManifest;
+    private AndroidParser androidManifest;
 
 
     public TinkerPackageConfigExtension(project) {
@@ -57,7 +57,7 @@ public class TinkerPackageConfigExtension {
                         String.format("old apk file %s is not exist, you can set the value directly!", oldPakFile)
                 )
             }
-            androidManifest = AndroidManifest.getAndroidManifest(oldPakFile);
+            androidManifest = AndroidParser.getAndroidManifest(oldPakFile);
         }
     }
 
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerPatchExtension.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerPatchExtension.groovy
index 81210332..17ec5b63 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerPatchExtension.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerPatchExtension.groovy
@@ -31,7 +31,7 @@ public class TinkerPatchExtension {
     String oldApk
 
     /**
-     * if there is loader class changes,
+     * If there is loader class changes,
      * or Activity, Service, Receiver, Provider change, it will terminal
      * if ignoreWarning is false
      * default: false
@@ -39,7 +39,7 @@ public class TinkerPatchExtension {
     boolean ignoreWarning
 
     /**
-     * if sign the patch file with the android signConfig
+     * If sign the patch file with the android signConfig
      * default: true
      */
     boolean useSign
@@ -53,9 +53,14 @@ public class TinkerPatchExtension {
     void checkParameter() {
         if (oldApk == null) {
             throw new GradleException("old apk is null, you must set the correct old apk value!")
-        } else if (!new File(oldApk).exists()) {
+        }
+        File apk = new File(oldApk)
+        if (!apk.exists()) {
             throw new GradleException("old apk ${oldApk} is not exist, you must set the correct old apk value!")
+        } else if (!apk.isFile()) {
+            throw new GradleException("old apk ${oldApk} is a directory, you must set the correct old apk value!")
         }
+
     }
 
     @Override
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerManifestTask.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerManifestTask.groovy
index 0b60c831..65e589d7 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerManifestTask.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerManifestTask.groovy
@@ -46,7 +46,8 @@ public class TinkerManifestTask extends DefaultTask {
         project.logger.error("tinker add ${tinkerValue} to your AndroidManifest.xml ${manifestPath}")
 
         def ns = new Namespace("http://schemas.android.com/apk/res/android", "android")
-        def xml = new XmlParser().parse(manifestPath)
+        manifestPath
+        def xml = new XmlParser().parse(new InputStreamReader(new FileInputStream(manifestPath), "utf-8"))
 
         def application = xml.application[0]
         if (application) {
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerMultidexConfigTask.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerMultidexConfigTask.groovy
index a7384fa7..c52447dd 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerMultidexConfigTask.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerMultidexConfigTask.groovy
@@ -16,6 +16,7 @@
 
 package com.tencent.tinker.build.gradle.task
 
+import com.tencent.tinker.build.auxiliaryclass.AuxiliaryClassInjector
 import com.tencent.tinker.build.gradle.TinkerPatchPlugin
 import org.gradle.api.DefaultTask
 import org.gradle.api.tasks.TaskAction
@@ -39,7 +40,7 @@ public class TinkerMultidexConfigTask extends DefaultTask {
                     "\n" +
                     "-keep public class * extends com.tencent.tinker.loader.app.TinkerApplication {\n" +
                     "    *;\n" +
-                    "}"
+                    "}\n"
 
 
     def applicationVariant
@@ -61,6 +62,17 @@ public class TinkerMultidexConfigTask extends DefaultTask {
 
         fr.write(MULTIDEX_CONFIG_SETTINGS)
         fr.write("\n")
+
+        // Write additional rules to keep auxiliary class in primary dex.
+        if (project.tinkerPatch.dex.usePreGeneratedPatchDex) {
+            final String additionalRules =
+                    "-keep class ${AuxiliaryClassInjector.AUXILIARY_CLASSNAME} {\n" +
+                            '    *;\n' +
+                            '}\n'
+            fr.write(additionalRules)
+            fr.write('\n')
+        }
+
         //unlike proguard, if loader endwith *, we must change to **
         fr.write("#your dex.loader patterns here\n")
         Iterable<String> loader = project.extensions.tinkerPatch.dex.loader
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerPatchSchemaTask.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerPatchSchemaTask.groovy
index 4b7cc559..8ae768d3 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerPatchSchemaTask.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerPatchSchemaTask.groovy
@@ -30,7 +30,7 @@ public class TinkerPatchSchemaTask extends DefaultTask {
     def android
     String buildApkPath
     String outputFolder
-    def signconfig
+    def signConfig
 
     public TinkerPatchSchemaTask() {
         description = 'Assemble Tinker Patch'
@@ -54,13 +54,13 @@ public class TinkerPatchSchemaTask extends DefaultTask {
 
         InputParam.Builder builder = new InputParam.Builder()
         if (configuration.useSign) {
-            if (signconfig == null) {
-                throw new GradleException("can't the get signconfig for ${taskName} build")
+            if (signConfig == null) {
+                throw new GradleException("can't the get signConfig for ${taskName} build")
             }
-            builder.setSignFile(signconfig.storeFile)
-                    .setKeypass(signconfig.keyPassword)
-                    .setStorealias(signconfig.keyAlias)
-                    .setStorepass(signconfig.storePassword)
+            builder.setSignFile(signConfig.storeFile)
+                    .setKeypass(signConfig.keyPassword)
+                    .setStorealias(signConfig.keyAlias)
+                    .setStorepass(signConfig.storePassword)
 
         }
 
@@ -68,6 +68,7 @@ public class TinkerPatchSchemaTask extends DefaultTask {
                .setNewApk(buildApkPath)
                .setOutBuilder(outputFolder)
                .setIgnoreWarning(configuration.ignoreWarning)
+               .setUsePreGeneratedPatchDex(configuration.dex.usePreGeneratedPatchDex)
                .setDexFilePattern(configuration.dex.pattern)
                .setDexLoaderPattern(configuration.dex.loader)
                .setDexMode(configuration.dex.dexMode)
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerProguardConfigTask.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerProguardConfigTask.groovy
index c0f9e0d0..4283b7b3 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerProguardConfigTask.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerProguardConfigTask.groovy
@@ -16,6 +16,7 @@
 
 package com.tencent.tinker.build.gradle.task
 
+import com.tencent.tinker.build.auxiliaryclass.AuxiliaryClassInjector
 import com.tencent.tinker.build.gradle.TinkerPatchPlugin
 import com.tencent.tinker.build.util.FileOperation
 import org.gradle.api.DefaultTask
@@ -86,6 +87,22 @@ public class TinkerProguardConfigTask extends DefaultTask {
         }
 
         fr.write(PROGUARD_CONFIG_SETTINGS)
+
+        // Write additional rules to keep auxiliary class, <init> and <clinit>
+        if (project.tinkerPatch.dex.usePreGeneratedPatchDex) {
+            def additionalKeptRules =
+                    "-dontwarn ${AuxiliaryClassInjector.AUXILIARY_CLASSNAME} \n" +
+                            '-keepclassmembers class * { \n' +
+                            '    <init>(...); \n' +
+                            '    static void <clinit>(...); \n' +
+                            '}\n' +
+                            "-keep class ${AuxiliaryClassInjector.AUXILIARY_CLASSNAME} {\n" +
+                            '    *;\n' +
+                            '}\n'
+            fr.write(additionalKeptRules)
+            fr.write('\n')
+        }
+
         fr.write("#your dex.loader patterns here\n")
         //they will removed when apply
         Iterable<String> loader = project.extensions.tinkerPatch.dex.loader
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerResourceIdTask.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerResourceIdTask.groovy
index 4e51c6a0..30a12c12 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerResourceIdTask.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerResourceIdTask.groovy
@@ -60,6 +60,7 @@ public class TinkerResourceIdTask extends DefaultTask {
             rTypeResourceMap = PatchUtil.readRTxt(resourceMappingFile);
         } else {
             project.logger.error("apply resource mapping file ${resourceMappingFile} is illegal, just ignore")
+            return
         }
         AaptResourceCollector aaptResourceCollector = AaptUtil.collectResource(resourceDirectoryList, rTypeResourceMap)
         PatchUtil.generatePublicResourceXml(aaptResourceCollector, idsXml, publicXml)
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/transform/AuxiliaryInjectTransform.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/transform/AuxiliaryInjectTransform.groovy
new file mode 100644
index 00000000..8507e4e1
--- /dev/null
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/transform/AuxiliaryInjectTransform.groovy
@@ -0,0 +1,441 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.build.gradle.transform
+
+import com.android.build.api.transform.*
+import com.google.common.collect.ImmutableSet
+import com.google.common.io.Files
+import com.tencent.tinker.build.auxiliaryclass.AuxiliaryClassGenerator
+import com.tencent.tinker.build.auxiliaryclass.AuxiliaryClassInjector
+import com.tencent.tinker.build.auxiliaryclass.AuxiliaryClassInjector.ProcessJarCallback
+import com.tencent.tinker.build.util.MD5
+import com.tencent.tinker.commons.ziputil.Streams
+import groovy.io.FileType
+import org.gradle.api.Project
+
+import java.lang.reflect.Constructor
+import java.util.zip.ZipEntry
+import java.util.zip.ZipInputStream
+import java.util.zip.ZipOutputStream
+
+/**
+ * Transform for calling AuxiliaryClassGenerator and AuxiliaryClassInjector.
+ *
+ * @author tangyinsheng
+ */
+public class AuxiliaryInjectTransform extends Transform {
+    private static final String TRANSFORM_NAME = 'AuxiliaryInject'
+
+    private final Project project
+    private final String auxiliaryClassPathName
+
+    private boolean isEnabled = false
+
+    def applicationVariants
+
+    /* ****** Variant related parameters start ****** */
+
+    boolean isInitialized = false
+    def manifestFile
+    def appClassName
+    def appClassPathName
+
+    /* ******  Variant related parameters end  ****** */
+
+    public AuxiliaryInjectTransform(Project project) {
+        this.project = project
+        this.auxiliaryClassPathName =
+                AuxiliaryClassInjector.AUXILIARY_CLASSNAME.replace('.', '/') + '.class'
+
+        project.afterEvaluate {
+            this.isEnabled = project.tinkerPatch.dex.usePreGeneratedPatchDex
+
+            this.applicationVariants = project.android.applicationVariants
+        }
+    }
+
+    @Override
+    String getName() {
+        return TRANSFORM_NAME
+    }
+
+    @Override
+    Set<QualifiedContent.ContentType> getInputTypes() {
+        return ImmutableSet.of(QualifiedContent.DefaultContentType.CLASSES)
+    }
+
+    @Override
+    Set<QualifiedContent.Scope> getScopes() {
+        return ImmutableSet.of(
+                QualifiedContent.Scope.PROJECT,
+                QualifiedContent.Scope.PROJECT_LOCAL_DEPS,
+                QualifiedContent.Scope.SUB_PROJECTS,
+                QualifiedContent.Scope.SUB_PROJECTS_LOCAL_DEPS,
+                QualifiedContent.Scope.EXTERNAL_LIBRARIES
+        )
+    }
+
+    @Override
+    boolean isIncremental() {
+        return true
+    }
+
+    private String getTaskNamePrefix(Transform transform) {
+        StringBuilder sb = new StringBuilder(100);
+        sb.append("transform");
+
+        Iterator<QualifiedContent.ContentType> iterator = transform.getInputTypes().iterator();
+        // there's always at least one
+        sb.append(iterator.next().name().toLowerCase(Locale.getDefault()).capitalize());
+        while (iterator.hasNext()) {
+            sb.append("And").append(
+                    iterator.next().name().toLowerCase(Locale.getDefault()).capitalize());
+        }
+
+        sb.append("With").append(transform.getName().capitalize()).append("For");
+
+        return sb.toString();
+    }
+
+    private String decapitalize(String src) {
+        char[] chars = src.toCharArray()
+        chars[0] += (char) 32
+        return new String(chars)
+    }
+
+    private void initVariantRelatedParamsIfNeeded(String variantName) {
+        if (this.isInitialized) {
+            return
+        }
+
+        // Get manifest file path.
+        this.applicationVariants.any { variant ->
+            if (variant.name.equals(variantName)) {
+                def variantOutput = variant.outputs.first()
+                this.manifestFile = variantOutput.processManifest.manifestOutputFile
+                return true  // break out.
+            }
+        }
+
+        // Get application classname from manifest file.
+        def parsedManifest = new XmlParser().parse(this.manifestFile)
+        def androidTag = new groovy.xml.Namespace(
+                "http://schemas.android.com/apk/res/android", 'android')
+        this.appClassName = parsedManifest.application[0].attribute(androidTag.name)
+        this.appClassPathName = this.appClassName.replace('.', '/') + '.class'
+
+        this.isInitialized = true
+    }
+
+    @Override
+    public void transform(TransformInvocation transformInvocation) throws TransformException, InterruptedException, IOException {
+        String variantName = decapitalize(transformInvocation.context.path.split(getTaskNamePrefix(this))[1])
+        initVariantRelatedParamsIfNeeded(variantName)
+
+        def dirInputs = new HashSet<>()
+        def jarInputs = new HashSet<>()
+
+        // Collecting inputs.
+        transformInvocation.inputs.each { input ->
+            input.directoryInputs.each { dirInput ->
+                dirInputs.add(dirInput)
+            }
+            input.jarInputs.each { jarInput ->
+                jarInputs.add(jarInput)
+            }
+        }
+
+        if (!this.isEnabled) {
+            printMsgLog("PreGeneratedPatchDex mode is disabled, skip transforming.")
+        }
+
+        // Auxiliary class may be exist if user create it manually in his project.
+        boolean isAuxiliaryClassExists = false
+
+        if (!dirInputs.isEmpty() || !jarInputs.isEmpty()) {
+            File dirOutput = transformInvocation.outputProvider.getContentLocation(
+                    "classes", getOutputTypes(), getScopes(), Format.DIRECTORY)
+            if (!dirOutput.exists()) {
+                dirOutput.mkdirs()
+            }
+
+            if (!dirInputs.isEmpty()) {
+                dirInputs.each { dirInput ->
+                    if (transformInvocation.incremental) {
+                        dirInput.changedFiles.each { entry ->
+                            File fileInput = entry.getKey()
+                            File fileOutput = new File(fileInput.getAbsolutePath().replace(
+                                    dirInput.file.getAbsolutePath(), dirOutput.getAbsolutePath()))
+                            if (!fileOutput.exists()) {
+                                fileOutput.getParentFile().mkdirs()
+                            }
+                            final String relativeInputClassPath =
+                                    dirInput.file.toPath().relativize(fileInput.toPath())
+                                            .toString().replace('\\', '/')
+
+                            Status fileStatus = entry.getValue()
+                            switch(fileStatus) {
+                                case Status.ADDED:
+                                case Status.CHANGED:
+                                    if (fileInput.isDirectory()) {
+                                        return // continue.
+                                    }
+
+                                    // If disabled, skip all classes.
+                                    if (!this.isEnabled) {
+                                        Files.copy(fileInput, fileOutput)
+                                    } else {
+                                        // Skip application class.
+                                        if (relativeInputClassPath.equals(this.appClassPathName)) {
+                                            printWarnLog('Skipping Application class: %s',
+                                                    relativeInputClassPath)
+                                            Files.copy(fileInput, fileOutput)
+                                        } else
+                                        // Skip and mark auxiliary class.
+                                        if (relativeInputClassPath.equals(this.auxiliaryClassPathName)) {
+                                            isAuxiliaryClassExists = true
+                                            Files.copy(fileInput, fileOutput)
+                                        } else {
+                                            printMsgLog('Processing %s file %s',
+                                                    fileStatus,
+                                                    relativeInputClassPath)
+                                            AuxiliaryClassInjector.processClass(fileInput, fileOutput)
+                                        }
+                                    }
+                                    break
+                                case Status.REMOVED:
+                                    // Print log if it's enabled only.
+                                    if (this.isEnabled) {
+                                        printMsgLog('Removing %s file %s from result.', fileStatus,
+                                                dirOutput.toPath().relativize(fileOutput.toPath()).toString())
+                                    }
+
+                                    if (fileOutput.exists()) {
+                                        if (fileOutput.isDirectory()) {
+                                            fileOutput.deleteDir()
+                                        } else {
+                                            fileOutput.delete()
+                                        }
+                                    }
+                                    break
+                            }
+                        }
+                    } else {
+                        if (dirOutput.exists()) {
+                            dirOutput.deleteDir()
+                        }
+
+                        dirInput.file.traverse(type: FileType.FILES, nameFilter: ~/.*\.class$/) { fileInput ->
+                            File fileOutput = new File(fileInput.getAbsolutePath().replace(dirInput.file.getAbsolutePath(), dirOutput.getAbsolutePath()))
+                            if (!fileOutput.exists()) {
+                                fileOutput.getParentFile().mkdirs()
+                            }
+                            final String relativeInputClassPath =
+                                    dirInput.file.toPath().relativize(fileInput.toPath())
+                                            .toString().replace('\\', '/')
+
+                            // If disabled, skip all classes.
+                            if (!this.isEnabled) {
+                                Files.copy(fileInput, fileOutput)
+                            } else {
+                                // Skip application class.
+                                if (relativeInputClassPath.equals(this.appClassPathName)) {
+                                    printWarnLog('Skipping Application class: %s',
+                                            relativeInputClassPath)
+                                    Files.copy(fileInput, fileOutput)
+                                } else
+                                // Skip and mark auxiliary class.
+                                if (relativeInputClassPath.equals(this.auxiliaryClassPathName)) {
+                                    isAuxiliaryClassExists = true
+                                    Files.copy(fileInput, fileOutput)
+                                } else {
+                                    printMsgLog('Processing %s file %s',
+                                            Status.ADDED,
+                                            relativeInputClassPath)
+                                    AuxiliaryClassInjector.processClass(fileInput, fileOutput)
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+
+            if (!jarInputs.isEmpty()) {
+                File jarOutput = transformInvocation.outputProvider.getContentLocation(
+                        "combined", getOutputTypes(), getScopes(), Format.JAR
+                )
+                if (!jarOutput.exists()) {
+                    jarOutput.getParentFile().mkdirs()
+                }
+
+                File tempJarOutputDir = new File(transformInvocation.context.temporaryDir, "combined-jars")
+                if (!tempJarOutputDir.exists()) {
+                    tempJarOutputDir.mkdirs()
+                }
+
+                List<File> jarsToMerge = new ArrayList<>()
+
+                jarInputs.each { jarInput ->
+                    File fileInput = jarInput.file
+                    File fileOutput = new File(tempJarOutputDir,
+                            getUniqueHashName(fileInput))
+                    if (!fileOutput.exists()) {
+                        fileOutput.getParentFile().mkdirs()
+                    }
+
+                    switch (jarInput.status) {
+                        case Status.NOTCHANGED:
+                            if (transformInvocation.incremental) {
+                                break
+                            }
+                        case Status.ADDED:
+                        case Status.CHANGED:
+                            // Print log if it's enabled only.
+                            if (this.isEnabled) {
+                                printMsgLog('Processing %s file %s',
+                                        transformInvocation.incremental ? jarInput.status : Status.ADDED,
+                                        tempJarOutputDir.toPath().relativize(fileOutput.toPath()).toString())
+                            }
+
+                            AuxiliaryClassInjector.processJar(fileInput, fileOutput, new ProcessJarCallback() {
+                                @Override
+                                boolean onProcessClassEntry(String entryName) {
+                                    // If disabled, skip all classes.
+                                    if (!this.isEnabled) {
+                                        return false
+                                    } else {
+                                        // Skip application class.
+                                        if (entryName.equals(AuxiliaryInjectTransform.this.appClassPathName)) {
+                                            return false
+                                        } else
+                                        // Skip and mark auxiliary class.
+                                        if (entryName.equals(AuxiliaryInjectTransform.this.auxiliaryClassPathName)) {
+                                            isAuxiliaryClassExists = true
+                                            return false
+                                        } else {
+                                            return true;
+                                        }
+                                    }
+                                }
+                            })
+                            jarsToMerge.add(fileOutput)
+                            break
+                        case Status.REMOVED:
+                            // Print log if it's enabled only.
+                            if (this.isEnabled) {
+                                printMsgLog('Removing %s file %s from result.', fileStatus,
+                                        tempJarOutputDir.toPath().relativize(fileOutput.toPath()).toString())
+                            }
+
+                            if (fileOutput.exists()) {
+                                fileOutput.delete()
+                            }
+                            break
+                    }
+                }
+
+                mergeJars(jarsToMerge, jarOutput)
+            }
+
+            if (this.isEnabled) {
+                if (!isAuxiliaryClassExists) {
+                    printMsgLog('Generating auxiliary class %s.', this.auxiliaryClassPathName)
+                    AuxiliaryClassGenerator.generateAuxiliaryClass(
+                            dirOutput, AuxiliaryClassInjector.AUXILIARY_CLASSNAME)
+                } else {
+                    printWarnLog(
+                            'Found auxiliary class %s in your source codes, skip generating.',
+                            this.auxiliaryClassPathName
+                    )
+                }
+            }
+        }
+    }
+
+    private String getUniqueHashName(File fileInput) {
+        final String fileInputName = fileInput.getName()
+        if (fileInput.isDirectory()) {
+            return fileInputName
+        }
+        final String parentDirPath = fileInput.getParentFile().getAbsolutePath()
+        final String pathMD5 = MD5.getMessageDigest(parentDirPath.getBytes())
+        final int extSepPos = fileInputName.lastIndexOf('.')
+        final String fileInputNamePrefix =
+                (extSepPos >= 0 ? fileInputName.substring(0, extSepPos) : fileInputName)
+        final String fileInputNameSurfix =
+                (extSepPos >= 0 ? fileInputName.substring(extSepPos) : '')
+        return fileInputNamePrefix + '_' + pathMD5 + fileInputNameSurfix
+    }
+
+    private void mergeJars(Collection<File> jarsToMerge, File jarOutput) {
+        if (jarsToMerge == null || jarsToMerge.size() == 0) {
+            return
+        }
+
+        Set<String> addedEntries = new HashSet<>()
+        ZipOutputStream zos = null
+        try {
+            zos = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(jarOutput)))
+            jarsToMerge.each { jarInput ->
+                ZipInputStream zis = null
+                try {
+                    zis = new ZipInputStream(new BufferedInputStream(new FileInputStream(jarInput)))
+                    ZipEntry entryIn = null
+                    while ((entryIn = zis.getNextEntry()) != null) {
+                        final String entryName = entryIn.getName()
+                        if (!addedEntries.contains(entryName)) {
+                            addedEntries.add(entryName)
+                            ZipEntry entryOut = new ZipEntry(entryIn.getName())
+                            zos.putNextEntry(entryOut)
+                            if (!entryIn.isDirectory()) {
+                                Streams.copy(zis, zos)
+                            }
+                            zos.closeEntry()
+                        }
+                    }
+                } finally {
+                    closeQuietly(zis)
+                }
+            }
+        } finally {
+            closeQuietly(zos)
+        }
+    }
+
+    private void printMsgLog(String fmt, Object... vals) {
+        final String title = TRANSFORM_NAME.capitalize()
+        this.project.logger.lifecycle("[{}] {}", title,
+                (vals == null || vals.length == 0 ? fmt : String.format(fmt, vals)))
+    }
+
+    private void printWarnLog(String fmt, Object... vals) {
+        final String title = TRANSFORM_NAME.capitalize()
+        this.project.logger.warn("[{}] {}", title,
+                (vals == null || vals.length == 0 ? fmt : String.format(fmt, vals)))
+    }
+
+    private void closeQuietly(Closeable target) {
+        if (target != null) {
+            try {
+                target.close()
+            } catch (Exception e) {
+                // Ignored.
+            }
+        }
+    }
+}
+
diff --git a/tinker-build/tinker-patch-lib/build.gradle b/tinker-build/tinker-patch-lib/build.gradle
index 9b48db6e..ddb4e9b4 100644
--- a/tinker-build/tinker-patch-lib/build.gradle
+++ b/tinker-build/tinker-patch-lib/build.gradle
@@ -9,8 +9,10 @@ group rootProject.ext.GROUP
 dependencies {
     compile fileTree(dir: 'libs', include: ['*.jar'])
     compile project(':tinker-commons')
-    compile group: 'net.dongliu', name: 'apk-parser', version: '2.1.6'
+    compile group: 'com.tencent.mm', name: 'apk-parser-lib', version: '1.0.0'
     compile group: 'com.google.guava', name: 'guava', version: '11.0.2'
+    compile group: 'org.smali', name: 'dexlib2', version: '2.1.3'
+    compile group: 'org.ow2.asm', name: 'asm-all', version: '5.0.4'
 }
 
 sourceSets {
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptUtil.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptUtil.java
index 2a2695c0..9dec2aaa 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptUtil.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptUtil.java
@@ -78,7 +78,7 @@ public static AaptResourceCollector collectResource(List<String> resourceDirecto
         return collectResource(resourceDirectoryList, null);
     }
 
-    public static AaptResourceCollector collectResource(List<String> resourceDirectoryList, Map<RType, Set<com.tencent.tinker.build.aapt.RDotTxtEntry>> rTypeResourceMap) {
+    public static AaptResourceCollector collectResource(List<String> resourceDirectoryList, Map<RType, Set<RDotTxtEntry>> rTypeResourceMap) {
         AaptResourceCollector resourceCollector = new AaptResourceCollector(rTypeResourceMap);
         List<com.tencent.tinker.build.aapt.RDotTxtEntry> references = new ArrayList<com.tencent.tinker.build.aapt.RDotTxtEntry>();
         for (String resourceDirectory : resourceDirectoryList) {
@@ -98,7 +98,7 @@ public static AaptResourceCollector collectResource(List<String> resourceDirecto
         return resourceCollector;
     }
 
-    public static void processXmlFilesForIds(String resourceDirectory, List<com.tencent.tinker.build.aapt.RDotTxtEntry> references, AaptResourceCollector resourceCollector) throws Exception {
+    public static void processXmlFilesForIds(String resourceDirectory, List<RDotTxtEntry> references, AaptResourceCollector resourceCollector) throws Exception {
         List<String> xmlFullFilenameList = FileUtil.findMatchFile(resourceDirectory, Constant.Symbol.DOT + Constant.File.XML);
         if (xmlFullFilenameList != null) {
             for (String xmlFullFilename : xmlFullFilenameList) {
@@ -170,7 +170,7 @@ public static void processFileNamesInDirectory(String resourceDirectory, AaptRes
 
                 RType rType = RESOURCE_TYPES.get(directoryName);
                 resourceCollector.addIntResourceIfNotPresent(rType, resourceName);
-                com.tencent.tinker.build.aapt.ResourceDirectory resourceDirectoryBean = new com.tencent.tinker.build.aapt.ResourceDirectory(file.getParentFile().getName(), file.getAbsolutePath());
+                ResourceDirectory resourceDirectoryBean = new ResourceDirectory(file.getParentFile().getName(), file.getAbsolutePath());
                 resourceCollector.addRTypeResourceName(rType, resourceName, null, resourceDirectoryBean);
             }
         }
@@ -244,14 +244,14 @@ public static void processValuesFile(String valuesFullFilename, AaptResourceColl
                     break;
             }
             try {
-                addToResourceCollector(resourceCollector, new com.tencent.tinker.build.aapt.ResourceDirectory(directoryName, valuesFullFilename), node, rType, resourceValue);
+                addToResourceCollector(resourceCollector, new ResourceDirectory(directoryName, valuesFullFilename), node, rType, resourceValue);
             } catch (Exception e) {
                 throw new AaptUtilException(e.getMessage() + ",Process file error:" + valuesFullFilename, e);
             }
         }
     }
 
-    public static void processXmlFile(String xmlFullFilename, List<com.tencent.tinker.build.aapt.RDotTxtEntry> references, AaptResourceCollector resourceCollector) throws IOException, XPathExpressionException {
+    public static void processXmlFile(String xmlFullFilename, List<RDotTxtEntry> references, AaptResourceCollector resourceCollector) throws IOException, XPathExpressionException {
         Document document = JavaXmlUtil.parse(xmlFullFilename);
         NodeList nodesWithIds = (NodeList) ANDROID_ID_DEFINITION.evaluate(document, XPathConstants.NODESET);
         for (int i = 0; i < nodesWithIds.getLength(); i++) {
@@ -267,7 +267,9 @@ public static void processXmlFile(String xmlFullFilename, List<com.tencent.tinke
         for (int i = 0; i < nodesUsingIds.getLength(); i++) {
             String resourceName = nodesUsingIds.item(i).getNodeValue();
             int slashPosition = resourceName.indexOf('/');
-
+            if (slashPosition < 0) {
+                continue;
+            }
             String rawRType = resourceName.substring(1, slashPosition);
             String name = resourceName.substring(slashPosition + 1);
 
@@ -282,7 +284,7 @@ public static void processXmlFile(String xmlFullFilename, List<com.tencent.tinke
 //if(!resourceCollector.isContainResource(rType, IdType.INT, sanitizeName(resourceCollector, name))){
 //throw new AaptUtilException("Not found reference '" + resourceName + "' in '" + xmlFullFilename + "'");
 //}
-            references.add(new com.tencent.tinker.build.aapt.FakeRDotTxtEntry(IdType.INT, rType, sanitizeName(resourceCollector, name)));
+            references.add(new FakeRDotTxtEntry(IdType.INT, rType, sanitizeName(resourceCollector, name)));
         }
     }
 
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/apkparser/AndroidManifest.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/apkparser/AndroidParser.java
similarity index 60%
rename from tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/apkparser/AndroidManifest.java
rename to tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/apkparser/AndroidParser.java
index ea63940f..b417847d 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/apkparser/AndroidManifest.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/apkparser/AndroidParser.java
@@ -16,9 +16,14 @@
 
 package com.tencent.tinker.build.apkparser;
 
+import com.tencent.tinker.build.patch.Configuration;
+
 import net.dongliu.apk.parser.ApkParser;
 import net.dongliu.apk.parser.bean.ApkMeta;
 import net.dongliu.apk.parser.exception.ParserException;
+import net.dongliu.apk.parser.struct.StringPool;
+import net.dongliu.apk.parser.struct.resource.ResourceTable;
+import net.dongliu.apk.parser.utils.ParseUtils;
 
 import org.w3c.dom.Document;
 import org.w3c.dom.NamedNodeMap;
@@ -27,7 +32,9 @@
 
 import java.io.ByteArrayInputStream;
 import java.io.File;
+import java.io.FileOutputStream;
 import java.io.IOException;
+import java.nio.ByteBuffer;
 import java.text.ParseException;
 import java.util.ArrayList;
 import java.util.HashMap;
@@ -39,7 +46,7 @@
 /**
  * Created by zhangshaowen on 16/5/5.
  */
-public class AndroidManifest {
+public class AndroidParser {
     public static final int TYPE_SERVICE            = 1;
     public static final int TYPE_ACTIVITY           = 2;
     public static final int TYPE_BROADCAST_RECEIVER = 3;
@@ -55,15 +62,79 @@
     public final HashMap<String, String> metaDatas = new HashMap<>();
 
 
-    public AndroidManifest(ApkMeta apkMeta, String xml) throws ParserException {
+    public AndroidParser(ApkMeta apkMeta, String xml) throws ParserException {
         this.apkMeta = apkMeta;
         this.xml = xml;
         parse();
     }
 
-    public static AndroidManifest getAndroidManifest(File file) throws IOException, ParseException {
+    public static boolean resourceTableLogicalChange(Configuration config) throws IOException {
+        ApkParser parser = new ApkParser(config.mOldApkFile);
+        ApkParser newParser = new ApkParser(config.mNewApkFile);
+        parser.parseResourceTable();
+        newParser.parseResourceTable();
+        return parser.getResourceTable().equals(newParser.getResourceTable());
+    }
+
+    public static void editResourceTableString(String from, String to, File originFile, File destFile) throws IOException {
+        if (from == null || to == null) {
+            return;
+        }
+        if (!originFile.exists()) {
+            throw new RuntimeException("origin resources.arsc is not exist, path:" + originFile.getPath());
+        }
+
+        if (from.length() != to.length()) {
+            throw new RuntimeException("only support the same string length now!");
+        }
+        ApkParser parser = new ApkParser();
+        parser.parseResourceTable(originFile);
+        ResourceTable resourceTable = parser.getResourceTable();
+        StringPool stringPool = resourceTable.getStringPool();
+        ByteBuffer buffer = resourceTable.getBuffers();
+        byte[] array = buffer.array();
+        int length = stringPool.getPool().length;
+        boolean found = false;
+        for (int i = 0; i < length; i++) {
+            String value = stringPool.get(i);
+            if (value.equals(from)) {
+                found = true;
+                long offset = stringPool.getPoolOffsets().get(i);
+                //length
+                offset += 2;
+                byte[] tempByte;
+                if (stringPool.isUtf8()) {
+                    tempByte = to.getBytes(ParseUtils.charsetUTF8);
+                    if (to.length() != tempByte.length) {
+                        throw new RuntimeException(String.format(
+                            "editResourceTableString length is different, name %d, tempByte %d\n", to.length(), tempByte.length));
+                    }
+                } else {
+                    tempByte = to.getBytes(ParseUtils.charsetUTF16);
+                    if ((to.length() * 2) != tempByte.length) {
+                        throw new RuntimeException(String.format(
+                            "editResourceTableString length is different, name %d, tempByte %d\n", to.length(), tempByte.length));
+                    }
+                }
+                System.arraycopy(tempByte, 0, array, (int) offset, tempByte.length);
+            }
+        }
+        if (!found) {
+            throw new RuntimeException("can't found string:" + from + " in the resources.arsc file's string pool!");
+        }
+
+        //write array to file
+        FileOutputStream fileOutputStream = new FileOutputStream(destFile);
+        try {
+            fileOutputStream.write(array);
+        } finally {
+            fileOutputStream.close();
+        }
+    }
+
+    public static AndroidParser getAndroidManifest(File file) throws IOException, ParseException {
         ApkParser apkParser = new ApkParser(file);
-        AndroidManifest androidManifest = new AndroidManifest(apkParser.getApkMeta(), apkParser.getManifestXml());
+        AndroidParser androidManifest = new AndroidParser(apkParser.getApkMeta(), apkParser.getManifestXml());
         return androidManifest;
     }
 
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/auxiliaryclass/AuxiliaryClassGenerator.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/auxiliaryclass/AuxiliaryClassGenerator.java
new file mode 100644
index 00000000..f19c2c69
--- /dev/null
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/auxiliaryclass/AuxiliaryClassGenerator.java
@@ -0,0 +1,130 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.build.auxiliaryclass;
+
+import org.objectweb.asm.ClassWriter;
+import org.objectweb.asm.MethodVisitor;
+import org.objectweb.asm.Opcodes;
+
+import java.io.BufferedOutputStream;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.util.regex.Pattern;
+
+/**
+ * Created by tangyinsheng on 2016/10/13.
+ */
+
+public final class AuxiliaryClassGenerator {
+    private static final String JAVA_IDENTIFIER_PATTERN_STR =
+            "(?:\\p{javaJavaIdentifierStart}\\p{javaJavaIdentifierPart}*)";
+
+    private static final String JAVA_FULL_CLASSNAME_PATTERN_STR =
+            String.format("(%s(?:\\.%s)*)", JAVA_IDENTIFIER_PATTERN_STR,
+                    JAVA_IDENTIFIER_PATTERN_STR);
+
+    private static final Pattern JAVA_FULL_CLASSNAME_PATTERN =
+            Pattern.compile(JAVA_FULL_CLASSNAME_PATTERN_STR);
+
+    public static void generateAuxiliaryClass(File dirOutput, String dotClassName) throws IOException {
+        if (!JAVA_FULL_CLASSNAME_PATTERN.matcher(dotClassName).matches()) {
+            throw new IllegalArgumentException("Bad dotClassName: " + dotClassName);
+        }
+        if (isPrimitiveClass(dotClassName)) {
+            throw new UnsupportedOperationException("Cannot generate primitive class.");
+        }
+        if (isArrayClass(dotClassName)) {
+            throw new UnsupportedOperationException("Cannot generate array class.");
+        }
+
+        final int lastDotSepPos = dotClassName.lastIndexOf('.');
+        final String classPkgPart =
+                (lastDotSepPos >= 0 ? dotClassName.substring(0, lastDotSepPos) : "");
+        final String classNamePart = dotClassName.substring(lastDotSepPos + 1);
+
+        final File realDirOutput = new File(dirOutput, classPkgPart.replace('.', '/'));
+        if (!realDirOutput.exists()) {
+            realDirOutput.mkdirs();
+        }
+        final File fileOut = new File(realDirOutput, classNamePart + ".class");
+
+        generateClass(dotClassName, fileOut);
+    }
+
+    private static void generateClass(String dotClassName, File fileOut) throws IOException {
+        final String classDesc = dotClassName.replace('.', '/');
+        ClassWriter cw = new ClassWriter(0);
+        cw.visit(
+                Opcodes.V1_7,
+                Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER,
+                classDesc,
+                null,
+                "java/lang/Object",
+                null
+        );
+        cw.visitSource(fileOut.getName(), null);
+        {
+            MethodVisitor mv = cw.visitMethod(
+                    Opcodes.ACC_PUBLIC, "<init>", "()V", null, null
+            );
+            mv.visitVarInsn(Opcodes.ALOAD, 0);
+            mv.visitMethodInsn(Opcodes.INVOKESPECIAL,
+                    "java/lang/Object",
+                    "<init>",
+                    "()V",
+                    false
+            );
+            mv.visitInsn(Opcodes.RETURN);
+            mv.visitMaxs(1, 1);
+            mv.visitEnd();
+        }
+        cw.visitEnd();
+        byte[] classBytes = cw.toByteArray();
+
+        OutputStream os = null;
+        try {
+            os = new BufferedOutputStream(new FileOutputStream(fileOut));
+            os.write(classBytes);
+        } finally {
+            if (os != null) {
+                try {
+                    os.close();
+                } catch (Exception e) {
+                    // Ignored.
+                }
+            }
+        }
+    }
+
+    private static boolean isPrimitiveClass(String className) {
+        try {
+            return Class.forName(className).isPrimitive();
+        } catch (ClassNotFoundException e) {
+            return false;
+        }
+    }
+
+    private static boolean isArrayClass(String className) {
+        try {
+            return Class.forName(className).isArray();
+        } catch (ClassNotFoundException e) {
+            return false;
+        }
+    }
+}
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/auxiliaryclass/AuxiliaryClassInjectAdapter.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/auxiliaryclass/AuxiliaryClassInjectAdapter.java
new file mode 100644
index 00000000..a840654a
--- /dev/null
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/auxiliaryclass/AuxiliaryClassInjectAdapter.java
@@ -0,0 +1,141 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.build.auxiliaryclass;
+
+import org.objectweb.asm.ClassVisitor;
+import org.objectweb.asm.ClassWriter;
+import org.objectweb.asm.MethodVisitor;
+import org.objectweb.asm.Opcodes;
+import org.objectweb.asm.Type;
+
+/**
+ * Created by tangyinsheng on 2016/10/10.
+ */
+
+public final class AuxiliaryClassInjectAdapter extends ClassVisitor {
+    private final String auxiliaryClassDesc;
+    private boolean isClInitExists;
+    private boolean isInitExists;
+    private boolean isTargetClass;
+    private boolean isInjected;
+
+    public AuxiliaryClassInjectAdapter(String auxiliaryClassName, ClassWriter cw) {
+        super(Opcodes.ASM5, cw);
+        this.auxiliaryClassDesc = fastClassNameToDesc(auxiliaryClassName);
+    }
+
+    private String fastClassNameToDesc(String className) {
+        if (className.startsWith("L") && className.endsWith(";")) {
+            return className;
+        }
+        if ("boolean".equals(className)) {
+            return "Z";
+        } else
+        if ("byte".equals(className)) {
+            return "B";
+        } else
+        if ("char".equals(className)) {
+            return "C";
+        } else
+        if ("short".equals(className)) {
+            return "S";
+        } else
+        if ("int".equals(className)) {
+            return "I";
+        } else
+        if ("long".equals(className)) {
+            return "J";
+        } else
+        if ("float".equals(className)) {
+            return "F";
+        } else
+        if ("double".equals(className)) {
+            return "D";
+        } else {
+            className = className.replace('.', '/');
+            return "L" + className + ";";
+        }
+    }
+
+    @Override
+    public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {
+        super.visit(version, access, name, signature, superName, interfaces);
+        this.isClInitExists = false;
+        this.isInitExists = false;
+        this.isTargetClass = ((access & Opcodes.ACC_INTERFACE) == 0);
+        this.isInjected = false;
+    }
+
+    @Override
+    public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {
+        MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);
+        if (mv != null && this.isTargetClass && !this.isInjected) {
+            if ("<clinit>".equals(name)) {
+                this.isClInitExists = true;
+                this.isInjected = true;
+                mv = new InjectImplMethodVisitor(mv);
+            } else
+            if ("<init>".equals(name)) {
+                this.isInitExists = true;
+                this.isInjected = true;
+                mv = new InjectImplMethodVisitor(mv);
+            }
+        }
+        return mv;
+    }
+
+    @Override
+    public void visitEnd() {
+        // If method <clinit> and <init> are not found, we should generate a <clinit>.
+        if (!this.isClInitExists && !this.isInitExists) {
+            MethodVisitor mv = super.visitMethod(Opcodes.ACC_STATIC, "<clinit>", "()V", null, null);
+            mv.visitCode();
+            mv.visitLdcInsn(Type.getType(AuxiliaryClassInjectAdapter.this.auxiliaryClassDesc));
+            mv.visitVarInsn(Opcodes.ASTORE, 0);
+            mv.visitInsn(Opcodes.RETURN);
+            mv.visitMaxs(1, 1);
+            mv.visitEnd();
+        }
+        super.visitEnd();
+    }
+
+    private class InjectImplMethodVisitor extends MethodVisitor {
+        InjectImplMethodVisitor(MethodVisitor mv) {
+            super(Opcodes.ASM5, mv);
+        }
+
+        @Override
+        public void visitInsn(int opcode) {
+            if (opcode == Opcodes.RETURN) {
+                super.visitLdcInsn(Type.getType(AuxiliaryClassInjectAdapter.this.auxiliaryClassDesc));
+                super.visitVarInsn(Opcodes.ASTORE, 0);
+            }
+            super.visitInsn(opcode);
+        }
+
+        @Override
+        public void visitMaxs(int maxStack, int maxLocals) {
+            if (maxStack < 1) {
+                maxStack = 1;
+            }
+            if (maxLocals < 1) {
+                maxLocals = 1;
+            }
+            super.visitMaxs(maxStack, maxLocals);
+        }
+    }
+}
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/auxiliaryclass/AuxiliaryClassInjector.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/auxiliaryclass/AuxiliaryClassInjector.java
new file mode 100644
index 00000000..88979366
--- /dev/null
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/auxiliaryclass/AuxiliaryClassInjector.java
@@ -0,0 +1,123 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.build.auxiliaryclass;
+
+import com.tencent.tinker.commons.ziputil.Streams;
+
+import org.objectweb.asm.ClassReader;
+import org.objectweb.asm.ClassWriter;
+
+import java.io.BufferedInputStream;
+import java.io.BufferedOutputStream;
+import java.io.Closeable;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.nio.charset.Charset;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipInputStream;
+import java.util.zip.ZipOutputStream;
+
+/**
+ * Created by tangyinsheng on 2016/10/9.
+ */
+
+public final class AuxiliaryClassInjector {
+    public static final String AUXILIARY_CLASSNAME = "dalvik.system.PathClassLoader";
+
+    public interface ProcessJarCallback {
+        boolean onProcessClassEntry(String entryName);
+    }
+
+    public static void processClass(File classIn, File classOut) throws IOException {
+        InputStream is = null;
+        OutputStream os = null;
+        try {
+            is = new BufferedInputStream(new FileInputStream(classIn));
+            os = new BufferedOutputStream(new FileOutputStream(classOut));
+            processClass(is, os);
+        } finally {
+            closeQuietly(os);
+            closeQuietly(is);
+        }
+    }
+
+    public static void processJar(File jarIn, File jarOut, ProcessJarCallback cb) throws IOException {
+        try {
+            processJarHelper(jarIn, jarOut, cb, Charset.forName("UTF-8"), Charset.forName("UTF-8"));
+        } catch (IllegalArgumentException e) {
+            if ("MALFORMED".equals(e.getMessage())) {
+                processJarHelper(jarIn, jarOut, cb, Charset.forName("GBK"), Charset.forName("UTF-8"));
+            } else {
+                throw e;
+            }
+        }
+    }
+
+    @SuppressWarnings("NewApi")
+    private static void processJarHelper(File jarIn, File jarOut, ProcessJarCallback cb, Charset charsetIn, Charset charsetOut) throws IOException {
+        ZipInputStream zis = null;
+        ZipOutputStream zos = null;
+        try {
+            zis = new ZipInputStream(new BufferedInputStream(new FileInputStream(jarIn)), charsetIn);
+            zos = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(jarOut)), charsetOut);
+            ZipEntry entryIn = null;
+            while ((entryIn = zis.getNextEntry()) != null) {
+                final String entryName = entryIn.getName();
+                ZipEntry entryOut = new ZipEntry(entryName);
+                zos.putNextEntry(entryOut);
+                if (!entryIn.isDirectory()) {
+                    if (entryName.endsWith(".class")) {
+                        if (cb == null || cb.onProcessClassEntry(entryName)) {
+                            processClass(zis, zos);
+                        } else {
+                            Streams.copy(zis, zos);
+                        }
+                    } else {
+                        Streams.copy(zis, zos);
+                    }
+                }
+                zos.closeEntry();
+            }
+        } finally {
+            closeQuietly(zos);
+            closeQuietly(zis);
+        }
+    }
+
+    private static void processClass(InputStream classIn, OutputStream classOut) throws IOException {
+        ClassReader cr = new ClassReader(classIn);
+        ClassWriter cw = new ClassWriter(0);
+        AuxiliaryClassInjectAdapter aia = new AuxiliaryClassInjectAdapter(AUXILIARY_CLASSNAME, cw);
+        cr.accept(aia, 0);
+        classOut.write(cw.toByteArray());
+        classOut.flush();
+    }
+
+    private static void closeQuietly(Closeable target) {
+        if (target != null) {
+            try {
+                target.close();
+            } catch (Exception e) {
+                // Ignored.
+            }
+        }
+    }
+}
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/builder/PatchBuilder.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/builder/PatchBuilder.java
index 6a2210b3..a607da74 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/builder/PatchBuilder.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/builder/PatchBuilder.java
@@ -23,7 +23,10 @@
 import com.tencent.tinker.build.util.TypedValue;
 
 import java.io.File;
+import java.io.FileInputStream;
 import java.io.IOException;
+import java.security.Key;
+import java.security.KeyStore;
 import java.util.ArrayList;
 
 /**
@@ -45,7 +48,7 @@ public PatchBuilder(Configuration config) {
         this.sevenZipOutPutDir = new File(config.mOutFolder, TypedValue.OUT_7ZIP_FILE_PATH);
     }
 
-    public void buildPatch() throws IOException, InterruptedException {
+    public void buildPatch() throws Exception {
         final File resultDir = config.mTempResultDir;
         if (!resultDir.exists()) {
             throw new IOException(String.format(
@@ -80,23 +83,47 @@ public void buildPatch() throws IOException, InterruptedException {
 
     }
 
+    private String getSignatureAlgorithm() throws Exception {
+        FileInputStream fileIn = new FileInputStream(config.mSignatureFile);
+        KeyStore keyStore = KeyStore.getInstance("JKS");
+        keyStore.load(fileIn, config.mStorePass.toCharArray());
+        Key key = keyStore.getKey(config.mStoreAlias, config.mKeyPass.toCharArray());
+        String keyAlgorithm = key.getAlgorithm();
+        String signatureAlgorithm;
+        if (keyAlgorithm.equalsIgnoreCase("DSA")) {
+            signatureAlgorithm = "SHA1withDSA";
+        } else if (keyAlgorithm.equalsIgnoreCase("RSA")) {
+            signatureAlgorithm = "SHA1withRSA";
+        } else if (keyAlgorithm.equalsIgnoreCase("EC")) {
+            signatureAlgorithm = "SHA1withECDSA";
+        } else {
+            throw new RuntimeException("private key is not a DSA or "
+                + "RSA key");
+        }
+        return signatureAlgorithm;
+    }
+
     /**
      * @param input  unsigned file input
      * @param output signed file output
      * @throws IOException
      * @throws InterruptedException
      */
-    private void signApk(File input, File output) throws IOException, InterruptedException {
+    private void signApk(File input, File output) throws Exception {
         //sign apk
         if (config.mUseSignAPk) {
             Logger.d("Signing apk: %s", output.getName());
+            String signatureAlgorithm = getSignatureAlgorithm();
+            Logger.d("Signing key algorithm is %s", signatureAlgorithm);
+
             if (output.exists()) {
                 output.delete();
             }
             ArrayList<String> command = new ArrayList<>();
             command.add("jarsigner");
+            // issue https://github.com/Tencent/tinker/issues/118
             command.add("-sigalg");
-            command.add("MD5withRSA");
+            command.add(signatureAlgorithm);
             command.add("-digestalg");
             command.add("SHA1");
             command.add("-keystore");
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java
index 6c366f00..fa32385f 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java
@@ -17,11 +17,14 @@
 package com.tencent.tinker.build.decoder;
 
 
+import com.google.common.io.Files;
+
 import com.tencent.tinker.android.dex.ClassDef;
 import com.tencent.tinker.android.dex.Dex;
 import com.tencent.tinker.android.dex.DexFormat;
 import com.tencent.tinker.android.dx.util.Hex;
 import com.tencent.tinker.build.dexpatcher.DexPatchGenerator;
+import com.tencent.tinker.build.dexpatcher.util.SmallDexClassInfoCollector;
 import com.tencent.tinker.build.dexpatcher.util.SmallDexPatchGenerator;
 import com.tencent.tinker.build.info.InfoWriter;
 import com.tencent.tinker.build.patch.Configuration;
@@ -39,6 +42,17 @@
 import com.tencent.tinker.commons.dexpatcher.DexPatcherLogger.IDexPatcherLogger;
 import com.tencent.tinker.commons.dexpatcher.struct.SmallPatchedDexItemFile;
 
+import org.jf.dexlib2.Opcodes;
+import org.jf.dexlib2.builder.BuilderMutableMethodImplementation;
+import org.jf.dexlib2.dexbacked.DexBackedDexFile;
+import org.jf.dexlib2.iface.DexFile;
+import org.jf.dexlib2.iface.Field;
+import org.jf.dexlib2.iface.Method;
+import org.jf.dexlib2.writer.builder.BuilderField;
+import org.jf.dexlib2.writer.builder.BuilderMethod;
+import org.jf.dexlib2.writer.builder.DexBuilder;
+import org.jf.dexlib2.writer.io.FileDataStore;
+
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
@@ -56,7 +70,9 @@
  * Created by zhangshaowen on 2016/3/23.
  */
 public class DexDiffDecoder extends BaseDecoder {
-    private static final String TEST_DEX_PATH = "test.dex";
+    private static final String TEST_DEX_NAME = "test.dex";
+    private static final String PREGENERATED_PATCH_DEX_NAME = "changed_classes.dex";
+
     private final InfoWriter logWriter;
     private final InfoWriter metaWriter;
 
@@ -141,15 +157,19 @@ public boolean patch(final File oldFile, final File newFile) throws IOException,
         //new add file
         if (oldFile == null || !oldFile.exists() || oldFile.length() == 0) {
             hasDexChanged = true;
-            copyNewDexAndMarkInMeta(newFile, newMd5, dexDiffOut);
-            return true;
+            if (!config.mUsePreGeneratedPatchDex) {
+                copyNewDexAndMarkInMeta(newFile, newMd5, dexDiffOut);
+                return true;
+            }
         }
 
         final String oldMd5 = MD5.getMD5(oldFile);
 
-        if (!oldMd5.equals(newMd5)) {
+        if ((oldMd5 != null && !oldMd5.equals(newMd5)) || (oldMd5 == null && newMd5 != null)) {
             hasDexChanged = true;
-            checkAddedOrDeletedClasses(oldFile, newFile);
+            if (oldMd5 != null) {
+                checkAddedOrDeletedClasses(oldFile, newFile);
+            }
         }
 
         RelatedInfo relatedInfo = new RelatedInfo();
@@ -159,13 +179,12 @@ public boolean patch(final File oldFile, final File newFile) throws IOException,
         // collect current old dex file and corresponding new dex file for further processing.
         oldAndNewDexFilePairList.add(new AbstractMap.SimpleEntry<>(oldFile, newFile));
 
-        final String dexName = oldFile.getName();
+        final String dexName = (oldFile != null ? oldFile.getName() : newFile.getName());
         dexNameToRelatedInfoMap.put(dexName, relatedInfo);
 
         return true;
     }
 
-    @SuppressWarnings("NewApi")
     @Override
     public void onAllPatchesEnd() throws Exception {
         if (!hasDexChanged) {
@@ -173,6 +192,122 @@ public void onAllPatchesEnd() throws Exception {
             return;
         }
 
+        if (config.mUsePreGeneratedPatchDex) {
+            generateStubModePatchDex();
+        } else {
+            generatePatchInfoFile();
+        }
+    }
+
+    @SuppressWarnings("NewApi")
+    private void generateStubModePatchDex() throws IOException {
+        List<File> oldDexList = new ArrayList<>();
+        List<File> newDexList = new ArrayList<>();
+        for (AbstractMap.SimpleEntry<File, File> oldAndNewDexFilePair : oldAndNewDexFilePairList) {
+            File oldDexFile = oldAndNewDexFilePair.getKey();
+            File newDexFile = oldAndNewDexFilePair.getValue();
+            if (oldDexFile != null) {
+                oldDexList.add(oldDexFile);
+            }
+            if (newDexFile != null) {
+                newDexList.add(newDexFile);
+            }
+        }
+
+        DexGroup oldDexGroup = DexGroup.wrap(oldDexList);
+        DexGroup newDexGroup = DexGroup.wrap(newDexList);
+
+        SmallDexClassInfoCollector smallDexClassInfoCollector = new SmallDexClassInfoCollector();
+        smallDexClassInfoCollector.setLoaderClassPatterns(config.mDexLoaderPattern);
+        smallDexClassInfoCollector.setLogger(this.dexPatcherLoggerBridge);
+
+        Set<DexClassInfo> classInfosInPatchedDex =
+                smallDexClassInfoCollector.doCollect(oldDexGroup, newDexGroup);
+
+        // So far we have got all infos of classes we need to include in stub mode patch dex.
+        // Now construct the stub mode patch dex.
+        final Set<String> classDescsInPatchedDex = new HashSet<>();
+        Set<Dex> newDexes = new HashSet<>();
+
+        DexBuilder dexBuilder = DexBuilder.makeDexBuilder(Opcodes.forApi(15));
+
+        for (DexClassInfo classInfo : classInfosInPatchedDex) {
+            classDescsInPatchedDex.add(classInfo.classDesc);
+            newDexes.add(classInfo.owner);
+        }
+
+        for (Dex newDex : newDexes) {
+            DexFile dexFile = new DexBackedDexFile(Opcodes.forApi(15), newDex.getBytes());
+            for (org.jf.dexlib2.iface.ClassDef parsedClassDef : dexFile.getClasses()) {
+                if (classDescsInPatchedDex.contains(parsedClassDef.getType())) {
+                    List<BuilderField> builderFields = new ArrayList<>();
+                    for (Field parsedField : parsedClassDef.getFields()) {
+                        BuilderField builderField = dexBuilder.internField(
+                                parsedField.getDefiningClass(),
+                                parsedField.getName(),
+                                parsedField.getType(),
+                                parsedField.getAccessFlags(),
+                                parsedField.getInitialValue(),
+                                parsedField.getAnnotations()
+                        );
+                        builderFields.add(builderField);
+                    }
+                    List<BuilderMethod> builderMethods = new ArrayList<>();
+                    for (Method parsedMethod : parsedClassDef.getMethods()) {
+                        BuilderMethod builderMethod = dexBuilder.internMethod(
+                                parsedMethod.getDefiningClass(),
+                                parsedMethod.getName(),
+                                parsedMethod.getParameters(),
+                                parsedMethod.getReturnType(),
+                                parsedMethod.getAccessFlags(),
+                                parsedMethod.getAnnotations(),
+                                new BuilderMutableMethodImplementation(
+                                        dexBuilder, parsedMethod.getImplementation()
+                                )
+                        );
+                        builderMethods.add(builderMethod);
+                    }
+
+                    dexBuilder.internClassDef(
+                            parsedClassDef.getType(),
+                            parsedClassDef.getAccessFlags(),
+                            parsedClassDef.getSuperclass(),
+                            parsedClassDef.getInterfaces(),
+                            parsedClassDef.getSourceFile(),
+                            parsedClassDef.getAnnotations(),
+                            builderFields,
+                            builderMethods
+                    );
+                }
+            }
+        }
+
+        // Write constructed stub mode patch dex to file and record it in meta file.
+        final String dexMode = config.mDexRaw ? "raw" : "jar";
+        final File dest = new File(config.mTempResultDir + "/" + PREGENERATED_PATCH_DEX_NAME);
+
+        FileDataStore fileDataStore = new FileDataStore(dest);
+        dexBuilder.writeTo(fileDataStore);
+
+        final File tempPreGeneratedPatchDexPath = new File(config.mOutFolder + File.separator + TypedValue.DEX_TEMP_PATCH_DIR + File.separator + "pre-generated");
+        ensureDirectoryExist(tempPreGeneratedPatchDexPath);
+        Files.copy(dest, new File(tempPreGeneratedPatchDexPath, PREGENERATED_PATCH_DEX_NAME));
+
+        final String md5 = MD5.getMD5(dest);
+
+        String meta = PREGENERATED_PATCH_DEX_NAME + "," + "" + "," + md5 + "," + md5 + "," + 0
+                        + "," + 0 + "," + dexMode;
+
+        Logger.d("\nPre-generated patch dex: %s, size:%d", dest.getAbsolutePath(), dest.length());
+        Logger.d("DexDecoder:write pre-generated patch dex meta file data: %s", meta);
+
+        metaWriter.writeLineToInfoFile(meta);
+
+        addTestDex();
+    }
+
+    @SuppressWarnings("NewApi")
+    private void generatePatchInfoFile() throws IOException {
         File tempFullPatchDexPath = new File(config.mOutFolder + File.separator + TypedValue.DEX_TEMP_PATCH_DIR + File.separator + "full");
         ensureDirectoryExist(tempFullPatchDexPath);
         File tempSmallPatchDexPath = new File(config.mOutFolder + File.separator + TypedValue.DEX_TEMP_PATCH_DIR + File.separator + "small");
@@ -386,7 +521,7 @@ public void onAllPatchesEnd() throws Exception {
         Set<String> movedCrossFilesClassDescs = deletedClassDescs;
         if (!movedCrossFilesClassDescs.isEmpty()) {
             Logger.e("Warning:Class Moved. Some classes are just moved from one dex to another. "
-                + "This behavior may leads to unnecessary enlargement of patch file. you should try to check them:");
+                    + "This behavior may leads to unnecessary enlargement of patch file. you should try to check them:");
 
             for (String classDesc : movedCrossFilesClassDescs) {
                 StringBuilder sb = new StringBuilder();
@@ -524,14 +659,14 @@ private void addTestDex() throws IOException {
             dexMode = "raw";
         }
 
-        final InputStream is = DexDiffDecoder.class.getResourceAsStream("/" + TEST_DEX_PATH);
+        final InputStream is = DexDiffDecoder.class.getResourceAsStream("/" + TEST_DEX_NAME);
         String md5 = MD5.getMD5(is, 1024);
         is.close();
 
-        String meta = TEST_DEX_PATH + "," + "" + "," + md5 + "," + md5 + "," + 0 + "," + 0 + "," + dexMode;
+        String meta = TEST_DEX_NAME + "," + "" + "," + md5 + "," + md5 + "," + 0 + "," + 0 + "," + dexMode;
 
-        File dest = new File(config.mTempResultDir + "/" + TEST_DEX_PATH);
-        FileOperation.copyResourceUsingStream(TEST_DEX_PATH, dest);
+        File dest = new File(config.mTempResultDir + "/" + TEST_DEX_NAME);
+        FileOperation.copyResourceUsingStream(TEST_DEX_NAME, dest);
         Logger.d("\nAdd test install result dex: %s, size:%d", dest.getAbsolutePath(), dest.length());
         Logger.d("DexDecoder:write test dex meta file data: %s", meta);
 
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ManifestDecoder.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ManifestDecoder.java
index d21414ee..59e6e400 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ManifestDecoder.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ManifestDecoder.java
@@ -17,7 +17,7 @@
 package com.tencent.tinker.build.decoder;
 
 
-import com.tencent.tinker.build.apkparser.AndroidManifest;
+import com.tencent.tinker.build.apkparser.AndroidParser;
 import com.tencent.tinker.build.patch.Configuration;
 import com.tencent.tinker.build.util.Logger;
 import com.tencent.tinker.build.util.TinkerPatchException;
@@ -42,8 +42,8 @@ public ManifestDecoder(Configuration config) throws IOException {
     public boolean patch(File oldFile, File newFile) throws IOException, TinkerPatchException {
         final boolean ignoreWarning = config.mIgnoreWarning;
         try {
-            AndroidManifest oldAndroidManifest = AndroidManifest.getAndroidManifest(oldFile);
-            AndroidManifest newAndroidManifest = AndroidManifest.getAndroidManifest(newFile);
+            AndroidParser oldAndroidManifest = AndroidParser.getAndroidManifest(oldFile);
+            AndroidParser newAndroidManifest = AndroidParser.getAndroidManifest(newFile);
             //check minSdkVersion
             int minSdkVersion = Integer.parseInt(oldAndroidManifest.apkMeta.getMinSdkVersion());
 
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ResDiffDecoder.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ResDiffDecoder.java
index 193b41c1..1347e16d 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ResDiffDecoder.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ResDiffDecoder.java
@@ -17,6 +17,7 @@
 package com.tencent.tinker.build.decoder;
 
 import com.tencent.tinker.bsdiff.BSDiff;
+import com.tencent.tinker.build.apkparser.AndroidParser;
 import com.tencent.tinker.build.info.InfoWriter;
 import com.tencent.tinker.build.patch.Configuration;
 import com.tencent.tinker.build.util.FileOperation;
@@ -52,6 +53,11 @@
     private       HashMap<String, LargeModeInfo> largeModifiedMap;
     private ArrayList<String> deletedSet;
 
+    private boolean arscChanged;
+    private File oldArscFile;
+    private File newArscFile;
+
+
     public ResDiffDecoder(Configuration config, String metaPath, String logPath) throws IOException {
         super(config);
 
@@ -80,8 +86,8 @@ public void clean() {
     }
 
     private boolean checkLargeModFile(File file) {
-        long lenght = file.length();
-        if (lenght > config.mLargeModSize * TypedValue.K_BYTES) {
+        long length = file.length();
+        if (length > config.mLargeModSize * TypedValue.K_BYTES) {
             return true;
         }
         return false;
@@ -89,14 +95,19 @@ private boolean checkLargeModFile(File file) {
 
     @Override
     public boolean patch(File oldFile, File newFile) throws IOException, TinkerPatchException {
+        String name = getRelativeString(newFile);
+        if (name.equals(TypedValue.RES_ARSC)) {
+            oldArscFile = oldFile;
+            newArscFile = newFile;
+        }
         //actually, it won't go below
         if (newFile == null || !newFile.exists()) {
-            String name = getRelativeStringByOldDir(oldFile);
-            if (Utils.checkFileInPattern(config.mResIgnoreChangePattern, name)) {
-                Logger.e("found delete resource: " + name + " ,but it match ignore change pattern, just ignore!");
+            String relativeStringByOldDir = getRelativeStringByOldDir(oldFile);
+            if (Utils.checkFileInPattern(config.mResIgnoreChangePattern, relativeStringByOldDir)) {
+                Logger.e("found delete resource: " + relativeStringByOldDir + " ,but it match ignore change pattern, just ignore!");
                 return false;
             }
-            deletedSet.add(name);
+            deletedSet.add(relativeStringByOldDir);
             writeResLog(newFile, oldFile, TypedValue.DEL);
             return true;
         }
@@ -104,7 +115,6 @@ public boolean patch(File oldFile, File newFile) throws IOException, TinkerPatch
         File outputFile = getOutputPath(newFile).toFile();
 
         if (oldFile == null || !oldFile.exists()) {
-            String name = getRelativeString(newFile);
             if (Utils.checkFileInPattern(config.mResIgnoreChangePattern, name)) {
                 Logger.e("found add resource: " + name + " ,but it match ignore change pattern, just ignore!");
                 return false;
@@ -126,15 +136,28 @@ public boolean patch(File oldFile, File newFile) throws IOException, TinkerPatch
         if (oldMd5 != null && oldMd5.equals(newMd5)) {
             return false;
         }
-        String name = getRelativeString(newFile);
         if (Utils.checkFileInPattern(config.mResIgnoreChangePattern, name)) {
-            Logger.e("found modify resource: " + name + " ,but it match ignore change pattern, just ignore!");
+            Logger.d("found modify resource: " + name + ", but it match ignore change pattern, just ignore!");
             return false;
         }
         if (name.equals(TypedValue.RES_MANIFEST)) {
-            Logger.e("found modify resource: " + name + " ,but it is AndroidManifest.xml, just ignore!");
+            Logger.d("found modify resource: " + name + ", but it is AndroidManifest.xml, just ignore!");
             return false;
         }
+        if (name.equals(TypedValue.RES_ARSC)) {
+            if (AndroidParser.resourceTableLogicalChange(config)) {
+                Logger.d("found modify resource: " + name + ", but it is logically the same as original new resources.arsc, just ignore!");
+                return false;
+            }
+            //deal with resources.arsc later
+            arscChanged = true;
+            return true;
+        }
+        dealWithModeFile(name, newMd5, oldFile, newFile, outputFile);
+        return true;
+    }
+
+    private boolean dealWithModeFile(String name, String newMd5, File oldFile, File newFile, File outputFile) throws IOException {
         if (checkLargeModFile(newFile)) {
             if (!outputFile.getParentFile().exists()) {
                 outputFile.getParentFile().mkdirs();
@@ -155,7 +178,7 @@ public boolean patch(File oldFile, File newFile) throws IOException, TinkerPatch
         modifiedSet.add(name);
         FileOperation.copyFileUsingStream(newFile, outputFile);
         writeResLog(newFile, oldFile, TypedValue.MOD);
-        return true;
+        return false;
     }
 
     private void writeResLog(File newFile, File oldFile, int mode) throws IOException {
@@ -197,10 +220,18 @@ public void onAllPatchesStart() throws IOException, TinkerPatchException {
 
     }
 
+    private void modArscFileForTestResource() throws IOException {
+        File tempArscFile = new File(config.mOutFolder + File.separator + "edited_resources.arsc");
+        //there is resource changed, edit test resource string
+        AndroidParser.editResourceTableString(TypedValue.TEST_STRING_VALUE_A, TypedValue.TEST_STRING_VALUE_B, newArscFile, tempArscFile);
+        dealWithModeFile(TypedValue.RES_ARSC, MD5.getMD5(tempArscFile), oldArscFile, tempArscFile, getOutputPath(newArscFile).toFile());
+        Logger.d("Edit resources.arsc file for test resource change, final path: " + tempArscFile.getAbsolutePath());
+    }
+
     @Override
     public void onAllPatchesEnd() throws IOException, TinkerPatchException {
         //only there is only deleted set, we just ignore
-        if (addedSet.isEmpty() && modifiedSet.isEmpty() && largeModifiedSet.isEmpty()) {
+        if (addedSet.isEmpty() && modifiedSet.isEmpty() && largeModifiedSet.isEmpty() && !arscChanged) {
             return;
         }
 
@@ -211,13 +242,12 @@ public void onAllPatchesEnd() throws IOException, TinkerPatchException {
             throw new TinkerPatchException("resource must contain AndroidManifest.xml pattern");
         }
 
+        modArscFileForTestResource();
+
         //check gradle build
         if (config.mUsingGradle) {
-            final boolean resourceArscChanged = modifiedSet.contains(TypedValue.RES_ARSC)
-                || largeModifiedSet.contains(TypedValue.RES_ARSC);
             final boolean ignoreWarning = config.mIgnoreWarning;
-
-            if (resourceArscChanged && !config.mUseApplyResource) {
+            if (arscChanged && !config.mUseApplyResource) {
                 if (ignoreWarning) {
                     //ignoreWarning, just log
                     Logger.e("Warning:ignoreWarning is true, but resources.arsc is changed, you should use applyResourceMapping mode to build the new apk, otherwise, it may be crash at some times");
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/DexPatchGenerator.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/DexPatchGenerator.java
index 8bbe973b..d058b2d0 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/DexPatchGenerator.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/DexPatchGenerator.java
@@ -547,173 +547,129 @@ private void writeResultToStream(OutputStream os) throws IOException {
         buffer.writeInt(firstChunkOffset);
         buffer.position(firstChunkOffset);
 
-        new PatchOperationsWriter<StringData>(this.stringDataSectionDiffAlg.getPatchOperationList()) {
-            @Override
-            protected void writeItem(DexDataBuffer buffer, StringData item) {
-                buffer.writeStringData(item);
-            }
-        }.writeToBuffer(buffer);
-
-        new PatchOperationsWriter<Integer>(this.typeIdSectionDiffAlg.getPatchOperationList()) {
-            @Override
-            protected void writeItem(DexDataBuffer buffer, Integer item) {
-                buffer.writeInt(item);
-            }
-        }.writeToBuffer(buffer);
-
-        new PatchOperationsWriter<TypeList>(this.typeListSectionDiffAlg.getPatchOperationList()) {
-            @Override
-            protected void writeItem(DexDataBuffer buffer, TypeList item) {
-                buffer.writeTypeList(item);
-            }
-        }.writeToBuffer(buffer);
-
-        new PatchOperationsWriter<ProtoId>(this.protoIdSectionDiffAlg.getPatchOperationList()) {
-            @Override
-            protected void writeItem(DexDataBuffer buffer, ProtoId item) {
-                buffer.writeProtoId(item);
-            }
-        }.writeToBuffer(buffer);
-
-        new PatchOperationsWriter<FieldId>(this.fieldIdSectionDiffAlg.getPatchOperationList()) {
-            @Override
-            protected void writeItem(DexDataBuffer buffer, FieldId item) {
-                buffer.writeFieldId(item);
-            }
-        }.writeToBuffer(buffer);
-
-        new PatchOperationsWriter<MethodId>(this.methodIdSectionDiffAlg.getPatchOperationList()) {
-            @Override
-            protected void writeItem(DexDataBuffer buffer, MethodId item) {
-                buffer.writeMethodId(item);
-            }
-        }.writeToBuffer(buffer);
-
-        new PatchOperationsWriter<Annotation>(this.annotationSectionDiffAlg.getPatchOperationList()) {
-            @Override
-            protected void writeItem(DexDataBuffer buffer, Annotation item) {
-                buffer.writeAnnotation(item);
-            }
-        }.writeToBuffer(buffer);
-
-        new PatchOperationsWriter<AnnotationSet>(this.annotationSetSectionDiffAlg.getPatchOperationList()) {
-            @Override
-            protected void writeItem(DexDataBuffer buffer, AnnotationSet item) {
-                buffer.writeAnnotationSet(item);
-            }
-        }.writeToBuffer(buffer);
-
-        new PatchOperationsWriter<AnnotationSetRefList>(this.annotationSetRefListSectionDiffAlg.getPatchOperationList()) {
-            @Override
-            protected void writeItem(DexDataBuffer buffer, AnnotationSetRefList item) {
-                buffer.writeAnnotationSetRefList(item);
-            }
-        }.writeToBuffer(buffer);
-
-        new PatchOperationsWriter<AnnotationsDirectory>(this.annotationsDirectorySectionDiffAlg.getPatchOperationList()) {
-            @Override
-            protected void writeItem(DexDataBuffer buffer, AnnotationsDirectory item) {
-                buffer.writeAnnotationsDirectory(item);
-            }
-        }.writeToBuffer(buffer);
-
-        new PatchOperationsWriter<DebugInfoItem>(this.debugInfoSectionDiffAlg.getPatchOperationList()) {
-            @Override
-            protected void writeItem(DexDataBuffer buffer, DebugInfoItem item) {
-                buffer.writeDebugInfoItem(item);
-            }
-        }.writeToBuffer(buffer);
-
-        new PatchOperationsWriter<Code>(this.codeSectionDiffAlg.getPatchOperationList()) {
-            @Override
-            protected void writeItem(DexDataBuffer buffer, Code item) {
-                buffer.writeCode(item);
-            }
-        }.writeToBuffer(buffer);
-
-        new PatchOperationsWriter<ClassData>(this.classDataSectionDiffAlg.getPatchOperationList()) {
-            @Override
-            protected void writeItem(DexDataBuffer buffer, ClassData item) {
-                buffer.writeClassData(item);
-            }
-        }.writeToBuffer(buffer);
-
-        new PatchOperationsWriter<EncodedValue>(this.encodedArraySectionDiffAlg.getPatchOperationList()) {
-            @Override
-            protected void writeItem(DexDataBuffer buffer, EncodedValue item) {
-                buffer.writeEncodedArray(item);
-            }
-        }.writeToBuffer(buffer);
-
-        new PatchOperationsWriter<ClassDef>(this.classDefSectionDiffAlg.getPatchOperationList()) {
-            @Override
-            protected void writeItem(DexDataBuffer buffer, ClassDef item) {
-                buffer.writeClassDef(item);
-            }
-        }.writeToBuffer(buffer);
+        writePatchOperations(buffer, this.stringDataSectionDiffAlg.getPatchOperationList());
+        writePatchOperations(buffer, this.typeIdSectionDiffAlg.getPatchOperationList());
+        writePatchOperations(buffer, this.typeListSectionDiffAlg.getPatchOperationList());
+        writePatchOperations(buffer, this.protoIdSectionDiffAlg.getPatchOperationList());
+        writePatchOperations(buffer, this.fieldIdSectionDiffAlg.getPatchOperationList());
+        writePatchOperations(buffer, this.methodIdSectionDiffAlg.getPatchOperationList());
+        writePatchOperations(buffer, this.annotationSectionDiffAlg.getPatchOperationList());
+        writePatchOperations(buffer, this.annotationSetSectionDiffAlg.getPatchOperationList());
+        writePatchOperations(buffer, this.annotationSetRefListSectionDiffAlg.getPatchOperationList());
+        writePatchOperations(buffer, this.annotationsDirectorySectionDiffAlg.getPatchOperationList());
+        writePatchOperations(buffer, this.debugInfoSectionDiffAlg.getPatchOperationList());
+        writePatchOperations(buffer, this.codeSectionDiffAlg.getPatchOperationList());
+        writePatchOperations(buffer, this.classDataSectionDiffAlg.getPatchOperationList());
+        writePatchOperations(buffer, this.encodedArraySectionDiffAlg.getPatchOperationList());
+        writePatchOperations(buffer, this.classDefSectionDiffAlg.getPatchOperationList());
 
         byte[] bufferData = buffer.array();
         os.write(bufferData);
         os.flush();
     }
 
-    private abstract class PatchOperationsWriter<T> {
-        private final List<PatchOperation<T>> patchOperationList;
-
-        PatchOperationsWriter(List<PatchOperation<T>> patchOperationList) {
-            this.patchOperationList = patchOperationList;
-        }
-
-        protected abstract void writeItem(DexDataBuffer buffer, T item);
-
-        public final void writeToBuffer(DexDataBuffer buffer) {
-            List<Integer> delOpIndexList = new ArrayList<>(patchOperationList.size());
-            List<Integer> addOpIndexList = new ArrayList<>(patchOperationList.size());
-            List<Integer> replaceOpIndexList = new ArrayList<>(patchOperationList.size());
-            List<T> newItemList = new ArrayList<>(patchOperationList.size());
-
-            for (PatchOperation<T> patchOperation : patchOperationList) {
-                switch (patchOperation.op) {
-                    case PatchOperation.OP_DEL: {
-                        delOpIndexList.add(patchOperation.index);
-                        break;
-                    }
-                    case PatchOperation.OP_ADD: {
-                        addOpIndexList.add(patchOperation.index);
-                        newItemList.add(patchOperation.newItem);
-                        break;
-                    }
-                    case PatchOperation.OP_REPLACE: {
-                        replaceOpIndexList.add(patchOperation.index);
-                        newItemList.add(patchOperation.newItem);
-                        break;
-                    }
+    private <T extends Comparable<T>> void writePatchOperations(
+            DexDataBuffer buffer, List<PatchOperation<T>> patchOperationList
+    ) {
+        List<Integer> delOpIndexList = new ArrayList<>(patchOperationList.size());
+        List<Integer> addOpIndexList = new ArrayList<>(patchOperationList.size());
+        List<Integer> replaceOpIndexList = new ArrayList<>(patchOperationList.size());
+        List<T> newItemList = new ArrayList<>(patchOperationList.size());
+
+        for (PatchOperation<T> patchOperation : patchOperationList) {
+            switch (patchOperation.op) {
+                case PatchOperation.OP_DEL: {
+                    delOpIndexList.add(patchOperation.index);
+                    break;
+                }
+                case PatchOperation.OP_ADD: {
+                    addOpIndexList.add(patchOperation.index);
+                    newItemList.add(patchOperation.newItem);
+                    break;
+                }
+                case PatchOperation.OP_REPLACE: {
+                    replaceOpIndexList.add(patchOperation.index);
+                    newItemList.add(patchOperation.newItem);
+                    break;
                 }
             }
+        }
 
-            buffer.writeUleb128(delOpIndexList.size());
-            int lastIndex = 0;
-            for (Integer index : delOpIndexList) {
-                buffer.writeSleb128(index - lastIndex);
-                lastIndex = index;
-            }
+        buffer.writeUleb128(delOpIndexList.size());
+        int lastIndex = 0;
+        for (Integer index : delOpIndexList) {
+            buffer.writeSleb128(index - lastIndex);
+            lastIndex = index;
+        }
 
-            buffer.writeUleb128(addOpIndexList.size());
-            lastIndex = 0;
-            for (Integer index : addOpIndexList) {
-                buffer.writeSleb128(index - lastIndex);
-                lastIndex = index;
-            }
+        buffer.writeUleb128(addOpIndexList.size());
+        lastIndex = 0;
+        for (Integer index : addOpIndexList) {
+            buffer.writeSleb128(index - lastIndex);
+            lastIndex = index;
+        }
 
-            buffer.writeUleb128(replaceOpIndexList.size());
-            lastIndex = 0;
-            for (Integer index : replaceOpIndexList) {
-                buffer.writeSleb128(index - lastIndex);
-                lastIndex = index;
-            }
+        buffer.writeUleb128(replaceOpIndexList.size());
+        lastIndex = 0;
+        for (Integer index : replaceOpIndexList) {
+            buffer.writeSleb128(index - lastIndex);
+            lastIndex = index;
+        }
 
-            for (T newItem : newItemList) {
-                writeItem(buffer, newItem);
+        for (T newItem : newItemList) {
+            if (newItem instanceof StringData) {
+                buffer.writeStringData((StringData) newItem);
+            } else
+            if (newItem instanceof Integer) {
+                // TypeId item.
+                buffer.writeInt((Integer) newItem);
+            } else
+            if (newItem instanceof TypeList) {
+                buffer.writeTypeList((TypeList) newItem);
+            } else
+            if (newItem instanceof ProtoId) {
+                buffer.writeProtoId((ProtoId) newItem);
+            } else
+            if (newItem instanceof FieldId) {
+                buffer.writeFieldId((FieldId) newItem);
+            } else
+            if (newItem instanceof MethodId) {
+                buffer.writeMethodId((MethodId) newItem);
+            } else
+            if (newItem instanceof Annotation) {
+                buffer.writeAnnotation((Annotation) newItem);
+            } else
+            if (newItem instanceof AnnotationSet) {
+                buffer.writeAnnotationSet((AnnotationSet) newItem);
+            } else
+            if (newItem instanceof AnnotationSetRefList) {
+                buffer.writeAnnotationSetRefList(
+                        (AnnotationSetRefList) newItem
+                );
+            } else
+            if (newItem instanceof AnnotationsDirectory) {
+                buffer.writeAnnotationsDirectory(
+                        (AnnotationsDirectory) newItem
+                );
+            } else
+            if (newItem instanceof DebugInfoItem) {
+                buffer.writeDebugInfoItem((DebugInfoItem) newItem);
+            } else
+            if (newItem instanceof Code) {
+                buffer.writeCode((Code) newItem);
+            } else
+            if (newItem instanceof ClassData) {
+                buffer.writeClassData((ClassData) newItem);
+            } else
+            if (newItem instanceof EncodedValue) {
+                buffer.writeEncodedArray((EncodedValue) newItem);
+            } else
+            if (newItem instanceof ClassDef) {
+                buffer.writeClassDef((ClassDef) newItem);
+            } else {
+                throw new IllegalStateException(
+                        "Unknown item type: " + newItem.getClass()
+                );
             }
         }
     }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/DexSectionDiffAlgorithm.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/DexSectionDiffAlgorithm.java
index 9bf57a8e..9c3f9671 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/DexSectionDiffAlgorithm.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/DexSectionDiffAlgorithm.java
@@ -179,6 +179,16 @@ protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffse
 
     /**
      * Mark deleted index or offset in {@code indexMap}.
+     *
+     * Here we mark deleted item for such a case like this:
+     *   Item in DebugInfo section reference a string in StringData section
+     *   by index X, while in patched dex, the referenced string is removed.
+     *
+     * The {@code indexMap} must be aware of this case and return -1
+     * instead of the original value X.
+     *
+     * Further more, the special value -1 is not chosen by our inspiration but
+     * the definition of NO_INDEX in document of dex file format.
      */
     protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
         // Should override by subclass if needed.
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/RefToRefAffectedClassInsnVisitor.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/RefToRefAffectedClassInsnVisitor.java
new file mode 100644
index 00000000..8158746a
--- /dev/null
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/RefToRefAffectedClassInsnVisitor.java
@@ -0,0 +1,136 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.build.dexpatcher.util;
+
+import com.tencent.tinker.android.dex.ClassData;
+import com.tencent.tinker.android.dex.Dex;
+import com.tencent.tinker.android.dex.FieldId;
+import com.tencent.tinker.android.dex.MethodId;
+import com.tencent.tinker.android.dex.ProtoId;
+import com.tencent.tinker.android.dx.instruction.InstructionCodec;
+import com.tencent.tinker.android.dx.instruction.InstructionVisitor;
+import com.tencent.tinker.commons.dexpatcher.DexPatcherLogger;
+
+import java.util.Collection;
+
+/**
+ * Created by tangyinsheng on 2016/10/8.
+ */
+
+public class RefToRefAffectedClassInsnVisitor extends InstructionVisitor {
+    private static final String TAG = "RefToRefAffectedClassInsnVisitor";
+
+    private final Dex methodOwner;
+    private final ClassData.Method method;
+    private final Collection<String> refAffectedClassDefs;
+    private final DexPatcherLogger logger;
+
+    public boolean isMethodReferencedToRefAffectedClass;
+
+    RefToRefAffectedClassInsnVisitor(Dex methodOwner, ClassData.Method method, Collection<String> refAffectedClassDefs, DexPatcherLogger logger) {
+        super(null);
+        this.methodOwner = methodOwner;
+        this.method = method;
+        this.refAffectedClassDefs = refAffectedClassDefs;
+        this.logger = logger;
+        this.isMethodReferencedToRefAffectedClass = false;
+    }
+
+    @Override
+    public void visitZeroRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal) {
+        processIndexByType(index, indexType);
+    }
+
+    @Override
+    public void visitOneRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a) {
+        processIndexByType(index, indexType);
+    }
+
+    @Override
+    public void visitTwoRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int b) {
+        processIndexByType(index, indexType);
+    }
+
+    @Override
+    public void visitThreeRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int b, int c) {
+        processIndexByType(index, indexType);
+    }
+
+    @Override
+    public void visitFourRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int b, int c, int d) {
+        processIndexByType(index, indexType);
+    }
+
+    @Override
+    public void visitFiveRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int b, int c, int d, int e) {
+        processIndexByType(index, indexType);
+    }
+
+    @Override
+    public void visitRegisterRangeInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int registerCount) {
+        processIndexByType(index, indexType);
+    }
+
+    private void processIndexByType(int index, int indexType) {
+        String typeName = null;
+        String refInfoInLog = null;
+        switch (indexType) {
+            case InstructionCodec.INDEX_TYPE_TYPE_REF: {
+                typeName = methodOwner.typeNames().get(index);
+                refInfoInLog = "init ref-changed class";
+                break;
+            }
+            case InstructionCodec.INDEX_TYPE_FIELD_REF: {
+                final FieldId fieldId = methodOwner.fieldIds().get(index);
+                typeName = methodOwner.typeNames().get(fieldId.declaringClassIndex);
+                refInfoInLog = "referencing to field: " + methodOwner.strings().get(fieldId.nameIndex);
+                break;
+            }
+            case InstructionCodec.INDEX_TYPE_METHOD_REF: {
+                final MethodId methodId = methodOwner.methodIds().get(index);
+                typeName = methodOwner.typeNames().get(methodId.declaringClassIndex);
+                refInfoInLog = "invoking method: " + getMethodProtoTypeStr(methodId);
+                break;
+            }
+        }
+        if (typeName != null && refAffectedClassDefs.contains(typeName)) {
+            MethodId methodId = methodOwner.methodIds().get(method.methodIndex);
+            logger.i(
+                    TAG,
+                    "Method %s in class %s referenced ref-changed class %s by %s",
+                    getMethodProtoTypeStr(methodId),
+                    methodOwner.typeNames().get(methodId.declaringClassIndex),
+                    typeName,
+                    refInfoInLog
+            );
+            isMethodReferencedToRefAffectedClass = true;
+        }
+    }
+
+    private String getMethodProtoTypeStr(MethodId methodId) {
+        StringBuilder strBuilder = new StringBuilder();
+        strBuilder.append(methodOwner.strings().get(methodId.nameIndex));
+        ProtoId protoId = methodOwner.protoIds().get(methodId.protoIndex);
+        strBuilder.append('(');
+        short[] paramTypeIds = methodOwner.parameterTypeIndicesFromMethodId(methodId);
+        for (short typeId : paramTypeIds) {
+            strBuilder.append(methodOwner.typeNames().get(typeId));
+        }
+        strBuilder.append(')').append(methodOwner.typeNames().get(protoId.returnTypeIndex));
+        return strBuilder.toString();
+    }
+}
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/SmallDexClassInfoCollector.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/SmallDexClassInfoCollector.java
new file mode 100644
index 00000000..f9be6337
--- /dev/null
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/SmallDexClassInfoCollector.java
@@ -0,0 +1,162 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.build.dexpatcher.util;
+
+import com.tencent.tinker.android.dex.ClassData;
+import com.tencent.tinker.android.dex.Code;
+import com.tencent.tinker.android.dex.Dex;
+import com.tencent.tinker.android.dx.instruction.InstructionReader;
+import com.tencent.tinker.android.dx.instruction.ShortArrayCodeInput;
+import com.tencent.tinker.build.util.DexClassesComparator;
+import com.tencent.tinker.build.util.DexClassesComparator.DexClassInfo;
+import com.tencent.tinker.build.util.DexClassesComparator.DexGroup;
+import com.tencent.tinker.commons.dexpatcher.DexPatcherLogger;
+
+import java.io.EOFException;
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.Set;
+
+/**
+ * Created by tangyinsheng on 2016/10/8.
+ */
+
+public final class SmallDexClassInfoCollector {
+    private static final String TAG = "SmallDexClassInfoCollector";
+
+    private static final DexPatcherLogger logger = new DexPatcherLogger();
+    private final Set<String> loaderClassPatterns = new HashSet<>();
+
+    public SmallDexClassInfoCollector setLoaderClassPatterns(Collection<String> loaderClassPatterns) {
+        this.loaderClassPatterns.clear();
+        this.loaderClassPatterns.addAll(loaderClassPatterns);
+        return this;
+    }
+
+    public SmallDexClassInfoCollector addLoaderClassPattern(String loaderClassPattern) {
+        this.loaderClassPatterns.add(loaderClassPattern);
+        return this;
+    }
+
+    public SmallDexClassInfoCollector clearLoaderClassPattern() {
+        this.loaderClassPatterns.clear();
+        return this;
+    }
+
+    public SmallDexClassInfoCollector setLogger(DexPatcherLogger.IDexPatcherLogger loggerImpl) {
+        this.logger.setLoggerImpl(loggerImpl);
+        return this;
+    }
+
+    public Set<DexClassInfo> doCollect(DexGroup oldDexGroup, DexGroup newDexGroup) {
+        DexClassesComparator dexClassesCmp = new DexClassesComparator("*");
+        dexClassesCmp.setCompareMode(DexClassesComparator.COMPARE_MODE_CAUSE_REF_CHANGE_ONLY);
+        dexClassesCmp.setIgnoredRemovedClassDescPattern(this.loaderClassPatterns);
+        dexClassesCmp.startCheck(oldDexGroup, newDexGroup);
+
+        Set<String> refAffectedClassDescs
+                = dexClassesCmp.getChangedClassDescToInfosMap().keySet();
+
+        Set<DexClassInfo> classInfosInNewDexGroup
+                = newDexGroup.getClassInfosInDexesWithDuplicateCheck();
+
+        Set<DexClassInfo> classInfosOfSmallDex = new HashSet<>();
+
+        for (DexClassInfo patchedClassInfo : classInfosInNewDexGroup) {
+            if (patchedClassInfo.classDef.classDataOffset == 0) {
+                continue;
+            }
+
+            ClassData patchedClassData
+                    = patchedClassInfo.owner.readClassData(patchedClassInfo.classDef);
+
+            boolean shouldAdd = isClassMethodReferenceToRefAffectedClass(
+                    patchedClassInfo.owner,
+                    patchedClassData.directMethods,
+                    refAffectedClassDescs
+            );
+
+            if (!shouldAdd) {
+                shouldAdd = isClassMethodReferenceToRefAffectedClass(
+                        patchedClassInfo.owner,
+                        patchedClassData.virtualMethods,
+                        refAffectedClassDescs
+                );
+            }
+
+            if (shouldAdd) {
+                logger.i(TAG, "Add class %s to small dex.", patchedClassInfo.classDesc);
+                classInfosOfSmallDex.add(patchedClassInfo);
+            }
+        }
+
+        // So far we get descriptors of classes we need to add additionally,
+        // while we still need to do a fully compare to collect added classes
+        // and replaced classes since they may use items in their owner dex which
+        // is not modified.
+        dexClassesCmp.setCompareMode(DexClassesComparator.COMPARE_MODE_NORMAL);
+        dexClassesCmp.startCheck(oldDexGroup, newDexGroup);
+
+        Collection<DexClassInfo> addedClassInfos = dexClassesCmp.getAddedClassInfos();
+        for (DexClassInfo addClassInfo : addedClassInfos) {
+            logger.i(TAG, "Add class %s to small dex.", addClassInfo.classDesc);
+            classInfosOfSmallDex.add(addClassInfo);
+        }
+
+        Collection<DexClassInfo[]> changedOldPatchedClassInfos =
+                dexClassesCmp.getChangedClassDescToInfosMap().values();
+
+        // changedOldPatchedClassInfo[1] means changedPatchedClassInfo
+        for (DexClassInfo[] changedOldPatchedClassInfo : changedOldPatchedClassInfos) {
+            logger.i(TAG, "Add class %s to small dex.", changedOldPatchedClassInfo[1].classDesc);
+            classInfosOfSmallDex.add(changedOldPatchedClassInfo[1]);
+        }
+
+        return classInfosOfSmallDex;
+    }
+
+    private boolean isClassMethodReferenceToRefAffectedClass(
+            Dex owner,
+            ClassData.Method[] methods,
+            Collection<String> affectedClassDescs
+    ) {
+        if (affectedClassDescs.isEmpty() || methods == null || methods.length == 0) {
+            return false;
+        }
+
+        for (ClassData.Method method : methods) {
+            if (method.codeOffset == 0) {
+                continue;
+            }
+            Code code = owner.readCode(method);
+            RefToRefAffectedClassInsnVisitor refInsnVisitor =
+                    new RefToRefAffectedClassInsnVisitor(owner, method, affectedClassDescs, logger);
+            InstructionReader insnReader =
+                    new InstructionReader(new ShortArrayCodeInput(code.instructions));
+            try {
+                insnReader.accept(refInsnVisitor);
+                if (refInsnVisitor.isMethodReferencedToRefAffectedClass) {
+                    return true;
+                }
+            } catch (EOFException e) {
+                throw new IllegalStateException(e);
+            }
+        }
+
+        return false;
+    }
+}
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/SmallDexPatchGenerator.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/SmallDexPatchGenerator.java
index dd805303..d56b2a1e 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/SmallDexPatchGenerator.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/SmallDexPatchGenerator.java
@@ -44,7 +44,6 @@
 import com.tencent.tinker.android.dx.instruction.ShortArrayCodeInput;
 import com.tencent.tinker.android.dx.util.Hex;
 import com.tencent.tinker.android.dx.util.IndexMap;
-import com.tencent.tinker.build.util.DexClassesComparator;
 import com.tencent.tinker.build.util.DexClassesComparator.DexClassInfo;
 import com.tencent.tinker.build.util.DexClassesComparator.DexGroup;
 import com.tencent.tinker.commons.dexpatcher.DexPatcherLogger;
@@ -737,104 +736,17 @@ private void writeDataChunk(
         }
     }
 
-    private boolean isClassMethodReferenceToRefAffectedClass(
-            Dex owner,
-            ClassData.Method[] methods,
-            Collection<String> affectedClassDescs
-    ) {
-        if (affectedClassDescs.isEmpty() || methods == null || methods.length == 0) {
-            return false;
-        }
-
-        for (ClassData.Method method : methods) {
-            if (method.codeOffset == 0) {
-                continue;
-            }
-            Code code = owner.readCode(method);
-            RefToRefAffectedClassInsnVisitor refInsnVisitor =
-                    new RefToRefAffectedClassInsnVisitor(owner, method, affectedClassDescs);
-            InstructionReader insnReader =
-                    new InstructionReader(new ShortArrayCodeInput(code.instructions));
-            try {
-                insnReader.accept(refInsnVisitor);
-                if (refInsnVisitor.isMethodReferencedToRefAffectedClass) {
-                    return true;
-                }
-            } catch (EOFException e) {
-                throw new IllegalStateException(e);
-            }
-        }
-
-        return false;
-    }
-
     private void collectItemIndicesFromDexGroup(
             DexGroup oldDexGroup,
             DexGroup patchedDexGroup
     ) {
-        DexClassesComparator dexClassesCmp = new DexClassesComparator("*");
-        dexClassesCmp.setCompareMode(DexClassesComparator.COMPARE_MODE_CAUSE_REF_CHANGE_ONLY);
-        dexClassesCmp.setIgnoredRemovedClassDescPattern(this.loaderClassPatterns);
-        dexClassesCmp.startCheck(oldDexGroup, patchedDexGroup);
-
-        Set<String> refAffectedClassDescs
-                = dexClassesCmp.getChangedClassDescToInfosMap().keySet();
-
-        Set<DexClassInfo> classInfosInPatchedDexGroup
-                = patchedDexGroup.getClassInfosInDexesWithDuplicateCheck();
-
-        Set<DexClassInfo> patchedClassInfosForItemIndexCollecting = new HashSet<>();
-
-        for (DexClassInfo patchedClassInfo : classInfosInPatchedDexGroup) {
-            if (patchedClassInfo.classDef.classDataOffset == 0) {
-                continue;
-            }
-            ClassData patchedClassData
-                    = patchedClassInfo.owner.readClassData(patchedClassInfo.classDef);
-
-            boolean shouldAdd = isClassMethodReferenceToRefAffectedClass(
-                    patchedClassInfo.owner,
-                    patchedClassData.directMethods,
-                    refAffectedClassDescs
-            );
-
-            if (!shouldAdd) {
-                shouldAdd = isClassMethodReferenceToRefAffectedClass(
-                        patchedClassInfo.owner,
-                        patchedClassData.virtualMethods,
-                        refAffectedClassDescs
-                );
-            }
-
-            if (shouldAdd) {
-                logger.i(TAG, "Add class %s to small patched dex.", patchedClassInfo.classDesc);
-                patchedClassInfosForItemIndexCollecting.add(patchedClassInfo);
-            }
-        }
-
-        // So far we get descriptors of classes we need to add additionally,
-        // while we still need to do a fully compare to collect added classes
-        // and replaced classes since they may use items in their owner dex which
-        // is not modified.
-        dexClassesCmp.setCompareMode(DexClassesComparator.COMPARE_MODE_NORMAL);
-        dexClassesCmp.startCheck(oldDexGroup, patchedDexGroup);
-
-        Collection<DexClassInfo> addedClassInfos = dexClassesCmp.getAddedClassInfos();
-        for (DexClassInfo addClassInfo : addedClassInfos) {
-            logger.i(TAG, "Add class %s to small patched dex.", addClassInfo.classDesc);
-            patchedClassInfosForItemIndexCollecting.add(addClassInfo);
-        }
-
-        Collection<DexClassInfo[]> changedOldPatchedClassInfos =
-                dexClassesCmp.getChangedClassDescToInfosMap().values();
+        SmallDexClassInfoCollector smallDexClassInfoCollector = new SmallDexClassInfoCollector();
+        smallDexClassInfoCollector.setLoaderClassPatterns(this.loaderClassPatterns);
+        smallDexClassInfoCollector.setLogger(this.logger.getLoggerImpl());
+        Set<DexClassInfo> patchedClassInfosForItemIndexCollecting =
+                smallDexClassInfoCollector.doCollect(oldDexGroup, patchedDexGroup);
 
-        // changedOldPatchedClassInfo[1] means changedPatchedClassInfo
-        for (DexClassInfo[] changedOldPatchedClassInfo : changedOldPatchedClassInfos) {
-            logger.i(TAG, "Add class %s to small patched dex.", changedOldPatchedClassInfo[1].classDesc);
-            patchedClassInfosForItemIndexCollecting.add(changedOldPatchedClassInfo[1]);
-        }
-
-        // Finally we collect all elements' indices of collected class.
+        // Collect all elements' indices of collected class.
 
         Map<Dex, OffsetToIndexConverter> dexToOffsetToIndexConverterMap = new HashMap<>();
 
@@ -1787,105 +1699,6 @@ public int simulate(int smallPatchBaseOffset) {
         }
     }
 
-    private class RefToRefAffectedClassInsnVisitor extends InstructionVisitor {
-        private final Dex methodOwner;
-        private final ClassData.Method method;
-        private final Collection<String> refAffectedClassDefs;
-        private boolean isMethodReferencedToRefAffectedClass;
-
-        RefToRefAffectedClassInsnVisitor(Dex methodOwner, ClassData.Method method, Collection<String> refAffectedClassDefs) {
-            super(null);
-            this.methodOwner = methodOwner;
-            this.method = method;
-            this.refAffectedClassDefs = refAffectedClassDefs;
-            this.isMethodReferencedToRefAffectedClass = false;
-        }
-
-        @Override
-        public void visitZeroRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal) {
-            processIndexByType(index, indexType);
-        }
-
-        @Override
-        public void visitOneRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a) {
-            processIndexByType(index, indexType);
-        }
-
-        @Override
-        public void visitTwoRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int b) {
-            processIndexByType(index, indexType);
-        }
-
-        @Override
-        public void visitThreeRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int b, int c) {
-            processIndexByType(index, indexType);
-        }
-
-        @Override
-        public void visitFourRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int b, int c, int d) {
-            processIndexByType(index, indexType);
-        }
-
-        @Override
-        public void visitFiveRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int b, int c, int d, int e) {
-            processIndexByType(index, indexType);
-        }
-
-        @Override
-        public void visitRegisterRangeInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int registerCount) {
-            processIndexByType(index, indexType);
-        }
-
-        private void processIndexByType(int index, int indexType) {
-            String typeName = null;
-            String refInfoInLog = null;
-            switch (indexType) {
-                case InstructionCodec.INDEX_TYPE_TYPE_REF: {
-                    typeName = methodOwner.typeNames().get(index);
-                    refInfoInLog = "init ref-changed class";
-                    break;
-                }
-                case InstructionCodec.INDEX_TYPE_FIELD_REF: {
-                    final FieldId fieldId = methodOwner.fieldIds().get(index);
-                    typeName = methodOwner.typeNames().get(fieldId.declaringClassIndex);
-                    refInfoInLog = "referencing to field: " + methodOwner.strings().get(fieldId.nameIndex);
-                    break;
-                }
-                case InstructionCodec.INDEX_TYPE_METHOD_REF: {
-                    final MethodId methodId = methodOwner.methodIds().get(index);
-                    typeName = methodOwner.typeNames().get(methodId.declaringClassIndex);
-                    refInfoInLog = "invoking method: " + getMethodProtoTypeStr(methodId);
-                    break;
-                }
-            }
-            if (typeName != null && refAffectedClassDefs.contains(typeName)) {
-                MethodId methodId = methodOwner.methodIds().get(method.methodIndex);
-                logger.i(
-                        TAG,
-                        "Method %s in class %s referenced ref-changed class %s by %s",
-                        getMethodProtoTypeStr(methodId),
-                        methodOwner.typeNames().get(methodId.declaringClassIndex),
-                        typeName,
-                        refInfoInLog
-                );
-                isMethodReferencedToRefAffectedClass = true;
-            }
-        }
-
-        private String getMethodProtoTypeStr(MethodId methodId) {
-            StringBuilder strBuilder = new StringBuilder();
-            strBuilder.append(methodOwner.strings().get(methodId.nameIndex));
-            ProtoId protoId = methodOwner.protoIds().get(methodId.protoIndex);
-            strBuilder.append('(');
-            short[] paramTypeIds = methodOwner.parameterTypeIndicesFromMethodId(methodId);
-            for (short typeId : paramTypeIds) {
-                strBuilder.append(methodOwner.typeNames().get(typeId));
-            }
-            strBuilder.append(')').append(methodOwner.typeNames().get(protoId.returnTypeIndex));
-            return strBuilder.toString();
-        }
-    }
-
     private class IndicesCollectorInsnVisitor extends InstructionVisitor {
         private final Dex ownerDex;
         private final OffsetToIndexConverter offsetToIndexConverter;
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/info/PatchInfoGen.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/info/PatchInfoGen.java
index a097f658..39ad80ef 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/info/PatchInfoGen.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/info/PatchInfoGen.java
@@ -16,7 +16,7 @@
 
 package com.tencent.tinker.build.info;
 
-import com.tencent.tinker.build.apkparser.AndroidManifest;
+import com.tencent.tinker.build.apkparser.AndroidParser;
 import com.tencent.tinker.build.patch.Configuration;
 import com.tencent.tinker.build.util.TinkerPatchException;
 import com.tencent.tinker.build.util.TypedValue;
@@ -41,7 +41,7 @@ public PatchInfoGen(Configuration config) {
 
     private void addTinkerID() throws IOException, ParseException {
         if (!config.mPackageFields.containsKey(TypedValue.TINKER_ID)) {
-            AndroidManifest oldAndroidManifest = AndroidManifest.getAndroidManifest(config.mOldApkFile);
+            AndroidParser oldAndroidManifest = AndroidParser.getAndroidManifest(config.mOldApkFile);
             String tinkerID = oldAndroidManifest.metaDatas.get(TypedValue.TINKER_ID);
 
             if (tinkerID == null) {
@@ -51,7 +51,7 @@ private void addTinkerID() throws IOException, ParseException {
         }
 
         if (!config.mPackageFields.containsKey(TypedValue.NEW_TINKER_ID)) {
-            AndroidManifest newAndroidManifest = AndroidManifest.getAndroidManifest(config.mNewApkFile);
+            AndroidParser newAndroidManifest = AndroidParser.getAndroidManifest(config.mNewApkFile);
             String tinkerID = newAndroidManifest.metaDatas.get(TypedValue.TINKER_ID);
 
             if (tinkerID == null) {
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/Configuration.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/Configuration.java
index 9b359eb5..e1823c93 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/Configuration.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/Configuration.java
@@ -83,6 +83,7 @@
     public File             mOldApkFile;
     public File             mNewApkFile;
     public boolean          mIgnoreWarning;
+    public boolean          mUsePreGeneratedPatchDex;
     /**
      * lib config
      */
@@ -213,6 +214,8 @@ public Configuration(InputParam param) throws IOException, TinkerPatchException
         mOutFolder = param.outFolder;
 
         mIgnoreWarning = param.ignoreWarning;
+        mUsePreGeneratedPatchDex = param.usePreGeneratedPatchDex;
+
         mSevenZipPath = param.sevenZipPath;
         mPackageFields = param.configFields;
 
@@ -234,6 +237,7 @@ public String toString() {
         sb.append("newApk:" + mNewApkPath + "\n");
         sb.append("outputFolder:" + mOutFolder + "\n");
         sb.append("isIgnoreWarning:" + mIgnoreWarning + "\n");
+        sb.append("isInsertStubMode:" + mUsePreGeneratedPatchDex + "\n");
         sb.append("7-ZipPath:" + mSevenZipPath + "\n");
         sb.append("useSignAPk:" + mUseSignAPk + "\n");
 
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/InputParam.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/InputParam.java
index 6a217f47..348f431a 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/InputParam.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/InputParam.java
@@ -35,6 +35,7 @@
     public final String  storealias;
     public final String  storepass;
     public final boolean ignoreWarning;
+    public final boolean usePreGeneratedPatchDex;
     public final boolean useSign;
 
     /**
@@ -81,6 +82,7 @@ private InputParam(
         String storealias,
         String storepass,
         boolean ignoreWarning,
+        boolean usePreGeneratedPatchDex,
         boolean useSign,
 
         ArrayList<String> dexFilePattern,
@@ -103,6 +105,7 @@ private InputParam(
         this.storealias = storealias;
         this.storepass = storepass;
         this.ignoreWarning = ignoreWarning;
+        this.usePreGeneratedPatchDex = usePreGeneratedPatchDex;
         this.useSign = useSign;
 
         this.dexFilePattern = dexFilePattern;
@@ -132,6 +135,7 @@ private InputParam(
         private String  storealias;
         private String  storepass;
         private boolean ignoreWarning;
+        private boolean usePreGeneratedPatchDex;
         private boolean useSign;
 
         /**
@@ -243,6 +247,11 @@ public Builder setIgnoreWarning(boolean ignoreWarning) {
             return this;
         }
 
+        public Builder setUsePreGeneratedPatchDex(boolean usePreGeneratedPatchDex) {
+            this.usePreGeneratedPatchDex = usePreGeneratedPatchDex;
+            return this;
+        }
+
         public Builder setDexLoaderPattern(ArrayList<String> dexLoaderPattern) {
             this.dexLoaderPattern = dexLoaderPattern;
             return this;
@@ -270,25 +279,26 @@ public Builder setUseSign(boolean useSign) {
 
         public InputParam create() {
             return new InputParam(
-                oldApk,
-                newApk,
-                outFolder,
-                signFile,
-                keypass,
-                storealias,
-                storepass,
-                ignoreWarning,
-                useSign,
-                dexFilePattern,
-                dexLoaderPattern,
-                dexMode,
-                soFilePattern,
-                resourceFilePattern,
-                resourceIgnoreChangePattern,
-                largeModSize,
-                useApplyResource,
-                configFields,
-                sevenZipPath
+                    oldApk,
+                    newApk,
+                    outFolder,
+                    signFile,
+                    keypass,
+                    storealias,
+                    storepass,
+                    ignoreWarning,
+                    usePreGeneratedPatchDex,
+                    useSign,
+                    dexFilePattern,
+                    dexLoaderPattern,
+                    dexMode,
+                    soFilePattern,
+                    resourceFilePattern,
+                    resourceIgnoreChangePattern,
+                    largeModSize,
+                    useApplyResource,
+                    configFields,
+                    sevenZipPath
             );
         }
     }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/Logger.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/Logger.java
index 965b87c8..777c3245 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/Logger.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/Logger.java
@@ -34,7 +34,9 @@ public static void initLogger(Configuration config) throws IOException {
     }
 
     public static void closeLogger() {
-        logWriter.close();
+        if (logWriter != null) {
+            logWriter.close();
+        }
     }
 
     public static void d(final String msg) {
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/TypedValue.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/TypedValue.java
index 4837f67a..13120a8d 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/TypedValue.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/TypedValue.java
@@ -70,4 +70,8 @@
     public static final String LARGE_MOD_TITLE = "large modify:";
     public static final String DEL_TITLE       = "delete:";
     public static final String PATTERN_TITLE   = "pattern:";
+
+    public static final String TEST_STRING_VALUE_A = "only use for test tinker resource: a";
+    public static final String TEST_STRING_VALUE_B = "only use for test tinker resource: b";
+
 }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/org/jf/dexlib2/builder/BuilderMutableMethodImplementation.java b/tinker-build/tinker-patch-lib/src/main/java/org/jf/dexlib2/builder/BuilderMutableMethodImplementation.java
new file mode 100644
index 00000000..50d89e3e
--- /dev/null
+++ b/tinker-build/tinker-patch-lib/src/main/java/org/jf/dexlib2/builder/BuilderMutableMethodImplementation.java
@@ -0,0 +1,1142 @@
+/*
+ * Copyright 2013, Google Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ * copyright notice, this list of conditions and the following disclaimer
+ * in the documentation and/or other materials provided with the
+ * distribution.
+ *     * Neither the name of Google Inc. nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ * *** This file is NOT a part of DexLib2 project. ***
+ *
+ * Tricky ways for converting MethodImplementation in DexFile into the corresponding
+ * one in DexBuilder.
+ *
+ * If you pass null as DexBuilder, this class behavior the same as
+ * what {@link org.jf.dexlib2.builder.MutableMethodImplementation} would do.
+ */
+
+package org.jf.dexlib2.builder;
+
+import com.google.common.base.Function;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Sets;
+
+import org.jf.dexlib2.DebugItemType;
+import org.jf.dexlib2.Opcode;
+import org.jf.dexlib2.builder.debug.BuilderEndLocal;
+import org.jf.dexlib2.builder.debug.BuilderEpilogueBegin;
+import org.jf.dexlib2.builder.debug.BuilderLineNumber;
+import org.jf.dexlib2.builder.debug.BuilderPrologueEnd;
+import org.jf.dexlib2.builder.debug.BuilderRestartLocal;
+import org.jf.dexlib2.builder.debug.BuilderSetSourceFile;
+import org.jf.dexlib2.builder.debug.BuilderStartLocal;
+import org.jf.dexlib2.builder.instruction.BuilderArrayPayload;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction10t;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction10x;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction11n;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction11x;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction12x;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction20bc;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction20t;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction21c;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction21ih;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction21lh;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction21s;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction21t;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction22b;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction22c;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction22s;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction22t;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction22x;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction23x;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction25x;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction30t;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction31c;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction31i;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction31t;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction32x;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction35c;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction3rc;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction51l;
+import org.jf.dexlib2.builder.instruction.BuilderPackedSwitchPayload;
+import org.jf.dexlib2.builder.instruction.BuilderSparseSwitchPayload;
+import org.jf.dexlib2.iface.ExceptionHandler;
+import org.jf.dexlib2.iface.MethodImplementation;
+import org.jf.dexlib2.iface.TryBlock;
+import org.jf.dexlib2.iface.debug.DebugItem;
+import org.jf.dexlib2.iface.debug.EndLocal;
+import org.jf.dexlib2.iface.debug.LineNumber;
+import org.jf.dexlib2.iface.debug.RestartLocal;
+import org.jf.dexlib2.iface.debug.SetSourceFile;
+import org.jf.dexlib2.iface.debug.StartLocal;
+import org.jf.dexlib2.iface.instruction.Instruction;
+import org.jf.dexlib2.iface.instruction.SwitchElement;
+import org.jf.dexlib2.iface.instruction.formats.ArrayPayload;
+import org.jf.dexlib2.iface.instruction.formats.Instruction10t;
+import org.jf.dexlib2.iface.instruction.formats.Instruction10x;
+import org.jf.dexlib2.iface.instruction.formats.Instruction11n;
+import org.jf.dexlib2.iface.instruction.formats.Instruction11x;
+import org.jf.dexlib2.iface.instruction.formats.Instruction12x;
+import org.jf.dexlib2.iface.instruction.formats.Instruction20bc;
+import org.jf.dexlib2.iface.instruction.formats.Instruction20t;
+import org.jf.dexlib2.iface.instruction.formats.Instruction21c;
+import org.jf.dexlib2.iface.instruction.formats.Instruction21ih;
+import org.jf.dexlib2.iface.instruction.formats.Instruction21lh;
+import org.jf.dexlib2.iface.instruction.formats.Instruction21s;
+import org.jf.dexlib2.iface.instruction.formats.Instruction21t;
+import org.jf.dexlib2.iface.instruction.formats.Instruction22b;
+import org.jf.dexlib2.iface.instruction.formats.Instruction22c;
+import org.jf.dexlib2.iface.instruction.formats.Instruction22s;
+import org.jf.dexlib2.iface.instruction.formats.Instruction22t;
+import org.jf.dexlib2.iface.instruction.formats.Instruction22x;
+import org.jf.dexlib2.iface.instruction.formats.Instruction23x;
+import org.jf.dexlib2.iface.instruction.formats.Instruction25x;
+import org.jf.dexlib2.iface.instruction.formats.Instruction30t;
+import org.jf.dexlib2.iface.instruction.formats.Instruction31c;
+import org.jf.dexlib2.iface.instruction.formats.Instruction31i;
+import org.jf.dexlib2.iface.instruction.formats.Instruction31t;
+import org.jf.dexlib2.iface.instruction.formats.Instruction32x;
+import org.jf.dexlib2.iface.instruction.formats.Instruction35c;
+import org.jf.dexlib2.iface.instruction.formats.Instruction3rc;
+import org.jf.dexlib2.iface.instruction.formats.Instruction51l;
+import org.jf.dexlib2.iface.instruction.formats.PackedSwitchPayload;
+import org.jf.dexlib2.iface.instruction.formats.SparseSwitchPayload;
+import org.jf.dexlib2.iface.reference.Reference;
+import org.jf.dexlib2.iface.reference.StringReference;
+import org.jf.dexlib2.iface.reference.TypeReference;
+import org.jf.dexlib2.writer.builder.DexBuilder;
+import org.jf.util.ExceptionWithContext;
+
+import java.util.AbstractList;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
+
+/**
+ * Created by tangyinsheng on 2016/10/9.
+ */
+public class BuilderMutableMethodImplementation implements MethodImplementation {
+    private final DexBuilder dexBuilder;
+    private final int registerCount;
+    private final ArrayList<MethodLocation> instructionList = Lists.newArrayList(new MethodLocation(null, 0, 0));
+    private final ArrayList<BuilderTryBlock> tryBlocks = Lists.newArrayList();
+    private boolean fixInstructions = true;
+
+    public BuilderMutableMethodImplementation(DexBuilder dexBuilder, @Nonnull MethodImplementation methodImplementation) {
+        this.dexBuilder = dexBuilder;
+
+        this.registerCount = methodImplementation.getRegisterCount();
+
+        int codeAddress = 0;
+        int index = 0;
+
+        for (Instruction instruction : methodImplementation.getInstructions()) {
+            codeAddress += instruction.getCodeUnits();
+            index++;
+
+            instructionList.add(new MethodLocation(null, codeAddress, index));
+        }
+
+        final int[] codeAddressToIndex = new int[codeAddress + 1];
+        Arrays.fill(codeAddressToIndex, -1);
+
+        for (int i = 0; i < instructionList.size(); i++) {
+            codeAddressToIndex[instructionList.get(i).codeAddress] = i;
+        }
+
+        List<Task> switchPayloadTasks = Lists.newArrayList();
+        index = 0;
+        for (final Instruction instruction : methodImplementation.getInstructions()) {
+            final MethodLocation location = instructionList.get(index);
+            final Opcode opcode = instruction.getOpcode();
+            if (opcode == Opcode.PACKED_SWITCH_PAYLOAD || opcode == Opcode.SPARSE_SWITCH_PAYLOAD) {
+                switchPayloadTasks.add(new Task() {
+                    @Override
+                    public void perform() {
+                        convertAndSetInstruction(location, codeAddressToIndex, instruction);
+                    }
+                });
+            } else {
+                convertAndSetInstruction(location, codeAddressToIndex, instruction);
+            }
+            index++;
+        }
+
+        // the switch payload instructions must be converted last, so that any switch statements that refer to them
+        // have created the referring labels that we look for
+        for (Task switchPayloadTask : switchPayloadTasks) {
+            switchPayloadTask.perform();
+        }
+
+        for (DebugItem debugItem : methodImplementation.getDebugItems()) {
+            int debugCodeAddress = debugItem.getCodeAddress();
+            int locationIndex = mapCodeAddressToIndex(codeAddressToIndex, debugCodeAddress);
+            MethodLocation debugLocation = instructionList.get(locationIndex);
+            BuilderDebugItem builderDebugItem = convertDebugItem(debugItem);
+            debugLocation.getDebugItems().add(builderDebugItem);
+            builderDebugItem.location = debugLocation;
+        }
+
+        for (TryBlock<? extends ExceptionHandler> tryBlock : methodImplementation.getTryBlocks()) {
+            Label startLabel = newLabel(codeAddressToIndex, tryBlock.getStartCodeAddress());
+            Label endLabel = newLabel(codeAddressToIndex, tryBlock.getStartCodeAddress() + tryBlock.getCodeUnitCount());
+
+            for (ExceptionHandler exceptionHandler : tryBlock.getExceptionHandlers()) {
+                tryBlocks.add(new BuilderTryBlock(startLabel, endLabel,
+                        exceptionHandler.getExceptionTypeReference(),
+                        newLabel(codeAddressToIndex, exceptionHandler.getHandlerCodeAddress())));
+            }
+        }
+    }
+
+    public BuilderMutableMethodImplementation(int registerCount) {
+        this.dexBuilder = null;
+        this.registerCount = registerCount;
+    }
+
+    @Override
+    public int getRegisterCount() {
+        return registerCount;
+    }
+
+    @Nonnull
+    public List<BuilderInstruction> getInstructions() {
+        if (fixInstructions) {
+            fixInstructions();
+        }
+
+        return new AbstractList<BuilderInstruction>() {
+            @Override
+            public BuilderInstruction get(int i) {
+                if (i >= size()) {
+                    throw new IndexOutOfBoundsException();
+                }
+                if (fixInstructions) {
+                    fixInstructions();
+                }
+                return instructionList.get(i).instruction;
+            }
+
+            @Override
+            public int size() {
+                if (fixInstructions) {
+                    fixInstructions();
+                }
+                // don't include the last MethodLocation, which always has a null instruction
+                return instructionList.size() - 1;
+            }
+        };
+    }
+
+    @Nonnull
+    @Override
+    public List<BuilderTryBlock> getTryBlocks() {
+        if (fixInstructions) {
+            fixInstructions();
+        }
+        return Collections.unmodifiableList(tryBlocks);
+    }
+
+    @Nonnull
+    @Override
+    public Iterable<? extends DebugItem> getDebugItems() {
+        if (fixInstructions) {
+            fixInstructions();
+        }
+        return Iterables.concat(
+                Iterables.transform(instructionList, new Function<MethodLocation, Iterable<? extends DebugItem>>() {
+                    @Nullable
+                    @Override
+                    public Iterable<? extends DebugItem> apply(@Nullable MethodLocation input) {
+                        assert input != null;
+                        if (fixInstructions) {
+                            throw new IllegalStateException("This iterator was invalidated by a change to"
+                                + " this MutableMethodImplementation.");
+                        }
+                        return input.getDebugItems();
+                    }
+                }));
+    }
+
+    public void addCatch(@Nullable TypeReference type, @Nonnull Label from,
+                         @Nonnull Label to, @Nonnull Label handler) {
+        tryBlocks.add(new BuilderTryBlock(from, to, type, handler));
+    }
+
+    public void addCatch(@Nullable String type, @Nonnull Label from, @Nonnull Label to,
+                         @Nonnull Label handler) {
+        tryBlocks.add(new BuilderTryBlock(from, to, type, handler));
+    }
+
+    public void addCatch(@Nonnull Label from, @Nonnull Label to, @Nonnull Label handler) {
+        tryBlocks.add(new BuilderTryBlock(from, to, handler));
+    }
+
+    public void addInstruction(int index, BuilderInstruction instruction) {
+        // the end check here is intentially >= rather than >, because the list always includes an "empty"
+        // (null instruction) MethodLocation at the end. To add an instruction to the end of the list, the user would
+        // provide the index of this empty item, which would be size() - 1.
+        if (index >= instructionList.size()) {
+            throw new IndexOutOfBoundsException();
+        }
+
+        if (index == instructionList.size() - 1) {
+            addInstruction(instruction);
+            return;
+        }
+        int codeAddress = instructionList.get(index).getCodeAddress();
+        MethodLocation newLoc = new MethodLocation(instruction, codeAddress, index);
+        instructionList.add(index, newLoc);
+        instruction.location = newLoc;
+
+        codeAddress += instruction.getCodeUnits();
+
+        for (int i = index + 1; i < instructionList.size(); i++) {
+            MethodLocation location = instructionList.get(i);
+            location.index++;
+            location.codeAddress = codeAddress;
+            if (location.instruction != null) {
+                codeAddress += location.instruction.getCodeUnits();
+            } else {
+                // only the last MethodLocation should have a null instruction
+                assert i == instructionList.size() - 1;
+            }
+        }
+
+        this.fixInstructions = true;
+    }
+
+    public void addInstruction(@Nonnull BuilderInstruction instruction) {
+        MethodLocation last = instructionList.get(instructionList.size() - 1);
+        last.instruction = instruction;
+        instruction.location = last;
+
+        int nextCodeAddress = last.codeAddress + instruction.getCodeUnits();
+        instructionList.add(new MethodLocation(null, nextCodeAddress, instructionList.size()));
+
+        this.fixInstructions = true;
+    }
+
+    public void replaceInstruction(int index, @Nonnull BuilderInstruction replacementInstruction) {
+        if (index >= instructionList.size() - 1) {
+            throw new IndexOutOfBoundsException();
+        }
+
+        MethodLocation replaceLocation = instructionList.get(index);
+        replacementInstruction.location = replaceLocation;
+        BuilderInstruction old = replaceLocation.instruction;
+        assert old != null;
+        old.location = null;
+        replaceLocation.instruction = replacementInstruction;
+
+        // TODO: factor out index/address fix up loop
+        int codeAddress = replaceLocation.codeAddress + replaceLocation.instruction.getCodeUnits();
+        for (int i = index + 1; i < instructionList.size(); i++) {
+            MethodLocation location = instructionList.get(i);
+            location.codeAddress = codeAddress;
+
+            Instruction instruction = location.getInstruction();
+            if (instruction != null) {
+                codeAddress += instruction.getCodeUnits();
+            } else {
+                assert i == instructionList.size() - 1;
+            }
+        }
+
+        this.fixInstructions = true;
+    }
+
+    public void removeInstruction(int index) {
+        if (index >= instructionList.size() - 1) {
+            throw new IndexOutOfBoundsException();
+        }
+
+        MethodLocation toRemove = instructionList.get(index);
+        toRemove.instruction = null;
+        MethodLocation next = instructionList.get(index + 1);
+        toRemove.mergeInto(next);
+
+        instructionList.remove(index);
+        int codeAddress = toRemove.codeAddress;
+        for (int i = index; i < instructionList.size(); i++) {
+            MethodLocation location = instructionList.get(i);
+            location.index = i;
+            location.codeAddress = codeAddress;
+
+            Instruction instruction = location.getInstruction();
+            if (instruction != null) {
+                codeAddress += instruction.getCodeUnits();
+            } else {
+                assert i == instructionList.size() - 1;
+            }
+        }
+
+        this.fixInstructions = true;
+    }
+
+    public void swapInstructions(int index1, int index2) {
+        if (index1 >= instructionList.size() - 1 || index2 >= instructionList.size() - 1) {
+            throw new IndexOutOfBoundsException();
+        }
+        MethodLocation first = instructionList.get(index1);
+        MethodLocation second = instructionList.get(index2);
+
+        // only the last MethodLocation may have a null instruction
+        assert first.instruction != null;
+        assert second.instruction != null;
+
+        first.instruction.location = second;
+        second.instruction.location = first;
+
+        {
+            BuilderInstruction tmp = second.instruction;
+            second.instruction = first.instruction;
+            first.instruction = tmp;
+        }
+
+        if (index2 < index1) {
+            int tmp = index2;
+            index2 = index1;
+            index1 = tmp;
+        }
+
+        int codeAddress = first.codeAddress + first.instruction.getCodeUnits();
+        for (int i = index1 + 1; i <= index2; i++) {
+            MethodLocation location = instructionList.get(i);
+            location.codeAddress = codeAddress;
+
+            Instruction instruction = location.instruction;
+            assert instruction != null;
+            codeAddress += location.instruction.getCodeUnits();
+        }
+
+        this.fixInstructions = true;
+    }
+
+    @Nullable
+    private BuilderInstruction getFirstNonNop(int startIndex) {
+
+        for (int i = startIndex; i < instructionList.size() - 1; i++) {
+            BuilderInstruction instruction = instructionList.get(i).instruction;
+            assert instruction != null;
+            if (instruction.getOpcode() != Opcode.NOP) {
+                return instruction;
+            }
+        }
+        return null;
+    }
+
+    private void fixInstructions() {
+        HashSet<MethodLocation> payloadLocations = Sets.newHashSet();
+
+        for (MethodLocation location : instructionList) {
+            BuilderInstruction instruction = location.instruction;
+            if (instruction != null) {
+                switch (instruction.getOpcode()) {
+                    case SPARSE_SWITCH:
+                    case PACKED_SWITCH: {
+                        MethodLocation targetLocation =
+                                ((BuilderOffsetInstruction) instruction).getTarget().getLocation();
+                        BuilderInstruction targetInstruction = targetLocation.instruction;
+                        if (targetInstruction == null) {
+                            throw new IllegalStateException(String.format("Switch instruction at address/index "
+                                + "0x%x/%d points to the end of the method.", location.codeAddress, location.index));
+                        }
+
+                        if (targetInstruction.getOpcode() == Opcode.NOP) {
+                            targetInstruction = getFirstNonNop(targetLocation.index + 1);
+                        }
+                        if (targetInstruction == null || !(targetInstruction instanceof BuilderSwitchPayload)) {
+                            throw new IllegalStateException(String.format("Switch instruction at address/index "
+                                + "0x%x/%d does not refer to a payload instruction.",
+                                    location.codeAddress, location.index));
+                        }
+                        if ((instruction.opcode == Opcode.PACKED_SWITCH
+                            && targetInstruction.getOpcode() != Opcode.PACKED_SWITCH_PAYLOAD)
+                            || (instruction.opcode == Opcode.SPARSE_SWITCH
+                            && targetInstruction.getOpcode() != Opcode.SPARSE_SWITCH_PAYLOAD)) {
+                            throw new IllegalStateException(String.format("Switch instruction at address/index "
+                                + "0x%x/%d refers to the wrong type of payload instruction.",
+                                    location.codeAddress, location.index));
+                        }
+
+                        if (!payloadLocations.add(targetLocation)) {
+                            throw new IllegalStateException("Multiple switch instructions refer to the same payload. "
+                                + "This is not currently supported. Please file a bug :)");
+                        }
+
+                        ((BuilderSwitchPayload) targetInstruction).referrer = location;
+                        break;
+                    }
+                }
+            }
+        }
+
+        boolean madeChanges;
+        do {
+            madeChanges = false;
+
+            for (int index = 0; index < instructionList.size(); index++) {
+                MethodLocation location = instructionList.get(index);
+                BuilderInstruction instruction = location.instruction;
+                if (instruction != null) {
+                    switch (instruction.getOpcode()) {
+                        case GOTO: {
+                            int offset = ((BuilderOffsetInstruction) instruction).internalGetCodeOffset();
+                            if (offset < Byte.MIN_VALUE || offset > Byte.MAX_VALUE) {
+                                BuilderOffsetInstruction replacement;
+                                if (offset < Short.MIN_VALUE || offset > Short.MAX_VALUE) {
+                                    replacement = new BuilderInstruction30t(Opcode.GOTO_32,
+                                            ((BuilderOffsetInstruction) instruction).getTarget());
+                                } else {
+                                    replacement = new BuilderInstruction20t(Opcode.GOTO_16,
+                                            ((BuilderOffsetInstruction) instruction).getTarget());
+                                }
+                                replaceInstruction(location.index, replacement);
+                                madeChanges = true;
+                            }
+                            break;
+                        }
+                        case GOTO_16: {
+                            int offset = ((BuilderOffsetInstruction) instruction).internalGetCodeOffset();
+                            if (offset < Short.MIN_VALUE || offset > Short.MAX_VALUE) {
+                                BuilderOffsetInstruction replacement = new BuilderInstruction30t(Opcode.GOTO_32,
+                                        ((BuilderOffsetInstruction) instruction).getTarget());
+                                replaceInstruction(location.index, replacement);
+                                madeChanges = true;
+                            }
+                            break;
+                        }
+                        case SPARSE_SWITCH_PAYLOAD:
+                        case PACKED_SWITCH_PAYLOAD:
+                            if (((BuilderSwitchPayload) instruction).referrer == null) {
+                                // if the switch payload isn't referenced, just remove it
+                                removeInstruction(index);
+                                index--;
+                                madeChanges = true;
+                                break;
+                            }
+                            // intentional fall-through
+                        case ARRAY_PAYLOAD: {
+                            if ((location.codeAddress & 0x01) != 0) {
+                                int previousIndex = location.index - 1;
+                                MethodLocation previousLocation = instructionList.get(previousIndex);
+                                Instruction previousInstruction = previousLocation.instruction;
+                                assert previousInstruction != null;
+                                if (previousInstruction.getOpcode() == Opcode.NOP) {
+                                    removeInstruction(previousIndex);
+                                    index--;
+                                } else {
+                                    addInstruction(location.index, new BuilderInstruction10x(Opcode.NOP));
+                                    index++;
+                                }
+                                madeChanges = true;
+                            }
+                            break;
+                        }
+                    }
+                }
+            }
+        } while (madeChanges);
+
+        fixInstructions = false;
+    }
+
+    private int mapCodeAddressToIndex(@Nonnull int[] codeAddressToIndex, int codeAddress) {
+        int index;
+        do {
+            index = codeAddressToIndex[codeAddress];
+            if (index < 0) {
+                codeAddress--;
+            } else {
+                return index;
+            }
+        } while (true);
+    }
+
+    private int mapCodeAddressToIndex(int codeAddress) {
+        float avgCodeUnitsPerInstruction = 1.9f;
+
+        int index = (int) (codeAddress / avgCodeUnitsPerInstruction);
+        if (index >= instructionList.size()) {
+            index = instructionList.size() - 1;
+        }
+
+        MethodLocation guessedLocation = instructionList.get(index);
+
+        if (guessedLocation.codeAddress == codeAddress) {
+            return index;
+        } else if (guessedLocation.codeAddress > codeAddress) {
+            do {
+                index--;
+            } while (instructionList.get(index).codeAddress > codeAddress);
+            return index;
+        } else {
+            do {
+                index++;
+            }
+            while (index < instructionList.size() && instructionList.get(index).codeAddress <= codeAddress);
+            return index - 1;
+        }
+    }
+
+    @Nonnull
+    public Label newLabelForAddress(int codeAddress) {
+        if (codeAddress < 0 || codeAddress > instructionList.get(instructionList.size() - 1).codeAddress) {
+            throw new IndexOutOfBoundsException(String.format("codeAddress %d out of bounds", codeAddress));
+        }
+        MethodLocation referent = instructionList.get(mapCodeAddressToIndex(codeAddress));
+        return referent.addNewLabel();
+    }
+
+    @Nonnull
+    public Label newLabelForIndex(int instructionIndex) {
+        if (instructionIndex < 0 || instructionIndex >= instructionList.size()) {
+            throw new IndexOutOfBoundsException(String.format("instruction index %d out of bounds", instructionIndex));
+        }
+        MethodLocation referent = instructionList.get(instructionIndex);
+        return referent.addNewLabel();
+    }
+
+    @Nonnull
+    private Label newLabel(@Nonnull int[] codeAddressToIndex, int codeAddress) {
+        MethodLocation referent = instructionList.get(mapCodeAddressToIndex(codeAddressToIndex, codeAddress));
+        return referent.addNewLabel();
+    }
+
+    @Nonnull
+    public Label newSwitchPayloadReferenceLabel(@Nonnull MethodLocation switchLocation,
+                                                @Nonnull int[] codeAddressToIndex, int codeAddress) {
+        MethodLocation referent = instructionList.get(mapCodeAddressToIndex(codeAddressToIndex, codeAddress));
+        SwitchPayloadReferenceLabel label = new SwitchPayloadReferenceLabel();
+        label.switchLocation = switchLocation;
+        referent.getLabels().add(label);
+        return label;
+    }
+
+    private void setInstruction(@Nonnull MethodLocation location, @Nonnull BuilderInstruction instruction) {
+        location.instruction = instruction;
+        instruction.location = location;
+    }
+
+    private void convertAndSetInstruction(@Nonnull MethodLocation location, int[] codeAddressToIndex,
+                                          @Nonnull Instruction instruction) {
+        switch (instruction.getOpcode().format) {
+            case Format10t:
+                setInstruction(location, newBuilderInstruction10t(location.codeAddress,
+                        codeAddressToIndex,
+                        (Instruction10t) instruction));
+                return;
+            case Format10x:
+                setInstruction(location, newBuilderInstruction10x((Instruction10x) instruction));
+                return;
+            case Format11n:
+                setInstruction(location, newBuilderInstruction11n((Instruction11n) instruction));
+                return;
+            case Format11x:
+                setInstruction(location, newBuilderInstruction11x((Instruction11x) instruction));
+                return;
+            case Format12x:
+                setInstruction(location, newBuilderInstruction12x((Instruction12x) instruction));
+                return;
+            case Format20bc:
+                setInstruction(location, newBuilderInstruction20bc((Instruction20bc) instruction));
+                return;
+            case Format20t:
+                setInstruction(location, newBuilderInstruction20t(location.codeAddress,
+                        codeAddressToIndex,
+                        (Instruction20t) instruction));
+                return;
+            case Format21c:
+                setInstruction(location, newBuilderInstruction21c((Instruction21c) instruction));
+                return;
+            case Format21ih:
+                setInstruction(location, newBuilderInstruction21ih((Instruction21ih) instruction));
+                return;
+            case Format21lh:
+                setInstruction(location, newBuilderInstruction21lh((Instruction21lh) instruction));
+                return;
+            case Format21s:
+                setInstruction(location, newBuilderInstruction21s((Instruction21s) instruction));
+                return;
+            case Format21t:
+                setInstruction(location, newBuilderInstruction21t(location.codeAddress,
+                        codeAddressToIndex,
+                        (Instruction21t) instruction));
+                return;
+            case Format22b:
+                setInstruction(location, newBuilderInstruction22b((Instruction22b) instruction));
+                return;
+            case Format22c:
+                setInstruction(location, newBuilderInstruction22c((Instruction22c) instruction));
+                return;
+            case Format22s:
+                setInstruction(location, newBuilderInstruction22s((Instruction22s) instruction));
+                return;
+            case Format22t:
+                setInstruction(location, newBuilderInstruction22t(location.codeAddress,
+                        codeAddressToIndex,
+                        (Instruction22t) instruction));
+                return;
+            case Format22x:
+                setInstruction(location, newBuilderInstruction22x((Instruction22x) instruction));
+                return;
+            case Format23x:
+                setInstruction(location, newBuilderInstruction23x((Instruction23x) instruction));
+                return;
+            case Format25x:
+                setInstruction(location, newBuilderInstruction25x((Instruction25x) instruction));
+                return;
+            case Format30t:
+                setInstruction(location, newBuilderInstruction30t(location.codeAddress,
+                        codeAddressToIndex,
+                        (Instruction30t) instruction));
+                return;
+            case Format31c:
+                setInstruction(location, newBuilderInstruction31c((Instruction31c) instruction));
+                return;
+            case Format31i:
+                setInstruction(location, newBuilderInstruction31i((Instruction31i) instruction));
+                return;
+            case Format31t:
+                setInstruction(location, newBuilderInstruction31t(location, codeAddressToIndex,
+                        (Instruction31t) instruction));
+                return;
+            case Format32x:
+                setInstruction(location, newBuilderInstruction32x((Instruction32x) instruction));
+                return;
+            case Format35c:
+                setInstruction(location, newBuilderInstruction35c((Instruction35c) instruction));
+                return;
+            case Format3rc:
+                setInstruction(location, newBuilderInstruction3rc((Instruction3rc) instruction));
+                return;
+            case Format51l:
+                setInstruction(location, newBuilderInstruction51l((Instruction51l) instruction));
+                return;
+            case PackedSwitchPayload:
+                setInstruction(location,
+                        newBuilderPackedSwitchPayload(location, codeAddressToIndex, (PackedSwitchPayload) instruction));
+                return;
+            case SparseSwitchPayload:
+                setInstruction(location,
+                        newBuilderSparseSwitchPayload(location, codeAddressToIndex, (SparseSwitchPayload) instruction));
+                return;
+            case ArrayPayload:
+                setInstruction(location, newBuilderArrayPayload((ArrayPayload) instruction));
+                return;
+            default:
+                throw new ExceptionWithContext("Instruction format %s not supported", instruction.getOpcode().format);
+        }
+    }
+
+    @Nonnull
+    private BuilderInstruction10t newBuilderInstruction10t(int codeAddress, int[] codeAddressToIndex,
+                                                           @Nonnull Instruction10t instruction) {
+        return new BuilderInstruction10t(
+                instruction.getOpcode(),
+                newLabel(codeAddressToIndex, codeAddress + instruction.getCodeOffset()));
+    }
+
+    @Nonnull
+    private BuilderInstruction10x newBuilderInstruction10x(@Nonnull Instruction10x instruction) {
+        return new BuilderInstruction10x(
+                instruction.getOpcode());
+    }
+
+    @Nonnull
+    private BuilderInstruction11n newBuilderInstruction11n(@Nonnull Instruction11n instruction) {
+        return new BuilderInstruction11n(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getNarrowLiteral());
+    }
+
+    @Nonnull
+    private BuilderInstruction11x newBuilderInstruction11x(@Nonnull Instruction11x instruction) {
+        return new BuilderInstruction11x(
+                instruction.getOpcode(),
+                instruction.getRegisterA());
+    }
+
+    @Nonnull
+    private BuilderInstruction12x newBuilderInstruction12x(@Nonnull Instruction12x instruction) {
+        return new BuilderInstruction12x(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getRegisterB());
+    }
+
+    @Nonnull
+    private BuilderInstruction20bc newBuilderInstruction20bc(@Nonnull Instruction20bc instruction) {
+        return new BuilderInstruction20bc(
+                instruction.getOpcode(),
+                instruction.getVerificationError(),
+                convertReference(instruction.getReference()));
+    }
+
+    @Nonnull
+    private BuilderInstruction20t newBuilderInstruction20t(int codeAddress, int[] codeAddressToIndex,
+                                                           @Nonnull Instruction20t instruction) {
+        return new BuilderInstruction20t(
+                instruction.getOpcode(),
+                newLabel(codeAddressToIndex, codeAddress + instruction.getCodeOffset()));
+    }
+
+    @Nonnull
+    private BuilderInstruction21c newBuilderInstruction21c(@Nonnull Instruction21c instruction) {
+        return new BuilderInstruction21c(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                convertReference(instruction.getReference()));
+    }
+
+    @Nonnull
+    private BuilderInstruction21ih newBuilderInstruction21ih(@Nonnull Instruction21ih instruction) {
+        return new BuilderInstruction21ih(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getNarrowLiteral());
+    }
+
+    @Nonnull
+    private BuilderInstruction21lh newBuilderInstruction21lh(@Nonnull Instruction21lh instruction) {
+        return new BuilderInstruction21lh(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getWideLiteral());
+    }
+
+    @Nonnull
+    private BuilderInstruction21s newBuilderInstruction21s(@Nonnull Instruction21s instruction) {
+        return new BuilderInstruction21s(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getNarrowLiteral());
+    }
+
+    @Nonnull
+    private BuilderInstruction21t newBuilderInstruction21t(int codeAddress, int[] codeAddressToIndex,
+                                                           @Nonnull Instruction21t instruction) {
+        return new BuilderInstruction21t(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                newLabel(codeAddressToIndex, codeAddress + instruction.getCodeOffset()));
+    }
+
+    @Nonnull
+    private BuilderInstruction22b newBuilderInstruction22b(@Nonnull Instruction22b instruction) {
+        return new BuilderInstruction22b(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getRegisterB(),
+                instruction.getNarrowLiteral());
+    }
+
+    @Nonnull
+    private BuilderInstruction22c newBuilderInstruction22c(@Nonnull Instruction22c instruction) {
+        return new BuilderInstruction22c(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getRegisterB(),
+                convertReference(instruction.getReference()));
+    }
+
+    @Nonnull
+    private BuilderInstruction22s newBuilderInstruction22s(@Nonnull Instruction22s instruction) {
+        return new BuilderInstruction22s(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getRegisterB(),
+                instruction.getNarrowLiteral());
+    }
+
+    @Nonnull
+    private BuilderInstruction22t newBuilderInstruction22t(int codeAddress, int[] codeAddressToIndex,
+                                                           @Nonnull Instruction22t instruction) {
+        return new BuilderInstruction22t(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getRegisterB(),
+                newLabel(codeAddressToIndex, codeAddress + instruction.getCodeOffset()));
+    }
+
+    @Nonnull
+    private BuilderInstruction22x newBuilderInstruction22x(@Nonnull Instruction22x instruction) {
+        return new BuilderInstruction22x(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getRegisterB());
+    }
+
+    @Nonnull
+    private BuilderInstruction23x newBuilderInstruction23x(@Nonnull Instruction23x instruction) {
+        return new BuilderInstruction23x(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getRegisterB(),
+                instruction.getRegisterC());
+    }
+
+    @Nonnull
+    private BuilderInstruction30t newBuilderInstruction30t(int codeAddress, int[] codeAddressToIndex,
+                                                           @Nonnull Instruction30t instruction) {
+        return new BuilderInstruction30t(
+                instruction.getOpcode(),
+                newLabel(codeAddressToIndex, codeAddress + instruction.getCodeOffset()));
+    }
+
+    @Nonnull
+    private BuilderInstruction31c newBuilderInstruction31c(@Nonnull Instruction31c instruction) {
+        return new BuilderInstruction31c(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                convertReference(instruction.getReference()));
+    }
+
+    @Nonnull
+    private BuilderInstruction31i newBuilderInstruction31i(@Nonnull Instruction31i instruction) {
+        return new BuilderInstruction31i(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getNarrowLiteral());
+    }
+
+    @Nonnull
+    private BuilderInstruction31t newBuilderInstruction31t(@Nonnull MethodLocation location, int[] codeAddressToIndex,
+                                                           @Nonnull Instruction31t instruction) {
+        int codeAddress = location.getCodeAddress();
+        Label newLabel;
+        if (instruction.getOpcode() != Opcode.FILL_ARRAY_DATA) {
+            // if it's a sparse switch or packed switch
+            newLabel = newSwitchPayloadReferenceLabel(location, codeAddressToIndex, codeAddress + instruction.getCodeOffset());
+        } else {
+            newLabel = newLabel(codeAddressToIndex, codeAddress + instruction.getCodeOffset());
+        }
+        return new BuilderInstruction31t(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                newLabel);
+    }
+
+    @Nonnull
+    private BuilderInstruction32x newBuilderInstruction32x(@Nonnull Instruction32x instruction) {
+        return new BuilderInstruction32x(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getRegisterB());
+    }
+
+    @Nonnull
+    private BuilderInstruction35c newBuilderInstruction35c(@Nonnull Instruction35c instruction) {
+        return new BuilderInstruction35c(
+                instruction.getOpcode(),
+                instruction.getRegisterCount(),
+                instruction.getRegisterC(),
+                instruction.getRegisterD(),
+                instruction.getRegisterE(),
+                instruction.getRegisterF(),
+                instruction.getRegisterG(),
+                convertReference(instruction.getReference()));
+    }
+
+    @Nonnull
+    private BuilderInstruction25x newBuilderInstruction25x(@Nonnull Instruction25x instruction) {
+        return new BuilderInstruction25x(
+                instruction.getOpcode(),
+                instruction.getParameterRegisterCount(),
+                instruction.getRegisterFixedC(),
+                instruction.getRegisterParameterD(),
+                instruction.getRegisterParameterE(),
+                instruction.getRegisterParameterF(),
+                instruction.getRegisterParameterG());
+    }
+
+    @Nonnull
+    private BuilderInstruction3rc newBuilderInstruction3rc(@Nonnull Instruction3rc instruction) {
+        return new BuilderInstruction3rc(
+                instruction.getOpcode(),
+                instruction.getStartRegister(),
+                instruction.getRegisterCount(),
+                convertReference(instruction.getReference()));
+    }
+
+    @Nonnull
+    private BuilderInstruction51l newBuilderInstruction51l(@Nonnull Instruction51l instruction) {
+        return new BuilderInstruction51l(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getWideLiteral());
+    }
+
+    @Nullable
+    private MethodLocation findSwitchForPayload(@Nonnull MethodLocation payloadLocation) {
+        MethodLocation location = payloadLocation;
+        MethodLocation switchLocation = null;
+        do {
+            for (Label label : location.getLabels()) {
+                if (label instanceof SwitchPayloadReferenceLabel) {
+                    if (switchLocation != null) {
+                        throw new IllegalStateException("Multiple switch instructions refer to the same payload. "
+                            + "This is not currently supported. Please file a bug :)");
+                    }
+                    switchLocation = ((SwitchPayloadReferenceLabel) label).switchLocation;
+                }
+            }
+
+            // A switch instruction can refer to the payload instruction itself, or to a nop before the payload
+            // instruction.
+            // We need to search for all occurrences of a switch reference, so we can detect when multiple switch
+            // statements refer to the same payload
+            // TODO: confirm that it could refer to the first NOP in a series of NOPs preceding the payload
+            if (location.index == 0) {
+                return switchLocation;
+            }
+            location = instructionList.get(location.index - 1);
+            if (location.instruction == null || location.instruction.getOpcode() != Opcode.NOP) {
+                return switchLocation;
+            }
+        } while (true);
+    }
+
+    @Nonnull
+    private BuilderPackedSwitchPayload newBuilderPackedSwitchPayload(@Nonnull MethodLocation location,
+                                                                     @Nonnull int[] codeAddressToIndex,
+                                                                     @Nonnull PackedSwitchPayload instruction) {
+        List<? extends SwitchElement> switchElements = instruction.getSwitchElements();
+        if (switchElements.size() == 0) {
+            return new BuilderPackedSwitchPayload(0, null);
+        }
+
+        MethodLocation switchLocation = findSwitchForPayload(location);
+        int baseAddress;
+        if (switchLocation == null) {
+            baseAddress = 0;
+        } else {
+            baseAddress = switchLocation.codeAddress;
+        }
+
+        List<Label> labels = Lists.newArrayList();
+        for (SwitchElement element : switchElements) {
+            labels.add(newLabel(codeAddressToIndex, element.getOffset() + baseAddress));
+        }
+
+        return new BuilderPackedSwitchPayload(switchElements.get(0).getKey(), labels);
+    }
+
+    @Nonnull
+    private BuilderSparseSwitchPayload newBuilderSparseSwitchPayload(@Nonnull MethodLocation location,
+                                                                     @Nonnull int[] codeAddressToIndex,
+                                                                     @Nonnull SparseSwitchPayload instruction) {
+        List<? extends SwitchElement> switchElements = instruction.getSwitchElements();
+        if (switchElements.size() == 0) {
+            return new BuilderSparseSwitchPayload(null);
+        }
+
+        MethodLocation switchLocation = findSwitchForPayload(location);
+        int baseAddress;
+        if (switchLocation == null) {
+            baseAddress = 0;
+        } else {
+            baseAddress = switchLocation.codeAddress;
+        }
+
+        List<SwitchLabelElement> labelElements = Lists.newArrayList();
+        for (SwitchElement element : switchElements) {
+            labelElements.add(new SwitchLabelElement(element.getKey(),
+                    newLabel(codeAddressToIndex, element.getOffset() + baseAddress)));
+        }
+
+        return new BuilderSparseSwitchPayload(labelElements);
+    }
+
+    @Nonnull
+    private BuilderArrayPayload newBuilderArrayPayload(@Nonnull ArrayPayload instruction) {
+        return new BuilderArrayPayload(instruction.getElementWidth(), instruction.getArrayElements());
+    }
+
+    private Reference convertReference(@Nonnull Reference reference) {
+        if (reference != null && this.dexBuilder != null) {
+            return this.dexBuilder.internReference(reference);
+        } else {
+            return reference;
+        }
+    }
+
+    @Nonnull
+    private BuilderDebugItem convertDebugItem(@Nonnull DebugItem debugItem) {
+        switch (debugItem.getDebugItemType()) {
+            case DebugItemType.START_LOCAL: {
+                StartLocal startLocal = (StartLocal) debugItem;
+                return new BuilderStartLocal(startLocal.getRegister(),
+                        (StringReference) convertReference(startLocal.getNameReference()),
+                        (TypeReference) convertReference(startLocal.getTypeReference()),
+                        (StringReference) convertReference(startLocal.getSignatureReference()));
+            }
+            case DebugItemType.END_LOCAL: {
+                EndLocal endLocal = (EndLocal) debugItem;
+                return new BuilderEndLocal(endLocal.getRegister());
+            }
+            case DebugItemType.RESTART_LOCAL: {
+                RestartLocal restartLocal = (RestartLocal) debugItem;
+                return new BuilderRestartLocal(restartLocal.getRegister());
+            }
+            case DebugItemType.PROLOGUE_END:
+                return new BuilderPrologueEnd();
+            case DebugItemType.EPILOGUE_BEGIN:
+                return new BuilderEpilogueBegin();
+            case DebugItemType.LINE_NUMBER: {
+                LineNumber lineNumber = (LineNumber) debugItem;
+                return new BuilderLineNumber(lineNumber.getLineNumber());
+            }
+            case DebugItemType.SET_SOURCE_FILE: {
+                SetSourceFile setSourceFile = (SetSourceFile) debugItem;
+                return new BuilderSetSourceFile(
+                        (StringReference) convertReference(setSourceFile.getSourceFileReference())
+                );
+            }
+            default:
+                throw new ExceptionWithContext("Invalid debug item type: " + debugItem.getDebugItemType());
+        }
+    }
+
+    private interface Task {
+        void perform();
+    }
+
+    private static class SwitchPayloadReferenceLabel extends Label {
+        @Nonnull
+        public MethodLocation switchLocation;
+    }
+}
+
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/DexPatcherLogger.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/DexPatcherLogger.java
index 3ee24910..76b4ae65 100644
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/DexPatcherLogger.java
+++ b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/DexPatcherLogger.java
@@ -7,6 +7,10 @@
 public final class DexPatcherLogger {
     private IDexPatcherLogger loggerImpl = null;
 
+    public IDexPatcherLogger getLoggerImpl() {
+        return this.loggerImpl;
+    }
+
     public void setLoggerImpl(IDexPatcherLogger dexPatcherLogger) {
         this.loggerImpl = dexPatcherLogger;
     }
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/DexSectionPatchAlgorithm.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/DexSectionPatchAlgorithm.java
index ca2aadf8..835ebd94 100644
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/DexSectionPatchAlgorithm.java
+++ b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/DexSectionPatchAlgorithm.java
@@ -105,6 +105,16 @@ protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffse
 
     /**
      * Mark deleted index or offset in {@code indexMap}.
+     *
+     * Here we mark deleted item for such a case like this:
+     *   Item in DebugInfo section reference a string in StringData section
+     *   by index X, while in patched dex, the referenced string is removed.
+     *
+     * The {@code indexMap} must be aware of this case and return -1
+     * instead of the original value X.
+     *
+     * Further more, the special value -1 is not chosen by our inspiration but
+     * the definition of NO_INDEX in document of dex file format.
      */
     protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
         // Should override by subclass if needed.
@@ -247,11 +257,21 @@ private void doFullPatch(
             } else
             if (Arrays.binarySearch(deletedIndices, oldIndex) >= 0) {
                 T skippedOldItem = nextItem(oldSection); // skip old item.
+                markDeletedIndexOrOffset(
+                        oldToFullPatchedIndexMap,
+                        oldIndex,
+                        getItemOffsetOrIndex(oldIndex, skippedOldItem)
+                );
                 ++oldIndex;
                 ++deletedItemCounter;
             } else
             if (Arrays.binarySearch(replacedIndices, oldIndex) >= 0) {
                 T skippedOldItem = nextItem(oldSection); // skip old item.
+                markDeletedIndexOrOffset(
+                        oldToFullPatchedIndexMap,
+                        oldIndex,
+                        getItemOffsetOrIndex(oldIndex, skippedOldItem)
+                );
                 ++oldIndex;
             } else
             if (oldIndex < oldItemCount) {
@@ -362,11 +382,21 @@ private void doSmallPatch(
             } else
             if (Arrays.binarySearch(deletedIndices, oldIndex) >= 0) {
                 T skippedOldItem = nextItem(oldSection); // skip old item.
+                markDeletedIndexOrOffset(
+                        oldToFullPatchedIndexMap,
+                        oldIndex,
+                        getItemOffsetOrIndex(oldIndex, skippedOldItem)
+                );
                 ++oldIndex;
                 ++deletedItemCounter;
             } else
             if (Arrays.binarySearch(replacedIndices, oldIndex) >= 0) {
                 T skippedOldItem = nextItem(oldSection); // skip old item.
+                markDeletedIndexOrOffset(
+                        oldToFullPatchedIndexMap,
+                        oldIndex,
+                        getItemOffsetOrIndex(oldIndex, skippedOldItem)
+                );
                 ++oldIndex;
             } else
             if (oldIndex < oldItemCount) {
diff --git a/tinker-sample-android/app/build.gradle b/tinker-sample-android/app/build.gradle
index b143b809..e9b6f2d6 100644
--- a/tinker-sample-android/app/build.gradle
+++ b/tinker-sample-android/app/build.gradle
@@ -10,15 +10,16 @@ dependencies {
     compile("com.tencent.tinker:tinker-android-anno:${TINKER_VERSION}") { changing = true }
     compile "com.android.support:multidex:1.0.1"
 
+    //use to test multiDex
+//    compile group: 'com.google.guava', name: 'guava', version: '19.0'
+//    compile "org.scala-lang:scala-library:2.11.7"
+
     //use for local maven test
 //    compile("com.tencent.tinker:tinker-android-loader:${TINKER_VERSION}") { changing = true }
 //    compile("com.tencent.tinker:aosp-dexutils:${TINKER_VERSION}") { changing = true }
 //    compile("com.tencent.tinker:bsdiff-util:${TINKER_VERSION}") { changing = true }
 //    compile("com.tencent.tinker:tinker-commons:${TINKER_VERSION}") { changing = true }
 
-    //use to test multiDex
-//    compile group: 'com.google.guava', name: 'guava', version: '19.0'
-//    compile "org.scala-lang:scala-library:2.11.7"
 }
 
 def gitSha() {
@@ -91,7 +92,7 @@ android {
          * client version would update with patch
          * so we can get the newly git version easily!
          */
-        buildConfigField "String", "CLIENTVERSION", "\"${gitSha()}\""
+        buildConfigField "String", "CLIENTVERSION", "\"${getTinkerIdValue()}\""
         buildConfigField "String", "PLATFORM",  "\"all\""
     }
 //    //use to test flavors support
@@ -134,13 +135,17 @@ def bakPath = file("${buildDir}/bakApk/")
 ext {
     //for some reason, you may want to ignore tinkerBuild, such as instant run debug build?
     tinkerEnabled = true
-    //you should bak the following files
+
+    //for normal build
     //old apk file to build patch apk
-    tinkerOldApkPath = "${bakPath}/app-debug-0919-20-32-57.apk"
+    tinkerOldApkPath = "${bakPath}/app-debug-1018-17-32-47.apk"
     //proguard mapping file to build patch apk
     tinkerApplyMappingPath = "${bakPath}/"
     //resource R.txt to build patch apk, must input if there is resource changed
     tinkerApplyResourcePath = "${bakPath}/"
+
+    //use for build all flavor, just fill this field
+    tinkerBuildFlavorDirectory = "${bakPath}/app-debug-1018-17-32-47-R.txt"
 }
 
 
@@ -164,6 +169,10 @@ def buildWithTinker() {
     return hasProperty("TINKER_ENABLE") ? TINKER_ENABLE : ext.tinkerEnabled
 }
 
+def getTinkerBuildFlavorDirectory() {
+    return ext.tinkerBuildFlavorDirectory
+}
+
 if (buildWithTinker()) {
     apply plugin: 'com.tencent.tinker.patch'
 
@@ -190,6 +199,7 @@ if (buildWithTinker()) {
          * case 5: resources.arsc has changed, but we don't use applyResourceMapping to build
          */
         ignoreWarning = false
+
         /**
          * optional，default 'true'
          * whether sign the patch file
@@ -235,6 +245,20 @@ if (buildWithTinker()) {
              * or you want to save rom or check quicker, you can use raw mode also
              */
             dexMode = "jar"
+            /**
+             * optional，default 'false'
+             * if usePreGeneratedPatchDex is true, tinker framework will generate auxiliary class
+             * and insert auxiliary instruction when compiling base package using
+             * assemble{Debug/Release} task to prevent class pre-verified issue in dvm.
+             * Besides, a real dex file contains necessary class will be generated and packed into
+             * patch package instead of any patch info files.
+             *
+             * Use this mode if you have to use any dex encryption solutions.
+             *
+             * Notice: If you change this value, please trigger clean task
+             * and regenerate base package.
+             */
+            usePreGeneratedPatchDex = false
             /**
              * necessary，default '[]'
              * what dexes in apk are expected to deal with tinkerPatch
@@ -252,7 +276,8 @@ if (buildWithTinker()) {
              *
              */
             loader = ["com.tencent.tinker.loader.*",
-                      "tinker.sample.android.SampleApplication",
+                      //warning, you must change it with your application
+                      "tinker.sample.android.app.SampleApplication",
                       //use sample, let BaseBuildInfo unchangeable with tinker
                       "tinker.sample.android.app.BaseBuildInfo"
             ]
@@ -311,7 +336,10 @@ if (buildWithTinker()) {
              * Then you can use patch conditional!
              */
             configField("platform", "all")
-
+            /**
+             * patch version via packageConfig
+             */
+            configField("patchVersion", "1.0")
         }
         //or you can add config filed outside, or get meta value from old apk
         //project.tinkerPatch.packageConfig.configField("test1", project.tinkerPatch.packageConfig.getMetaDataFromOldApk("Test"))
@@ -334,8 +362,11 @@ if (buildWithTinker()) {
         }
     }
 
-
-
+    List<String> flavors = new ArrayList<>();
+    project.android.productFlavors.each {flavor ->
+        flavors.add(flavor.name)
+    }
+    boolean hasFlavors = flavors.size() > 0
     /**
     * bak apk and mapping
     */
@@ -344,32 +375,76 @@ if (buildWithTinker()) {
          * task type, you want to bak
          */
         def taskName = variant.name
+        def date = new Date().format("MMdd-HH-mm-ss")
 
         tasks.all {
             if ("assemble${taskName.capitalize()}".equalsIgnoreCase(it.name)) {
+
                 it.doLast {
                     copy {
-                        def date = new Date().format("MMdd-HH-mm-ss")
-                        from "${buildDir}/outputs/apk/${project.getName()}-${taskName}.apk"
-                        into bakPath
+                        def fileNamePrefix = "${project.name}-${variant.baseName}"
+                        def newFileNamePrefix = hasFlavors ? "${fileNamePrefix}" : "${fileNamePrefix}-${date}"
+
+                        def destPath = hasFlavors ? file("${bakPath}/${project.name}-${date}/${variant.flavorName}") : bakPath
+                        from variant.outputs.outputFile
+                        into destPath
                         rename { String fileName ->
-                            fileName.replace("${project.getName()}-${taskName}.apk", "${project.getName()}-${taskName}-${date}.apk")
+                            fileName.replace("${fileNamePrefix}.apk", "${newFileNamePrefix}.apk")
                         }
 
-                        from "${buildDir}/outputs/mapping/${taskName}/mapping.txt"
-                        into bakPath
+                        from "${buildDir}/outputs/mapping/${variant.dirName}/mapping.txt"
+                        into destPath
                         rename { String fileName ->
-                            fileName.replace("mapping.txt", "${project.getName()}-${taskName}-${date}-mapping.txt")
+                            fileName.replace("mapping.txt", "${newFileNamePrefix}-mapping.txt")
                         }
 
-                        from "${buildDir}/intermediates/symbols/${taskName}/R.txt"
-                        into bakPath
+                        from "${buildDir}/intermediates/symbols/${variant.dirName}/R.txt"
+                        into destPath
                         rename { String fileName ->
-                            fileName.replace("R.txt", "${project.getName()}-${taskName}-${date}-R.txt")
+                            fileName.replace("R.txt", "${newFileNamePrefix}-R.txt")
                         }
                     }
                 }
             }
         }
     }
+    project.afterEvaluate {
+        //sample use for build all flavor for one time
+        if (hasFlavors) {
+            task(tinkerPatchAllFlavorRelease) {
+                group = 'tinker'
+                def originOldPath = getTinkerBuildFlavorDirectory()
+                for (String flavor : flavors) {
+                    def tinkerTask = tasks.getByName("tinkerPatch${flavor.capitalize()}Release")
+                    dependsOn tinkerTask
+                    def preAssembleTask = tasks.getByName("process${flavor.capitalize()}ReleaseManifest")
+                    preAssembleTask.doFirst {
+                        String flavorName = preAssembleTask.name.substring(7, 8).toLowerCase() + preAssembleTask.name.substring(8, preAssembleTask.name.length() - 15)
+                        project.tinkerPatch.oldApk = "${originOldPath}/${flavorName}/${project.name}-${flavorName}-release.apk"
+                        project.tinkerPatch.buildConfig.applyMapping = "${originOldPath}/${flavorName}/${project.name}-${flavorName}-release-mapping.txt"
+                        project.tinkerPatch.buildConfig.applyResourceMapping = "${originOldPath}/${flavorName}/${project.name}-${flavorName}-release-R.txt"
+
+                    }
+
+                }
+            }
+
+            task(tinkerPatchAllFlavorDebug) {
+                group = 'tinker'
+                def originOldPath = getTinkerBuildFlavorDirectory()
+                for (String flavor : flavors) {
+                    def tinkerTask = tasks.getByName("tinkerPatch${flavor.capitalize()}Debug")
+                    dependsOn tinkerTask
+                    def preAssembleTask = tasks.getByName("process${flavor.capitalize()}DebugManifest")
+                    preAssembleTask.doFirst {
+                        String flavorName = preAssembleTask.name.substring(7, 8).toLowerCase() + preAssembleTask.name.substring(8, preAssembleTask.name.length() - 13)
+                        project.tinkerPatch.oldApk = "${originOldPath}/${flavorName}/${project.name}-${flavorName}-debug.apk"
+                        project.tinkerPatch.buildConfig.applyMapping = "${originOldPath}/${flavorName}/${project.name}-${flavorName}-debug-mapping.txt"
+                        project.tinkerPatch.buildConfig.applyResourceMapping = "${originOldPath}/${flavorName}/${project.name}-${flavorName}-debug-R.txt"
+                    }
+
+                }
+            }
+        }
+    }
 }
diff --git a/tinker-sample-android/app/libs/armeabi/libstlport_shared.so b/tinker-sample-android/app/libs/armeabi/libstlport_shared.so
deleted file mode 100755
index 050818bb..00000000
Binary files a/tinker-sample-android/app/libs/armeabi/libstlport_shared.so and /dev/null differ
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SampleTinkerReport.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SampleTinkerReport.java
index 269f1066..9ec92dd2 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SampleTinkerReport.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SampleTinkerReport.java
@@ -74,6 +74,8 @@
     public static final int KEY_APPLIED_PACKAGE_CHECK_META_NOT_FOUND            = 155;
     public static final int KEY_APPLIED_PACKAGE_CHECK_TINKER_ID_NOT_EQUAL       = 156;
     public static final int KEY_APPLIED_PACKAGE_CHECK_RES_META                  = 157;
+    public static final int KEY_APPLIED_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT    = 158;
+
     //version check
     public static final int KEY_APPLIED_VERSION_CHECK                           = 180;
     //extract error
@@ -100,11 +102,13 @@
 
 
     // KEY -- load detail
-    public static final int KEY_LOADED_UNKNOWN_EXCEPTION   = 250;
-    public static final int KEY_LOADED_UNCAUGHT_EXCEPTION  = 251;
-    public static final int KEY_LOADED_EXCEPTION_DEX       = 252;
-    public static final int KEY_LOADED_EXCEPTION_DEX_CHECK = 253;
-    public static final int KEY_LOADED_EXCEPTION_RESOURCE  = 254;
+    public static final int KEY_LOADED_UNKNOWN_EXCEPTION        = 250;
+    public static final int KEY_LOADED_UNCAUGHT_EXCEPTION       = 251;
+    public static final int KEY_LOADED_EXCEPTION_DEX            = 252;
+    public static final int KEY_LOADED_EXCEPTION_DEX_CHECK      = 253;
+    public static final int KEY_LOADED_EXCEPTION_RESOURCE       = 254;
+    public static final int KEY_LOADED_EXCEPTION_RESOURCE_CEHCK = 255;
+
 
     public static final int KEY_LOADED_MISMATCH_DEX       = 300;
     public static final int KEY_LOADED_MISMATCH_LIB       = 301;
@@ -126,6 +130,8 @@
     public static final int KEY_LOADED_PACKAGE_CHECK_TINKER_ID_NOT_EQUAL       = 355;
     public static final int KEY_LOADED_PACKAGE_CHECK_PACKAGE_META_NOT_FOUND    = 356;
     public static final int KEY_LOADED_PACKAGE_CHECK_RES_META                  = 357;
+    public static final int KEY_LOADED_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT    = 358;
+
 
     public static final int KEY_LOADED_SUCC_COST_500_LESS  = 400;
     public static final int KEY_LOADED_SUCC_COST_1000_LESS = 401;
@@ -228,6 +234,9 @@ public static void onLoadPackageCheckFail(int errorCode) {
             case ShareConstants.ERROR_PACKAGE_CHECK_RESOURCE_META_CORRUPTED:
                 reporter.onReport(KEY_LOADED_PACKAGE_CHECK_RES_META);
                 break;
+            case ShareConstants.ERROR_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT:
+                reporter.onReport(KEY_LOADED_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT);
+                break;
         }
     }
 
@@ -309,12 +318,12 @@ public static void onLoadException(Throwable throwable, int errorCode) {
         if (reporter == null) {
             return;
         }
-        boolean isDexCheckFail = false;
+        boolean isCheckFail = false;
         switch (errorCode) {
             case ShareConstants.ERROR_LOAD_EXCEPTION_DEX:
                 if (throwable.getMessage().contains(ShareConstants.CHECK_DEX_INSTALL_FAIL)) {
                     reporter.onReport(KEY_LOADED_EXCEPTION_DEX_CHECK);
-                    isDexCheckFail = true;
+                    isCheckFail = true;
                     TinkerLog.e(TAG, "tinker dex check fail:" + throwable.getMessage());
                 } else {
                     reporter.onReport(KEY_LOADED_EXCEPTION_DEX);
@@ -322,7 +331,14 @@ public static void onLoadException(Throwable throwable, int errorCode) {
                 }
                 break;
             case ShareConstants.ERROR_LOAD_EXCEPTION_RESOURCE:
-                reporter.onReport(KEY_LOADED_EXCEPTION_RESOURCE);
+                if (throwable.getMessage().contains(ShareConstants.CHECK_RES_INSTALL_FAIL)) {
+                    reporter.onReport(KEY_LOADED_EXCEPTION_RESOURCE_CEHCK);
+                    isCheckFail = true;
+                    TinkerLog.e(TAG, "tinker res check fail:" + throwable.getMessage());
+                } else {
+                    reporter.onReport(KEY_LOADED_EXCEPTION_RESOURCE);
+                    TinkerLog.e(TAG, "tinker res reflect fail:" + throwable.getMessage());
+                }
                 break;
             case ShareConstants.ERROR_LOAD_EXCEPTION_UNCAUGHT:
                 reporter.onReport(KEY_LOADED_UNCAUGHT_EXCEPTION);
@@ -332,7 +348,7 @@ public static void onLoadException(Throwable throwable, int errorCode) {
                 break;
         }
         //reporter exception, for dex check fail, we don't need to report stacktrace
-        if (!isDexCheckFail) {
+        if (!isCheckFail) {
             reporter.onReport("Tinker Exception:load tinker occur exception " + Utils.getExceptionCauseString(throwable));
         }
     }
@@ -483,6 +499,9 @@ public static void onApplyPackageCheckFail(int errorCode) {
             case ShareConstants.ERROR_PACKAGE_CHECK_RESOURCE_META_CORRUPTED:
                 reporter.onReport(KEY_APPLIED_PACKAGE_CHECK_RES_META);
                 break;
+            case ShareConstants.ERROR_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT:
+                reporter.onReport(KEY_APPLIED_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT);
+                break;
         }
     }
 
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/util/UpgradePatchRetry.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/util/UpgradePatchRetry.java
index e3f8eefa..714749e6 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/util/UpgradePatchRetry.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/util/UpgradePatchRetry.java
@@ -149,6 +149,10 @@ public void onPatchServiceStart(Intent intent) {
         File patchFile = new File(path);
 
         String patchMd5 = SharePatchFileUtil.getMD5(patchFile);
+        if (patchMd5 == null) {
+            TinkerLog.w(TAG, "onPatchServiceStart patch md5 is null, just return");
+            return;
+        }
 
         if (retryInfoFile.exists()) {
             retryInfo = RetryInfo.readRetryProperty(retryInfoFile);
diff --git a/tinker-sample-android/gradle.properties b/tinker-sample-android/gradle.properties
index 02a06b39..c9e94d4f 100644
--- a/tinker-sample-android/gradle.properties
+++ b/tinker-sample-android/gradle.properties
@@ -17,4 +17,4 @@
 # http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
 # org.gradle.parallel=true
 
-TINKER_VERSION=1.6.2
+TINKER_VERSION=1.7.0
