diff --git a/build.gradle b/build.gradle
index e35b7423..1edf14f1 100644
--- a/build.gradle
+++ b/build.gradle
@@ -28,7 +28,7 @@ ext {
     compileSdkVersion = 23
     targetSdkVersion = compileSdkVersion
     buildToolsVersion = '23.0.2'
-    supportLibVersion = '23.0.1'
+    supportLibVersion = '25.1.0'
     javaVersion = JavaVersion.VERSION_1_7
 
     GROUP = 'com.tencent.tinker'
diff --git a/gradle.properties b/gradle.properties
index 072deecb..24c09552 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -16,5 +16,5 @@
 # This option should only be used with decoupled projects. More details, visit
 # http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
 # org.gradle.parallel=true
-VERSION_NAME_PREFIX=1.9.6
+VERSION_NAME_PREFIX=1.9.8
 VERSION_NAME_SUFFIX=
\ No newline at end of file
diff --git a/tinker-android/tinker-android-lib/src/main/AndroidManifest.xml b/tinker-android/tinker-android-lib/src/main/AndroidManifest.xml
index b03a6d56..fbcfdc79 100644
--- a/tinker-android/tinker-android-lib/src/main/AndroidManifest.xml
+++ b/tinker-android/tinker-android-lib/src/main/AndroidManifest.xml
@@ -3,6 +3,14 @@
 
     <application>
 
+        <!--
+            Notice:
+            Following service must run in the same process.
+              TinkerPatchService$IntentServiceRunner
+              TinkerPatchService$IntentServiceRunner$InnerService
+              TinkerPatchService$JobServiceRunner
+        -->
+        <!-- ########################################################################### -->
         <service
             android:name=".service.TinkerPatchService$IntentServiceRunner"
             android:exported="false"
@@ -16,6 +24,8 @@
             android:permission="android.permission.BIND_JOB_SERVICE"
             android:exported="false"
             android:process=":patch"/>
+        <!-- ########################################################################### -->
+
         <service
             android:name=".service.DefaultTinkerResultService"
             android:exported="false"/>
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java
index 9c29ebfc..d106fb81 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java
@@ -110,11 +110,11 @@ protected static boolean waitAndCheckDexOptFile(File patchFile, Tinker manager)
             }
         }
         List<File> failDexFiles = new ArrayList<>();
-        // check again, if still can be found, just return
+        // check again, if still can't be found, just return
         for (File file : optFiles) {
             TinkerLog.i(TAG, "check dex optimizer file exist: %s, size %d", file.getPath(), file.length());
 
-            if (!SharePatchFileUtil.isLegalFile(file)) {
+            if (!SharePatchFileUtil.isLegalFile(file) && !SharePatchFileUtil.shouldAcceptEvenIfIllegal(file)) {
                 TinkerLog.e(TAG, "final parallel dex optimizer file %s is not exist, return false", file.getName());
                 failDexFiles.add(file);
             }
@@ -127,6 +127,9 @@ protected static boolean waitAndCheckDexOptFile(File patchFile, Tinker manager)
         if (Build.VERSION.SDK_INT >= 21) {
             Throwable lastThrowable = null;
             for (File file : optFiles) {
+                if (SharePatchFileUtil.shouldAcceptEvenIfIllegal(file)) {
+                    continue;
+                }
                 TinkerLog.i(TAG, "check dex optimizer file format: %s, size %d", file.getName(), file.length());
                 int returnType;
                 try {
@@ -175,12 +178,19 @@ private static boolean patchDexExtractViaDexDiff(Context context, String patchVe
         // may have directory in android o
         if (files != null) {
             for (File file : files) {
-                if (file.isFile()) {
+                final String fileName = file.getName();
+                if (file.isFile()
+                    &&  (fileName.endsWith(ShareConstants.DEX_SUFFIX)
+                      || fileName.endsWith(ShareConstants.JAR_SUFFIX)
+                      || fileName.endsWith(ShareConstants.PATCH_SUFFIX))
+                ) {
                     legalFiles.add(file);
                 }
             }
         }
 
+        TinkerLog.i(TAG, "legal files to do dexopt: " + legalFiles);
+
         final String optimizeDexDirectory = patchVersionDirectory + "/" + DEX_OPTIMIZE_PATH + "/";
         return dexOptimizeDexFiles(context, legalFiles, optimizeDexDirectory, patchFile);
 
@@ -378,6 +388,9 @@ public void onFailed(File dexFile, File optimizedDir, Throwable thr) {
     private static boolean checkAllDexOptFile(ArrayList<File> files, int count) {
         for (File file : files) {
             if (!SharePatchFileUtil.isLegalFile(file)) {
+                if (SharePatchFileUtil.shouldAcceptEvenIfIllegal(file)) {
+                    continue;
+                }
                 TinkerLog.e(TAG, "parallel dex optimizer file %s is not exist, just wait %d times", file.getName(), count);
                 return false;
             }
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultLoadReporter.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultLoadReporter.java
index f6f6b67c..902c19c7 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultLoadReporter.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultLoadReporter.java
@@ -91,9 +91,12 @@ public void onLoadPatchVersionChanged(String oldVersion, String newVersion, File
         if (!Tinker.with(context).isMainProcess()) {
             return;
         }
-        TinkerLog.i(TAG, "onLoadPatchVersionChanged, try kill all other process");
-        //kill all other process to ensure that all process's code is the same.
-        ShareTinkerInternals.killAllOtherProcess(context);
+
+        // Unnecessary now. Since other processes are killed in TinkerLoader.
+//        TinkerLog.i(TAG, "onLoadPatchVersionChanged, try kill all other process");
+        // kill all other process to ensure that all process's code is the same.
+//        ShareTinkerInternals.killAllOtherProcess(context);
+
         // reset retry count to 1, for interpret retry
         UpgradePatchRetry.getInstance(context).onPatchResetMaxCheck(newVersion);
 
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/TinkerPatchService.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/TinkerPatchService.java
index 0cc63add..020a486e 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/TinkerPatchService.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/TinkerPatchService.java
@@ -47,6 +47,7 @@
 import java.io.File;
 import java.lang.ref.WeakReference;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
 
 /**
  * Created by zhangshaowen on 16/3/14.
@@ -68,20 +69,26 @@ public static void runPatchService(final Context context, final String path) {
             if (Build.VERSION.SDK_INT < MIN_SDKVER_TO_USE_JOBSCHEDULER) {
                 runPatchServiceByIntentService(context, path);
             } else {
-                if (!runPatchServiceByJobScheduler(context, path)) {
-                    TinkerLog.e(TAG, "start patch job service fail, try to fallback to intent service.");
-                    mHandler.postDelayed(new Runnable() {
-                        @Override
-                        public void run() {
-                            // This method will tell us whether the intent service or the job scheduler
-                            // is running.
-                            TinkerLog.i(TAG, "fallback: prepare trying to run patch service by intent service.");
-                            if (!TinkerServiceInternals.isTinkerPatchServiceRunning(context)) {
+                try {
+                    runPatchServiceByJobScheduler(context, path);
+                } catch (Throwable ignored) {
+                    // ignored.
+                }
+                mHandler.postDelayed(new Runnable() {
+                    @Override
+                    public void run() {
+                        TinkerLog.i(TAG, "check if patch service is running.");
+                        if (!TinkerServiceInternals.isTinkerPatchServiceRunning(context)) {
+                            TinkerLog.w(TAG, "patch service is not running, retry with IntentService.");
+                            try {
                                 runPatchServiceByIntentService(context, path);
+                                TinkerLog.i(TAG, "successfully start patch service with IntentService.");
+                            } catch (Throwable thr) {
+                                TinkerLog.e(TAG, "failure to start patch service with IntentService. osver: %s, manu: %s, msg: %s", Build.VERSION.SDK_INT, Build.MANUFACTURER, thr.toString());
                             }
                         }
-                    }, TimeUnit.SECONDS.toMillis(3));
-                }
+                    }
+                }, TimeUnit.SECONDS.toMillis(5));
             }
         } catch (Throwable throwable) {
             TinkerLog.e(TAG, "start patch service fail, exception:" + throwable);
@@ -140,7 +147,7 @@ public static String getPatchResultExtra(Intent intent) {
         return ShareIntentUtil.getStringExtra(intent, RESULT_CLASS_EXTRA);
     }
 
-    public static Class<? extends Service> getRealRunnerClass() {
+    public static Class<? extends Service> getExpectedRealRunnerClass() {
         if (Build.VERSION.SDK_INT < MIN_SDKVER_TO_USE_JOBSCHEDULER) {
             return IntentServiceRunner.class;
         } else {
@@ -156,7 +163,16 @@ public static void setTinkerNotificationId(int id) {
         notificationId = id;
     }
 
+    private static AtomicBoolean sIsPatchApplying = new AtomicBoolean(false);
+
     private static void doApplyPatch(Context context, Intent intent) {
+        // Since we may retry with IntentService, we should prevent
+        // racing here again.
+        if (!sIsPatchApplying.compareAndSet(false, true)) {
+            TinkerLog.w(TAG, "TinkerPatchService doApplyPatch is running by another runner.");
+            return;
+        }
+
         Tinker tinker = Tinker.with(context);
         tinker.getPatchReporter().onPatchServiceStart(intent);
 
@@ -198,6 +214,8 @@ private static void doApplyPatch(Context context, Intent intent) {
         patchResult.e = e;
 
         AbstractResultService.runResultService(context, patchResult, getPatchResultExtra(intent));
+
+        sIsPatchApplying.set(false);
     }
 
     public static class IntentServiceRunner extends IntentService {
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/TinkerServiceInternals.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/TinkerServiceInternals.java
index 870f46a1..b98ee128 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/TinkerServiceInternals.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/TinkerServiceInternals.java
@@ -98,7 +98,7 @@ public static String getTinkerPatchServiceName(final Context context) {
             return patchServiceProcessName;
         }
         //may be null, and you may like to hardcode instead
-        String serviceName = TinkerServiceInternals.getServiceProcessName(context, TinkerPatchService.getRealRunnerClass());
+        String serviceName = TinkerServiceInternals.getServiceProcessName(context, TinkerPatchService.getExpectedRealRunnerClass());
         if (serviceName == null) {
             return null;
         }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AndroidNClassLoader.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AndroidNClassLoader.java
index d4235cb8..a283600a 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AndroidNClassLoader.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AndroidNClassLoader.java
@@ -107,20 +107,21 @@ private static AndroidNClassLoader createAndroidNClassLoader(PathClassLoader ori
         final Field pathListField = ShareReflectUtil.findField(originalClassLoader, "pathList");
         final Object originPathList = pathListField.get(originalClassLoader);
 
-        // To avoid 'dex file register with multiple classloader' exception on Android O, we must keep old
-        // dexPathList in original classloader so that after the newly loaded base dex was bound to
-        // AndroidNClassLoader we can still load class in base dex from original classloader.
         Object newPathList = recreateDexPathList(originPathList, androidNClassLoader, false);
 
         // Update new classloader's pathList.
         pathListField.set(androidNClassLoader, newPathList);
 
-        // Recreate old dexPathList.
+        // Change original classloader's definingContext to avoid potential class cast exception.
+        //
+        // Here's why we aren't going to recreate DexPathList with original classloader directly:
+        //  To avoid 'dex file register with multiple classloader' exception on Android O, we must
+        //  keep old dexPathList in original classloader so that we can still load classes in
+        //  base dex from original classloader.
+        ShareReflectUtil.findField(originPathList, "definingContext").set(originPathList, androidNClassLoader);
+
+        // Keep old dexPathList to avoid gc issue.
         oldDexPathListHolder = originPathList;
-        Object emptyOldPathList = recreateDexPathList(originPathList, originalClassLoader, true);
-        pathListField.set(originalClassLoader, emptyOldPathList);
-        Object recreatedOldPathList = recreateDexPathList(originPathList, originalClassLoader, false);
-        pathListField.set(originalClassLoader, recreatedOldPathList);
 
         return androidNClassLoader;
     }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerDexLoader.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerDexLoader.java
index 6f6a3988..e2690254 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerDexLoader.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerDexLoader.java
@@ -280,6 +280,9 @@ public static boolean checkComplete(String directory, ShareSecurityCheck securit
             //check dex opt whether complete also
             File dexOptFile = new File(SharePatchFileUtil.optimizedPathFor(dexFile, optimizeDexDirectoryFile));
             if (!SharePatchFileUtil.isLegalFile(dexOptFile)) {
+                if (SharePatchFileUtil.shouldAcceptEvenIfIllegal(dexOptFile)) {
+                    continue;
+                }
                 intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_MISSING_DEX_PATH, dexOptFile.getAbsolutePath());
                 ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_DEX_OPT_FILE_NOT_EXIST);
                 return false;
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerLoader.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerLoader.java
index ccf2bfff..5e98084f 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerLoader.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerLoader.java
@@ -240,6 +240,10 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, Intent resultInten
                 Log.w(TAG, "tryLoadPatchFiles:onReWritePatchInfoCorrupted");
                 return;
             }
+
+            Log.i(TAG, "tryLoadPatchFiles:success to rewrite patch info, kill other process.");
+            ShareTinkerInternals.killProcessExceptMain(app);
+
             if (oatModeChanged) {
                 // delete interpret odex
                 // for android o, directory change. Fortunately, we don't need to support android o interpret mode any more
@@ -293,11 +297,6 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, Intent resultInten
             ComponentHotplug.install(app, securityCheck);
         }
 
-        // kill all other process if oat mode change
-        if (oatModeChanged) {
-            ShareTinkerInternals.killAllOtherProcess(app);
-            Log.i(TAG, "tryLoadPatchFiles:oatModeChanged, try to kill all other process");
-        }
         //all is ok!
         ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_OK);
         Log.i(TAG, "tryLoadPatchFiles: load end, ok!");
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java
index 4d263801..8c363ca4 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java
@@ -98,8 +98,12 @@ public static void isResourceCanPatch(Context context) throws Throwable {
 
         // Kitkat needs this method call, Lollipop doesn't. However, it doesn't seem to cause any harm
         // in L, so we do it unconditionally.
-        stringBlocksField = findField(assets, "mStringBlocks");
-        ensureStringBlocksMethod = findMethod(assets, "ensureStringBlocks");
+        try {
+            stringBlocksField = findField(assets, "mStringBlocks");
+            ensureStringBlocksMethod = findMethod(assets, "ensureStringBlocks");
+        } catch (Throwable ignored) {
+            // Ignored.
+        }
 
         // Use class fetched from instance to avoid some ROMs that use customized AssetManager
         // class. (e.g. Baidu OS)
@@ -197,8 +201,10 @@ public static void monkeyPatchExistingResources(Context context, String external
 
         // Kitkat needs this method call, Lollipop doesn't. However, it doesn't seem to cause any harm
         // in L, so we do it unconditionally.
-        stringBlocksField.set(newAssetManager, null);
-        ensureStringBlocksMethod.invoke(newAssetManager);
+        if (stringBlocksField != null && ensureStringBlocksMethod != null) {
+            stringBlocksField.set(newAssetManager, null);
+            ensureStringBlocksMethod.invoke(newAssetManager);
+        }
 
         for (WeakReference<Resources> wr : references) {
             final Resources resources = wr.get();
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/TinkerApplication.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/TinkerApplication.java
index a656923a..f3f32bae 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/TinkerApplication.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/TinkerApplication.java
@@ -149,20 +149,15 @@ protected void attachBaseContext(Context base) {
     }
 
     private void loadTinker() {
-        //disable tinker, not need to install
-        if (tinkerFlags == TINKER_DISABLE) {
-            return;
-        }
-        tinkerResultIntent = new Intent();
         try {
             //reflect tinker loader, because loaderClass may be define by user!
             Class<?> tinkerLoadClass = Class.forName(loaderClassName, false, getClassLoader());
-
             Method loadMethod = tinkerLoadClass.getMethod(TINKER_LOADER_METHOD, TinkerApplication.class);
             Constructor<?> constructor = tinkerLoadClass.getConstructor();
             tinkerResultIntent = (Intent) loadMethod.invoke(constructor.newInstance(), this);
         } catch (Throwable e) {
             //has exception, put exception error code
+            tinkerResultIntent = new Intent();
             ShareIntentUtil.setIntentReturnCode(tinkerResultIntent, ShareConstants.ERROR_LOAD_PATCH_UNKNOWN_EXCEPTION);
             tinkerResultIntent.putExtra(INTENT_PATCH_EXCEPTION, e);
         }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchFileUtil.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchFileUtil.java
index 535f021d..3b552ed9 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchFileUtil.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchFileUtil.java
@@ -167,6 +167,20 @@ public static final boolean isLegalFile(File file) {
         return file != null && file.exists() && file.canRead() && file.isFile() && file.length() > 0;
     }
 
+    /**
+     * For some special device whose dex2oat procedure is optimized for tinker. (e.g. vivo, oppo)
+     *
+     * Because these devices by-pass our dex2oat request, which cause vm to load tinker's dex with interpret-mode
+     * and generate nothing instead of a valid oat file. It's fine to skip the check so far.
+     *
+     * @param file
+     * @return
+     */
+    public static final boolean shouldAcceptEvenIfIllegal(File file) {
+        return ("vivo".equalsIgnoreCase(Build.MANUFACTURER) || "oppo".equalsIgnoreCase(Build.MANUFACTURER))
+                && (!file.exists() || file.length() == 0);
+    }
+
     /**
      * get directory size
      *
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java
index 2c14b29c..517c6dab 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java
@@ -384,6 +384,27 @@ public static void killAllOtherProcess(Context context) {
 
     }
 
+    public static void killProcessExceptMain(Context context) {
+        final ActivityManager am = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
+        if (am == null) {
+            return;
+        }
+        List<ActivityManager.RunningAppProcessInfo> appProcessList = am.getRunningAppProcesses();
+        if (appProcessList != null) {
+            // NOTE: getRunningAppProcess() ONLY GIVE YOU THE PROCESS OF YOUR OWN PACKAGE IN ANDROID M
+            // BUT THAT'S ENOUGH HERE
+            for (ActivityManager.RunningAppProcessInfo ai : appProcessList) {
+                if (ai.uid != android.os.Process.myUid()) {
+                    continue;
+                }
+                if (ai.processName.equals(context.getPackageName())) {
+                    continue;
+                }
+                android.os.Process.killProcess(ai.pid);
+            }
+        }
+    }
+
     /**
      * add process name cache
      *
@@ -412,24 +433,24 @@ private static String getProcessNameInternal(final Context context) {
             (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
 
         if (activityManager != null) {
-            List<ActivityManager.RunningAppProcessInfo> appProcessList = activityManager
-                .getRunningAppProcesses();
+            try {
+                List<ActivityManager.RunningAppProcessInfo> appProcessList = activityManager
+                    .getRunningAppProcesses();
 
-            if (appProcessList != null) {
-                try {
+                if (appProcessList != null) {
                     for (ActivityManager.RunningAppProcessInfo process : appProcessList) {
                         if (process.pid == myPid) {
                             myProcess = process;
                             break;
                         }
                     }
-                } catch (Exception e) {
-                    Log.e(TAG, "getProcessNameInternal exception:" + e.getMessage());
-                }
 
-                if (myProcess != null) {
-                    return myProcess.processName;
+                    if (myProcess != null) {
+                        return myProcess.processName;
+                    }
                 }
+            } catch (Exception e) {
+                Log.e(TAG, "getProcessNameInternal exception:" + e.getMessage());
             }
         }
 
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/RDotTxtEntry.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/RDotTxtEntry.java
index e78e01b7..ee5faefa 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/RDotTxtEntry.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/RDotTxtEntry.java
@@ -116,7 +116,7 @@ public String toString() {
     // Taken from http://developer.android.com/reference/android/R.html
     // TRANSITION for api level 19
     public enum RType {
-        ANIM, ANIMATOR, ARRAY, ATTR, BOOL, COLOR, DIMEN, DRAWABLE, FRACTION, ID, INTEGER, INTERPOLATOR, LAYOUT, MENU, MIPMAP, PLURALS, RAW, STRING, STYLE, STYLEABLE, TRANSITION, XML;
+        ANIM, ANIMATOR, ARRAY, ATTR, BOOL, COLOR, DIMEN, DRAWABLE, FONT, FRACTION, ID, INTEGER, INTERPOLATOR, LAYOUT, MENU, MIPMAP, PLURALS, RAW, STRING, STYLE, STYLEABLE, TRANSITION, XML;
 
         @Override
         public String toString() {
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ManifestDecoder.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ManifestDecoder.java
index 1f1a5bc2..ce6aaea4 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ManifestDecoder.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ManifestDecoder.java
@@ -108,7 +108,12 @@ public boolean patch(File oldFile, File newFile) throws IOException, TinkerPatch
 
             if (!config.mSupportHotplugComponent && hasIncComponent) {
                 announceWarningOrException("manifest was changed, while hot plug component support mode is disabled. "
-                        + "Such changes will not take effect.");
+                        + "Such changes will not take effect, related components: \n"
+                        + " activity: " + incActivities + "\n"
+                        + " service: " + incServices + "\n"
+                        + " receiver: " + incReceivers + "\n"
+                        + " provider: " + incProviders + "\n"
+                );
             }
 
             // generate increment manifest.
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/Configuration.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/Configuration.java
index 6ddbfe70..dc655158 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/Configuration.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/Configuration.java
@@ -567,9 +567,13 @@ private void readResPatternsFromXml(Node node) throws IOException {
                         mResRawPattern.add(value);
                         addToPatterns(value, mResFilePattern);
                     } else if (tagName.equals(ATTR_IGNORE_CHANGE)) {
-                        addToPatterns(value, mResIgnoreChangePattern);
+                        if (!Utils.isBlank(value)) {
+                            addToPatterns(value, mResIgnoreChangePattern);
+                        }
                     } else if (tagName.equals(ATTR_IGNORE_CHANGE_WARNING)) {
-                        addToPatterns(value, mResIgnoreChangeWarningPattern);
+                        if (!Utils.isBlank(value)) {
+                            addToPatterns(value, mResIgnoreChangeWarningPattern);
+                        }
                     } else if (tagName.equals(ATTR_RES_LARGE_MOD)) {
                         mLargeModSize = Integer.valueOf(value);
                     } else {
diff --git a/tinker-sample-android/build.gradle b/tinker-sample-android/build.gradle
index c055f5fa..ed57cac0 100644
--- a/tinker-sample-android/build.gradle
+++ b/tinker-sample-android/build.gradle
@@ -7,7 +7,7 @@ buildscript {
     }
     dependencies {
         if (project.hasProperty('GRADLE_3') && GRADLE_3.equalsIgnoreCase('TRUE')) {
-            classpath 'com.android.tools.build:gradle:3.1.0-alpha06'
+            classpath 'com.android.tools.build:gradle:3.2.0-alpha02'
         } else {
             classpath 'com.android.tools.build:gradle:2.3.3'
         }
diff --git a/tinker-sample-android/gradle.properties b/tinker-sample-android/gradle.properties
index d71a66a0..2a7b1269 100644
--- a/tinker-sample-android/gradle.properties
+++ b/tinker-sample-android/gradle.properties
@@ -17,5 +17,5 @@
 # http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
 # org.gradle.parallel=true
 
-TINKER_VERSION=1.9.6
+TINKER_VERSION=1.9.8
 GRADLE_3=true
\ No newline at end of file
diff --git a/tinker-sample-android/gradle/wrapper/gradle-wrapper.properties b/tinker-sample-android/gradle/wrapper/gradle-wrapper.properties
index b08c4560..860d32cb 100644
--- a/tinker-sample-android/gradle/wrapper/gradle-wrapper.properties
+++ b/tinker-sample-android/gradle/wrapper/gradle-wrapper.properties
@@ -3,4 +3,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.4-rc-3-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.5-all.zip
