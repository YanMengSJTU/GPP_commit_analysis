diff --git a/gradle.properties b/gradle.properties
index 0667ab7c..8842bf2c 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -16,5 +16,5 @@
 # This option should only be used with decoupled projects. More details, visit
 # http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
 # org.gradle.parallel=true
-VERSION_NAME_PREFIX=1.7.1
+VERSION_NAME_PREFIX=1.8.0
 VERSION_NAME_SUFFIX=
\ No newline at end of file
diff --git a/settings.gradle b/settings.gradle
index ed01852c..fd725222 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -2,6 +2,7 @@ include ':tinker-commons'
 include ':tinker-android:tinker-android-loader'
 include ':tinker-android:tinker-android-lib'
 include ':tinker-android:tinker-android-anno'
+include ':tinker-android:tinker-server-client'
 include ':tinker-build:tinker-patch-cli'
 include ':tinker-build:tinker-patch-lib'
 include ':tinker-build:tinker-patch-gradle-plugin'
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/DefaultPatchListener.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/DefaultPatchListener.java
index f0f3055f..b4cf11d0 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/DefaultPatchListener.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/DefaultPatchListener.java
@@ -60,7 +60,7 @@ public int onPatchReceived(String path, boolean isUpgrade) {
 
     protected int patchCheck(String path, boolean isUpgrade) {
         Tinker manager = Tinker.with(context);
-        //check SharePrefenences also
+        //check SharePreferences also
         if (!manager.isTinkerEnabled() || !ShareTinkerInternals.isTinkerEnableWithSharedPreferences(context)) {
             return ShareConstants.ERROR_PATCH_DISABLE;
         }
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/TinkerPatchService.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/TinkerPatchService.java
index 75f254af..12281e2c 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/TinkerPatchService.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/TinkerPatchService.java
@@ -149,6 +149,10 @@ protected void onHandleIntent(Intent intent) {
     }
 
     private void increasingPriority() {
+        if (Build.VERSION.SDK_INT > 24) {
+            TinkerLog.i(TAG, "for Android 7.1, we just ignore increasingPriority job");
+            return;
+        }
         TinkerLog.i(TAG, "try to increase patch process priority");
         Notification notification = new Notification();
         if (Build.VERSION.SDK_INT < 18) {
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java
index c21c327e..96925995 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java
@@ -29,6 +29,7 @@
 import java.lang.reflect.Method;
 import java.util.Collection;
 import java.util.HashMap;
+import java.util.Map;
 
 import static android.os.Build.VERSION.SDK_INT;
 import static android.os.Build.VERSION_CODES.KITKAT;
@@ -44,8 +45,28 @@
     private static Method       ensureStringBlocksMethod = null;
     private static Field        assetsFiled              = null;
     private static Field        resourcesImplFiled      = null;
+    private static Field        resDir      = null;
 
     public static void isResourceCanPatch(Context context) throws Throwable {
+        //   - Replace mResDir to point to the external resource file instead of the .apk. This is
+        //     used as the asset path for new Resources objects.
+        //   - Set Application#mLoadedApk to the found LoadedApk instance
+
+        // Find the ActivityThread instance for the current thread
+        Class<?> activityThread = Class.forName("android.app.ActivityThread");
+        Object currentActivityThread = getActivityThread(context, activityThread);
+        // API version 8 has PackageInfo, 10 has LoadedApk. 9, I don't know.
+        Class<?> loadedApkClass;
+        try {
+            loadedApkClass = Class.forName("android.app.LoadedApk");
+        } catch (ClassNotFoundException e) {
+            loadedApkClass = Class.forName("android.app.ActivityThread$PackageInfo");
+        }
+        Field mApplication = loadedApkClass.getDeclaredField("mApplication");
+        mApplication.setAccessible(true);
+        resDir = loadedApkClass.getDeclaredField("mResDir");
+        resDir.setAccessible(true);
+
         /*
         (Note: the resource directory is *also* inserted into the loadedApk in
         monkeyPatchApplication)
@@ -110,13 +131,11 @@ public static void isResourceCanPatch(Context context) throws Throwable {
                 references = (Collection<WeakReference<Resources>>) mResourceReferences.get(resourcesManager);
             }
         } else {
-            Class<?> activityThread = Class.forName("android.app.ActivityThread");
             Field fMActiveResources = activityThread.getDeclaredField("mActiveResources");
             fMActiveResources.setAccessible(true);
-            Object thread = getActivityThread(context, activityThread);
             @SuppressWarnings("unchecked")
             HashMap<?, WeakReference<Resources>> map =
-                (HashMap<?, WeakReference<Resources>>) fMActiveResources.get(thread);
+                (HashMap<?, WeakReference<Resources>>) fMActiveResources.get(currentActivityThread);
             references = map.values();
         }
         // check resource
@@ -137,7 +156,27 @@ public static void monkeyPatchExistingResources(Context context, String external
         if (externalResourceFile == null) {
             return;
         }
+        // Find the ActivityThread instance for the current thread
+        Class<?> activityThread = Class.forName("android.app.ActivityThread");
+        Object currentActivityThread = getActivityThread(context, activityThread);
+
+        for (String fieldName : new String[]{"mPackages", "mResourcePackages"}) {
+            Field field = activityThread.getDeclaredField(fieldName);
+            field.setAccessible(true);
+            Object value = field.get(currentActivityThread);
+
+            for (Map.Entry<String, WeakReference<?>> entry
+                : ((Map<String, WeakReference<?>>) value).entrySet()) {
+                Object loadedApk = entry.getValue().get();
+                if (loadedApk == null) {
+                    continue;
+                }
+                if (externalResourceFile != null) {
+                   resDir.set(loadedApk, externalResourceFile);
+                }
 
+            }
+        }
         // Create a new AssetManager instance and point it to the resources installed under
         // /sdcard
 
diff --git a/tinker-android/tinker-server-client/.gitignore b/tinker-android/tinker-server-client/.gitignore
new file mode 100644
index 00000000..796b96d1
--- /dev/null
+++ b/tinker-android/tinker-server-client/.gitignore
@@ -0,0 +1 @@
+/build
diff --git a/tinker-android/tinker-server-client/build.gradle b/tinker-android/tinker-server-client/build.gradle
new file mode 100644
index 00000000..c33f1868
--- /dev/null
+++ b/tinker-android/tinker-server-client/build.gradle
@@ -0,0 +1,35 @@
+apply plugin: 'com.android.library'
+
+
+version rootProject.ext.VERSION_NAME
+group rootProject.ext.GROUP
+
+android {
+    compileSdkVersion rootProject.ext.compileSdkVersion
+    buildToolsVersion rootProject.ext.buildToolsVersion
+
+    defaultConfig {
+        minSdkVersion rootProject.ext.minSdkVersion
+        targetSdkVersion rootProject.ext.targetSdkVersion
+    }
+}
+
+dependencies {
+    compile fileTree(dir: 'libs', include: ['*.jar'])
+    compile project(':tinker-android:tinker-android-lib')
+    testCompile 'junit:junit:4.12'
+}
+
+task buildSdk(type: Copy, dependsOn: [build]) {
+    from("$buildDir/outputs/aar/") {
+        include "${project.getName()}-release.aar"
+    }
+
+    into(rootProject.file("buildSdk/android/"))
+    rename { String fileName ->
+        fileName.replace("release", "${version}")
+    }
+}
+
+apply from: rootProject.file('gradle/android-artifacts.gradle')
+apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
diff --git a/tinker-android/tinker-server-client/gradle.properties b/tinker-android/tinker-server-client/gradle.properties
new file mode 100644
index 00000000..165bd6ba
--- /dev/null
+++ b/tinker-android/tinker-server-client/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=tinker-server-client
+POM_NAME=Tinker Server Client
+POM_PACKAGING=jar
\ No newline at end of file
diff --git a/tinker-android/tinker-server-client/proguard-rules.pro b/tinker-android/tinker-server-client/proguard-rules.pro
new file mode 100644
index 00000000..ca7ea794
--- /dev/null
+++ b/tinker-android/tinker-server-client/proguard-rules.pro
@@ -0,0 +1,17 @@
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in /Users/zhangshaowen/Library/Android/sdk/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the proguardFiles
+# directive in build.gradle.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
diff --git a/tinker-android/tinker-server-client/src/androidTest/java/com/tencent/tinker/server/ApplicationTest.java b/tinker-android/tinker-server-client/src/androidTest/java/com/tencent/tinker/server/ApplicationTest.java
new file mode 100644
index 00000000..bfd398e1
--- /dev/null
+++ b/tinker-android/tinker-server-client/src/androidTest/java/com/tencent/tinker/server/ApplicationTest.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2016 Tencent WeChat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.server;
+
+import android.app.Application;
+import android.test.ApplicationTestCase;
+
+/**
+ * <a href="http://d.android.com/tools/testing/testing_android.html">Testing Fundamentals</a>
+ */
+public class ApplicationTest extends ApplicationTestCase<Application> {
+    public ApplicationTest() {
+        super(Application.class);
+    }
+}
\ No newline at end of file
diff --git a/tinker-android/tinker-server-client/src/main/AndroidManifest.xml b/tinker-android/tinker-server-client/src/main/AndroidManifest.xml
new file mode 100644
index 00000000..0b765d8f
--- /dev/null
+++ b/tinker-android/tinker-server-client/src/main/AndroidManifest.xml
@@ -0,0 +1,8 @@
+<manifest package="com.tencent.tinker.server"
+    >
+
+    <application>
+
+    </application>
+
+</manifest>
diff --git a/tinker-android/tinker-server-client/src/main/java/com/tencent/tinker/server/TinKerClientAPI.java b/tinker-android/tinker-server-client/src/main/java/com/tencent/tinker/server/TinKerClientAPI.java
new file mode 100644
index 00000000..2710853a
--- /dev/null
+++ b/tinker-android/tinker-server-client/src/main/java/com/tencent/tinker/server/TinKerClientAPI.java
@@ -0,0 +1,67 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.server;
+
+import android.content.Context;
+
+import com.tencent.tinker.server.model.DataFetcher;
+
+import java.io.File;
+
+/**
+ * Created by sun on 27/09/2016.
+ */
+
+public interface TinkerClientAPI {
+
+    String REPORT_SUCCESS_URL = "http://stat.tinkerpatch.com/succ.php";
+    String REPORT_FAIL_URL = "http://stat.tinkerpatch.com/err.php";
+    /**
+     * 每次启动或唤醒调请求 http://{Host}/{appKey}/{appVersion}?d={deviceId}&v={timestamp}
+     */
+    void sync(Context context, DataFetcher.DataCallback<String> callback);
+
+    /**
+     * 若本地未下载过这个补丁版本，则请求
+     * http://{Host}/{appKey}/{appVersion}/file{patchVersion}?d={deviceId}&v={timestamp}
+     */
+    void download(
+        Context context,
+        String patchVersion,
+        String filePath,
+        DataFetcher.DataCallback<? super File> callback
+    );
+
+    /**
+     * 用户补丁应用成功上报 http://stat.tinkerpatch.com/succ.php
+     * k:  appKey
+     * av: appVersion，当前app版本号
+     * pv: patchVersion，应用的补丁版本号
+     * t:  平台类型，填数字1
+     */
+    void reportSuccess(Context context, String patchVersion);
+
+    /**
+     * 应用补丁失败上报 http://stat.tinkerpatch.com/err.php
+     * k:  appKey
+     * av: appVersion，当前app版本号
+     * pv: patchVersion，应用的补丁版本号
+     * t:  平台类型，填数字1
+     * code: 错误码
+     */
+    void reportFail(Context context, String patchVersion, Integer errCode);
+}
diff --git a/tinker-android/tinker-server-client/src/main/java/com/tencent/tinker/server/TinkerClientImp.java b/tinker-android/tinker-server-client/src/main/java/com/tencent/tinker/server/TinkerClientImp.java
new file mode 100644
index 00000000..20d613ad
--- /dev/null
+++ b/tinker-android/tinker-server-client/src/main/java/com/tencent/tinker/server/TinkerClientImp.java
@@ -0,0 +1,395 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.server;
+
+import android.content.Context;
+import android.net.Uri;
+import android.text.TextUtils;
+
+import com.tencent.tinker.lib.util.TinkerLog;
+import com.tencent.tinker.server.model.DataFetcher;
+import com.tencent.tinker.server.model.TinkerClientUrl;
+import com.tencent.tinker.server.model.request.FailReport;
+import com.tencent.tinker.server.model.request.SuccessReport;
+import com.tencent.tinker.server.model.response.SyncResponse;
+import com.tencent.tinker.server.urlconnection.UrlConnectionUrlLoader;
+import com.tencent.tinker.server.utils.Conditions;
+import com.tencent.tinker.server.utils.Installation;
+import com.tencent.tinker.server.utils.Preconditions;
+import com.tencent.tinker.server.utils.Utils;
+import com.tencent.tinker.server.utils.VersionUtils;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+
+public class TinkerClientImp implements TinkerClientAPI {
+
+    public static final String TAG = "Tinker.ClientImp";
+
+    private static volatile TinkerClientImp        client;
+
+    private final String                 appVersion;
+    private final String                 appKey;
+    private final String                 host;
+    private final boolean                debug;
+    private final Conditions             conditions;
+    private       UrlConnectionUrlLoader loader;
+
+    TinkerClientImp(String appKey, String appVersion, String host, Boolean debug, Conditions conditions) {
+        this.appVersion = appVersion;
+        this.appKey = appKey;
+        this.host = host;
+        this.debug = debug;
+        this.conditions = conditions;
+    }
+
+    /**
+     * Singleton get method for Tinker client, you need invoke
+     * {@link #init(Context, String, String, Boolean)} before it invoke.
+     *
+     * @return the instance of {@link TinkerClientImp}
+     */
+    public static TinkerClientImp get() {
+        if (client == null) {
+            throw new RuntimeException("Please invoke init Tinker Client first");
+        }
+        return client;
+    }
+
+    /**
+     * init the Tinker Client, it only effect at first time.
+     * you should only invoke once in your app lifecycle
+     *
+     * @param context    {@link Context} context
+     * @param appKey     your appKey get from <a href=tinkerpatch.com>tinkerpatch.com<a/>
+     * @param appVersion your app version, this is "App版本号" in tinkerpatch.com
+     * @param debug      use debug config, which is "开发预览" in tinkerpatch.com
+     * @return {@link #TinkerClientImp} tinker patch client
+     */
+    public static TinkerClientImp init(Context context, String appKey, String appVersion, Boolean debug) {
+        if (client == null) {
+            synchronized (TinkerClientImp.class) {
+                if (client == null) {
+                    client = new Builder()
+                        .appKey(appKey)
+                        .appVersion(appVersion)
+                        .debug(debug)
+                        .conditions(context)
+                        .build();
+
+                    client.loader = new UrlConnectionUrlLoader();
+                }
+            }
+        }
+        return client;
+    }
+
+    public TinkerClientImp params(String key, String value) {
+        this.conditions.set(key, value);
+        return this;
+    }
+
+    public void save(Context context) {
+        try {
+            this.conditions.save(context);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public void update(final Context context, final DataFetcher.DataCallback<? super File> callback) {
+
+        if (callback == null) {
+            throw new RuntimeException("callback can't be null");
+        }
+
+        sync(context, new DataFetcher.DataCallback<String>() {
+            @Override
+            public void onDataReady(String data) {
+                SyncResponse response = SyncResponse.fromJson(data);
+                if (response == null) {
+                    callback.onLoadFailed(new RuntimeException("Can't sync with version: response == null"));
+                } else {
+
+                    DataFetcher.DataCallback<File> downloadCallback = new DataFetcher.DataCallback<File>() {
+                        @Override
+                        public void onDataReady(File data) {
+                            callback.onDataReady(data);
+                        }
+
+                        @Override
+                        public void onLoadFailed(Exception e) {
+                            callback.onLoadFailed(e);
+                        }
+                    };
+
+                    if (isUpdate(context, response.version)
+                        && !response.isPaused
+                        && Utils.isInGrayGroup(response.grayValue, context)
+                        && conditions.check(response.conditions)) {
+
+                        String patchPath = getPatchFilePath(context, response.version);
+                        download(context, response.version, patchPath, downloadCallback);
+                    } else {
+                        TinkerLog.i(TAG, "Needn't update, sync response is: " + response.toString()
+                            + "\ngray: " + Installation.grayValue(context));
+                    }
+                }
+            }
+
+            @Override
+            public void onLoadFailed(Exception e) {
+                callback.onLoadFailed(e);
+            }
+        });
+    }
+
+    @Override
+    public void sync(final Context context, final DataFetcher.DataCallback<String> callback) {
+        Uri.Builder urlBuilder = Uri.parse(this.host).buildUpon();
+        if (client.debug) {
+            urlBuilder.appendPath("dev");
+        }
+        final String url = urlBuilder.appendPath(this.appKey)
+            .appendPath(this.appVersion)
+            .appendQueryParameter("d", Installation.id(context))
+            .appendQueryParameter("v", String.valueOf(System.currentTimeMillis()))
+            .build().toString();
+
+        TinkerClientUrl tkClientUrl = new TinkerClientUrl.Builder().url(url).build();
+
+        final DataFetcher<InputStream> dataFetcher = loader.buildLoadData(tkClientUrl);
+        dataFetcher.loadData(new DataFetcher.DataCallback<InputStream>() {
+            @Override
+            public void onDataReady(InputStream data) {
+                if (callback == null) {
+                    return;
+                }
+                try {
+                    String response = Utils.readStreamToString(data, Utils.CHARSET);
+                    SyncResponse.fromJson(response);
+                    callback.onDataReady(response);
+                } catch (Exception e) {
+                    callback.onLoadFailed(e);
+                } finally {
+                    dataFetcher.cleanup();
+                }
+            }
+
+            @Override
+            public void onLoadFailed(Exception e) {
+                if (callback == null) {
+                    return;
+                }
+                try {
+                    callback.onLoadFailed(e);
+                } finally {
+                    dataFetcher.cleanup();
+                }
+            }
+        });
+    }
+
+    @Override
+    public void download(final Context context,
+                         final String patchVersion,
+                         final String filePath,
+                         final DataFetcher.DataCallback<? super File> callback) {
+
+        Preconditions.checkNotEmpty(patchVersion);
+        final String url = Uri.parse(this.host)
+            .buildUpon()
+            .appendPath(this.appKey)
+            .appendPath(this.appVersion)
+            .appendPath(String.format("file%s", patchVersion))
+            .appendQueryParameter("d", Installation.id(context))
+            .appendQueryParameter("v", String.valueOf(System.currentTimeMillis()))
+            .build().toString();
+
+        TinkerClientUrl tkClientUrl = new TinkerClientUrl.Builder().url(url).build();
+
+        final DataFetcher<InputStream> dataFetcher = loader.buildLoadData(tkClientUrl);
+        dataFetcher.loadData(new DataFetcher.DataCallback<InputStream>() {
+            @Override
+            public void onDataReady(InputStream data) {
+                if (callback == null) {
+                    return;
+                }
+                try {
+                    callback.onDataReady(Utils.readStreamToFile(data, filePath));
+                    VersionUtils.update(context, Integer.parseInt(patchVersion), filePath);
+                } catch (Exception e) {
+                    callback.onLoadFailed(e);
+                } finally {
+                    dataFetcher.cleanup();
+                }
+            }
+
+            @Override
+            public void onLoadFailed(Exception e) {
+                if (callback == null) {
+                    return;
+                }
+
+                try {
+                    callback.onLoadFailed(e);
+                } finally {
+                    dataFetcher.cleanup();
+                }
+            }
+        });
+    }
+
+    @Override
+    public void reportSuccess(Context context, String patchVersion) {
+        Uri.Builder urlBuilder = Uri.parse(TinkerClientAPI.REPORT_SUCCESS_URL).buildUpon();
+        final String url = urlBuilder.build().toString();
+        SuccessReport report = new SuccessReport(this.appKey, this.appVersion, patchVersion);
+        TinkerClientUrl tkClientUrl = new TinkerClientUrl.Builder()
+            .url(url)
+            .body(report.toJson())
+            .method("POST").build();
+        final DataFetcher<InputStream> dataFetcher = loader.buildLoadData(tkClientUrl);
+        dataFetcher.loadData(new DataFetcher.DataCallback<InputStream>() {
+            @Override
+            public void onDataReady(InputStream data) {
+                TinkerLog.d(TAG, "reportSuccess successfully");
+            }
+
+            @Override
+            public void onLoadFailed(Exception e) {
+                TinkerLog.e(TAG, "reportSuccess error", e);
+            }
+        });
+    }
+
+    @Override
+    public void reportFail(Context context, String patchVersion, Integer errCode) {
+        Uri.Builder urlBuilder = Uri.parse(TinkerClientAPI.REPORT_FAIL_URL).buildUpon();
+        final String url = urlBuilder.build().toString();
+        FailReport report = new FailReport(this.appKey, this.appVersion, patchVersion, errCode);
+        TinkerClientUrl tkClientUrl = new TinkerClientUrl.Builder()
+            .url(url)
+            .body(report.toJson())
+            .method("POST").build();
+        final DataFetcher<InputStream> dataFetcher = loader.buildLoadData(tkClientUrl);
+        dataFetcher.loadData(new DataFetcher.DataCallback<InputStream>() {
+            @Override
+            public void onDataReady(InputStream data) {
+                TinkerLog.d(TAG, "reportFail successfully");
+            }
+
+            @Override
+            public void onLoadFailed(Exception e) {
+                TinkerLog.e(TAG, "reportSuccess error", e);
+            }
+        });
+    }
+
+    /**
+     * Get current patch version
+     *
+     * @param context {@link Context}
+     * @return patch version
+     */
+    public Integer getCurrentPatchVersoin(Context context) {
+        return VersionUtils.getCurrentVersion(context);
+    }
+
+    public String getAppVersion() {
+        return appVersion;
+    }
+
+    public String getAppKey() {
+        return appKey;
+    }
+
+    public String getHost() {
+        return host;
+    }
+
+    public boolean isDebug() {
+        return debug;
+    }
+
+    public Conditions getConditions() {
+        return conditions;
+    }
+
+    String getPatchFilePath(Context context, String version) {
+        File file = new File(context.getFilesDir(), Utils.DEFAULT_PATCH_PATH_PREFIX + version);
+        return file.getAbsolutePath();
+    }
+
+    Boolean isUpdate(Context context, String version) {
+        Integer latestVersion = Integer.parseInt(version);
+        Integer currentVersion = VersionUtils.getCurrentVersion(context);
+        return latestVersion > currentVersion;
+    }
+
+    static class Builder {
+        private static final String HOST_URL = "http://q.tinkerpatch.com";
+        private String     appVersion;
+        private String     appKey;
+        private String     host;
+        private Boolean    debug;
+        private Conditions conditions;
+
+        TinkerClientImp.Builder host(String host) {
+            this.host = host;
+            return this;
+        }
+
+        TinkerClientImp.Builder appKey(String appKey) {
+            this.appKey = appKey;
+            return this;
+        }
+
+        TinkerClientImp.Builder appVersion(String appVersion) {
+            this.appVersion = appVersion;
+            return this;
+        }
+
+        TinkerClientImp.Builder debug(boolean debug) {
+            this.debug = debug;
+            return this;
+        }
+
+        TinkerClientImp.Builder conditions(Context context) {
+            this.conditions = new Conditions(context);
+            return this;
+        }
+
+        void makeDefault() {
+            if (TextUtils.isEmpty(host)) {
+                this.host = HOST_URL;
+            }
+            if (TextUtils.isEmpty(this.appKey) || TextUtils.isEmpty(this.appVersion)) {
+                throw new RuntimeException("You need setup Appkey and AppVersion");
+            }
+            if (this.conditions == null) {
+                throw new RuntimeException("You need init conditions property");
+            }
+        }
+
+        public TinkerClientImp build() {
+            makeDefault();
+            return new TinkerClientImp(this.appKey, this.appVersion, this.host, this.debug, this.conditions);
+        }
+    }
+}
diff --git a/tinker-android/tinker-server-client/src/main/java/com/tencent/tinker/server/TinkerServerClient.java b/tinker-android/tinker-server-client/src/main/java/com/tencent/tinker/server/TinkerServerClient.java
new file mode 100644
index 00000000..3b4284f2
--- /dev/null
+++ b/tinker-android/tinker-server-client/src/main/java/com/tencent/tinker/server/TinkerServerClient.java
@@ -0,0 +1,92 @@
+/*
+ * Copyright (C) 2016 Tencent WeChat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.server;
+
+import android.content.Context;
+import android.content.SharedPreferences;
+
+import com.tencent.tinker.lib.tinker.Tinker;
+import com.tencent.tinker.lib.util.TinkerLog;
+import com.tencent.tinker.loader.TinkerRuntimeException;
+import com.tencent.tinker.loader.shareutil.ShareConstants;
+import com.tencent.tinker.loader.shareutil.ShareTinkerInternals;
+import com.tencent.tinker.server.model.DataFetcher;
+
+/**
+ * Created by zhangshaowen on 16/5/29.
+ */
+public class TinkerServerClient {
+    private static final String TAG = "Tinker.ServerClient";
+
+    private static final String TINKER_LAST_CHECK = "tinker_last_check";
+
+    private static final long DEFAULT_CHECK_INTERVAL = 1 * 3600 * 1000;
+    private static final long NEVER_CHECK_UPDATE     = -1;
+
+    private long checkInterval = DEFAULT_CHECK_INTERVAL;
+
+    private Tinker          tinker;
+    private Context         context;
+    private TinkerClientImp tinkerClientImp;
+
+    public TinkerServerClient(Context context, Tinker tinker, String appKey, String appVersion, Boolean debug) {
+        this.tinker = tinker;
+        this.context = context;
+        this.tinkerClientImp = TinkerClientImp.init(context, appKey, appVersion, debug);
+    }
+
+    public void checkTinkerUpdate() {
+        //check SharePreferences also
+        if (!tinker.isTinkerEnabled() || !ShareTinkerInternals.isTinkerEnableWithSharedPreferences(context)) {
+            TinkerLog.e(TAG, "tinker is disable, just return");
+            return;
+        }
+        SharedPreferences sp = context.getSharedPreferences(ShareConstants.TINKER_SHARE_PREFERENCE_CONFIG, Context.MODE_MULTI_PROCESS);
+        long last = sp.getLong(TINKER_LAST_CHECK, 0);
+        if (last == NEVER_CHECK_UPDATE) {
+            TinkerLog.i(TAG, "tinker update is disabled, with never check flag!");
+            return;
+        }
+        long interval = System.currentTimeMillis() - last;
+        if (tinkerClientImp.isDebug() || interval >= checkInterval) {
+            sp.edit().putLong(TINKER_LAST_CHECK, System.currentTimeMillis()).commit();
+            tinkerClientImp.sync(context, new DataFetcher.DataCallback<String>() {
+                @Override
+                public void onDataReady(String data) {
+                    TinkerLog.i(TAG, "tinker sync onDataReady:" + data);
+                }
+
+                @Override
+                public void onLoadFailed(Exception e) {
+                    TinkerLog.i(TAG, "tinker sync onLoadFailed:" + e);
+                }
+            });
+        } else {
+            TinkerLog.i(TAG, "tinker sync should wait interval %ss", (checkInterval - interval) / 1000);
+        }
+
+        return;
+    }
+
+    public void setCheckIntervalByHours(int hours) {
+        if (hours <= 0 || hours > 24) {
+            throw new TinkerRuntimeException("hours must be between 0 and 24");
+        }
+        checkInterval = hours * 3600 * 1000;
+    }
+
+}
diff --git a/tinker-android/tinker-server-client/src/main/java/com/tencent/tinker/server/model/DataFetcher.java b/tinker-android/tinker-server-client/src/main/java/com/tencent/tinker/server/model/DataFetcher.java
new file mode 100644
index 00000000..6c0e2844
--- /dev/null
+++ b/tinker-android/tinker-server-client/src/main/java/com/tencent/tinker/server/model/DataFetcher.java
@@ -0,0 +1,73 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.server.model;
+
+/**
+ * @param <T> The type of data to be loaded (InputStream, byte[], File etc).
+ */
+public interface DataFetcher<T> {
+
+    /**
+     * Synchronously fetch data from which a resource can be decoded.
+     * <p>
+     * <p> This will always be called on
+     * background thread so it is safe to perform long running tasks here. Any third party libraries
+     * called must be thread safe since this method will be called from a thread in a {@link
+     * java.util.concurrent.ExecutorService} that may have more than one background thread. </p>
+     * <p>
+     * <p> This method will only be called when the corresponding resource is not in the cache. </p>
+     * <p>
+     * <p> Note - this method will be run on a background thread so blocking I/O is safe. </p>
+     *
+     * @see #cleanup() where the data retuned will be cleaned up
+     */
+    void loadData(DataCallback<? super T> callback);
+
+    /**
+     * Cleanup or recycle any resources used by this data fetcher. This method will be called in a
+     * finally block after the data provided by
+     * <p> Note - this method will be run on a background thread so blocking I/O is safe. </p>
+     */
+    void cleanup();
+
+    void cancel();
+
+    /**
+     * Returns the class of the data this fetcher will attempt to obtain.
+     */
+    Class<T> getDataClass();
+
+    /**
+     * Callback that should be called when data has been loaded and is available, or when the load
+     * fails.
+     *
+     * @param <T> The type of data that will be loaded.
+     */
+    interface DataCallback<T> {
+        /**
+         * Called with the loaded data if the load succeeded, or with {@code null} if the load failed.
+         */
+        void onDataReady(T data);
+
+        /**
+         * Called when the load fails.
+         *
+         * @param e a non-null {@link Exception} indicating why the load failed.
+         */
+        void onLoadFailed(Exception e);
+    }
+}
diff --git a/tinker-android/tinker-server-client/src/main/java/com/tencent/tinker/server/model/Headers.java b/tinker-android/tinker-server-client/src/main/java/com/tencent/tinker/server/model/Headers.java
new file mode 100644
index 00000000..75dea199
--- /dev/null
+++ b/tinker-android/tinker-server-client/src/main/java/com/tencent/tinker/server/model/Headers.java
@@ -0,0 +1,87 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.server.model;
+
+import android.text.TextUtils;
+
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+
+class Headers {
+
+    /**
+     * A Headers object containing reasonable defaults that should be used when users don't want
+     * to provide their own headers.
+     */
+    public static final Headers DEFAULT = new Headers.Builder().build();
+
+    final Map<String, String> headers;
+
+    Headers(Map<String, String> headers) {
+        this.headers = new HashMap<>(headers);
+    }
+
+    public Map<String, String> getHeaders() {
+        return headers;
+    }
+
+    private static class Builder {
+        private static final String USER_AGENT_HEADER = "User-Agent";
+        private static final String DEFAULT_USER_AGENT = System.getProperty("http.agent");
+        private static final String ENCODING_HEADER = "Accept-Encoding";
+        private static final String DEFAULT_ENCODING = "identity";
+        private static final Map<String, String> DEFAULT_HEADERS;
+
+        static {
+            Map<String, String> temp = new HashMap<>(2);
+            if (!TextUtils.isEmpty(DEFAULT_USER_AGENT)) {
+                temp.put(USER_AGENT_HEADER, DEFAULT_USER_AGENT);
+            }
+            temp.put(ENCODING_HEADER, DEFAULT_ENCODING);
+            DEFAULT_HEADERS = Collections.unmodifiableMap(temp);
+        }
+
+        private Map<String, String> headers;
+
+        Builder() {
+            // This constructor is intentionally empty. Nothing special is needed here.
+        }
+
+        public Builder setHeader(String key, String value) {
+            if (headers == null) {
+                headers = new HashMap<>();
+            }
+            if (!TextUtils.isEmpty(key)) {
+                if (value == null && headers.containsKey(key)) {
+                    headers.remove(key);
+                } else {
+                    headers.put(key, value);
+                }
+            }
+            return this;
+        }
+
+        public Headers build() {
+            if (headers == null || headers.isEmpty()) {
+                return new Headers(DEFAULT_HEADERS);
+            } else {
+                return new Headers(Collections.unmodifiableMap(headers));
+            }
+        }
+    }
+}
diff --git a/tinker-android/tinker-server-client/src/main/java/com/tencent/tinker/server/model/TinkerClientUrl.java b/tinker-android/tinker-server-client/src/main/java/com/tencent/tinker/server/model/TinkerClientUrl.java
new file mode 100644
index 00000000..844fab8d
--- /dev/null
+++ b/tinker-android/tinker-server-client/src/main/java/com/tencent/tinker/server/model/TinkerClientUrl.java
@@ -0,0 +1,153 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.server.model;
+
+import android.net.Uri;
+import android.text.TextUtils;
+
+import com.tencent.tinker.server.utils.Preconditions;
+
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Created by sun on 28/09/2016.
+ */
+
+public class TinkerClientUrl {
+
+    private static final String ALLOWED_URI_CHARS = "@#&=*+-_.,:!?()/~'%";
+
+    private final Headers headers;
+    private final String stringUrl;
+    private final String body;
+    private final String method;
+
+    private String safeStringUrl;
+    private URL safeUrl;
+
+    public TinkerClientUrl(String stringUrl, Headers headers, String body, String method) {
+        this.stringUrl = Preconditions.checkNotEmpty(stringUrl);
+        this.method = Preconditions.checkNotEmpty(method);
+        this.headers = headers;
+        this.body = body;
+    }
+
+    public URL toURL() throws MalformedURLException {
+        return getSafeUrl();
+    }
+
+    public String toStringUrl() {
+        return getSafeStringUrl();
+    }
+
+    public Map<String, String> getHeaders() {
+        return headers.getHeaders();
+    }
+
+    public String getMethod() {
+        return method;
+    }
+
+    public String getBody() {
+        return body;
+    }
+
+    // See http://stackoverflow.com/questions/3286067/url-encoding-in-android. Although the answer
+    // using URI would work, using it would require both decoding and encoding each string which is
+    // more complicated, slower and generates more objects than the solution below. See also issue
+    // #133.
+    private URL getSafeUrl() throws MalformedURLException {
+        if (safeUrl == null) {
+            safeUrl = new URL(getSafeStringUrl());
+        }
+        return safeUrl;
+    }
+
+    private String getSafeStringUrl() {
+        if (TextUtils.isEmpty(safeStringUrl)) {
+            safeStringUrl = Uri.encode(stringUrl, ALLOWED_URI_CHARS);
+        }
+        return safeStringUrl;
+    }
+
+    public static class Builder {
+        private String url;
+        private HashMap<String, String> params;
+        private String body;
+        private String method;
+        private Headers headers;
+
+        public TinkerClientUrl.Builder url(String url) {
+            this.url = url;
+            return this;
+        }
+
+        public TinkerClientUrl.Builder param(String key, Object value) {
+            if (params == null) {
+                this.params = new HashMap<>();
+            }
+            this.params.put(key, String.valueOf(value));
+            return this;
+        }
+
+        public TinkerClientUrl.Builder body(String body) {
+            this.body = body;
+            return this;
+        }
+
+        public TinkerClientUrl.Builder method(String method) {
+            switch (method) {
+                case "GET":
+                case "POST":
+                    this.method = method;
+                    break;
+                default:
+                    throw new RuntimeException("Didn't Supported Method, Please pass the correct method");
+            }
+            return this;
+        }
+
+        public TinkerClientUrl.Builder headers(Headers headers) {
+            this.headers = headers;
+            return this;
+        }
+
+        private void makeDefault() {
+            Uri.Builder urlBuilder = Uri.parse(this.url).buildUpon();
+            if (TextUtils.isEmpty(this.method)) {
+                this.method = "GET";
+            }
+            if (this.headers == null) {
+                this.headers = Headers.DEFAULT;
+            }
+            if (this.params != null) {
+                for (Map.Entry<String, String> entry : params.entrySet()) {
+                    urlBuilder.appendQueryParameter(entry.getKey(), entry.getValue());
+                }
+            }
+            this.url = urlBuilder.build().toString();
+        }
+
+        public TinkerClientUrl build() {
+            makeDefault();
+            return new TinkerClientUrl(this.url, this.headers, this.body, this.method);
+        }
+    }
+}
diff --git a/tinker-android/tinker-server-client/src/main/java/com/tencent/tinker/server/model/request/BaseReport.java b/tinker-android/tinker-server-client/src/main/java/com/tencent/tinker/server/model/request/BaseReport.java
new file mode 100644
index 00000000..aeba6a12
--- /dev/null
+++ b/tinker-android/tinker-server-client/src/main/java/com/tencent/tinker/server/model/request/BaseReport.java
@@ -0,0 +1,55 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.server.model.request;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+/**
+ * Created by sun on 24/10/2016.
+ */
+public class BaseReport {
+    public final String appKey;
+    public final String appVersion;
+    public final String patchVersion;
+    public final Integer platformType;
+
+    public BaseReport(String appKey, String appVersion, String patchVersion) {
+        this.appKey = appKey;
+        this.appVersion = appVersion;
+        this.patchVersion = patchVersion;
+        this.platformType = 1;
+    }
+
+    protected JSONObject toJsonObject() throws JSONException {
+        JSONObject jsonObject = new JSONObject();
+        jsonObject.put("k", appKey);
+        jsonObject.put("av", appVersion);
+        jsonObject.put("pv", patchVersion);
+        jsonObject.put("t", platformType);
+        return jsonObject;
+    }
+
+    public String toJson() {
+        try {
+            return toJsonObject().toString();
+        } catch (JSONException e) {
+            e.printStackTrace();
+            return "";
+        }
+    }
+}
diff --git a/tinker-android/tinker-server-client/src/main/java/com/tencent/tinker/server/model/request/FailReport.java b/tinker-android/tinker-server-client/src/main/java/com/tencent/tinker/server/model/request/FailReport.java
new file mode 100644
index 00000000..2c53ba43
--- /dev/null
+++ b/tinker-android/tinker-server-client/src/main/java/com/tencent/tinker/server/model/request/FailReport.java
@@ -0,0 +1,39 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.server.model.request;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+/**
+ * Created by sun on 24/10/2016.
+ */
+public class FailReport extends BaseReport {
+    public Integer errCode;
+
+    public FailReport(String appKey, String appVersion, String patchVersion, Integer errCode) {
+        super(appKey, appVersion, patchVersion);
+        this.errCode = errCode;
+    }
+
+    @Override
+    protected JSONObject toJsonObject() throws JSONException {
+        JSONObject jsonObject = super.toJsonObject();
+        jsonObject.put("code", errCode);
+        return jsonObject;
+    }
+}
diff --git a/tinker-android/tinker-server-client/src/main/java/com/tencent/tinker/server/model/request/SuccessReport.java b/tinker-android/tinker-server-client/src/main/java/com/tencent/tinker/server/model/request/SuccessReport.java
new file mode 100644
index 00000000..234e4689
--- /dev/null
+++ b/tinker-android/tinker-server-client/src/main/java/com/tencent/tinker/server/model/request/SuccessReport.java
@@ -0,0 +1,27 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.server.model.request;
+
+/**
+ * Created by sun on 24/10/2016.
+ */
+
+public class SuccessReport extends BaseReport {
+    public SuccessReport(String appKey, String appVersion, String patchVersion) {
+        super(appKey, appVersion, patchVersion);
+    }
+}
diff --git a/tinker-android/tinker-server-client/src/main/java/com/tencent/tinker/server/model/response/SyncResponse.java b/tinker-android/tinker-server-client/src/main/java/com/tencent/tinker/server/model/response/SyncResponse.java
new file mode 100644
index 00000000..e4347fcb
--- /dev/null
+++ b/tinker-android/tinker-server-client/src/main/java/com/tencent/tinker/server/model/response/SyncResponse.java
@@ -0,0 +1,67 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.server.model.response;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+/**
+ * Created by sun on 10/10/2016.
+ */
+
+public final class SyncResponse {
+
+    private static final String KEY_VERSION = "v";
+    private static final String KEY_GRAY = "g";
+    private static final String KEY_CONDITIONS = "c";
+    private static final String KEY_PAUSE = "p";
+    public final String version;
+    public final Integer grayValue;
+    public final String conditions;
+    public final Boolean isPaused;
+
+    private SyncResponse(String version, Integer grayValue, String conditions, Boolean pause) {
+        this.version = version;
+        this.conditions = conditions;
+        this.isPaused = pause;
+        if (grayValue == 0) {
+            this.grayValue = null;
+        } else {
+            this.grayValue = grayValue;
+        }
+    }
+
+    public static SyncResponse fromJson(String json) {
+        try {
+            JSONObject jsonObject = new JSONObject(json);
+            String version = jsonObject.getString(KEY_VERSION);
+            String conditions = jsonObject.optString(KEY_CONDITIONS);
+            Integer grayValue = jsonObject.optInt(KEY_GRAY);
+            Integer pauseFlag = jsonObject.optInt(KEY_PAUSE);
+            return new SyncResponse(version, grayValue, conditions, pauseFlag == 1);
+        } catch (JSONException e) {
+            e.printStackTrace();
+        }
+        return null;
+    }
+
+    @Override
+    public String toString() {
+        return "version:" + version + "\ngrayValue:" + grayValue + "\nconditions:" + conditions
+            + "\npause:" + isPaused;
+    }
+}
diff --git a/tinker-android/tinker-server-client/src/main/java/com/tencent/tinker/server/urlconnection/UrlConnectionStreamFetcher.java b/tinker-android/tinker-server-client/src/main/java/com/tencent/tinker/server/urlconnection/UrlConnectionStreamFetcher.java
new file mode 100644
index 00000000..e1c0d41e
--- /dev/null
+++ b/tinker-android/tinker-server-client/src/main/java/com/tencent/tinker/server/urlconnection/UrlConnectionStreamFetcher.java
@@ -0,0 +1,130 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.server.urlconnection;
+
+
+
+import com.tencent.tinker.lib.util.TinkerLog;
+import com.tencent.tinker.server.model.DataFetcher;
+import com.tencent.tinker.server.model.TinkerClientUrl;
+import com.tencent.tinker.server.utils.Preconditions;
+import com.tencent.tinker.server.utils.Utils;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStreamWriter;
+import java.net.HttpURLConnection;
+import java.util.Map;
+import java.util.concurrent.Executor;
+
+
+public class UrlConnectionStreamFetcher implements DataFetcher<InputStream> {
+
+    private static final String TAG = "UrlConnectionFetcher";
+    private final TinkerClientUrl tkUrl;
+    private final Executor        executor;
+    InputStream stream;
+
+    public UrlConnectionStreamFetcher(Executor executor, TinkerClientUrl tkUrl) {
+        this.tkUrl = tkUrl;
+        this.executor = executor;
+    }
+
+    @Override
+    public void loadData(final DataCallback<? super InputStream> callback) {
+        ConnectionWorker worker = new ConnectionWorker(tkUrl, new DataCallback<InputStream>() {
+            @Override
+            public void onDataReady(InputStream data) {
+                stream = data;
+                callback.onDataReady(data);
+            }
+
+            @Override
+            public void onLoadFailed(Exception e) {
+                callback.onLoadFailed(e);
+            }
+        });
+        executor.execute(worker);
+    }
+
+    @Override
+    public void cleanup() {
+        try {
+            if (stream != null) {
+                stream.close();
+            }
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+
+    @Override
+    public void cancel() {
+        // NOT IMPLEMENT
+    }
+
+    @Override
+    public Class<InputStream> getDataClass() {
+        return InputStream.class;
+    }
+
+    private static class ConnectionWorker implements Runnable {
+
+        private final DataCallback<? super InputStream> callback;
+        private final TinkerClientUrl                   url;
+
+        ConnectionWorker(TinkerClientUrl url, DataCallback<? super InputStream> callback) {
+            this.callback = Preconditions.checkNotNull(callback);
+            this.url = Preconditions.checkNotNull(url);
+        }
+
+        @Override
+        public void run() {
+            try {
+                HttpURLConnection conn = (HttpURLConnection) url.toURL().openConnection();
+                conn.setRequestMethod(url.getMethod());
+                conn.setDoOutput(true);
+                conn.setReadTimeout(10000 /* milliseconds */);
+                conn.setConnectTimeout(15000 /* milliseconds */);
+                conn.setInstanceFollowRedirects(false);
+                conn.setUseCaches(false);
+                for (Map.Entry<String, String> entry : url.getHeaders().entrySet()) {
+                    conn.setRequestProperty(entry.getKey(), entry.getValue());
+                }
+                switch (url.getMethod()) {
+                    case "GET":
+                        break;
+                    case "POST":
+                        OutputStreamWriter writer = new OutputStreamWriter(conn.getOutputStream(), Utils.CHARSET);
+                        writer.write(url.getBody());
+                        writer.flush();
+                        writer.close();
+                        break;
+                    default:
+                        throw new RuntimeException("Unsupported request method" + url.getMethod());
+                }
+                conn.connect();
+                TinkerLog.d(TAG, "response code " + conn.getResponseCode() + " msg: " + conn.getResponseMessage());
+                InputStream inputStream = conn.getInputStream();
+                this.callback.onDataReady(inputStream);
+            } catch (IOException e) {
+                e.printStackTrace();
+                this.callback.onLoadFailed(e);
+            }
+        }
+    }
+}
diff --git a/tinker-android/tinker-server-client/src/main/java/com/tencent/tinker/server/urlconnection/UrlConnectionUrlLoader.java b/tinker-android/tinker-server-client/src/main/java/com/tencent/tinker/server/urlconnection/UrlConnectionUrlLoader.java
new file mode 100644
index 00000000..20ac00fe
--- /dev/null
+++ b/tinker-android/tinker-server-client/src/main/java/com/tencent/tinker/server/urlconnection/UrlConnectionUrlLoader.java
@@ -0,0 +1,36 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.server.urlconnection;
+import com.tencent.tinker.server.model.DataFetcher;
+import com.tencent.tinker.server.model.TinkerClientUrl;
+
+import java.io.InputStream;
+import java.util.concurrent.Executor;
+import java.util.concurrent.Executors;
+
+public class UrlConnectionUrlLoader {
+
+    private final Executor executor;
+
+    public UrlConnectionUrlLoader() {
+        executor = Executors.newSingleThreadExecutor();
+    }
+
+    public DataFetcher<InputStream> buildLoadData(TinkerClientUrl url) {
+        return new UrlConnectionStreamFetcher(executor, url);
+    }
+}
diff --git a/tinker-android/tinker-server-client/src/main/java/com/tencent/tinker/server/utils/Conditions.java b/tinker-android/tinker-server-client/src/main/java/com/tencent/tinker/server/utils/Conditions.java
new file mode 100644
index 00000000..ce194593
--- /dev/null
+++ b/tinker-android/tinker-server-client/src/main/java/com/tencent/tinker/server/utils/Conditions.java
@@ -0,0 +1,320 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.server.utils;
+
+import android.content.Context;
+import android.text.TextUtils;
+
+import com.tencent.tinker.lib.util.TinkerLog;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.Stack;
+import java.util.regex.Pattern;
+
+import static com.tencent.tinker.server.TinkerClientImp.TAG;
+
+
+/**
+ * Created by sun on 11/10/2016.
+ */
+
+public class Conditions {
+
+    static final String FILE_NAME = "CONDITIONS_MAP";
+    static final Pattern INT_PATTERN = Pattern.compile("-?[0-9]+");
+
+    private final Map<String, String> properties;
+
+    public Conditions(Context context) {
+        properties = read(context);
+    }
+
+    public Boolean check(String rules) {
+        if (TextUtils.isEmpty(rules)) {
+            return true;
+        }
+        List<String> rpList = Helper.toReversePolish(rules);
+        try {
+            return Helper.calcReversePolish(rpList, properties);
+        } catch (Exception ignore) {
+            TinkerLog.e(TAG, "parse conditions error(have you written '==' as '='?): " + rules);
+            TinkerLog.w(TAG, "exception:" + ignore);
+            return false;
+        }
+    }
+
+    /**
+     * set the k,v to conditions map.
+     * you should invoke {@link #save(Context)} for saving the map to disk
+     * @param key the key
+     * @param value the value
+     * @return {@link Conditions} this
+     */
+    public Conditions set(String key, String value) {
+        properties.put(key, value);
+        return this;
+    }
+
+    /**
+     * Clean all properties. you should invoke {@link #save(Context)} for saving to disk.
+     * @return {@link Conditions} this
+     */
+    public Conditions clean() {
+        properties.clear();
+        return this;
+    }
+
+    /**
+     * save to disk
+     * @param context {@link Context}
+     * @throws IOException
+     */
+    public void save(Context context) throws IOException {
+        File file = new File(context.getFilesDir(), FILE_NAME);
+        ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(file));
+        outputStream.writeObject(properties);
+        outputStream.flush();
+        outputStream.close();
+    }
+
+    private HashMap<String, String> read(Context context) {
+
+        try {
+            File file = new File(context.getFilesDir(), FILE_NAME);
+            if (file.exists()) {
+                ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file));
+                HashMap<String, String> map = (HashMap<String, String>) ois.readObject();
+                ois.close();
+                return map;
+            }
+        } catch (Exception ignore) {
+            ignore.printStackTrace();
+        }
+        return new HashMap<>();
+    }
+
+    static final class Helper {
+        private static final String WITH_DELIMITER = "((?<=[%1$s])|(?=[%1$s]))";
+        private static final List<String> TOKENS = new ArrayList<>(4);
+        private static final HashMap<String, Integer> TOKEN_PRIORITY = new HashMap<>();
+
+        static {
+            TOKENS.add("&");
+            TOKENS.add("|");
+            TOKENS.add("(");
+            TOKENS.add(")");
+
+            TOKEN_PRIORITY.put("&", 2);
+            TOKEN_PRIORITY.put("|", 1);
+            TOKEN_PRIORITY.put("(", 3);
+            TOKEN_PRIORITY.put(")", 3);
+        }
+
+        private Helper() {
+            // A Util Class
+        }
+
+        public static List<String> toReversePolish(String input) {
+            Stack<String> opStack = new Stack<>();
+            List<String> rpList = new LinkedList<>();
+            for (String word : tokenize(input)) {
+                if (isToken(word)) {
+                    pushOp(opStack, rpList, word);
+                } else {
+                    rpList.add(word);
+                }
+            }
+            while (!opStack.isEmpty()) {
+                rpList.add(opStack.pop());
+            }
+            return rpList;
+        }
+
+        private static void pushOp(Stack<String> stack, List<String> rpList, String op) {
+            if (stack.isEmpty() || "(".equals(op)) {
+                stack.push(op);
+                return;
+            }
+
+            if (")".equals(op)) {
+                String tmp;
+                while (!"(".equals(tmp = stack.pop())) {
+                    rpList.add(tmp);
+                }
+                return;
+            }
+            if ("(".equals(stack.peek())) {
+                stack.push(op);
+                return;
+            }
+
+            if (TOKEN_PRIORITY.get(op) > TOKEN_PRIORITY.get(stack.peek())) {
+                stack.push(op);
+            } else {
+                rpList.add(stack.pop());
+                pushOp(stack, rpList, op);
+            }
+        }
+
+        public static Boolean calcReversePolish(List<String> list, Map<String, String> props) {
+            Stack<Object> stack = new Stack<>();
+            for (String word : list) {
+                if (!isToken(word)) {
+                    // lazy calcExpr at pop from stack, some expr needn't calculate.
+                    // such 'true || expr'
+                    stack.push(word);
+                } else {
+                    Boolean left, right;
+                    Object v1, v2;
+                    switch (word) {
+                        case "|":
+                            v1 = stack.pop();
+                            v2 = stack.pop();
+                            left = calcExpr(v1, props);
+                            if (left) {
+                                stack.push(Boolean.TRUE);
+                                continue;
+                            }
+                            right = calcExpr(v2, props);
+                            stack.push(right);
+                            break;
+                        case "&":
+                            v1 = stack.pop();
+                            v2 = stack.pop();
+                            left = calcExpr(v1, props);
+                            if (!left) {
+                                stack.push(Boolean.FALSE);
+                                continue;
+                            }
+                            right = calcExpr(v2, props);
+                            stack.push(right);
+                            break;
+                        default:
+                            throw new RuntimeException("Unsupported Operator: " + word);
+                    }
+                }
+            }
+            return calcExpr(stack.pop(), props);
+        }
+
+        public static Boolean calcExpr(Object obj, Map<String, String> props) {
+            if (obj instanceof String) {
+                return calcExpr((String) obj, props);
+            } else if (obj instanceof Boolean) {
+                return (Boolean) obj;
+            } else {
+                throw new RuntimeException("illegal type pass to calcExpr");
+            }
+        }
+
+        public static Boolean calcExpr(String expr, Map<String, String> props) {
+            boolean isInProps = false;
+            List<String> exprList = splitExpr(expr);
+            String op = exprList.get(1);
+            String left = exprList.get(0);
+            String right = exprList.get(2);
+            if (props.containsKey(left)) {
+                isInProps = true;
+                left = props.get(left);
+            }
+            if (props.containsKey(right)) {
+                isInProps = true;
+                right = props.get(right);
+            }
+            return isInProps && calcExpr(left, right, op);
+        }
+
+        public static Boolean calcExpr(String left, String right, String op) {
+            switch (op) {
+                case "==":
+                    return left.equals(right);
+                case "!=":
+                    return !left.equals(right);
+                case ">=":
+                    if (isInt(left)) {
+                        return Integer.parseInt(left) >= Integer.parseInt(right);
+                    } else {
+                        return left.compareToIgnoreCase(right) >= 0;
+                    }
+                case ">":
+                    if (isInt(left)) {
+                        return Integer.parseInt(left) > Integer.parseInt(right);
+                    } else {
+                        return left.compareToIgnoreCase(right) > 0;
+                    }
+                case "<=":
+                    if (isInt(left)) {
+                        return Integer.parseInt(left) <= Integer.parseInt(right);
+                    } else {
+                        return left.compareToIgnoreCase(right) <= 0;
+                    }
+                case "<":
+                    if (isInt(left)) {
+                        return Integer.parseInt(left) < Integer.parseInt(right);
+                    } else {
+                        return left.compareToIgnoreCase(right) < 0;
+                    }
+                default:
+                    throw new RuntimeException("Unsupported Operator");
+            }
+        }
+
+        public static List<String> splitExpr(String expr) {
+            String[] ops = new String[] {"==", "!=", ">=", "<=", ">", "<"};
+            for (String op : ops) {
+                if (expr.contains(op)) {
+                    int pos = expr.indexOf(op);
+                    String left = expr.substring(0, pos);
+                    String right = expr.substring(pos + op.length(), expr.length());
+                    return Arrays.asList(left, op, right);
+                }
+            }
+            return new ArrayList<>();
+        }
+
+        private static Boolean isToken(String word) {
+            return TOKENS.contains(word);
+        }
+
+        private static List<String> tokenize(String input) {
+            input = input.replaceAll("\\s+", "")
+                .replaceAll("&amp;", "&").replaceAll("&lt;", "<").replaceAll("&gt;", ">")
+                .replaceAll("&&", "&").replaceAll("\\|\\|", "|");
+            List<String> tokens = new ArrayList<>(TOKENS.size());
+            for (String token : TOKENS) {
+                tokens.add(Pattern.quote(token));
+            }
+            String splits = TextUtils.join("|", tokens);
+            return Arrays.asList(input.split(String.format(WITH_DELIMITER, splits)));
+        }
+
+        private static Boolean isInt(String string) {
+            return INT_PATTERN.matcher(string).matches();
+        }
+    }
+}
diff --git a/tinker-android/tinker-server-client/src/main/java/com/tencent/tinker/server/utils/Installation.java b/tinker-android/tinker-server-client/src/main/java/com/tencent/tinker/server/utils/Installation.java
new file mode 100644
index 00000000..c82f0ecc
--- /dev/null
+++ b/tinker-android/tinker-server-client/src/main/java/com/tencent/tinker/server/utils/Installation.java
@@ -0,0 +1,97 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.server.utils;
+
+import android.content.Context;
+
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.RandomAccessFile;
+import java.util.Random;
+import java.util.UUID;
+
+/**
+ * solution from
+ * <a href="http://android-developers.blogspot.com/2011/03/identifying-app-installations.html">
+ * identifying-app-installations</a>
+ */
+public final class Installation {
+    private static final String INSTALLATION = "INSTALLATION";
+    private static final String GRAY_VALUE = "GRAY_VALUE";
+    private static String gID = null;
+    private static Integer gValue = null;
+
+    private Installation() {
+        // A Utils Class
+    }
+
+    public static synchronized String id(Context context) {
+        if (gID == null) {
+            gID = fileValue(context, INSTALLATION, UUID.randomUUID().toString());
+        }
+        return gID;
+    }
+
+    public static synchronized Integer grayValue(Context context) {
+        if (gValue == null) {
+            int g = randInt(1, 10);
+            gValue = Integer.valueOf(fileValue(context, GRAY_VALUE, String.valueOf(g)));
+        }
+        return gValue;
+    }
+
+    private static synchronized String fileValue(Context context, String fileName, String value) {
+        File file = new File(context.getFilesDir(), fileName);
+        try {
+            if (!file.exists()) {
+                writeInstallationFile(file, value);
+            }
+            return readInstallationFile(file);
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    private static String readInstallationFile(File installation) throws IOException {
+        RandomAccessFile f = new RandomAccessFile(installation, "r");
+        byte[] bytes = new byte[(int) f.length()];
+        f.readFully(bytes);
+        f.close();
+        return new String(bytes, Utils.CHARSET);
+    }
+
+    private static void writeInstallationFile(File installation, String value) throws IOException {
+        FileOutputStream out = null;
+        try {
+            out = new FileOutputStream(installation);
+            out.write(value.getBytes(Utils.CHARSET));
+            out.flush();
+        } finally {
+            if (out != null) {
+                out.close();
+            }
+        }
+
+    }
+
+    private static int randInt(int min, int max) {
+        Random rand = new Random();
+        return rand.nextInt((max - min) + 1) + min;
+    }
+}
diff --git a/tinker-android/tinker-server-client/src/main/java/com/tencent/tinker/server/utils/Preconditions.java b/tinker-android/tinker-server-client/src/main/java/com/tencent/tinker/server/utils/Preconditions.java
new file mode 100644
index 00000000..96973a10
--- /dev/null
+++ b/tinker-android/tinker-server-client/src/main/java/com/tencent/tinker/server/utils/Preconditions.java
@@ -0,0 +1,59 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.server.utils;
+
+import android.text.TextUtils;
+
+import java.util.Collection;
+
+public final class Preconditions {
+
+    private Preconditions() {
+        // Utils class.
+    }
+
+    public static void checkArgument(boolean expression, String message) {
+        if (!expression) {
+            throw new IllegalArgumentException(message);
+        }
+    }
+
+    public static <T> T checkNotNull(T arg) {
+        return checkNotNull(arg, "Argument must not be null");
+    }
+
+    public static <T> T checkNotNull(T arg, String message) {
+        if (arg == null) {
+            throw new NullPointerException(message);
+        }
+        return arg;
+    }
+
+    public static String checkNotEmpty(String string) {
+        if (TextUtils.isEmpty(string)) {
+            throw new IllegalArgumentException("Must not be null or empty");
+        }
+        return string;
+    }
+
+    public static <T extends Collection<Y>, Y> T checkNotEmpty(T collection) {
+        if (collection.isEmpty()) {
+            throw new IllegalArgumentException("Must not be empty.");
+        }
+        return collection;
+    }
+}
diff --git a/tinker-android/tinker-server-client/src/main/java/com/tencent/tinker/server/utils/Utils.java b/tinker-android/tinker-server-client/src/main/java/com/tencent/tinker/server/utils/Utils.java
new file mode 100644
index 00000000..9fdbdd07
--- /dev/null
+++ b/tinker-android/tinker-server-client/src/main/java/com/tencent/tinker/server/utils/Utils.java
@@ -0,0 +1,91 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.server.utils;
+
+import android.content.Context;
+
+
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * Created by sun on 9/18/16.
+ */
+
+public final class Utils {
+    public static final String CHARSET = "UTF-8";
+    public static final int BUFFER_SIZE = 4096;
+    public static final String DEFAULT_PATCH_PATH_PREFIX = "tkclient_patch/patch_";
+
+    private Utils() {
+        // A Utils Class
+    }
+
+    public static File readStreamToFile(InputStream inputStream, String filePath) throws IOException {
+        if (inputStream == null) {
+            return null;
+        }
+
+        File file = new File(filePath);
+        File parent = file.getParentFile();
+        if (!parent.exists() && !parent.mkdirs()) {
+            throw new IOException(String.format("Can't create folder %s", parent.getAbsolutePath()));
+        }
+        FileOutputStream fileOutput = new FileOutputStream(file);
+        try {
+            byte[] buffer = new byte[BUFFER_SIZE];
+            int bufferLength;
+            while ((bufferLength = inputStream.read(buffer)) > 0) {
+                fileOutput.write(buffer, 0, bufferLength);
+            }
+        } finally {
+            try {
+                fileOutput.close();
+            } catch (IOException ignored) {
+                // ignored
+            }
+        }
+        return file;
+    }
+
+    public static String readStreamToString(InputStream inputStream, String charset) throws IOException {
+        if (inputStream == null) {
+            return null;
+        }
+
+        ByteArrayOutputStream bo = new ByteArrayOutputStream();
+        byte[] buffer = new byte[BUFFER_SIZE];
+        int bufferLength;
+
+        while ((bufferLength = inputStream.read(buffer)) > 0) {
+            bo.write(buffer, 0, bufferLength);
+        }
+        return bo.toString(charset);
+    }
+
+    /**
+     * 在SDK启动时检测灰度值有没有生成，若没有，从1-10随机选择一个数，保存起来作为这个设备的灰度值。
+     * 若是灰度下发，请求返回的json会有g字段，值是1-10，例如{v:5, g:2}。
+     * 这里g字段的值大于设备的灰度值就命中灰度，否则不命中
+     */
+    public static boolean isInGrayGroup(Integer grayValue, Context context) {
+        return grayValue == null || Installation.grayValue(context) >= grayValue;
+    }
+}
diff --git a/tinker-android/tinker-server-client/src/main/java/com/tencent/tinker/server/utils/VersionUtils.java b/tinker-android/tinker-server-client/src/main/java/com/tencent/tinker/server/utils/VersionUtils.java
new file mode 100644
index 00000000..70e1fc36
--- /dev/null
+++ b/tinker-android/tinker-server-client/src/main/java/com/tencent/tinker/server/utils/VersionUtils.java
@@ -0,0 +1,62 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.server.utils;
+
+import android.content.Context;
+import android.content.SharedPreferences;
+
+import com.tencent.tinker.lib.util.TinkerLog;
+
+import static com.tencent.tinker.server.TinkerClientImp.TAG;
+
+/**
+ * Created by sun on 18/10/2016.
+ */
+
+public final class VersionUtils {
+
+    private static final String CURRENT_VERSION = "current_version";
+    private static final String PATCH_FILE_PREF = "patch_path_";
+    private static final String SP_FILE_NAME    = "tkclient_sp_version";
+
+    private VersionUtils() {
+        // A Util Class
+    }
+
+    public static boolean update(Context context, Integer version, String path) {
+        SharedPreferences sp = context.getSharedPreferences(SP_FILE_NAME, Context.MODE_PRIVATE);
+        Integer current = sp.getInt(CURRENT_VERSION, 0);
+        if (version > current) {
+            return sp.edit().putInt(CURRENT_VERSION, version)
+                .putString(PATCH_FILE_PREF + version, path)
+                .commit();
+        } else {
+            TinkerLog.w(TAG, "update failed, target version is not latest. current version is:" + version);
+            return false;
+        }
+    }
+
+    public static Integer getCurrentVersion(Context context) {
+        SharedPreferences sp = context.getSharedPreferences(SP_FILE_NAME, Context.MODE_PRIVATE);
+        return sp.getInt(CURRENT_VERSION, 0);
+    }
+
+    public static String getPatchFilePath(Context context, Integer version) {
+        SharedPreferences sp = context.getSharedPreferences(SP_FILE_NAME, Context.MODE_PRIVATE);
+        return sp.getString(PATCH_FILE_PREF + version, "");
+    }
+}
diff --git a/tinker-android/tinker-server-client/src/test/java/com/tencent/tinker/server/ExampleUnitTest.java b/tinker-android/tinker-server-client/src/test/java/com/tencent/tinker/server/ExampleUnitTest.java
new file mode 100644
index 00000000..642c79f6
--- /dev/null
+++ b/tinker-android/tinker-server-client/src/test/java/com/tencent/tinker/server/ExampleUnitTest.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2016 Tencent WeChat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.server;
+
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+
+/**
+ * To work on unit tests, switch the Test Artifact in the Build Variants view.
+ */
+public class ExampleUnitTest {
+    @Test
+    public void addition_isCorrect() throws Exception {
+        assertEquals(4, 2 + 2);
+    }
+}
\ No newline at end of file
diff --git a/tinker-build/tinker-patch-cli/tool_output/tinker_proguard.pro b/tinker-build/tinker-patch-cli/tool_output/tinker_proguard.pro
index 23c74455..e4ef8030 100644
--- a/tinker-build/tinker-patch-cli/tool_output/tinker_proguard.pro
+++ b/tinker-build/tinker-patch-cli/tool_output/tinker_proguard.pro
@@ -26,6 +26,6 @@
 }
 
 #your dex.loader pattern here
--keep class com.tencent.tinker.loader.*
+-keep class com.tencent.tinker.loader.**
 -keep class tinker.sample.android.app.SampleApplication
 
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerProguardConfigTask.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerProguardConfigTask.groovy
index 6bb132f2..8528b265 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerProguardConfigTask.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerProguardConfigTask.groovy
@@ -108,6 +108,9 @@ public class TinkerProguardConfigTask extends DefaultTask {
         //they will removed when apply
         Iterable<String> loader = project.extensions.tinkerPatch.dex.loader
         for (String pattern : loader) {
+            if (pattern.endsWith("*") && !pattern.endsWith("**")) {
+                pattern += "*"
+            }
             fr.write("-keep class " + pattern)
             fr.write("\n")
         }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptResourceCollector.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptResourceCollector.java
index 97bc68c4..2682965c 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptResourceCollector.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptResourceCollector.java
@@ -38,7 +38,7 @@
     private final Map<RType, Set<RDotTxtEntry>>                   rTypeResourceMap;
     private final Map<RType, Set<RDotTxtEntry>>                   rTypeIncreaseResourceMap;
     private final Map<String, Set<String>>                        duplicateResourceMap;
-    private final Map<String, String>                             sanitizeNameMap;
+    private final Map<RType, HashMap<String, String>>             sanitizeTypeMap;
     private final Set<String>                                     ignoreIdSet;
     private       int                                             currentTypeId;
 
@@ -50,7 +50,7 @@ public AaptResourceCollector() {
         this.rTypeResourceMap = new HashMap<RType, Set<RDotTxtEntry>>();
         this.rTypeIncreaseResourceMap = new HashMap<RType, Set<RDotTxtEntry>>();
         this.duplicateResourceMap = new HashMap<String, Set<String>>();
-        this.sanitizeNameMap = new HashMap<String, String>();
+        this.sanitizeTypeMap = new HashMap<RType, HashMap<String, String>>();
         this.originalResourceMap = new HashMap<RDotTxtEntry, RDotTxtEntry>();
         this.ignoreIdSet = new HashSet<String>();
         //attr type must 1
@@ -260,9 +260,16 @@ void addRTypeResourceName(RType rType, String resourceName, String resourceValue
         }
     }
 
-    void putSanitizeName(String sanitizeName, String rawName) {
-        if (!this.sanitizeNameMap.containsKey(sanitizeName)) {
-            this.sanitizeNameMap.put(sanitizeName, rawName);
+    void putSanitizeName(RType rType, String sanitizeName, String rawName) {
+        HashMap<String, String> sanitizeNameMap;
+        if (!sanitizeTypeMap.containsKey(rType)) {
+            sanitizeNameMap = new HashMap<>();
+            sanitizeTypeMap.put(rType, sanitizeNameMap);
+        } else {
+            sanitizeNameMap = sanitizeTypeMap.get(rType);
+        }
+        if (!sanitizeNameMap.containsKey(sanitizeName)) {
+            sanitizeNameMap.put(sanitizeName, rawName);
         }
     }
 
@@ -272,8 +279,11 @@ void putSanitizeName(String sanitizeName, String rawName) {
      * @param sanitizeName
      * @return String
      */
-    public String getRawName(String sanitizeName) {
-        return this.sanitizeNameMap.get(sanitizeName);
+    public String getRawName(RType rType, String sanitizeName) {
+        if (!sanitizeTypeMap.containsKey(rType)) {
+            return null;
+        }
+        return this.sanitizeTypeMap.get(rType).get(sanitizeName);
     }
 
     /**
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptUtil.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptUtil.java
index 9dec2aaa..8e058f76 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptUtil.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptUtil.java
@@ -284,12 +284,12 @@ public static void processXmlFile(String xmlFullFilename, List<RDotTxtEntry> ref
 //if(!resourceCollector.isContainResource(rType, IdType.INT, sanitizeName(resourceCollector, name))){
 //throw new AaptUtilException("Not found reference '" + resourceName + "' in '" + xmlFullFilename + "'");
 //}
-            references.add(new FakeRDotTxtEntry(IdType.INT, rType, sanitizeName(resourceCollector, name)));
+            references.add(new FakeRDotTxtEntry(IdType.INT, rType, sanitizeName(rType, resourceCollector, name)));
         }
     }
 
-    private static void addToResourceCollector(AaptResourceCollector resourceCollector, com.tencent.tinker.build.aapt.ResourceDirectory resourceDirectory, Node node, RType rType, String resourceValue) {
-        String resourceName = sanitizeName(resourceCollector, extractNameAttribute(node));
+    private static void addToResourceCollector(AaptResourceCollector resourceCollector, ResourceDirectory resourceDirectory, Node node, RType rType, String resourceValue) {
+        String resourceName = sanitizeName(rType, resourceCollector, extractNameAttribute(node));
         resourceCollector.addRTypeResourceName(rType, resourceName, resourceValue, resourceDirectory);
         if (rType.equals(RType.STYLEABLE)) {
 
@@ -300,7 +300,7 @@ private static void addToResourceCollector(AaptResourceCollector resourceCollect
                 }
 
                 String rawAttrName = extractNameAttribute(attrNode);
-                String attrName = sanitizeName(resourceCollector, rawAttrName);
+                String attrName = sanitizeName(rType, resourceCollector, rawAttrName);
                 resourceCollector.addResource(RType.STYLEABLE, IdType.INT, String.format("%s_%s", resourceName, attrName), Integer.toString(count++));
 
                 if (!rawAttrName.startsWith("android:")) {
@@ -315,9 +315,9 @@ private static void addToResourceCollector(AaptResourceCollector resourceCollect
         }
     }
 
-    private static String sanitizeName(AaptResourceCollector resourceCollector, String rawName) {
+    private static String sanitizeName(RType rType, AaptResourceCollector resourceCollector, String rawName) {
         String sanitizeName = rawName.replaceAll("[.:]", "_");
-        resourceCollector.putSanitizeName(sanitizeName, rawName);
+        resourceCollector.putSanitizeName(rType, sanitizeName, rawName);
         return sanitizeName;
     }
 
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/PatchUtil.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/PatchUtil.java
index 6f4a0cc1..af195a50 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/PatchUtil.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/PatchUtil.java
@@ -117,7 +117,7 @@ public static void generatePublicResourceXml(AaptResourceCollector aaptResourceC
                     Set<RDotTxtEntry> set = entry.getValue();
                     for (RDotTxtEntry rDotTxtEntry : set) {
 //                        if (rType.equals(RType.STYLE)) {
-                            String rawName = aaptResourceCollector.getRawName(rDotTxtEntry.name);
+                            String rawName = aaptResourceCollector.getRawName(rType, rDotTxtEntry.name);
                             if (StringUtil.isBlank(rawName)) {
 //                                System.err.println("Blank?" + rDotTxtEntry.name);
                                 rawName = rDotTxtEntry.name;
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java
index fa32385f..0a298879 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java
@@ -308,9 +308,9 @@ private void generateStubModePatchDex() throws IOException {
 
     @SuppressWarnings("NewApi")
     private void generatePatchInfoFile() throws IOException {
-        File tempFullPatchDexPath = new File(config.mOutFolder + File.separator + TypedValue.DEX_TEMP_PATCH_DIR + File.separator + "full");
+        File tempFullPatchDexPath = new File(config.mOutFolder + File.separator + TypedValue.DEX_TEMP_PATCH_DIR + File.separator + "dalvik");
         ensureDirectoryExist(tempFullPatchDexPath);
-        File tempSmallPatchDexPath = new File(config.mOutFolder + File.separator + TypedValue.DEX_TEMP_PATCH_DIR + File.separator + "small");
+        File tempSmallPatchDexPath = new File(config.mOutFolder + File.separator + TypedValue.DEX_TEMP_PATCH_DIR + File.separator + "art");
         ensureDirectoryExist(tempSmallPatchDexPath);
 
         // Generate dex diff out and full patched dex if a pair of dex is different.
diff --git a/tinker-sample-android/app/build.gradle b/tinker-sample-android/app/build.gradle
index 9fdbdf75..5ec6e604 100644
--- a/tinker-sample-android/app/build.gradle
+++ b/tinker-sample-android/app/build.gradle
@@ -8,6 +8,8 @@ dependencies {
     compile "com.android.support:appcompat-v7:23.1.1"
     compile("com.tencent.tinker:tinker-android-lib:${TINKER_VERSION}") { changing = true }
     compile("com.tencent.tinker:tinker-android-anno:${TINKER_VERSION}") { changing = true }
+    compile("com.tencent.tinker:tinker-server-client:${TINKER_VERSION}") { changing = true }
+
     compile "com.android.support:multidex:1.0.1"
 
     //use to test multiDex
@@ -95,6 +97,11 @@ android {
         buildConfigField "String", "CLIENTVERSION", "\"${getTinkerIdValue()}\""
         buildConfigField "String", "PLATFORM",  "\"all\""
     }
+
+//    aaptOptions{
+//        cruncherEnabled false
+//    }
+
 //    //use to test flavors support
 //    productFlavors {
 //        flavor1 {
diff --git a/tinker-sample-android/app/src/main/AndroidManifest.xml b/tinker-sample-android/app/src/main/AndroidManifest.xml
index 9676eb94..f000eafc 100644
--- a/tinker-sample-android/app/src/main/AndroidManifest.xml
+++ b/tinker-sample-android/app/src/main/AndroidManifest.xml
@@ -6,6 +6,7 @@
 
     <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
     <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
+    <uses-permission android:name="android.permission.INTERNET" />
 
     <application
         android:name=".app.SampleApplication"
diff --git a/tinker-sample-android/gradle.properties b/tinker-sample-android/gradle.properties
index beec0488..a6a66d40 100644
--- a/tinker-sample-android/gradle.properties
+++ b/tinker-sample-android/gradle.properties
@@ -17,4 +17,4 @@
 # http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
 # org.gradle.parallel=true
 
-TINKER_VERSION=1.7.1
+TINKER_VERSION=1.8.0
