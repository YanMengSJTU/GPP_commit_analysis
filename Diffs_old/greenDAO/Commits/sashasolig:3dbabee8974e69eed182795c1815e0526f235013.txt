diff --git a/DaoCore/src/de/greenrobot/dao/AbstractDao.java b/DaoCore/src/de/greenrobot/dao/AbstractDao.java
index fd124a9b..99a3970d 100644
--- a/DaoCore/src/de/greenrobot/dao/AbstractDao.java
+++ b/DaoCore/src/de/greenrobot/dao/AbstractDao.java
@@ -197,7 +197,7 @@ public boolean detach(T entity) {
         }
     }
 
-    protected List<T> loadAllAndCloseCursor(Cursor cursor) {
+    public List<T> loadAllAndCloseCursor(Cursor cursor) {
         try {
             return loadAllFromCursor(cursor);
         } finally {
diff --git a/DaoCore/src/de/greenrobot/dao/LazyList.java b/DaoCore/src/de/greenrobot/dao/LazyList.java
index 10bbc70b..b3bf5d9c 100644
--- a/DaoCore/src/de/greenrobot/dao/LazyList.java
+++ b/DaoCore/src/de/greenrobot/dao/LazyList.java
@@ -34,9 +34,9 @@
  * entities. However, to avoid leaked cursors, you should not rely on this behavior: if an exception occurs before the
  * entire list is read, you should close the lazy list (and thus the underlying cursor) on your own to be on the safe
  * side.
- * 
+ *
  * @author Markus
- * 
+ *
  * @param <E>
  *            Entity type.
  */
@@ -127,7 +127,7 @@ public void close() {
     private final ReentrantLock lock;
     private volatile int loadedCount;
 
-    LazyList(AbstractDao<E, ?> dao, Cursor cursor, boolean cacheEntities) {
+    public LazyList(AbstractDao<E, ?> dao, Cursor cursor, boolean cacheEntities) {
         this.dao = dao;
         this.cursor = cursor;
         size = cursor.getCount();
