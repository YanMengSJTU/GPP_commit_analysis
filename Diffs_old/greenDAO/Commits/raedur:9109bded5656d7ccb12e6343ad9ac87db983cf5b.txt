diff --git a/DaoCore/java-formater.xml b/DaoCore/java-formater.xml
new file mode 100644
index 00000000..9eabc7e4
--- /dev/null
+++ b/DaoCore/java-formater.xml
@@ -0,0 +1,291 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<profiles version="12">
+<profile kind="CodeFormatterProfile" name="greenrobot" version="12">
+<setting id="org.eclipse.jdt.core.formatter.comment.insert_new_line_before_root_tags" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.disabling_tag" value="@formatter:off"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_annotation" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_type_parameters" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_type_declaration" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_type_arguments" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.brace_position_for_anonymous_type_declaration" value="end_of_line"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_colon_in_case" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_brace_in_array_initializer" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.comment.new_lines_at_block_boundaries" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_in_empty_annotation_declaration" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_before_closing_brace_in_array_initializer" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_annotation" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.blank_lines_before_field" value="0"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_while" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.use_on_off_tags" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_annotation_type_member_declaration" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_before_else_in_if_statement" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_prefix_operator" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.keep_else_statement_on_same_line" value="false"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_ellipsis" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.comment.insert_new_line_for_parameter" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_annotation_type_declaration" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.indent_breaks_compare_to_cases" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_at_in_annotation" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_multiple_fields" value="16"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_expressions_in_array_initializer" value="16"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_conditional_expression" value="80"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_for" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_binary_operator" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_question_in_wildcard" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.brace_position_for_array_initializer" value="end_of_line"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_enum_constant" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_before_finally_in_try_statement" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_local_variable" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_before_catch_in_try_statement" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_while" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.blank_lines_after_package" value="1"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_type_parameters" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.continuation_indentation" value="2"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_postfix_operator" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_arguments_in_method_invocation" value="16"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_type_arguments" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_superinterfaces" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.blank_lines_before_new_chunk" value="1"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_binary_operator" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.blank_lines_before_package" value="0"/>
+<setting id="org.eclipse.jdt.core.compiler.source" value="1.7"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_enum_constant_arguments" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_constructor_declaration" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.comment.format_line_comments" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_closing_angle_bracket_in_type_arguments" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_enum_declarations" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.join_wrapped_lines" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_block" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_arguments_in_explicit_constructor_call" value="16"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_invocation_arguments" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.blank_lines_before_member_type" value="1"/>
+<setting id="org.eclipse.jdt.core.formatter.align_type_members_on_columns" value="false"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_enum_constant" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_for" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_method_declaration" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_selector_in_method_invocation" value="16"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_switch" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_unary_operator" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_colon_in_case" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.comment.indent_parameter_description" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_method_declaration" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_switch" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_enum_declaration" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_type_parameters" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.comment.clear_blank_lines_in_block_comment" value="false"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_in_empty_type_declaration" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.lineSplit" value="120"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_if" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_between_brackets_in_array_type_reference" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_parenthesized_expression" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_explicitconstructorcall_arguments" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_constructor_declaration" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.blank_lines_before_first_class_body_declaration" value="0"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_method" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.indentation.size" value="4"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_method_declaration" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.enabling_tag" value="@formatter:on"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_enum_constant" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_superclass_in_type_declaration" value="16"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_assignment" value="0"/>
+<setting id="org.eclipse.jdt.core.compiler.problem.assertIdentifier" value="error"/>
+<setting id="org.eclipse.jdt.core.formatter.tabulation.char" value="space"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_constructor_declaration_parameters" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_semicolon_in_try_resources" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_prefix_operator" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.indent_statements_compare_to_body" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.blank_lines_before_method" value="1"/>
+<setting id="org.eclipse.jdt.core.formatter.wrap_outer_expressions_when_nested" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.format_guardian_clause_on_one_line" value="false"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_colon_in_for" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_cast" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_parameters_in_constructor_declaration" value="16"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_colon_in_labeled_statement" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.brace_position_for_annotation_type_declaration" value="end_of_line"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_in_empty_method_body" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_method_declaration" value="0"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_method_invocation" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_try" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_bracket_in_array_allocation_expression" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_enum_constant" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_annotation" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_at_in_annotation_type_declaration" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_declaration_throws" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_if" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.brace_position_for_switch" value="end_of_line"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_declaration_throws" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_parenthesized_expression_in_return" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_annotation" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_question_in_conditional" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_question_in_wildcard" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_try" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_bracket_in_array_allocation_expression" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.comment.preserve_white_space_between_code_and_line_comments" value="false"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_parenthesized_expression_in_throw" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_type_arguments" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.compiler.problem.enumIdentifier" value="error"/>
+<setting id="org.eclipse.jdt.core.formatter.indent_switchstatements_compare_to_switch" value="false"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_ellipsis" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.brace_position_for_block" value="end_of_line"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_for_inits" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.brace_position_for_method_declaration" value="end_of_line"/>
+<setting id="org.eclipse.jdt.core.formatter.compact_else_if" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.wrap_before_or_operator_multicatch" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_array_initializer" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_for_increments" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.format_line_comment_starting_on_first_column" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_bracket_in_array_reference" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_field" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.brace_position_for_enum_constant" value="end_of_line"/>
+<setting id="org.eclipse.jdt.core.formatter.comment.indent_root_tags" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_enum_declarations" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_union_type_in_multicatch" value="16"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_explicitconstructorcall_arguments" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_switch" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_declaration_parameters" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_superinterfaces" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_allocation_expression" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.tabulation.size" value="4"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_type_reference" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_opening_brace_in_array_initializer" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_closing_brace_in_block" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_reference" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_in_empty_enum_constant" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_type_arguments" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_constructor_declaration" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_constructor_declaration_throws" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_if" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.comment.clear_blank_lines_in_javadoc_comment" value="false"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_throws_clause_in_constructor_declaration" value="16"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_assignment_operator" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_assignment_operator" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.indent_empty_lines" value="false"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_synchronized" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_closing_paren_in_cast" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_declaration_parameters" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.brace_position_for_block_in_case" value="end_of_line"/>
+<setting id="org.eclipse.jdt.core.formatter.number_of_empty_lines_to_preserve" value="1"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_method_declaration" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_catch" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_constructor_declaration" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_method_invocation" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_bracket_in_array_reference" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_arguments_in_qualified_allocation_expression" value="16"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_and_in_type_parameter" value="insert"/>
+<setting id="org.eclipse.jdt.core.compiler.compliance" value="1.7"/>
+<setting id="org.eclipse.jdt.core.formatter.continuation_indentation_for_array_initializer" value="2"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_between_empty_brackets_in_array_allocation_expression" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_at_in_annotation_type_declaration" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_arguments_in_allocation_expression" value="16"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_cast" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_unary_operator" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_parameterized_type_reference" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_anonymous_type_declaration" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.keep_empty_array_initializer_on_one_line" value="false"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_in_empty_enum_declaration" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.keep_imple_if_on_one_line" value="false"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_constructor_declaration_parameters" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_closing_angle_bracket_in_type_parameters" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_at_end_of_file_if_missing" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_colon_in_for" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_colon_in_labeled_statement" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_parameterized_type_reference" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_superinterfaces_in_type_declaration" value="16"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_binary_expression" value="16"/>
+<setting id="org.eclipse.jdt.core.formatter.brace_position_for_enum_declaration" value="end_of_line"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_type" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_while" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode" value="enabled"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_try" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.put_empty_statement_on_new_line" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_label" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_parameter" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_type_parameters" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_method_invocation" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_before_while_in_do_statement" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_arguments_in_enum_constant" value="16"/>
+<setting id="org.eclipse.jdt.core.formatter.comment.format_javadoc_comments" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.comment.line_length" value="120"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_package" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.blank_lines_between_import_groups" value="1"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_enum_constant_arguments" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_semicolon" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.brace_position_for_constructor_declaration" value="end_of_line"/>
+<setting id="org.eclipse.jdt.core.formatter.number_of_blank_lines_at_beginning_of_method_body" value="0"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_colon_in_conditional" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_type_header" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_annotation_type_member_declaration" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.wrap_before_binary_operator" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_enum_declaration_header" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.blank_lines_between_type_declarations" value="1"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_synchronized" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.indent_statements_compare_to_block" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_superinterfaces_in_enum_declaration" value="16"/>
+<setting id="org.eclipse.jdt.core.formatter.join_lines_in_comments" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_question_in_conditional" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_multiple_field_declarations" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_compact_if" value="16"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_for_inits" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.indent_switchstatements_compare_to_cases" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_array_initializer" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_colon_in_default" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_and_in_type_parameter" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_constructor_declaration" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.blank_lines_before_imports" value="1"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_colon_in_assert" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.comment.format_html" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_throws_clause_in_method_declaration" value="16"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_type_parameters" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_allocation_expression" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_in_empty_anonymous_type_declaration" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_colon_in_conditional" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_parameterized_type_reference" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_for" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_postfix_operator" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.comment.format_source_code" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_synchronized" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_allocation_expression" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_constructor_declaration_throws" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_parameters_in_method_declaration" value="16"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_brace_in_array_initializer" value="insert"/>
+<setting id="org.eclipse.jdt.core.compiler.codegen.targetPlatform" value="1.7"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_resources_in_try" value="80"/>
+<setting id="org.eclipse.jdt.core.formatter.use_tabs_only_for_leading_indentations" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_arguments_in_annotation" value="0"/>
+<setting id="org.eclipse.jdt.core.formatter.comment.format_header" value="false"/>
+<setting id="org.eclipse.jdt.core.formatter.comment.format_block_comments" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_enum_constant" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_enum_constants" value="0"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_in_empty_block" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_annotation_declaration_header" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_parenthesized_expression" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_parenthesized_expression" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_catch" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_multiple_local_declarations" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_switch" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_for_increments" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_method_invocation" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_colon_in_assert" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.brace_position_for_type_declaration" value="end_of_line"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_array_initializer" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_between_empty_braces_in_array_initializer" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_method_declaration" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_semicolon_in_for" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_catch" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_parameterized_type_reference" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_multiple_field_declarations" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_annotation" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_parameterized_type_reference" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_invocation_arguments" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.comment.new_lines_at_javadoc_boundaries" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.blank_lines_after_imports" value="1"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_multiple_local_declarations" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_enum_constant_header" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_semicolon_in_for" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.never_indent_line_comments_on_first_column" value="false"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_semicolon_in_try_resources" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_type_arguments" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.never_indent_block_comments_on_first_column" value="false"/>
+<setting id="org.eclipse.jdt.core.formatter.keep_then_statement_on_same_line" value="false"/>
+</profile>
+</profiles>
diff --git a/DaoCore/src/de/greenrobot/dao/AbstractDao.java b/DaoCore/src/de/greenrobot/dao/AbstractDao.java
index af01658a..6d86e393 100644
--- a/DaoCore/src/de/greenrobot/dao/AbstractDao.java
+++ b/DaoCore/src/de/greenrobot/dao/AbstractDao.java
@@ -18,6 +18,7 @@
 
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collection;
 import java.util.List;
 
 import android.database.CrossProcessCursor;
@@ -416,10 +417,15 @@ final protected T loadCurrent(Cursor cursor, int offset, boolean lock) {
         return loadAllAndCloseCursor(cursor);
     }
 
-    /** @deprecated groupBy & having does not make sense for entities. Method will be removed. */
-    public List<T> query(String selection, String[] selectionArgs, String groupBy, String having, String orderby) {
-        Cursor cursor = db.query(config.tablename, getAllColumns(), selection, selectionArgs, groupBy, having, orderby);
-        return loadAllAndCloseCursor(cursor);
+    /** Creates a repeatable {@link Query} object based on the given raw SQL where you can pass any WHERE clause and arguments. */
+    public Query<T> queryRawCreate(String where, Object... selectionArg) {
+        List<Object> argList = Arrays.asList(selectionArg);
+        return queryRawCreateListArgs(where, argList);
+    }
+
+    /** Creates a repeatable {@link Query} object based on the given raw SQL where you can pass any WHERE clause and arguments. */
+    public Query<T> queryRawCreateListArgs(String where, Collection<Object> selectionArg) {
+        return new Query<T>(this, statements.getSelectAll() + where, selectionArg);
     }
 
     public void deleteAll() {
diff --git a/DaoCore/src/de/greenrobot/dao/AbstractDaoSession.java b/DaoCore/src/de/greenrobot/dao/AbstractDaoSession.java
index 081ee710..5ed9d07b 100644
--- a/DaoCore/src/de/greenrobot/dao/AbstractDaoSession.java
+++ b/DaoCore/src/de/greenrobot/dao/AbstractDaoSession.java
@@ -20,6 +20,8 @@
 import java.util.Map;
 import java.util.concurrent.Callable;
 
+import de.greenrobot.dao.async.AsyncSession;
+
 import android.database.sqlite.SQLiteDatabase;
 
 /**
@@ -185,4 +187,11 @@ public SQLiteDatabase getDatabase() {
         return db;
     }
 
+    /**
+     * Creates a new {@link AsyncSession} to issue asynchronous entity operations. See {@link AsyncSession} for details.
+     */
+    public AsyncSession startAsyncSession() {
+        return new AsyncSession(this);
+    }
+
 }
diff --git a/DaoCore/src/de/greenrobot/dao/LazyList.java b/DaoCore/src/de/greenrobot/dao/LazyList.java
index 10bbc70b..96253fc9 100644
--- a/DaoCore/src/de/greenrobot/dao/LazyList.java
+++ b/DaoCore/src/de/greenrobot/dao/LazyList.java
@@ -236,6 +236,7 @@ public E get(int location) {
                     if (entity == null) {
                         entity = loadEntity(location);
                         entities.set(location, entity);
+                        // Ignore FindBugs: increment of volatile is fine here because we use a lock
                         loadedCount++;
                         if (loadedCount == size) {
                             cursor.close();
diff --git a/DaoCore/src/de/greenrobot/dao/async/AsyncDaoException.java b/DaoCore/src/de/greenrobot/dao/async/AsyncDaoException.java
new file mode 100644
index 00000000..a36a994c
--- /dev/null
+++ b/DaoCore/src/de/greenrobot/dao/async/AsyncDaoException.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package de.greenrobot.dao.async;
+
+import de.greenrobot.dao.DaoException;
+
+/**
+ * Used here: {@link AsyncOperation#getResult()}.
+ * 
+ * @author Markus
+ */
+public class AsyncDaoException extends DaoException {
+
+    private static final long serialVersionUID = 5872157552005102382L;
+
+    private final AsyncOperation failedOperation;
+
+    public AsyncDaoException(AsyncOperation failedOperation, Throwable cause) {
+        super(cause);
+        this.failedOperation = failedOperation;
+    }
+
+    public AsyncOperation getFailedOperation() {
+        return failedOperation;
+    }
+
+}
diff --git a/DaoCore/src/de/greenrobot/dao/async/AsyncOperation.java b/DaoCore/src/de/greenrobot/dao/async/AsyncOperation.java
new file mode 100644
index 00000000..20d250ab
--- /dev/null
+++ b/DaoCore/src/de/greenrobot/dao/async/AsyncOperation.java
@@ -0,0 +1,226 @@
+/*
+ * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package de.greenrobot.dao.async;
+
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.DaoException;
+import android.database.sqlite.SQLiteDatabase;
+
+/**
+ * An operation that will be enqueued for asynchronous execution.
+ * 
+ * @author Markus
+ * 
+ * @see AsyncSession
+ */
+// TODO Implement Future<V>
+public class AsyncOperation {
+    public static enum OperationType {
+        Insert, InsertInTxIterable, InsertInTxArray, //
+        InsertOrReplace, InsertOrReplaceInTxIterable, InsertOrReplaceInTxArray, //
+        Update, UpdateInTxIterable, UpdateInTxArray, //
+        Delete, DeleteInTxIterable, DeleteInTxArray, //
+        DeleteByKey, DeleteAll, //
+        TransactionRunnable, TransactionCallable, //
+        QueryList, QueryUnique, //
+        Load, LoadAll, //
+        Count, Refresh
+    }
+
+    public static final int FLAG_MERGE_TX = 1;
+
+    /** TODO unused, just an idea */
+    public static final int FLAG_STOP_QUEUE_ON_EXCEPTION = 1 << 1;
+
+    final OperationType type;
+    final AbstractDao<Object, Object> dao;
+    private final SQLiteDatabase database;
+    /** Entity, Iterable<Entity>, Entity[], or Runnable. */
+    final Object parameter;
+    final int flags;
+
+    volatile long timeStarted;
+    volatile long timeCompleted;
+    private volatile boolean completed;
+    volatile Throwable throwable;
+    volatile Object result;
+    volatile int mergedOperationsCount;
+
+    int sequenceNumber;
+
+    @SuppressWarnings("unchecked")
+    AsyncOperation(OperationType type, AbstractDao<?, ?> dao, Object parameter, int flags) {
+        this.type = type;
+        this.flags = flags;
+        this.dao = (AbstractDao<Object, Object>) dao;
+        this.database = null;
+        this.parameter = parameter;
+    }
+
+    AsyncOperation(OperationType type, SQLiteDatabase database, Object parameter, int flags) {
+        this.type = type;
+        this.database = database;
+        this.flags = flags;
+        this.dao = null;
+        this.parameter = parameter;
+    }
+
+    public Throwable getThrowable() {
+        return throwable;
+    }
+
+    public void setThrowable(Throwable throwable) {
+        this.throwable = throwable;
+    }
+
+    public OperationType getType() {
+        return type;
+    }
+
+    public Object getParameter() {
+        return parameter;
+    }
+
+    /**
+     * The operation's result after it has completed. Waits until a result is available.
+     * 
+     * @return The operation's result or null if the operation type does not produce any result.
+     * @throws {@link AsyncDaoException} if the operation produced an exception
+     * @see #waitForCompletion()
+     */
+    public synchronized Object getResult() {
+        if (!completed) {
+            waitForCompletion();
+        }
+        if (throwable != null) {
+            throw new AsyncDaoException(this, throwable);
+        }
+        return result;
+    }
+
+    /** @return true if this operation may be merged with others into a single database transaction. */
+    public boolean isMergeTx() {
+        return (flags & FLAG_MERGE_TX) != 0;
+    }
+
+    SQLiteDatabase getDatabase() {
+        return database != null ? database : dao.getDatabase();
+    }
+
+    /**
+     * @return true if this operation is mergeable with the given operation. Checks for null, {@link #FLAG_MERGE_TX},
+     *         and if the database instances match.
+     */
+    boolean isMergeableWith(AsyncOperation other) {
+        return other != null && isMergeTx() && other.isMergeTx() && getDatabase() == other.getDatabase();
+    }
+
+    public long getTimeStarted() {
+        return timeStarted;
+    }
+
+    public long getTimeCompleted() {
+        return timeCompleted;
+    }
+
+    public long getDuration() {
+        if (timeCompleted == 0) {
+            throw new DaoException("This operation did not yet complete");
+        } else {
+            return timeCompleted - timeStarted;
+        }
+    }
+
+    public boolean isFailed() {
+        return throwable != null;
+    }
+
+    public boolean isCompleted() {
+        return completed;
+    }
+
+    /**
+     * Waits until the operation is complete. If the thread gets interrupted, any {@link InterruptedException} will be
+     * rethrown as a {@link DaoException}.
+     * 
+     * @return Result if any, see {@link #getResult()}
+     */
+    public synchronized Object waitForCompletion() {
+        while (!completed) {
+            try {
+                wait();
+            } catch (InterruptedException e) {
+                throw new DaoException("Interrupted while waiting for operation to complete", e);
+            }
+        }
+        return result;
+    }
+
+    /**
+     * Waits until the operation is complete, but at most the given amount of milliseconds.If the thread gets
+     * interrupted, any {@link InterruptedException} will be rethrown as a {@link DaoException}.
+     * 
+     * @return true if the operation completed in the given time frame.
+     */
+    public synchronized boolean waitForCompletion(int maxMillis) {
+        if (!completed) {
+            try {
+                wait(maxMillis);
+            } catch (InterruptedException e) {
+                throw new DaoException("Interrupted while waiting for operation to complete", e);
+            }
+        }
+        return completed;
+    }
+
+    /** Called when the operation is done. Notifies any threads waiting for this operation's completion. */
+    synchronized void setCompleted() {
+        completed = true;
+        notifyAll();
+    }
+
+    public boolean isCompletedSucessfully() {
+        return completed && throwable == null;
+    }
+
+    /**
+     * If this operation was successfully merged with other operation into a single TX, this will give the count of
+     * merged operations. If the operation was not merged, it will be 0.
+     */
+    public int getMergedOperationsCount() {
+        return mergedOperationsCount;
+    }
+
+    /**
+     * Each operation get a unique sequence number when the operation is enqueued. Can be used for efficiently
+     * identifying/mapping operations.
+     */
+    public int getSequenceNumber() {
+        return sequenceNumber;
+    }
+
+    /** Reset to prepare another execution run. */
+    void reset() {
+        timeStarted = 0;
+        timeCompleted = 0;
+        completed = false;
+        throwable = null;
+        result = null;
+        mergedOperationsCount = 0;
+    }
+
+}
diff --git a/DaoCore/src/de/greenrobot/dao/async/AsyncOperationExecutor.java b/DaoCore/src/de/greenrobot/dao/async/AsyncOperationExecutor.java
new file mode 100644
index 00000000..03ac71a6
--- /dev/null
+++ b/DaoCore/src/de/greenrobot/dao/async/AsyncOperationExecutor.java
@@ -0,0 +1,368 @@
+/*
+ * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.dao.async;
+
+import java.util.ArrayList;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.TimeUnit;
+
+import android.database.sqlite.SQLiteDatabase;
+import android.os.Handler;
+import android.os.Looper;
+import android.os.Message;
+import de.greenrobot.dao.DaoException;
+import de.greenrobot.dao.DaoLog;
+import de.greenrobot.dao.Query;
+
+class AsyncOperationExecutor implements Runnable, Handler.Callback {
+
+    private static ExecutorService executorService = Executors.newCachedThreadPool();
+
+    private final BlockingQueue<AsyncOperation> queue;
+    private volatile boolean executorRunning;
+    private volatile int maxOperationCountToMerge;
+    private volatile AsyncOperationListener listener;
+    private volatile AsyncOperationListener listenerMainThread;
+    private volatile int waitForMergeMillis;
+
+    private int countOperationsEnqueued;
+    private int countOperationsCompleted;
+
+    private Handler handlerMainThread;
+    private int lastSequenceNumber;
+
+    AsyncOperationExecutor() {
+        queue = new LinkedBlockingQueue<AsyncOperation>();
+        maxOperationCountToMerge = 50;
+        waitForMergeMillis = 50;
+    }
+
+    public void enqueue(AsyncOperation operation) {
+        synchronized (this) {
+            operation.sequenceNumber = ++lastSequenceNumber;
+            queue.add(operation);
+            countOperationsEnqueued++;
+            if (!executorRunning) {
+                executorRunning = true;
+                executorService.execute(this);
+            }
+        }
+    }
+
+    public int getMaxOperationCountToMerge() {
+        return maxOperationCountToMerge;
+    }
+
+    public void setMaxOperationCountToMerge(int maxOperationCountToMerge) {
+        this.maxOperationCountToMerge = maxOperationCountToMerge;
+    }
+
+    public int getWaitForMergeMillis() {
+        return waitForMergeMillis;
+    }
+
+    public void setWaitForMergeMillis(int waitForMergeMillis) {
+        this.waitForMergeMillis = waitForMergeMillis;
+    }
+
+    public AsyncOperationListener getListener() {
+        return listener;
+    }
+
+    public void setListener(AsyncOperationListener listener) {
+        this.listener = listener;
+    }
+
+    public AsyncOperationListener getListenerMainThread() {
+        return listenerMainThread;
+    }
+
+    public void setListenerMainThread(AsyncOperationListener listenerMainThread) {
+        this.listenerMainThread = listenerMainThread;
+    }
+
+    public synchronized boolean isCompleted() {
+        return countOperationsEnqueued == countOperationsCompleted;
+    }
+
+    /**
+     * Waits until all enqueued operations are complete. If the thread gets interrupted, any
+     * {@link InterruptedException} will be rethrown as a {@link DaoException}.
+     */
+    public synchronized void waitForCompletion() {
+        while (!isCompleted()) {
+            try {
+                wait();
+            } catch (InterruptedException e) {
+                throw new DaoException("Interrupted while waiting for all operations to complete", e);
+            }
+        }
+    }
+
+    /**
+     * Waits until all enqueued operations are complete, but at most the given amount of milliseconds. If the thread
+     * gets interrupted, any {@link InterruptedException} will be rethrown as a {@link DaoException}.
+     * 
+     * @return true if operations completed in the given time frame.
+     */
+    public synchronized boolean waitForCompletion(int maxMillis) {
+        if (!isCompleted()) {
+            try {
+                wait(maxMillis);
+            } catch (InterruptedException e) {
+                throw new DaoException("Interrupted while waiting for all operations to complete", e);
+            }
+        }
+        return isCompleted();
+    }
+
+    @Override
+    public void run() {
+        try {
+            try {
+                while (true) {
+                    AsyncOperation operation = queue.poll(1, TimeUnit.SECONDS);
+                    if (operation == null) {
+                        synchronized (this) {
+                            // Check again, this time in synchronized
+                            operation = queue.poll();
+                            if (operation == null) {
+                                executorRunning = false;
+                                return;
+                            }
+                        }
+                    }
+                    if (operation != null) {
+                        if (operation.isMergeTx()) {
+                            // Wait some ms for another operation to merge because a TX is expensive
+                            AsyncOperation operation2 = queue.poll(waitForMergeMillis, TimeUnit.MILLISECONDS);
+                            if (operation2 != null) {
+                                if (operation.isMergeableWith(operation2)) {
+                                    mergeTxAndExecute(operation, operation2);
+                                } else {
+                                    // Cannot merge, execute both
+                                    executeOperationAndPostCompleted(operation);
+                                    executeOperationAndPostCompleted(operation2);
+                                }
+                                continue;
+                            }
+                        }
+                        executeOperationAndPostCompleted(operation);
+                    }
+                }
+            } catch (InterruptedException e) {
+                DaoLog.w(Thread.currentThread().getName() + " was interruppted", e);
+            }
+        } finally {
+            executorRunning = false;
+        }
+    }
+
+    private void mergeTxAndExecute(AsyncOperation operation1, AsyncOperation operation2) {
+        ArrayList<AsyncOperation> mergedOps = new ArrayList<AsyncOperation>();
+        mergedOps.add(operation1);
+        mergedOps.add(operation2);
+
+        SQLiteDatabase db = operation1.getDatabase();
+        db.beginTransaction();
+        boolean failed = false;
+        try {
+            for (int i = 0; i < mergedOps.size(); i++) {
+                AsyncOperation operation = mergedOps.get(i);
+                executeOperation(operation);
+                if (operation.isFailed()) {
+                    // Operation may still have changed the DB, roll back everything
+                    failed = true;
+                    break;
+                }
+                if (i == mergedOps.size() - 1) {
+                    AsyncOperation peekedOp = queue.peek();
+                    if (i < maxOperationCountToMerge && operation.isMergeableWith(peekedOp)) {
+                        AsyncOperation removedOp = queue.remove();
+                        if (removedOp != peekedOp) {
+                            // Paranoia check, should not occur unless threading is broken
+                            throw new DaoException("Internal error: peeked op did not match removed op");
+                        }
+                        mergedOps.add(removedOp);
+                    } else {
+                        // No more ops in the queue to merge, finish it
+                        db.setTransactionSuccessful();
+                    }
+                }
+            }
+        } finally {
+            db.endTransaction();
+        }
+        if (failed) {
+            DaoLog.i("Revered merged transaction because one of the operations failed. Executing operations one by one instead...");
+            for (AsyncOperation asyncOperation : mergedOps) {
+                asyncOperation.reset();
+                executeOperationAndPostCompleted(asyncOperation);
+            }
+        } else {
+            int mergedCount = mergedOps.size();
+            for (AsyncOperation asyncOperation : mergedOps) {
+                asyncOperation.mergedOperationsCount = mergedCount;
+                handleOperationCompleted(asyncOperation);
+            }
+        }
+    }
+
+    private void handleOperationCompleted(AsyncOperation operation) {
+        operation.setCompleted();
+
+        AsyncOperationListener listenerToCall = listener;
+        if (listenerToCall != null) {
+            listenerToCall.onAsyncOperationCompleted(operation);
+        }
+        if (listenerMainThread != null) {
+            if (handlerMainThread == null) {
+                handlerMainThread = new Handler(Looper.getMainLooper(), this);
+            }
+            Message msg = handlerMainThread.obtainMessage(1, operation);
+            handlerMainThread.sendMessage(msg);
+        }
+        synchronized (this) {
+            countOperationsCompleted++;
+            if (countOperationsCompleted == countOperationsEnqueued) {
+                notifyAll();
+            }
+        }
+    }
+
+    private void executeOperationAndPostCompleted(AsyncOperation operation) {
+        executeOperation(operation);
+        handleOperationCompleted(operation);
+    }
+
+    @SuppressWarnings({ "unchecked", "rawtypes" })
+    private void executeOperation(AsyncOperation operation) {
+        operation.timeStarted = System.currentTimeMillis();
+        try {
+            switch (operation.type) {
+            case Delete:
+                operation.dao.delete(operation.parameter);
+                break;
+            case DeleteInTxIterable:
+                operation.dao.deleteInTx((Iterable<Object>) operation.parameter);
+                break;
+            case DeleteInTxArray:
+                operation.dao.deleteInTx((Object[]) operation.parameter);
+                break;
+            case Insert:
+                operation.dao.insert(operation.parameter);
+                break;
+            case InsertInTxIterable:
+                operation.dao.insertInTx((Iterable<Object>) operation.parameter);
+                break;
+            case InsertInTxArray:
+                operation.dao.insertInTx((Object[]) operation.parameter);
+                break;
+            case InsertOrReplace:
+                operation.dao.insertOrReplace(operation.parameter);
+                break;
+            case InsertOrReplaceInTxIterable:
+                operation.dao.insertOrReplaceInTx((Iterable<Object>) operation.parameter);
+                break;
+            case InsertOrReplaceInTxArray:
+                operation.dao.insertOrReplaceInTx((Object[]) operation.parameter);
+                break;
+            case Update:
+                operation.dao.update(operation.parameter);
+                break;
+            case UpdateInTxIterable:
+                operation.dao.updateInTx((Iterable<Object>) operation.parameter);
+                break;
+            case UpdateInTxArray:
+                operation.dao.updateInTx((Object[]) operation.parameter);
+                break;
+            case TransactionRunnable:
+                executeTransactionRunnable(operation);
+                break;
+            case TransactionCallable:
+                executeTransactionCallable(operation);
+                break;
+            case QueryList:
+                operation.result = ((Query) operation.parameter).list();
+                break;
+            case QueryUnique:
+                operation.result = ((Query) operation.parameter).unique();
+                break;
+            case DeleteByKey:
+                operation.dao.deleteByKey(operation.parameter);
+                break;
+            case DeleteAll:
+                operation.dao.deleteAll();
+                break;
+            case Load:
+                operation.result = operation.dao.load(operation.parameter);
+                break;
+            case LoadAll:
+                operation.result = operation.dao.loadAll();
+                break;
+            case Count:
+                operation.result = operation.dao.count();
+                break;
+            case Refresh:
+                operation.dao.refresh(operation.parameter);
+                break;
+            default:
+                throw new DaoException("Unsupported operation: " + operation.type);
+            }
+        } catch (Throwable th) {
+            operation.throwable = th;
+        }
+        operation.timeCompleted = System.currentTimeMillis();
+        // Do not set it to completed here because it might be a merged TX
+    }
+
+    private void executeTransactionRunnable(AsyncOperation operation) {
+        SQLiteDatabase db = operation.getDatabase();
+        db.beginTransaction();
+        try {
+            ((Runnable) operation.parameter).run();
+            db.setTransactionSuccessful();
+        } finally {
+            db.endTransaction();
+        }
+    }
+
+    @SuppressWarnings("unchecked")
+    private void executeTransactionCallable(AsyncOperation operation) throws Exception {
+        SQLiteDatabase db = operation.getDatabase();
+        db.beginTransaction();
+        try {
+            operation.result = ((Callable<Object>) operation.parameter).call();
+            db.setTransactionSuccessful();
+        } finally {
+            db.endTransaction();
+        }
+    }
+
+    @Override
+    public boolean handleMessage(Message msg) {
+        AsyncOperationListener listenerToCall = listenerMainThread;
+        if (listenerToCall != null) {
+            listenerToCall.onAsyncOperationCompleted((AsyncOperation) msg.obj);
+        }
+        return false;
+    }
+
+}
diff --git a/DaoCore/src/de/greenrobot/dao/Command.java b/DaoCore/src/de/greenrobot/dao/async/AsyncOperationListener.java
similarity index 57%
rename from DaoCore/src/de/greenrobot/dao/Command.java
rename to DaoCore/src/de/greenrobot/dao/async/AsyncOperationListener.java
index ff61a6b3..cd8a91d8 100644
--- a/DaoCore/src/de/greenrobot/dao/Command.java
+++ b/DaoCore/src/de/greenrobot/dao/async/AsyncOperationListener.java
@@ -13,27 +13,8 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+package de.greenrobot.dao.async;
 
-package de.greenrobot.dao;
-
-/**
- * Can be queued (future work).
- * 
- * @author Markus
- */
-public class Command {
-    public static enum CommandType {
-        Insert, InsertInTx, AndSoOn
-    }
-
-    public CommandType type;
-    public AbstractDao<?, ?> dao;
-    public Object data;
-
-    public Command(CommandType type, AbstractDao<?, ?> dao, Object data) {
-        this.type = type;
-        this.dao = dao;
-        this.data = data;
-    }
-
+public interface AsyncOperationListener {
+    void onAsyncOperationCompleted(AsyncOperation operation);
 }
diff --git a/DaoCore/src/de/greenrobot/dao/async/AsyncSession.java b/DaoCore/src/de/greenrobot/dao/async/AsyncSession.java
new file mode 100644
index 00000000..d77f099e
--- /dev/null
+++ b/DaoCore/src/de/greenrobot/dao/async/AsyncSession.java
@@ -0,0 +1,322 @@
+package de.greenrobot.dao.async;
+
+import java.util.concurrent.Callable;
+
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.AbstractDaoSession;
+import de.greenrobot.dao.DaoException;
+import de.greenrobot.dao.Query;
+import de.greenrobot.dao.async.AsyncOperation.OperationType;
+
+/**
+ * Asynchronous interface to entity operations. All operations will enqueued a @link {@link AsyncOperation} and return
+ * immediately (fine to call on the UI/main thread). The queue will be processed in a (single) background thread. The
+ * processing order is the call order of the operations. It's possible to start multiple AsyncSessions that will execute
+ * concurrently.
+ * 
+ * @author Markus
+ * 
+ * @see AbstractDaoSession#startAsyncSession()
+ */
+// Facade to AsyncOperationExecutor: prepares operations and delegates work to AsyncOperationExecutor.
+public class AsyncSession {
+    private final AbstractDaoSession daoSession;
+    private final AsyncOperationExecutor executor;
+
+    public AsyncSession(AbstractDaoSession daoSession) {
+        this.daoSession = daoSession;
+        this.executor = new AsyncOperationExecutor();
+    }
+
+    public int getMaxOperationCountToMerge() {
+        return executor.getMaxOperationCountToMerge();
+    }
+
+    public void setMaxOperationCountToMerge(int maxOperationCountToMerge) {
+        executor.setMaxOperationCountToMerge(maxOperationCountToMerge);
+    }
+
+    public int getWaitForMergeMillis() {
+        return executor.getWaitForMergeMillis();
+    }
+
+    public void setWaitForMergeMillis(int waitForMergeMillis) {
+        executor.setWaitForMergeMillis(waitForMergeMillis);
+    }
+
+    public AsyncOperationListener getListener() {
+        return executor.getListener();
+    }
+
+    public void setListener(AsyncOperationListener listener) {
+        executor.setListener(listener);
+    }
+
+    public AsyncOperationListener getListenerMainThread() {
+        return executor.getListenerMainThread();
+    }
+
+    public void setListenerMainThread(AsyncOperationListener listenerMainThread) {
+        executor.setListenerMainThread(listenerMainThread);
+    }
+
+    public boolean isCompleted() {
+        return executor.isCompleted();
+    }
+
+    /**
+     * Waits until all enqueued operations are complete. If the thread gets interrupted, any
+     * {@link InterruptedException} will be rethrown as a {@link DaoException}.
+     */
+    public void waitForCompletion() {
+        executor.waitForCompletion();
+    }
+
+    /**
+     * Waits until all enqueued operations are complete, but at most the given amount of milliseconds. If the thread
+     * gets interrupted, any {@link InterruptedException} will be rethrown as a {@link DaoException}.
+     * 
+     * @return true if operations completed in the given time frame.
+     */
+    public boolean waitForCompletion(int maxMillis) {
+        return executor.waitForCompletion(maxMillis);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#insert(Object)}. */
+    public AsyncOperation insert(Object entity) {
+        return insert(entity, 0);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#insert(Object)}. */
+    public AsyncOperation insert(Object entity, int flags) {
+        return enqueueEntityOperation(OperationType.Insert, entity, flags);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#insertInTx(Object...)}. */
+    public <E> AsyncOperation insertInTx(Class<E> entityClass, E... entities) {
+        return insertInTx(entityClass, 0, entities);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#insertInTx(Object...)}. */
+    public <E> AsyncOperation insertInTx(Class<E> entityClass, int flags, E... entities) {
+        return enqueEntityOperation(OperationType.InsertInTxArray, entityClass, entities, flags);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#insertInTx(Iterable)}. */
+    public <E> AsyncOperation insertInTx(Class<E> entityClass, Iterable<E> entities) {
+        return insertInTx(entityClass, entities, 0);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#insertInTx(Iterable)}. */
+    public <E> AsyncOperation insertInTx(Class<E> entityClass, Iterable<E> entities, int flags) {
+        return enqueEntityOperation(OperationType.InsertInTxIterable, entityClass, entities, flags);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#insertOrReplace(Object)}. */
+    public AsyncOperation insertOrReplace(Object entity) {
+        return insertOrReplace(entity, 0);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#insertOrReplace(Object)}. */
+    public AsyncOperation insertOrReplace(Object entity, int flags) {
+        return enqueueEntityOperation(OperationType.InsertOrReplace, entity, flags);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#insertOrReplaceInTx(Object...)}. */
+    public <E> AsyncOperation insertOrReplaceInTx(Class<E> entityClass, E... entities) {
+        return insertOrReplaceInTx(entityClass, 0, entities);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#insertOrReplaceInTx(Object...)}. */
+    public <E> AsyncOperation insertOrReplaceInTx(Class<E> entityClass, int flags, E... entities) {
+        return enqueEntityOperation(OperationType.InsertOrReplaceInTxArray, entityClass, entities, flags);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#insertOrReplaceInTx(Iterable)}. */
+    public <E> AsyncOperation insertOrReplaceInTx(Class<E> entityClass, Iterable<E> entities) {
+        return insertOrReplaceInTx(entityClass, entities, 0);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#insertOrReplaceInTx(Iterable)}. */
+    public <E> AsyncOperation insertOrReplaceInTx(Class<E> entityClass, Iterable<E> entities, int flags) {
+        return enqueEntityOperation(OperationType.InsertOrReplaceInTxIterable, entityClass, entities, flags);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#update(Object)}. */
+    public AsyncOperation update(Object entity) {
+        return update(entity, 0);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#update(Object)}. */
+    public AsyncOperation update(Object entity, int flags) {
+        return enqueueEntityOperation(OperationType.Update, entity, flags);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#updateInTx(Object...)}. */
+    public <E> AsyncOperation updateInTx(Class<E> entityClass, E... entities) {
+        return updateInTx(entityClass, 0, entities);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#updateInTx(Object...)}. */
+    public <E> AsyncOperation updateInTx(Class<E> entityClass, int flags, E... entities) {
+        return enqueEntityOperation(OperationType.UpdateInTxArray, entityClass, entities, flags);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#updateInTx(Iterable)}. */
+    public <E> AsyncOperation updateInTx(Class<E> entityClass, Iterable<E> entities) {
+        return updateInTx(entityClass, entities, 0);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#updateInTx(Iterable)}. */
+    public <E> AsyncOperation updateInTx(Class<E> entityClass, Iterable<E> entities, int flags) {
+        return enqueEntityOperation(OperationType.UpdateInTxIterable, entityClass, entities, flags);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#delete(Object)}. */
+    public AsyncOperation delete(Object entity) {
+        return delete(entity, 0);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#delete(Object)}. */
+    public AsyncOperation delete(Object entity, int flags) {
+        return enqueueEntityOperation(OperationType.Delete, entity, flags);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#deleteByKey(Object)}. */
+    public AsyncOperation deleteByKey(Object key) {
+        return deleteByKey(key, 0);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#deleteByKey(Object)}. */
+    public AsyncOperation deleteByKey(Object key, int flags) {
+        return enqueueEntityOperation(OperationType.DeleteByKey, key, flags);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#deleteInTx(Object...)}. */
+    public <E> AsyncOperation deleteInTx(Class<E> entityClass, E... entities) {
+        return deleteInTx(entityClass, 0, entities);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#deleteInTx(Object...)}. */
+    public <E> AsyncOperation deleteInTx(Class<E> entityClass, int flags, E... entities) {
+        return enqueEntityOperation(OperationType.DeleteInTxArray, entityClass, entities, flags);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#deleteInTx(Iterable)}. */
+    public <E> AsyncOperation deleteInTx(Class<E> entityClass, Iterable<E> entities) {
+        return deleteInTx(entityClass, entities, 0);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#deleteInTx(Iterable)}. */
+    public <E> AsyncOperation deleteInTx(Class<E> entityClass, Iterable<E> entities, int flags) {
+        return enqueEntityOperation(OperationType.DeleteInTxIterable, entityClass, entities, flags);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#deleteAll()}. */
+    public <E> AsyncOperation deleteAll(Class<E> entityClass) {
+        return deleteAll(entityClass, 0);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#deleteAll()}. */
+    public <E> AsyncOperation deleteAll(Class<E> entityClass, int flags) {
+        return enqueEntityOperation(OperationType.DeleteAll, entityClass, null, flags);
+    }
+
+    /** Asynchronous version of {@link AbstractDaoSession#runInTx(Runnable)}. */
+    public AsyncOperation runInTx(Runnable runnable) {
+        return runInTx(runnable, 0);
+    }
+
+    /** Asynchronous version of {@link AbstractDaoSession#runInTx(Runnable)}. */
+    public AsyncOperation runInTx(Runnable runnable, int flags) {
+        return enqueueDatabaseOperation(OperationType.TransactionRunnable, runnable, flags);
+    }
+
+    /** Asynchronous version of {@link AbstractDaoSession#callInTx(Callable)}. */
+    public AsyncOperation callInTx(Callable<?> callable) {
+        return callInTx(callable, 0);
+    }
+
+    /** Asynchronous version of {@link AbstractDaoSession#callInTx(Callable)}. */
+    public AsyncOperation callInTx(Callable<?> callable, int flags) {
+        return enqueueDatabaseOperation(OperationType.TransactionCallable, callable, flags);
+    }
+
+    /** Asynchronous version of {@link Query#list()}. */
+    public AsyncOperation queryList(Query<?> query) {
+        return queryList(query, 0);
+    }
+
+    /** Asynchronous version of {@link Query#list()}. */
+    public AsyncOperation queryList(Query<?> query, int flags) {
+        return enqueueDatabaseOperation(OperationType.QueryList, query, flags);
+    }
+
+    /** Asynchronous version of {@link Query#unique()}. */
+    public AsyncOperation queryUnique(Query<?> query) {
+        return queryUnique(query, 0);
+    }
+
+    /** Asynchronous version of {@link Query#unique()}. */
+    public AsyncOperation queryUnique(Query<?> query, int flags) {
+        return enqueueDatabaseOperation(OperationType.QueryUnique, query, flags);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#load(Object)}. */
+    public AsyncOperation load(Class<?> entityClass, Object key) {
+        return load(entityClass, key, 0);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#load(Object)}. */
+    public AsyncOperation load(Class<?> entityClass, Object key, int flags) {
+        return enqueEntityOperation(OperationType.Load, entityClass, key, flags);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#loadAll()}. */
+    public AsyncOperation loadAll(Class<?> entityClass) {
+        return loadAll(entityClass, 0);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#loadAll()}. */
+    public AsyncOperation loadAll(Class<?> entityClass, int flags) {
+        return enqueEntityOperation(OperationType.LoadAll, entityClass, null, flags);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#count()}. */
+    public AsyncOperation count(Class<?> entityClass) {
+        return count(entityClass, 0);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#count()}. */
+    public AsyncOperation count(Class<?> entityClass, int flags) {
+        return enqueEntityOperation(OperationType.Count, entityClass, null, flags);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#refresh(Object)}. */
+    public AsyncOperation refresh(Object entity) {
+        return refresh(entity, 0);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#refresh(Object)}. */
+    public AsyncOperation refresh(Object entity, int flags) {
+        return enqueueEntityOperation(OperationType.Refresh, entity, flags);
+    }
+
+    private AsyncOperation enqueueDatabaseOperation(OperationType type, Object param, int flags) {
+        AsyncOperation operation = new AsyncOperation(type, daoSession.getDatabase(), param, flags);
+        executor.enqueue(operation);
+        return operation;
+    }
+
+    private AsyncOperation enqueueEntityOperation(OperationType type, Object entity, int flags) {
+        return enqueEntityOperation(type, entity.getClass(), entity, flags);
+    }
+
+    private <E> AsyncOperation enqueEntityOperation(OperationType type, Class<E> entityClass, Object param, int flags) {
+        AbstractDao<?, ?> dao = daoSession.getDao(entityClass);
+        AsyncOperation operation = new AsyncOperation(type, dao, param, flags);
+        executor.enqueue(operation);
+        return operation;
+    }
+
+}
diff --git a/DaoGenerator/java-formater.xml b/DaoGenerator/java-formater.xml
new file mode 100644
index 00000000..9eabc7e4
--- /dev/null
+++ b/DaoGenerator/java-formater.xml
@@ -0,0 +1,291 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<profiles version="12">
+<profile kind="CodeFormatterProfile" name="greenrobot" version="12">
+<setting id="org.eclipse.jdt.core.formatter.comment.insert_new_line_before_root_tags" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.disabling_tag" value="@formatter:off"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_annotation" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_type_parameters" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_type_declaration" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_type_arguments" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.brace_position_for_anonymous_type_declaration" value="end_of_line"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_colon_in_case" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_brace_in_array_initializer" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.comment.new_lines_at_block_boundaries" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_in_empty_annotation_declaration" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_before_closing_brace_in_array_initializer" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_annotation" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.blank_lines_before_field" value="0"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_while" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.use_on_off_tags" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_annotation_type_member_declaration" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_before_else_in_if_statement" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_prefix_operator" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.keep_else_statement_on_same_line" value="false"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_ellipsis" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.comment.insert_new_line_for_parameter" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_annotation_type_declaration" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.indent_breaks_compare_to_cases" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_at_in_annotation" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_multiple_fields" value="16"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_expressions_in_array_initializer" value="16"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_conditional_expression" value="80"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_for" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_binary_operator" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_question_in_wildcard" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.brace_position_for_array_initializer" value="end_of_line"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_enum_constant" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_before_finally_in_try_statement" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_local_variable" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_before_catch_in_try_statement" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_while" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.blank_lines_after_package" value="1"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_type_parameters" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.continuation_indentation" value="2"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_postfix_operator" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_arguments_in_method_invocation" value="16"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_type_arguments" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_superinterfaces" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.blank_lines_before_new_chunk" value="1"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_binary_operator" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.blank_lines_before_package" value="0"/>
+<setting id="org.eclipse.jdt.core.compiler.source" value="1.7"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_enum_constant_arguments" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_constructor_declaration" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.comment.format_line_comments" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_closing_angle_bracket_in_type_arguments" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_enum_declarations" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.join_wrapped_lines" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_block" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_arguments_in_explicit_constructor_call" value="16"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_invocation_arguments" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.blank_lines_before_member_type" value="1"/>
+<setting id="org.eclipse.jdt.core.formatter.align_type_members_on_columns" value="false"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_enum_constant" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_for" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_method_declaration" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_selector_in_method_invocation" value="16"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_switch" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_unary_operator" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_colon_in_case" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.comment.indent_parameter_description" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_method_declaration" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_switch" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_enum_declaration" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_type_parameters" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.comment.clear_blank_lines_in_block_comment" value="false"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_in_empty_type_declaration" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.lineSplit" value="120"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_if" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_between_brackets_in_array_type_reference" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_parenthesized_expression" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_explicitconstructorcall_arguments" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_constructor_declaration" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.blank_lines_before_first_class_body_declaration" value="0"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_method" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.indentation.size" value="4"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_method_declaration" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.enabling_tag" value="@formatter:on"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_enum_constant" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_superclass_in_type_declaration" value="16"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_assignment" value="0"/>
+<setting id="org.eclipse.jdt.core.compiler.problem.assertIdentifier" value="error"/>
+<setting id="org.eclipse.jdt.core.formatter.tabulation.char" value="space"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_constructor_declaration_parameters" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_semicolon_in_try_resources" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_prefix_operator" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.indent_statements_compare_to_body" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.blank_lines_before_method" value="1"/>
+<setting id="org.eclipse.jdt.core.formatter.wrap_outer_expressions_when_nested" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.format_guardian_clause_on_one_line" value="false"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_colon_in_for" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_cast" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_parameters_in_constructor_declaration" value="16"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_colon_in_labeled_statement" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.brace_position_for_annotation_type_declaration" value="end_of_line"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_in_empty_method_body" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_method_declaration" value="0"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_method_invocation" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_try" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_bracket_in_array_allocation_expression" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_enum_constant" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_annotation" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_at_in_annotation_type_declaration" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_declaration_throws" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_if" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.brace_position_for_switch" value="end_of_line"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_declaration_throws" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_parenthesized_expression_in_return" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_annotation" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_question_in_conditional" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_question_in_wildcard" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_try" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_bracket_in_array_allocation_expression" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.comment.preserve_white_space_between_code_and_line_comments" value="false"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_parenthesized_expression_in_throw" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_type_arguments" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.compiler.problem.enumIdentifier" value="error"/>
+<setting id="org.eclipse.jdt.core.formatter.indent_switchstatements_compare_to_switch" value="false"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_ellipsis" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.brace_position_for_block" value="end_of_line"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_for_inits" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.brace_position_for_method_declaration" value="end_of_line"/>
+<setting id="org.eclipse.jdt.core.formatter.compact_else_if" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.wrap_before_or_operator_multicatch" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_array_initializer" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_for_increments" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.format_line_comment_starting_on_first_column" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_bracket_in_array_reference" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_field" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.brace_position_for_enum_constant" value="end_of_line"/>
+<setting id="org.eclipse.jdt.core.formatter.comment.indent_root_tags" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_enum_declarations" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_union_type_in_multicatch" value="16"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_explicitconstructorcall_arguments" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_switch" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_declaration_parameters" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_superinterfaces" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_allocation_expression" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.tabulation.size" value="4"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_type_reference" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_opening_brace_in_array_initializer" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_closing_brace_in_block" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_reference" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_in_empty_enum_constant" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_type_arguments" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_constructor_declaration" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_constructor_declaration_throws" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_if" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.comment.clear_blank_lines_in_javadoc_comment" value="false"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_throws_clause_in_constructor_declaration" value="16"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_assignment_operator" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_assignment_operator" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.indent_empty_lines" value="false"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_synchronized" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_closing_paren_in_cast" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_declaration_parameters" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.brace_position_for_block_in_case" value="end_of_line"/>
+<setting id="org.eclipse.jdt.core.formatter.number_of_empty_lines_to_preserve" value="1"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_method_declaration" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_catch" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_constructor_declaration" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_method_invocation" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_bracket_in_array_reference" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_arguments_in_qualified_allocation_expression" value="16"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_and_in_type_parameter" value="insert"/>
+<setting id="org.eclipse.jdt.core.compiler.compliance" value="1.7"/>
+<setting id="org.eclipse.jdt.core.formatter.continuation_indentation_for_array_initializer" value="2"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_between_empty_brackets_in_array_allocation_expression" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_at_in_annotation_type_declaration" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_arguments_in_allocation_expression" value="16"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_cast" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_unary_operator" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_parameterized_type_reference" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_anonymous_type_declaration" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.keep_empty_array_initializer_on_one_line" value="false"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_in_empty_enum_declaration" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.keep_imple_if_on_one_line" value="false"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_constructor_declaration_parameters" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_closing_angle_bracket_in_type_parameters" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_at_end_of_file_if_missing" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_colon_in_for" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_colon_in_labeled_statement" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_parameterized_type_reference" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_superinterfaces_in_type_declaration" value="16"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_binary_expression" value="16"/>
+<setting id="org.eclipse.jdt.core.formatter.brace_position_for_enum_declaration" value="end_of_line"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_type" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_while" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode" value="enabled"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_try" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.put_empty_statement_on_new_line" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_label" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_parameter" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_type_parameters" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_method_invocation" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_before_while_in_do_statement" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_arguments_in_enum_constant" value="16"/>
+<setting id="org.eclipse.jdt.core.formatter.comment.format_javadoc_comments" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.comment.line_length" value="120"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_package" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.blank_lines_between_import_groups" value="1"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_enum_constant_arguments" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_semicolon" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.brace_position_for_constructor_declaration" value="end_of_line"/>
+<setting id="org.eclipse.jdt.core.formatter.number_of_blank_lines_at_beginning_of_method_body" value="0"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_colon_in_conditional" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_type_header" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_annotation_type_member_declaration" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.wrap_before_binary_operator" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_enum_declaration_header" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.blank_lines_between_type_declarations" value="1"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_synchronized" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.indent_statements_compare_to_block" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_superinterfaces_in_enum_declaration" value="16"/>
+<setting id="org.eclipse.jdt.core.formatter.join_lines_in_comments" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_question_in_conditional" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_multiple_field_declarations" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_compact_if" value="16"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_for_inits" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.indent_switchstatements_compare_to_cases" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_array_initializer" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_colon_in_default" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_and_in_type_parameter" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_constructor_declaration" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.blank_lines_before_imports" value="1"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_colon_in_assert" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.comment.format_html" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_throws_clause_in_method_declaration" value="16"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_type_parameters" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_allocation_expression" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_in_empty_anonymous_type_declaration" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_colon_in_conditional" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_parameterized_type_reference" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_for" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_postfix_operator" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.comment.format_source_code" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_synchronized" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_allocation_expression" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_constructor_declaration_throws" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_parameters_in_method_declaration" value="16"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_brace_in_array_initializer" value="insert"/>
+<setting id="org.eclipse.jdt.core.compiler.codegen.targetPlatform" value="1.7"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_resources_in_try" value="80"/>
+<setting id="org.eclipse.jdt.core.formatter.use_tabs_only_for_leading_indentations" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_arguments_in_annotation" value="0"/>
+<setting id="org.eclipse.jdt.core.formatter.comment.format_header" value="false"/>
+<setting id="org.eclipse.jdt.core.formatter.comment.format_block_comments" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_enum_constant" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_enum_constants" value="0"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_in_empty_block" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_annotation_declaration_header" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_parenthesized_expression" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_parenthesized_expression" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_catch" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_multiple_local_declarations" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_switch" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_for_increments" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_method_invocation" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_colon_in_assert" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.brace_position_for_type_declaration" value="end_of_line"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_array_initializer" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_between_empty_braces_in_array_initializer" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_method_declaration" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_semicolon_in_for" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_catch" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_parameterized_type_reference" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_multiple_field_declarations" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_annotation" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_parameterized_type_reference" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_invocation_arguments" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.comment.new_lines_at_javadoc_boundaries" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.blank_lines_after_imports" value="1"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_multiple_local_declarations" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_enum_constant_header" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_semicolon_in_for" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.never_indent_line_comments_on_first_column" value="false"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_semicolon_in_try_resources" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_type_arguments" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.never_indent_block_comments_on_first_column" value="false"/>
+<setting id="org.eclipse.jdt.core.formatter.keep_then_statement_on_same_line" value="false"/>
+</profile>
+</profiles>
diff --git a/DaoTest/src/de/greenrobot/daotest/async/AbstractAsyncTest.java b/DaoTest/src/de/greenrobot/daotest/async/AbstractAsyncTest.java
new file mode 100644
index 00000000..1e4579ba
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/async/AbstractAsyncTest.java
@@ -0,0 +1,48 @@
+package de.greenrobot.daotest.async;
+
+import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
+
+import android.app.Application;
+import de.greenrobot.dao.async.AsyncOperation;
+import de.greenrobot.dao.async.AsyncOperationListener;
+import de.greenrobot.dao.async.AsyncSession;
+import de.greenrobot.dao.test.AbstractDaoSessionTest;
+import de.greenrobot.daotest.DaoMaster;
+import de.greenrobot.daotest.DaoSession;
+
+public abstract class AbstractAsyncTest extends AbstractDaoSessionTest<Application, DaoMaster, DaoSession> implements
+        AsyncOperationListener {
+
+    protected AsyncSession asyncSession;
+    protected List<AsyncOperation> completedOperations;
+
+    public AbstractAsyncTest() {
+        super(DaoMaster.class);
+    }
+
+    @Override
+    protected void setUp() {
+        super.setUp();
+        asyncSession = daoSession.startAsyncSession();
+        asyncSession.setListener(this);
+        completedOperations = new CopyOnWriteArrayList<AsyncOperation>();
+    }
+
+    public void assertWaitForCompletion1Sec() {
+        assertTrue(asyncSession.waitForCompletion(1000));
+        assertTrue(asyncSession.isCompleted());
+    }
+
+    @Override
+    public void onAsyncOperationCompleted(AsyncOperation operation) {
+        completedOperations.add(operation);
+    }
+
+    protected void assertSingleOperationCompleted(AsyncOperation operation) {
+        assertSame(operation, completedOperations.get(0));
+        assertEquals(1, completedOperations.size());
+        assertTrue(operation.isCompleted());
+    }
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/async/BasicAsyncTest.java b/DaoTest/src/de/greenrobot/daotest/async/BasicAsyncTest.java
new file mode 100644
index 00000000..5a181ee8
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/async/BasicAsyncTest.java
@@ -0,0 +1,156 @@
+package de.greenrobot.daotest.async;
+
+import java.util.concurrent.Callable;
+
+import android.os.Looper;
+import de.greenrobot.dao.async.AsyncDaoException;
+import de.greenrobot.dao.async.AsyncOperation;
+import de.greenrobot.dao.async.AsyncOperationListener;
+import de.greenrobot.daotest.SimpleEntity;
+
+public class BasicAsyncTest extends AbstractAsyncTest {
+
+    Thread txThread;
+    boolean testListenerMainThread_done;
+
+    public void testSequenceNumber() {
+        AsyncOperation op1 = asyncSession.count(SimpleEntity.class);
+        assertEquals(1, op1.getSequenceNumber());
+        AsyncOperation op2 = asyncSession.count(SimpleEntity.class);
+        assertEquals(2, op2.getSequenceNumber());
+    }
+
+    public void testWaitForCompletionNoOps() {
+        assertTrue(asyncSession.isCompleted());
+        assertTrue(asyncSession.waitForCompletion(1));
+        asyncSession.waitForCompletion();
+    }
+
+    public void testAsyncInsert() {
+        SimpleEntity entity = new SimpleEntity();
+        entity.setSimpleString("heho");
+        AsyncOperation operation = asyncSession.insert(entity);
+        assertWaitForCompletion1Sec();
+        SimpleEntity entity2 = daoSession.load(SimpleEntity.class, entity.getId());
+        assertNotNull(entity2);
+        assertEquals("heho", entity2.getSimpleString());
+        assertFalse(operation.isFailed());
+        assertSingleOperationCompleted(operation);
+    }
+
+    public void testAsyncUpdate() {
+        SimpleEntity entity = new SimpleEntity();
+        entity.setSimpleString("heho");
+        daoSession.insert(entity);
+        entity.setSimpleString("updated");
+        AsyncOperation operation = asyncSession.update(entity);
+        assertWaitForCompletion1Sec();
+        daoSession.clear();
+        SimpleEntity entity2 = daoSession.load(SimpleEntity.class, entity.getId());
+        assertNotNull(entity2);
+        assertEquals("updated", entity2.getSimpleString());
+        assertFalse(operation.isFailed());
+        assertSingleOperationCompleted(operation);
+    }
+
+    public void testOperationGetResult() {
+        SimpleEntity entity = new SimpleEntity();
+        entity.setSimpleString("heho");
+        daoSession.insert(entity);
+        daoSession.clear();
+
+        AsyncOperation operation = asyncSession.load(SimpleEntity.class, entity.getId());
+        SimpleEntity result = (SimpleEntity) operation.getResult();
+        assertTrue(operation.isCompleted());
+        assertTrue(operation.isCompletedSucessfully());
+        assertNotNull(result);
+        assertNotSame(entity, result);
+        assertEquals(entity.getId(), result.getId());
+        assertEquals(entity.getSimpleString(), result.getSimpleString());
+    }
+
+    public void testOperationGetResultException() {
+        SimpleEntity entity = new SimpleEntity();
+        daoSession.insert(entity);
+        AsyncOperation operation = asyncSession.insert(entity);
+        try {
+            operation.getResult();
+            fail("getResult should have thrown");
+        } catch (AsyncDaoException expected) {
+            // OK
+        }
+        assertTrue(operation.isCompleted());
+        assertFalse(operation.isCompletedSucessfully());
+        assertTrue(operation.isFailed());
+    }
+
+    public void testAsyncException() {
+        SimpleEntity entity = new SimpleEntity();
+        daoSession.insert(entity);
+        AsyncOperation operation = asyncSession.insert(entity);
+        assertWaitForCompletion1Sec();
+        assertSingleOperationCompleted(operation);
+
+        assertTrue(operation.isFailed());
+        assertNotNull(operation.getThrowable());
+    }
+
+    public void testAsyncOperationWaitMillis() {
+        AsyncOperation operation = asyncSession.insert(new SimpleEntity());
+        assertTrue(asyncSession.waitForCompletion(1000));
+        assertSingleOperationCompleted(operation);
+    }
+
+    public void testAsyncOperationWait() {
+        AsyncOperation operation = asyncSession.insert(new SimpleEntity());
+        asyncSession.waitForCompletion();
+        assertSingleOperationCompleted(operation);
+    }
+
+    public void testAsyncRunInTx() {
+        AsyncOperation operation = asyncSession.runInTx(new Runnable() {
+
+            @Override
+            public void run() {
+                txThread = Thread.currentThread();
+            }
+        });
+        assertWaitForCompletion1Sec();
+        assertSingleOperationCompleted(operation);
+        assertNotNull(txThread);
+        assertFalse(Thread.currentThread().equals(txThread));
+    }
+
+    public void testAsynCallInTx() {
+        AsyncOperation operation = asyncSession.callInTx(new Callable<String>() {
+
+            @Override
+            public String call() throws Exception {
+                txThread = Thread.currentThread();
+                return "OK";
+            }
+        });
+        assertEquals("OK", operation.waitForCompletion());
+        assertNotNull(txThread);
+        assertFalse(Thread.currentThread().equals(txThread));
+    }
+
+    public void testListenerMainThread() throws InterruptedException {
+        AsyncOperationListener listener = new AsyncOperationListener() {
+            @Override
+            public synchronized void onAsyncOperationCompleted(AsyncOperation operation) {
+                assertEquals(Looper.getMainLooper(), Looper.myLooper());
+                testListenerMainThread_done = true;
+                notifyAll();
+            }
+        };
+        asyncSession.setListenerMainThread(listener);
+        asyncSession.insert(new SimpleEntity());
+        assertWaitForCompletion1Sec();
+        while (!testListenerMainThread_done) {
+            synchronized (listener) {
+                listener.wait();
+            }
+        }
+    }
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/async/MergeTxAsyncTest.java b/DaoTest/src/de/greenrobot/daotest/async/MergeTxAsyncTest.java
new file mode 100644
index 00000000..c307e914
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/async/MergeTxAsyncTest.java
@@ -0,0 +1,30 @@
+package de.greenrobot.daotest.async;
+
+import de.greenrobot.dao.async.AsyncOperation;
+import de.greenrobot.daotest.SimpleEntity;
+
+public class MergeTxAsyncTest extends AbstractAsyncTest {
+
+    public void testMergeInsertAndUpdate() {
+        SimpleEntity entity = new SimpleEntity();
+        entity.setId(42l);
+        entity.setSimpleString("heho");
+        
+        SimpleEntity entity2 = new SimpleEntity();
+        entity2.setId(42l);
+        entity2.setSimpleString("updated");
+        
+        AsyncOperation op1 = asyncSession.insert(entity, AsyncOperation.FLAG_MERGE_TX);
+        AsyncOperation op2 = asyncSession.update(entity2, AsyncOperation.FLAG_MERGE_TX);
+        
+        assertWaitForCompletion1Sec();
+        daoSession.clear();
+        SimpleEntity entity3 = daoSession.load(SimpleEntity.class, 42l);
+        assertNotNull(entity3);
+        assertEquals(entity2.getSimpleString(), entity3.getSimpleString());
+        
+        assertEquals(2, op1.getMergedOperationsCount());
+        assertEquals(2, op2.getMergedOperationsCount());
+    }
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/query/RawQueryTest.java b/DaoTest/src/de/greenrobot/daotest/query/RawQueryTest.java
new file mode 100644
index 00000000..bf2db6c4
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/query/RawQueryTest.java
@@ -0,0 +1,90 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.query;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import de.greenrobot.dao.LazyList;
+import de.greenrobot.dao.Query;
+import de.greenrobot.dao.QueryBuilder;
+import de.greenrobot.daotest.TestEntity;
+import de.greenrobot.daotest.TestEntityDao.Properties;
+import de.greenrobot.daotest.entity.TestEntityTestBase;
+
+public class RawQueryTest extends TestEntityTestBase {
+    @Override
+    protected void setUp() {
+        super.setUp();
+        QueryBuilder.LOG_SQL = true;
+        QueryBuilder.LOG_VALUES = true;
+    }
+
+    public void testRawQueryEmptySql() {
+        insert(3);
+        Query<TestEntity> query = dao.queryRawCreate("");
+        List<TestEntity> result = query.list();
+        assertEquals(3, result.size());
+    }
+
+    public void testRawQueryEqualsString() {
+        ArrayList<TestEntity> inserted = insert(3);
+        String value = getSimpleString(1);
+
+        String sql = "WHERE " + Properties.SimpleString.columnName + "=?";
+        List<TestEntity> result = dao.queryRawCreate(sql, value).list();
+        assertEquals(1, result.size());
+
+        TestEntity resultEntity = result.get(0);
+        assertEquals(value, resultEntity.getSimpleString());
+        assertEquals(inserted.get(1).getId(), resultEntity.getId());
+    }
+
+    public void testRawQueryCreate_setParameterInQuery() {
+        insert(3);
+        String value = getSimpleString(2);
+
+        String sql = "WHERE " + Properties.SimpleString.columnName + "=?";
+        Query<TestEntity> query = dao.queryRawCreate(sql, getSimpleString(1));
+        query.list();
+
+        query.setParameter(0, value);
+        List<TestEntity> result = query.list();
+
+        assertEquals(1, result.size());
+        assertEquals(value, result.get(0).getSimpleString());
+    }
+    
+    public void testRawQueryLazyList() {
+        ArrayList<TestEntity> list = insert(2);
+
+        LazyList<TestEntity> listLazy = dao.queryRawCreate("").listLazy();
+        assertEquals(list.size(), listLazy.size());
+        assertNull(listLazy.peak(0));
+        assertNull(listLazy.peak(1));
+
+        assertNotNull(listLazy.get(1));
+        assertNull(listLazy.peak(0));
+        assertNotNull(listLazy.peak(1));
+
+        assertNotNull(listLazy.get(0));
+        assertNotNull(listLazy.peak(0));
+        assertNotNull(listLazy.peak(1));
+    }
+
+}
diff --git a/README.md b/README.md
index db8445cb..f31c0aac 100644
--- a/README.md
+++ b/README.md
@@ -6,6 +6,14 @@ Home page, documentation, and support links: http://greendao-orm.com/
 
 Release History
 ---------------
+### VX.X.0 Preview (2012-??-??): New asynchronous API
+* New AsyncSession (acquired from DaoSession.startAsyncSession()) provides most operations for DAOs, Queries, and transactions in a asynchronously variant
+* AsyncOperations are processed in order by a background thread
+* waitForCompletion methods for AsyncSession and AsyncOperations
+* AsyncOperationListener for asynchronous callback when operations complete
+* Asynchronous operations can be merged in single transactions (details follow)
+* Added raw SQL queries returning a Query object (LazyList support etc.)
+
 ### V1.2.0 (2012-06-08): Feature release
 * Limited support of String PKs (no relations using String FKs yet)
 * Fixed index creation (please update your schema)
