diff --git a/DaoGenerator/src-generator-testentities/de/greenrobot/daogenerator/gentest/TestDaoGenerator.java b/DaoGenerator/src-generator-testentities/de/greenrobot/daogenerator/gentest/TestDaoGenerator.java
index 47bba961..434cf50a 100644
--- a/DaoGenerator/src-generator-testentities/de/greenrobot/daogenerator/gentest/TestDaoGenerator.java
+++ b/DaoGenerator/src-generator-testentities/de/greenrobot/daogenerator/gentest/TestDaoGenerator.java
@@ -63,6 +63,7 @@ public TestDaoGenerator() {
 
     public void generate() throws Exception {
         DaoGenerator daoGenerator = new DaoGenerator();
+
         daoGenerator.generateAll(schema, "../DaoTest/src-gen", "../DaoTest/src");
         daoGenerator.generateAll(schema2, "../DaoTest/src-gen", "../DaoTest/src");
     }
diff --git a/DaoGenerator/src-template/content-provider.ftl b/DaoGenerator/src-template/content-provider.ftl
index 93396f73..e7e3d644 100644
--- a/DaoGenerator/src-template/content-provider.ftl
+++ b/DaoGenerator/src-template/content-provider.ftl
@@ -1,5 +1,7 @@
 package ${contentProvider.javaPackage};
 
+import java.sql.Connection;
+
 import android.content.ContentProvider;
 import android.content.ContentResolver;
 import android.content.ContentValues;
@@ -10,8 +12,8 @@ import android.database.sqlite.SQLiteQueryBuilder;
 import android.net.Uri;
 
 import de.greenrobot.dao.DaoLog;
+import de.greenrobot.platform.android.util.SQLiteUtil;
 
-import ${schema.defaultJavaPackageDao}.DaoSession;
 import ${entity.javaPackageDao}.${entity.classNameDao};
 
 /* Copy this code snippet into your AndroidManifest.xml inside the
@@ -43,31 +45,31 @@ import ${entity.javaPackageDao}.${entity.classNameDao};
     private static final UriMatcher sURIMatcher;
 
     static {
-    sURIMatcher = new UriMatcher(UriMatcher.NO_MATCH);
-    sURIMatcher.addURI(AUTHORITY, BASE_PATH, ${entity.className?upper_case}_DIR);
-    sURIMatcher.addURI(AUTHORITY, BASE_PATH + "/#", ${entity.className?upper_case}_ID);
+    	sURIMatcher = new UriMatcher(UriMatcher.NO_MATCH);
+    	sURIMatcher.addURI(AUTHORITY, BASE_PATH, ${entity.className?upper_case}_DIR);
+    	sURIMatcher.addURI(AUTHORITY, BASE_PATH + "/#", ${entity.className?upper_case}_ID);
     }
 
     /**
     * This must be set from outside, it's recommended to do this inside your Application object.
     * Subject to change (static isn't nice).
     */
-    public static DaoSession daoSession;
+    public static Connection connection;
 
     @Override
     public boolean onCreate() {
-    // if(daoSession == null) {
-    // throw new IllegalStateException("DaoSession must be set before content provider is created");
-    // }
-    DaoLog.d("Content Provider started: " + CONTENT_URI);
-    return true;
+    	// if(daoSession == null) {
+   		// throw new IllegalStateException("DaoSession must be set before content provider is created");
+    	// }
+    	DaoLog.d("Content Provider started: " + CONTENT_URI);
+    	return true;
     }
 
     protected SQLiteDatabase getDatabase() {
-    if(daoSession == null) {
-    throw new IllegalStateException("DaoSession must be set during content provider is active");
-    }
-    return daoSession.getDatabase();
+    	if(connection == null) {
+    		throw new IllegalStateException("Connection must be set during content provider is active");
+    	}
+    	return SQLiteUtil.from(connection, getContext());
     }
 
 <#--
@@ -77,23 +79,23 @@ import ${entity.javaPackageDao}.${entity.classNameDao};
 -->
     @Override
     public Uri insert(Uri uri, ContentValues values) {
-<#if contentProvider.isReadOnly()>
-    throw new UnsupportedOperationException("This content provider is readonly");
-<#else>
-    int uriType = sURIMatcher.match(uri);
-    long id = 0;
-    String path = "";
-    switch (uriType) {
-    case ${entity.className?upper_case}_DIR:
-    id = getDatabase().insert(TABLENAME, null, values);
-    path = BASE_PATH + "/" + id;
-    break;
-    default:
-    throw new IllegalArgumentException("Unknown URI: " + uri);
-    }
-    getContext().getContentResolver().notifyChange(uri, null);
-    return Uri.parse(path);
-</#if>
+	<#if contentProvider.isReadOnly()>
+	    throw new UnsupportedOperationException("This content provider is readonly");
+	<#else>
+	    int uriType = sURIMatcher.match(uri);
+	    long id = 0;
+	    String path = "";
+	    switch (uriType) {
+	    	case ${entity.className?upper_case}_DIR:
+		    	id = getDatabase().insert(TABLENAME, null, values);
+		    	path = BASE_PATH + "/" + id;
+		   		break;
+	    	default:
+	    		throw new IllegalArgumentException("Unknown URI: " + uri);
+	    }
+	    getContext().getContentResolver().notifyChange(uri, null);
+	    return Uri.parse(path);
+	</#if>
     }
 
 <#--
@@ -103,32 +105,32 @@ import ${entity.javaPackageDao}.${entity.classNameDao};
 -->
     @Override
     public int delete(Uri uri, String selection, String[] selectionArgs) {
-<#if contentProvider.isReadOnly()>
-    throw new UnsupportedOperationException("This content provider is readonly");
-<#else>
-    int uriType = sURIMatcher.match(uri);
-    SQLiteDatabase db = getDatabase();
-    int rowsDeleted = 0;
-    String id;
-    switch (uriType) {
-    case ${entity.className?upper_case}_DIR:
-    rowsDeleted = db.delete(TABLENAME, selection, selectionArgs);
-    break;
-    case ${entity.className?upper_case}_ID:
-    id = uri.getLastPathSegment();
-    if (TextUtils.isEmpty(selection)) {
-    rowsDeleted = db.delete(TABLENAME, PK + "=" + id, null);
-    } else {
-    rowsDeleted = db.delete(TABLENAME, PK + "=" + id + " and "
-    + selection, selectionArgs);
-    }
-    break;
-    default:
-    throw new IllegalArgumentException("Unknown URI: " + uri);
-    }
-    getContext().getContentResolver().notifyChange(uri, null);
-    return rowsDeleted;
-</#if>
+	<#if contentProvider.isReadOnly()>
+	    throw new UnsupportedOperationException("This content provider is readonly");
+	<#else>
+	    int uriType = sURIMatcher.match(uri);
+	    SQLiteDatabase db = getDatabase();
+	    int rowsDeleted = 0;
+	    String id;
+	    switch (uriType) {
+		    case ${entity.className?upper_case}_DIR:
+		    	rowsDeleted = db.delete(TABLENAME, selection, selectionArgs);
+		    	break;
+		    case ${entity.className?upper_case}_ID:
+		   		id = uri.getLastPathSegment();
+		    	if (TextUtils.isEmpty(selection)) {
+		    		rowsDeleted = db.delete(TABLENAME, PK + "=" + id, null);
+		    	} else {
+		    		rowsDeleted = db.delete(TABLENAME, PK + "=" + id + " and "
+		    		+ selection, selectionArgs);
+		    	}
+		    	break;
+		    default:
+		    	throw new IllegalArgumentException("Unknown URI: " + uri);
+	    }
+	    getContext().getContentResolver().notifyChange(uri, null);
+	    return rowsDeleted;
+	</#if>
     }
 
 <#--
@@ -139,32 +141,32 @@ import ${entity.javaPackageDao}.${entity.classNameDao};
     @Override
     public int update(Uri uri, ContentValues values, String selection,
     String[] selectionArgs) {
-<#if contentProvider.isReadOnly()>
-    throw new UnsupportedOperationException("This content provider is readonly");
-<#else>
-    int uriType = sURIMatcher.match(uri);
-    SQLiteDatabase db = getDatabase();
-    int rowsUpdated = 0;
-    String id;
-    switch (uriType) {
-    case ${entity.className?upper_case}_DIR:
-    rowsUpdated = db.update(TABLENAME, values, selection, selectionArgs);
-    break;
-    case ${entity.className?upper_case}_ID:
-    id = uri.getLastPathSegment();
-    if (TextUtils.isEmpty(selection)) {
-    rowsUpdated = db.update(TABLENAME, values, PK + "=" + id, null);
-    } else {
-    rowsUpdated = db.update(TABLENAME, values, PK + "=" + id
-    + " and " + selection, selectionArgs);
-    }
-    break;
-    default:
-    throw new IllegalArgumentException("Unknown URI: " + uri);
-    }
-    getContext().getContentResolver().notifyChange(uri, null);
-    return rowsUpdated;
-</#if>
+	<#if contentProvider.isReadOnly()>
+	    throw new UnsupportedOperationException("This content provider is readonly");
+	<#else>
+	    int uriType = sURIMatcher.match(uri);
+	    SQLiteDatabase db = getDatabase();
+	    int rowsUpdated = 0;
+	    String id;
+	    switch (uriType) {
+	    	case ${entity.className?upper_case}_DIR:
+	    		rowsUpdated = db.update(TABLENAME, values, selection, selectionArgs);
+	    		break;
+	    	case ${entity.className?upper_case}_ID:
+	    		id = uri.getLastPathSegment();
+	    		if (TextUtils.isEmpty(selection)) {
+	    			rowsUpdated = db.update(TABLENAME, values, PK + "=" + id, null);
+	    		} else {
+	    			rowsUpdated = db.update(TABLENAME, values, PK + "=" + id
+	    			+ " and " + selection, selectionArgs);
+	    		}
+	    		break;
+	    	default:
+	    		throw new IllegalArgumentException("Unknown URI: " + uri);
+	    }
+	    getContext().getContentResolver().notifyChange(uri, null);
+	    return rowsUpdated;
+	</#if>
     }
 <#--
 ##########################################
@@ -175,27 +177,27 @@ import ${entity.javaPackageDao}.${entity.classNameDao};
     public Cursor query(Uri uri, String[] projection, String selection,
     String[] selectionArgs, String sortOrder) {
 
-    SQLiteQueryBuilder queryBuilder = new SQLiteQueryBuilder();
-    int uriType = sURIMatcher.match(uri);
-    switch (uriType) {
-    case ${entity.className?upper_case}_DIR:
-    queryBuilder.setTables(TABLENAME);
-    break;
-    case ${entity.className?upper_case}_ID:
-    queryBuilder.setTables(TABLENAME);
-    queryBuilder.appendWhere(PK + "="
-    + uri.getLastPathSegment());
-    break;
-    default:
-    throw new IllegalArgumentException("Unknown URI: " + uri);
-    }
-
-    SQLiteDatabase db = getDatabase();
-    Cursor cursor = queryBuilder.query(db, projection, selection,
-    selectionArgs, null, null, sortOrder);
-    cursor.setNotificationUri(getContext().getContentResolver(), uri);
-
-    return cursor;
+	    SQLiteQueryBuilder queryBuilder = new SQLiteQueryBuilder();
+	    int uriType = sURIMatcher.match(uri);
+	    switch (uriType) {
+	    	case ${entity.className?upper_case}_DIR:
+	    		queryBuilder.setTables(TABLENAME);
+	    		break;
+	    	case ${entity.className?upper_case}_ID:
+	    		queryBuilder.setTables(TABLENAME);
+	    		queryBuilder.appendWhere(PK + "="
+	    		+ uri.getLastPathSegment());
+	    		break;
+	    	default:
+	    		throw new IllegalArgumentException("Unknown URI: " + uri);
+	    }
+	
+	    SQLiteDatabase db = getDatabase();
+	    Cursor cursor = queryBuilder.query(db, projection, selection,
+	    selectionArgs, null, null, sortOrder);
+	    cursor.setNotificationUri(getContext().getContentResolver(), uri);
+	
+	    return cursor;
     }
 
 <#--
@@ -205,13 +207,13 @@ import ${entity.javaPackageDao}.${entity.classNameDao};
 -->
     @Override
     public final String getType(Uri uri) {
-    switch (sURIMatcher.match(uri)) {
-    case ${entity.className?upper_case}_DIR:
-    return CONTENT_TYPE;
-    case ${entity.className?upper_case}_ID:
-    return CONTENT_ITEM_TYPE;
-    default :
-    throw new IllegalArgumentException("Unsupported URI: " + uri);
-    }
-    }
-    }
+    	switch (sURIMatcher.match(uri)) {
+    		case ${entity.className?upper_case}_DIR:
+    			return CONTENT_TYPE;
+    		case ${entity.className?upper_case}_ID:
+    			return CONTENT_ITEM_TYPE;
+    		default :
+    			throw new IllegalArgumentException("Unsupported URI: " + uri);
+    	}
+    }
+}
diff --git a/DaoGenerator/src-template/dao-deep.ftl b/DaoGenerator/src-template/dao-deep.ftl
index eee5dc97..caf36e90 100644
--- a/DaoGenerator/src-template/dao-deep.ftl
+++ b/DaoGenerator/src-template/dao-deep.ftl
@@ -42,12 +42,12 @@ along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
         return selectDeep;
     }
     
-    protected ${entity.className} loadCurrentDeep(Cursor cursor, boolean lock) {
-        ${entity.className} entity = loadCurrent(cursor, 0, lock);
+    protected ${entity.className} loadCurrentDeep(ResultSet resultSet, boolean lock) throws SQLException {
+        ${entity.className} entity = loadCurrent(resultSet, 0, lock);
         int offset = getAllColumns().length;
 
 <#list entity.toOneRelations as toOne>
-        ${toOne.targetEntity.className} ${toOne.name} = loadCurrentOther(daoSession.get${toOne.targetEntity.classNameDao}(), cursor, offset);
+        ${toOne.targetEntity.className} ${toOne.name} = loadCurrentOther(daoSession.get${toOne.targetEntity.classNameDao}(), resultSet, offset);
 <#if toOne.fkProperties[0].notNull>         if(${toOne.name} != null) {
     </#if>        entity.set${toOne.name?cap_first}(${toOne.name});
 <#if toOne.fkProperties[0].notNull>
@@ -61,7 +61,7 @@ along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
         return entity;    
     }
 
-    public ${entity.className} loadDeep(Long key) {
+    public ${entity.className} loadDeep(Long key) throws SQLException {
         assertSinglePk();
         if (key == null) {
             return null;
@@ -73,35 +73,35 @@ along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
         String sql = builder.toString();
         
         String[] keyArray = new String[] { key.toString() };
-        Cursor cursor = db.rawQuery(sql, keyArray);
+        ResultSet resultSet = JDBCUtils.query(connection, sql, (Object[]) keyArray);
         
         try {
-            boolean available = cursor.moveToFirst();
+            boolean available = resultSet.next();
             if (!available) {
                 return null;
-            } else if (!cursor.isLast()) {
-                throw new IllegalStateException("Expected unique result, but count was " + cursor.getCount());
+            } else if (!resultSet.isLast()) {
+                throw new IllegalStateException("Expected unique result, but count was " + JDBCUtils.getCount(resultSet));
             }
-            return loadCurrentDeep(cursor, true);
+            return loadCurrentDeep(resultSet, true);
         } finally {
-            cursor.close();
+            resultSet.close();
         }
     }
     
     /** Reads all available rows from the given cursor and returns a list of new ImageTO objects. */
-    public List<${entity.className}> loadAllDeepFromCursor(Cursor cursor) {
-        int count = cursor.getCount();
+    public List<${entity.className}> loadAllDeepFromResultSet(ResultSet resultSet) throws SQLException {
+        int count = JDBCUtils.getCount(resultSet);
         List<${entity.className}> list = new ArrayList<${entity.className}>(count);
         
-        if (cursor.moveToFirst()) {
+        if (resultSet.first()) {
             if (identityScope != null) {
                 identityScope.lock();
                 identityScope.reserveRoom(count);
             }
             try {
                 do {
-                    list.add(loadCurrentDeep(cursor, false));
-                } while (cursor.moveToNext());
+                    list.add(loadCurrentDeep(resultSet, false));
+                } while (resultSet.next());
             } finally {
                 if (identityScope != null) {
                     identityScope.unlock();
@@ -111,19 +111,20 @@ along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
         return list;
     }
     
-    protected List<${entity.className}> loadDeepAllAndCloseCursor(Cursor cursor) {
+    protected List<${entity.className}> loadDeepAllAndCloseResultSet(ResultSet resultSet) throws SQLException {
         try {
-            return loadAllDeepFromCursor(cursor);
+            return loadAllDeepFromResultSet(resultSet);
         } finally {
-            cursor.close();
+            resultSet.close();
         }
     }
     
 
     /** A raw-style query where you can pass any WHERE clause and arguments. */
-    public List<${entity.className}> queryDeep(String where, String... selectionArg) {
-        Cursor cursor = db.rawQuery(getSelectDeep() + where, selectionArg);
-        return loadDeepAllAndCloseCursor(cursor);
+    public List<${entity.className}> queryDeep(String where, String... selectionArg) throws SQLException {
+    
+        ResultSet resultSet = JDBCUtils.query( connection, ( getSelectDeep() + where ), (Object[]) selectionArg );
+        return loadDeepAllAndCloseResultSet(resultSet);
     }
  
 </#if>
\ No newline at end of file
diff --git a/DaoGenerator/src-template/dao-master.ftl b/DaoGenerator/src-template/dao-master.ftl
index 4de541cd..1e3a139d 100644
--- a/DaoGenerator/src-template/dao-master.ftl
+++ b/DaoGenerator/src-template/dao-master.ftl
@@ -19,11 +19,9 @@ along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
 -->
 package ${schema.defaultJavaPackageDao};
 
-import android.content.Context;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteDatabase.CursorFactory;
-import android.database.sqlite.SQLiteOpenHelper;
-import android.util.Log;
+import java.sql.Connection;
+import java.sql.SQLException;
+
 import de.greenrobot.dao.AbstractDaoMaster;
 import de.greenrobot.dao.identityscope.IdentityScopeType;
 
@@ -39,63 +37,36 @@ public class DaoMaster extends AbstractDaoMaster {
     public static final int SCHEMA_VERSION = ${schema.version};
 
     /** Creates underlying database table using DAOs. */
-    public static void createAllTables(SQLiteDatabase db, boolean ifNotExists) {
+    public static void createAllTables(Connection connection, boolean ifNotExists) throws SQLException {
 <#list schema.entities as entity>
 <#if !entity.skipTableCreation>
-        ${entity.classNameDao}.createTable(db, ifNotExists);
+        ${entity.classNameDao}.createTable(connection, ifNotExists);
 </#if>
 </#list>
     }
     
     /** Drops underlying database table using DAOs. */
-    public static void dropAllTables(SQLiteDatabase db, boolean ifExists) {
+    public static void dropAllTables(Connection connection, boolean ifExists) throws SQLException {
 <#list schema.entities as entity>
 <#if !entity.skipTableCreation>
-        ${entity.classNameDao}.dropTable(db, ifExists);
+        ${entity.classNameDao}.dropTable(connection, ifExists);
 </#if>
 </#list>
     }
     
-    public static abstract class OpenHelper extends SQLiteOpenHelper {
-
-        public OpenHelper(Context context, String name, CursorFactory factory) {
-            super(context, name, factory, SCHEMA_VERSION);
-        }
-
-        @Override
-        public void onCreate(SQLiteDatabase db) {
-            Log.i("greenDAO", "Creating tables for schema version " + SCHEMA_VERSION);
-            createAllTables(db, false);
-        }
-    }
-    
-    /** WARNING: Drops all table on Upgrade! Use only during development. */
-    public static class DevOpenHelper extends OpenHelper {
-        public DevOpenHelper(Context context, String name, CursorFactory factory) {
-            super(context, name, factory);
-        }
-
-        @Override
-        public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
-            Log.i("greenDAO", "Upgrading schema from version " + oldVersion + " to " + newVersion + " by dropping all tables");
-            dropAllTables(db, true);
-            onCreate(db);
-        }
-    }
-
-    public DaoMaster(SQLiteDatabase db) {
-        super(db, SCHEMA_VERSION);
+    public DaoMaster(Connection connection) {
+        super(connection, SCHEMA_VERSION);
 <#list schema.entities as entity>
         registerDaoClass(${entity.classNameDao}.class);
 </#list>
     }
     
     public DaoSession newSession() {
-        return new DaoSession(db, IdentityScopeType.Session, daoConfigMap);
+        return new DaoSession(connection, IdentityScopeType.Session, daoConfigMap);
     }
     
     public DaoSession newSession(IdentityScopeType type) {
-        return new DaoSession(db, type, daoConfigMap);
+        return new DaoSession(connection, type, daoConfigMap);
     }
     
 }
diff --git a/DaoGenerator/src-template/dao-session.ftl b/DaoGenerator/src-template/dao-session.ftl
index e0201a48..50f10947 100644
--- a/DaoGenerator/src-template/dao-session.ftl
+++ b/DaoGenerator/src-template/dao-session.ftl
@@ -19,8 +19,7 @@ along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
 -->
 package ${schema.defaultJavaPackageDao};
 
-import android.database.sqlite.SQLiteDatabase;
-
+import java.sql.Connection;
 import java.util.Map;
 
 import de.greenrobot.dao.AbstractDao;
@@ -53,9 +52,9 @@ public class DaoSession extends AbstractDaoSession {
     private final ${entity.classNameDao} ${entity.classNameDao?uncap_first};
 </#list>        
 
-    public DaoSession(SQLiteDatabase db, IdentityScopeType type, Map<Class<? extends AbstractDao<?, ?>>, DaoConfig>
+    public DaoSession(Connection connection, IdentityScopeType type, Map<Class<? extends AbstractDao<?, ?>>, DaoConfig>
             daoConfigMap) {
-        super(db);
+        super(connection);
 
 <#list schema.entities as entity>
         ${entity.classNameDao?uncap_first}Config = daoConfigMap.get(${entity.classNameDao}.class).clone();
diff --git a/DaoGenerator/src-template/dao.ftl b/DaoGenerator/src-template/dao.ftl
index 443f74dc..9b58600a 100644
--- a/DaoGenerator/src-template/dao.ftl
+++ b/DaoGenerator/src-template/dao.ftl
@@ -17,8 +17,8 @@ You should have received a copy of the GNU General Public License
 along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
 
 -->
-<#assign toBindType = {"Boolean":"Long", "Byte":"Long", "Short":"Long", "Int":"Long", "Long":"Long", "Float":"Double", "Double":"Double", "String":"String", "ByteArray":"Blob", "Date": "Long" } />
-<#assign toCursorType = {"Boolean":"Short", "Byte":"Short", "Short":"Short", "Int":"Int", "Long":"Long", "Float":"Float", "Double":"Double", "String":"String", "ByteArray":"Blob", "Date": "Long"  } />
+<#assign toBindType = {"Boolean":"Long", "Byte":"Long", "Short":"Long", "Int":"Long", "Long":"Long", "Float":"Double", "Double":"Double", "String":"String", "ByteArray":"Bytes", "Date": "Long" } />
+<#assign toCursorType = {"Boolean":"Short", "Byte":"Short", "Short":"Short", "Int":"Int", "Long":"Long", "Float":"Float", "Double":"Double", "String":"String", "ByteArray":"Bytes", "Date": "Long"  } />
 package ${entity.javaPackageDao};
 
 <#if entity.toOneRelations?has_content || entity.incomingToManyRelations?has_content>
@@ -27,9 +27,14 @@ import java.util.List;
 <#if entity.toOneRelations?has_content>
 import java.util.ArrayList;
 </#if>
-import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteStatement;
+import java.sql.PreparedStatement;
+import java.sql.ResultSet;
+import java.sql.SQLException;
+<#if !entity.skipTableCreation>
+import java.sql.Connection;
+</#if>
+
+import de.greenrobot.platform.java.util.JDBCUtils;
 
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.Property;
@@ -76,8 +81,7 @@ public class ${entity.classNameDao} extends AbstractDao<${entity.className}, ${e
     };
 
 <#if entity.active>
-    private DaoSession daoSession;
-
+	private DaoSession daoSession;
 </#if>
 <#list entity.incomingToManyRelations as toMany>
     private Query<${toMany.targetEntity.className}> ${toMany.sourceEntity.className?uncap_first}_${toMany.name?cap_first}Query;
@@ -96,16 +100,16 @@ public class ${entity.classNameDao} extends AbstractDao<${entity.className}, ${e
 
 <#if !entity.skipTableCreation>
     /** Creates the underlying database table. */
-    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+    public static void createTable(Connection connection, boolean ifNotExists) throws SQLException {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
-        db.execSQL("CREATE TABLE " + constraint + "'${entity.tableName}' (" + //
+        JDBCUtils.execute( connection, "CREATE TABLE " + constraint + "'${entity.tableName}' (" + //
 <#list entity.propertiesColumns as property>
                 "'${property.columnName}' ${property.columnType}<#if property.constraints??> ${property.constraints} </#if><#if property_has_next>," +<#else>);");</#if> // ${property_index}: ${property.propertyName}
 </#list>
 <#if entity.indexes?has_content >
         // Add Indexes
 <#list entity.indexes as index>
-        db.execSQL("CREATE <#if index.unique>UNIQUE </#if>INDEX " + constraint + "${index.name} ON ${entity.tableName}" +
+        JDBCUtils.execute( connection, "CREATE <#if index.unique>UNIQUE </#if>INDEX " + constraint + "${index.name} ON ${entity.tableName}" +
                 " (<#list index.properties 
 as property>${property.columnName}<#if property_has_next>,</#if></#list>);");
 </#list>
@@ -113,21 +117,19 @@ as property>${property.columnName}<#if property_has_next>,</#if></#list>);");
     }
 
     /** Drops the underlying database table. */
-    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
-        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'${entity.tableName}'";
-        db.execSQL(sql);
+    public static void dropTable(Connection connection, boolean ifExists) throws SQLException {
+        JDBCUtils.execute( connection, "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'${entity.tableName}'");
     }
 
 </#if>
     /** @inheritdoc */
     @Override
-    protected void bindValues(SQLiteStatement stmt, ${entity.className} entity) {
-        stmt.clearBindings();
+    protected void bindValues(PreparedStatement statement, ${entity.className} entity) throws SQLException {
 <#list entity.properties as property>
 <#if property.notNull || entity.protobuf>
 <#if entity.protobuf>
         if(entity.has${property.propertyName?cap_first}()) {
-    </#if>        stmt.bind${toBindType[property.propertyType]}(${property_index + 1}, entity.get${property.propertyName?cap_first}()<#if
+    </#if>        statement.set${toBindType[property.propertyType]}(${property_index + 1}, entity.get${property.propertyName?cap_first}()<#if
      property.propertyType == "Boolean"> ? 1l: 0l</#if><#if property.propertyType == "Date">.getTime()</#if>);
 <#if entity.protobuf>
         }
@@ -135,7 +137,7 @@ as property>${property.columnName}<#if property_has_next>,</#if></#list>);");
 <#else> <#-- nullable, non-protobuff -->
         ${property.javaType} ${property.propertyName} = entity.get${property.propertyName?cap_first}();
         if (${property.propertyName} != null) {
-            stmt.bind${toBindType[property.propertyType]}(${property_index + 1}, ${property.propertyName}<#if
+            statement.set${toBindType[property.propertyType]}(${property_index + 1}, ${property.propertyName}<#if
  property.propertyType == "Boolean"> ? 1l: 0l</#if><#if property.propertyType == "Date">.getTime()</#if>);
         }
 </#if>
@@ -168,11 +170,12 @@ as property>${property.columnName}<#if property_has_next>,</#if></#list>);");
 </#if>
     /** @inheritdoc */
     @Override
-    public ${entity.pkType} readKey(Cursor cursor, int offset) {
+    public ${entity.pkType} readKey(ResultSet resultSet, int offset) throws SQLException {
 <#if entity.pkProperty??>
-        return <#if !entity.pkProperty.notNull>cursor.isNull(offset + ${entity.pkProperty.ordinal}) ? null : </#if><#if
+    	int index = 1;
+        return <#if !entity.pkProperty.notNull>JDBCUtils.isNull(resultSet, offset + index) ? null : </#if><#if
             entity.pkProperty.propertyType == "Byte">(byte) </#if><#if
-            entity.pkProperty.propertyType == "Date">new java.util.Date(</#if>cursor.get${toCursorType[entity.pkProperty.propertyType]}(offset + ${entity.pkProperty.ordinal})<#if
+            entity.pkProperty.propertyType == "Date">new java.util.Date(</#if>resultSet.get${toCursorType[entity.pkProperty.propertyType]}(offset + index++)<#if
             entity.pkProperty.propertyType == "Boolean"> != 0</#if><#if
             entity.pkProperty.propertyType == "Date">)</#if>;
 <#else>
@@ -182,13 +185,14 @@ as property>${property.columnName}<#if property_has_next>,</#if></#list>);");
 
     /** @inheritdoc */
     @Override
-    public ${entity.className} readEntity(Cursor cursor, int offset) {
+    public ${entity.className} readEntity(ResultSet resultSet, int offset) throws SQLException {
 <#if entity.protobuf>
         Builder builder = ${entity.className}.newBuilder();
+        int index = 1;
 <#list entity.properties as property>
 <#if !property.notNull>
         if (!cursor.isNull(offset + ${property_index})) {
-    </#if>        builder.set${property.propertyName?cap_first}(cursor.get${toCursorType[property.propertyType]}(offset + ${property_index}));
+    </#if>        builder.set${property.propertyName?cap_first}(resultSet.get${toCursorType[property.propertyType]}(offset + index));
 <#if !property.notNull>
         }
 </#if>        
@@ -198,11 +202,12 @@ as property>${property.columnName}<#if property_has_next>,</#if></#list>);");
 <#--
 ############################## readEntity non-protobuff, constructor ############################## 
 -->
-        ${entity.className} entity = new ${entity.className}( //
+		int index = 1;
+        ${entity.className} entity = new ${entity.className}(
 <#list entity.properties as property>
-            <#if !property.notNull>cursor.isNull(offset + ${property_index}) ? null : </#if><#if
+            <#if !property.notNull>JDBCUtils.isNull(resultSet, offset + index) ? null : </#if><#if
             property.propertyType == "Byte">(byte) </#if><#if
-            property.propertyType == "Date">new java.util.Date(</#if>cursor.get${toCursorType[property.propertyType]}(offset + ${property_index})<#if
+            property.propertyType == "Date">new java.util.Date(</#if>resultSet.get${toCursorType[property.propertyType]}(offset + index++)<#if
             property.propertyType == "Boolean"> != 0</#if><#if
             property.propertyType == "Date">)</#if><#if property_has_next>,</#if> // ${property.propertyName}
 </#list>        
@@ -213,21 +218,22 @@ as property>${property.columnName}<#if property_has_next>,</#if></#list>);");
 ############################## readEntity non-protobuff, setters ############################## 
 -->
         ${entity.className} entity = new ${entity.className}();
-        readEntity(cursor, entity, offset);
+        readEntity(resultSet, entity, offset);
         return entity;
 </#if>
     }
      
     /** @inheritdoc */
     @Override
-    public void readEntity(Cursor cursor, ${entity.className} entity, int offset) {
+    public void readEntity(ResultSet resultSet, ${entity.className} entity, int offset) throws SQLException {
 <#if entity.protobuf>
         throw new UnsupportedOperationException("Protobuf objects cannot be modified");
 <#else> 
+		int index = 1;
 <#list entity.properties as property>
-        entity.set${property.propertyName?cap_first}(<#if !property.notNull>cursor.isNull(offset + ${property_index}) ? null : </#if><#if
+        entity.set${property.propertyName?cap_first}(<#if !property.notNull>JDBCUtils.isNull(resultSet, offset + index) ? null : </#if><#if
             property.propertyType == "Byte">(byte) </#if><#if
-            property.propertyType == "Date">new java.util.Date(</#if>cursor.get${toCursorType[property.propertyType]}(offset + ${property_index})<#if
+            property.propertyType == "Date">new java.util.Date(</#if>resultSet.get${toCursorType[property.propertyType]}(offset + index++)<#if
             property.propertyType == "Boolean"> != 0</#if><#if
             property.propertyType == "Date">)</#if>);
 </#list>
@@ -275,7 +281,7 @@ as property>${property.columnName}<#if property_has_next>,</#if></#list>);");
 <#list entity.incomingToManyRelations as toMany>
     /** Internal query to resolve the "${toMany.name}" to-many relationship of ${toMany.sourceEntity.className}. */
     public List<${toMany.targetEntity.className}> _query${toMany.sourceEntity.className?cap_first}_${toMany.name?cap_first}(<#--
-    --><#list toMany.targetProperties as property>${property.javaType} ${property.propertyName}<#if property_has_next>, </#if></#list>) {
+    --><#list toMany.targetProperties as property>${property.javaType} ${property.propertyName}<#if property_has_next>, </#if></#list>) throws SQLException {
         synchronized (this) {
             if (${toMany.sourceEntity.className?uncap_first}_${toMany.name?cap_first}Query == null) {
                 QueryBuilder<${toMany.targetEntity.className}> queryBuilder = queryBuilder();
diff --git a/DaoGenerator/src-template/entity.ftl b/DaoGenerator/src-template/entity.ftl
index e40c0a18..75eea1f5 100644
--- a/DaoGenerator/src-template/entity.ftl
+++ b/DaoGenerator/src-template/entity.ftl
@@ -22,6 +22,10 @@ along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
 <#assign complexTypes = ["String", "ByteArray", "Date"]/>
 package ${entity.javaPackage};
 
+<#if entity.active>
+import java.sql.SQLException;
+</#if>
+
 <#if entity.toManyRelations?has_content>
 import java.util.List;
 </#if>
@@ -52,6 +56,10 @@ entity.superclass?has_content> extends ${entity.superclass} </#if><#if
 entity.interfacesToImplement?has_content> implements <#list entity.interfacesToImplement
 as ifc>${ifc}<#if ifc_has_next>, </#if></#list></#if> {
 
+<#if entity.interfacesToImplement?has_content>
+	private static final long serialVersionUID = 1L;
+</#if>
+
 <#list entity.properties as property>
 <#if property.notNull && complexTypes?seq_contains(property.propertyType)>
     /** Not-null value. */
@@ -110,7 +118,7 @@ property>${property.javaType} ${property.propertyName}<#if property_has_next>, <
     /** called by internal mechanisms, do not call yourself. */
     public void __setDaoSession(DaoSession daoSession) {
         this.daoSession = daoSession;
-        myDao = daoSession != null ? daoSession.get${entity.classNameDao?cap_first}() : null;
+        myDao = this.daoSession != null ? this.daoSession.get${entity.classNameDao?cap_first}() : null;
     }
 
 </#if>
@@ -137,7 +145,7 @@ property>${property.javaType} ${property.propertyName}<#if property_has_next>, <
 -->
 <#list entity.toOneRelations as toOne>
     /** To-one relationship, resolved on first access. */
-    public ${toOne.targetEntity.className} get${toOne.name?cap_first}() {
+    public ${toOne.targetEntity.className} get${toOne.name?cap_first}() throws SQLException {
 <#if toOne.useFkProperty>
         ${toOne.fkProperties[0].javaType} __key = this.${toOne.fkProperties[0].propertyName};
         if (${toOne.name}__resolvedKey == null || <#--
@@ -198,7 +206,7 @@ property>${property.javaType} ${property.propertyName}<#if property_has_next>, <
 -->
 <#list entity.toManyRelations as toMany>
     /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
-    public List<${toMany.targetEntity.className}> get${toMany.name?cap_first}() {
+    public List<${toMany.targetEntity.className}> get${toMany.name?cap_first}() throws SQLException {
         if (${toMany.name} == null) {
             if (daoSession == null) {
                 throw new DaoException("Entity is detached from DAO context");
@@ -228,7 +236,7 @@ property>${property.javaType} ${property.propertyName}<#if property_has_next>, <
 -->
 <#if entity.active>
     /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
-    public void delete() {
+    public void delete() throws SQLException {
         if (myDao == null) {
             throw new DaoException("Entity is detached from DAO context");
         }    
@@ -236,7 +244,7 @@ property>${property.javaType} ${property.propertyName}<#if property_has_next>, <
     }
 
     /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
-    public void update() {
+    public void update() throws SQLException {
         if (myDao == null) {
             throw new DaoException("Entity is detached from DAO context");
         }    
@@ -244,7 +252,7 @@ property>${property.javaType} ${property.propertyName}<#if property_has_next>, <
     }
 
     /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
-    public void refresh() {
+    public void refresh() throws SQLException {
         if (myDao == null) {
             throw new DaoException("Entity is detached from DAO context");
         }    
diff --git a/DaoGenerator/src/de/greenrobot/daogenerator/Entity.java b/DaoGenerator/src/de/greenrobot/daogenerator/Entity.java
index dc8b1049..41714d61 100644
--- a/DaoGenerator/src/de/greenrobot/daogenerator/Entity.java
+++ b/DaoGenerator/src/de/greenrobot/daogenerator/Entity.java
@@ -230,6 +230,7 @@ protected void addIncomingToMany(ToMany toMany) {
     public ContentProvider addContentProvider() {
         List<Entity> entities = new ArrayList<Entity>();
         ContentProvider contentProvider = new ContentProvider(schema, entities);
+        contentProvider.setClassName( this.getClassName() + "ContentProvider" );
         contentProviders.add(contentProvider);
         return contentProvider;
     }
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/AbcdefEntity.java b/DaoTest/src-gen/de/greenrobot/daotest/AbcdefEntity.java
index e441334f..baa28005 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/AbcdefEntity.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/AbcdefEntity.java
@@ -1,11 +1,13 @@
 package de.greenrobot.daotest;
 
+
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
 /**
  * Entity mapped to table ABCDEF_ENTITY.
  */
 public class AbcdefEntity {
 
+
     private Long id;
     private Integer a;
     private Integer b;
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/AbcdefEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/AbcdefEntityDao.java
index 040cfba1..02823975 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/AbcdefEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/AbcdefEntityDao.java
@@ -1,15 +1,17 @@
 package de.greenrobot.daotest;
 
-import java.sql.Connection;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
+import java.sql.Connection;
+
+import de.greenrobot.platform.java.util.JDBCUtils;
 
-import android.database.sqlite.SQLiteDatabase;
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.Property;
 import de.greenrobot.dao.internal.DaoConfig;
-import de.greenrobot.platform.java.util.JDBCUtils;
+
+import de.greenrobot.daotest.AbcdefEntity;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
@@ -47,8 +49,7 @@ public AbcdefEntityDao(DaoConfig config, DaoSession daoSession) {
         super(config, daoSession);
     }
 
-    /** Creates the underlying database table. 
-     * @throws SQLException */
+    /** Creates the underlying database table. */
     public static void createTable(Connection connection, boolean ifNotExists) throws SQLException {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
         JDBCUtils.execute( connection, "CREATE TABLE " + constraint + "'ABCDEF_ENTITY' (" + //
@@ -67,120 +68,119 @@ public static void createTable(Connection connection, boolean ifNotExists) throw
     }
 
     /** Drops the underlying database table. */
-    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
-        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'ABCDEF_ENTITY'";
-        db.execSQL(sql);
+    public static void dropTable(Connection connection, boolean ifExists) throws SQLException {
+        JDBCUtils.execute( connection, "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'ABCDEF_ENTITY'");
     }
 
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
-    protected void bindValues(PreparedStatement stmt, AbcdefEntity entity) throws SQLException {
-//        stmt.clearBindings();
+    protected void bindValues(PreparedStatement statement, AbcdefEntity entity) throws SQLException {
  
         Long id = entity.getId();
         if (id != null) {
-            stmt.setLong(1, id);
+            statement.setLong(1, id);
         }
  
         Integer a = entity.getA();
         if (a != null) {
-            stmt.setLong(2, a);
+            statement.setLong(2, a);
         }
  
         Integer b = entity.getB();
         if (b != null) {
-            stmt.setLong(3, b);
+            statement.setLong(3, b);
         }
  
         Integer c = entity.getC();
         if (c != null) {
-            stmt.setLong(4, c);
+            statement.setLong(4, c);
         }
  
         Integer d = entity.getD();
         if (d != null) {
-            stmt.setLong(5, d);
+            statement.setLong(5, d);
         }
  
         Integer e = entity.getE();
         if (e != null) {
-            stmt.setLong(6, e);
+            statement.setLong(6, e);
         }
  
         Integer f = entity.getF();
         if (f != null) {
-            stmt.setLong(7, f);
+            statement.setLong(7, f);
         }
  
         Integer g = entity.getG();
         if (g != null) {
-            stmt.setLong(8, g);
+            statement.setLong(8, g);
         }
  
         Integer h = entity.getH();
         if (h != null) {
-            stmt.setLong(9, h);
+            statement.setLong(9, h);
         }
  
         Integer j = entity.getJ();
         if (j != null) {
-            stmt.setLong(10, j);
+            statement.setLong(10, j);
         }
  
         Integer i = entity.getI();
         if (i != null) {
-            stmt.setLong(11, i);
+            statement.setLong(11, i);
         }
  
         Integer k = entity.getK();
         if (k != null) {
-            stmt.setLong(12, k);
+            statement.setLong(12, k);
         }
     }
 
     /** @inheritdoc */
     @Override
     public Long readKey(ResultSet resultSet, int offset) throws SQLException {
-        return resultSet.getObject(offset + 0) == null ? null : resultSet.getLong(offset + 0);
+    	int index = 1;
+        return JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++);
     }    
 
     /** @inheritdoc */
     @Override
     public AbcdefEntity readEntity(ResultSet resultSet, int offset) throws SQLException {
-        AbcdefEntity entity = new AbcdefEntity( //
-            resultSet.getObject(offset + 0) == null ? null : resultSet.getLong(offset + 0), // id
-            resultSet.getObject(offset + 1) == null ? null : resultSet.getInt(offset + 1), // a
-            resultSet.getObject(offset + 2) == null ? null : resultSet.getInt(offset + 2), // b
-            resultSet.getObject(offset + 3) == null ? null : resultSet.getInt(offset + 3), // c
-            resultSet.getObject(offset + 4) == null ? null : resultSet.getInt(offset + 4), // d
-            resultSet.getObject(offset + 5) == null ? null : resultSet.getInt(offset + 5), // e
-            resultSet.getObject(offset + 6) == null ? null : resultSet.getInt(offset + 6), // f
-            resultSet.getObject(offset + 7) == null ? null : resultSet.getInt(offset + 7), // g
-            resultSet.getObject(offset + 8) == null ? null : resultSet.getInt(offset + 8), // h
-            resultSet.getObject(offset + 9) == null ? null : resultSet.getInt(offset + 9), // j
-            resultSet.getObject(offset + 10) == null ? null : resultSet.getInt(offset + 10), // i
-            resultSet.getObject(offset + 11) == null ? null : resultSet.getInt(offset + 11) // k
+		int index = 1;
+        AbcdefEntity entity = new AbcdefEntity(
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++), // id
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getInt(offset + index++), // a
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getInt(offset + index++), // b
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getInt(offset + index++), // c
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getInt(offset + index++), // d
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getInt(offset + index++), // e
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getInt(offset + index++), // f
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getInt(offset + index++), // g
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getInt(offset + index++), // h
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getInt(offset + index++), // j
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getInt(offset + index++), // i
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getInt(offset + index++) // k
         );
         return entity;
     }
      
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
     public void readEntity(ResultSet resultSet, AbcdefEntity entity, int offset) throws SQLException {
-        entity.setId(resultSet.getObject(offset + 0) == null ? null : resultSet.getLong(offset + 0));
-        entity.setA(resultSet.getObject(offset + 1) == null ? null : resultSet.getInt(offset + 1));
-        entity.setB(resultSet.getObject(offset + 2) == null ? null : resultSet.getInt(offset + 2));
-        entity.setC(resultSet.getObject(offset + 3) == null ? null : resultSet.getInt(offset + 3));
-        entity.setD(resultSet.getObject(offset + 4) == null ? null : resultSet.getInt(offset + 4));
-        entity.setE(resultSet.getObject(offset + 5) == null ? null : resultSet.getInt(offset + 5));
-        entity.setF(resultSet.getObject(offset + 6) == null ? null : resultSet.getInt(offset + 6));
-        entity.setG(resultSet.getObject(offset + 7) == null ? null : resultSet.getInt(offset + 7));
-        entity.setH(resultSet.getObject(offset + 8) == null ? null : resultSet.getInt(offset + 8));
-        entity.setJ(resultSet.getObject(offset + 9) == null ? null : resultSet.getInt(offset + 9));
-        entity.setI(resultSet.getObject(offset + 10) == null ? null : resultSet.getInt(offset + 10));
-        entity.setK(resultSet.getObject(offset + 11) == null ? null : resultSet.getInt(offset + 11));
+		int index = 1;
+        entity.setId(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++));
+        entity.setA(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getInt(offset + index++));
+        entity.setB(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getInt(offset + index++));
+        entity.setC(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getInt(offset + index++));
+        entity.setD(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getInt(offset + index++));
+        entity.setE(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getInt(offset + index++));
+        entity.setF(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getInt(offset + index++));
+        entity.setG(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getInt(offset + index++));
+        entity.setH(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getInt(offset + index++));
+        entity.setJ(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getInt(offset + index++));
+        entity.setI(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getInt(offset + index++));
+        entity.setK(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getInt(offset + index++));
      }
     
     /** @inheritdoc */
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/AnActiveEntity.java b/DaoTest/src-gen/de/greenrobot/daotest/AnActiveEntity.java
index 8a2be01e..7bef7d5d 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/AnActiveEntity.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/AnActiveEntity.java
@@ -2,7 +2,7 @@
 
 import java.sql.SQLException;
 
-import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.daotest.DaoSession;
 import de.greenrobot.dao.DaoException;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
@@ -11,6 +11,7 @@
  */
 public class AnActiveEntity {
 
+
     private Long id;
     private String text;
 
@@ -36,7 +37,7 @@ public AnActiveEntity(Long id, String text) {
     /** called by internal mechanisms, do not call yourself. */
     public void __setDaoSession(DaoSession daoSession) {
         this.daoSession = daoSession;
-        myDao = daoSession != null ? daoSession.getAnActiveEntityDao() : null;
+        myDao = this.daoSession != null ? this.daoSession.getAnActiveEntityDao() : null;
     }
 
     public Long getId() {
@@ -55,8 +56,7 @@ public void setText(String text) {
         this.text = text;
     }
 
-    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. 
-     * @throws SQLException */
+    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
     public void delete() throws SQLException {
         if (myDao == null) {
             throw new DaoException("Entity is detached from DAO context");
@@ -64,8 +64,7 @@ public void delete() throws SQLException {
         myDao.delete(this);
     }
 
-    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. 
-     * @throws SQLException */
+    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
     public void update() throws SQLException {
         if (myDao == null) {
             throw new DaoException("Entity is detached from DAO context");
@@ -73,8 +72,7 @@ public void update() throws SQLException {
         myDao.update(this);
     }
 
-    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. 
-     * @throws SQLException */
+    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
     public void refresh() throws SQLException {
         if (myDao == null) {
             throw new DaoException("Entity is detached from DAO context");
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/AnActiveEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/AnActiveEntityDao.java
index f21eab26..3907a45e 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/AnActiveEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/AnActiveEntityDao.java
@@ -1,15 +1,17 @@
 package de.greenrobot.daotest;
 
-import java.sql.Connection;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
+import java.sql.Connection;
+
+import de.greenrobot.platform.java.util.JDBCUtils;
 
-import android.database.sqlite.SQLiteDatabase;
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.Property;
 import de.greenrobot.dao.internal.DaoConfig;
-import de.greenrobot.platform.java.util.JDBCUtils;
+
+import de.greenrobot.daotest.AnActiveEntity;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
@@ -28,8 +30,7 @@
         public final static Property Text = new Property(1, String.class, "text", false, "TEXT");
     };
 
-    private DaoSession daoSession;
-
+	private DaoSession daoSession;
 
     public AnActiveEntityDao(DaoConfig config) {
         super(config);
@@ -40,35 +41,31 @@ public AnActiveEntityDao(DaoConfig config, DaoSession daoSession) {
         this.daoSession = daoSession;
     }
 
-    /** Creates the underlying database table. 
-     * @throws SQLException */
+    /** Creates the underlying database table. */
     public static void createTable(Connection connection, boolean ifNotExists) throws SQLException {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
-        JDBCUtils.execute(connection, "CREATE TABLE " + constraint + "'AN_ACTIVE_ENTITY' (" + //
+        JDBCUtils.execute( connection, "CREATE TABLE " + constraint + "'AN_ACTIVE_ENTITY' (" + //
                 "'_id' INTEGER PRIMARY KEY ," + // 0: id
                 "'TEXT' TEXT);"); // 1: text
     }
 
     /** Drops the underlying database table. */
-    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
-        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'AN_ACTIVE_ENTITY'";
-        db.execSQL(sql);
+    public static void dropTable(Connection connection, boolean ifExists) throws SQLException {
+        JDBCUtils.execute( connection, "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'AN_ACTIVE_ENTITY'");
     }
 
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
-    protected void bindValues(PreparedStatement stmt, AnActiveEntity entity) throws SQLException {
-//        stmt.clearBindings();
+    protected void bindValues(PreparedStatement statement, AnActiveEntity entity) throws SQLException {
  
         Long id = entity.getId();
         if (id != null) {
-            stmt.setLong(1, id);
+            statement.setLong(1, id);
         }
  
         String text = entity.getText();
         if (text != null) {
-            stmt.setString(2, text);
+            statement.setString(2, text);
         }
     }
 
@@ -78,30 +75,30 @@ protected void attachEntity(AnActiveEntity entity) {
         entity.__setDaoSession(daoSession);
     }
 
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
     public Long readKey(ResultSet resultSet, int offset) throws SQLException {
-        return resultSet.getObject(offset + 0) == null ? null : resultSet.getLong(offset + 0);
+    	int index = 1;
+        return JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++);
     }    
 
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
     public AnActiveEntity readEntity(ResultSet resultSet, int offset) throws SQLException {
-        AnActiveEntity entity = new AnActiveEntity( //
-            resultSet.getObject(offset + 0) == null ? null : resultSet.getLong(offset + 0), // id
-            resultSet.getObject(offset + 1) == null ? null : resultSet.getString(offset + 1) // text
+		int index = 1;
+        AnActiveEntity entity = new AnActiveEntity(
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++), // id
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getString(offset + index++) // text
         );
         return entity;
     }
      
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
     public void readEntity(ResultSet resultSet, AnActiveEntity entity, int offset) throws SQLException {
-        entity.setId(resultSet.getObject(offset + 0) == null ? null : resultSet.getLong(offset + 0));
-        entity.setText(resultSet.getObject(offset + 1) == null ? null : resultSet.getString(offset + 1));
+		int index = 1;
+        entity.setId(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++));
+        entity.setText(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getString(offset + index++));
      }
     
     /** @inheritdoc */
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/AutoincrementEntity.java b/DaoTest/src-gen/de/greenrobot/daotest/AutoincrementEntity.java
index cc81483c..fd4ddafd 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/AutoincrementEntity.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/AutoincrementEntity.java
@@ -1,11 +1,13 @@
 package de.greenrobot.daotest;
 
+
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
 /**
  * Entity mapped to table AUTOINCREMENT_ENTITY.
  */
 public class AutoincrementEntity {
 
+
     private Long id;
 
     public AutoincrementEntity() {
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/AutoincrementEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/AutoincrementEntityDao.java
index 50564116..d7b9677c 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/AutoincrementEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/AutoincrementEntityDao.java
@@ -1,15 +1,17 @@
 package de.greenrobot.daotest;
 
-import java.sql.Connection;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
+import java.sql.Connection;
+
+import de.greenrobot.platform.java.util.JDBCUtils;
 
-import android.database.sqlite.SQLiteDatabase;
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.Property;
 import de.greenrobot.dao.internal.DaoConfig;
-import de.greenrobot.platform.java.util.JDBCUtils;
+
+import de.greenrobot.daotest.AutoincrementEntity;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
@@ -36,8 +38,7 @@ public AutoincrementEntityDao(DaoConfig config, DaoSession daoSession) {
         super(config, daoSession);
     }
 
-    /** Creates the underlying database table. 
-     * @throws SQLException */
+    /** Creates the underlying database table. */
     public static void createTable(Connection connection, boolean ifNotExists) throws SQLException {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
         JDBCUtils.execute( connection, "CREATE TABLE " + constraint + "'AUTOINCREMENT_ENTITY' (" + //
@@ -45,45 +46,42 @@ public static void createTable(Connection connection, boolean ifNotExists) throw
     }
 
     /** Drops the underlying database table. */
-    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
-        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'AUTOINCREMENT_ENTITY'";
-        db.execSQL(sql);
+    public static void dropTable(Connection connection, boolean ifExists) throws SQLException {
+        JDBCUtils.execute( connection, "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'AUTOINCREMENT_ENTITY'");
     }
 
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
-    protected void bindValues(PreparedStatement stmt, AutoincrementEntity entity) throws SQLException {
-//        stmt.clearBindings();
+    protected void bindValues(PreparedStatement statement, AutoincrementEntity entity) throws SQLException {
  
         Long id = entity.getId();
         if (id != null) {
-            stmt.setLong(1, id);
+            statement.setLong(1, id);
         }
     }
 
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
     public Long readKey(ResultSet resultSet, int offset) throws SQLException {
-        return resultSet.getObject(offset + 0) == null ? null : resultSet.getLong(offset + 0);
+    	int index = 1;
+        return JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++);
     }    
 
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
     public AutoincrementEntity readEntity(ResultSet resultSet, int offset) throws SQLException {
-        AutoincrementEntity entity = new AutoincrementEntity( //
-            resultSet.getObject(offset + 0) == null ? null : resultSet.getLong(offset + 0) // id
+		int index = 1;
+        AutoincrementEntity entity = new AutoincrementEntity(
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++) // id
         );
         return entity;
     }
      
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
     public void readEntity(ResultSet resultSet, AutoincrementEntity entity, int offset) throws SQLException {
-        entity.setId(resultSet.getObject(offset + 0) == null ? null : resultSet.getLong(offset + 0));
+		int index = 1;
+        entity.setId(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++));
      }
     
     /** @inheritdoc */
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/DaoMaster.java b/DaoTest/src-gen/de/greenrobot/daotest/DaoMaster.java
index bb77f261..8313d9e3 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/DaoMaster.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/DaoMaster.java
@@ -3,14 +3,24 @@
 import java.sql.Connection;
 import java.sql.SQLException;
 
-import android.content.Context;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteDatabase.CursorFactory;
-import android.database.sqlite.SQLiteOpenHelper;
-import android.util.Log;
 import de.greenrobot.dao.AbstractDaoMaster;
 import de.greenrobot.dao.identityscope.IdentityScopeType;
-import de.greenrobot.platform.java.util.JDBCUtils;
+
+import de.greenrobot.daotest.SimpleEntityDao;
+import de.greenrobot.daotest.SimpleEntityNotNullDao;
+import de.greenrobot.daotest.TestEntityDao;
+import de.greenrobot.daotest.RelationEntityDao;
+import de.greenrobot.daotest.DateEntityDao;
+import de.greenrobot.daotest.SpecialNamesEntityDao;
+import de.greenrobot.daotest.AbcdefEntityDao;
+import de.greenrobot.daotest.ToManyTargetEntityDao;
+import de.greenrobot.daotest.ToManyEntityDao;
+import de.greenrobot.daotest.TreeEntityDao;
+import de.greenrobot.daotest.AnActiveEntityDao;
+import de.greenrobot.daotest.ExtendsImplementsEntityDao;
+import de.greenrobot.daotest.StringKeyValueEntityDao;
+import de.greenrobot.daotest.AutoincrementEntityDao;
+import de.greenrobot.daotest.SqliteMasterDao;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
@@ -19,8 +29,7 @@
 public class DaoMaster extends AbstractDaoMaster {
     public static final int SCHEMA_VERSION = 1;
 
-    /** Creates underlying database table using DAOs. 
-     * @throws SQLException */
+    /** Creates underlying database table using DAOs. */
     public static void createAllTables(Connection connection, boolean ifNotExists) throws SQLException {
         SimpleEntityDao.createTable(connection, ifNotExists);
         SimpleEntityNotNullDao.createTable(connection, ifNotExists);
@@ -39,59 +48,23 @@ public static void createAllTables(Connection connection, boolean ifNotExists) t
     }
     
     /** Drops underlying database table using DAOs. */
-    public static void dropAllTables(SQLiteDatabase db, boolean ifExists) {
-        SimpleEntityDao.dropTable(db, ifExists);
-        SimpleEntityNotNullDao.dropTable(db, ifExists);
-        TestEntityDao.dropTable(db, ifExists);
-        RelationEntityDao.dropTable(db, ifExists);
-        DateEntityDao.dropTable(db, ifExists);
-        SpecialNamesEntityDao.dropTable(db, ifExists);
-        AbcdefEntityDao.dropTable(db, ifExists);
-        ToManyTargetEntityDao.dropTable(db, ifExists);
-        ToManyEntityDao.dropTable(db, ifExists);
-        TreeEntityDao.dropTable(db, ifExists);
-        AnActiveEntityDao.dropTable(db, ifExists);
-        ExtendsImplementsEntityDao.dropTable(db, ifExists);
-        StringKeyValueEntityDao.dropTable(db, ifExists);
-        AutoincrementEntityDao.dropTable(db, ifExists);
-    }
-    
-    public static abstract class OpenHelper extends SQLiteOpenHelper {
-
-        public OpenHelper(Context context, String name, CursorFactory factory) {
-            super(context, name, factory, SCHEMA_VERSION);
-        }
-
-        @Override
-        public void onCreate(SQLiteDatabase db) {
-            Log.i("greenDAO", "Creating tables for schema version " + SCHEMA_VERSION);
-			try
-			{
-				String dbPath = db.getPath();
-				Connection connection = JDBCUtils.connect( dbPath );
-				createAllTables(connection, false);
-			}
-			catch ( SQLException e )
-			{
-				e.printStackTrace();
-			}
-        }
+    public static void dropAllTables(Connection connection, boolean ifExists) throws SQLException {
+        SimpleEntityDao.dropTable(connection, ifExists);
+        SimpleEntityNotNullDao.dropTable(connection, ifExists);
+        TestEntityDao.dropTable(connection, ifExists);
+        RelationEntityDao.dropTable(connection, ifExists);
+        DateEntityDao.dropTable(connection, ifExists);
+        SpecialNamesEntityDao.dropTable(connection, ifExists);
+        AbcdefEntityDao.dropTable(connection, ifExists);
+        ToManyTargetEntityDao.dropTable(connection, ifExists);
+        ToManyEntityDao.dropTable(connection, ifExists);
+        TreeEntityDao.dropTable(connection, ifExists);
+        AnActiveEntityDao.dropTable(connection, ifExists);
+        ExtendsImplementsEntityDao.dropTable(connection, ifExists);
+        StringKeyValueEntityDao.dropTable(connection, ifExists);
+        AutoincrementEntityDao.dropTable(connection, ifExists);
     }
     
-    /** WARNING: Drops all table on Upgrade! Use only during development. */
-    public static class DevOpenHelper extends OpenHelper {
-        public DevOpenHelper(Context context, String name, CursorFactory factory) {
-            super(context, name, factory);
-        }
-
-        @Override
-        public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
-            Log.i("greenDAO", "Upgrading schema from version " + oldVersion + " to " + newVersion + " by dropping all tables");
-            dropAllTables(db, true);
-            onCreate(db);
-        }
-    }
-
     public DaoMaster(Connection connection) {
         super(connection, SCHEMA_VERSION);
         registerDaoClass(SimpleEntityDao.class);
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/DaoSession.java b/DaoTest/src-gen/de/greenrobot/daotest/DaoSession.java
index 77ad42c7..8273b0fc 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/DaoSession.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/DaoSession.java
@@ -8,6 +8,38 @@
 import de.greenrobot.dao.identityscope.IdentityScopeType;
 import de.greenrobot.dao.internal.DaoConfig;
 
+import de.greenrobot.daotest.SimpleEntity;
+import de.greenrobot.daotest.SimpleEntityNotNull;
+import de.greenrobot.daotest.TestEntity;
+import de.greenrobot.daotest.RelationEntity;
+import de.greenrobot.daotest.DateEntity;
+import de.greenrobot.daotest.SpecialNamesEntity;
+import de.greenrobot.daotest.AbcdefEntity;
+import de.greenrobot.daotest.ToManyTargetEntity;
+import de.greenrobot.daotest.ToManyEntity;
+import de.greenrobot.daotest.TreeEntity;
+import de.greenrobot.daotest.AnActiveEntity;
+import de.greenrobot.daotest.ExtendsImplementsEntity;
+import de.greenrobot.daotest.StringKeyValueEntity;
+import de.greenrobot.daotest.AutoincrementEntity;
+import de.greenrobot.daotest.SqliteMaster;
+
+import de.greenrobot.daotest.SimpleEntityDao;
+import de.greenrobot.daotest.SimpleEntityNotNullDao;
+import de.greenrobot.daotest.TestEntityDao;
+import de.greenrobot.daotest.RelationEntityDao;
+import de.greenrobot.daotest.DateEntityDao;
+import de.greenrobot.daotest.SpecialNamesEntityDao;
+import de.greenrobot.daotest.AbcdefEntityDao;
+import de.greenrobot.daotest.ToManyTargetEntityDao;
+import de.greenrobot.daotest.ToManyEntityDao;
+import de.greenrobot.daotest.TreeEntityDao;
+import de.greenrobot.daotest.AnActiveEntityDao;
+import de.greenrobot.daotest.ExtendsImplementsEntityDao;
+import de.greenrobot.daotest.StringKeyValueEntityDao;
+import de.greenrobot.daotest.AutoincrementEntityDao;
+import de.greenrobot.daotest.SqliteMasterDao;
+
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 
 /**
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/DateEntity.java b/DaoTest/src-gen/de/greenrobot/daotest/DateEntity.java
index b01bd724..0adf3be0 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/DateEntity.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/DateEntity.java
@@ -1,11 +1,13 @@
 package de.greenrobot.daotest;
 
+
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
 /**
  * Entity mapped to table DATE_ENTITY.
  */
 public class DateEntity {
 
+
     private Long id;
     private java.util.Date date;
     /** Not-null value. */
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/DateEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/DateEntityDao.java
index 4c740a0c..9e7fd277 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/DateEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/DateEntityDao.java
@@ -1,15 +1,17 @@
 package de.greenrobot.daotest;
 
-import java.sql.Connection;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
+import java.sql.Connection;
+
+import de.greenrobot.platform.java.util.JDBCUtils;
 
-import android.database.sqlite.SQLiteDatabase;
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.Property;
 import de.greenrobot.dao.internal.DaoConfig;
-import de.greenrobot.platform.java.util.JDBCUtils;
+
+import de.greenrobot.daotest.DateEntity;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
@@ -38,66 +40,62 @@ public DateEntityDao(DaoConfig config, DaoSession daoSession) {
         super(config, daoSession);
     }
 
-    /** Creates the underlying database table. 
-     * @throws SQLException */
+    /** Creates the underlying database table. */
     public static void createTable(Connection connection, boolean ifNotExists) throws SQLException {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
-        JDBCUtils.execute(connection, "CREATE TABLE " + constraint + "'DATE_ENTITY' (" + //
+        JDBCUtils.execute( connection, "CREATE TABLE " + constraint + "'DATE_ENTITY' (" + //
                 "'_id' INTEGER PRIMARY KEY ," + // 0: id
                 "'DATE' INTEGER," + // 1: date
                 "'DATE_NOT_NULL' INTEGER NOT NULL );"); // 2: dateNotNull
     }
 
     /** Drops the underlying database table. */
-    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
-        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'DATE_ENTITY'";
-        db.execSQL(sql);
+    public static void dropTable(Connection connection, boolean ifExists) throws SQLException {
+        JDBCUtils.execute( connection, "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'DATE_ENTITY'");
     }
 
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
-    protected void bindValues(PreparedStatement stmt, DateEntity entity) throws SQLException {
-//        stmt.clearBindings();
+    protected void bindValues(PreparedStatement statement, DateEntity entity) throws SQLException {
  
         Long id = entity.getId();
         if (id != null) {
-            stmt.setLong(1, id);
+            statement.setLong(1, id);
         }
  
         java.util.Date date = entity.getDate();
         if (date != null) {
-            stmt.setLong(2, date.getTime());
+            statement.setLong(2, date.getTime());
         }
-        stmt.setLong(3, entity.getDateNotNull().getTime());
+        statement.setLong(3, entity.getDateNotNull().getTime());
     }
 
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
     public Long readKey(ResultSet resultSet, int offset) throws SQLException {
-        return JDBCUtils.isNull( resultSet, offset + 0) ? null : resultSet.getLong(offset + 0);
+    	int index = 1;
+        return JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++);
     }    
 
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
     public DateEntity readEntity(ResultSet resultSet, int offset) throws SQLException {
-        DateEntity entity = new DateEntity( //
-            JDBCUtils.isNull( resultSet, offset + 0) ? null : resultSet.getLong(offset + 0), // id
-            JDBCUtils.isNull( resultSet, offset + 1) ? null : new java.util.Date(resultSet.getLong(offset + 1)), // date
-            new java.util.Date(resultSet.getLong(offset + 2)) // dateNotNull
+		int index = 1;
+        DateEntity entity = new DateEntity(
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++), // id
+            JDBCUtils.isNull(resultSet, offset + index) ? null : new java.util.Date(resultSet.getLong(offset + index++)), // date
+            new java.util.Date(resultSet.getLong(offset + index++)) // dateNotNull
         );
         return entity;
     }
      
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
     public void readEntity(ResultSet resultSet, DateEntity entity, int offset) throws SQLException {
-        entity.setId(JDBCUtils.isNull( resultSet, offset + 0) ? null : resultSet.getLong(offset + 0));
-        entity.setDate(JDBCUtils.isNull( resultSet, offset + 1) ? null : new java.util.Date(resultSet.getLong(offset + 1)));
-        entity.setDateNotNull(new java.util.Date(resultSet.getLong(offset + 2)));
+		int index = 1;
+        entity.setId(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++));
+        entity.setDate(JDBCUtils.isNull(resultSet, offset + index) ? null : new java.util.Date(resultSet.getLong(offset + index++)));
+        entity.setDateNotNull(new java.util.Date(resultSet.getLong(offset + index++)));
      }
     
     /** @inheritdoc */
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/ExtendsImplementsEntity.java b/DaoTest/src-gen/de/greenrobot/daotest/ExtendsImplementsEntity.java
index 72c57ee8..bac2555f 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/ExtendsImplementsEntity.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/ExtendsImplementsEntity.java
@@ -1,11 +1,14 @@
 package de.greenrobot.daotest;
 
+
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
 /**
  * Entity mapped to table EXTENDS_IMPLEMENTS_ENTITY.
  */
 public class ExtendsImplementsEntity extends TestSuperclass  implements TestInterface, java.io.Serializable {
 
+	private static final long serialVersionUID = 1L;
+
     private Long id;
     private String text;
 
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/ExtendsImplementsEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/ExtendsImplementsEntityDao.java
index d0eb5998..6b1a4428 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/ExtendsImplementsEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/ExtendsImplementsEntityDao.java
@@ -1,15 +1,17 @@
 package de.greenrobot.daotest;
 
-import java.sql.Connection;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
+import java.sql.Connection;
+
+import de.greenrobot.platform.java.util.JDBCUtils;
 
-import android.database.sqlite.SQLiteDatabase;
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.Property;
 import de.greenrobot.dao.internal.DaoConfig;
-import de.greenrobot.platform.java.util.JDBCUtils;
+
+import de.greenrobot.daotest.ExtendsImplementsEntity;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
@@ -37,62 +39,58 @@ public ExtendsImplementsEntityDao(DaoConfig config, DaoSession daoSession) {
         super(config, daoSession);
     }
 
-    /** Creates the underlying database table. 
-     * @throws SQLException */
+    /** Creates the underlying database table. */
     public static void createTable(Connection connection, boolean ifNotExists) throws SQLException {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
-        JDBCUtils.execute(connection, "CREATE TABLE " + constraint + "'EXTENDS_IMPLEMENTS_ENTITY' (" + //
+        JDBCUtils.execute( connection, "CREATE TABLE " + constraint + "'EXTENDS_IMPLEMENTS_ENTITY' (" + //
                 "'_id' INTEGER PRIMARY KEY ," + // 0: id
                 "'TEXT' TEXT);"); // 1: text
     }
 
     /** Drops the underlying database table. */
-    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
-        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'EXTENDS_IMPLEMENTS_ENTITY'";
-        db.execSQL(sql);
+    public static void dropTable(Connection connection, boolean ifExists) throws SQLException {
+        JDBCUtils.execute( connection, "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'EXTENDS_IMPLEMENTS_ENTITY'");
     }
 
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
-    protected void bindValues(PreparedStatement stmt, ExtendsImplementsEntity entity) throws SQLException {
-//        stmt.clearBindings();
+    protected void bindValues(PreparedStatement statement, ExtendsImplementsEntity entity) throws SQLException {
  
         Long id = entity.getId();
         if (id != null) {
-            stmt.setLong(1, id);
+            statement.setLong(1, id);
         }
  
         String text = entity.getText();
         if (text != null) {
-            stmt.setString(2, text);
+            statement.setString(2, text);
         }
     }
 
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
     public Long readKey(ResultSet resultSet, int offset) throws SQLException {
-        return JDBCUtils.isNull(resultSet, offset + 0) ? null : resultSet.getLong(offset + 0);
+    	int index = 1;
+        return JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++);
     }    
 
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
     public ExtendsImplementsEntity readEntity(ResultSet resultSet, int offset) throws SQLException {
-        ExtendsImplementsEntity entity = new ExtendsImplementsEntity( //
-            JDBCUtils.isNull(resultSet, offset + 0) ? null : resultSet.getLong(offset + 0), // id
-            JDBCUtils.isNull(resultSet, offset + 1) ? null : resultSet.getString(offset + 1) // text
+		int index = 1;
+        ExtendsImplementsEntity entity = new ExtendsImplementsEntity(
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++), // id
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getString(offset + index++) // text
         );
         return entity;
     }
      
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
     public void readEntity(ResultSet resultSet, ExtendsImplementsEntity entity, int offset) throws SQLException {
-        entity.setId(JDBCUtils.isNull(resultSet, offset + 0) ? null : resultSet.getLong(offset + 0));
-        entity.setText(JDBCUtils.isNull(resultSet, offset + 1) ? null : resultSet.getString(offset + 1));
+		int index = 1;
+        entity.setId(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++));
+        entity.setText(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getString(offset + index++));
      }
     
     /** @inheritdoc */
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/RelationEntity.java b/DaoTest/src-gen/de/greenrobot/daotest/RelationEntity.java
index 7ab954f1..3150cf47 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/RelationEntity.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/RelationEntity.java
@@ -2,7 +2,7 @@
 
 import java.sql.SQLException;
 
-import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.daotest.DaoSession;
 import de.greenrobot.dao.DaoException;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
@@ -11,6 +11,7 @@
  */
 public class RelationEntity {
 
+
     private Long id;
     private Long parentId;
     private Long testId;
@@ -54,7 +55,7 @@ public RelationEntity(Long id, Long parentId, Long testId, long testIdNotNull, S
     /** called by internal mechanisms, do not call yourself. */
     public void __setDaoSession(DaoSession daoSession) {
         this.daoSession = daoSession;
-        myDao = daoSession != null ? daoSession.getRelationEntityDao() : null;
+        myDao = this.daoSession != null ? this.daoSession.getRelationEntityDao() : null;
     }
 
     public Long getId() {
@@ -97,8 +98,7 @@ public void setSimpleString(String simpleString) {
         this.simpleString = simpleString;
     }
 
-    /** To-one relationship, resolved on first access. 
-     * @throws SQLException */
+    /** To-one relationship, resolved on first access. */
     public RelationEntity getParent() throws SQLException {
         Long __key = this.parentId;
         if (parent__resolvedKey == null || !parent__resolvedKey.equals(__key)) {
@@ -123,8 +123,7 @@ public void setParent(RelationEntity parent) {
         }
     }
 
-    /** To-one relationship, resolved on first access. 
-     * @throws SQLException */
+    /** To-one relationship, resolved on first access. */
     public TestEntity getTestEntity() throws SQLException {
         Long __key = this.testId;
         if (testEntity__resolvedKey == null || !testEntity__resolvedKey.equals(__key)) {
@@ -149,8 +148,7 @@ public void setTestEntity(TestEntity testEntity) {
         }
     }
 
-    /** To-one relationship, resolved on first access. 
-     * @throws SQLException */
+    /** To-one relationship, resolved on first access. */
     public TestEntity getTestNotNull() throws SQLException {
         long __key = this.testIdNotNull;
         if (testNotNull__resolvedKey == null || !testNotNull__resolvedKey.equals(__key)) {
@@ -178,8 +176,7 @@ public void setTestNotNull(TestEntity testNotNull) {
         }
     }
 
-    /** To-one relationship, resolved on first access. 
-     * @throws SQLException */
+    /** To-one relationship, resolved on first access. */
     public TestEntity getTestWithoutProperty() throws SQLException {
         if (testWithoutProperty != null || !testWithoutProperty__refreshed) {
             if (daoSession == null) {
@@ -204,8 +201,7 @@ public void setTestWithoutProperty(TestEntity testWithoutProperty) {
         }
     }
 
-    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. 
-     * @throws SQLException */
+    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
     public void delete() throws SQLException {
         if (myDao == null) {
             throw new DaoException("Entity is detached from DAO context");
@@ -213,8 +209,7 @@ public void delete() throws SQLException {
         myDao.delete(this);
     }
 
-    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. 
-     * @throws SQLException */
+    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
     public void update() throws SQLException {
         if (myDao == null) {
             throw new DaoException("Entity is detached from DAO context");
@@ -222,8 +217,7 @@ public void update() throws SQLException {
         myDao.update(this);
     }
 
-    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. 
-     * @throws SQLException */
+    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
     public void refresh() throws SQLException {
         if (myDao == null) {
             throw new DaoException("Entity is detached from DAO context");
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/RelationEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/RelationEntityDao.java
index 752cf633..c4fce469 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/RelationEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/RelationEntityDao.java
@@ -1,18 +1,20 @@
 package de.greenrobot.daotest;
 
-import java.sql.Connection;
+import java.util.List;
+import java.util.ArrayList;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
-import java.util.ArrayList;
-import java.util.List;
+import java.sql.Connection;
+
+import de.greenrobot.platform.java.util.JDBCUtils;
 
-import android.database.sqlite.SQLiteDatabase;
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.Property;
-import de.greenrobot.dao.internal.DaoConfig;
 import de.greenrobot.dao.internal.SqlUtils;
-import de.greenrobot.platform.java.util.JDBCUtils;
+import de.greenrobot.dao.internal.DaoConfig;
+
+import de.greenrobot.daotest.RelationEntity;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
@@ -35,8 +37,7 @@
         public final static Property TestWithoutProperty = new Property(5, Long.class, "testWithoutProperty", false, "WITHOUT_PROPERTY_TEST_ID");
     };
 
-    private DaoSession daoSession;
-
+	private DaoSession daoSession;
 
     public RelationEntityDao(DaoConfig config) {
         super(config);
@@ -47,11 +48,10 @@ public RelationEntityDao(DaoConfig config, DaoSession daoSession) {
         this.daoSession = daoSession;
     }
 
-    /** Creates the underlying database table. 
-     * @throws SQLException */
+    /** Creates the underlying database table. */
     public static void createTable(Connection connection, boolean ifNotExists) throws SQLException {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
-        JDBCUtils.execute(connection, "CREATE TABLE " + constraint + "'RELATION_ENTITY' (" + //
+        JDBCUtils.execute( connection, "CREATE TABLE " + constraint + "'RELATION_ENTITY' (" + //
                 "'_id' INTEGER PRIMARY KEY ," + // 0: id
                 "'PARENT_ID' INTEGER," + // 1: parentId
                 "'TEST_ID' INTEGER," + // 2: testId
@@ -61,36 +61,33 @@ public static void createTable(Connection connection, boolean ifNotExists) throw
     }
 
     /** Drops the underlying database table. */
-    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
-        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'RELATION_ENTITY'";
-        db.execSQL(sql);
+    public static void dropTable(Connection connection, boolean ifExists) throws SQLException {
+        JDBCUtils.execute( connection, "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'RELATION_ENTITY'");
     }
 
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
-    protected void bindValues(PreparedStatement stmt, RelationEntity entity) throws SQLException {
-//        stmt.clearBindings();
+    protected void bindValues(PreparedStatement statement, RelationEntity entity) throws SQLException {
  
         Long id = entity.getId();
         if (id != null) {
-            stmt.setLong(1, id);
+            statement.setLong(1, id);
         }
  
         Long parentId = entity.getParentId();
         if (parentId != null) {
-            stmt.setLong(2, parentId);
+            statement.setLong(2, parentId);
         }
  
         Long testId = entity.getTestId();
         if (testId != null) {
-            stmt.setLong(3, testId);
+            statement.setLong(3, testId);
         }
-        stmt.setLong(4, entity.getTestIdNotNull());
+        statement.setLong(4, entity.getTestIdNotNull());
  
         String simpleString = entity.getSimpleString();
         if (simpleString != null) {
-            stmt.setString(5, simpleString);
+            statement.setString(5, simpleString);
         }
     }
 
@@ -100,36 +97,36 @@ protected void attachEntity(RelationEntity entity) {
         entity.__setDaoSession(daoSession);
     }
 
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
     public Long readKey(ResultSet resultSet, int offset) throws SQLException {
-        return JDBCUtils.isNull(resultSet, offset + 0) ? null : resultSet.getLong(offset + 0);
+    	int index = 1;
+        return JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++);
     }    
 
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
     public RelationEntity readEntity(ResultSet resultSet, int offset) throws SQLException {
-        RelationEntity entity = new RelationEntity( //
-            JDBCUtils.isNull(resultSet, offset + 0) ? null : resultSet.getLong(offset + 0), // id
-            JDBCUtils.isNull(resultSet, offset + 1) ? null : resultSet.getLong(offset + 1), // parentId
-            JDBCUtils.isNull(resultSet, offset + 2) ? null : resultSet.getLong(offset + 2), // testId
-            resultSet.getLong(offset + 3), // testIdNotNull
-            JDBCUtils.isNull(resultSet, offset + 4) ? null : resultSet.getString(offset + 4) // simpleString
+		int index = 1;
+        RelationEntity entity = new RelationEntity(
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++), // id
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++), // parentId
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++), // testId
+            resultSet.getLong(offset + index++), // testIdNotNull
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getString(offset + index++) // simpleString
         );
         return entity;
     }
      
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
     public void readEntity(ResultSet resultSet, RelationEntity entity, int offset) throws SQLException {
-        entity.setId(JDBCUtils.isNull( resultSet, offset + 0) ? null : resultSet.getLong(offset + 0));
-        entity.setParentId(JDBCUtils.isNull( resultSet, offset + 1) ? null : resultSet.getLong(offset + 1));
-        entity.setTestId(JDBCUtils.isNull( resultSet, offset + 2) ? null : resultSet.getLong(offset + 2));
-        entity.setTestIdNotNull(resultSet.getLong(offset + 3));
-        entity.setSimpleString(JDBCUtils.isNull( resultSet, offset + 4) ? null : resultSet.getString(offset + 4));
+		int index = 1;
+        entity.setId(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++));
+        entity.setParentId(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++));
+        entity.setTestId(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++));
+        entity.setTestIdNotNull(resultSet.getLong(offset + index++));
+        entity.setSimpleString(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getString(offset + index++));
      }
     
     /** @inheritdoc */
@@ -155,126 +152,119 @@ protected boolean isEntityUpdateable() {
         return true;
     }
     
-    private String selectDeep;
-
-    protected String getSelectDeep() {
-        if (selectDeep == null) {
-            StringBuilder builder = new StringBuilder("SELECT ");
-            SqlUtils.appendColumns(builder, "T", getAllColumns());
-            builder.append(',');
-            SqlUtils.appendColumns(builder, "T0", daoSession.getRelationEntityDao().getAllColumns());
-            builder.append(',');
-            SqlUtils.appendColumns(builder, "T1", daoSession.getTestEntityDao().getAllColumns());
-            builder.append(',');
-            SqlUtils.appendColumns(builder, "T2", daoSession.getTestEntityDao().getAllColumns());
-            builder.append(',');
-            SqlUtils.appendColumns(builder, "T3", daoSession.getTestEntityDao().getAllColumns());
-            builder.append(" FROM RELATION_ENTITY T");
-            builder.append(" LEFT JOIN RELATION_ENTITY T0 ON T.'PARENT_ID'=T0.'_id'");
-            builder.append(" LEFT JOIN TEST_ENTITY T1 ON T.'TEST_ID'=T1.'_id'");
-            builder.append(" LEFT JOIN TEST_ENTITY T2 ON T.'TEST_ID_NOT_NULL'=T2.'_id'");
-            builder.append(" LEFT JOIN TEST_ENTITY T3 ON T.'WITHOUT_PROPERTY_TEST_ID'=T3.'_id'");
-            builder.append(' ');
-            selectDeep = builder.toString();
-        }
-        return selectDeep;
-    }
-    
-    protected RelationEntity loadCurrentDeep(ResultSet resultSet, boolean lock) throws SQLException {
-        RelationEntity entity = loadCurrent(resultSet, 0, lock);
-        int offset = getAllColumns().length;
-
-        RelationEntity parent = loadCurrentOther(daoSession.getRelationEntityDao(), resultSet, offset);
-        entity.setParent(parent);
-        offset += daoSession.getRelationEntityDao().getAllColumns().length;
-
-        TestEntity testEntity = loadCurrentOther(daoSession.getTestEntityDao(), resultSet, offset);
-        entity.setTestEntity(testEntity);
-        offset += daoSession.getTestEntityDao().getAllColumns().length;
-
-        TestEntity testNotNull = loadCurrentOther(daoSession.getTestEntityDao(), resultSet, offset);
-         if(testNotNull != null) {
-            entity.setTestNotNull(testNotNull);
-        }
-        offset += daoSession.getTestEntityDao().getAllColumns().length;
-
-        TestEntity testWithoutProperty = loadCurrentOther(daoSession.getTestEntityDao(), resultSet, offset);
-        entity.setTestWithoutProperty(testWithoutProperty);
-
-        return entity;    
-    }
-
-    public RelationEntity loadDeep(Long key) throws SQLException {
-        assertSinglePk();
-        if (key == null) {
-            return null;
-        }
-
-        StringBuilder builder = new StringBuilder(getSelectDeep());
-        builder.append("WHERE ");
-        SqlUtils.appendColumnsEqValue(builder, "T", getPkColumns());
-        String sql = builder.toString();
-        
-        String[] keyArray = new String[] { key.toString() };
-        ResultSet resultSet = JDBCUtils.query( connection, sql, (Object[]) keyArray );
-        
-        try {
-            boolean available = resultSet.first();
-            if (!available) {
-                return null;
-            } else if (!resultSet.isLast()) {
-                throw new IllegalStateException("Expected unique result, but count was " + resultSet.getFetchSize());
-            }
-            return loadCurrentDeep(resultSet, true);
-        } finally {
-            resultSet.close();
-        }
-    }
-    
-    /** Reads all available rows from the given cursor and returns a list of new ImageTO objects. 
-     * @throws SQLException */
-    public List<RelationEntity> loadAllDeepFromCursor(ResultSet resultSet) throws SQLException {
-        int count = resultSet.getFetchSize();
-        List<RelationEntity> list = new ArrayList<RelationEntity>(count);
-        
-        if (resultSet.first()) {
-            if (identityScope != null) {
-                identityScope.lock();
-                identityScope.reserveRoom(count);
-            }
-            try {
-                do {
-                    list.add(loadCurrentDeep(resultSet, false));
-                } while (resultSet.next());
-            } finally {
-                if (identityScope != null) {
-                    identityScope.unlock();
-                }
-            }
-        }
-        return list;
-    }
-    
-    protected List<RelationEntity> loadDeepAllAndCloseCursor(ResultSet resultSet) throws SQLException {
-        try {
-            return loadAllDeepFromCursor(resultSet);
-        } finally {
-            resultSet.close();
-        }
-    }
-    
-
-    /** A raw-style query where you can pass any WHERE clause and arguments. 
-     * @throws SQLException */
-    public List<RelationEntity> queryDeep(String where, String... selectionArg) throws SQLException {
-    	//@formatter:off
-    	ResultSet resultSet = JDBCUtils.query( 
-    			connection, 
-    			getSelectDeep() + where, 
-    			(Object[]) selectionArg
-    	);
-    	//@formatter:on
-        return loadDeepAllAndCloseCursor(resultSet);
-    }
- 
+    private String selectDeep;
+
+    protected String getSelectDeep() {
+        if (selectDeep == null) {
+            StringBuilder builder = new StringBuilder("SELECT ");
+            SqlUtils.appendColumns(builder, "T", getAllColumns());
+            builder.append(',');
+            SqlUtils.appendColumns(builder, "T0", daoSession.getRelationEntityDao().getAllColumns());
+            builder.append(',');
+            SqlUtils.appendColumns(builder, "T1", daoSession.getTestEntityDao().getAllColumns());
+            builder.append(',');
+            SqlUtils.appendColumns(builder, "T2", daoSession.getTestEntityDao().getAllColumns());
+            builder.append(',');
+            SqlUtils.appendColumns(builder, "T3", daoSession.getTestEntityDao().getAllColumns());
+            builder.append(" FROM RELATION_ENTITY T");
+            builder.append(" LEFT JOIN RELATION_ENTITY T0 ON T.'PARENT_ID'=T0.'_id'");
+            builder.append(" LEFT JOIN TEST_ENTITY T1 ON T.'TEST_ID'=T1.'_id'");
+            builder.append(" LEFT JOIN TEST_ENTITY T2 ON T.'TEST_ID_NOT_NULL'=T2.'_id'");
+            builder.append(" LEFT JOIN TEST_ENTITY T3 ON T.'WITHOUT_PROPERTY_TEST_ID'=T3.'_id'");
+            builder.append(' ');
+            selectDeep = builder.toString();
+        }
+        return selectDeep;
+    }
+    
+    protected RelationEntity loadCurrentDeep(ResultSet resultSet, boolean lock) throws SQLException {
+        RelationEntity entity = loadCurrent(resultSet, 0, lock);
+        int offset = getAllColumns().length;
+
+        RelationEntity parent = loadCurrentOther(daoSession.getRelationEntityDao(), resultSet, offset);
+        entity.setParent(parent);
+        offset += daoSession.getRelationEntityDao().getAllColumns().length;
+
+        TestEntity testEntity = loadCurrentOther(daoSession.getTestEntityDao(), resultSet, offset);
+        entity.setTestEntity(testEntity);
+        offset += daoSession.getTestEntityDao().getAllColumns().length;
+
+        TestEntity testNotNull = loadCurrentOther(daoSession.getTestEntityDao(), resultSet, offset);
+         if(testNotNull != null) {
+            entity.setTestNotNull(testNotNull);
+        }
+        offset += daoSession.getTestEntityDao().getAllColumns().length;
+
+        TestEntity testWithoutProperty = loadCurrentOther(daoSession.getTestEntityDao(), resultSet, offset);
+        entity.setTestWithoutProperty(testWithoutProperty);
+
+        return entity;    
+    }
+
+    public RelationEntity loadDeep(Long key) throws SQLException {
+        assertSinglePk();
+        if (key == null) {
+            return null;
+        }
+
+        StringBuilder builder = new StringBuilder(getSelectDeep());
+        builder.append("WHERE ");
+        SqlUtils.appendColumnsEqValue(builder, "T", getPkColumns());
+        String sql = builder.toString();
+        
+        String[] keyArray = new String[] { key.toString() };
+        ResultSet resultSet = JDBCUtils.query(connection, sql, (Object[]) keyArray);
+        
+        try {
+            boolean available = resultSet.next();
+            if (!available) {
+                return null;
+            } else if (!resultSet.isLast()) {
+                throw new IllegalStateException("Expected unique result, but count was " + JDBCUtils.getCount(resultSet));
+            }
+            return loadCurrentDeep(resultSet, true);
+        } finally {
+            resultSet.close();
+        }
+    }
+    
+    /** Reads all available rows from the given cursor and returns a list of new ImageTO objects. */
+    public List<RelationEntity> loadAllDeepFromResultSet(ResultSet resultSet) throws SQLException {
+        int count = JDBCUtils.getCount(resultSet);
+        List<RelationEntity> list = new ArrayList<RelationEntity>(count);
+        
+        if (resultSet.first()) {
+            if (identityScope != null) {
+                identityScope.lock();
+                identityScope.reserveRoom(count);
+            }
+            try {
+                do {
+                    list.add(loadCurrentDeep(resultSet, false));
+                } while (resultSet.next());
+            } finally {
+                if (identityScope != null) {
+                    identityScope.unlock();
+                }
+            }
+        }
+        return list;
+    }
+    
+    protected List<RelationEntity> loadDeepAllAndCloseResultSet(ResultSet resultSet) throws SQLException {
+        try {
+            return loadAllDeepFromResultSet(resultSet);
+        } finally {
+            resultSet.close();
+        }
+    }
+    
+
+    /** A raw-style query where you can pass any WHERE clause and arguments. */
+    public List<RelationEntity> queryDeep(String where, String... selectionArg) throws SQLException {
+    
+        ResultSet resultSet = JDBCUtils.query( connection, ( getSelectDeep() + where ), (Object[]) selectionArg );
+        return loadDeepAllAndCloseResultSet(resultSet);
+    }
+ 
 }
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntity.java b/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntity.java
index 9c072e1e..e919dfa4 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntity.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntity.java
@@ -1,11 +1,13 @@
 package de.greenrobot.daotest;
 
+
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
 /**
  * Entity mapped to table SIMPLE_ENTITY.
  */
 public class SimpleEntity {
 
+
     private Long id;
     private Boolean simpleBoolean;
     private Byte simpleByte;
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntityContentProvider.java b/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntityContentProvider.java
index cacfee24..aa17849a 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntityContentProvider.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntityContentProvider.java
@@ -10,115 +10,118 @@
 import android.database.sqlite.SQLiteDatabase;
 import android.database.sqlite.SQLiteQueryBuilder;
 import android.net.Uri;
+
 import de.greenrobot.dao.DaoLog;
 import de.greenrobot.platform.android.util.SQLiteUtil;
 
-/* Copy this code snippet into your AndroidManifest.xml inside the <application> element:
+import de.greenrobot.daotest.SimpleEntityDao;
+
+/* Copy this code snippet into your AndroidManifest.xml inside the
+<application> element:
 
     <provider
-        android:name="de.greenrobot.daotest.SimpleEntityContentProvider"
-        android:authorities="de.greenrobot.daotest" />
-*/
+            android:name="de.greenrobot.daotest.SimpleEntityContentProvider"
+            android:authorities="de.greenrobot.daotest.provider"/>
+    */
 
-public class SimpleEntityContentProvider extends ContentProvider {
+    public class SimpleEntityContentProvider extends ContentProvider {
 
-    public static final String AUTHORITY = "de.greenrobot.daotest";
-    public static final String BASE_PATH = "SimpleEntity";
+    public static final String AUTHORITY = "de.greenrobot.daotest.provider";
+    public static final String BASE_PATH = "";
     public static final Uri CONTENT_URI = Uri.parse("content://" + AUTHORITY + "/" + BASE_PATH);
     public static final String CONTENT_TYPE = ContentResolver.CURSOR_DIR_BASE_TYPE
-            + "/" + BASE_PATH;
+    + "/" + BASE_PATH;
     public static final String CONTENT_ITEM_TYPE = ContentResolver.CURSOR_ITEM_BASE_TYPE
-            + "/" + BASE_PATH;
-            
+    + "/" + BASE_PATH;
+
     private static final String TABLENAME = SimpleEntityDao.TABLENAME;
-    private static final String PK = SimpleEntityDao.Properties.Id.columnName;
+    private static final String PK = SimpleEntityDao.Properties.Id
+    .columnName;
 
     private static final int SIMPLEENTITY_DIR = 0;
     private static final int SIMPLEENTITY_ID = 1;
 
     private static final UriMatcher sURIMatcher;
-     
+
     static {
-        sURIMatcher = new UriMatcher(UriMatcher.NO_MATCH);      
-        sURIMatcher.addURI(AUTHORITY, BASE_PATH, SIMPLEENTITY_DIR);
-        sURIMatcher.addURI(AUTHORITY, BASE_PATH + "/#", SIMPLEENTITY_ID);
+    	sURIMatcher = new UriMatcher(UriMatcher.NO_MATCH);
+    	sURIMatcher.addURI(AUTHORITY, BASE_PATH, SIMPLEENTITY_DIR);
+    	sURIMatcher.addURI(AUTHORITY, BASE_PATH + "/#", SIMPLEENTITY_ID);
     }
-    
-    /** 
+
+    /**
     * This must be set from outside, it's recommended to do this inside your Application object.
     * Subject to change (static isn't nice).
     */
-    public static DaoSession daoSession;
-    
+    public static Connection connection;
+
     @Override
     public boolean onCreate() {
-        // if(daoSession == null) {
-        //     throw new IllegalStateException("DaoSession must be set before content provider is created");
-        // }
-        DaoLog.d("Content Provider started: " + CONTENT_URI);
-        return true;
+    	// if(daoSession == null) {
+   		// throw new IllegalStateException("DaoSession must be set before content provider is created");
+    	// }
+    	DaoLog.d("Content Provider started: " + CONTENT_URI);
+    	return true;
     }
-    
-    protected Connection getConnection() {
-        if(daoSession == null) {
-            throw new IllegalStateException("DaoSession must be set during content provider is active");
-        }
-        return daoSession.getConnection();
+
+    protected SQLiteDatabase getDatabase() {
+    	if(connection == null) {
+    		throw new IllegalStateException("Connection must be set during content provider is active");
+    	}
+    	return SQLiteUtil.from(connection, getContext());
     }
-        
+
     @Override
     public Uri insert(Uri uri, ContentValues values) {
-        throw new UnsupportedOperationException("This content provider is readonly");
+	    throw new UnsupportedOperationException("This content provider is readonly");
     }
 
     @Override
     public int delete(Uri uri, String selection, String[] selectionArgs) {
-        throw new UnsupportedOperationException("This content provider is readonly");
+	    throw new UnsupportedOperationException("This content provider is readonly");
     }
-    
+
     @Override
     public int update(Uri uri, ContentValues values, String selection,
-            String[] selectionArgs) {
-        throw new UnsupportedOperationException("This content provider is readonly");
+    String[] selectionArgs) {
+	    throw new UnsupportedOperationException("This content provider is readonly");
     }
- 
     @Override
     public Cursor query(Uri uri, String[] projection, String selection,
-            String[] selectionArgs, String sortOrder) {
-
-        SQLiteQueryBuilder queryBuilder = new SQLiteQueryBuilder();
-        int uriType = sURIMatcher.match(uri);
-        switch (uriType) {
-        case SIMPLEENTITY_DIR:
-            queryBuilder.setTables(TABLENAME);
-            break;
-        case SIMPLEENTITY_ID:
-            queryBuilder.setTables(TABLENAME);
-            queryBuilder.appendWhere(PK + "="
-                    + uri.getLastPathSegment());
-            break;
-        default:
-            throw new IllegalArgumentException("Unknown URI: " + uri);
-        }
-
-        Connection connection = getConnection();
-        SQLiteDatabase db = SQLiteUtil.from(connection, getContext());
-        Cursor cursor = queryBuilder.query(db, projection, selection,
-                selectionArgs, null, null, sortOrder);
-        cursor.setNotificationUri(getContext().getContentResolver(), uri);
-
-        return cursor;
+    String[] selectionArgs, String sortOrder) {
+
+	    SQLiteQueryBuilder queryBuilder = new SQLiteQueryBuilder();
+	    int uriType = sURIMatcher.match(uri);
+	    switch (uriType) {
+	    	case SIMPLEENTITY_DIR:
+	    		queryBuilder.setTables(TABLENAME);
+	    		break;
+	    	case SIMPLEENTITY_ID:
+	    		queryBuilder.setTables(TABLENAME);
+	    		queryBuilder.appendWhere(PK + "="
+	    		+ uri.getLastPathSegment());
+	    		break;
+	    	default:
+	    		throw new IllegalArgumentException("Unknown URI: " + uri);
+	    }
+	
+	    SQLiteDatabase db = getDatabase();
+	    Cursor cursor = queryBuilder.query(db, projection, selection,
+	    selectionArgs, null, null, sortOrder);
+	    cursor.setNotificationUri(getContext().getContentResolver(), uri);
+	
+	    return cursor;
     }
-    
+
     @Override
     public final String getType(Uri uri) {
-        switch (sURIMatcher.match(uri)) {
-        case SIMPLEENTITY_DIR:
-            return CONTENT_TYPE;
-        case SIMPLEENTITY_ID:
-            return CONTENT_ITEM_TYPE;
-        default :
-            throw new IllegalArgumentException("Unsupported URI: " + uri);
-        }
+    	switch (sURIMatcher.match(uri)) {
+    		case SIMPLEENTITY_DIR:
+    			return CONTENT_TYPE;
+    		case SIMPLEENTITY_ID:
+    			return CONTENT_ITEM_TYPE;
+    		default :
+    			throw new IllegalArgumentException("Unsupported URI: " + uri);
+    	}
     }
 }
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntityDao.java
index 6e73d231..13838bb3 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntityDao.java
@@ -1,15 +1,17 @@
 package de.greenrobot.daotest;
 
-import java.sql.Connection;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
+import java.sql.Connection;
+
+import de.greenrobot.platform.java.util.JDBCUtils;
 
-import android.database.sqlite.SQLiteDatabase;
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.Property;
 import de.greenrobot.dao.internal.DaoConfig;
-import de.greenrobot.platform.java.util.JDBCUtils;
+
+import de.greenrobot.daotest.SimpleEntity;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
@@ -45,11 +47,10 @@ public SimpleEntityDao(DaoConfig config, DaoSession daoSession) {
         super(config, daoSession);
     }
 
-    /** Creates the underlying database table. 
-     * @throws ` */
+    /** Creates the underlying database table. */
     public static void createTable(Connection connection, boolean ifNotExists) throws SQLException {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
-        String sql = "CREATE TABLE " + constraint + "'SIMPLE_ENTITY' (" + //
+        JDBCUtils.execute( connection, "CREATE TABLE " + constraint + "'SIMPLE_ENTITY' (" + //
                 "'_id' INTEGER PRIMARY KEY ," + // 0: id
                 "'SIMPLE_BOOLEAN' INTEGER," + // 1: simpleBoolean
                 "'SIMPLE_BYTE' INTEGER," + // 2: simpleByte
@@ -59,113 +60,109 @@ public static void createTable(Connection connection, boolean ifNotExists) throw
                 "'SIMPLE_FLOAT' REAL," + // 6: simpleFloat
                 "'SIMPLE_DOUBLE' REAL," + // 7: simpleDouble
                 "'SIMPLE_STRING' TEXT," + // 8: simpleString
-                "'SIMPLE_BYTE_ARRAY' BLOB);"; // 9: simpleByteArray
-        JDBCUtils.execute( connection, sql );
+                "'SIMPLE_BYTE_ARRAY' BLOB);"); // 9: simpleByteArray
     }
 
     /** Drops the underlying database table. */
-    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
-        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'SIMPLE_ENTITY'";
-        db.execSQL(sql);
+    public static void dropTable(Connection connection, boolean ifExists) throws SQLException {
+        JDBCUtils.execute( connection, "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'SIMPLE_ENTITY'");
     }
 
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
-    protected void bindValues(PreparedStatement stmt, SimpleEntity entity) throws SQLException {
-//        stmt.clearBindings();
+    protected void bindValues(PreparedStatement statement, SimpleEntity entity) throws SQLException {
  
         Long id = entity.getId();
         if (id != null) {
-            stmt.setLong(1, id);
+            statement.setLong(1, id);
         }
  
         Boolean simpleBoolean = entity.getSimpleBoolean();
         if (simpleBoolean != null) {
-            stmt.setLong(2, simpleBoolean ? 1l: 0l);
+            statement.setLong(2, simpleBoolean ? 1l: 0l);
         }
  
         Byte simpleByte = entity.getSimpleByte();
         if (simpleByte != null) {
-            stmt.setLong(3, simpleByte);
+            statement.setLong(3, simpleByte);
         }
  
         Short simpleShort = entity.getSimpleShort();
         if (simpleShort != null) {
-            stmt.setLong(4, simpleShort);
+            statement.setLong(4, simpleShort);
         }
  
         Integer simpleInt = entity.getSimpleInt();
         if (simpleInt != null) {
-            stmt.setLong(5, simpleInt);
+            statement.setLong(5, simpleInt);
         }
  
         Long simpleLong = entity.getSimpleLong();
         if (simpleLong != null) {
-            stmt.setLong(6, simpleLong);
+            statement.setLong(6, simpleLong);
         }
  
         Float simpleFloat = entity.getSimpleFloat();
         if (simpleFloat != null) {
-            stmt.setDouble(7, simpleFloat);
+            statement.setDouble(7, simpleFloat);
         }
  
         Double simpleDouble = entity.getSimpleDouble();
         if (simpleDouble != null) {
-            stmt.setDouble(8, simpleDouble);
+            statement.setDouble(8, simpleDouble);
         }
  
         String simpleString = entity.getSimpleString();
         if (simpleString != null) {
-            stmt.setString(9, simpleString);
+            statement.setString(9, simpleString);
         }
  
         byte[] simpleByteArray = entity.getSimpleByteArray();
         if (simpleByteArray != null) {
-            stmt.setBytes(10, simpleByteArray);
+            statement.setBytes(10, simpleByteArray);
         }
     }
 
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
     public Long readKey(ResultSet resultSet, int offset) throws SQLException {
-        return JDBCUtils.isNull( resultSet, offset + 0 ) ? null : resultSet.getLong(offset + 0);
+    	int index = 1;
+        return JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++);
     }    
 
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
     public SimpleEntity readEntity(ResultSet resultSet, int offset) throws SQLException {
-        SimpleEntity entity = new SimpleEntity( //
-            JDBCUtils.isNull( resultSet, offset + 0 ) ? null : resultSet.getLong(offset + 0), // id
-            JDBCUtils.isNull( resultSet, offset + 1 ) ? null : resultSet.getShort(offset + 1) != 0, // simpleBoolean
-            JDBCUtils.isNull( resultSet, offset + 2 ) ? null : (byte) resultSet.getShort(offset + 2), // simpleByte
-            JDBCUtils.isNull( resultSet, offset + 3 ) ? null : resultSet.getShort(offset + 3), // simpleShort
-            JDBCUtils.isNull( resultSet, offset + 4 ) ? null : resultSet.getInt(offset + 4), // simpleInt
-            JDBCUtils.isNull( resultSet, offset + 5 ) ? null : resultSet.getLong(offset + 5), // simpleLong
-            JDBCUtils.isNull( resultSet, offset + 6 ) ? null : resultSet.getFloat(offset + 6), // simpleFloat
-            JDBCUtils.isNull( resultSet, offset + 7 ) ? null : resultSet.getDouble(offset + 7), // simpleDouble
-            JDBCUtils.isNull( resultSet, offset + 8 ) ? null : resultSet.getString(offset + 8), // simpleString
-            JDBCUtils.isNull( resultSet, offset + 9 ) ? null : resultSet.getBytes(offset + 9) // simpleByteArray
+		int index = 1;
+        SimpleEntity entity = new SimpleEntity(
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++), // id
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getShort(offset + index++) != 0, // simpleBoolean
+            JDBCUtils.isNull(resultSet, offset + index) ? null : (byte) resultSet.getShort(offset + index++), // simpleByte
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getShort(offset + index++), // simpleShort
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getInt(offset + index++), // simpleInt
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++), // simpleLong
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getFloat(offset + index++), // simpleFloat
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getDouble(offset + index++), // simpleDouble
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getString(offset + index++), // simpleString
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getBytes(offset + index++) // simpleByteArray
         );
         return entity;
     }
      
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
     public void readEntity(ResultSet resultSet, SimpleEntity entity, int offset) throws SQLException {
-        entity.setId(JDBCUtils.isNull( resultSet, offset + 0 ) ? null : resultSet.getLong(offset + 0));
-        entity.setSimpleBoolean(JDBCUtils.isNull( resultSet, offset + 1) ? null : resultSet.getShort(offset + 1) != 0);
-        entity.setSimpleByte(JDBCUtils.isNull( resultSet, offset + 2) ? null : (byte) resultSet.getShort(offset + 2));
-        entity.setSimpleShort(JDBCUtils.isNull( resultSet, offset + 3) ? null : resultSet.getShort(offset + 3));
-        entity.setSimpleInt(JDBCUtils.isNull( resultSet, offset + 4) ? null : resultSet.getInt(offset + 4));
-        entity.setSimpleLong(JDBCUtils.isNull( resultSet, offset + 5) ? null : resultSet.getLong(offset + 5));
-        entity.setSimpleFloat(JDBCUtils.isNull( resultSet, offset + 6) ? null : resultSet.getFloat(offset + 6));
-        entity.setSimpleDouble(JDBCUtils.isNull( resultSet, offset + 7) ? null : resultSet.getDouble(offset + 7));
-        entity.setSimpleString(JDBCUtils.isNull( resultSet, offset + 8) ? null : resultSet.getString(offset + 8));
-        entity.setSimpleByteArray(JDBCUtils.isNull( resultSet, offset + 9) ? null : resultSet.getBytes(offset + 9));
+		int index = 1;
+        entity.setId(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++));
+        entity.setSimpleBoolean(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getShort(offset + index++) != 0);
+        entity.setSimpleByte(JDBCUtils.isNull(resultSet, offset + index) ? null : (byte) resultSet.getShort(offset + index++));
+        entity.setSimpleShort(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getShort(offset + index++));
+        entity.setSimpleInt(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getInt(offset + index++));
+        entity.setSimpleLong(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++));
+        entity.setSimpleFloat(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getFloat(offset + index++));
+        entity.setSimpleDouble(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getDouble(offset + index++));
+        entity.setSimpleString(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getString(offset + index++));
+        entity.setSimpleByteArray(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getBytes(offset + index++));
      }
     
     /** @inheritdoc */
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntityNotNull.java b/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntityNotNull.java
index 98c6a053..44acb624 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntityNotNull.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntityNotNull.java
@@ -1,11 +1,13 @@
 package de.greenrobot.daotest;
 
+
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
 /**
  * Entity mapped to table SIMPLE_ENTITY_NOT_NULL.
  */
 public class SimpleEntityNotNull {
 
+
     private long id;
     private boolean simpleBoolean;
     private byte simpleByte;
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntityNotNullDao.java b/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntityNotNullDao.java
index 3bcc7adf..dd735aa2 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntityNotNullDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntityNotNullDao.java
@@ -1,15 +1,17 @@
 package de.greenrobot.daotest;
 
-import java.sql.Connection;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
+import java.sql.Connection;
+
+import de.greenrobot.platform.java.util.JDBCUtils;
 
-import android.database.sqlite.SQLiteDatabase;
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.Property;
 import de.greenrobot.dao.internal.DaoConfig;
-import de.greenrobot.platform.java.util.JDBCUtils;
+
+import de.greenrobot.daotest.SimpleEntityNotNull;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
@@ -45,11 +47,10 @@ public SimpleEntityNotNullDao(DaoConfig config, DaoSession daoSession) {
         super(config, daoSession);
     }
 
-    /** Creates the underlying database table. 
-     * @throws SQLException */
+    /** Creates the underlying database table. */
     public static void createTable(Connection connection, boolean ifNotExists) throws SQLException {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
-        String sql = ("CREATE TABLE " + constraint + "'SIMPLE_ENTITY_NOT_NULL' (" + //
+        JDBCUtils.execute( connection, "CREATE TABLE " + constraint + "'SIMPLE_ENTITY_NOT_NULL' (" + //
                 "'_id' INTEGER PRIMARY KEY NOT NULL ," + // 0: id
                 "'SIMPLE_BOOLEAN' INTEGER NOT NULL ," + // 1: simpleBoolean
                 "'SIMPLE_BYTE' INTEGER NOT NULL ," + // 2: simpleByte
@@ -60,72 +61,68 @@ public static void createTable(Connection connection, boolean ifNotExists) throw
                 "'SIMPLE_DOUBLE' REAL NOT NULL ," + // 7: simpleDouble
                 "'SIMPLE_STRING' TEXT NOT NULL ," + // 8: simpleString
                 "'SIMPLE_BYTE_ARRAY' BLOB NOT NULL );"); // 9: simpleByteArray
-        JDBCUtils.execute( connection, sql );
     }
 
     /** Drops the underlying database table. */
-    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
-        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'SIMPLE_ENTITY_NOT_NULL'";
-        db.execSQL(sql);
+    public static void dropTable(Connection connection, boolean ifExists) throws SQLException {
+        JDBCUtils.execute( connection, "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'SIMPLE_ENTITY_NOT_NULL'");
     }
 
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
-    protected void bindValues(PreparedStatement stmt, SimpleEntityNotNull entity) throws SQLException {
-//        stmt.clearBindings();
-        stmt.setLong(1, entity.getId());
-        stmt.setLong(2, entity.getSimpleBoolean() ? 1l: 0l);
-        stmt.setLong(3, entity.getSimpleByte());
-        stmt.setLong(4, entity.getSimpleShort());
-        stmt.setLong(5, entity.getSimpleInt());
-        stmt.setLong(6, entity.getSimpleLong());
-        stmt.setDouble(7, entity.getSimpleFloat());
-        stmt.setDouble(8, entity.getSimpleDouble());
-        stmt.setString(9, entity.getSimpleString());
-        stmt.setBytes(10, entity.getSimpleByteArray());
+    protected void bindValues(PreparedStatement statement, SimpleEntityNotNull entity) throws SQLException {
+        statement.setLong(1, entity.getId());
+        statement.setLong(2, entity.getSimpleBoolean() ? 1l: 0l);
+        statement.setLong(3, entity.getSimpleByte());
+        statement.setLong(4, entity.getSimpleShort());
+        statement.setLong(5, entity.getSimpleInt());
+        statement.setLong(6, entity.getSimpleLong());
+        statement.setDouble(7, entity.getSimpleFloat());
+        statement.setDouble(8, entity.getSimpleDouble());
+        statement.setString(9, entity.getSimpleString());
+        statement.setBytes(10, entity.getSimpleByteArray());
     }
 
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
     public Long readKey(ResultSet resultSet, int offset) throws SQLException {
-        return resultSet.getLong(offset + 0);
+    	int index = 1;
+        return resultSet.getLong(offset + index++);
     }    
 
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
     public SimpleEntityNotNull readEntity(ResultSet resultSet, int offset) throws SQLException {
-        SimpleEntityNotNull entity = new SimpleEntityNotNull( //
-            resultSet.getLong(offset + 0), // id
-            resultSet.getShort(offset + 1) != 0, // simpleBoolean
-            (byte) resultSet.getShort(offset + 2), // simpleByte
-            resultSet.getShort(offset + 3), // simpleShort
-            resultSet.getInt(offset + 4), // simpleInt
-            resultSet.getLong(offset + 5), // simpleLong
-            resultSet.getFloat(offset + 6), // simpleFloat
-            resultSet.getDouble(offset + 7), // simpleDouble
-            resultSet.getString(offset + 8), // simpleString
-            resultSet.getBytes(offset + 9) // simpleByteArray
+		int index = 1;
+        SimpleEntityNotNull entity = new SimpleEntityNotNull(
+            resultSet.getLong(offset + index++), // id
+            resultSet.getShort(offset + index++) != 0, // simpleBoolean
+            (byte) resultSet.getShort(offset + index++), // simpleByte
+            resultSet.getShort(offset + index++), // simpleShort
+            resultSet.getInt(offset + index++), // simpleInt
+            resultSet.getLong(offset + index++), // simpleLong
+            resultSet.getFloat(offset + index++), // simpleFloat
+            resultSet.getDouble(offset + index++), // simpleDouble
+            resultSet.getString(offset + index++), // simpleString
+            resultSet.getBytes(offset + index++) // simpleByteArray
         );
         return entity;
     }
      
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
     public void readEntity(ResultSet resultSet, SimpleEntityNotNull entity, int offset) throws SQLException {
-        entity.setId(resultSet.getLong(offset + 0));
-        entity.setSimpleBoolean(resultSet.getShort(offset + 1) != 0);
-        entity.setSimpleByte((byte) resultSet.getShort(offset + 2));
-        entity.setSimpleShort(resultSet.getShort(offset + 3));
-        entity.setSimpleInt(resultSet.getInt(offset + 4));
-        entity.setSimpleLong(resultSet.getLong(offset + 5));
-        entity.setSimpleFloat(resultSet.getFloat(offset + 6));
-        entity.setSimpleDouble(resultSet.getDouble(offset + 7));
-        entity.setSimpleString(resultSet.getString(offset + 8));
-        entity.setSimpleByteArray(resultSet.getBytes(offset + 9));
+		int index = 1;
+        entity.setId(resultSet.getLong(offset + index++));
+        entity.setSimpleBoolean(resultSet.getShort(offset + index++) != 0);
+        entity.setSimpleByte((byte) resultSet.getShort(offset + index++));
+        entity.setSimpleShort(resultSet.getShort(offset + index++));
+        entity.setSimpleInt(resultSet.getInt(offset + index++));
+        entity.setSimpleLong(resultSet.getLong(offset + index++));
+        entity.setSimpleFloat(resultSet.getFloat(offset + index++));
+        entity.setSimpleDouble(resultSet.getDouble(offset + index++));
+        entity.setSimpleString(resultSet.getString(offset + index++));
+        entity.setSimpleByteArray(resultSet.getBytes(offset + index++));
      }
     
     /** @inheritdoc */
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/SpecialNamesEntity.java b/DaoTest/src-gen/de/greenrobot/daotest/SpecialNamesEntity.java
index 3a907aeb..023cec90 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/SpecialNamesEntity.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/SpecialNamesEntity.java
@@ -1,11 +1,13 @@
 package de.greenrobot.daotest;
 
+
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
 /**
  * Entity mapped to table SPECIAL_NAMES_ENTITY.
  */
 public class SpecialNamesEntity {
 
+
     private Long id;
     private String count;
     private String select;
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/SpecialNamesEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/SpecialNamesEntityDao.java
index b9f08b43..ed202705 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/SpecialNamesEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/SpecialNamesEntityDao.java
@@ -1,15 +1,17 @@
 package de.greenrobot.daotest;
 
-import java.sql.Connection;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
+import java.sql.Connection;
+
+import de.greenrobot.platform.java.util.JDBCUtils;
 
-import android.database.sqlite.SQLiteDatabase;
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.Property;
 import de.greenrobot.dao.internal.DaoConfig;
-import de.greenrobot.platform.java.util.JDBCUtils;
+
+import de.greenrobot.daotest.SpecialNamesEntity;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
@@ -45,8 +47,7 @@ public SpecialNamesEntityDao(DaoConfig config, DaoSession daoSession) {
         super(config, daoSession);
     }
 
-    /** Creates the underlying database table. 
-     * @throws SQLException */
+    /** Creates the underlying database table. */
     public static void createTable(Connection connection, boolean ifNotExists) throws SQLException {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
         JDBCUtils.execute( connection, "CREATE TABLE " + constraint + "'SPECIAL_NAMES_ENTITY' (" + //
@@ -63,108 +64,105 @@ public static void createTable(Connection connection, boolean ifNotExists) throw
     }
 
     /** Drops the underlying database table. */
-    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
-        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'SPECIAL_NAMES_ENTITY'";
-        db.execSQL(sql);
+    public static void dropTable(Connection connection, boolean ifExists) throws SQLException {
+        JDBCUtils.execute( connection, "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'SPECIAL_NAMES_ENTITY'");
     }
 
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
-    protected void bindValues(PreparedStatement stmt, SpecialNamesEntity entity) throws SQLException {
-//        stmt.clearBindings();
+    protected void bindValues(PreparedStatement statement, SpecialNamesEntity entity) throws SQLException {
  
         Long id = entity.getId();
         if (id != null) {
-            stmt.setLong(1, id);
+            statement.setLong(1, id);
         }
  
         String count = entity.getCount();
         if (count != null) {
-            stmt.setString(2, count);
+            statement.setString(2, count);
         }
  
         String select = entity.getSelect();
         if (select != null) {
-            stmt.setString(3, select);
+            statement.setString(3, select);
         }
  
         String sum = entity.getSum();
         if (sum != null) {
-            stmt.setString(4, sum);
+            statement.setString(4, sum);
         }
  
         String avg = entity.getAvg();
         if (avg != null) {
-            stmt.setString(5, avg);
+            statement.setString(5, avg);
         }
  
         String join = entity.getJoin();
         if (join != null) {
-            stmt.setString(6, join);
+            statement.setString(6, join);
         }
  
         String distinct = entity.getDistinct();
         if (distinct != null) {
-            stmt.setString(7, distinct);
+            statement.setString(7, distinct);
         }
  
         String on = entity.getOn();
         if (on != null) {
-            stmt.setString(8, on);
+            statement.setString(8, on);
         }
  
         String index = entity.getIndex();
         if (index != null) {
-            stmt.setString(9, index);
+            statement.setString(9, index);
         }
  
         Integer order = entity.getOrder();
         if (order != null) {
-            stmt.setLong(10, order);
+            statement.setLong(10, order);
         }
     }
 
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
     public Long readKey(ResultSet resultSet, int offset) throws SQLException {
-        return JDBCUtils.isNull( resultSet, offset + 0) ? null : resultSet.getLong(offset + 0);
+    	int index = 1;
+        return JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++);
     }    
 
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
     public SpecialNamesEntity readEntity(ResultSet resultSet, int offset) throws SQLException {
-        SpecialNamesEntity entity = new SpecialNamesEntity( //
-            JDBCUtils.isNull( resultSet, offset + 0) ? null : resultSet.getLong(offset + 0), // id
-            JDBCUtils.isNull( resultSet, offset + 1) ? null : resultSet.getString(offset + 1), // count
-            JDBCUtils.isNull( resultSet, offset + 2) ? null : resultSet.getString(offset + 2), // select
-            JDBCUtils.isNull( resultSet, offset + 3) ? null : resultSet.getString(offset + 3), // sum
-            JDBCUtils.isNull( resultSet, offset + 4) ? null : resultSet.getString(offset + 4), // avg
-            JDBCUtils.isNull( resultSet, offset + 5) ? null : resultSet.getString(offset + 5), // join
-            JDBCUtils.isNull( resultSet, offset + 6) ? null : resultSet.getString(offset + 6), // distinct
-            JDBCUtils.isNull( resultSet, offset + 7) ? null : resultSet.getString(offset + 7), // on
-            JDBCUtils.isNull( resultSet, offset + 8) ? null : resultSet.getString(offset + 8), // index
-            JDBCUtils.isNull( resultSet, offset + 9) ? null : resultSet.getInt(offset + 9) // order
+		int index = 1;
+        SpecialNamesEntity entity = new SpecialNamesEntity(
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++), // id
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getString(offset + index++), // count
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getString(offset + index++), // select
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getString(offset + index++), // sum
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getString(offset + index++), // avg
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getString(offset + index++), // join
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getString(offset + index++), // distinct
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getString(offset + index++), // on
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getString(offset + index++), // index
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getInt(offset + index++) // order
         );
         return entity;
     }
      
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
     public void readEntity(ResultSet resultSet, SpecialNamesEntity entity, int offset) throws SQLException {
-        entity.setId(JDBCUtils.isNull( resultSet, offset + 0) ? null : resultSet.getLong(offset + 0));
-        entity.setCount(JDBCUtils.isNull( resultSet, offset + 1) ? null : resultSet.getString(offset + 1));
-        entity.setSelect(JDBCUtils.isNull( resultSet, offset + 2) ? null : resultSet.getString(offset + 2));
-        entity.setSum(JDBCUtils.isNull( resultSet, offset + 3) ? null : resultSet.getString(offset + 3));
-        entity.setAvg(JDBCUtils.isNull( resultSet, offset + 4) ? null : resultSet.getString(offset + 4));
-        entity.setJoin(JDBCUtils.isNull( resultSet, offset + 5) ? null : resultSet.getString(offset + 5));
-        entity.setDistinct(JDBCUtils.isNull( resultSet, offset + 6) ? null : resultSet.getString(offset + 6));
-        entity.setOn(JDBCUtils.isNull( resultSet, offset + 7) ? null : resultSet.getString(offset + 7));
-        entity.setIndex(JDBCUtils.isNull( resultSet, offset + 8) ? null : resultSet.getString(offset + 8));
-        entity.setOrder(JDBCUtils.isNull( resultSet, offset + 9) ? null : resultSet.getInt(offset + 9));
+		int index = 1;
+        entity.setId(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++));
+        entity.setCount(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getString(offset + index++));
+        entity.setSelect(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getString(offset + index++));
+        entity.setSum(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getString(offset + index++));
+        entity.setAvg(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getString(offset + index++));
+        entity.setJoin(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getString(offset + index++));
+        entity.setDistinct(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getString(offset + index++));
+        entity.setOn(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getString(offset + index++));
+        entity.setIndex(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getString(offset + index++));
+        entity.setOrder(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getInt(offset + index++));
      }
     
     /** @inheritdoc */
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/SqliteMaster.java b/DaoTest/src-gen/de/greenrobot/daotest/SqliteMaster.java
index d67dc10f..0ba7a9f5 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/SqliteMaster.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/SqliteMaster.java
@@ -1,5 +1,6 @@
 package de.greenrobot.daotest;
 
+
 // THIS CODE IS GENERATED BY greenDAO, EDIT ONLY INSIDE THE "KEEP"-SECTIONS
 
 // KEEP INCLUDES - put your custom includes here
@@ -9,6 +10,7 @@
  */
 public class SqliteMaster {
 
+
     private String type;
     private String name;
     private String tableName;
@@ -70,10 +72,6 @@ public void setSql(String sql) {
     }
 
     // KEEP METHODS - put your custom methods here
-    @Override
-    public String toString() {
-        return "Type: " + type + ", name: " + name + ", table: " + tableName + ", SQL: " + sql;
-    }
     // KEEP METHODS END
 
 }
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/SqliteMasterDao.java b/DaoTest/src-gen/de/greenrobot/daotest/SqliteMasterDao.java
index 838f4888..0dd6e514 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/SqliteMasterDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/SqliteMasterDao.java
@@ -4,10 +4,13 @@
 import java.sql.ResultSet;
 import java.sql.SQLException;
 
+import de.greenrobot.platform.java.util.JDBCUtils;
+
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.Property;
 import de.greenrobot.dao.internal.DaoConfig;
-import de.greenrobot.platform.java.util.JDBCUtils;
+
+import de.greenrobot.daotest.SqliteMaster;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
@@ -38,67 +41,65 @@ public SqliteMasterDao(DaoConfig config, DaoSession daoSession) {
         super(config, daoSession);
     }
 
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
-    protected void bindValues(PreparedStatement stmt, SqliteMaster entity) throws SQLException {
-//        stmt.clearBindings();
+    protected void bindValues(PreparedStatement statement, SqliteMaster entity) throws SQLException {
  
         String type = entity.getType();
         if (type != null) {
-            stmt.setString(1, type);
+            statement.setString(1, type);
         }
  
         String name = entity.getName();
         if (name != null) {
-            stmt.setString(2, name);
+            statement.setString(2, name);
         }
  
         String tableName = entity.getTableName();
         if (tableName != null) {
-            stmt.setString(3, tableName);
+            statement.setString(3, tableName);
         }
  
         Long rootpage = entity.getRootpage();
         if (rootpage != null) {
-            stmt.setLong(4, rootpage);
+            statement.setLong(4, rootpage);
         }
  
         String sql = entity.getSql();
         if (sql != null) {
-            stmt.setString(5, sql);
+            statement.setString(5, sql);
         }
     }
 
     /** @inheritdoc */
     @Override
-    public Void readKey(ResultSet resultSet, int offset) {
+    public Void readKey(ResultSet resultSet, int offset) throws SQLException {
         return null;
     }    
 
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
     public SqliteMaster readEntity(ResultSet resultSet, int offset) throws SQLException {
-        SqliteMaster entity = new SqliteMaster( //
-            JDBCUtils.isNull(resultSet, offset + 0) ? null : resultSet.getString(offset + 0), // type
-            JDBCUtils.isNull(resultSet, offset + 1) ? null : resultSet.getString(offset + 1), // name
-            JDBCUtils.isNull(resultSet, offset + 2) ? null : resultSet.getString(offset + 2), // tableName
-            JDBCUtils.isNull(resultSet, offset + 3) ? null : resultSet.getLong(offset + 3), // rootpage
-            JDBCUtils.isNull(resultSet, offset + 4) ? null : resultSet.getString(offset + 4) // sql
+		int index = 1;
+        SqliteMaster entity = new SqliteMaster(
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getString(offset + index++), // type
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getString(offset + index++), // name
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getString(offset + index++), // tableName
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++), // rootpage
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getString(offset + index++) // sql
         );
         return entity;
     }
      
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
     public void readEntity(ResultSet resultSet, SqliteMaster entity, int offset) throws SQLException {
-        entity.setType(JDBCUtils.isNull(resultSet, offset + 0) ? null : resultSet.getString(offset + 0));
-        entity.setName(JDBCUtils.isNull(resultSet, offset + 1) ? null : resultSet.getString(offset + 1));
-        entity.setTableName(JDBCUtils.isNull(resultSet, offset + 2) ? null : resultSet.getString(offset + 2));
-        entity.setRootpage(JDBCUtils.isNull(resultSet, offset + 3) ? null : resultSet.getLong(offset + 3));
-        entity.setSql(JDBCUtils.isNull(resultSet, offset + 4) ? null : resultSet.getString(offset + 4));
+		int index = 1;
+        entity.setType(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getString(offset + index++));
+        entity.setName(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getString(offset + index++));
+        entity.setTableName(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getString(offset + index++));
+        entity.setRootpage(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++));
+        entity.setSql(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getString(offset + index++));
      }
     
     /** @inheritdoc */
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/StringKeyValueEntity.java b/DaoTest/src-gen/de/greenrobot/daotest/StringKeyValueEntity.java
index b436d049..19192702 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/StringKeyValueEntity.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/StringKeyValueEntity.java
@@ -1,11 +1,13 @@
 package de.greenrobot.daotest;
 
+
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
 /**
  * Entity mapped to table STRING_KEY_VALUE_ENTITY.
  */
 public class StringKeyValueEntity {
 
+
     private String key;
     private String value;
 
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/StringKeyValueEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/StringKeyValueEntityDao.java
index 854be5ae..5725bf3c 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/StringKeyValueEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/StringKeyValueEntityDao.java
@@ -1,15 +1,17 @@
 package de.greenrobot.daotest;
 
-import java.sql.Connection;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
+import java.sql.Connection;
+
+import de.greenrobot.platform.java.util.JDBCUtils;
 
-import android.database.sqlite.SQLiteDatabase;
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.Property;
 import de.greenrobot.dao.internal.DaoConfig;
-import de.greenrobot.platform.java.util.JDBCUtils;
+
+import de.greenrobot.daotest.StringKeyValueEntity;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
@@ -37,62 +39,58 @@ public StringKeyValueEntityDao(DaoConfig config, DaoSession daoSession) {
         super(config, daoSession);
     }
 
-    /** Creates the underlying database table. 
-     * @throws SQLException */
+    /** Creates the underlying database table. */
     public static void createTable(Connection connection, boolean ifNotExists) throws SQLException {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
-        JDBCUtils.execute(connection, "CREATE TABLE " + constraint + "'STRING_KEY_VALUE_ENTITY' (" + //
+        JDBCUtils.execute( connection, "CREATE TABLE " + constraint + "'STRING_KEY_VALUE_ENTITY' (" + //
                 "'KEY' TEXT PRIMARY KEY NOT NULL ," + // 0: key
                 "'VALUE' TEXT);"); // 1: value
     }
 
     /** Drops the underlying database table. */
-    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
-        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'STRING_KEY_VALUE_ENTITY'";
-        db.execSQL(sql);
+    public static void dropTable(Connection connection, boolean ifExists) throws SQLException {
+        JDBCUtils.execute( connection, "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'STRING_KEY_VALUE_ENTITY'");
     }
 
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
-    protected void bindValues(PreparedStatement stmt, StringKeyValueEntity entity) throws SQLException {
-//        stmt.clearBindings();
+    protected void bindValues(PreparedStatement statement, StringKeyValueEntity entity) throws SQLException {
  
         String key = entity.getKey();
         if (key != null) {
-            stmt.setString(1, key);
+            statement.setString(1, key);
         }
  
         String value = entity.getValue();
         if (value != null) {
-            stmt.setString(2, value);
+            statement.setString(2, value);
         }
     }
 
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
     public String readKey(ResultSet resultSet, int offset) throws SQLException {
-        return JDBCUtils.isNull(resultSet, offset + 0) ? null : resultSet.getString(offset + 0);
+    	int index = 1;
+        return JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getString(offset + index++);
     }    
 
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
     public StringKeyValueEntity readEntity(ResultSet resultSet, int offset) throws SQLException {
-        StringKeyValueEntity entity = new StringKeyValueEntity( //
-            JDBCUtils.isNull(resultSet, offset + 0) ? null : resultSet.getString(offset + 0), // key
-            JDBCUtils.isNull(resultSet, offset + 1) ? null : resultSet.getString(offset + 1) // value
+		int index = 1;
+        StringKeyValueEntity entity = new StringKeyValueEntity(
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getString(offset + index++), // key
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getString(offset + index++) // value
         );
         return entity;
     }
      
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
     public void readEntity(ResultSet resultSet, StringKeyValueEntity entity, int offset) throws SQLException {
-        entity.setKey(JDBCUtils.isNull(resultSet, offset + 0) ? null : resultSet.getString(offset + 0));
-        entity.setValue(JDBCUtils.isNull(resultSet, offset + 1) ? null : resultSet.getString(offset + 1));
+		int index = 1;
+        entity.setKey(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getString(offset + index++));
+        entity.setValue(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getString(offset + index++));
      }
     
     /** @inheritdoc */
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/TestEntity.java b/DaoTest/src-gen/de/greenrobot/daotest/TestEntity.java
index 82bde4bd..72d40ccc 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/TestEntity.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/TestEntity.java
@@ -1,11 +1,13 @@
 package de.greenrobot.daotest;
 
+
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
 /**
  * Entity mapped to table TEST_ENTITY.
  */
 public class TestEntity {
 
+
     private Long id;
     private int simpleInt;
     private Integer simpleInteger;
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/TestEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/TestEntityDao.java
index 711b2c9c..ec4f7ec2 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/TestEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/TestEntityDao.java
@@ -1,15 +1,17 @@
 package de.greenrobot.daotest;
 
-import java.sql.Connection;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
+import java.sql.Connection;
+
+import de.greenrobot.platform.java.util.JDBCUtils;
 
-import android.database.sqlite.SQLiteDatabase;
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.Property;
 import de.greenrobot.dao.internal.DaoConfig;
-import de.greenrobot.platform.java.util.JDBCUtils;
+
+import de.greenrobot.daotest.TestEntity;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
@@ -44,124 +46,111 @@ public TestEntityDao(DaoConfig config, DaoSession daoSession) {
         super(config, daoSession);
     }
 
-    /** Creates the underlying database table. 
-     * @throws SQLException */
+    /** Creates the underlying database table. */
     public static void createTable(Connection connection, boolean ifNotExists) throws SQLException {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
-        PreparedStatement statement = connection.prepareStatement(
-    		"CREATE TABLE " + constraint + "'TEST_ENTITY' (" + //
-            "'_id' INTEGER PRIMARY KEY ," + // 0: id
-            "'SIMPLE_INT' INTEGER NOT NULL ," + // 1: simpleInt
-            "'SIMPLE_INTEGER' INTEGER," + // 2: simpleInteger
-            "'SIMPLE_STRING_NOT_NULL' TEXT NOT NULL ," + // 3: simpleStringNotNull
-            "'SIMPLE_STRING' TEXT," + // 4: simpleString
-            "'INDEXED_STRING' TEXT," + // 5: indexedString
-            "'INDEXED_STRING_ASC_UNIQUE' TEXT," + // 6: indexedStringAscUnique
-            "'SIMPLE_DATE' INTEGER," + // 7: simpleDate
-            "'SIMPLE_BOOLEAN' INTEGER);" // 8: simpleBoolean
-        ); 
-        statement.execute();
-        statement.close();
+        JDBCUtils.execute( connection, "CREATE TABLE " + constraint + "'TEST_ENTITY' (" + //
+                "'_id' INTEGER PRIMARY KEY ," + // 0: id
+                "'SIMPLE_INT' INTEGER NOT NULL ," + // 1: simpleInt
+                "'SIMPLE_INTEGER' INTEGER," + // 2: simpleInteger
+                "'SIMPLE_STRING_NOT_NULL' TEXT NOT NULL ," + // 3: simpleStringNotNull
+                "'SIMPLE_STRING' TEXT," + // 4: simpleString
+                "'INDEXED_STRING' TEXT," + // 5: indexedString
+                "'INDEXED_STRING_ASC_UNIQUE' TEXT," + // 6: indexedStringAscUnique
+                "'SIMPLE_DATE' INTEGER," + // 7: simpleDate
+                "'SIMPLE_BOOLEAN' INTEGER);"); // 8: simpleBoolean
         // Add Indexes
-        statement = connection.prepareStatement("CREATE INDEX " + constraint + "IDX_TEST_ENTITY_INDEXED_STRING ON TEST_ENTITY" +
+        JDBCUtils.execute( connection, "CREATE INDEX " + constraint + "IDX_TEST_ENTITY_INDEXED_STRING ON TEST_ENTITY" +
                 " (INDEXED_STRING);");
-        statement.execute();
-        statement.close();
-
-        statement = connection.prepareStatement("CREATE UNIQUE INDEX " + constraint + "IDX_TEST_ENTITY_INDEXED_STRING_ASC_UNIQUE ON TEST_ENTITY" +
+        JDBCUtils.execute( connection, "CREATE UNIQUE INDEX " + constraint + "IDX_TEST_ENTITY_INDEXED_STRING_ASC_UNIQUE ON TEST_ENTITY" +
                 " (INDEXED_STRING_ASC_UNIQUE);");
-        statement.execute();
-        statement.close();
     }
 
     /** Drops the underlying database table. */
-    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
-        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'TEST_ENTITY'";
-        db.execSQL(sql);
+    public static void dropTable(Connection connection, boolean ifExists) throws SQLException {
+        JDBCUtils.execute( connection, "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'TEST_ENTITY'");
     }
 
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
-    protected void bindValues(PreparedStatement stmt, TestEntity entity) throws SQLException {
-//        stmt.clearBindings();
+    protected void bindValues(PreparedStatement statement, TestEntity entity) throws SQLException {
  
         Long id = entity.getId();
         if (id != null) {
-            stmt.setLong(1, id);
+            statement.setLong(1, id);
         }
-        stmt.setLong(2, entity.getSimpleInt());
+        statement.setLong(2, entity.getSimpleInt());
  
         Integer simpleInteger = entity.getSimpleInteger();
         if (simpleInteger != null) {
-            stmt.setLong(3, simpleInteger);
+            statement.setLong(3, simpleInteger);
         }
-        stmt.setString(4, entity.getSimpleStringNotNull());
+        statement.setString(4, entity.getSimpleStringNotNull());
  
         String simpleString = entity.getSimpleString();
         if (simpleString != null) {
-            stmt.setString(5, simpleString);
+            statement.setString(5, simpleString);
         }
  
         String indexedString = entity.getIndexedString();
         if (indexedString != null) {
-            stmt.setString(6, indexedString);
+            statement.setString(6, indexedString);
         }
  
         String indexedStringAscUnique = entity.getIndexedStringAscUnique();
         if (indexedStringAscUnique != null) {
-            stmt.setString(7, indexedStringAscUnique);
+            statement.setString(7, indexedStringAscUnique);
         }
  
         java.util.Date simpleDate = entity.getSimpleDate();
         if (simpleDate != null) {
-            stmt.setLong(8, simpleDate.getTime());
+            statement.setLong(8, simpleDate.getTime());
         }
  
         Boolean simpleBoolean = entity.getSimpleBoolean();
         if (simpleBoolean != null) {
-            stmt.setLong(9, simpleBoolean ? 1l: 0l);
+            statement.setLong(9, simpleBoolean ? 1l: 0l);
         }
     }
 
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
     public Long readKey(ResultSet resultSet, int offset) throws SQLException {
-        return JDBCUtils.isNull(resultSet, offset + 0) ? null : resultSet.getLong(offset + 0);
+    	int index = 1;
+        return JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++);
     }    
 
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
     public TestEntity readEntity(ResultSet resultSet, int offset) throws SQLException {
-        TestEntity entity = new TestEntity( //
-            JDBCUtils.isNull(resultSet, offset + 0) ? null : resultSet.getLong(offset + 0), // id
-            resultSet.getInt(offset + 1), // simpleInt
-            JDBCUtils.isNull(resultSet, offset + 2) ? null : resultSet.getInt(offset + 2), // simpleInteger
-            resultSet.getString(offset + 3), // simpleStringNotNull
-            JDBCUtils.isNull(resultSet, offset + 4) ? null : resultSet.getString(offset + 4), // simpleString
-            JDBCUtils.isNull(resultSet, offset + 5) ? null : resultSet.getString(offset + 5), // indexedString
-            JDBCUtils.isNull(resultSet, offset + 6) ? null : resultSet.getString(offset + 6), // indexedStringAscUnique
-            JDBCUtils.isNull(resultSet, offset + 7) ? null : new java.util.Date(resultSet.getLong(offset + 7)), // simpleDate
-            JDBCUtils.isNull(resultSet, offset + 8) ? null : resultSet.getShort(offset + 8) != 0 // simpleBoolean
+		int index = 1;
+        TestEntity entity = new TestEntity(
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++), // id
+            resultSet.getInt(offset + index++), // simpleInt
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getInt(offset + index++), // simpleInteger
+            resultSet.getString(offset + index++), // simpleStringNotNull
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getString(offset + index++), // simpleString
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getString(offset + index++), // indexedString
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getString(offset + index++), // indexedStringAscUnique
+            JDBCUtils.isNull(resultSet, offset + index) ? null : new java.util.Date(resultSet.getLong(offset + index++)), // simpleDate
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getShort(offset + index++) != 0 // simpleBoolean
         );
         return entity;
     }
      
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
     public void readEntity(ResultSet resultSet, TestEntity entity, int offset) throws SQLException {
-        entity.setId(JDBCUtils.isNull(resultSet, offset + 0) ? null : resultSet.getLong(offset + 0));
-        entity.setSimpleInt(resultSet.getInt(offset + 1));
-        entity.setSimpleInteger(JDBCUtils.isNull(resultSet, offset + 2) ? null : resultSet.getInt(offset + 2));
-        entity.setSimpleStringNotNull(resultSet.getString(offset + 3));
-        entity.setSimpleString(JDBCUtils.isNull(resultSet, offset + 4) ? null : resultSet.getString(offset + 4));
-        entity.setIndexedString(JDBCUtils.isNull(resultSet, offset + 5) ? null : resultSet.getString(offset + 5));
-        entity.setIndexedStringAscUnique(JDBCUtils.isNull(resultSet, offset + 6) ? null : resultSet.getString(offset + 6));
-        entity.setSimpleDate(JDBCUtils.isNull(resultSet, offset + 7) ? null : new java.util.Date(resultSet.getLong(offset + 7)));
-        entity.setSimpleBoolean(JDBCUtils.isNull(resultSet, offset + 8) ? null : resultSet.getShort(offset + 8) != 0);
+		int index = 1;
+        entity.setId(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++));
+        entity.setSimpleInt(resultSet.getInt(offset + index++));
+        entity.setSimpleInteger(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getInt(offset + index++));
+        entity.setSimpleStringNotNull(resultSet.getString(offset + index++));
+        entity.setSimpleString(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getString(offset + index++));
+        entity.setIndexedString(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getString(offset + index++));
+        entity.setIndexedStringAscUnique(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getString(offset + index++));
+        entity.setSimpleDate(JDBCUtils.isNull(resultSet, offset + index) ? null : new java.util.Date(resultSet.getLong(offset + index++)));
+        entity.setSimpleBoolean(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getShort(offset + index++) != 0);
      }
     
     /** @inheritdoc */
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/ToManyEntity.java b/DaoTest/src-gen/de/greenrobot/daotest/ToManyEntity.java
index fc0e209b..68c7f06b 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/ToManyEntity.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/ToManyEntity.java
@@ -1,9 +1,9 @@
 package de.greenrobot.daotest;
 
 import java.sql.SQLException;
-import java.util.List;
 
-import de.greenrobot.dao.AbstractDao;
+import java.util.List;
+import de.greenrobot.daotest.DaoSession;
 import de.greenrobot.dao.DaoException;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
@@ -12,6 +12,7 @@
  */
 public class ToManyEntity {
 
+
     private Long id;
     private String sourceJoinProperty;
 
@@ -41,7 +42,7 @@ public ToManyEntity(Long id, String sourceJoinProperty) {
     /** called by internal mechanisms, do not call yourself. */
     public void __setDaoSession(DaoSession daoSession) {
         this.daoSession = daoSession;
-        myDao = daoSession != null ? daoSession.getToManyEntityDao() : null;
+        myDao = this.daoSession != null ? this.daoSession.getToManyEntityDao() : null;
     }
 
     public Long getId() {
@@ -60,8 +61,7 @@ public void setSourceJoinProperty(String sourceJoinProperty) {
         this.sourceJoinProperty = sourceJoinProperty;
     }
 
-    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. 
-     * @throws SQLException */
+    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
     public List<ToManyTargetEntity> getToManyTargetEntityList() throws SQLException {
         if (toManyTargetEntityList == null) {
             if (daoSession == null) {
@@ -83,8 +83,7 @@ public synchronized void resetToManyTargetEntityList() {
         toManyTargetEntityList = null;
     }
 
-    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. 
-     * @throws SQLException */
+    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
     public List<ToManyTargetEntity> getToManyDescList() throws SQLException {
         if (toManyDescList == null) {
             if (daoSession == null) {
@@ -106,8 +105,7 @@ public synchronized void resetToManyDescList() {
         toManyDescList = null;
     }
 
-    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. 
-     * @throws SQLException */
+    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
     public List<ToManyTargetEntity> getToManyByJoinProperty() throws SQLException {
         if (toManyByJoinProperty == null) {
             if (daoSession == null) {
@@ -129,8 +127,7 @@ public synchronized void resetToManyByJoinProperty() {
         toManyByJoinProperty = null;
     }
 
-    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. 
-     * @throws SQLException */
+    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
     public List<ToManyTargetEntity> getToManyJoinTwo() throws SQLException {
         if (toManyJoinTwo == null) {
             if (daoSession == null) {
@@ -152,8 +149,7 @@ public synchronized void resetToManyJoinTwo() {
         toManyJoinTwo = null;
     }
 
-    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. 
-     * @throws SQLException */
+    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
     public void delete() throws SQLException {
         if (myDao == null) {
             throw new DaoException("Entity is detached from DAO context");
@@ -161,8 +157,7 @@ public void delete() throws SQLException {
         myDao.delete(this);
     }
 
-    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. 
-     * @throws SQLException */
+    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
     public void update() throws SQLException {
         if (myDao == null) {
             throw new DaoException("Entity is detached from DAO context");
@@ -170,8 +165,7 @@ public void update() throws SQLException {
         myDao.update(this);
     }
 
-    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. 
-     * @throws SQLException */
+    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
     public void refresh() throws SQLException {
         if (myDao == null) {
             throw new DaoException("Entity is detached from DAO context");
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/ToManyEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/ToManyEntityDao.java
index 6baefd40..ccfed9c0 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/ToManyEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/ToManyEntityDao.java
@@ -1,15 +1,17 @@
 package de.greenrobot.daotest;
 
-import java.sql.Connection;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
+import java.sql.Connection;
+
+import de.greenrobot.platform.java.util.JDBCUtils;
 
-import android.database.sqlite.SQLiteDatabase;
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.Property;
 import de.greenrobot.dao.internal.DaoConfig;
-import de.greenrobot.platform.java.util.JDBCUtils;
+
+import de.greenrobot.daotest.ToManyEntity;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
@@ -28,8 +30,7 @@
         public final static Property SourceJoinProperty = new Property(1, String.class, "sourceJoinProperty", false, "SOURCE_JOIN_PROPERTY");
     };
 
-    private DaoSession daoSession;
-
+	private DaoSession daoSession;
 
     public ToManyEntityDao(DaoConfig config) {
         super(config);
@@ -40,8 +41,7 @@ public ToManyEntityDao(DaoConfig config, DaoSession daoSession) {
         this.daoSession = daoSession;
     }
 
-    /** Creates the underlying database table. 
-     * @throws SQLException */
+    /** Creates the underlying database table. */
     public static void createTable(Connection connection, boolean ifNotExists) throws SQLException {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
         JDBCUtils.execute( connection, "CREATE TABLE " + constraint + "'TO_MANY_ENTITY' (" + //
@@ -50,25 +50,22 @@ public static void createTable(Connection connection, boolean ifNotExists) throw
     }
 
     /** Drops the underlying database table. */
-    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
-        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'TO_MANY_ENTITY'";
-        db.execSQL(sql);
+    public static void dropTable(Connection connection, boolean ifExists) throws SQLException {
+        JDBCUtils.execute( connection, "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'TO_MANY_ENTITY'");
     }
 
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
-    protected void bindValues(PreparedStatement stmt, ToManyEntity entity) throws SQLException {
-//        stmt.clearBindings();
+    protected void bindValues(PreparedStatement statement, ToManyEntity entity) throws SQLException {
  
         Long id = entity.getId();
         if (id != null) {
-            stmt.setLong(1, id);
+            statement.setLong(1, id);
         }
  
         String sourceJoinProperty = entity.getSourceJoinProperty();
         if (sourceJoinProperty != null) {
-            stmt.setString(2, sourceJoinProperty);
+            statement.setString(2, sourceJoinProperty);
         }
     }
 
@@ -78,30 +75,30 @@ protected void attachEntity(ToManyEntity entity) {
         entity.__setDaoSession(daoSession);
     }
 
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
     public Long readKey(ResultSet resultSet, int offset) throws SQLException {
-        return JDBCUtils.isNull( resultSet, offset + 0) ? null : resultSet.getLong(offset + 0);
+    	int index = 1;
+        return JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++);
     }    
 
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
     public ToManyEntity readEntity(ResultSet resultSet, int offset) throws SQLException {
-        ToManyEntity entity = new ToManyEntity( //
-            JDBCUtils.isNull( resultSet, offset + 0) ? null : resultSet.getLong(offset + 0), // id
-            JDBCUtils.isNull( resultSet, offset + 1) ? null : resultSet.getString(offset + 1) // sourceJoinProperty
+		int index = 1;
+        ToManyEntity entity = new ToManyEntity(
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++), // id
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getString(offset + index++) // sourceJoinProperty
         );
         return entity;
     }
      
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
     public void readEntity(ResultSet resultSet, ToManyEntity entity, int offset) throws SQLException {
-        entity.setId(JDBCUtils.isNull( resultSet, offset + 0) ? null : resultSet.getLong(offset + 0));
-        entity.setSourceJoinProperty(JDBCUtils.isNull( resultSet, offset + 1) ? null : resultSet.getString(offset + 1));
+		int index = 1;
+        entity.setId(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++));
+        entity.setSourceJoinProperty(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getString(offset + index++));
      }
     
     /** @inheritdoc */
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/ToManyTargetEntity.java b/DaoTest/src-gen/de/greenrobot/daotest/ToManyTargetEntity.java
index ad585ffb..d51c6bd1 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/ToManyTargetEntity.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/ToManyTargetEntity.java
@@ -1,11 +1,13 @@
 package de.greenrobot.daotest;
 
+
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
 /**
  * Entity mapped to table TO_MANY_TARGET_ENTITY.
  */
 public class ToManyTargetEntity {
 
+
     private Long toManyId;
     private Long toManyIdDesc;
     private Long id;
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/ToManyTargetEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/ToManyTargetEntityDao.java
index 855d145a..c44a6510 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/ToManyTargetEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/ToManyTargetEntityDao.java
@@ -1,18 +1,20 @@
 package de.greenrobot.daotest;
 
-import java.sql.Connection;
+import java.util.List;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
-import java.util.List;
+import java.sql.Connection;
+
+import de.greenrobot.platform.java.util.JDBCUtils;
 
-import android.database.sqlite.SQLiteDatabase;
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.Property;
 import de.greenrobot.dao.internal.DaoConfig;
 import de.greenrobot.dao.query.Query;
 import de.greenrobot.dao.query.QueryBuilder;
-import de.greenrobot.platform.java.util.JDBCUtils;
+
+import de.greenrobot.daotest.ToManyTargetEntity;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
@@ -46,8 +48,7 @@ public ToManyTargetEntityDao(DaoConfig config, DaoSession daoSession) {
         super(config, daoSession);
     }
 
-    /** Creates the underlying database table. 
-     * @throws SQLException */
+    /** Creates the underlying database table. */
     public static void createTable(Connection connection, boolean ifNotExists) throws SQLException {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
         JDBCUtils.execute( connection, "CREATE TABLE " + constraint + "'TO_MANY_TARGET_ENTITY' (" + //
@@ -58,66 +59,63 @@ public static void createTable(Connection connection, boolean ifNotExists) throw
     }
 
     /** Drops the underlying database table. */
-    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
-        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'TO_MANY_TARGET_ENTITY'";
-        db.execSQL(sql);
+    public static void dropTable(Connection connection, boolean ifExists) throws SQLException {
+        JDBCUtils.execute( connection, "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'TO_MANY_TARGET_ENTITY'");
     }
 
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
-    protected void bindValues(PreparedStatement stmt, ToManyTargetEntity entity) throws SQLException {
-//        stmt.clearBindings();
+    protected void bindValues(PreparedStatement statement, ToManyTargetEntity entity) throws SQLException {
  
         Long toManyId = entity.getToManyId();
         if (toManyId != null) {
-            stmt.setLong(1, toManyId);
+            statement.setLong(1, toManyId);
         }
  
         Long toManyIdDesc = entity.getToManyIdDesc();
         if (toManyIdDesc != null) {
-            stmt.setLong(2, toManyIdDesc);
+            statement.setLong(2, toManyIdDesc);
         }
  
         Long id = entity.getId();
         if (id != null) {
-            stmt.setLong(3, id);
+            statement.setLong(3, id);
         }
  
         String targetJoinProperty = entity.getTargetJoinProperty();
         if (targetJoinProperty != null) {
-            stmt.setString(4, targetJoinProperty);
+            statement.setString(4, targetJoinProperty);
         }
     }
 
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
     public Long readKey(ResultSet resultSet, int offset) throws SQLException {
-        return JDBCUtils.isNull( resultSet, offset + 2) ? null : resultSet.getLong(offset + 2);
+    	int index = 1;
+        return JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++);
     }    
 
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
     public ToManyTargetEntity readEntity(ResultSet resultSet, int offset) throws SQLException {
-        ToManyTargetEntity entity = new ToManyTargetEntity( //
-            JDBCUtils.isNull( resultSet, offset + 0) ? null : resultSet.getLong(offset + 0), // toManyId
-            JDBCUtils.isNull( resultSet, offset + 1) ? null : resultSet.getLong(offset + 1), // toManyIdDesc
-            JDBCUtils.isNull( resultSet, offset + 2) ? null : resultSet.getLong(offset + 2), // id
-            JDBCUtils.isNull( resultSet, offset + 3) ? null : resultSet.getString(offset + 3) // targetJoinProperty
+		int index = 1;
+        ToManyTargetEntity entity = new ToManyTargetEntity(
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++), // toManyId
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++), // toManyIdDesc
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++), // id
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getString(offset + index++) // targetJoinProperty
         );
         return entity;
     }
      
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
     public void readEntity(ResultSet resultSet, ToManyTargetEntity entity, int offset) throws SQLException {
-        entity.setToManyId(JDBCUtils.isNull( resultSet, offset + 0) ? null : resultSet.getLong(offset + 0));
-        entity.setToManyIdDesc(JDBCUtils.isNull( resultSet, offset + 1) ? null : resultSet.getLong(offset + 1));
-        entity.setId(JDBCUtils.isNull( resultSet, offset + 2) ? null : resultSet.getLong(offset + 2));
-        entity.setTargetJoinProperty(JDBCUtils.isNull( resultSet, offset + 3) ? null : resultSet.getString(offset + 3));
+		int index = 1;
+        entity.setToManyId(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++));
+        entity.setToManyIdDesc(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++));
+        entity.setId(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++));
+        entity.setTargetJoinProperty(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getString(offset + index++));
      }
     
     /** @inheritdoc */
@@ -143,8 +141,7 @@ protected boolean isEntityUpdateable() {
         return true;
     }
     
-    /** Internal query to resolve the "toManyTargetEntityList" to-many relationship of ToManyEntity. 
-     * @throws SQLException */
+    /** Internal query to resolve the "toManyTargetEntityList" to-many relationship of ToManyEntity. */
     public List<ToManyTargetEntity> _queryToManyEntity_ToManyTargetEntityList(Long toManyId) throws SQLException {
         synchronized (this) {
             if (toManyEntity_ToManyTargetEntityListQuery == null) {
@@ -159,8 +156,7 @@ protected boolean isEntityUpdateable() {
         return query.list();
     }
 
-    /** Internal query to resolve the "toManyDescList" to-many relationship of ToManyEntity. 
-     * @throws SQLException */
+    /** Internal query to resolve the "toManyDescList" to-many relationship of ToManyEntity. */
     public List<ToManyTargetEntity> _queryToManyEntity_ToManyDescList(Long toManyIdDesc) throws SQLException {
         synchronized (this) {
             if (toManyEntity_ToManyDescListQuery == null) {
@@ -175,8 +171,7 @@ protected boolean isEntityUpdateable() {
         return query.list();
     }
 
-    /** Internal query to resolve the "toManyByJoinProperty" to-many relationship of ToManyEntity. 
-     * @throws SQLException */
+    /** Internal query to resolve the "toManyByJoinProperty" to-many relationship of ToManyEntity. */
     public List<ToManyTargetEntity> _queryToManyEntity_ToManyByJoinProperty(String targetJoinProperty) throws SQLException {
         synchronized (this) {
             if (toManyEntity_ToManyByJoinPropertyQuery == null) {
@@ -191,8 +186,7 @@ protected boolean isEntityUpdateable() {
         return query.list();
     }
 
-    /** Internal query to resolve the "toManyJoinTwo" to-many relationship of ToManyEntity. 
-     * @throws SQLException */
+    /** Internal query to resolve the "toManyJoinTwo" to-many relationship of ToManyEntity. */
     public List<ToManyTargetEntity> _queryToManyEntity_ToManyJoinTwo(Long toManyId, String targetJoinProperty) throws SQLException {
         synchronized (this) {
             if (toManyEntity_ToManyJoinTwoQuery == null) {
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/TreeEntity.java b/DaoTest/src-gen/de/greenrobot/daotest/TreeEntity.java
index 2820b803..d2be620e 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/TreeEntity.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/TreeEntity.java
@@ -1,9 +1,9 @@
 package de.greenrobot.daotest;
 
 import java.sql.SQLException;
-import java.util.List;
 
-import de.greenrobot.dao.AbstractDao;
+import java.util.List;
+import de.greenrobot.daotest.DaoSession;
 import de.greenrobot.dao.DaoException;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
@@ -12,6 +12,7 @@
  */
 public class TreeEntity {
 
+
     private Long id;
     private Long parentId;
 
@@ -41,7 +42,7 @@ public TreeEntity(Long id, Long parentId) {
     /** called by internal mechanisms, do not call yourself. */
     public void __setDaoSession(DaoSession daoSession) {
         this.daoSession = daoSession;
-        myDao = daoSession != null ? daoSession.getTreeEntityDao() : null;
+        myDao = this.daoSession != null ? this.daoSession.getTreeEntityDao() : null;
     }
 
     public Long getId() {
@@ -60,8 +61,7 @@ public void setParentId(Long parentId) {
         this.parentId = parentId;
     }
 
-    /** To-one relationship, resolved on first access. 
-     * @throws SQLException */
+    /** To-one relationship, resolved on first access. */
     public TreeEntity getParent() throws SQLException {
         Long __key = this.parentId;
         if (parent__resolvedKey == null || !parent__resolvedKey.equals(__key)) {
@@ -86,8 +86,7 @@ public void setParent(TreeEntity parent) {
         }
     }
 
-    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. 
-     * @throws SQLException */
+    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
     public List<TreeEntity> getChildren() throws SQLException {
         if (children == null) {
             if (daoSession == null) {
@@ -109,8 +108,7 @@ public synchronized void resetChildren() {
         children = null;
     }
 
-    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. 
-     * @throws SQLException */
+    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
     public void delete() throws SQLException {
         if (myDao == null) {
             throw new DaoException("Entity is detached from DAO context");
@@ -118,8 +116,7 @@ public void delete() throws SQLException {
         myDao.delete(this);
     }
 
-    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. 
-     * @throws SQLException */
+    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
     public void update() throws SQLException {
         if (myDao == null) {
             throw new DaoException("Entity is detached from DAO context");
@@ -127,8 +124,7 @@ public void update() throws SQLException {
         myDao.update(this);
     }
 
-    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. 
-     * @throws SQLException */
+    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
     public void refresh() throws SQLException {
         if (myDao == null) {
             throw new DaoException("Entity is detached from DAO context");
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/TreeEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/TreeEntityDao.java
index 8357aaca..22082d94 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/TreeEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/TreeEntityDao.java
@@ -1,20 +1,22 @@
 package de.greenrobot.daotest;
 
-import java.sql.Connection;
+import java.util.List;
+import java.util.ArrayList;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
-import java.util.ArrayList;
-import java.util.List;
+import java.sql.Connection;
+
+import de.greenrobot.platform.java.util.JDBCUtils;
 
-import android.database.sqlite.SQLiteDatabase;
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.Property;
-import de.greenrobot.dao.internal.DaoConfig;
 import de.greenrobot.dao.internal.SqlUtils;
+import de.greenrobot.dao.internal.DaoConfig;
 import de.greenrobot.dao.query.Query;
 import de.greenrobot.dao.query.QueryBuilder;
-import de.greenrobot.platform.java.util.JDBCUtils;
+
+import de.greenrobot.daotest.TreeEntity;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
@@ -33,8 +35,7 @@
         public final static Property ParentId = new Property(1, Long.class, "parentId", false, "PARENT_ID");
     };
 
-    private DaoSession daoSession;
-
+	private DaoSession daoSession;
     private Query<TreeEntity> treeEntity_ChildrenQuery;
 
     public TreeEntityDao(DaoConfig config) {
@@ -46,8 +47,7 @@ public TreeEntityDao(DaoConfig config, DaoSession daoSession) {
         this.daoSession = daoSession;
     }
 
-    /** Creates the underlying database table. 
-     * @throws SQLException */
+    /** Creates the underlying database table. */
     public static void createTable(Connection connection, boolean ifNotExists) throws SQLException {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
         JDBCUtils.execute( connection, "CREATE TABLE " + constraint + "'TREE_ENTITY' (" + //
@@ -56,25 +56,22 @@ public static void createTable(Connection connection, boolean ifNotExists) throw
     }
 
     /** Drops the underlying database table. */
-    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
-        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'TREE_ENTITY'";
-        db.execSQL(sql);
+    public static void dropTable(Connection connection, boolean ifExists) throws SQLException {
+        JDBCUtils.execute( connection, "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'TREE_ENTITY'");
     }
 
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
-    protected void bindValues(PreparedStatement stmt, TreeEntity entity) throws SQLException {
-//        stmt.clearBindings();
+    protected void bindValues(PreparedStatement statement, TreeEntity entity) throws SQLException {
  
         Long id = entity.getId();
         if (id != null) {
-            stmt.setLong(1, id);
+            statement.setLong(1, id);
         }
  
         Long parentId = entity.getParentId();
         if (parentId != null) {
-            stmt.setLong(2, parentId);
+            statement.setLong(2, parentId);
         }
     }
 
@@ -84,30 +81,30 @@ protected void attachEntity(TreeEntity entity) {
         entity.__setDaoSession(daoSession);
     }
 
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
     public Long readKey(ResultSet resultSet, int offset) throws SQLException {
-        return JDBCUtils.isNull( resultSet, offset + 0) ? null : resultSet.getLong(offset + 0);
+    	int index = 1;
+        return JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++);
     }    
 
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
     public TreeEntity readEntity(ResultSet resultSet, int offset) throws SQLException {
-        TreeEntity entity = new TreeEntity( //
-            JDBCUtils.isNull( resultSet, offset + 0) ? null : resultSet.getLong(offset + 0), // id
-            JDBCUtils.isNull( resultSet, offset + 1) ? null : resultSet.getLong(offset + 1) // parentId
+		int index = 1;
+        TreeEntity entity = new TreeEntity(
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++), // id
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++) // parentId
         );
         return entity;
     }
      
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
     public void readEntity(ResultSet resultSet, TreeEntity entity, int offset) throws SQLException {
-        entity.setId(JDBCUtils.isNull( resultSet, offset + 0) ? null : resultSet.getLong(offset + 0));
-        entity.setParentId(JDBCUtils.isNull( resultSet, offset + 1) ? null : resultSet.getLong(offset + 1));
+		int index = 1;
+        entity.setId(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++));
+        entity.setParentId(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++));
      }
     
     /** @inheritdoc */
@@ -133,8 +130,7 @@ protected boolean isEntityUpdateable() {
         return true;
     }
     
-    /** Internal query to resolve the "children" to-many relationship of TreeEntity. 
-     * @throws SQLException */
+    /** Internal query to resolve the "children" to-many relationship of TreeEntity. */
     public List<TreeEntity> _queryTreeEntity_Children(Long parentId) throws SQLException {
         synchronized (this) {
             if (treeEntity_ChildrenQuery == null) {
@@ -148,97 +144,96 @@ protected boolean isEntityUpdateable() {
         return query.list();
     }
 
-    private String selectDeep;
-
-    protected String getSelectDeep() {
-        if (selectDeep == null) {
-            StringBuilder builder = new StringBuilder("SELECT ");
-            SqlUtils.appendColumns(builder, "T", getAllColumns());
-            builder.append(',');
-            SqlUtils.appendColumns(builder, "T0", daoSession.getTreeEntityDao().getAllColumns());
-            builder.append(" FROM TREE_ENTITY T");
-            builder.append(" LEFT JOIN TREE_ENTITY T0 ON T.'PARENT_ID'=T0.'_id'");
-            builder.append(' ');
-            selectDeep = builder.toString();
-        }
-        return selectDeep;
-    }
-    
-    protected TreeEntity loadCurrentDeep(ResultSet resultSet, boolean lock) throws SQLException {
-        TreeEntity entity = loadCurrent(resultSet, 0, lock);
-        int offset = getAllColumns().length;
-
-        TreeEntity parent = loadCurrentOther(daoSession.getTreeEntityDao(), resultSet, offset);
-        entity.setParent(parent);
-
-        return entity;    
-    }
-
-    public TreeEntity loadDeep(Long key) throws SQLException {
-        assertSinglePk();
-        if (key == null) {
-            return null;
-        }
-
-        StringBuilder builder = new StringBuilder(getSelectDeep());
-        builder.append("WHERE ");
-        SqlUtils.appendColumnsEqValue(builder, "T", getPkColumns());
-        String sql = builder.toString();
-        
-        Object[] keyArray = new Object[] { key.toString() };
-        ResultSet resultSet = JDBCUtils.query( connection, sql, keyArray );
-        
-        try {
-            boolean available = resultSet.next();
-            if (!available) {
-                return null;
-            } else if (!resultSet.isLast()) {
-                throw new IllegalStateException("Expected unique result, but count was " + resultSet.getFetchSize());
-            }
-            return loadCurrentDeep(resultSet, true);
-        } finally {
-            resultSet.close();
-        }
-    }
-    
-    /** Reads all available rows from the given cursor and returns a list of new ImageTO objects. 
-     * @throws SQLException */
-    public List<TreeEntity> loadAllDeepFromCursor(ResultSet resultSet) throws SQLException {
-        int count = resultSet.getFetchSize();
-        List<TreeEntity> list = new ArrayList<TreeEntity>(count);
-        
-        if (resultSet.first()) {
-            if (identityScope != null) {
-                identityScope.lock();
-                identityScope.reserveRoom(count);
-            }
-            try {
-                do {
-                    list.add(loadCurrentDeep(resultSet, false));
-                } while (resultSet.next());
-            } finally {
-                if (identityScope != null) {
-                    identityScope.unlock();
-                }
-            }
-        }
-        return list;
-    }
-    
-    protected List<TreeEntity> loadDeepAllAndCloseCursor(ResultSet resultSet) throws SQLException {
-        try {
-            return loadAllDeepFromCursor(resultSet);
-        } finally {
-            resultSet.close();
-        }
-    }
-    
-
-    /** A raw-style query where you can pass any WHERE clause and arguments. 
-     * @throws SQLException */
-    public List<TreeEntity> queryDeep(String where, String... selectionArg) throws SQLException {
-        ResultSet resultset = JDBCUtils.query(connection, ( getSelectDeep() + where ), (Object[]) selectionArg);
-        return loadDeepAllAndCloseCursor(resultset);
-    }
- 
+    private String selectDeep;
+
+    protected String getSelectDeep() {
+        if (selectDeep == null) {
+            StringBuilder builder = new StringBuilder("SELECT ");
+            SqlUtils.appendColumns(builder, "T", getAllColumns());
+            builder.append(',');
+            SqlUtils.appendColumns(builder, "T0", daoSession.getTreeEntityDao().getAllColumns());
+            builder.append(" FROM TREE_ENTITY T");
+            builder.append(" LEFT JOIN TREE_ENTITY T0 ON T.'PARENT_ID'=T0.'_id'");
+            builder.append(' ');
+            selectDeep = builder.toString();
+        }
+        return selectDeep;
+    }
+    
+    protected TreeEntity loadCurrentDeep(ResultSet resultSet, boolean lock) throws SQLException {
+        TreeEntity entity = loadCurrent(resultSet, 0, lock);
+        int offset = getAllColumns().length;
+
+        TreeEntity parent = loadCurrentOther(daoSession.getTreeEntityDao(), resultSet, offset);
+        entity.setParent(parent);
+
+        return entity;    
+    }
+
+    public TreeEntity loadDeep(Long key) throws SQLException {
+        assertSinglePk();
+        if (key == null) {
+            return null;
+        }
+
+        StringBuilder builder = new StringBuilder(getSelectDeep());
+        builder.append("WHERE ");
+        SqlUtils.appendColumnsEqValue(builder, "T", getPkColumns());
+        String sql = builder.toString();
+        
+        String[] keyArray = new String[] { key.toString() };
+        ResultSet resultSet = JDBCUtils.query(connection, sql, (Object[]) keyArray);
+        
+        try {
+            boolean available = resultSet.next();
+            if (!available) {
+                return null;
+            } else if (!resultSet.isLast()) {
+                throw new IllegalStateException("Expected unique result, but count was " + JDBCUtils.getCount(resultSet));
+            }
+            return loadCurrentDeep(resultSet, true);
+        } finally {
+            resultSet.close();
+        }
+    }
+    
+    /** Reads all available rows from the given cursor and returns a list of new ImageTO objects. */
+    public List<TreeEntity> loadAllDeepFromResultSet(ResultSet resultSet) throws SQLException {
+        int count = JDBCUtils.getCount(resultSet);
+        List<TreeEntity> list = new ArrayList<TreeEntity>(count);
+        
+        if (resultSet.first()) {
+            if (identityScope != null) {
+                identityScope.lock();
+                identityScope.reserveRoom(count);
+            }
+            try {
+                do {
+                    list.add(loadCurrentDeep(resultSet, false));
+                } while (resultSet.next());
+            } finally {
+                if (identityScope != null) {
+                    identityScope.unlock();
+                }
+            }
+        }
+        return list;
+    }
+    
+    protected List<TreeEntity> loadDeepAllAndCloseResultSet(ResultSet resultSet) throws SQLException {
+        try {
+            return loadAllDeepFromResultSet(resultSet);
+        } finally {
+            resultSet.close();
+        }
+    }
+    
+
+    /** A raw-style query where you can pass any WHERE clause and arguments. */
+    public List<TreeEntity> queryDeep(String where, String... selectionArg) throws SQLException {
+    
+        ResultSet resultSet = JDBCUtils.query( connection, ( getSelectDeep() + where ), (Object[]) selectionArg );
+        return loadDeepAllAndCloseResultSet(resultSet);
+    }
+ 
 }
diff --git a/DaoTest/src-gen/de/greenrobot/daotest2/KeepEntity.java b/DaoTest/src-gen/de/greenrobot/daotest2/KeepEntity.java
index b3b185a8..ff1a75e3 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest2/KeepEntity.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest2/KeepEntity.java
@@ -1,19 +1,19 @@
 package de.greenrobot.daotest2;
 
+
 // THIS CODE IS GENERATED BY greenDAO, EDIT ONLY INSIDE THE "KEEP"-SECTIONS
 
 // KEEP INCLUDES - put your custom includes here
-import android.os.Build;
 // KEEP INCLUDES END
 /**
  * Entity mapped to table KEEP_ENTITY.
  */
 public class KeepEntity {
 
+
     private Long id;
 
     // KEEP FIELDS - put your custom fields here
-    String extra = Build.VERSION.SDK;
     // KEEP FIELDS END
 
     public KeepEntity() {
@@ -32,10 +32,6 @@ public void setId(Long id) {
     }
 
     // KEEP METHODS - put your custom methods here
-    @Override
-    public String toString() {
-        return "KeepEntity ID=42 (extra=" + extra + ")";
-    }
     // KEEP METHODS END
 
 }
diff --git a/DaoTest/src-gen/de/greenrobot/daotest2/ToManyTarget2.java b/DaoTest/src-gen/de/greenrobot/daotest2/ToManyTarget2.java
index 3265f8ec..cdad8234 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest2/ToManyTarget2.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest2/ToManyTarget2.java
@@ -1,5 +1,6 @@
 package de.greenrobot.daotest2;
 
+
 // THIS CODE IS GENERATED BY greenDAO, EDIT ONLY INSIDE THE "KEEP"-SECTIONS
 
 // KEEP INCLUDES - put your custom includes here
@@ -9,6 +10,7 @@
  */
 public class ToManyTarget2 {
 
+
     private Long id;
     private Long fkId;
 
diff --git a/DaoTest/src-gen/de/greenrobot/daotest2/dao/DaoMaster.java b/DaoTest/src-gen/de/greenrobot/daotest2/dao/DaoMaster.java
index 342fbd26..16b7a043 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest2/dao/DaoMaster.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest2/dao/DaoMaster.java
@@ -1,16 +1,15 @@
 package de.greenrobot.daotest2.dao;
 
 import java.sql.Connection;
+import java.sql.SQLException;
 
-import android.content.Context;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteDatabase.CursorFactory;
-import android.database.sqlite.SQLiteOpenHelper;
-import android.util.Log;
 import de.greenrobot.dao.AbstractDaoMaster;
 import de.greenrobot.dao.identityscope.IdentityScopeType;
-import de.greenrobot.daotest2.specialdao.RelationSource2Dao;
+
+import de.greenrobot.daotest2.dao.KeepEntityDao;
+import de.greenrobot.daotest2.dao.ToManyTarget2Dao;
 import de.greenrobot.daotest2.to1_specialdao.ToOneTarget2Dao;
+import de.greenrobot.daotest2.specialdao.RelationSource2Dao;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
@@ -20,48 +19,21 @@
     public static final int SCHEMA_VERSION = 1;
 
     /** Creates underlying database table using DAOs. */
-    public static void createAllTables(SQLiteDatabase db, boolean ifNotExists) {
-        KeepEntityDao.createTable(db, ifNotExists);
-        ToManyTarget2Dao.createTable(db, ifNotExists);
-        ToOneTarget2Dao.createTable(db, ifNotExists);
-        RelationSource2Dao.createTable(db, ifNotExists);
+    public static void createAllTables(Connection connection, boolean ifNotExists) throws SQLException {
+        KeepEntityDao.createTable(connection, ifNotExists);
+        ToManyTarget2Dao.createTable(connection, ifNotExists);
+        ToOneTarget2Dao.createTable(connection, ifNotExists);
+        RelationSource2Dao.createTable(connection, ifNotExists);
     }
     
     /** Drops underlying database table using DAOs. */
-    public static void dropAllTables(SQLiteDatabase db, boolean ifExists) {
-        KeepEntityDao.dropTable(db, ifExists);
-        ToManyTarget2Dao.dropTable(db, ifExists);
-        ToOneTarget2Dao.dropTable(db, ifExists);
-        RelationSource2Dao.dropTable(db, ifExists);
-    }
-    
-    public static abstract class OpenHelper extends SQLiteOpenHelper {
-
-        public OpenHelper(Context context, String name, CursorFactory factory) {
-            super(context, name, factory, SCHEMA_VERSION);
-        }
-
-        @Override
-        public void onCreate(SQLiteDatabase db) {
-            Log.i("greenDAO", "Creating tables for schema version " + SCHEMA_VERSION);
-            createAllTables(db, false);
-        }
+    public static void dropAllTables(Connection connection, boolean ifExists) throws SQLException {
+        KeepEntityDao.dropTable(connection, ifExists);
+        ToManyTarget2Dao.dropTable(connection, ifExists);
+        ToOneTarget2Dao.dropTable(connection, ifExists);
+        RelationSource2Dao.dropTable(connection, ifExists);
     }
     
-    /** WARNING: Drops all table on Upgrade! Use only during development. */
-    public static class DevOpenHelper extends OpenHelper {
-        public DevOpenHelper(Context context, String name, CursorFactory factory) {
-            super(context, name, factory);
-        }
-
-        @Override
-        public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
-            Log.i("greenDAO", "Upgrading schema from version " + oldVersion + " to " + newVersion + " by dropping all tables");
-            dropAllTables(db, true);
-            onCreate(db);
-        }
-    }
-
     public DaoMaster(Connection connection) {
         super(connection, SCHEMA_VERSION);
         registerDaoClass(KeepEntityDao.class);
diff --git a/DaoTest/src-gen/de/greenrobot/daotest2/dao/DaoSession.java b/DaoTest/src-gen/de/greenrobot/daotest2/dao/DaoSession.java
index 81a96cb8..c83909a2 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest2/dao/DaoSession.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest2/dao/DaoSession.java
@@ -7,12 +7,16 @@
 import de.greenrobot.dao.AbstractDaoSession;
 import de.greenrobot.dao.identityscope.IdentityScopeType;
 import de.greenrobot.dao.internal.DaoConfig;
+
 import de.greenrobot.daotest2.KeepEntity;
 import de.greenrobot.daotest2.ToManyTarget2;
-import de.greenrobot.daotest2.specialdao.RelationSource2Dao;
+import de.greenrobot.daotest2.to1_specialentity.ToOneTarget2;
 import de.greenrobot.daotest2.specialentity.RelationSource2;
+
+import de.greenrobot.daotest2.dao.KeepEntityDao;
+import de.greenrobot.daotest2.dao.ToManyTarget2Dao;
 import de.greenrobot.daotest2.to1_specialdao.ToOneTarget2Dao;
-import de.greenrobot.daotest2.to1_specialentity.ToOneTarget2;
+import de.greenrobot.daotest2.specialdao.RelationSource2Dao;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 
diff --git a/DaoTest/src-gen/de/greenrobot/daotest2/dao/KeepEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest2/dao/KeepEntityDao.java
index 40ebce17..f2c973b3 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest2/dao/KeepEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest2/dao/KeepEntityDao.java
@@ -3,13 +3,15 @@
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
+import java.sql.Connection;
+
+import de.greenrobot.platform.java.util.JDBCUtils;
 
-import android.database.sqlite.SQLiteDatabase;
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.Property;
 import de.greenrobot.dao.internal.DaoConfig;
+
 import de.greenrobot.daotest2.KeepEntity;
-import de.greenrobot.platform.java.util.JDBCUtils;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
@@ -37,52 +39,49 @@ public KeepEntityDao(DaoConfig config, DaoSession daoSession) {
     }
 
     /** Creates the underlying database table. */
-    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+    public static void createTable(Connection connection, boolean ifNotExists) throws SQLException {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
-        db.execSQL("CREATE TABLE " + constraint + "'KEEP_ENTITY' (" + //
+        JDBCUtils.execute( connection, "CREATE TABLE " + constraint + "'KEEP_ENTITY' (" + //
                 "'_id' INTEGER PRIMARY KEY );"); // 0: id
     }
 
     /** Drops the underlying database table. */
-    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
-        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'KEEP_ENTITY'";
-        db.execSQL(sql);
+    public static void dropTable(Connection connection, boolean ifExists) throws SQLException {
+        JDBCUtils.execute( connection, "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'KEEP_ENTITY'");
     }
 
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
-    protected void bindValues(PreparedStatement stmt, KeepEntity entity) throws SQLException {
-//        stmt.clearBindings();
+    protected void bindValues(PreparedStatement statement, KeepEntity entity) throws SQLException {
  
         Long id = entity.getId();
         if (id != null) {
-            stmt.setLong(1, id);
+            statement.setLong(1, id);
         }
     }
 
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
     public Long readKey(ResultSet resultSet, int offset) throws SQLException {
-        return JDBCUtils.isNull( resultSet, offset + 0) ? null : resultSet.getLong(offset + 0);
+    	int index = 1;
+        return JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++);
     }    
 
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
     public KeepEntity readEntity(ResultSet resultSet, int offset) throws SQLException {
-        KeepEntity entity = new KeepEntity( //
-        		JDBCUtils.isNull( resultSet, offset + 0) ? null : resultSet.getLong(offset + 0) // id
+		int index = 1;
+        KeepEntity entity = new KeepEntity(
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++) // id
         );
         return entity;
     }
      
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
     public void readEntity(ResultSet resultSet, KeepEntity entity, int offset) throws SQLException {
-        entity.setId(JDBCUtils.isNull( resultSet, offset + 0) ? null : resultSet.getLong(offset + 0));
+		int index = 1;
+        entity.setId(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++));
      }
     
     /** @inheritdoc */
diff --git a/DaoTest/src-gen/de/greenrobot/daotest2/dao/ToManyTarget2Dao.java b/DaoTest/src-gen/de/greenrobot/daotest2/dao/ToManyTarget2Dao.java
index 2c88068a..8d1ce6cc 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest2/dao/ToManyTarget2Dao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest2/dao/ToManyTarget2Dao.java
@@ -1,18 +1,20 @@
 package de.greenrobot.daotest2.dao;
 
+import java.util.List;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
-import java.util.List;
+import java.sql.Connection;
+
+import de.greenrobot.platform.java.util.JDBCUtils;
 
-import android.database.sqlite.SQLiteDatabase;
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.Property;
 import de.greenrobot.dao.internal.DaoConfig;
 import de.greenrobot.dao.query.Query;
 import de.greenrobot.dao.query.QueryBuilder;
+
 import de.greenrobot.daotest2.ToManyTarget2;
-import de.greenrobot.platform.java.util.JDBCUtils;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
@@ -42,60 +44,57 @@ public ToManyTarget2Dao(DaoConfig config, DaoSession daoSession) {
     }
 
     /** Creates the underlying database table. */
-    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+    public static void createTable(Connection connection, boolean ifNotExists) throws SQLException {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
-        db.execSQL("CREATE TABLE " + constraint + "'TO_MANY_TARGET2' (" + //
+        JDBCUtils.execute( connection, "CREATE TABLE " + constraint + "'TO_MANY_TARGET2' (" + //
                 "'_id' INTEGER PRIMARY KEY ," + // 0: id
                 "'FK_ID' INTEGER);"); // 1: fkId
     }
 
     /** Drops the underlying database table. */
-    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
-        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'TO_MANY_TARGET2'";
-        db.execSQL(sql);
+    public static void dropTable(Connection connection, boolean ifExists) throws SQLException {
+        JDBCUtils.execute( connection, "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'TO_MANY_TARGET2'");
     }
 
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
-    protected void bindValues(PreparedStatement stmt, ToManyTarget2 entity) throws SQLException {
-//        stmt.clearBindings();
+    protected void bindValues(PreparedStatement statement, ToManyTarget2 entity) throws SQLException {
  
         Long id = entity.getId();
         if (id != null) {
-            stmt.setLong(1, id);
+            statement.setLong(1, id);
         }
  
         Long fkId = entity.getFkId();
         if (fkId != null) {
-            stmt.setLong(2, fkId);
+            statement.setLong(2, fkId);
         }
     }
 
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
     public Long readKey(ResultSet resultSet, int offset) throws SQLException {
-        return JDBCUtils.isNull(resultSet, offset + 0) ? null : resultSet.getLong(offset + 0);
+    	int index = 1;
+        return JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++);
     }    
 
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
     public ToManyTarget2 readEntity(ResultSet resultSet, int offset) throws SQLException {
-        ToManyTarget2 entity = new ToManyTarget2( //
-            JDBCUtils.isNull(resultSet, offset + 0) ? null : resultSet.getLong(offset + 0), // id
-            JDBCUtils.isNull(resultSet, offset + 1) ? null : resultSet.getLong(offset + 1) // fkId
+		int index = 1;
+        ToManyTarget2 entity = new ToManyTarget2(
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++), // id
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++) // fkId
         );
         return entity;
     }
      
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
     public void readEntity(ResultSet resultSet, ToManyTarget2 entity, int offset) throws SQLException {
-        entity.setId(JDBCUtils.isNull(resultSet, offset + 0) ? null : resultSet.getLong(offset + 0));
-        entity.setFkId(JDBCUtils.isNull(resultSet, offset + 1) ? null : resultSet.getLong(offset + 1));
+		int index = 1;
+        entity.setId(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++));
+        entity.setFkId(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++));
      }
     
     /** @inheritdoc */
@@ -121,8 +120,7 @@ protected boolean isEntityUpdateable() {
         return true;
     }
     
-    /** Internal query to resolve the "toManyTarget2List" to-many relationship of RelationSource2. 
-     * @throws SQLException */
+    /** Internal query to resolve the "toManyTarget2List" to-many relationship of RelationSource2. */
     public List<ToManyTarget2> _queryRelationSource2_ToManyTarget2List(Long fkId) throws SQLException {
         synchronized (this) {
             if (relationSource2_ToManyTarget2ListQuery == null) {
diff --git a/DaoTest/src-gen/de/greenrobot/daotest2/specialdao/RelationSource2Dao.java b/DaoTest/src-gen/de/greenrobot/daotest2/specialdao/RelationSource2Dao.java
index fac9b87c..8644eb99 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest2/specialdao/RelationSource2Dao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest2/specialdao/RelationSource2Dao.java
@@ -1,20 +1,24 @@
 package de.greenrobot.daotest2.specialdao;
 
+import java.util.List;
+import java.util.ArrayList;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
-import java.util.ArrayList;
-import java.util.List;
+import java.sql.Connection;
+
+import de.greenrobot.platform.java.util.JDBCUtils;
 
-import android.database.sqlite.SQLiteDatabase;
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.Property;
-import de.greenrobot.dao.internal.DaoConfig;
 import de.greenrobot.dao.internal.SqlUtils;
+import de.greenrobot.dao.internal.DaoConfig;
+
 import de.greenrobot.daotest2.dao.DaoSession;
-import de.greenrobot.daotest2.specialentity.RelationSource2;
+
 import de.greenrobot.daotest2.to1_specialentity.ToOneTarget2;
-import de.greenrobot.platform.java.util.JDBCUtils;
+
+import de.greenrobot.daotest2.specialentity.RelationSource2;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
@@ -33,8 +37,7 @@
         public final static Property ToOneId = new Property(1, Long.class, "toOneId", false, "TO_ONE_ID");
     };
 
-    private DaoSession daoSession;
-
+	private DaoSession daoSession;
 
     public RelationSource2Dao(DaoConfig config) {
         super(config);
@@ -46,33 +49,30 @@ public RelationSource2Dao(DaoConfig config, DaoSession daoSession) {
     }
 
     /** Creates the underlying database table. */
-    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+    public static void createTable(Connection connection, boolean ifNotExists) throws SQLException {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
-        db.execSQL("CREATE TABLE " + constraint + "'RELATION_SOURCE2' (" + //
+        JDBCUtils.execute( connection, "CREATE TABLE " + constraint + "'RELATION_SOURCE2' (" + //
                 "'_id' INTEGER PRIMARY KEY ," + // 0: id
                 "'TO_ONE_ID' INTEGER);"); // 1: toOneId
     }
 
     /** Drops the underlying database table. */
-    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
-        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'RELATION_SOURCE2'";
-        db.execSQL(sql);
+    public static void dropTable(Connection connection, boolean ifExists) throws SQLException {
+        JDBCUtils.execute( connection, "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'RELATION_SOURCE2'");
     }
 
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
-    protected void bindValues(PreparedStatement stmt, RelationSource2 entity) throws SQLException {
-//        stmt.clearBindings();
+    protected void bindValues(PreparedStatement statement, RelationSource2 entity) throws SQLException {
  
         Long id = entity.getId();
         if (id != null) {
-            stmt.setLong(1, id);
+            statement.setLong(1, id);
         }
  
         Long toOneId = entity.getToOneId();
         if (toOneId != null) {
-            stmt.setLong(2, toOneId);
+            statement.setLong(2, toOneId);
         }
     }
 
@@ -82,30 +82,30 @@ protected void attachEntity(RelationSource2 entity) {
         entity.__setDaoSession(daoSession);
     }
 
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
     public Long readKey(ResultSet resultSet, int offset) throws SQLException {
-        return JDBCUtils.isNull( resultSet, offset + 0) ? null : resultSet.getLong(offset + 0);
+    	int index = 1;
+        return JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++);
     }    
 
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
     public RelationSource2 readEntity(ResultSet resultSet, int offset) throws SQLException {
-        RelationSource2 entity = new RelationSource2( //
-            JDBCUtils.isNull( resultSet, offset + 0) ? null : resultSet.getLong(offset + 0), // id
-            JDBCUtils.isNull( resultSet, offset + 1) ? null : resultSet.getLong(offset + 1) // toOneId
+		int index = 1;
+        RelationSource2 entity = new RelationSource2(
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++), // id
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++) // toOneId
         );
         return entity;
     }
      
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
     public void readEntity(ResultSet resultSet, RelationSource2 entity, int offset) throws SQLException {
-        entity.setId(JDBCUtils.isNull( resultSet, offset + 0) ? null : resultSet.getLong(offset + 0));
-        entity.setToOneId(JDBCUtils.isNull( resultSet, offset + 1) ? null : resultSet.getLong(offset + 1));
+		int index = 1;
+        entity.setId(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++));
+        entity.setToOneId(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++));
      }
     
     /** @inheritdoc */
@@ -131,97 +131,96 @@ protected boolean isEntityUpdateable() {
         return true;
     }
     
-    private String selectDeep;
-
-    protected String getSelectDeep() {
-        if (selectDeep == null) {
-            StringBuilder builder = new StringBuilder("SELECT ");
-            SqlUtils.appendColumns(builder, "T", getAllColumns());
-            builder.append(',');
-            SqlUtils.appendColumns(builder, "T0", daoSession.getToOneTarget2Dao().getAllColumns());
-            builder.append(" FROM RELATION_SOURCE2 T");
-            builder.append(" LEFT JOIN TO_ONE_TARGET2 T0 ON T.'TO_ONE_ID'=T0.'_id'");
-            builder.append(' ');
-            selectDeep = builder.toString();
-        }
-        return selectDeep;
-    }
-    
-    protected RelationSource2 loadCurrentDeep(ResultSet resultSet, boolean lock) throws SQLException {
-        RelationSource2 entity = loadCurrent(resultSet, 0, lock);
-        int offset = getAllColumns().length;
-
-        ToOneTarget2 toOneTarget2 = loadCurrentOther(daoSession.getToOneTarget2Dao(), resultSet, offset);
-        entity.setToOneTarget2(toOneTarget2);
-
-        return entity;    
-    }
-
-    public RelationSource2 loadDeep(Long key) throws SQLException {
-        assertSinglePk();
-        if (key == null) {
-            return null;
-        }
-
-        StringBuilder builder = new StringBuilder(getSelectDeep());
-        builder.append("WHERE ");
-        SqlUtils.appendColumnsEqValue(builder, "T", getPkColumns());
-        String sql = builder.toString();
-        
-        String[] keyArray = new String[] { key.toString() };
-        ResultSet resultSet = JDBCUtils.query( connection, sql, (Object[]) keyArray );
-        
-        try {
-            boolean available = resultSet.first();
-            if (!available) {
-                return null;
-            } else if (!resultSet.isLast()) {
-                throw new IllegalStateException("Expected unique result, but count was " + resultSet.getFetchSize());
-            }
-            return loadCurrentDeep(resultSet, true);
-        } finally {
-            resultSet.close();
-        }
-    }
-    
-    /** Reads all available rows from the given cursor and returns a list of new ImageTO objects. 
-     * @throws SQLException */
-    public List<RelationSource2> loadAllDeepFromCursor(ResultSet resultSet) throws SQLException {
-        int count = resultSet.getFetchSize();
-        List<RelationSource2> list = new ArrayList<RelationSource2>(count);
-        
-        if (resultSet.first()) {
-            if (identityScope != null) {
-                identityScope.lock();
-                identityScope.reserveRoom(count);
-            }
-            try {
-                do {
-                    list.add(loadCurrentDeep(resultSet, false));
-                } while (resultSet.next());
-            } finally {
-                if (identityScope != null) {
-                    identityScope.unlock();
-                }
-            }
-        }
-        return list;
-    }
-    
-    protected List<RelationSource2> loadDeepAllAndCloseCursor(ResultSet resultSet) throws SQLException {
-        try {
-            return loadAllDeepFromCursor(resultSet);
-        } finally {
-            resultSet.close();
-        }
-    }
-    
-
-    /** A raw-style query where you can pass any WHERE clause and arguments. 
-     * @throws SQLException */
-    public List<RelationSource2> queryDeep(String where, String... selectionArg) throws SQLException {
-        ResultSet resultSet = JDBCUtils.query(connection, getSelectDeep() + where, (Object[]) selectionArg);
-        return loadDeepAllAndCloseCursor(resultSet);
-    }
- 
+    private String selectDeep;
+
+    protected String getSelectDeep() {
+        if (selectDeep == null) {
+            StringBuilder builder = new StringBuilder("SELECT ");
+            SqlUtils.appendColumns(builder, "T", getAllColumns());
+            builder.append(',');
+            SqlUtils.appendColumns(builder, "T0", daoSession.getToOneTarget2Dao().getAllColumns());
+            builder.append(" FROM RELATION_SOURCE2 T");
+            builder.append(" LEFT JOIN TO_ONE_TARGET2 T0 ON T.'TO_ONE_ID'=T0.'_id'");
+            builder.append(' ');
+            selectDeep = builder.toString();
+        }
+        return selectDeep;
+    }
+    
+    protected RelationSource2 loadCurrentDeep(ResultSet resultSet, boolean lock) throws SQLException {
+        RelationSource2 entity = loadCurrent(resultSet, 0, lock);
+        int offset = getAllColumns().length;
+
+        ToOneTarget2 toOneTarget2 = loadCurrentOther(daoSession.getToOneTarget2Dao(), resultSet, offset);
+        entity.setToOneTarget2(toOneTarget2);
+
+        return entity;    
+    }
+
+    public RelationSource2 loadDeep(Long key) throws SQLException {
+        assertSinglePk();
+        if (key == null) {
+            return null;
+        }
+
+        StringBuilder builder = new StringBuilder(getSelectDeep());
+        builder.append("WHERE ");
+        SqlUtils.appendColumnsEqValue(builder, "T", getPkColumns());
+        String sql = builder.toString();
+        
+        String[] keyArray = new String[] { key.toString() };
+        ResultSet resultSet = JDBCUtils.query(connection, sql, (Object[]) keyArray);
+        
+        try {
+            boolean available = resultSet.next();
+            if (!available) {
+                return null;
+            } else if (!resultSet.isLast()) {
+                throw new IllegalStateException("Expected unique result, but count was " + JDBCUtils.getCount(resultSet));
+            }
+            return loadCurrentDeep(resultSet, true);
+        } finally {
+            resultSet.close();
+        }
+    }
+    
+    /** Reads all available rows from the given cursor and returns a list of new ImageTO objects. */
+    public List<RelationSource2> loadAllDeepFromResultSet(ResultSet resultSet) throws SQLException {
+        int count = JDBCUtils.getCount(resultSet);
+        List<RelationSource2> list = new ArrayList<RelationSource2>(count);
+        
+        if (resultSet.first()) {
+            if (identityScope != null) {
+                identityScope.lock();
+                identityScope.reserveRoom(count);
+            }
+            try {
+                do {
+                    list.add(loadCurrentDeep(resultSet, false));
+                } while (resultSet.next());
+            } finally {
+                if (identityScope != null) {
+                    identityScope.unlock();
+                }
+            }
+        }
+        return list;
+    }
+    
+    protected List<RelationSource2> loadDeepAllAndCloseResultSet(ResultSet resultSet) throws SQLException {
+        try {
+            return loadAllDeepFromResultSet(resultSet);
+        } finally {
+            resultSet.close();
+        }
+    }
+    
+
+    /** A raw-style query where you can pass any WHERE clause and arguments. */
+    public List<RelationSource2> queryDeep(String where, String... selectionArg) throws SQLException {
+    
+        ResultSet resultSet = JDBCUtils.query( connection, ( getSelectDeep() + where ), (Object[]) selectionArg );
+        return loadDeepAllAndCloseResultSet(resultSet);
+    }
+ 
 }
diff --git a/DaoTest/src-gen/de/greenrobot/daotest2/specialentity/RelationSource2.java b/DaoTest/src-gen/de/greenrobot/daotest2/specialentity/RelationSource2.java
index f72725d9..a07feadd 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest2/specialentity/RelationSource2.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest2/specialentity/RelationSource2.java
@@ -1,12 +1,12 @@
 package de.greenrobot.daotest2.specialentity;
 
 import java.sql.SQLException;
-import java.util.List;
 
-import de.greenrobot.dao.AbstractDao;
+import java.util.List;
+import de.greenrobot.daotest2.dao.DaoSession;
 import de.greenrobot.dao.DaoException;
+
 import de.greenrobot.daotest2.ToManyTarget2;
-import de.greenrobot.daotest2.dao.DaoSession;
 import de.greenrobot.daotest2.dao.ToManyTarget2Dao;
 import de.greenrobot.daotest2.specialdao.RelationSource2Dao;
 import de.greenrobot.daotest2.to1_specialdao.ToOneTarget2Dao;
@@ -21,6 +21,7 @@
  */
 public class RelationSource2 {
 
+
     private Long id;
     private Long toOneId;
 
@@ -53,7 +54,7 @@ public RelationSource2(Long id, Long toOneId) {
     /** called by internal mechanisms, do not call yourself. */
     public void __setDaoSession(DaoSession daoSession) {
         this.daoSession = daoSession;
-        myDao = daoSession != null ? daoSession.getRelationSource2Dao() : null;
+        myDao = this.daoSession != null ? this.daoSession.getRelationSource2Dao() : null;
     }
 
     public Long getId() {
@@ -72,8 +73,7 @@ public void setToOneId(Long toOneId) {
         this.toOneId = toOneId;
     }
 
-    /** To-one relationship, resolved on first access. 
-     * @throws SQLException */
+    /** To-one relationship, resolved on first access. */
     public ToOneTarget2 getToOneTarget2() throws SQLException {
         Long __key = this.toOneId;
         if (toOneTarget2__resolvedKey == null || !toOneTarget2__resolvedKey.equals(__key)) {
@@ -98,8 +98,7 @@ public void setToOneTarget2(ToOneTarget2 toOneTarget2) {
         }
     }
 
-    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. 
-     * @throws SQLException */
+    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
     public List<ToManyTarget2> getToManyTarget2List() throws SQLException {
         if (toManyTarget2List == null) {
             if (daoSession == null) {
@@ -121,8 +120,7 @@ public synchronized void resetToManyTarget2List() {
         toManyTarget2List = null;
     }
 
-    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. 
-     * @throws SQLException */
+    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
     public void delete() throws SQLException {
         if (myDao == null) {
             throw new DaoException("Entity is detached from DAO context");
@@ -130,8 +128,7 @@ public void delete() throws SQLException {
         myDao.delete(this);
     }
 
-    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. 
-     * @throws SQLException */
+    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
     public void update() throws SQLException {
         if (myDao == null) {
             throw new DaoException("Entity is detached from DAO context");
@@ -139,8 +136,7 @@ public void update() throws SQLException {
         myDao.update(this);
     }
 
-    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. 
-     * @throws SQLException */
+    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
     public void refresh() throws SQLException {
         if (myDao == null) {
             throw new DaoException("Entity is detached from DAO context");
diff --git a/DaoTest/src-gen/de/greenrobot/daotest2/to1_specialdao/ToOneTarget2Dao.java b/DaoTest/src-gen/de/greenrobot/daotest2/to1_specialdao/ToOneTarget2Dao.java
index b1ea4ea8..b8814897 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest2/to1_specialdao/ToOneTarget2Dao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest2/to1_specialdao/ToOneTarget2Dao.java
@@ -3,14 +3,17 @@
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
+import java.sql.Connection;
+
+import de.greenrobot.platform.java.util.JDBCUtils;
 
-import android.database.sqlite.SQLiteDatabase;
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.Property;
 import de.greenrobot.dao.internal.DaoConfig;
+
 import de.greenrobot.daotest2.dao.DaoSession;
+
 import de.greenrobot.daotest2.to1_specialentity.ToOneTarget2;
-import de.greenrobot.platform.java.util.JDBCUtils;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
@@ -38,52 +41,49 @@ public ToOneTarget2Dao(DaoConfig config, DaoSession daoSession) {
     }
 
     /** Creates the underlying database table. */
-    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+    public static void createTable(Connection connection, boolean ifNotExists) throws SQLException {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
-        db.execSQL("CREATE TABLE " + constraint + "'TO_ONE_TARGET2' (" + //
+        JDBCUtils.execute( connection, "CREATE TABLE " + constraint + "'TO_ONE_TARGET2' (" + //
                 "'_id' INTEGER PRIMARY KEY );"); // 0: id
     }
 
     /** Drops the underlying database table. */
-    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
-        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'TO_ONE_TARGET2'";
-        db.execSQL(sql);
+    public static void dropTable(Connection connection, boolean ifExists) throws SQLException {
+        JDBCUtils.execute( connection, "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'TO_ONE_TARGET2'");
     }
 
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
-    protected void bindValues(PreparedStatement stmt, ToOneTarget2 entity) throws SQLException {
-//        stmt.clearBindings();
+    protected void bindValues(PreparedStatement statement, ToOneTarget2 entity) throws SQLException {
  
         Long id = entity.getId();
         if (id != null) {
-            stmt.setLong(1, id);
+            statement.setLong(1, id);
         }
     }
 
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
     public Long readKey(ResultSet resultSet, int offset) throws SQLException {
-        return JDBCUtils.isNull(resultSet, offset + 0) ? null : resultSet.getLong(offset + 0);
+    	int index = 1;
+        return JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++);
     }    
 
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
     public ToOneTarget2 readEntity(ResultSet resultSet, int offset) throws SQLException {
-        ToOneTarget2 entity = new ToOneTarget2( //
-        		JDBCUtils.isNull(resultSet, offset + 0) ? null : resultSet.getLong(offset + 0) // id
+		int index = 1;
+        ToOneTarget2 entity = new ToOneTarget2(
+            JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++) // id
         );
         return entity;
     }
      
-    /** @throws SQLException 
-     * @inheritdoc */
+    /** @inheritdoc */
     @Override
     public void readEntity(ResultSet resultSet, ToOneTarget2 entity, int offset) throws SQLException {
-        entity.setId(JDBCUtils.isNull(resultSet, offset + 0) ? null : resultSet.getLong(offset + 0));
+		int index = 1;
+        entity.setId(JDBCUtils.isNull(resultSet, offset + index) ? null : resultSet.getLong(offset + index++));
      }
     
     /** @inheritdoc */
diff --git a/DaoTest/src-gen/de/greenrobot/daotest2/to1_specialentity/ToOneTarget2.java b/DaoTest/src-gen/de/greenrobot/daotest2/to1_specialentity/ToOneTarget2.java
index d5444c79..0988defc 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest2/to1_specialentity/ToOneTarget2.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest2/to1_specialentity/ToOneTarget2.java
@@ -1,5 +1,6 @@
 package de.greenrobot.daotest2.to1_specialentity;
 
+
 // THIS CODE IS GENERATED BY greenDAO, EDIT ONLY INSIDE THE "KEEP"-SECTIONS
 
 // KEEP INCLUDES - put your custom includes here
@@ -9,6 +10,7 @@
  */
 public class ToOneTarget2 {
 
+
     private Long id;
 
     // KEEP FIELDS - put your custom fields here
diff --git a/DaoTest/src/de/greenrobot/daotest/DaoSessionConcurrentTest.java b/DaoTest/src/de/greenrobot/daotest/DaoSessionConcurrentTest.java
deleted file mode 100644
index 004a3d3d..00000000
--- a/DaoTest/src/de/greenrobot/daotest/DaoSessionConcurrentTest.java
+++ /dev/null
@@ -1,550 +0,0 @@
-package de.greenrobot.daotest;
-
-import java.sql.Connection;
-import java.sql.PreparedStatement;
-import java.sql.SQLException;
-import java.util.concurrent.CountDownLatch;
-
-import android.os.SystemClock;
-import de.greenrobot.dao.DaoLog;
-import de.greenrobot.dao.query.DeleteQuery;
-import de.greenrobot.dao.query.Query;
-import de.greenrobot.dao.test.AbstractDaoSessionTest;
-
-public class DaoSessionConcurrentTest extends AbstractDaoSessionTest<DaoMaster, DaoSession> {
-    class TestThread extends Thread {
-        final Runnable runnable;
-
-        public TestThread(Runnable runnable) {
-            this.runnable = runnable;
-        }
-
-        @Override
-        public void run() {
-            latchThreadsReady.countDown();
-            try {
-                latchInsideTx.await();
-            } catch (InterruptedException e) {
-                throw new RuntimeException(e);
-            }
-            runnable.run();
-            latchThreadsDone.countDown();
-        }
-
-    }
-
-    private final static int TIME_TO_WAIT_FOR_THREAD = 100; // Use 1000 to be on the safe side, 100 once stable
-
-    protected TestEntityDao dao;
-
-    protected CountDownLatch latchThreadsReady;
-    protected CountDownLatch latchInsideTx;
-    protected CountDownLatch latchThreadsDone;
-
-    public DaoSessionConcurrentTest() {
-        super(DaoMaster.class);
-    }
-
-    @Override
-    protected void setUp() throws Exception {
-        super.setUp();
-        dao = daoSession.getTestEntityDao();
-    }
-
-    protected void initThreads(Runnable... runnables) throws InterruptedException {
-        latchThreadsReady = new CountDownLatch(runnables.length);
-        latchInsideTx = new CountDownLatch(1);
-        latchThreadsDone = new CountDownLatch(runnables.length);
-        for (Runnable runnable : runnables) {
-            new TestThread(runnable).start();
-        }
-        latchThreadsReady.await();
-    }
-
-    public void testConcurrentInsertDuringTx() throws InterruptedException, SQLException {
-        Runnable runnable1 = new Runnable() {
-            @Override
-            public void run() {
-                try
-				{
-					dao.insert(createEntity(null));
-				}
-				catch ( SQLException e )
-				{
-					e.printStackTrace();
-				}
-            }
-        };
-        Runnable runnable2 = new Runnable() {
-            @Override
-            public void run() {
-                try
-				{
-					dao.insertInTx(createEntity(null));
-				}
-				catch ( SQLException e )
-				{
-					e.printStackTrace();
-				}
-            }
-        };
-        Runnable runnable3 = new Runnable() {
-            @Override
-            public void run() {
-                try
-				{
-					daoSession.runInTx(new Runnable() {
-					    @Override
-					    public void run() {
-					        try
-							{
-								dao.insert(createEntity(null));
-							}
-							catch ( SQLException e )
-							{
-								e.printStackTrace();
-							}
-					    }
-					});
-				}
-				catch ( SQLException e )
-				{
-					e.printStackTrace();
-				}
-            }
-        };
-        Runnable runnable4 = new Runnable() {
-            @Override
-            public void run() {
-                try
-				{
-					dao.insertWithoutSettingPk(createEntity(null));
-				}
-				catch ( SQLException e )
-				{
-					e.printStackTrace();
-				}
-            }
-        };
-        Runnable runnable5 = new Runnable() {
-            @Override
-            public void run() {
-                try
-				{
-					dao.insertOrReplace(createEntity(null));
-				}
-				catch ( SQLException e )
-				{
-					e.printStackTrace();
-				}
-            }
-        };
-        initThreads(runnable1, runnable2, runnable3, runnable4, runnable5);
-        // Builds the statement so it is ready immediately in the thread
-        dao.insert(createEntity(null));
-        doTx(new Runnable() {
-            @Override
-            public void run() {
-                try
-				{
-					dao.insert(createEntity(null));
-				}
-				catch ( SQLException e )
-				{
-					e.printStackTrace();
-				}
-            }
-        });
-        latchThreadsDone.await();
-        assertEquals(7, dao.count());
-    }
-
-    public void testConcurrentUpdateDuringTx() throws InterruptedException, SQLException {
-        final TestEntity entity = createEntity(null);
-        dao.insert(entity);
-        Runnable runnable1 = new Runnable() {
-            @Override
-            public void run() {
-                try
-				{
-					dao.update(entity);
-				}
-				catch ( SQLException e )
-				{
-					e.printStackTrace();
-				}
-            }
-        };
-        Runnable runnable2 = new Runnable() {
-            @Override
-            public void run() {
-                try
-				{
-					dao.updateInTx(entity);
-				}
-				catch ( SQLException e )
-				{
-					e.printStackTrace();
-				}
-            }
-        };
-        Runnable runnable3 = new Runnable() {
-            @Override
-            public void run() {
-                try
-				{
-					daoSession.runInTx(new Runnable() {
-					    @Override
-					    public void run() {
-					        try
-							{
-								dao.update(entity);
-							}
-							catch ( SQLException e )
-							{
-								e.printStackTrace();
-							}
-					    }
-					});
-				}
-				catch ( SQLException e )
-				{
-					e.printStackTrace();
-				}
-            }
-        };
-        initThreads(runnable1, runnable2, runnable3);
-        // Builds the statement so it is ready immediately in the thread
-        dao.update(entity);
-        doTx(new Runnable() {
-            @Override
-            public void run() {
-                try
-				{
-					dao.update(entity);
-				}
-				catch ( SQLException e )
-				{
-					e.printStackTrace();
-				}
-            }
-        });
-        latchThreadsDone.await();
-    }
-
-    public void testConcurrentDeleteDuringTx() throws InterruptedException, SQLException {
-        final TestEntity entity = createEntity(null);
-        dao.insert(entity);
-        Runnable runnable1 = new Runnable() {
-            @Override
-            public void run() {
-                try
-				{
-					dao.delete(entity);
-				}
-				catch ( SQLException e )
-				{
-					e.printStackTrace();
-				}
-            }
-        };
-        Runnable runnable2 = new Runnable() {
-            @Override
-            public void run() {
-                try
-				{
-					dao.deleteInTx(entity);
-				}
-				catch ( SQLException e )
-				{
-					e.printStackTrace();
-				}
-            }
-        };
-        Runnable runnable3 = new Runnable() {
-            @Override
-            public void run() {
-                try
-				{
-					daoSession.runInTx(new Runnable() {
-					    @Override
-					    public void run() {
-					        try
-							{
-								dao.delete(entity);
-							}
-							catch ( SQLException e )
-							{
-								e.printStackTrace();
-							}
-					    }
-					});
-				}
-				catch ( SQLException e )
-				{
-					e.printStackTrace();
-				}
-            }
-        };
-        initThreads(runnable1, runnable2, runnable3);
-        // Builds the statement so it is ready immediately in the thread
-        dao.delete(entity);
-        doTx(new Runnable() {
-            @Override
-            public void run() {
-                try
-				{
-					dao.delete(entity);
-				}
-				catch ( SQLException e )
-				{
-					e.printStackTrace();
-				}
-            }
-        });
-        latchThreadsDone.await();
-    }
-
-    // Query doesn't involve any statement locking currently, but just to stay on the safe side...
-    public void testConcurrentQueryDuringTx() throws InterruptedException, SQLException {
-        final TestEntity entity = createEntity(null);
-        dao.insert(entity);
-        final Query<TestEntity> query = dao.queryBuilder().build();
-        Runnable runnable1 = new Runnable() {
-            @Override
-            public void run() {
-                try
-				{
-					query.forCurrentThread().list();
-				}
-				catch ( SQLException e )
-				{
-					e.printStackTrace();
-				}
-            }
-        };
-
-        initThreads(runnable1);
-        // Builds the statement so it is ready immediately in the thread
-        query.list();
-        doTx(new Runnable() {
-            @Override
-            public void run() {
-                try
-				{
-					query.list();
-				}
-				catch ( SQLException e )
-				{
-					e.printStackTrace();
-				}
-            }
-        });
-        latchThreadsDone.await();
-    }
-
-    // No connection for read can be acquired while TX is active; this will deadlock!
-    public void _testConcurrentLockAndQueryDuringTx() throws InterruptedException, SQLException {
-        final TestEntity entity = createEntity(null);
-        dao.insert(entity);
-        final Query<TestEntity> query = dao.queryBuilder().build();
-        Runnable runnable1 = new Runnable() {
-            @Override
-            public void run() {
-                synchronized (query) {
-                    try
-					{
-						query.list();
-					}
-					catch ( SQLException e )
-					{
-						e.printStackTrace();
-					}
-                }
-            }
-        };
-
-        initThreads(runnable1);
-        // Builds the statement so it is ready immediately in the thread
-        query.list();
-        doTx(new Runnable() {
-            @Override
-            public void run() {
-                synchronized (query) {
-                    try
-					{
-						query.list();
-					}
-					catch ( SQLException e )
-					{
-						e.printStackTrace();
-					}
-                }
-            }
-        });
-        latchThreadsDone.await();
-    }
-
-    public void testConcurrentDeleteQueryDuringTx() throws InterruptedException, SQLException {
-        final TestEntity entity = createEntity(null);
-        dao.insert(entity);
-        final DeleteQuery<TestEntity> query = dao.queryBuilder().buildDelete();
-        Runnable runnable1 = new Runnable() {
-            @Override
-            public void run() {
-                try
-				{
-					query.forCurrentThread().executeDeleteWithoutDetachingEntities();
-				}
-				catch ( SQLException e )
-				{
-					e.printStackTrace();
-				}
-            }
-        };
-
-        initThreads(runnable1);
-        // Builds the statement so it is ready immediately in the thread
-        query.executeDeleteWithoutDetachingEntities();
-        doTx(new Runnable() {
-            @Override
-            public void run() {
-                try
-				{
-					query.executeDeleteWithoutDetachingEntities();
-				}
-				catch ( SQLException e )
-				{
-					e.printStackTrace();
-				}
-            }
-        });
-        latchThreadsDone.await();
-    }
-
-    public void testConcurrentResolveToMany() throws InterruptedException, SQLException {
-        final ToManyEntity entity = new ToManyEntity();
-        ToManyEntityDao toManyDao = daoSession.getToManyEntityDao();
-        toManyDao.insert(entity);
-
-        Runnable runnable1 = new Runnable() {
-            @Override
-            public void run() {
-                try
-				{
-					entity.getToManyTargetEntityList();
-				}
-				catch ( SQLException e )
-				{
-					e.printStackTrace();
-				}
-            }
-        };
-
-        initThreads(runnable1);
-        doTx(new Runnable() {
-            @Override
-            public void run() {
-                try
-				{
-					entity.getToManyTargetEntityList();
-				}
-				catch ( SQLException e )
-				{
-					e.printStackTrace();
-				}
-            }
-        });
-        latchThreadsDone.await();
-    }
-
-    public void testConcurrentResolveToOne() throws InterruptedException, SQLException {
-        final TreeEntity entity = new TreeEntity();
-        TreeEntityDao toOneDao = daoSession.getTreeEntityDao();
-        toOneDao.insert(entity);
-
-        Runnable runnable1 = new Runnable() {
-            @Override
-            public void run() {
-                try
-				{
-					entity.getParent();
-				}
-				catch ( SQLException e )
-				{
-					e.printStackTrace();
-				}
-            }
-        };
-
-        initThreads(runnable1);
-        doTx(new Runnable() {
-            @Override
-            public void run() {
-                try
-				{
-					entity.getParent();
-				}
-				catch ( SQLException e )
-				{
-					e.printStackTrace();
-				}
-            }
-        });
-        latchThreadsDone.await();
-    }
-
-    /**
-     * We could put the statements inside ThreadLocals (fast enough), but it comes with initialization penalty for new
-     * threads and costs more memory.
-     */
-    public void _testThreadLocalSpeed() {
-        final Connection connection = dao.getConnection();
-        ThreadLocal<PreparedStatement> threadLocal = new ThreadLocal<PreparedStatement>() {
-            @Override
-            protected PreparedStatement initialValue() {
-                try
-				{
-					return connection.prepareStatement("SELECT 42");
-				}
-				catch ( SQLException e )
-				{
-					e.printStackTrace();
-					return null;
-				}
-            }
-        };
-        threadLocal.get();
-        long start = SystemClock.currentThreadTimeMillis();
-        for (int i = 0; i < 1000; i++) {
-        	PreparedStatement sqLiteStatement = threadLocal.get();
-            assertNotNull(sqLiteStatement);
-        }
-        Long time = SystemClock.currentThreadTimeMillis() - start;
-        DaoLog.d("TIME: " + time + "ms");
-        // Around 1ms on a S3
-        assertTrue(time < 10);
-    }
-
-    protected void doTx(final Runnable runnableInsideTx) throws SQLException {
-        daoSession.runInTx(new Runnable() {
-            @Override
-            public void run() {
-                latchInsideTx.countDown();
-                // Give the concurrent thread time so it will try to acquire locks
-                try {
-                    Thread.sleep(TIME_TO_WAIT_FOR_THREAD);
-                } catch (InterruptedException e) {
-                    throw new RuntimeException(e);
-                }
-                runnableInsideTx.run();
-            }
-        });
-    }
-
-    protected TestEntity createEntity(Long key) {
-        TestEntity entity = new TestEntity(key);
-        entity.setSimpleStringNotNull("green");
-        return entity;
-    }
-}
diff --git a/DaoTest/src/de/greenrobot/daotest/DaoSessionConcurrentWALTest.java b/DaoTest/src/de/greenrobot/daotest/DaoSessionConcurrentWALTest.java
deleted file mode 100644
index b870495d..00000000
--- a/DaoTest/src/de/greenrobot/daotest/DaoSessionConcurrentWALTest.java
+++ /dev/null
@@ -1,55 +0,0 @@
-package de.greenrobot.daotest;
-
-
-public class DaoSessionConcurrentWALTest extends DaoSessionConcurrentTest {
-
-// FIXME is there a WriteAheadLogging on JDBC?
-//    @Override
-//    protected SQLiteDatabase createDatabase() {
-//        int MODE_ENABLE_WRITE_AHEAD_LOGGING = 8;
-//        getContext().deleteDatabase(DB_NAME);
-//        return getContext().openOrCreateDatabase(DB_NAME, MODE_ENABLE_WRITE_AHEAD_LOGGING, null);
-//    }
-//
-//    public void testConcurrentLockAndQueryDuringTxWAL() throws InterruptedException {
-//        if (Build.VERSION.SDK_INT >= 16) {
-//            try {
-//                Method method = db.getClass().getMethod("isWriteAheadLoggingEnabled");
-//                boolean walEnabled = (Boolean) method.invoke(db);
-//                if (!walEnabled) {
-//                    throw new RuntimeException("WAL is disabled. This test will deadlock without WAL");
-//                }
-//            } catch (Exception e) {
-//                throw new RuntimeException(e);
-//            }
-//        } else {
-//            DaoLog.e("Sorry, we need at least API level 16 for WAL");
-//            return;
-//        }
-//
-//        final TestEntity entity = createEntity(null);
-//        dao.insert(entity);
-//        final Query<TestEntity> query = dao.queryBuilder().build();
-//        Runnable runnable1 = new Runnable() {
-//            @Override
-//            public void run() {
-//                synchronized (query) {
-//                    query.forCurrentThread().list();
-//                }
-//            }
-//        };
-//
-//        initThreads(runnable1);
-//        // Builds the statement so it is ready immediately in the thread
-//        query.list();
-//        doTx(new Runnable() {
-//            @Override
-//            public void run() {
-//                synchronized (query) {
-//                    query.list();
-//                }
-//            }
-//        });
-//        latchThreadsDone.await();
-//    }
-}
diff --git a/DaoTest/src/de/greenrobot/daotest/DaoSessionTest.java b/DaoTest/src/de/greenrobot/daotest/DaoSessionTest.java
deleted file mode 100644
index a2a2e041..00000000
--- a/DaoTest/src/de/greenrobot/daotest/DaoSessionTest.java
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daotest;
-
-import java.sql.SQLException;
-
-import de.greenrobot.dao.test.AbstractDaoSessionTest;
-
-public class DaoSessionTest extends AbstractDaoSessionTest<DaoMaster, DaoSession> {
-
-    public DaoSessionTest() {
-        super(DaoMaster.class);
-    }
-
-    public void testInsertAndLoad() throws SQLException {
-        SimpleEntity entity = new SimpleEntity();
-        daoSession.insert(entity);
-        Long id = entity.getId();
-        assertNotNull(id);
-        SimpleEntity entity2 = daoSession.load(SimpleEntity.class, id);
-        assertNotNull(entity2);
-    }
-
-    public void testIdentity() throws SQLException {
-        SimpleEntity entity = new SimpleEntity();
-        daoSession.insert(entity);
-        SimpleEntity entity2 = daoSession.load(SimpleEntity.class, entity.getId());
-        SimpleEntity entity3 = daoSession.load(SimpleEntity.class, entity.getId());
-        assertSame(entity, entity2);
-        assertSame(entity, entity3);
-    }
-
-    public void testIdentityPerSession() throws SQLException {
-        SimpleEntity entity = new SimpleEntity();
-        daoSession.insert(entity);
-        DaoSession session2 = daoMaster.newSession();
-        SimpleEntity entity2 = session2.load(SimpleEntity.class, entity.getId());
-        assertNotSame(entity, entity2);
-    }
-
-    public void testSessionReset() throws SQLException {
-        SimpleEntity entity = new SimpleEntity();
-        daoSession.insert(entity);
-        daoSession.clear();
-        SimpleEntity entity2 = daoSession.load(SimpleEntity.class, entity.getId());
-        assertNotSame(entity, entity2);
-    }
-}
\ No newline at end of file
diff --git a/DaoTest/src/de/greenrobot/daotest/DbTestTest.java b/DaoTest/src/de/greenrobot/daotest/DbTestTest.java
deleted file mode 100644
index 657408fc..00000000
--- a/DaoTest/src/de/greenrobot/daotest/DbTestTest.java
+++ /dev/null
@@ -1,117 +0,0 @@
-package de.greenrobot.daotest;
-
-import junit.framework.AssertionFailedError;
-import android.app.Application;
-import de.greenrobot.dao.test.DbTest;
-
-public class DbTestTest extends DbTest {
-    public static class MyApp extends Application {
-        static int onCreateCounterStatic;
-        static int onTerminateCounterStatic;
-
-        int onCreateCounter;
-        int onTerminateCounter;
-
-        @Override
-        public void onCreate() {
-            super.onCreate();
-            onCreateCounter++;
-            onCreateCounterStatic++;
-        }
-
-        @Override
-        public void onTerminate() {
-            super.onTerminate();
-            onTerminateCounterStatic++;
-            onTerminateCounter++;
-        }
-    }
-
-    @Override
-    protected void setUp() throws Exception {
-        super.setUp();
-        MyApp.onCreateCounterStatic = 0;
-        MyApp.onTerminateCounterStatic = 0;
-    }
-
-    @Override
-    protected void tearDown() throws Exception {
-        super.tearDown();
-        assertEquals(MyApp.onCreateCounterStatic, MyApp.onTerminateCounterStatic);
-    }
-
-    public void testCreateApplication() {
-        MyApp app = createApplication(MyApp.class);
-        assertNotNull(app);
-
-        assertEquals(1, app.onCreateCounter);
-        assertEquals(1, MyApp.onCreateCounterStatic);
-        assertEquals(0, app.onTerminateCounter);
-        assertEquals(0, MyApp.onTerminateCounterStatic);
-    }
-
-    public void testTerminateApplication() {
-        MyApp app = createApplication(MyApp.class);
-        terminateApplication();
-
-        assertEquals(1, app.onCreateCounter);
-        assertEquals(1, MyApp.onCreateCounterStatic);
-        assertEquals(1, app.onTerminateCounter);
-        assertEquals(1, MyApp.onTerminateCounterStatic);
-    }
-
-    public void testGetApplicationBeforeCreate() {
-        try {
-            getApplication();
-            fail("Should have thrown");
-        } catch (AssertionFailedError e) {
-            // Expected
-        }
-    }
-
-    public void testGetApplication() {
-        try {
-            getApplication();
-            fail("Should have thrown");
-        } catch (AssertionFailedError e) {
-            // Expected
-        }
-
-        MyApp app = createApplication(MyApp.class);
-        MyApp app2 = getApplication();
-        assertSame(app, app2);
-    }
-
-    public void testGetApplicationAfterTerminate() {
-        MyApp app = createApplication(MyApp.class);
-        terminateApplication();
-        try {
-            getApplication();
-            fail("Should have thrown");
-        } catch (AssertionFailedError e) {
-            // Expected
-        }
-    }
-
-
-    public void testMultipleApplications() {
-        MyApp app1 = createApplication(MyApp.class);
-        terminateApplication();
-
-        MyApp app2 = createApplication(MyApp.class);
-        assertNotSame(app2, app1);
-
-        MyApp app = getApplication();
-        assertSame(app2, app);
-
-        assertEquals(1, app1.onCreateCounter);
-        assertEquals(1, app1.onTerminateCounter);
-        assertEquals(1, app2.onCreateCounter);
-        assertEquals(0, app2.onTerminateCounter);
-
-        assertEquals(2, MyApp.onCreateCounterStatic);
-        assertEquals(1, MyApp.onTerminateCounterStatic);
-    }
-
-
-}
\ No newline at end of file
diff --git a/DaoTest/src/de/greenrobot/daotest/DbUtilsTest.java b/DaoTest/src/de/greenrobot/daotest/DbUtilsTest.java
deleted file mode 100644
index 0abfa312..00000000
--- a/DaoTest/src/de/greenrobot/daotest/DbUtilsTest.java
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daotest;
-
-import java.io.IOException;
-import java.sql.PreparedStatement;
-import java.sql.ResultSet;
-import java.sql.SQLException;
-
-import de.greenrobot.dao.DbUtils;
-import de.greenrobot.dao.test.DbTest;
-
-public class DbUtilsTest extends DbTest {
-    public void testExecuteSqlScript() throws IOException, SQLException {
-        DbUtils.executeSqlScript(getContext(), connection, "minimal-entity.sql");
-        PreparedStatement statement = connection.prepareStatement( "SELECT count(*) from MINIMAL_ENTITY" );
-        ResultSet resultSet = statement.executeQuery();
-        try {
-            resultSet.next();
-            assertEquals(5, resultSet.getInt(1));
-        } finally {
-            statement.close();
-        }
-    }
-
-}
diff --git a/DaoTest/src/de/greenrobot/daotest/IndexTest.java b/DaoTest/src/de/greenrobot/daotest/IndexTest.java
deleted file mode 100644
index 04b8f0b9..00000000
--- a/DaoTest/src/de/greenrobot/daotest/IndexTest.java
+++ /dev/null
@@ -1,50 +0,0 @@
-package de.greenrobot.daotest;
-
-import java.sql.SQLException;
-import java.util.List;
-
-import junit.framework.Assert;
-import de.greenrobot.dao.DaoLog;
-import de.greenrobot.dao.test.AbstractDaoTest;
-import de.greenrobot.daotest.SqliteMasterDao.Properties;
-
-public class IndexTest extends AbstractDaoTest<SqliteMasterDao, SqliteMaster, Void> {
-
-    public IndexTest() {
-        super(SqliteMasterDao.class);
-    }
-
-    public void testIndexesCreated() throws SQLException {
-        Assert.assertEquals(0, getIndexes().size());
-
-        TestEntityDao.createTable(connection, false);
-        List<SqliteMaster> indexes = getIndexes();
-        Assert.assertEquals(2, indexes.size());
-
-        SqliteMaster index1 = indexes.get(0);
-        SqliteMaster index2 = indexes.get(1);
-        Assert.assertEquals(TestEntityDao.TABLENAME, index1.getTableName());
-        Assert.assertEquals(TestEntityDao.TABLENAME, index2.getTableName());
-        Assert.assertEquals("IDX_TEST_ENTITY_INDEXED_STRING", index1.getName());
-        Assert.assertEquals("IDX_TEST_ENTITY_INDEXED_STRING_ASC_UNIQUE", index2.getName());
-
-        for (SqliteMaster index : indexes) {
-            DaoLog.v(index.toString());
-        }
-    }
-    
-    public void testIndexCreateIfNotExists() throws SQLException {
-        Assert.assertEquals(0, getIndexes().size());
-        TestEntityDao.createTable(connection, false);
-        Assert.assertEquals(2, getIndexes().size());
-        TestEntityDao.createTable(connection, true);
-        Assert.assertEquals(2, getIndexes().size());
-    }
-
-    private List<SqliteMaster> getIndexes() throws SQLException {
-        String where = "WHERE " + Properties.Type.columnName + "=? ORDER BY " + Properties.Name.columnName;
-        List<SqliteMaster> indexes = dao.queryRaw(where, "index");
-        return indexes;
-    }
-
-}
diff --git a/DaoTest/src/de/greenrobot/daotest/LongHashMapTest.java b/DaoTest/src/de/greenrobot/daotest/LongHashMapTest.java
deleted file mode 100644
index 433658bd..00000000
--- a/DaoTest/src/de/greenrobot/daotest/LongHashMapTest.java
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daotest;
-
-import java.util.Random;
-
-import junit.framework.TestCase;
-import de.greenrobot.dao.internal.LongHashMap;
-
-public class LongHashMapTest extends TestCase {
-
-    Random random;
-    private String traceName;
-    private long start;
-
-    public LongHashMapTest() {
-        this.random = new Random();
-    }
-
-    public void testLongHashMapSimple() {
-        LongHashMap<Object> map = new LongHashMap<Object>();
-
-        map.put(1l << 33, "OK");
-        assertNull(map.get(0));
-        assertEquals("OK", map.get(1l << 33));
-
-        long keyLong = 0x7fffffffl << 33l + 14;
-        assertNull(map.remove(keyLong));
-        map.put(keyLong, "OK");
-        assertTrue(map.containsKey(keyLong));
-        assertEquals("OK", map.remove(keyLong));
-
-        keyLong = Long.MAX_VALUE;
-        map.put(keyLong, "OK");
-        assertTrue(map.containsKey(keyLong));
-
-        keyLong = 8064216579113853113l;
-        map.put(keyLong, "OK");
-        assertTrue(map.containsKey(keyLong));
-
-    }
-
-    public void testLongHashMapRandom() {
-        LongHashMap<Object> map = new LongHashMap<Object>();
-        for (int i = 0; i < 5000; i++) {
-            long key = random.nextLong();
-            String value = "Value-" + key;
-            map.put(key, value);
-            assertTrue("" + key, map.containsKey(key));
-
-            int keyInt = (int) key;
-            String valueInt = "Value-" + keyInt;
-            map.put(keyInt, valueInt);
-            assertTrue(map.containsKey(keyInt));
-
-            assertEquals(value, map.get(key));
-            assertEquals(valueInt, map.get(keyInt));
-
-            assertEquals(value, map.remove(key));
-            assertEquals(valueInt, map.remove(keyInt));
-
-            assertNull(map.get(key));
-            assertNull(map.get(keyInt));
-        }
-    }
-
-}
diff --git a/DaoTest/src/de/greenrobot/daotest/TestInterface.java b/DaoTest/src/de/greenrobot/daotest/TestInterface.java
deleted file mode 100644
index 7c38baab..00000000
--- a/DaoTest/src/de/greenrobot/daotest/TestInterface.java
+++ /dev/null
@@ -1,5 +0,0 @@
-package de.greenrobot.daotest;
-
-public interface TestInterface {
-
-}
diff --git a/DaoTest/src/de/greenrobot/daotest/TestSuperclass.java b/DaoTest/src/de/greenrobot/daotest/TestSuperclass.java
deleted file mode 100644
index 8687b520..00000000
--- a/DaoTest/src/de/greenrobot/daotest/TestSuperclass.java
+++ /dev/null
@@ -1,5 +0,0 @@
-package de.greenrobot.daotest;
-
-public class TestSuperclass {
-
-}
diff --git a/DaoTest/src/de/greenrobot/daotest/async/AbstractAsyncTest.java b/DaoTest/src/de/greenrobot/daotest/async/AbstractAsyncTest.java
deleted file mode 100644
index 423733c0..00000000
--- a/DaoTest/src/de/greenrobot/daotest/async/AbstractAsyncTest.java
+++ /dev/null
@@ -1,47 +0,0 @@
-package de.greenrobot.daotest.async;
-
-import java.util.List;
-import java.util.concurrent.CopyOnWriteArrayList;
-
-import de.greenrobot.dao.async.AsyncOperation;
-import de.greenrobot.dao.async.AsyncOperationListener;
-import de.greenrobot.dao.async.AsyncSession;
-import de.greenrobot.dao.test.AbstractDaoSessionTest;
-import de.greenrobot.daotest.DaoMaster;
-import de.greenrobot.daotest.DaoSession;
-
-public abstract class AbstractAsyncTest extends AbstractDaoSessionTest<DaoMaster, DaoSession> implements
-        AsyncOperationListener {
-
-    protected AsyncSession asyncSession;
-    protected List<AsyncOperation> completedOperations;
-
-    public AbstractAsyncTest() {
-        super(DaoMaster.class);
-    }
-
-    @Override
-    protected void setUp() throws Exception {
-        super.setUp();
-        asyncSession = daoSession.startAsyncSession();
-        asyncSession.setListener(this);
-        completedOperations = new CopyOnWriteArrayList<AsyncOperation>();
-    }
-
-    public void assertWaitForCompletion1Sec() {
-        assertTrue(asyncSession.waitForCompletion(1000));
-        assertTrue(asyncSession.isCompleted());
-    }
-
-    @Override
-    public void onAsyncOperationCompleted(AsyncOperation operation) {
-        completedOperations.add(operation);
-    }
-
-    protected void assertSingleOperationCompleted(AsyncOperation operation) {
-        assertSame(operation, completedOperations.get(0));
-        assertEquals(1, completedOperations.size());
-        assertTrue(operation.isCompleted());
-    }
-
-}
diff --git a/DaoTest/src/de/greenrobot/daotest/async/BasicAsyncTest.java b/DaoTest/src/de/greenrobot/daotest/async/BasicAsyncTest.java
deleted file mode 100644
index db949788..00000000
--- a/DaoTest/src/de/greenrobot/daotest/async/BasicAsyncTest.java
+++ /dev/null
@@ -1,157 +0,0 @@
-package de.greenrobot.daotest.async;
-
-import java.sql.SQLException;
-import java.util.concurrent.Callable;
-
-import android.os.Looper;
-import de.greenrobot.dao.async.AsyncDaoException;
-import de.greenrobot.dao.async.AsyncOperation;
-import de.greenrobot.dao.async.AsyncOperationListener;
-import de.greenrobot.daotest.SimpleEntity;
-
-public class BasicAsyncTest extends AbstractAsyncTest {
-
-    Thread txThread;
-    boolean testListenerMainThread_done;
-
-    public void testSequenceNumber() {
-        AsyncOperation op1 = asyncSession.count(SimpleEntity.class);
-        assertEquals(1, op1.getSequenceNumber());
-        AsyncOperation op2 = asyncSession.count(SimpleEntity.class);
-        assertEquals(2, op2.getSequenceNumber());
-    }
-
-    public void testWaitForCompletionNoOps() {
-        assertTrue(asyncSession.isCompleted());
-        assertTrue(asyncSession.waitForCompletion(1));
-        asyncSession.waitForCompletion();
-    }
-
-    public void testAsyncInsert() throws SQLException {
-        SimpleEntity entity = new SimpleEntity();
-        entity.setSimpleString("heho");
-        AsyncOperation operation = asyncSession.insert(entity);
-        assertWaitForCompletion1Sec();
-        SimpleEntity entity2 = daoSession.load(SimpleEntity.class, entity.getId());
-        assertNotNull(entity2);
-        assertEquals("heho", entity2.getSimpleString());
-        assertFalse(operation.isFailed());
-        assertSingleOperationCompleted(operation);
-    }
-
-    public void testAsyncUpdate() throws SQLException {
-        SimpleEntity entity = new SimpleEntity();
-        entity.setSimpleString("heho");
-        daoSession.insert(entity);
-        entity.setSimpleString("updated");
-        AsyncOperation operation = asyncSession.update(entity);
-        assertWaitForCompletion1Sec();
-        daoSession.clear();
-        SimpleEntity entity2 = daoSession.load(SimpleEntity.class, entity.getId());
-        assertNotNull(entity2);
-        assertEquals("updated", entity2.getSimpleString());
-        assertFalse(operation.isFailed());
-        assertSingleOperationCompleted(operation);
-    }
-
-    public void testOperationGetResult() throws SQLException {
-        SimpleEntity entity = new SimpleEntity();
-        entity.setSimpleString("heho");
-        daoSession.insert(entity);
-        daoSession.clear();
-
-        AsyncOperation operation = asyncSession.load(SimpleEntity.class, entity.getId());
-        SimpleEntity result = (SimpleEntity) operation.getResult();
-        assertTrue(operation.isCompleted());
-        assertTrue(operation.isCompletedSucessfully());
-        assertNotNull(result);
-        assertNotSame(entity, result);
-        assertEquals(entity.getId(), result.getId());
-        assertEquals(entity.getSimpleString(), result.getSimpleString());
-    }
-
-    public void testOperationGetResultException() throws SQLException {
-        SimpleEntity entity = new SimpleEntity();
-        daoSession.insert(entity);
-        AsyncOperation operation = asyncSession.insert(entity);
-        try {
-            operation.getResult();
-            fail("getResult should have thrown");
-        } catch (AsyncDaoException expected) {
-            // OK
-        }
-        assertTrue(operation.isCompleted());
-        assertFalse(operation.isCompletedSucessfully());
-        assertTrue(operation.isFailed());
-    }
-
-    public void testAsyncException() throws SQLException {
-        SimpleEntity entity = new SimpleEntity();
-        daoSession.insert(entity);
-        AsyncOperation operation = asyncSession.insert(entity);
-        assertWaitForCompletion1Sec();
-        assertSingleOperationCompleted(operation);
-
-        assertTrue(operation.isFailed());
-        assertNotNull(operation.getThrowable());
-    }
-
-    public void testAsyncOperationWaitMillis() {
-        AsyncOperation operation = asyncSession.insert(new SimpleEntity());
-        assertTrue(asyncSession.waitForCompletion(1000));
-        assertSingleOperationCompleted(operation);
-    }
-
-    public void testAsyncOperationWait() {
-        AsyncOperation operation = asyncSession.insert(new SimpleEntity());
-        asyncSession.waitForCompletion();
-        assertSingleOperationCompleted(operation);
-    }
-
-    public void testAsyncRunInTx() {
-        AsyncOperation operation = asyncSession.runInTx(new Runnable() {
-
-            @Override
-            public void run() {
-                txThread = Thread.currentThread();
-            }
-        });
-        assertWaitForCompletion1Sec();
-        assertSingleOperationCompleted(operation);
-        assertNotNull(txThread);
-        assertFalse(Thread.currentThread().equals(txThread));
-    }
-
-    public void testAsynCallInTx() {
-        AsyncOperation operation = asyncSession.callInTx(new Callable<String>() {
-
-            @Override
-            public String call() throws Exception {
-                txThread = Thread.currentThread();
-                return "OK";
-            }
-        });
-        assertEquals("OK", operation.waitForCompletion());
-        assertNotNull(txThread);
-        assertFalse(Thread.currentThread().equals(txThread));
-    }
-
-    public void testListenerMainThread() throws InterruptedException {
-        AsyncOperationListener listener = new AsyncOperationListener() {
-            @Override
-            public synchronized void onAsyncOperationCompleted(AsyncOperation operation) {
-                assertEquals(Looper.getMainLooper(), Looper.myLooper());
-                testListenerMainThread_done = true;
-                notifyAll();
-            }
-        };
-        asyncSession.setListenerMainThread(listener);
-        asyncSession.insert(new SimpleEntity());
-        assertWaitForCompletion1Sec();
-        while (!testListenerMainThread_done) {
-            synchronized (listener) {
-                listener.wait();
-            }
-        }
-    }
-}
diff --git a/DaoTest/src/de/greenrobot/daotest/async/MergeTxAsyncTest.java b/DaoTest/src/de/greenrobot/daotest/async/MergeTxAsyncTest.java
deleted file mode 100644
index cdcc2a42..00000000
--- a/DaoTest/src/de/greenrobot/daotest/async/MergeTxAsyncTest.java
+++ /dev/null
@@ -1,32 +0,0 @@
-package de.greenrobot.daotest.async;
-
-import java.sql.SQLException;
-
-import de.greenrobot.dao.async.AsyncOperation;
-import de.greenrobot.daotest.SimpleEntity;
-
-public class MergeTxAsyncTest extends AbstractAsyncTest {
-
-    public void testMergeInsertAndUpdate() throws SQLException {
-        SimpleEntity entity = new SimpleEntity();
-        entity.setId(42l);
-        entity.setSimpleString("heho");
-        
-        SimpleEntity entity2 = new SimpleEntity();
-        entity2.setId(42l);
-        entity2.setSimpleString("updated");
-        
-        AsyncOperation op1 = asyncSession.insert(entity, AsyncOperation.FLAG_MERGE_TX);
-        AsyncOperation op2 = asyncSession.update(entity2, AsyncOperation.FLAG_MERGE_TX);
-        
-        assertWaitForCompletion1Sec();
-        daoSession.clear();
-        SimpleEntity entity3 = daoSession.load(SimpleEntity.class, 42l);
-        assertNotNull(entity3);
-        assertEquals(entity2.getSimpleString(), entity3.getSimpleString());
-        
-        assertEquals(2, op1.getMergedOperationsCount());
-        assertEquals(2, op2.getMergedOperationsCount());
-    }
-
-}
diff --git a/DaoTest/src/de/greenrobot/daotest/contentprovider/SimpleEntityContentProviderTest.java b/DaoTest/src/de/greenrobot/daotest/contentprovider/SimpleEntityContentProviderTest.java
deleted file mode 100644
index c2e22c21..00000000
--- a/DaoTest/src/de/greenrobot/daotest/contentprovider/SimpleEntityContentProviderTest.java
+++ /dev/null
@@ -1,70 +0,0 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daotest.contentprovider;
-
-import java.sql.SQLException;
-
-import android.database.Cursor;
-import android.test.suitebuilder.annotation.Suppress;
-import de.greenrobot.dao.test.AbstractDaoSessionTest;
-import de.greenrobot.daotest.DaoMaster;
-import de.greenrobot.daotest.DaoSession;
-import de.greenrobot.daotest.SimpleEntity;
-import de.greenrobot.daotest.SimpleEntityContentProvider;
-import de.greenrobot.daotest.SimpleEntityDao;
-
-@Suppress
-// TODO Activate once the gradle build is fixed (AndroidManifest.xml is not used for instrumentTest)
-public class SimpleEntityContentProviderTest extends AbstractDaoSessionTest<DaoMaster, DaoSession> {
-
-    public SimpleEntityContentProviderTest() {
-        super(DaoMaster.class);
-    }
-
-    @Override
-    protected void setUp() throws Exception {
-        super.setUp();
-        SimpleEntityContentProvider.daoSession = daoSession;
-    }
-
-    public void testQuery() throws SQLException {
-        SimpleEntity entity = new SimpleEntity();
-        entity.setSimpleString("hello");
-        daoSession.insert(entity);
-        long id = entity.getId();
-
-        SimpleEntity entity2 = new SimpleEntity();
-        entity2.setSimpleString("content");
-        daoSession.insert(entity2);
-        long id2 = entity2.getId();
-        Cursor cursor = getContext().getContentResolver().query(SimpleEntityContentProvider.CONTENT_URI, null,
-                null, null, "_id");
-        assertEquals(2, cursor.getCount());
-        int idxId = cursor.getColumnIndexOrThrow(SimpleEntityDao.Properties.Id.columnName);
-        int idxString = cursor.getColumnIndexOrThrow(SimpleEntityDao.Properties.SimpleString.columnName);
-
-        assertTrue(cursor.moveToFirst());
-        assertEquals("hello", cursor.getString(idxString));
-        assertEquals(id, cursor.getLong(idxId));
-
-        assertTrue(cursor.moveToNext());
-        assertEquals("content", cursor.getString(idxString));
-        assertEquals(id2, cursor.getLong(idxId));
-    }
-
-}
\ No newline at end of file
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/AbcdefEntityTest.java b/DaoTest/src/de/greenrobot/daotest/entity/AbcdefEntityTest.java
index d68dcef5..4994b6f4 100644
--- a/DaoTest/src/de/greenrobot/daotest/entity/AbcdefEntityTest.java
+++ b/DaoTest/src/de/greenrobot/daotest/entity/AbcdefEntityTest.java
@@ -1,23 +1,7 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
 package de.greenrobot.daotest.entity;
 
 import de.greenrobot.dao.test.AbstractDaoTestLongPk;
+
 import de.greenrobot.daotest.AbcdefEntity;
 import de.greenrobot.daotest.AbcdefEntityDao;
 
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/AnActiveEntityMultithreadingTest.java b/DaoTest/src/de/greenrobot/daotest/entity/AnActiveEntityMultithreadingTest.java
deleted file mode 100644
index d498e80e..00000000
--- a/DaoTest/src/de/greenrobot/daotest/entity/AnActiveEntityMultithreadingTest.java
+++ /dev/null
@@ -1,143 +0,0 @@
-/*
- * Copyright (C) 2013 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daotest.entity;
-
-import java.lang.reflect.Field;
-import java.sql.SQLException;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-
-import de.greenrobot.dao.DaoLog;
-import de.greenrobot.dao.test.AbstractDaoSessionTest;
-import de.greenrobot.daotest.AnActiveEntity;
-import de.greenrobot.daotest.AnActiveEntityDao;
-import de.greenrobot.daotest.DaoMaster;
-import de.greenrobot.daotest.DaoSession;
-
-public class AnActiveEntityMultithreadingTest extends AbstractDaoSessionTest<DaoMaster, DaoSession> {
-
-    /** Serious multithreading tests require this set to true. */
-    private static final boolean LONG_RUNNING = false;
-    private static final int ENTITIES_TO_CHECK = LONG_RUNNING ? 1000000 : 10000;
-
-    private AnActiveEntityDao dao;
-    private CountDownLatch latch = new CountDownLatch(2);
-    volatile boolean running = true;
-
-    public AnActiveEntityMultithreadingTest() {
-        super(DaoMaster.class);
-    }
-
-    @Override
-    protected void setUp() throws Exception {
-        super.setUp();
-        dao = daoSession.getAnActiveEntityDao();
-    }
-
-    public void testAlwaysAttachedWithInsertDelete() throws Exception {
-        doTestAlwaysAttached(new InsertDeleteThread());
-    }
-
-    public void testAlwaysAttachedWithDetach() throws Exception {
-        doTestAlwaysAttached(new DetachThread());
-    }
-
-    private void doTestAlwaysAttached(Thread thread) throws Exception {
-        thread.start();
-
-        Field daoSessionField = AnActiveEntity.class.getDeclaredField("daoSession");
-        daoSessionField.setAccessible(true);
-
-        int countEntity = 0;
-        countDownAndAwaitLatch();
-
-        try {
-            assertTrue(latch.await(10, TimeUnit.SECONDS));
-            for (int i = 0;; i++) {
-                AnActiveEntity entity = dao.load(1l);
-                if (entity != null) {
-                    countEntity++;
-                    assertNotNull(daoSessionField.get(entity));
-                }
-                if (i == 1000000 && countEntity == 0) {
-                    fail("No entity available");
-                }
-                if (countEntity % 10000 == 0) {
-                    DaoLog.d("Checked entities " + countEntity + " in " + i + " iterations");
-                }
-                if (countEntity == ENTITIES_TO_CHECK) {
-                    break;
-                }
-            }
-        } finally {
-            running = false;
-            thread.join();
-        }
-    }
-
-    private void countDownAndAwaitLatch() {
-        latch.countDown();
-        try {
-            assertTrue(latch.await(10, TimeUnit.SECONDS));
-        } catch (InterruptedException e) {
-            throw new RuntimeException(e);
-        }
-    }
-
-    class InsertDeleteThread extends Thread {
-        @Override
-        public void run() {
-            countDownAndAwaitLatch();
-
-            while (running) {
-                AnActiveEntity entity = null;
-                entity = new AnActiveEntity(1l);
-                try
-				{
-					dao.insert(entity);
-					dao.delete(entity);
-				}
-				catch ( SQLException e )
-				{
-					e.printStackTrace();
-				}
-            }
-        }
-    }
-
-    class DetachThread extends Thread {
-        @Override
-        public void run() {
-            countDownAndAwaitLatch();
-
-            AnActiveEntity entity = new AnActiveEntity(1l);
-            try
-			{
-				dao.insert(entity);
-				while (running) {
-					dao.detach(entity);
-					entity = dao.load(1l);
-				}
-			}
-			catch ( SQLException e )
-			{
-				e.printStackTrace();
-			}
-        }
-    }
-}
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/AnActiveEntityTest.java b/DaoTest/src/de/greenrobot/daotest/entity/AnActiveEntityTest.java
index 8b5e4c7a..e4fd33d8 100644
--- a/DaoTest/src/de/greenrobot/daotest/entity/AnActiveEntityTest.java
+++ b/DaoTest/src/de/greenrobot/daotest/entity/AnActiveEntityTest.java
@@ -1,98 +1,21 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
 package de.greenrobot.daotest.entity;
 
-import java.sql.SQLException;
+import de.greenrobot.dao.test.AbstractDaoTestLongPk;
 
-import de.greenrobot.dao.DaoException;
-import de.greenrobot.dao.test.AbstractDaoSessionTest;
 import de.greenrobot.daotest.AnActiveEntity;
 import de.greenrobot.daotest.AnActiveEntityDao;
-import de.greenrobot.daotest.DaoMaster;
-import de.greenrobot.daotest.DaoSession;
 
-public class AnActiveEntityTest extends AbstractDaoSessionTest<DaoMaster, DaoSession> {
-
-    private AnActiveEntityDao dao;
+public class AnActiveEntityTest extends AbstractDaoTestLongPk<AnActiveEntityDao, AnActiveEntity> {
 
     public AnActiveEntityTest() {
-        super(DaoMaster.class);
+        super(AnActiveEntityDao.class);
     }
 
     @Override
-    protected void setUp() throws Exception {
-        super.setUp();
-        dao = daoSession.getAnActiveEntityDao();
-    }
-
-    public void testThrowWhenDetached() throws SQLException {
+    protected AnActiveEntity createEntity(Long key) {
         AnActiveEntity entity = new AnActiveEntity();
-        try {
-            entity.delete();
-            fail("Should fail for detached entity");
-        } catch (DaoException e) {
-            // OK, expected
-        }
-        try {
-            entity.refresh();
-            fail("Should fail for detached entity");
-        } catch (DaoException e) {
-            // OK, expected
-        }
-        try {
-            entity.update();
-            fail("Should fail for detached entity");
-        } catch (DaoException e) {
-            // OK, expected
-        }
-    }
-
-    public void testActiveUpdate() throws SQLException {
-        AnActiveEntity entity = new AnActiveEntity(1l);
-        long rowId = dao.insert(entity);
-
-        entity.setText("NEW");
-        entity.update();
-
-        daoSession.clear();
-        AnActiveEntity entity2 = dao.load(rowId);
-        assertNotSame(entity, entity2);
-        assertEquals("NEW", entity2.getText());
-    }
-
-    public void testActiveRefresh() throws SQLException {
-        AnActiveEntity entity = new AnActiveEntity(1l);
-        dao.insert(entity);
-
-        AnActiveEntity entity2 = new AnActiveEntity(1l);
-        entity2.setText("NEW");
-        dao.update(entity2);
-
-        entity.refresh();
-        assertEquals("NEW", entity.getText());
-    }
-
-    public void testActiveDelete() throws SQLException {
-        AnActiveEntity entity = new AnActiveEntity(1l);
-        dao.insert(entity);
-
-        entity.delete();
-        assertNull(dao.load(1l));
+        entity.setId(key);
+        return entity;
     }
 
 }
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/AutoincrementEntityTest.java b/DaoTest/src/de/greenrobot/daotest/entity/AutoincrementEntityTest.java
index 97f865ee..384b8e82 100644
--- a/DaoTest/src/de/greenrobot/daotest/entity/AutoincrementEntityTest.java
+++ b/DaoTest/src/de/greenrobot/daotest/entity/AutoincrementEntityTest.java
@@ -1,41 +1,21 @@
 package de.greenrobot.daotest.entity;
 
-import java.sql.SQLException;
+import de.greenrobot.dao.test.AbstractDaoTestLongPk;
 
-import de.greenrobot.dao.test.AbstractDaoSessionTest;
 import de.greenrobot.daotest.AutoincrementEntity;
-import de.greenrobot.daotest.DaoMaster;
-import de.greenrobot.daotest.DaoSession;
-import de.greenrobot.daotest.SimpleEntity;
+import de.greenrobot.daotest.AutoincrementEntityDao;
 
-public class AutoincrementEntityTest extends AbstractDaoSessionTest<DaoMaster, DaoSession> {
+public class AutoincrementEntityTest extends AbstractDaoTestLongPk<AutoincrementEntityDao, AutoincrementEntity> {
 
     public AutoincrementEntityTest() {
-        super(DaoMaster.class);
+        super(AutoincrementEntityDao.class);
     }
 
-    public void testAutoincrement() throws SQLException {
+    @Override
+    protected AutoincrementEntity createEntity(Long key) {
         AutoincrementEntity entity = new AutoincrementEntity();
-        daoSession.insert(entity);
-        Long id1 = entity.getId();
-        assertNotNull(id1);
-        daoSession.delete(entity);
-
-        AutoincrementEntity entity2 = new AutoincrementEntity();
-        daoSession.insert(entity2);
-        assertEquals(id1 + 1, (long) entity2.getId());
-    }
-
-    public void testNoAutoincrement() throws SQLException {
-        SimpleEntity entity = new SimpleEntity();
-        daoSession.insert(entity);
-        Long id1 = entity.getId();
-        assertNotNull(id1);
-        daoSession.delete(entity);
-
-        SimpleEntity entity2 = new SimpleEntity();
-        daoSession.insert(entity2);
-        assertEquals(id1, entity2.getId());
+        entity.setId(key);
+        return entity;
     }
 
 }
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/DateEntityTest.java b/DaoTest/src/de/greenrobot/daotest/entity/DateEntityTest.java
index 2bfa6d57..78a1b07d 100644
--- a/DaoTest/src/de/greenrobot/daotest/entity/DateEntityTest.java
+++ b/DaoTest/src/de/greenrobot/daotest/entity/DateEntityTest.java
@@ -1,26 +1,7 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
 package de.greenrobot.daotest.entity;
 
-import java.sql.SQLException;
-import java.util.Date;
-
 import de.greenrobot.dao.test.AbstractDaoTestLongPk;
+
 import de.greenrobot.daotest.DateEntity;
 import de.greenrobot.daotest.DateEntityDao;
 
@@ -34,33 +15,8 @@ public DateEntityTest() {
     protected DateEntity createEntity(Long key) {
         DateEntity entity = new DateEntity();
         entity.setId(key);
-        entity.setDateNotNull(new Date());
+        entity.setDateNotNull();
         return entity;
     }
-    
-    public void testValues() throws SQLException {
-        DateEntity entity = createEntity(1l);
-        dao.insert(entity);
-        
-        DateEntity reloaded = dao.load(entity.getId());
-        assertNull(reloaded.getDate());
-        assertNotNull(reloaded.getDateNotNull());
-        assertEquals(entity.getDateNotNull(), reloaded.getDateNotNull());
-    }
-
-    public void testValues2() throws SQLException {
-        DateEntity entity = createEntity(1l);
-        long t1=32479875;
-        long t2=976345942443435235l;
-        entity.setDate(new Date(t1));
-        entity.setDateNotNull(new Date(t2));
-        dao.insert(entity);
-        
-        DateEntity reloaded = dao.load(entity.getId());
-        assertNotNull(reloaded.getDate());
-        assertNotNull(reloaded.getDateNotNull());
-        assertEquals(t1, reloaded.getDate().getTime());
-        assertEquals(t2, reloaded.getDateNotNull().getTime());
-    }
 
 }
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/ExtendsImplementsEntityTest.java b/DaoTest/src/de/greenrobot/daotest/entity/ExtendsImplementsEntityTest.java
index 757bb3eb..c9366717 100644
--- a/DaoTest/src/de/greenrobot/daotest/entity/ExtendsImplementsEntityTest.java
+++ b/DaoTest/src/de/greenrobot/daotest/entity/ExtendsImplementsEntityTest.java
@@ -1,15 +1,11 @@
 package de.greenrobot.daotest.entity;
 
-import java.io.Serializable;
-
 import de.greenrobot.dao.test.AbstractDaoTestLongPk;
+
 import de.greenrobot.daotest.ExtendsImplementsEntity;
 import de.greenrobot.daotest.ExtendsImplementsEntityDao;
-import de.greenrobot.daotest.TestInterface;
-import de.greenrobot.daotest.TestSuperclass;
 
-public class ExtendsImplementsEntityTest extends
-        AbstractDaoTestLongPk<ExtendsImplementsEntityDao, ExtendsImplementsEntity> {
+public class ExtendsImplementsEntityTest extends AbstractDaoTestLongPk<ExtendsImplementsEntityDao, ExtendsImplementsEntity> {
 
     public ExtendsImplementsEntityTest() {
         super(ExtendsImplementsEntityDao.class);
@@ -22,11 +18,4 @@ protected ExtendsImplementsEntity createEntity(Long key) {
         return entity;
     }
 
-    public void testInheritance() {
-        ExtendsImplementsEntity entity = createEntityWithRandomPk();
-        assertTrue(entity instanceof TestSuperclass);
-        assertTrue(entity instanceof TestInterface);
-        assertTrue(entity instanceof Serializable);
-    }
-
 }
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/RelationEntityTest.java b/DaoTest/src/de/greenrobot/daotest/entity/RelationEntityTest.java
index 0750be74..7e71f2ba 100644
--- a/DaoTest/src/de/greenrobot/daotest/entity/RelationEntityTest.java
+++ b/DaoTest/src/de/greenrobot/daotest/entity/RelationEntityTest.java
@@ -1,204 +1,22 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daotest.entity;
-
-import java.sql.SQLException;
-import java.util.List;
-
-import de.greenrobot.dao.identityscope.IdentityScopeType;
-import de.greenrobot.dao.test.AbstractDaoTestLongPk;
-import de.greenrobot.daotest.DaoMaster;
-import de.greenrobot.daotest.DaoSession;
-import de.greenrobot.daotest.RelationEntity;
-import de.greenrobot.daotest.RelationEntityDao;
-import de.greenrobot.daotest.TestEntity;
-import de.greenrobot.daotest.TestEntityDao;
-
-public class RelationEntityTest extends AbstractDaoTestLongPk<RelationEntityDao, RelationEntity> {
-
-    protected DaoMaster daoMaster;
-    protected DaoSession daoSession;
-    /** set before calling setUp of this class. */
-    protected IdentityScopeType identityScopeTypeForSession;
-
-    public RelationEntityTest() {
-        super(RelationEntityDao.class);
-        identityScopeTypeForSession = IdentityScopeType.None;
-    }
-
-    @Override
-    protected void setUp() throws Exception {
-        super.setUp();
-        TestEntityDao.createTable(connection, false);
-        daoMaster = new DaoMaster(connection);
-        daoSession = daoMaster.newSession(identityScopeTypeForSession);
-        dao = daoSession.getRelationEntityDao();
-    }
-
-    @Override
-    protected RelationEntity createEntity(Long key) {
-        RelationEntity entity = new RelationEntity();
-        entity.setId(key);
-        return entity;
-    }
-
-    public void testToOne() throws SQLException {
-        RelationEntity entity = insertEntityWithRelations(42l);
-        entity = dao.load(entity.getId());
-        assertTestEntity(entity);
-    }
-
-    public void testToOneSelf() throws SQLException {
-        RelationEntity entity = createEntity(1l);
-        dao.insert(entity);
-
-        entity = dao.load(1l);
-        assertNull(entity.getParent());
-
-        entity.setParentId(entity.getId());
-        dao.update(entity);
-
-        entity = dao.load(1l);
-        RelationEntity parent = entity.getParent();
-        assertEquals(entity.getId(), parent.getId());
-    }
-
-    public void testToOneClearKey() throws SQLException {
-        RelationEntity entity = insertEntityWithRelations(42l);
-        assertNotNull(entity.getParent());
-        entity.setParentId(null);
-        assertNull(entity.getParent());
-    }
-
-    public void testToOneClearEntity() throws SQLException {
-        RelationEntity entity = insertEntityWithRelations(42l);
-        assertNotNull(entity.getParentId());
-        entity.setParent(null);
-        assertNull(entity.getParentId());
-    }
-
-    public void testToOneUpdateKey() throws SQLException {
-        RelationEntity entity = insertEntityWithRelations(42l);
-        TestEntity testEntity = entity.getTestEntity();
-        RelationEntity entity2 = insertEntityWithRelations(43l);
-        TestEntity testEntity2 = entity2.getTestEntity();
-
-        entity.setTestId(testEntity2.getId());
-        assertEquals(testEntity2.getId(), entity.getTestEntity().getId());
-
-        entity.setTestId(null);
-        assertNull(entity.getTestEntity());
-
-        entity.setTestId(testEntity.getId());
-        assertEquals(testEntity.getId(), entity.getTestEntity().getId());
-    }
-
-    public void testToOneUpdateEntity() throws SQLException {
-        RelationEntity entity = insertEntityWithRelations(42l);
-        TestEntity testEntity = entity.getTestEntity();
-        RelationEntity entity2 = insertEntityWithRelations(43l);
-        TestEntity testEntity2 = entity2.getTestEntity();
-
-        entity.setTestEntity(testEntity2);
-        assertEquals(testEntity2.getId(), entity.getTestId());
-
-        entity.setTestEntity(null);
-        assertNull(entity.getTestId());
-
-        entity.setTestEntity(testEntity);
-        assertEquals(testEntity.getId(), entity.getTestId());
-    }
-
-    public void testToOneLoadDeep() throws SQLException {
-        RelationEntity entity = insertEntityWithRelations(42l);
-        entity = dao.loadDeep(entity.getId());
-        assertTestEntity(entity);
-    }
-
-    public void testToOneNoMatch() throws SQLException {
-        RelationEntity entity = insertEntityWithRelations(42l);
-        assertNotNull(entity.getTestEntity());
-        entity.setTestId(23l);
-        entity.setTestIdNotNull(-78);
-        assertNull(entity.getTestEntity());
-        assertNull(entity.getTestNotNull());
-    }
-
-    public void testToOneNoMatchLoadDeep() throws SQLException {
-        RelationEntity entity = insertEntityWithRelations(42l);
-        assertNotNull(entity.getTestEntity());
-        entity.setTestId(23l);
-        entity.setTestIdNotNull(-78);
-        dao.update(entity);
-        entity = dao.loadDeep(entity.getId());
-        assertNull(entity.getTestEntity());
-        assertNull(entity.getTestNotNull());
-    }
-
-    public void testToOneLoadDeepNull() throws SQLException {
-        RelationEntity entity = insertEntityWithRelations(42l);
-        entity.setParentId(null);
-        entity.setTestId(null);
-        dao.update(entity);
-        entity = dao.loadDeep(entity.getId());
-        assertNull(entity.getParent());
-        assertNull(entity.getTestEntity());
-    }
-
-    public void testQueryDeep() throws SQLException {
-        insertEntityWithRelations(42l);
-        String columnName = RelationEntityDao.Properties.SimpleString.columnName;
-        List<RelationEntity> entityList = dao.queryDeep("WHERE T." + columnName + "=?", "findMe");
-        assertEquals(1, entityList.size());
-        assertTestEntity(entityList.get(0));
-    }
-
-    protected RelationEntity insertEntityWithRelations(Long testEntityId) throws SQLException {
-        TestEntity testEntity = daoSession.getTestEntityDao().load(testEntityId);
-        if (testEntity == null) {
-            testEntity = new TestEntity(testEntityId);
-            testEntity.setSimpleStringNotNull("mytest");
-            daoSession.getTestEntityDao().insert(testEntity);
-        }
-
-        RelationEntity parentEntity = createEntity(null);
-        parentEntity.setSimpleString("I'm a parent");
-        parentEntity.setTestNotNull(testEntity);
-        dao.insert(parentEntity);
-
-        RelationEntity entity = createEntity(null);
-        entity.setTestId(testEntityId);
-        entity.setParentId(parentEntity.getId());
-        entity.setSimpleString("findMe");
-        entity.setTestNotNull(testEntity);
-        dao.insert(entity);
-
-        return entity;
-    }
-
-    protected void assertTestEntity(RelationEntity entity) throws SQLException {
-        TestEntity testEntity = entity.getTestEntity();
-        assertNotNull(testEntity);
-        assertEquals(42l, (long) testEntity.getId());
-        assertEquals("mytest", testEntity.getSimpleStringNotNull());
-        assertEquals("I'm a parent", entity.getParent().getSimpleString());
-        assertEquals(entity.getParentId(), entity.getParent().getId());
-        assertNotNull(entity.getTestNotNull());
-    }
-
-}
+package de.greenrobot.daotest.entity;
+
+import de.greenrobot.dao.test.AbstractDaoTestLongPk;
+
+import de.greenrobot.daotest.RelationEntity;
+import de.greenrobot.daotest.RelationEntityDao;
+
+public class RelationEntityTest extends AbstractDaoTestLongPk<RelationEntityDao, RelationEntity> {
+
+    public RelationEntityTest() {
+        super(RelationEntityDao.class);
+    }
+
+    @Override
+    protected RelationEntity createEntity(Long key) {
+        RelationEntity entity = new RelationEntity();
+        entity.setId(key);
+        entity.setTestIdNotNull();
+        return entity;
+    }
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/RelationEntityTestIdentityScope.java b/DaoTest/src/de/greenrobot/daotest/entity/RelationEntityTestIdentityScope.java
deleted file mode 100644
index 8ebdc5c4..00000000
--- a/DaoTest/src/de/greenrobot/daotest/entity/RelationEntityTestIdentityScope.java
+++ /dev/null
@@ -1,85 +0,0 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daotest.entity;
-
-import java.sql.SQLException;
-import java.util.List;
-
-import de.greenrobot.dao.identityscope.IdentityScopeType;
-import de.greenrobot.daotest.RelationEntity;
-import de.greenrobot.daotest.RelationEntityDao;
-
-/**
- * @author Markus
- */
-public class RelationEntityTestIdentityScope extends RelationEntityTest {
-
-    @Override
-    protected void setUp() throws Exception {
-        identityScopeTypeForSession = IdentityScopeType.Session;
-        super.setUp();
-    }
-
-    public void testToOneLoadDeepIdentityScope() throws SQLException {
-        RelationEntity entity = insertEntityWithRelations(42l);
-        RelationEntity entity2 = insertEntityWithRelations(42l);
-        entity = dao.loadDeep(entity.getId());
-        entity2 = dao.loadDeep(entity2.getId());
-        assertFalse(entity.getId().equals(entity2.getId()));
-        assertTestEntity(entity);
-        assertTestEntity(entity2);
-        assertSame(entity.getTestEntity(), entity2.getTestEntity());
-    }
-
-    public void testToQueryDeepIdentityScope() throws SQLException {
-        insertEntityWithRelations(42l);
-        RelationEntity entity2 = insertEntityWithRelations(42l);
-        String columnName = RelationEntityDao.Properties.SimpleString.columnName;
-        List<RelationEntity> entityList = dao.queryDeep("WHERE T." + columnName + "=?", "findMe");
-        assertEquals(2, entityList.size());
-        RelationEntity entity = entityList.get(0);
-        assertTestEntity(entity);
-        entity2 = entityList.get(1);
-        assertTestEntity(entity2);
-        assertSame(entity.getTestEntity(), entity2.getTestEntity());
-    }
-
-    public void testLoadDeepIdentityScope() throws SQLException {
-        RelationEntity entity = insertEntityWithRelations(42l);
-        RelationEntity entity2 = dao.loadDeep(entity.getId());
-        RelationEntity entity3 = dao.loadDeep(entity.getId());
-        assertSame(entity, entity2);
-        assertSame(entity, entity3);
-        assertTestEntity(entity);
-    }
-
-    public void testQueryDeepIdentityScope() throws SQLException {
-        RelationEntity entity = insertEntityWithRelations(42l);
-
-        String columnName = RelationEntityDao.Properties.SimpleString.columnName;
-        List<RelationEntity> entityList = dao.queryDeep("WHERE T." + columnName + "=?", "findMe");
-        RelationEntity entity2 = entityList.get(0);
-        entityList = dao.queryDeep("WHERE T." + columnName + "=?", "findMe");
-        RelationEntity entity3 = entityList.get(0);
-
-        assertSame(entity, entity2);
-        assertSame(entity, entity3);
-        assertTestEntity(entity);
-    }
-
-}
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/SimpleEntityNotNullHelper.java b/DaoTest/src/de/greenrobot/daotest/entity/SimpleEntityNotNullHelper.java
deleted file mode 100644
index 9a174bc6..00000000
--- a/DaoTest/src/de/greenrobot/daotest/entity/SimpleEntityNotNullHelper.java
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daotest.entity;
-
-import de.greenrobot.daotest.SimpleEntityNotNull;
-
-
-public class SimpleEntityNotNullHelper {
-    public static SimpleEntityNotNull createEntity(Long key) {
-        if (key == null) {
-            return null;
-        }
-        SimpleEntityNotNull entity = new SimpleEntityNotNull();
-        entity.setId(key);
-        entity.setSimpleBoolean(true);
-        entity.setSimpleByte(Byte.MAX_VALUE);
-        entity.setSimpleShort(Short.MAX_VALUE);
-        entity.setSimpleInt(Integer.MAX_VALUE);
-        entity.setSimpleLong(Long.MAX_VALUE);
-        entity.setSimpleFloat(Float.MAX_VALUE);
-        entity.setSimpleDouble(Double.MAX_VALUE);
-        entity.setSimpleString("greenrobot greenDAO");
-        byte[] bytes = { 42, -17, 23, 0, 127, -128 };
-        entity.setSimpleByteArray(bytes);
-        return entity;
-    }
-}
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/SimpleEntityNotNullTest.java b/DaoTest/src/de/greenrobot/daotest/entity/SimpleEntityNotNullTest.java
index 2d1a2474..7fff526a 100644
--- a/DaoTest/src/de/greenrobot/daotest/entity/SimpleEntityNotNullTest.java
+++ b/DaoTest/src/de/greenrobot/daotest/entity/SimpleEntityNotNullTest.java
@@ -1,26 +1,7 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
 package de.greenrobot.daotest.entity;
 
-import java.sql.SQLException;
-import java.util.Arrays;
-
 import de.greenrobot.dao.test.AbstractDaoTestLongPk;
+
 import de.greenrobot.daotest.SimpleEntityNotNull;
 import de.greenrobot.daotest.SimpleEntityNotNullDao;
 
@@ -32,51 +13,19 @@ public SimpleEntityNotNullTest() {
 
     @Override
     protected SimpleEntityNotNull createEntity(Long key) {
-        return SimpleEntityNotNullHelper.createEntity(key);
-    }
-
-    public void testValues() throws SQLException {
-        SimpleEntityNotNull entity = createEntity(1l);
-        dao.insert(entity);
-        SimpleEntityNotNull reloaded = dao.load(1l);
-        assertEqualProperties(entity, reloaded);
-    }
-
-    protected static void assertEqualProperties(SimpleEntityNotNull entity, SimpleEntityNotNull reloaded) {
-        assertNotSame(entity, reloaded);
-
-        assertEquals(entity.getId(), reloaded.getId());
-        assertEquals(entity.getSimpleBoolean(), reloaded.getSimpleBoolean());
-        assertEquals(entity.getSimpleDouble(), reloaded.getSimpleDouble());
-        assertEquals(entity.getSimpleFloat(), reloaded.getSimpleFloat());
-        assertEquals(entity.getSimpleLong(), reloaded.getSimpleLong());
-        assertEquals(entity.getSimpleByte(), reloaded.getSimpleByte());
-        assertEquals(entity.getSimpleInt(), reloaded.getSimpleInt());
-        assertEquals(entity.getSimpleShort(), reloaded.getSimpleShort());
-        assertEquals(entity.getSimpleBoolean(), reloaded.getSimpleBoolean());
-        assertEquals(entity.getSimpleString(), reloaded.getSimpleString());
-        assertTrue(Arrays.equals(entity.getSimpleByteArray(), reloaded.getSimpleByteArray()));
-    }
-
-    public void testUpdateValues() throws SQLException {
-        SimpleEntityNotNull entity = createEntity(1l);
-        dao.insert(entity);
-        entity = dao.load(1l);
-
-        entity.setSimpleBoolean(false);
-        entity.setSimpleByte(Byte.MIN_VALUE);
-        entity.setSimpleShort(Short.MIN_VALUE);
-        entity.setSimpleInt(Integer.MIN_VALUE);
-        entity.setSimpleLong(Long.MIN_VALUE);
-        entity.setSimpleFloat(Float.MIN_VALUE);
-        entity.setSimpleDouble(Double.MIN_VALUE);
-        entity.setSimpleString("greenDAO");
-        byte[] bytes = { -1, 0, 1 };
-        entity.setSimpleByteArray(bytes);
-        dao.update(entity);
-
-        SimpleEntityNotNull reloaded = dao.load(1l);
-        assertEqualProperties(entity, reloaded);
+        SimpleEntityNotNull entity = new SimpleEntityNotNull();
+        entity.setId(key);
+        entity.setId();
+        entity.setSimpleBoolean();
+        entity.setSimpleByte();
+        entity.setSimpleShort();
+        entity.setSimpleInt();
+        entity.setSimpleLong();
+        entity.setSimpleFloat();
+        entity.setSimpleDouble();
+        entity.setSimpleString();
+        entity.setSimpleByteArray();
+        return entity;
     }
 
 }
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/SimpleEntityTest.java b/DaoTest/src/de/greenrobot/daotest/entity/SimpleEntityTest.java
index ec7f057e..d4a0ce68 100644
--- a/DaoTest/src/de/greenrobot/daotest/entity/SimpleEntityTest.java
+++ b/DaoTest/src/de/greenrobot/daotest/entity/SimpleEntityTest.java
@@ -1,26 +1,7 @@
 package de.greenrobot.daotest.entity;
 
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-import java.sql.SQLException;
-import java.util.Arrays;
-
 import de.greenrobot.dao.test.AbstractDaoTestLongPk;
+
 import de.greenrobot.daotest.SimpleEntity;
 import de.greenrobot.daotest.SimpleEntityDao;
 
@@ -37,99 +18,4 @@ protected SimpleEntity createEntity(Long key) {
         return entity;
     }
 
-    public void testValuesNull() throws SQLException {
-        SimpleEntity entity = createEntity(1l);
-        dao.insert(entity);
-        SimpleEntity reloaded = dao.load(1l);
-        assertNotSame(entity, reloaded);
-
-        assertEquals(entity.getId(), reloaded.getId());
-        assertValuesNull(reloaded);
-    }
-
-    public void testValues() throws SQLException {
-        SimpleEntity entity = createEntity(1l);
-        setValues(entity);
-        dao.insert(entity);
-        SimpleEntity reloaded = dao.load(1l);
-        assertNotSame(entity, reloaded);
-        assertValues(reloaded);
-    }
-
-    public void testUpdateValues() throws SQLException {
-        SimpleEntity entity = createEntity(1l);
-        dao.insert(entity);
-        entity = dao.load(1l);
-        setValues(entity);
-        dao.update(entity);
-        SimpleEntity reloaded = dao.load(1l);
-        assertNotSame(entity, reloaded);
-        assertValues(reloaded);
-    }
-
-    public void testUpdateValuesToNull() throws SQLException {
-        SimpleEntity entity = createEntity(1l);
-        setValues(entity);
-        dao.insert(entity);
-        entity = dao.load(1l);
-        assertValues(entity);
-        setValuesToNull(entity);
-        dao.update(entity);
-        SimpleEntity reloaded = dao.load(1l);
-        assertNotSame(entity, reloaded);
-        assertValuesNull(reloaded);
-    }
-
-    protected void assertValues(SimpleEntity reloaded) {
-        assertEquals(1l, (long) reloaded.getId());
-        assertEquals(true, (boolean) reloaded.getSimpleBoolean());
-        assertEquals(Double.MAX_VALUE, reloaded.getSimpleDouble());
-        assertEquals(Float.MAX_VALUE, reloaded.getSimpleFloat());
-        assertEquals(Long.MAX_VALUE, (long) reloaded.getSimpleLong());
-        assertEquals(Byte.MAX_VALUE, (byte) reloaded.getSimpleByte());
-        assertEquals(Integer.MAX_VALUE, (int) reloaded.getSimpleInt());
-        assertEquals(Short.MAX_VALUE, (short) reloaded.getSimpleShort());
-        assertEquals("greenrobot greenDAO", reloaded.getSimpleString());
-        byte[] bytes = { 42, -17, 23, 0, 127, -128 };
-        assertTrue(Arrays.equals(bytes, reloaded.getSimpleByteArray()));
-    }
-
-    protected void setValues(SimpleEntity entity) {
-        entity.setSimpleBoolean(true);
-        entity.setSimpleByte(Byte.MAX_VALUE);
-        entity.setSimpleShort(Short.MAX_VALUE);
-        entity.setSimpleInt(Integer.MAX_VALUE);
-        entity.setSimpleLong(Long.MAX_VALUE);
-        entity.setSimpleFloat(Float.MAX_VALUE);
-        entity.setSimpleDouble(Double.MAX_VALUE);
-        entity.setSimpleString("greenrobot greenDAO");
-        byte[] bytes = { 42, -17, 23, 0, 127, -128 };
-        entity.setSimpleByteArray(bytes);
-    }
-
-    protected void setValuesToNull(SimpleEntity entity) {
-        entity.setSimpleBoolean(null);
-        entity.setSimpleByte(null);
-        entity.setSimpleShort(null);
-        entity.setSimpleInt(null);
-        entity.setSimpleLong(null);
-        entity.setSimpleFloat(null);
-        entity.setSimpleDouble(null);
-        entity.setSimpleString(null);
-        entity.setSimpleByteArray(null);
-    }
-
-    protected void assertValuesNull(SimpleEntity reloaded) {
-        assertNull(reloaded.getSimpleBoolean());
-        assertNull(reloaded.getSimpleDouble());
-        assertNull(reloaded.getSimpleFloat());
-        assertNull(reloaded.getSimpleLong());
-        assertNull(reloaded.getSimpleByte());
-        assertNull(reloaded.getSimpleInt());
-        assertNull(reloaded.getSimpleShort());
-        assertNull(reloaded.getSimpleBoolean());
-        assertNull(reloaded.getSimpleString());
-        assertNull(reloaded.getSimpleByteArray());
-    }
-
 }
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/SpecialNamesEntityTest.java b/DaoTest/src/de/greenrobot/daotest/entity/SpecialNamesEntityTest.java
index 4cc7d4f7..8430b720 100644
--- a/DaoTest/src/de/greenrobot/daotest/entity/SpecialNamesEntityTest.java
+++ b/DaoTest/src/de/greenrobot/daotest/entity/SpecialNamesEntityTest.java
@@ -1,23 +1,7 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
 package de.greenrobot.daotest.entity;
 
 import de.greenrobot.dao.test.AbstractDaoTestLongPk;
+
 import de.greenrobot.daotest.SpecialNamesEntity;
 import de.greenrobot.daotest.SpecialNamesEntityDao;
 
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/SqliteMasterTest.java b/DaoTest/src/de/greenrobot/daotest/entity/SqliteMasterTest.java
index 1b2573bf..9cd4cc22 100644
--- a/DaoTest/src/de/greenrobot/daotest/entity/SqliteMasterTest.java
+++ b/DaoTest/src/de/greenrobot/daotest/entity/SqliteMasterTest.java
@@ -1,32 +1,20 @@
 package de.greenrobot.daotest.entity;
 
-import java.sql.SQLException;
-import java.util.List;
+import de.greenrobot.dao.test.AbstractDaoTestLongPk;
 
-import de.greenrobot.dao.DaoLog;
-import de.greenrobot.dao.test.AbstractDaoTest;
 import de.greenrobot.daotest.SqliteMaster;
 import de.greenrobot.daotest.SqliteMasterDao;
-import de.greenrobot.daotest.SqliteMasterDao.Properties;
 
-public class SqliteMasterTest extends AbstractDaoTest<SqliteMasterDao, SqliteMaster, Void> {
+public class SqliteMasterTest extends AbstractDaoTestLongPk<SqliteMasterDao, SqliteMaster> {
 
     public SqliteMasterTest() {
         super(SqliteMasterDao.class);
     }
 
-    public void testLoadAll() throws SQLException {
-        List<SqliteMaster> all = dao.loadAll();
-        for (SqliteMaster meta : all) {
-            DaoLog.v(meta.toString());
-        }
-    }
-
-    public void testQueryRaw() throws SQLException {
-        List<SqliteMaster> tables = dao.queryRaw("WHERE " + Properties.Type.columnName + "=?", "table");
-        for (SqliteMaster table : tables) {
-            DaoLog.v(table.toString());
-        }
+    @Override
+    protected SqliteMaster createEntity(Long key) {
+        SqliteMaster entity = new SqliteMaster();
+        return entity;
     }
 
 }
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/StringKeyValueEntityIdentityScopeTest.java b/DaoTest/src/de/greenrobot/daotest/entity/StringKeyValueEntityIdentityScopeTest.java
deleted file mode 100644
index 3a4cd925..00000000
--- a/DaoTest/src/de/greenrobot/daotest/entity/StringKeyValueEntityIdentityScopeTest.java
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
- * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daotest.entity;
-
-import java.sql.SQLException;
-
-import de.greenrobot.dao.identityscope.IdentityScopeObject;
-import de.greenrobot.daotest.StringKeyValueEntity;
-
-public class StringKeyValueEntityIdentityScopeTest extends StringKeyValueEntityTest {
-    @Override
-    protected void setUp() throws Exception {
-        setIdentityScopeBeforeSetUp(new IdentityScopeObject<String, StringKeyValueEntity>());
-        super.setUp();
-    }
-
-    public void testLoadIdScope() throws SQLException {
-        StringKeyValueEntity entity = createEntityWithRandomPk();
-        dao.insert(entity);
-        StringKeyValueEntity entity2 = dao.load(entity.getKey());
-        StringKeyValueEntity entity3 = dao.load(entity.getKey());
-
-        assertSame(entity, entity2);
-        assertSame(entity2, entity3);
-    }
-
-    public void testLoadIdScope_load() throws SQLException {
-        StringKeyValueEntity entity = createEntityWithRandomPk();
-        dao.insert(entity);
-        dao.detach(entity);
-        StringKeyValueEntity entity2 = dao.load(entity.getKey());
-        StringKeyValueEntity entity3 = dao.load(entity.getKey());
-
-        assertNotSame(entity, entity2);
-        assertSame(entity2, entity3);
-    }
-
-    public void testDetach() throws SQLException {
-        StringKeyValueEntity entity = createEntityWithRandomPk();
-        dao.insert(entity);
-        dao.detach(entity);
-        StringKeyValueEntity entity2 = dao.load(entity.getKey());
-        dao.detach(entity2);
-        StringKeyValueEntity entity3 = dao.load(entity.getKey());
-
-        assertNotSame(entity, entity2);
-        assertNotSame(entity2, entity3);
-        assertNotSame(entity, entity3);
-    }
-
-    public void testDetachOther() throws SQLException {
-        StringKeyValueEntity entity = createEntityWithRandomPk();
-        dao.insert(entity);
-        dao.detach(entity);
-        StringKeyValueEntity entity2 = dao.load(entity.getKey());
-        dao.detach(entity);
-        StringKeyValueEntity entity3 = dao.load(entity.getKey());
-
-        assertSame(entity2, entity3);
-    }
-
-    public void testLoadAllScope() throws SQLException {
-        StringKeyValueEntity entity = createEntityWithRandomPk();
-        dao.insert(entity);
-        StringKeyValueEntity entity2 = dao.loadAll().get(0);
-        StringKeyValueEntity entity3 = dao.loadAll().get(0);
-
-        assertSame(entity, entity2);
-        assertSame(entity2, entity3);
-    }
-
-}
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/StringKeyValueEntityTest.java b/DaoTest/src/de/greenrobot/daotest/entity/StringKeyValueEntityTest.java
index 30792652..2480d8a8 100644
--- a/DaoTest/src/de/greenrobot/daotest/entity/StringKeyValueEntityTest.java
+++ b/DaoTest/src/de/greenrobot/daotest/entity/StringKeyValueEntityTest.java
@@ -1,7 +1,7 @@
 package de.greenrobot.daotest.entity;
 
-import junit.framework.Assert;
 import de.greenrobot.dao.test.AbstractDaoTestStringPk;
+
 import de.greenrobot.daotest.StringKeyValueEntity;
 import de.greenrobot.daotest.StringKeyValueEntityDao;
 
@@ -18,14 +18,4 @@ protected StringKeyValueEntity createEntity(String key) {
         return entity;
     }
 
-    public void testInsertWithoutPK() {
-        StringKeyValueEntity entity = createEntity(null);
-        try {
-            dao.insert(entity);
-            Assert.fail("Insert without pre-set PK succeeded");
-        } catch (Exception e) {
-            // Expected
-        }
-    }
-
 }
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/TestEntityIdentityScopeTest.java b/DaoTest/src/de/greenrobot/daotest/entity/TestEntityIdentityScopeTest.java
deleted file mode 100644
index db9bebba..00000000
--- a/DaoTest/src/de/greenrobot/daotest/entity/TestEntityIdentityScopeTest.java
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daotest.entity;
-
-import java.sql.SQLException;
-
-import de.greenrobot.dao.identityscope.IdentityScopeLong;
-import de.greenrobot.daotest.TestEntity;
-
-public class TestEntityIdentityScopeTest extends TestEntityTest {
-    @Override
-    protected void setUp() throws Exception {
-        setIdentityScopeBeforeSetUp(new IdentityScopeLong<TestEntity>());
-        super.setUp();
-    }
-
-    public void testLoadIdScope() throws SQLException {
-        TestEntity entity = createEntity(null);
-        dao.insert(entity);
-        TestEntity entity2 = dao.load(entity.getId());
-        TestEntity entity3 = dao.load(entity.getId());
-
-        assertSame(entity, entity2);
-        assertSame(entity2, entity3);
-    }
-
-    public void testDetach() throws SQLException {
-        TestEntity entity = createEntity(null);
-        dao.insert(entity);
-        dao.detach(entity);
-        TestEntity entity2 = dao.load(entity.getId());
-        dao.detach(entity2);
-        TestEntity entity3 = dao.load(entity.getId());
-
-        assertNotSame(entity, entity2);
-        assertNotSame(entity2, entity3);
-        assertNotSame(entity, entity3);
-    }
-
-    public void testDetachOther() throws SQLException {
-        TestEntity entity = createEntity(null);
-        dao.insert(entity);
-        dao.detach(entity);
-        TestEntity entity2 = dao.load(entity.getId());
-        dao.detach(entity);
-        TestEntity entity3 = dao.load(entity.getId());
-
-        assertSame(entity2, entity3);
-    }
-
-    public void testLoadAllScope() throws SQLException {
-        TestEntity entity = createEntity(null);
-        dao.insert(entity);
-        TestEntity entity2 = dao.loadAll().get(0);
-        TestEntity entity3 = dao.loadAll().get(0);
-
-        assertSame(entity, entity2);
-        assertSame(entity2, entity3);
-    }
-
-}
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/TestEntityTest.java b/DaoTest/src/de/greenrobot/daotest/entity/TestEntityTest.java
index 3436f95a..92c094a6 100644
--- a/DaoTest/src/de/greenrobot/daotest/entity/TestEntityTest.java
+++ b/DaoTest/src/de/greenrobot/daotest/entity/TestEntityTest.java
@@ -1,26 +1,7 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
 package de.greenrobot.daotest.entity;
 
-import java.sql.SQLException;
-
-import de.greenrobot.dao.DaoException;
 import de.greenrobot.dao.test.AbstractDaoTestLongPk;
+
 import de.greenrobot.daotest.TestEntity;
 import de.greenrobot.daotest.TestEntityDao;
 
@@ -34,36 +15,9 @@ public TestEntityTest() {
     protected TestEntity createEntity(Long key) {
         TestEntity entity = new TestEntity();
         entity.setId(key);
-        entity.setSimpleStringNotNull("green");
+        entity.setSimpleInt();
+        entity.setSimpleStringNotNull();
         return entity;
     }
 
-    public void testRefresh() throws SQLException {
-        TestEntity entity = createEntity(1l);
-        entity.setSimpleInteger(42);
-        entity.setSimpleString(null);
-        dao.insert(entity);
-        entity.setSimpleInteger(null);
-        entity.setSimpleString("temp");
-        dao.refresh(entity);
-        assertEquals(42, (int) entity.getSimpleInteger());
-        assertNull(entity.getSimpleString());
-    }
-
-    public void testRefreshIllegal() throws SQLException {
-        TestEntity entity = createEntity(1l);
-        try {
-            dao.refresh(entity);
-            fail("Exception expected");
-        } catch (DaoException expected) {
-        }
-        dao.insert(entity);
-        dao.delete(entity);
-        try {
-            dao.refresh(entity);
-            fail("Exception expected");
-        } catch (DaoException expected) {
-        }
-    }
-
 }
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/TestEntityTestBase.java b/DaoTest/src/de/greenrobot/daotest/entity/TestEntityTestBase.java
deleted file mode 100644
index 2ace247e..00000000
--- a/DaoTest/src/de/greenrobot/daotest/entity/TestEntityTestBase.java
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daotest.entity;
-
-import java.sql.SQLException;
-import java.util.ArrayList;
-
-import de.greenrobot.dao.query.LazyList;
-import de.greenrobot.dao.test.AbstractDaoTest;
-import de.greenrobot.daotest.TestEntity;
-import de.greenrobot.daotest.TestEntityDao;
-
-public abstract class TestEntityTestBase extends AbstractDaoTest<TestEntityDao, TestEntity, Long> {
-
-    public TestEntityTestBase() {
-        super(TestEntityDao.class);
-    }
-
-    protected TestEntity createEntity(int simpleInteger, String simpleString) {
-        TestEntity entity = new TestEntity();
-        entity.setId(null);
-        entity.setSimpleStringNotNull("green");
-        entity.setSimpleInteger(simpleInteger);
-        entity.setSimpleString(simpleString);
-        return entity;
-    }
-
-    protected ArrayList<TestEntity> insert(int count) throws SQLException {
-        ArrayList<TestEntity> list = new ArrayList<TestEntity>();
-        for (int i = 0; i < count; i++) {
-            TestEntity entity = createEntity(getSimpleInteger(i), getSimpleString(i));
-            list.add(entity);
-        }
-        dao.insertInTx(list);
-        return list;
-    }
-
-    protected String getSimpleString(int i) {
-        return "String" + (i + 100);
-    }
-
-    protected int getSimpleInteger(int i) {
-        return 100 + i;
-    }
-
-    protected void assertIds(ArrayList<TestEntity> list, LazyList<TestEntity> list2) {
-        for (int i = 0; i < list.size(); i++) {
-            TestEntity entity = list.get(i);
-            TestEntity lazyEntity = list2.get(i);
-            assertIds(entity, lazyEntity);
-        }
-    }
-
-    protected void assertIds(TestEntity entity, TestEntity entity2) {
-        assertEquals(entity.getId(), entity2.getId());
-    }
-
-}
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/ToManyEntityTest.java b/DaoTest/src/de/greenrobot/daotest/entity/ToManyEntityTest.java
index e67451fb..b8d7f48b 100644
--- a/DaoTest/src/de/greenrobot/daotest/entity/ToManyEntityTest.java
+++ b/DaoTest/src/de/greenrobot/daotest/entity/ToManyEntityTest.java
@@ -1,198 +1,21 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daotest.entity;
-
-import java.sql.SQLException;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-import de.greenrobot.dao.test.AbstractDaoSessionTest;
-import de.greenrobot.daotest.DaoMaster;
-import de.greenrobot.daotest.DaoSession;
-import de.greenrobot.daotest.ToManyEntity;
-import de.greenrobot.daotest.ToManyEntityDao;
-import de.greenrobot.daotest.ToManyTargetEntity;
-import de.greenrobot.daotest.ToManyTargetEntityDao;
-
-public class ToManyEntityTest extends AbstractDaoSessionTest<DaoMaster, DaoSession> {
-
-    private ToManyEntityDao toManyEntityDao;
-    private ToManyTargetEntityDao toManyTargetEntityDao;
-
-    public ToManyEntityTest() {
-        super(DaoMaster.class);
-    }
-
-    @Override
-    protected void setUp() throws Exception {
-        super.setUp();
-        toManyEntityDao = daoSession.getToManyEntityDao();
-        toManyTargetEntityDao = daoSession.getToManyTargetEntityDao();
-    }
-
-    public void testToManyBasics() throws SQLException {
-        int count = 0;
-        for (int i = 0; i < 16; i++) {
-            runTestToManyBasics(i + 1, i);
-            count += i;
-        }
-        assertEquals(count, toManyTargetEntityDao.count());
-    }
-
-    public void runTestToManyBasics(long id, int count) throws SQLException {
-        ToManyTargetEntity[] targetEntities = prepareToMany(id, count);
-
-        ToManyEntity testEntity = toManyEntityDao.load(id);
-        List<ToManyTargetEntity> resolvedToMany = testEntity.getToManyTargetEntityList();
-        assertSameEntities(targetEntities, resolvedToMany);
-    }
-
-    private void assertSameEntities(ToManyTargetEntity[] targetEntities, List<ToManyTargetEntity> resolvedToMany) {
-        int count = targetEntities.length;
-        assertEquals(count, resolvedToMany.size());
-
-        Map<Long, ToManyTargetEntity> resolvedMap = new HashMap<Long, ToManyTargetEntity>();
-        for (ToManyTargetEntity resolvedEntity : resolvedToMany) {
-            resolvedMap.put(resolvedEntity.getId(), resolvedEntity);
-        }
-        for (int i = 0; i < count; i++) {
-            long entityId = (long) targetEntities[i].getId();
-            assertTrue("ID=" + entityId, resolvedMap.containsKey(entityId));
-            assertSame(targetEntities[i], resolvedMap.get(entityId));
-        }
-    }
-
-    private ToManyTargetEntity[] prepareToMany(long id, int count) throws SQLException {
-        ToManyEntity entity = new ToManyEntity(id);
-        daoSession.insert(entity);
-        return insertTargetEntitites(id, count, null);
-    }
-
-    private ToManyTargetEntity[] insertTargetEntitites(Long toManyId, int count, String joinProperty) throws SQLException {
-        ToManyTargetEntity[] targetEntities = new ToManyTargetEntity[count];
-        for (int i = 0; i < count; i++) {
-            ToManyTargetEntity target = new ToManyTargetEntity();
-            target.setToManyId(toManyId);
-            target.setToManyIdDesc(toManyId);
-            target.setTargetJoinProperty(joinProperty);
-            targetEntities[i] = target;
-        }
-        toManyTargetEntityDao.insertInTx(targetEntities);
-        return targetEntities;
-    }
-
-    public void testGetToManyTwice() throws SQLException {
-        prepareToMany(1, 3);
-
-        ToManyEntity testEntity = toManyEntityDao.load(1l);
-        List<ToManyTargetEntity> resolvedToMany1 = testEntity.getToManyTargetEntityList();
-        List<ToManyTargetEntity> resolvedToMany2 = testEntity.getToManyTargetEntityList();
-        assertSame(resolvedToMany1, resolvedToMany2);
-    }
-
-    public void testResetToMany() throws SQLException {
-        ToManyTargetEntity[] targetEntities = prepareToMany(1, 3);
-
-        ToManyEntity testEntity = toManyEntityDao.load(1l);
-        List<ToManyTargetEntity> resolvedToMany1 = testEntity.getToManyTargetEntityList();
-        testEntity.resetToManyTargetEntityList();
-        List<ToManyTargetEntity> resolvedToMany2 = testEntity.getToManyTargetEntityList();
-        assertNotSame(resolvedToMany1, resolvedToMany2);
-        assertSameEntities(targetEntities, resolvedToMany2);
-    }
-
-    public void testChangeResetToMany() throws SQLException {
-        prepareToMany(1, 3);
-
-        ToManyEntity testEntity = toManyEntityDao.load(1l);
-        List<ToManyTargetEntity> resolvedToMany1 = testEntity.getToManyTargetEntityList();
-        testEntity.resetToManyTargetEntityList();
-
-        ToManyTargetEntity newEntity = new ToManyTargetEntity();
-        newEntity.setToManyId(1l);
-        daoSession.insert(newEntity);
-
-        List<ToManyTargetEntity> resolvedToMany2 = testEntity.getToManyTargetEntityList();
-        assertNotSame(resolvedToMany1, resolvedToMany2);
-        assertEquals(resolvedToMany1.size() + 1, resolvedToMany2.size());
-
-        testEntity.resetToManyTargetEntityList();
-        toManyTargetEntityDao.deleteAll();
-        List<ToManyTargetEntity> resolvedToMany3 = testEntity.getToManyTargetEntityList();
-        assertEquals(0, resolvedToMany3.size());
-    }
-
-    public void testToManyOrder() throws SQLException {
-        prepareToMany(1, 3);
-
-        ToManyEntity testEntity = toManyEntityDao.load(1l);
-        List<ToManyTargetEntity> resolvedToManyAsc = testEntity.getToManyTargetEntityList();
-        List<ToManyTargetEntity> resolvedToManyDesc = testEntity.getToManyDescList();
-        assertNotSame(resolvedToManyAsc, resolvedToManyDesc);
-        assertEquals(resolvedToManyAsc.get(1).getId(), resolvedToManyDesc.get(3).getId());
-        assertSame(resolvedToManyAsc.get(1), resolvedToManyDesc.get(3));
-        assertSame(resolvedToManyAsc.get(2), resolvedToManyDesc.get(2));
-        assertSame(resolvedToManyAsc.get(3), resolvedToManyDesc.get(1));
-    }
-
-    public void testJoinProperty() throws SQLException {
-        ToManyEntity entity = new ToManyEntity(1l);
-        entity.setSourceJoinProperty("JOIN ME");
-        daoSession.insert(entity);
-        insertTargetEntitites(null, 3, "JOIN ME");
-
-        ToManyEntity testEntity = toManyEntityDao.load(1l);
-        List<ToManyTargetEntity> targetEntities = testEntity.getToManyByJoinProperty();
-        assertEquals(3, targetEntities.size());
-
-        ToManyTargetEntity middleEntity = targetEntities.get(1);
-        middleEntity.setTargetJoinProperty("DON'T JOIN ME");
-        toManyTargetEntityDao.update(middleEntity);
-
-        testEntity.resetToManyByJoinProperty();
-        targetEntities = testEntity.getToManyByJoinProperty();
-        assertEquals(2, targetEntities.size());
-
-        assertFalse(middleEntity.getId() == targetEntities.get(0).getId());
-        assertFalse(middleEntity.getId() == targetEntities.get(1).getId());
-    }
-
-    public void testTwoJoinProperty() throws SQLException {
-        ToManyEntity entity = new ToManyEntity(1l);
-        entity.setSourceJoinProperty("JOIN ME");
-        daoSession.insert(entity);
-        insertTargetEntitites(1l, 3, "JOIN ME");
-
-        ToManyEntity testEntity = toManyEntityDao.load(1l);
-        List<ToManyTargetEntity> targetEntities = testEntity.getToManyJoinTwo();
-        assertEquals(3, targetEntities.size());
-
-        ToManyTargetEntity middleEntity = targetEntities.get(1);
-        middleEntity.setTargetJoinProperty("DON'T JOIN ME");
-        toManyTargetEntityDao.update(middleEntity);
-
-        testEntity.resetToManyJoinTwo();
-        targetEntities = testEntity.getToManyJoinTwo();
-        assertEquals(2, targetEntities.size());
-
-        assertFalse(middleEntity.getId() == targetEntities.get(0).getId());
-        assertFalse(middleEntity.getId() == targetEntities.get(1).getId());
-    }
-
-}
+package de.greenrobot.daotest.entity;
+
+import de.greenrobot.dao.test.AbstractDaoTestLongPk;
+
+import de.greenrobot.daotest.ToManyEntity;
+import de.greenrobot.daotest.ToManyEntityDao;
+
+public class ToManyEntityTest extends AbstractDaoTestLongPk<ToManyEntityDao, ToManyEntity> {
+
+    public ToManyEntityTest() {
+        super(ToManyEntityDao.class);
+    }
+
+    @Override
+    protected ToManyEntity createEntity(Long key) {
+        ToManyEntity entity = new ToManyEntity();
+        entity.setId(key);
+        return entity;
+    }
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/ToManyTargetEntityTest.java b/DaoTest/src/de/greenrobot/daotest/entity/ToManyTargetEntityTest.java
index 7170c14d..fc5a9df3 100644
--- a/DaoTest/src/de/greenrobot/daotest/entity/ToManyTargetEntityTest.java
+++ b/DaoTest/src/de/greenrobot/daotest/entity/ToManyTargetEntityTest.java
@@ -1,23 +1,7 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
 package de.greenrobot.daotest.entity;
 
 import de.greenrobot.dao.test.AbstractDaoTestLongPk;
+
 import de.greenrobot.daotest.ToManyTargetEntity;
 import de.greenrobot.daotest.ToManyTargetEntityDao;
 
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/TreeEntityTest.java b/DaoTest/src/de/greenrobot/daotest/entity/TreeEntityTest.java
index d8dfacdc..ce8c26e6 100644
--- a/DaoTest/src/de/greenrobot/daotest/entity/TreeEntityTest.java
+++ b/DaoTest/src/de/greenrobot/daotest/entity/TreeEntityTest.java
@@ -1,95 +1,21 @@
 package de.greenrobot.daotest.entity;
 
-import java.sql.SQLException;
+import de.greenrobot.dao.test.AbstractDaoTestLongPk;
 
-import de.greenrobot.dao.test.AbstractDaoSessionTest;
-import de.greenrobot.daotest.DaoMaster;
-import de.greenrobot.daotest.DaoSession;
 import de.greenrobot.daotest.TreeEntity;
 import de.greenrobot.daotest.TreeEntityDao;
 
-public class TreeEntityTest extends AbstractDaoSessionTest<DaoMaster, DaoSession> {
-
-    private TreeEntityDao treeEntityDao;
+public class TreeEntityTest extends AbstractDaoTestLongPk<TreeEntityDao, TreeEntity> {
 
     public TreeEntityTest() {
-        super(DaoMaster.class);
+        super(TreeEntityDao.class);
     }
 
     @Override
-    protected void setUp() throws Exception {
-        super.setUp();
-        treeEntityDao = daoSession.getTreeEntityDao();
-    }
-
-    public void testNavigateTreeFromLeaf() throws SQLException {
-        createTree();
-        daoSession.clear();
-
-        TreeEntity child1Child = treeEntityDao.load(101l);
-        assertEquals(0, child1Child.getChildren().size());
-
-        TreeEntity child1 = child1Child.getParent();
-        assertEquals(11l, child1.getId().longValue());
-        assertEquals(1, child1.getChildren().size());
-        assertSame(child1Child, child1.getChildren().get(0));
-
-        TreeEntity root = child1.getParent();
-        assertEquals(1l, root.getId().longValue());
-        assertEquals(2, root.getChildren().size());
-        assertNull(root.getParent());
-    }
-
-    public void testNavigateTreeFromMiddle() throws SQLException {
-        createTree();
-        daoSession.clear();
-
-        TreeEntity child1 = treeEntityDao.load(11l);
-        assertEquals(1, child1.getChildren().size());
-        TreeEntity child1Child = child1.getChildren().get(0);
-        assertEquals(101, child1Child.getId().longValue());
-        assertEquals(0, child1Child.getChildren().size());
-
-        TreeEntity root = child1.getParent();
-        assertEquals(1l, root.getId().longValue());
-        assertEquals(2, root.getChildren().size());
-        assertNull(root.getParent());
-    }
-
-    public void testNavigateTreeFromRoot() throws SQLException {
-        createTree();
-        daoSession.clear();
-
-        TreeEntity root = treeEntityDao.load(1l);
-        assertEquals(2, root.getChildren().size());
-        assertNull(root.getParent());
-
-        TreeEntity child1 = root.getChildren().get(0);
-        TreeEntity child2 = root.getChildren().get(1);
-        if (child1.getId() != 11l) {
-            child1 = child2;
-            child2 = root.getChildren().get(0);
-        }
-
-        assertSame(root, child1.getParent());
-        assertEquals(1, child1.getChildren().size());
-        TreeEntity child1Child = child1.getChildren().get(0);
-        assertEquals(101, child1Child.getId().longValue());
-        assertEquals(0, child1Child.getChildren().size());
-        
-        assertSame(root, child2.getParent());
-        assertEquals(0, child2.getChildren().size());
-    }
-
-    private void createTree() throws SQLException {
-        TreeEntity root = new TreeEntity(1l);
-        TreeEntity child1 = new TreeEntity(11l);
-        child1.setParent(root);
-        TreeEntity child2 = new TreeEntity(12l);
-        child2.setParent(root);
-        TreeEntity child1Child = new TreeEntity(101l);
-        child1Child.setParent(child1);
-        treeEntityDao.insertInTx(root, child1, child2, child1Child);
+    protected TreeEntity createEntity(Long key) {
+        TreeEntity entity = new TreeEntity();
+        entity.setId(key);
+        return entity;
     }
 
 }
diff --git a/DaoTest/src/de/greenrobot/daotest/performance/LoockupPerformanceTest.java b/DaoTest/src/de/greenrobot/daotest/performance/LoockupPerformanceTest.java
deleted file mode 100644
index 9b697d53..00000000
--- a/DaoTest/src/de/greenrobot/daotest/performance/LoockupPerformanceTest.java
+++ /dev/null
@@ -1,199 +0,0 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daotest.performance;
-
-import java.util.Date;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Random;
-
-import junit.framework.TestCase;
-import de.greenrobot.dao.DaoLog;
-import de.greenrobot.dao.internal.LongHashMap;
-import de.greenrobot.daotest.performance.target.LongHashMapAmarena2DZechner;
-import de.greenrobot.daotest.performance.target.LongHashMapJDBM;
-import de.greenrobot.daotest.performance.target.LongSparseArray;
-
-public class LoockupPerformanceTest extends TestCase {
-
-    Random random;
-    private String traceName;
-    private long start;
-
-    public LoockupPerformanceTest() {
-        this.random = new Random();
-    }
-
-    public void testHashMapPerformance() {
-        // runTests(100);
-        // runTests(1000);
-        // runTests(10000);
-        // runTests(100000); // hash: 1485/420ms; sparse: 148196/196ms
-        DaoLog.d("testHashMapPerformance DONE");
-    }
-
-    private void runTests(int count) {
-        runTests(count, false);
-        runTests(count, true);
-    }
-
-    private void runTests(int count, boolean randomKeys) {
-        DaoLog.d("-----------------------------------");
-        DaoLog.d("Look up " + count + (randomKeys ? " random" : " linear") + " keys on " + new Date());
-        DaoLog.d("-----------------------------------");
-        long[] keys = new long[count];
-        for (int i = 0; i < count; i++) {
-            if (randomKeys) {
-                keys[i] = random.nextLong();
-            } else {
-                keys[i] = i;
-            }
-        }
-        for (int i = 0; i < 3; i++) {
-            runMapTest(new HashMap<Long, Object>(count), keys, "hashmap");
-            // runMapTest(new WeakHashMap<Long, Object>(count), keys, "weakhashmap");
-            // runMapTest(new ConcurrentHashMap<Long, Object>(count), keys, "concurrent-hashmap");
-            // runLongSparseArrayTest(keys);
-            runLongHashMap(keys);
-            runLongHashMapAmarena2DZechnerTest(keys);
-            // runLongHashMapJDBMTest(keys);
-            DaoLog.d("-----------------------------------");
-        }
-    }
-
-    protected void runMapTest(Map<Long, Object> map, long[] keys, String name) {
-        startClock("put-" + name + "-" + keys.length);
-        for (long key : keys) {
-            map.put(key, this);
-        }
-        stopClock();
-
-        startClock("get-" + name + "-" + keys.length);
-        int lossCount = 0;
-        for (long key : keys) {
-            Object object = map.get(key);
-            if (object != this) {
-                lossCount++;
-            }
-        }
-        if (lossCount > 0) {
-            stopClock("losses: " + lossCount);
-        } else {
-            stopClock();
-        }
-    }
-
-    private void runLongSparseArrayTest(long[] keys) {
-        if (keys.length > 10000) {
-            DaoLog.d("Skipping runLongSparseArrayTest for " + keys.length);
-            return;
-        }
-        LongSparseArray<Object> array = new LongSparseArray<Object>(keys.length);
-
-        startClock("put-sparsearray-" + keys.length);
-        for (long key : keys) {
-            array.put(key, this);
-        }
-        stopClock();
-
-        startClock("get-sparsearray-" + keys.length);
-        for (long key : keys) {
-            Object object = array.get(key);
-            if (object != this) {
-                fail("Ups: " + object);
-            }
-        }
-        stopClock();
-    }
-
-    private void runLongHashMapJDBMTest(long[] keys) {
-        LongHashMapJDBM<Object> map = new LongHashMapJDBM<Object>(keys.length);
-
-        startClock("put-jdbm-" + keys.length);
-        for (long key : keys) {
-            map.put(key, this);
-        }
-        stopClock();
-
-        startClock("get-jdbm-" + keys.length);
-        for (long key : keys) {
-            Object object = map.get(key);
-            if (object != this) {
-                fail("Ups: " + object);
-            }
-        }
-        stopClock();
-    }
-
-    private void runLongHashMap(long[] keys) {
-        LongHashMap<Object> map = new LongHashMap<Object>(keys.length);
-        map.reserveRoom(keys.length);
-
-        startClock("put-my-" + keys.length);
-        for (long key : keys) {
-            map.put(key, this);
-        }
-        stopClock();
-
-        startClock("get-my-" + keys.length);
-        for (long key : keys) {
-            Object object = map.get(key);
-            if (object != this) {
-                fail("Ups: " + object);
-            }
-        }
-        stopClock();
-        map.logStats();
-    }
-
-    private void runLongHashMapAmarena2DZechnerTest(long[] keys) {
-        LongHashMapAmarena2DZechner<Object> map = new LongHashMapAmarena2DZechner<Object>(keys.length);
-
-        startClock("put-amarena-" + keys.length);
-        for (long key : keys) {
-            map.put(key, this);
-        }
-        stopClock();
-
-        startClock("get-amarena-" + keys.length);
-        for (long key : keys) {
-            Object object = map.get(key);
-            if (object != this) {
-                fail("Ups: " + object);
-            }
-        }
-        stopClock();
-        map.logStats();
-    }
-
-    protected void startClock(String traceName) {
-        this.traceName = traceName;
-        start = System.currentTimeMillis();
-    }
-
-    protected void stopClock() {
-        stopClock(null);
-    }
-
-    protected void stopClock(String extraInfoOrNull) {
-        long time = System.currentTimeMillis() - start;
-        String extraLog = extraInfoOrNull != null ? " (" + extraInfoOrNull + ")" : "";
-        DaoLog.d(traceName + " completed in " + time + "ms" + extraLog);
-    }
-
-}
diff --git a/DaoTest/src/de/greenrobot/daotest/performance/PerformanceTest.java b/DaoTest/src/de/greenrobot/daotest/performance/PerformanceTest.java
deleted file mode 100644
index c01c3276..00000000
--- a/DaoTest/src/de/greenrobot/daotest/performance/PerformanceTest.java
+++ /dev/null
@@ -1,170 +0,0 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daotest.performance;
-
-import java.sql.SQLException;
-import java.util.ArrayList;
-import java.util.Date;
-import java.util.List;
-
-import android.os.Debug;
-import de.greenrobot.dao.AbstractDao;
-import de.greenrobot.dao.DaoLog;
-import de.greenrobot.dao.test.AbstractDaoTest;
-
-public abstract class PerformanceTest<D extends AbstractDao<T, K>, T, K> extends AbstractDaoTest<D, T, K> {
-    long start;
-    private String traceName;
-    boolean useTraceView = false;
-
-    public PerformanceTest(Class<D> daoClass) {
-        super(daoClass, false);
-    }
-
-    public void testPerformance() throws Exception {
-        // runTests(1000);
-        // runTests(1000);
-        // runTests(1000);
-        // runTests(1000);
-        // runTests(1000);
-        // runTests(1000);
-    }
-
-    protected void runTests(int entityCount) throws SQLException {
-        DaoLog.d("####################");
-        DaoLog.d(getClass().getSimpleName() + ": " + entityCount + " entities on " + new Date());
-        DaoLog.d("####################");
-        clearIdentityScopeIfAny();
-
-        List<T> list = new ArrayList<T>(entityCount);
-        for (int i = 0; i < entityCount; i++) {
-            list.add(createEntity());
-        }
-        System.gc();
-
-        dao.deleteAll();
-        // runOneByOneTests(list, entityCount, entityCount / 10);
-        dao.deleteAll();
-        DaoLog.d("------------------------");
-        System.gc();
-
-        // runBatchTests(list);
-
-        startClock("delete-all");
-        dao.deleteAll();
-        stopClock();
-        System.gc();
-    }
-
-    protected void runOneByOneTests(List<T> list, int loadCount, int modifyCount) throws SQLException {
-        dao.insertInTx(list);
-        List<K> keys = new ArrayList<K>(loadCount);
-        for (int i = 0; i < loadCount; i++) {
-            keys.add(daoAccess.getKey(list.get(i)));
-        }
-        clearIdentityScopeIfAny();
-        System.gc();
-
-        list = runLoadOneByOne(keys, "load-one-by-one-1");
-        list = runLoadOneByOne(keys, "load-one-by-one-2");
-        Debug.stopMethodTracing();
-
-        dao.deleteAll();
-        System.gc();
-
-        startClock("insert-one-by-one");
-        for (int i = 0; i < modifyCount; i++) {
-            dao.insert(list.get(i));
-        }
-        stopClock(modifyCount + " entities");
-        System.gc();
-
-        startClock("update-one-by-one");
-        for (int i = 0; i < modifyCount; i++) {
-            dao.update(list.get(i));
-        }
-        stopClock(modifyCount + " entities");
-        System.gc();
-
-        startClock("delete-one-by-one");
-        for (int i = 0; i < modifyCount; i++) {
-            dao.delete(list.get(i));
-        }
-        stopClock(modifyCount + " entities");
-        System.gc();
-    }
-
-    protected List<T> runLoadOneByOne(List<K> keys, String traceName) throws SQLException {
-        List<T> list = new ArrayList<T>(keys.size());
-        startClock(traceName);
-        for (K key : keys) {
-            list.add(dao.load(key));
-        }
-        stopClock(keys.size() + " entities");
-        return list;
-    }
-
-    protected void runBatchTests(List<T> list) throws SQLException {
-        startClock("insert");
-        dao.insertInTx(list);
-        stopClock(list.size() + " entities");
-
-        list = null;
-        System.gc();
-
-        clearIdentityScopeIfAny();
-        list = runLoadAll("load-all-1");
-        list = runLoadAll("load-all-2");
-
-        startClock("update");
-        dao.updateInTx(list);
-        stopClock(list.size() + " entities");
-    }
-
-    protected List<T> runLoadAll(String traceName) throws SQLException {
-        startClock(traceName);
-        List<T> list = dao.loadAll();
-        stopClock(list.size() + " entities");
-        return list;
-    }
-
-    protected void startClock(String traceName) {
-        System.gc();
-        this.traceName = traceName;
-        if (useTraceView) {
-            Debug.startMethodTracing(traceName);
-        }
-        start = System.currentTimeMillis();
-    }
-
-    protected void stopClock() {
-        stopClock(null);
-    }
-
-    protected void stopClock(String extraInfoOrNull) {
-        long time = System.currentTimeMillis() - start;
-        String extraLog = extraInfoOrNull != null ? " (" + extraInfoOrNull + ")" : "";
-        DaoLog.d(traceName + " completed in " + time + "ms" + extraLog);
-        if (useTraceView) {
-            Debug.stopMethodTracing();
-        }
-        System.gc();
-    }
-
-    protected abstract T createEntity();
-}
diff --git a/DaoTest/src/de/greenrobot/daotest/performance/PerformanceTestNotNull.java b/DaoTest/src/de/greenrobot/daotest/performance/PerformanceTestNotNull.java
deleted file mode 100644
index 7b6be735..00000000
--- a/DaoTest/src/de/greenrobot/daotest/performance/PerformanceTestNotNull.java
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daotest.performance;
-
-import de.greenrobot.daotest.SimpleEntityNotNull;
-import de.greenrobot.daotest.SimpleEntityNotNullDao;
-import de.greenrobot.daotest.entity.SimpleEntityNotNullHelper;
-
-public class PerformanceTestNotNull extends PerformanceTest<SimpleEntityNotNullDao, SimpleEntityNotNull, Long> {
-
-    static long sequence;
-
-    public PerformanceTestNotNull() {
-        super(SimpleEntityNotNullDao.class);
-    }
-
-    @Override
-    protected SimpleEntityNotNull createEntity() {
-        return SimpleEntityNotNullHelper.createEntity(sequence++);
-    }
-
-}
diff --git a/DaoTest/src/de/greenrobot/daotest/performance/PerformanceTestNotNullIdentityScope.java b/DaoTest/src/de/greenrobot/daotest/performance/PerformanceTestNotNullIdentityScope.java
deleted file mode 100644
index eabbb7c0..00000000
--- a/DaoTest/src/de/greenrobot/daotest/performance/PerformanceTestNotNullIdentityScope.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daotest.performance;
-
-import de.greenrobot.dao.identityscope.IdentityScopeLong;
-import de.greenrobot.daotest.SimpleEntityNotNull;
-
-public class PerformanceTestNotNullIdentityScope extends PerformanceTestNotNull {
-
-    @Override
-    protected void setUp() throws Exception {
-        IdentityScopeLong<SimpleEntityNotNull> identityScope = new IdentityScopeLong< SimpleEntityNotNull>();
-        setIdentityScopeBeforeSetUp(identityScope);
-        super.setUp();
-    }
-
-}
diff --git a/DaoTest/src/de/greenrobot/daotest/performance/ReflectionPerformanceTest.java b/DaoTest/src/de/greenrobot/daotest/performance/ReflectionPerformanceTest.java
deleted file mode 100644
index e71f1ab8..00000000
--- a/DaoTest/src/de/greenrobot/daotest/performance/ReflectionPerformanceTest.java
+++ /dev/null
@@ -1,128 +0,0 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daotest.performance;
-
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-
-import de.greenrobot.dao.DaoLog;
-
-public class ReflectionPerformanceTest // extends TestCase
-{
-
-    int intValue;
-    String stringValue;
-
-    public int getIntValue() {
-        return intValue;
-    }
-
-    public void setIntValue(int inValue) {
-        this.intValue = inValue;
-    }
-
-    public String getStringValue() {
-        return stringValue;
-    }
-
-    public void setStringValue(String stringValue) {
-        this.stringValue = stringValue;
-    }
-
-    public void testSetIntPerf() throws SecurityException, NoSuchMethodException, IllegalArgumentException,
-            IllegalAccessException, InvocationTargetException {
-        int count = 100000;
-
-        long start = System.currentTimeMillis();
-        for (int i = 0; i < count; i++) {
-            setIntValue(i);
-        }
-        long time = System.currentTimeMillis() - start;
-
-        Method method = getClass().getMethod("setIntValue", int.class);
-        long start2 = System.currentTimeMillis();
-        for (int i = 0; i < count; i++) {
-            method.invoke(this, i);
-        }
-        long time2 = System.currentTimeMillis() - start2;
-        DaoLog.d("set int: normal=" + time + "ms, reflected=" + time2 + "ms, " + 1000 * count / time2
-                + " refelected ops/s, slower=" + ((float) time2) / time);
-
-    }
-
-    public void testGetIntPerf() throws SecurityException, NoSuchMethodException, IllegalArgumentException,
-            IllegalAccessException, InvocationTargetException {
-        int count = 100000;
-
-        long start = System.currentTimeMillis();
-        for (int i = 0; i < count; i++) {
-            int x = getIntValue();
-        }
-        long time = System.currentTimeMillis() - start;
-
-        Method method = getClass().getMethod("getIntValue");
-        long start2 = System.currentTimeMillis();
-        for (int i = 0; i < count; i++) {
-            int x = (Integer) method.invoke(this);
-        }
-        long time2 = System.currentTimeMillis() - start2;
-        DaoLog.d("get int: normal=" + time + "ms, reflected=" + time2 + "ms, " + 1000 * count / time2
-                + " refelected ops/s, slower=" + ((float) time2) / time);
-    }
-
-    public void testSetStringPerf() throws SecurityException, NoSuchMethodException, IllegalArgumentException,
-            IllegalAccessException, InvocationTargetException {
-        int count = 100000;
-
-        long start = System.currentTimeMillis();
-        for (int i = 0; i < count; i++) {
-            setStringValue("the quick brown fox");
-        }
-        long time = System.currentTimeMillis() - start;
-
-        Method method = getClass().getMethod("setStringValue", String.class);
-        long start2 = System.currentTimeMillis();
-        for (int i = 0; i < count; i++) {
-            method.invoke(this, "the quick brown fox");
-        }
-        long time2 = System.currentTimeMillis() - start2;
-        DaoLog.d("set String: normal=" + time + "ms, reflected=" + time2 + "ms, " + 1000 * count / time2
-                + " refelected ops/s, slower=" + ((float) time2) / time);
-
-    }
-
-    public void testGetStringPerf() throws SecurityException, NoSuchMethodException, IllegalArgumentException,
-            IllegalAccessException, InvocationTargetException {
-        int count = 100000;
-
-        long start = System.currentTimeMillis();
-        for (int i = 0; i < count; i++) {
-            String x = getStringValue();
-        }
-        long time = System.currentTimeMillis() - start;
-
-        Method method = getClass().getMethod("getStringValue");
-        long start2 = System.currentTimeMillis();
-        for (int i = 0; i < count; i++) {
-            String x = (String) method.invoke(this);
-        }
-        long time2 = System.currentTimeMillis() - start2;
-        DaoLog.d("get String: normal=" + time + "ms, reflected=" + time2 + "ms, " + 1000 * count / time2
-                + " refelected ops/s, slower=" + ((float) time2) / time);
-    }
-}
diff --git a/DaoTest/src/de/greenrobot/daotest/performance/target/ArrayUtils.java b/DaoTest/src/de/greenrobot/daotest/performance/target/ArrayUtils.java
deleted file mode 100644
index cb415d53..00000000
--- a/DaoTest/src/de/greenrobot/daotest/performance/target/ArrayUtils.java
+++ /dev/null
@@ -1,135 +0,0 @@
-/*
- * Copyright (C) 2006 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package de.greenrobot.daotest.performance.target;
-
-import java.lang.reflect.Array;
-
-// XXX these should be changed to reflect the actual memory allocator we use.
-// it looks like right now objects want to be powers of 2 minus 8
-// and the array size eats another 4 bytes
-
-/**
- * ArrayUtils contains some methods that you can call to find out
- * the most efficient increments by which to grow arrays.
- */
-public class ArrayUtils
-{
-    private static Object[] EMPTY = new Object[0];
-    private static final int CACHE_SIZE = 73;
-    private static Object[] sCache = new Object[CACHE_SIZE];
-
-    private ArrayUtils() { /* cannot be instantiated */ }
-
-    public static int idealByteArraySize(int need) {
-        for (int i = 4; i < 32; i++)
-            if (need <= (1 << i) - 12)
-                return (1 << i) - 12;
-
-        return need;
-    }
-
-    public static int idealBooleanArraySize(int need) {
-        return idealByteArraySize(need);
-    }
-
-    public static int idealShortArraySize(int need) {
-        return idealByteArraySize(need * 2) / 2;
-    }
-
-    public static int idealCharArraySize(int need) {
-        return idealByteArraySize(need * 2) / 2;
-    }
-
-    public static int idealIntArraySize(int need) {
-        return idealByteArraySize(need * 4) / 4;
-    }
-
-    public static int idealFloatArraySize(int need) {
-        return idealByteArraySize(need * 4) / 4;
-    }
-
-    public static int idealObjectArraySize(int need) {
-        return idealByteArraySize(need * 4) / 4;
-    }
-
-    public static int idealLongArraySize(int need) {
-        return idealByteArraySize(need * 8) / 8;
-    }
-
-    /**
-     * Checks if the beginnings of two byte arrays are equal.
-     *
-     * @param array1 the first byte array
-     * @param array2 the second byte array
-     * @param length the number of bytes to check
-     * @return true if they're equal, false otherwise
-     */
-    public static boolean equals(byte[] array1, byte[] array2, int length) {
-        if (array1 == array2) {
-            return true;
-        }
-        if (array1 == null || array2 == null || array1.length < length || array2.length < length) {
-            return false;
-        }
-        for (int i = 0; i < length; i++) {
-            if (array1[i] != array2[i]) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    /**
-     * Returns an empty array of the specified type.  The intent is that
-     * it will return the same empty array every time to avoid reallocation,
-     * although this is not guaranteed.
-     */
-    public static <T> T[] emptyArray(Class<T> kind) {
-        if (kind == Object.class) {
-            return (T[]) EMPTY;
-        }
-
-        int bucket = ((System.identityHashCode(kind) / 8) & 0x7FFFFFFF) % CACHE_SIZE;
-        Object cache = sCache[bucket];
-
-        if (cache == null || cache.getClass().getComponentType() != kind) {
-            cache = Array.newInstance(kind, 0);
-            sCache[bucket] = cache;
-
-            // Log.e("cache", "new empty " + kind.getName() + " at " + bucket);
-        }
-
-        return (T[]) cache;
-    }
-
-    /**
-     * Checks that value is present as at least one of the elements of the array.
-     * @param array the array to check in
-     * @param value the value to check for
-     * @return true if the value is present in the array
-     */
-    public static <T> boolean contains(T[] array, T value) {
-        for (T element : array) {
-            if (element == null) {
-                if (value == null) return true;
-            } else {
-                if (value != null && element.equals(value)) return true;
-            }
-        }
-        return false;
-    }
-}
diff --git a/DaoTest/src/de/greenrobot/daotest/performance/target/LongHashMapAmarena2DZechner.java b/DaoTest/src/de/greenrobot/daotest/performance/target/LongHashMapAmarena2DZechner.java
deleted file mode 100644
index a28e836b..00000000
--- a/DaoTest/src/de/greenrobot/daotest/performance/target/LongHashMapAmarena2DZechner.java
+++ /dev/null
@@ -1,249 +0,0 @@
-/*******************************************************************************
- * Copyright 2010 Mario Zechner (contact@badlogicgames.com)
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
- * License. You may obtain a copy of the License at
- * 
- * http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS"
- * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language
- * governing permissions and limitations under the License.
- ******************************************************************************/
-
-package de.greenrobot.daotest.performance.target;
-
-import java.util.Iterator;
-
-import de.greenrobot.dao.DaoLog;
-
-/**
- * An long to object hashmap, taken from Amarena2D (thanks Christoph :p).
- * 
- * @author christop widulle
- * 
- * @param <T>
- */
-public class LongHashMapAmarena2DZechner<T> {
-
-    private Entry[] table;
-    private float loadFactor;
-    private int size, mask, capacity, threshold;
-
-    public LongHashMapAmarena2DZechner() {
-        this(16, 0.75f);
-    }
-
-    public LongHashMapAmarena2DZechner(int initialCapacity) {
-        this(initialCapacity, 0.75f);
-    }
-
-    public LongHashMapAmarena2DZechner(int initialCapacity, float loadFactor) {
-        if (initialCapacity > 1 << 30)
-            throw new IllegalArgumentException("initialCapacity is too large.");
-        if (initialCapacity < 0)
-            throw new IllegalArgumentException("initialCapacity must be greater than zero.");
-        if (loadFactor <= 0)
-            throw new IllegalArgumentException("initialCapacity must be greater than zero.");
-        capacity = 1;
-        while (capacity < initialCapacity) {
-            capacity <<= 1;
-        }
-        this.loadFactor = loadFactor;
-        this.threshold = (int) (capacity * loadFactor);
-        this.table = new Entry[capacity];
-        this.mask = capacity - 1;
-    }
-
-    public boolean containsValue(Object value) {
-        Entry[] table = this.table;
-        for (int i = table.length; i-- > 0;)
-            for (Entry e = table[i]; e != null; e = e.next)
-                if (e.value.equals(value))
-                    return true;
-        return false;
-    }
-
-    public boolean containsKey(long key) {
-        int index = ((int) key) & mask;
-        for (Entry e = table[index]; e != null; e = e.next)
-            if (e.key == key)
-                return true;
-        return false;
-    }
-
-    @SuppressWarnings("unchecked")
-    public T get(long key) {
-        int index = (int) (key & mask);
-        for (Entry e = table[index]; e != null; e = e.next)
-            if (e.key == key)
-                return (T) e.value;
-        return null;
-    }
-
-    @SuppressWarnings("unchecked")
-    public T put(long key, T value) {
-        int index = (int) (key & mask);
-        // Check if key already exists.
-        for (Entry e = table[index]; e != null; e = e.next) {
-            if (e.key != key)
-                continue;
-            Object oldValue = e.value;
-            e.value = value;
-            return (T) oldValue;
-        }
-        table[index] = new Entry(key, value, table[index]);
-        if (size++ >= threshold) {
-            // Rehash.
-            int newCapacity = 2 * capacity;
-            Entry[] newTable = new Entry[newCapacity];
-            Entry[] src = table;
-            int bucketmask = newCapacity - 1;
-            for (int j = 0; j < src.length; j++) {
-                Entry e = src[j];
-                if (e != null) {
-                    src[j] = null;
-                    do {
-                        Entry next = e.next;
-                        index = (int) (e.key & bucketmask);
-                        e.next = newTable[index];
-                        newTable[index] = e;
-                        e = next;
-                    } while (e != null);
-                }
-            }
-            table = newTable;
-            capacity = newCapacity;
-            threshold = (int) (newCapacity * loadFactor);
-            mask = capacity - 1;
-        }
-        return null;
-    }
-
-    @SuppressWarnings("unchecked")
-    public T remove(long key) {
-        int index = (int) (key & mask);
-        Entry prev = table[index];
-        Entry e = prev;
-        while (e != null) {
-            Entry next = e.next;
-            if (e.key == key) {
-                size--;
-                if (prev == e) {
-                    table[index] = next;
-                } else {
-                    prev.next = next;
-                }
-                return (T) e.value;
-            }
-            prev = e;
-            e = next;
-        }
-        return null;
-    }
-
-    public int size() {
-        return size;
-    }
-
-    public void clear() {
-        Entry[] table = this.table;
-        for (int index = table.length; --index >= 0;)
-            table[index] = null;
-        size = 0;
-    }
-
-    static class Entry {
-        final long key;
-        Object value;
-        Entry next;
-
-        Entry(long k, Object v, Entry n) {
-            key = k;
-            value = v;
-            next = n;
-        }
-    }
-
-    EntryIterable iterable = new EntryIterable();
-
-    public Iterable<T> values() {
-        iterable.reset();
-        return iterable;
-    }
-
-    class EntryIterable implements Iterable<T> {
-        int currIndex = -1;
-        Entry currEntry = null;
-
-        Iterator<T> iter = new Iterator<T>() {
-            @Override
-            public boolean hasNext() {
-                if (currEntry == null) {
-                    if (!loadNextEntry())
-                        return false;
-                } else {
-                    if (currEntry.next == null) {
-                        if (loadNextEntry() == false)
-                            return false;
-                    } else
-                        currEntry = currEntry.next;
-                }
-
-                return true;
-            }
-
-            @SuppressWarnings("synthetic-access")
-            private boolean loadNextEntry() {
-                while (true) {
-                    currIndex++;
-                    if (currIndex >= table.length)
-                        return false;
-
-                    if (table[currIndex] == null)
-                        continue;
-                    else {
-                        currEntry = table[currIndex];
-                        return true;
-                    }
-                }
-            }
-
-            @SuppressWarnings("unchecked")
-            @Override
-            public T next() {
-                return (T) currEntry.value;
-            }
-
-            @Override
-            public void remove() {
-                throw new UnsupportedOperationException("not implemented");
-            }
-
-        };
-
-        public void reset() {
-            currIndex = -1;
-            currEntry = null;
-        }
-
-        @Override
-        public Iterator<T> iterator() {
-            return iter;
-        }
-
-    }
-
-    public void logStats() {
-        int collisions = 0;
-        for (Entry entry : table) {
-            while (entry != null && entry.next != null) {
-                collisions++;
-                entry = entry.next;
-            }
-        }
-        DaoLog.d("load: " + ((float) size) / capacity + ", size: " + size + ", capa: " + capacity + ", collisions: "
-                + collisions + ", collision ratio: " + ((float) collisions) / size);
-    }
-
-}
diff --git a/DaoTest/src/de/greenrobot/daotest/performance/target/LongHashMapJDBM.java b/DaoTest/src/de/greenrobot/daotest/performance/target/LongHashMapJDBM.java
deleted file mode 100644
index 3eeee1cb..00000000
--- a/DaoTest/src/de/greenrobot/daotest/performance/target/LongHashMapJDBM.java
+++ /dev/null
@@ -1,587 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package de.greenrobot.daotest.performance.target;
-
-import java.io.Serializable;
-import java.util.Arrays;
-import java.util.ConcurrentModificationException;
-import java.util.Iterator;
-import java.util.NoSuchElementException;
-
-/**
- * Hash Map which uses primitive long as key. 
- * Main advantage is new instanceof of Long does not have to be created for each lookup.
- * <p>
- * This code comes from Android, which in turns comes to Apache Harmony. 
- * This class was modified to use primitive longs and stripped down to consume less space. 
- * <p>
- * Author of JDBM modifications: Jan Kotek
- * <p>
- * Note: This map have weakened hash function, this works well for JDBM, but may be wrong for many other applications.  
- */
-public class LongHashMapJDBM<V> implements  Serializable {
-    private static final long serialVersionUID = 362499999763181265L;
-
-    protected int elementCount;
-
-    protected Entry<V>[] elementData;
-
-    private final float loadFactor;
-
-    protected int threshold;
-
-    transient int modCount = 0;	
-
-    private static final int DEFAULT_SIZE = 16;
-    
-    transient Entry<V> reuseAfterDelete = null;
-
-    static final class Entry<V> {
-
-        Entry<V> next;
-
-        long key;
-        V value;
-        
-        public boolean equals(Object object) {
-            if (this == object) {
-                return true;
-            }
-            if (object instanceof Entry) {
-                Entry<?> entry = (Entry) object;
-                return ( key == entry.key)
-                        && (value == null ? entry.value == null : value
-                                .equals(entry.value));
-            }
-            return false;
-        }
-
-
-        
-        public int hashCode() {
-            return (int)(key)
-                    ^ (value == null ? 0 : value.hashCode());
-        }
-
-        
-        
-        public String toString() {
-            return key + "=" + value;
-        }
-        
-
-        
-        Entry(long theKey) {
-        	this.key = theKey;
-        	this.value = null;
-        }
-
-        Entry(long theKey, V theValue) {
-            this.key = theKey;
-            this.value = theValue;
-            //origKeyHash = (int)(theKey ^ (theKey >>> 32));
-        }
-
-    }
-    
-
-    interface EntryType<RT,VT> {
-        RT get(Entry<VT> entry);
-    }
-
-    static class HashMapIterator<E,VT> implements Iterator<E> {
-        private int position = 0;
-
-        int expectedModCount;
-
-        final EntryType<E, VT> type;
-
-        boolean canRemove = false;
-
-        Entry<VT> entry;
-
-        Entry<VT> lastEntry;
-
-        final LongHashMapJDBM<VT> associatedMap;
-
-        HashMapIterator(EntryType<E, VT> value, LongHashMapJDBM<VT> hm) {
-            associatedMap = hm;
-            type = value;
-            expectedModCount = hm.modCount;
-        }
-
-        public boolean hasNext() {
-            if (entry != null) {
-                return true;
-            }
-            // BEGIN android-changed
-            Entry<VT>[] elementData = associatedMap.elementData;
-            int length = elementData.length;
-            int newPosition = position;
-            boolean result = false;
-
-            while (newPosition < length) {
-                if (elementData[newPosition] == null) {
-                    newPosition++;
-                } else {
-                    result = true;
-                    break;
-                }
-            }
-
-            position = newPosition;
-            return result;
-            // END android-changed
-        }
-
-        void checkConcurrentMod() throws ConcurrentModificationException {
-            if (expectedModCount != associatedMap.modCount) {
-                throw new ConcurrentModificationException();
-            }
-        }
-
-        public E next() {
-            // BEGIN android-changed
-            // inline checkConcurrentMod()
-            if (expectedModCount != associatedMap.modCount) {
-                throw new ConcurrentModificationException();
-            }
-            if (!hasNext()) {
-                throw new NoSuchElementException();
-            }
-
-            Entry<VT> result;
-            Entry<VT> _entry  = entry;
-            if (_entry == null) {
-                result = lastEntry = associatedMap.elementData[position++];
-                entry = lastEntry.next;
-            } else {
-                if (lastEntry.next != _entry) {
-                    lastEntry = lastEntry.next;
-                }
-                result = _entry;
-                entry = _entry.next;
-            }
-            canRemove = true;
-            return type.get(result);
-            // END android-changed
-        }
-
-        public void remove() {
-            checkConcurrentMod();
-            if (!canRemove) {
-                throw new IllegalStateException();
-            }
-
-            canRemove = false;
-            associatedMap.modCount++;
-            if (lastEntry.next == entry) {
-                while (associatedMap.elementData[--position] == null) {
-                    // Do nothing
-                }
-                associatedMap.elementData[position] = associatedMap.elementData[position].next;
-                entry = null;
-            } else {
-                lastEntry.next = entry;
-            }
-            if(lastEntry!=null){
-            	Entry<VT> reuse = lastEntry;
-            	lastEntry = null;
-            	reuse.key = Long.MIN_VALUE;
-            	reuse.value = null;
-            	associatedMap.reuseAfterDelete = reuse;
-            }
-
-            associatedMap.elementCount--;
-            expectedModCount++;
-        }
-    }
-
-
-
-    @SuppressWarnings("unchecked")
-    Entry<V>[] newElementArray(int s) {
-        return new Entry[s];
-    }
-
-    /**
-     * Constructs a new empty {@code HashMap} instance.
-     * 
-     * @since Android 1.0
-     */
-    public LongHashMapJDBM() {
-        this(DEFAULT_SIZE);
-    }
-
-    /**
-     * Constructs a new {@code HashMap} instance with the specified capacity.
-     * 
-     * @param capacity
-     *            the initial capacity of this hash map.
-     * @throws IllegalArgumentException
-     *                when the capacity is less than zero.
-     * @since Android 1.0
-     */
-    public LongHashMapJDBM(int capacity) {
-        if (capacity >= 0) {
-            elementCount = 0;
-            elementData = newElementArray(capacity == 0 ? 1 : capacity);
-            loadFactor = 0.75f; // Default load factor of 0.75
-            computeMaxSize();
-        } else {
-            throw new IllegalArgumentException();
-        }
-    }
-
-    /**
-     * Constructs a new {@code HashMap} instance with the specified capacity and
-     * load factor.
-     * 
-     * @param capacity
-     *            the initial capacity of this hash map.
-     * @param loadFactor
-     *            the initial load factor.
-     * @throws IllegalArgumentException
-     *                when the capacity is less than zero or the load factor is
-     *                less or equal to zero.
-     * @since Android 1.0
-     */
-    public LongHashMapJDBM(int capacity, float loadFactor) {
-        if (capacity >= 0 && loadFactor > 0) {
-            elementCount = 0;
-            elementData = newElementArray(capacity == 0 ? 1 : capacity);
-            this.loadFactor = loadFactor;
-            computeMaxSize();
-        } else {
-            throw new IllegalArgumentException();
-        }
-    }
-
-
-
-    // BEGIN android-changed
-    /**
-     * Removes all mappings from this hash map, leaving it empty.
-     * 
-     * @see #isEmpty
-     * @see #size
-     * @since Android 1.0
-     */
-    
-    public void clear() {
-        if (elementCount > 0) {
-            elementCount = 0;
-            Arrays.fill(elementData, null);
-            modCount++;
-        }
-    }
-    // END android-changed
-
-    /**
-     * Returns a shallow copy of this map.
-     * 
-     * @return a shallow copy of this map.
-     * @since Android 1.0
-     */
-    
-
-    private void computeMaxSize() {
-        threshold = (int) (elementData.length * loadFactor);
-    }
-
-    /**
-     * Returns whether this map contains the specified key.
-     * 
-     * @param key
-     *            the key to search for.
-     * @return {@code true} if this map contains the specified key,
-     *         {@code false} otherwise.
-     * @since Android 1.0
-     */
-    
-    public boolean containsKey(long key) {
-            int hash = (int)(key);
-            int index = (hash & 0x7FFFFFFF) % elementData.length;
-            Entry<V> m = findNonNullKeyEntry(key, index, hash);
-        return m != null;
-    }
-
-    /**
-     * Returns whether this map contains the specified value.
-     * 
-     * @param value
-     *            the value to search for.
-     * @return {@code true} if this map contains the specified value,
-     *         {@code false} otherwise.
-     * @since Android 1.0
-     */
-    
-    public boolean containsValue(Object value) {
-        if (value != null) {
-            for (int i = elementData.length; --i >= 0;) {
-                Entry<V> entry = elementData[i];
-                while (entry != null) {
-                    if (value.equals(entry.value)) {
-                        return true;
-                    }
-                    entry = entry.next;
-                }
-            }
-        } else {
-            for (int i = elementData.length; --i >= 0;) {
-                Entry<V> entry = elementData[i];
-                while (entry != null) {
-                    if (entry.value == null) {
-                        return true;
-                    }
-                    entry = entry.next;
-                }
-            }
-        }
-        return false;
-    }
-
-
-    /**
-     * Returns the value of the mapping with the specified key.
-     * 
-     * @param key
-     *            the key.
-     * @return the value of the mapping with the specified key, or {@code null}
-     *         if no mapping for the specified key is found.
-     * @since Android 1.0
-     */
-    
-    public V get(long key) {
-        Entry<V> m;
-        int hash = (int)(key);
-        int index = (hash & 0x7FFFFFFF) % elementData.length;
-        m = findNonNullKeyEntry(key, index, hash);
-
-        if (m != null) {
-            return m.value;
-        }
-        return null;
-    }
-
-    final Entry<V> findNonNullKeyEntry(long key, int index, int keyHash) {
-        Entry<V> m = elementData[index];
-            while (m != null) {
-
-                    if (key == m.key) {
-                        return m;
-                    }
-
-                m = m.next;
-
-        }
-        return null;
-    }
-
-
-    /**
-     * Returns whether this map is empty.
-     * 
-     * @return {@code true} if this map has no elements, {@code false}
-     *         otherwise.
-     * @see #size()
-     * @since Android 1.0
-     */
-    
-    public boolean isEmpty() {
-        return elementCount == 0;
-    }
-
-    /**
-     * @return iterator over keys
-     */
-    
-//      public Iterator<K> keyIterator(){
-//                 return new HashMapIterator<K, K, V>(
-//                            new MapEntry.Type<K, K, V>() {
-//                                public K get(Entry<K, V> entry) {
-//                                    return entry.key;
-//                                }
-//                            }, HashMap.this);
-//
-//     }
-
-    /**
-     * Maps the specified key to the specified value.
-     * 
-     * @param key
-     *            the key.
-     * @param value
-     *            the value.
-     * @return the value of any previous mapping with the specified key or
-     *         {@code null} if there was no such mapping.
-     * @since Android 1.0
-     */
-    
-
-    public V put(long key, V value) {
-        Entry<V> entry;
-            int hash =(int)(key);
-            int index = (hash & 0x7FFFFFFF) % elementData.length;
-            entry = findNonNullKeyEntry(key, index, hash);
-            if (entry == null) {
-                modCount++;
-                if (++elementCount > threshold) {
-                    rehash();
-                    index = (hash & 0x7FFFFFFF) % elementData.length;
-                }
-                entry = createHashedEntry(key, index);
-            }
-
-
-        V result = entry.value;
-        entry.value = value;
-        return result;
-    }
-
-    Entry<V> createEntry(long key, int index, V value) {
-        Entry<V> entry = reuseAfterDelete; 
-        if(entry == null){ 
-        	entry = new Entry<V>(key, value);
-        }else{
-        	reuseAfterDelete = null;
-        	entry.key = key;
-        	entry.value = value;
-        }
-        
-        entry.next = elementData[index];
-        elementData[index] = entry;
-        return entry;
-    }
-
-    Entry<V> createHashedEntry(long key, int index) {
-        Entry<V> entry = reuseAfterDelete; 
-        if(entry == null) {
-        	entry = new Entry<V>(key);
-        }else{
-        	reuseAfterDelete = null;
-        	entry.key = key;
-        	entry.value = null;
-        }
-
-        entry.next = elementData[index];
-        elementData[index] = entry;
-        return entry;
-    }
-
-
-    void rehash(int capacity) {
-        int length = (capacity == 0 ? 1 : capacity << 1);
-
-        Entry<V>[] newData = newElementArray(length);
-        for (int i = 0; i < elementData.length; i++) {
-            Entry<V> entry = elementData[i];
-            while (entry != null) {
-                int index = ((int)entry.key & 0x7FFFFFFF) % length;
-                Entry<V> next = entry.next;
-                entry.next = newData[index];
-                newData[index] = entry;
-                entry = next;
-            }
-        }
-        elementData = newData;
-        computeMaxSize();
-    }
-
-    void rehash() {
-        rehash(elementData.length);
-    }
-
-    /**
-     * Removes the mapping with the specified key from this map.
-     * 
-     * @param key
-     *            the key of the mapping to remove.
-     * @return the value of the removed mapping or {@code null} if no mapping
-     *         for the specified key was found.
-     * @since Android 1.0
-     */
-    
-    public V remove(long key) {
-        Entry<V> entry = removeEntry(key);
-        if(entry == null)
-        	return null;
-        V ret = entry.value;
-        entry.value = null;
-        entry.key = Long.MIN_VALUE;
-        reuseAfterDelete = entry;
-        
-        return ret;
-    }
-
-    Entry<V> removeEntry(long key) {
-        int index = 0;
-        Entry<V> entry;
-        Entry<V> last = null;
-
-        int hash = (int)(key);
-        index = (hash & 0x7FFFFFFF) % elementData.length;
-        entry = elementData[index];
-         while (entry != null && !(/*((int)entry.key) == hash &&*/ key == entry.key)) {
-             last = entry;
-              entry = entry.next;
-         }
-         
-         if (entry == null) {
-             return null;
-         }
-         
-        if (last == null) {
-            elementData[index] = entry.next;
-        } else {
-            last.next = entry.next;
-        }
-        modCount++;
-        elementCount--;
-        return entry;
-    }
-
-    /**
-     * Returns the number of elements in this map.
-     * 
-     * @return the number of elements in this map.
-     * @since Android 1.0
-     */
-    
-    public int size() {
-        return elementCount;
-    }
-
-    /**
-     * @returns iterator over values in map
-     */
-    public Iterator<V> valuesIterator() {
-        return new HashMapIterator<V, V>(
-                new EntryType<V,  V>() {
-                    public V get(Entry< V> entry) {
-                        return entry.value;
-                    }
-                }, LongHashMapJDBM.this);
-
-    }
-
-
-}
-
-
-
diff --git a/DaoTest/src/de/greenrobot/daotest/performance/target/LongSparseArray.java b/DaoTest/src/de/greenrobot/daotest/performance/target/LongSparseArray.java
deleted file mode 100644
index f515ad05..00000000
--- a/DaoTest/src/de/greenrobot/daotest/performance/target/LongSparseArray.java
+++ /dev/null
@@ -1,364 +0,0 @@
-/*
- * Copyright (C) 2009 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package de.greenrobot.daotest.performance.target;
-
-import android.util.Log;
-
-/**
- * SparseArrays map longs to Objects.  Unlike a normal array of Objects,
- * there can be gaps in the indices.  It is intended to be more efficient
- * than using a HashMap to map Longs to Objects.
- *
- * @hide
- */
-public class LongSparseArray<E> {
-    private static final Object DELETED = new Object();
-    private boolean mGarbage = false;
-
-    /**
-     * Creates a new SparseArray containing no mappings.
-     */
-    public LongSparseArray() {
-        this(10);
-    }
-
-    /**
-     * Creates a new SparseArray containing no mappings that will not
-     * require any additional memory allocation to store the specified
-     * number of mappings.
-     */
-    public LongSparseArray(int initialCapacity) {
-        initialCapacity = ArrayUtils.idealIntArraySize(initialCapacity);
-
-        mKeys = new long[initialCapacity];
-        mValues = new Object[initialCapacity];
-        mSize = 0;
-    }
-    
-    /**
-     * @return A copy of all keys contained in the sparse array.
-     */
-    public long[] getKeys() {
-        int length = mKeys.length;
-        long[] result = new long[length];
-        System.arraycopy(mKeys, 0, result, 0, length);
-        return result;
-    }
-    
-    /**
-     * Sets all supplied keys to the given unique value.
-     * @param keys Keys to set
-     * @param uniqueValue Value to set all supplied keys to
-     */
-    public void setValues(long[] keys, E uniqueValue) {
-        int length = keys.length;
-        for (int i = 0; i < length; i++) {
-            put(keys[i], uniqueValue);
-        }
-    }
-
-    /**
-     * Gets the Object mapped from the specified key, or <code>null</code>
-     * if no such mapping has been made.
-     */
-    public E get(long key) {
-        return get(key, null);
-    }
-
-    /**
-     * Gets the Object mapped from the specified key, or the specified Object
-     * if no such mapping has been made.
-     */
-    public E get(long key, E valueIfKeyNotFound) {
-        int i = binarySearch(mKeys, 0, mSize, key);
-
-        if (i < 0 || mValues[i] == DELETED) {
-            return valueIfKeyNotFound;
-        } else {
-            return (E) mValues[i];
-        }
-    }
-
-    /**
-     * Removes the mapping from the specified key, if there was any.
-     */
-    public void delete(long key) {
-        int i = binarySearch(mKeys, 0, mSize, key);
-
-        if (i >= 0) {
-            if (mValues[i] != DELETED) {
-                mValues[i] = DELETED;
-                mGarbage = true;
-            }
-        }
-    }
-
-    /**
-     * Alias for {@link #delete(long)}.
-     */
-    public void remove(long key) {
-        delete(key);
-    }
-
-    private void gc() {
-        // Log.e("SparseArray", "gc start with " + mSize);
-
-        int n = mSize;
-        int o = 0;
-        long[] keys = mKeys;
-        Object[] values = mValues;
-
-        for (int i = 0; i < n; i++) {
-            Object val = values[i];
-
-            if (val != DELETED) {
-                if (i != o) {
-                    keys[o] = keys[i];
-                    values[o] = val;
-                }
-
-                o++;
-            }
-        }
-
-        mGarbage = false;
-        mSize = o;
-
-        // Log.e("SparseArray", "gc end with " + mSize);
-    }
-
-    /**
-     * Adds a mapping from the specified key to the specified value,
-     * replacing the previous mapping from the specified key if there
-     * was one.
-     */
-    public void put(long key, E value) {
-        int i = binarySearch(mKeys, 0, mSize, key);
-
-        if (i >= 0) {
-            mValues[i] = value;
-        } else {
-            i = ~i;
-
-            if (i < mSize && mValues[i] == DELETED) {
-                mKeys[i] = key;
-                mValues[i] = value;
-                return;
-            }
-
-            if (mGarbage && mSize >= mKeys.length) {
-                gc();
-
-                // Search again because indices may have changed.
-                i = ~binarySearch(mKeys, 0, mSize, key);
-            }
-
-            if (mSize >= mKeys.length) {
-                int n = ArrayUtils.idealIntArraySize(mSize + 1);
-
-                long[] nkeys = new long[n];
-                Object[] nvalues = new Object[n];
-
-                // Log.e("SparseArray", "grow " + mKeys.length + " to " + n);
-                System.arraycopy(mKeys, 0, nkeys, 0, mKeys.length);
-                System.arraycopy(mValues, 0, nvalues, 0, mValues.length);
-
-                mKeys = nkeys;
-                mValues = nvalues;
-            }
-
-            if (mSize - i != 0) {
-                // Log.e("SparseArray", "move " + (mSize - i));
-                System.arraycopy(mKeys, i, mKeys, i + 1, mSize - i);
-                System.arraycopy(mValues, i, mValues, i + 1, mSize - i);
-            }
-
-            mKeys[i] = key;
-            mValues[i] = value;
-            mSize++;
-        }
-    }
-
-    /**
-     * Returns the number of key-value mappings that this SparseArray
-     * currently stores.
-     */
-    public int size() {
-        if (mGarbage) {
-            gc();
-        }
-
-        return mSize;
-    }
-
-    /**
-     * Given an index in the range <code>0...size()-1</code>, returns
-     * the key from the <code>index</code>th key-value mapping that this
-     * SparseArray stores.
-     */
-    public long keyAt(int index) {
-        if (mGarbage) {
-            gc();
-        }
-
-        return mKeys[index];
-    }
-
-    /**
-     * Given an index in the range <code>0...size()-1</code>, returns
-     * the value from the <code>index</code>th key-value mapping that this
-     * SparseArray stores.
-     */
-    public E valueAt(int index) {
-        if (mGarbage) {
-            gc();
-        }
-
-        return (E) mValues[index];
-    }
-
-    /**
-     * Given an index in the range <code>0...size()-1</code>, sets a new
-     * value for the <code>index</code>th key-value mapping that this
-     * SparseArray stores.
-     */
-    public void setValueAt(int index, E value) {
-        if (mGarbage) {
-            gc();
-        }
-
-        mValues[index] = value;
-    }
-
-    /**
-     * Returns the index for which {@link #keyAt} would return the
-     * specified key, or a negative number if the specified
-     * key is not mapped.
-     */
-    public int indexOfKey(long key) {
-        if (mGarbage) {
-            gc();
-        }
-
-        return binarySearch(mKeys, 0, mSize, key);
-    }
-
-    /**
-     * Returns an index for which {@link #valueAt} would return the
-     * specified key, or a negative number if no keys map to the
-     * specified value.
-     * Beware that this is a linear search, unlike lookups by key,
-     * and that multiple keys can map to the same value and this will
-     * find only one of them.
-     */
-    public int indexOfValue(E value) {
-        if (mGarbage) {
-            gc();
-        }
-
-        for (int i = 0; i < mSize; i++)
-            if (mValues[i] == value)
-                return i;
-
-        return -1;
-    }
-
-    /**
-     * Removes all key-value mappings from this SparseArray.
-     */
-    public void clear() {
-        int n = mSize;
-        Object[] values = mValues;
-
-        for (int i = 0; i < n; i++) {
-            values[i] = null;
-        }
-
-        mSize = 0;
-        mGarbage = false;
-    }
-
-    /**
-     * Puts a key/value pair into the array, optimizing for the case where
-     * the key is greater than all existing keys in the array.
-     */
-    public void append(long key, E value) {
-        if (mSize != 0 && key <= mKeys[mSize - 1]) {
-            put(key, value);
-            return;
-        }
-
-        if (mGarbage && mSize >= mKeys.length) {
-            gc();
-        }
-
-        int pos = mSize;
-        if (pos >= mKeys.length) {
-            int n = ArrayUtils.idealIntArraySize(pos + 1);
-
-            long[] nkeys = new long[n];
-            Object[] nvalues = new Object[n];
-
-            // Log.e("SparseArray", "grow " + mKeys.length + " to " + n);
-            System.arraycopy(mKeys, 0, nkeys, 0, mKeys.length);
-            System.arraycopy(mValues, 0, nvalues, 0, mValues.length);
-
-            mKeys = nkeys;
-            mValues = nvalues;
-        }
-
-        mKeys[pos] = key;
-        mValues[pos] = value;
-        mSize = pos + 1;
-    }
-
-    private static int binarySearch(long[] a, int start, int len, long key) {
-        int high = start + len, low = start - 1, guess;
-
-        while (high - low > 1) {
-            guess = (high + low) / 2;
-
-            if (a[guess] < key)
-                low = guess;
-            else
-                high = guess;
-        }
-
-        if (high == start + len)
-            return ~(start + len);
-        else if (a[high] == key)
-            return high;
-        else
-            return ~high;
-    }
-
-    private void checkIntegrity() {
-        for (int i = 1; i < mSize; i++) {
-            if (mKeys[i] <= mKeys[i - 1]) {
-                for (int j = 0; j < mSize; j++) {
-                    Log.e("FAIL", j + ": " + mKeys[j] + " -> " + mValues[j]);
-                }
-
-                throw new RuntimeException();
-            }
-        }
-    }
-
-    private long[] mKeys;
-    private Object[] mValues;
-    private int mSize;
-}
\ No newline at end of file
diff --git a/DaoTest/src/de/greenrobot/daotest/query/CountQueryTest.java b/DaoTest/src/de/greenrobot/daotest/query/CountQueryTest.java
deleted file mode 100644
index 12bd4a21..00000000
--- a/DaoTest/src/de/greenrobot/daotest/query/CountQueryTest.java
+++ /dev/null
@@ -1,126 +0,0 @@
-/*
- * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daotest.query;
-
-import java.sql.SQLException;
-import java.util.ArrayList;
-
-import de.greenrobot.dao.query.CountQuery;
-import de.greenrobot.dao.query.Query;
-import de.greenrobot.dao.query.QueryBuilder;
-import de.greenrobot.daotest.TestEntity;
-import de.greenrobot.daotest.TestEntityDao.Properties;
-import de.greenrobot.daotest.entity.TestEntityTestBase;
-
-// TODO more tests
-public class CountQueryTest extends TestEntityTestBase {
-    @Override
-    protected void setUp() throws Exception {
-        super.setUp();
-        QueryBuilder.LOG_SQL = true;
-        QueryBuilder.LOG_VALUES = true;
-    }
-
-    public void testCountQuerySimple() throws SQLException {
-        int value = getSimpleInteger(1);
-        CountQuery<TestEntity> query = dao.queryBuilder().where(Properties.SimpleInteger.eq(value)).buildCount();
-        assertEquals(0, query.count());
-
-        ArrayList<TestEntity> inserted = insert(3);
-        assertEquals(1, query.count());
-
-        inserted.get(2).setSimpleInteger(value);
-        dao.update(inserted.get(2));
-        assertEquals(2, query.count());
-
-        dao.deleteAll();
-        assertEquals(0, query.count());
-    }
-
-    public void testCountQueryTwoParameters() throws SQLException {
-        int value = getSimpleInteger(1);
-        String valueString = getSimpleString(1);
-        
-        QueryBuilder<TestEntity> queryBuilder = dao.queryBuilder();
-        queryBuilder.where(Properties.SimpleInteger.eq(value), Properties.SimpleString.eq(valueString));
-        CountQuery<TestEntity> query = queryBuilder.buildCount();
-        assertEquals(0, query.count());
-
-        ArrayList<TestEntity> inserted = insert(3);
-        assertEquals(1, query.count());
-
-        inserted.get(2).setSimpleInteger(value);
-        dao.update(inserted.get(2));
-        assertEquals(1, query.count());
-        
-        inserted.get(2).setSimpleString(valueString);
-        dao.update(inserted.get(2));
-        assertEquals(2, query.count());
-
-        dao.deleteAll();
-        assertEquals(0, query.count());
-    }
-
-    public void testCountQueryTwoParametersOr() throws SQLException {
-        int value = getSimpleInteger(1);
-        String valueString = getSimpleString(2);
-        
-        QueryBuilder<TestEntity> queryBuilder = dao.queryBuilder();
-        queryBuilder.whereOr(Properties.SimpleInteger.eq(value), Properties.SimpleString.eq(valueString));
-        CountQuery<TestEntity> query = queryBuilder.buildCount();
-        assertEquals(0, query.count());
-
-        ArrayList<TestEntity> inserted = insert(3);
-        assertEquals(2, query.count());
-
-        inserted.get(1).setSimpleInteger(getSimpleInteger(2));
-        dao.update(inserted.get(1));
-        assertEquals(1, query.count());
-        
-        inserted.get(2).setSimpleString(getSimpleString(3));
-        dao.update(inserted.get(2));
-        assertEquals(0, query.count());
-    }
-
-    public void testCountQueryChangeParameter() throws SQLException {
-        insert(3);
-
-        String value = "not existing value";
-        CountQuery<TestEntity> query = dao.queryBuilder().where(Properties.SimpleString.eq(value)).buildCount();
-        assertEquals(0, query.count());
-        query.setParameter(0, getSimpleString(1));
-        assertEquals(1, query.count());
-        query.setParameter(0, getSimpleString(2));
-        assertEquals(1, query.count());
-        query.setParameter(0, "you won't find me either");
-        assertEquals(0, query.count());
-    }
-
-    public void testBuildQueryAndCountQuery() throws SQLException {
-        insert(3);
-        int value = getSimpleInteger(1);
-
-        QueryBuilder<TestEntity> builder = dao.queryBuilder().where(Properties.SimpleInteger.eq(value));
-        Query<TestEntity> query = builder.build();
-        CountQuery<TestEntity> countQuery = builder.buildCount();
-
-        assertEquals(1, query.list().size());
-        assertEquals(1, countQuery.count());
-    }
-
-}
diff --git a/DaoTest/src/de/greenrobot/daotest/query/CountQueryThreadLocalTest.java b/DaoTest/src/de/greenrobot/daotest/query/CountQueryThreadLocalTest.java
deleted file mode 100644
index ee4c466f..00000000
--- a/DaoTest/src/de/greenrobot/daotest/query/CountQueryThreadLocalTest.java
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
- * Copyright (C) 2011-2013 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daotest.query;
-
-import java.sql.SQLException;
-
-import de.greenrobot.dao.DaoException;
-import de.greenrobot.dao.query.CountQuery;
-import de.greenrobot.dao.query.QueryBuilder;
-import de.greenrobot.daotest.TestEntity;
-import de.greenrobot.daotest.TestEntityDao.Properties;
-import de.greenrobot.daotest.entity.TestEntityTestBase;
-
-public class CountQueryThreadLocalTest extends TestEntityTestBase {
-    private CountQuery<TestEntity> queryFromOtherThread;
-
-    public void testGetForCurrentThread_SameInstance() {
-        CountQuery<TestEntity> query = dao.queryBuilder().buildCount();
-        assertSame(query, query.forCurrentThread());
-    }
-
-    public void testGetForCurrentThread_ParametersAreReset() throws SQLException {
-        insert(3);
-        int value = getSimpleInteger(1);
-        CountQuery<TestEntity> query = dao.queryBuilder().where(Properties.SimpleInteger.eq(value)).buildCount();
-        query.setParameter(0, value + 100);
-        assertEquals(0, query.count());
-        query = query.forCurrentThread();
-        assertEquals(1, query.count());
-    }
-
-    public void testGetForCurrentThread_TwoThreads() throws InterruptedException, SQLException {
-        insert(3);
-        createQueryFromOtherThread();
-        CountQuery<TestEntity> query = queryFromOtherThread.forCurrentThread();
-        assertNotSame(queryFromOtherThread, query);
-        assertEquals(1, query.count());
-        query.setParameter(0, -10);
-        assertEquals(0, query.count());
-    }
-
-    public void testThrowOutsideOwnerThread() throws InterruptedException, SQLException {
-        createQueryFromOtherThread();
-        try {
-            queryFromOtherThread.count();
-            fail("Did not throw");
-        } catch (DaoException expected) {
-        }
-        try {
-            queryFromOtherThread.setParameter(0, 42);
-            fail("Did not throw");
-        } catch (DaoException expected) {
-        }
-    }
-
-    private void createQueryFromOtherThread() throws InterruptedException {
-        Thread thread = new Thread() {
-
-            @Override
-            public void run() {
-                QueryBuilder<TestEntity> builder = dao.queryBuilder();
-                builder.where(Properties.SimpleInteger.eq(getSimpleInteger(1)));
-                queryFromOtherThread = builder.buildCount();
-            }
-        };
-        thread.start();
-        thread.join();
-        assertNotNull(queryFromOtherThread);
-    }
-
-}
diff --git a/DaoTest/src/de/greenrobot/daotest/query/DeleteQueryTest.java b/DaoTest/src/de/greenrobot/daotest/query/DeleteQueryTest.java
deleted file mode 100644
index b313bc5c..00000000
--- a/DaoTest/src/de/greenrobot/daotest/query/DeleteQueryTest.java
+++ /dev/null
@@ -1,119 +0,0 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daotest.query;
-
-import java.sql.SQLException;
-import java.util.ArrayList;
-import java.util.List;
-
-import de.greenrobot.dao.query.DeleteQuery;
-import de.greenrobot.dao.query.Query;
-import de.greenrobot.dao.query.QueryBuilder;
-import de.greenrobot.daotest.TestEntity;
-import de.greenrobot.daotest.TestEntityDao.Properties;
-import de.greenrobot.daotest.entity.TestEntityTestBase;
-
-// TODO more tests
-public class DeleteQueryTest extends TestEntityTestBase {
-    @Override
-    protected void setUp() throws Exception {
-        super.setUp();
-        QueryBuilder.LOG_SQL = true;
-        QueryBuilder.LOG_VALUES = true;
-    }
-
-    public void testDeleteQuerySimple() throws SQLException {
-        ArrayList<TestEntity> inserted = insert(3);
-        int value = getSimpleInteger(1);
-        inserted.get(2).setSimpleInteger(value);
-        dao.update(inserted.get(2));
-
-        DeleteQuery<TestEntity> deleteQuery = dao.queryBuilder().where(Properties.SimpleInteger.eq(value))
-                .buildDelete();
-
-        deleteQuery.executeDeleteWithoutDetachingEntities();
-
-        List<TestEntity> allAfterDelete = dao.loadAll();
-        assertEquals(1, allAfterDelete.size());
-        assertEquals(getSimpleInteger(0), (int) allAfterDelete.get(0).getSimpleInteger());
-    }
-
-    public void testDeleteQueryOr() throws SQLException {
-        ArrayList<TestEntity> inserted = insert(3);
-
-        QueryBuilder<TestEntity> queryBuilder = dao.queryBuilder();
-        Integer value1 = inserted.get(0).getSimpleInteger();
-        Integer value2 = inserted.get(2).getSimpleInteger();
-        queryBuilder.whereOr(Properties.SimpleInteger.eq(value1), Properties.SimpleInteger.eq(value2));
-        DeleteQuery<TestEntity> deleteQuery = queryBuilder.buildDelete();
-
-        deleteQuery.executeDeleteWithoutDetachingEntities();
-
-        List<TestEntity> allAfterDelete = dao.loadAll();
-        assertEquals(1, allAfterDelete.size());
-        assertEquals(inserted.get(1).getSimpleInteger(), allAfterDelete.get(0).getSimpleInteger());
-    }
-
-    public void testDeleteQueryExecutingMultipleTimes() throws SQLException {
-        insert(3);
-
-        String value = getSimpleString(1);
-        DeleteQuery<TestEntity> deleteQuery = dao.queryBuilder().where(Properties.SimpleString.eq(value)).buildDelete();
-        deleteQuery.executeDeleteWithoutDetachingEntities();
-        assertEquals(2, dao.count());
-
-        deleteQuery.executeDeleteWithoutDetachingEntities();
-        assertEquals(2, dao.count());
-
-        insert(3);
-        assertEquals(5, dao.count());
-
-        deleteQuery.executeDeleteWithoutDetachingEntities();
-        assertEquals(4, dao.count());
-    }
-
-    public void testDeleteQueryChangeParameter() throws SQLException {
-        insert(3);
-
-        String value = getSimpleString(1);
-        DeleteQuery<TestEntity> deleteQuery = dao.queryBuilder().where(Properties.SimpleString.eq(value)).buildDelete();
-        deleteQuery.executeDeleteWithoutDetachingEntities();
-        assertEquals(2, dao.count());
-
-        deleteQuery.setParameter(0, getSimpleString(0));
-        deleteQuery.executeDeleteWithoutDetachingEntities();
-        assertEquals(1, dao.count());
-
-        TestEntity remaining = dao.loadAll().get(0);
-        assertEquals(getSimpleString(2), remaining.getSimpleString());
-    }
-
-    public void testBuildQueryAndDeleteQuery() throws SQLException {
-        insert(3);
-        int value = getSimpleInteger(1);
-
-        QueryBuilder<TestEntity> builder = dao.queryBuilder().where(Properties.SimpleInteger.eq(value));
-        Query<TestEntity> query = builder.build();
-        DeleteQuery<TestEntity> deleteQuery = builder.buildDelete();
-
-        assertEquals(1, query.list().size());
-        deleteQuery.executeDeleteWithoutDetachingEntities();
-        assertEquals(0, query.list().size());
-    }
-
-}
diff --git a/DaoTest/src/de/greenrobot/daotest/query/DeleteQueryThreadLocalTest.java b/DaoTest/src/de/greenrobot/daotest/query/DeleteQueryThreadLocalTest.java
deleted file mode 100644
index ae8cfd97..00000000
--- a/DaoTest/src/de/greenrobot/daotest/query/DeleteQueryThreadLocalTest.java
+++ /dev/null
@@ -1,88 +0,0 @@
-/*
- * Copyright (C) 2011-2013 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daotest.query;
-
-import java.sql.SQLException;
-
-import de.greenrobot.dao.DaoException;
-import de.greenrobot.dao.query.DeleteQuery;
-import de.greenrobot.dao.query.QueryBuilder;
-import de.greenrobot.daotest.TestEntity;
-import de.greenrobot.daotest.TestEntityDao.Properties;
-import de.greenrobot.daotest.entity.TestEntityTestBase;
-
-public class DeleteQueryThreadLocalTest extends TestEntityTestBase {
-    private DeleteQuery<TestEntity> queryFromOtherThread;
-
-    public void testGetForCurrentThread_SameInstance() {
-        DeleteQuery<TestEntity> query = dao.queryBuilder().buildDelete();
-        assertSame(query, query.forCurrentThread());
-    }
-
-    public void testGetForCurrentThread_ParametersAreReset() throws SQLException {
-        insert(3);
-        int value = getSimpleInteger(1);
-        DeleteQuery<TestEntity> query = dao.queryBuilder().where(Properties.SimpleInteger.eq(value)).buildDelete();
-        query.setParameter(0, value + 100);
-        query.executeDeleteWithoutDetachingEntities();
-        assertEquals(3, dao.count());
-        query = query.forCurrentThread();
-        query.executeDeleteWithoutDetachingEntities();
-        assertEquals(2, dao.count());
-    }
-
-    public void testGetForCurrentThread_TwoThreads() throws InterruptedException, SQLException {
-        insert(3);
-        createQueryFromOtherThread();
-        DeleteQuery<TestEntity> query = queryFromOtherThread.forCurrentThread();
-        assertNotSame(queryFromOtherThread, query);
-        query.setParameter(0, getSimpleInteger(2));
-        query.executeDeleteWithoutDetachingEntities();
-        assertEquals(2, dao.count());
-    }
-
-    public void testThrowOutsideOwnerThread() throws InterruptedException, SQLException {
-        createQueryFromOtherThread();
-        try {
-            queryFromOtherThread.executeDeleteWithoutDetachingEntities();
-            fail("Did not throw");
-        } catch (DaoException expected) {
-        }
-        try {
-            queryFromOtherThread.setParameter(0, 42);
-            fail("Did not throw");
-        } catch (DaoException expected) {
-        }
-    }
-
-    private void createQueryFromOtherThread() throws InterruptedException {
-        Thread thread = new Thread() {
-
-            @Override
-            public void run() {
-                QueryBuilder<TestEntity> builder = dao.queryBuilder();
-                builder.where(Properties.SimpleInteger.eq(getSimpleInteger(1)));
-                queryFromOtherThread = builder.buildDelete();
-            }
-        };
-        thread.start();
-        thread.join();
-        assertNotNull(queryFromOtherThread);
-    }
-
-}
diff --git a/DaoTest/src/de/greenrobot/daotest/query/LazyListTest.java b/DaoTest/src/de/greenrobot/daotest/query/LazyListTest.java
deleted file mode 100644
index 316bdca9..00000000
--- a/DaoTest/src/de/greenrobot/daotest/query/LazyListTest.java
+++ /dev/null
@@ -1,188 +0,0 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daotest.query;
-
-import java.sql.SQLException;
-import java.util.ArrayList;
-import java.util.ListIterator;
-import java.util.NoSuchElementException;
-
-import de.greenrobot.dao.DaoException;
-import de.greenrobot.dao.query.CloseableListIterator;
-import de.greenrobot.dao.query.LazyList;
-import de.greenrobot.daotest.TestEntity;
-import de.greenrobot.daotest.TestEntityDao.Properties;
-import de.greenrobot.daotest.entity.TestEntityTestBase;
-
-public class LazyListTest extends TestEntityTestBase {
-
-    public void testSizeAndGetAndPeak() throws SQLException {
-        ArrayList<TestEntity> list = insert(2);
-
-        LazyList<TestEntity> listLazy = dao.queryBuilder().build().listLazy();
-        assertEquals(list.size(), listLazy.size());
-        assertNull(listLazy.peak(0));
-        assertNull(listLazy.peak(1));
-
-        assertNotNull(listLazy.get(1));
-        assertNull(listLazy.peak(0));
-        assertNotNull(listLazy.peak(1));
-
-        assertNotNull(listLazy.get(0));
-        assertNotNull(listLazy.peak(0));
-        assertNotNull(listLazy.peak(1));
-    }
-
-    public void testGetAll100() throws SQLException {
-        ArrayList<TestEntity> list = insert(100);
-        LazyList<TestEntity> listLazy = dao.queryBuilder().orderAsc(Properties.SimpleInteger).build().listLazy();
-        assertIds(list, listLazy);
-        assertTrue(listLazy.isClosed());
-    }
-
-    public void testGetAll100Uncached() throws SQLException {
-        ArrayList<TestEntity> list = insert(100);
-        LazyList<TestEntity> listLazy = dao.queryBuilder().orderAsc(Properties.SimpleInteger).build()
-                .listLazyUncached();
-        assertIds(list, listLazy);
-        assertFalse(listLazy.isClosed());
-        listLazy.close();
-    }
-
-    public void testIterator() throws SQLException {
-        ArrayList<TestEntity> list = insert(100);
-        LazyList<TestEntity> listLazy = dao.queryBuilder().orderAsc(Properties.SimpleInteger).build().listLazy();
-        testIerator(list, listLazy, false);
-        assertTrue(listLazy.isClosed());
-    }
-
-    public void testIteratorUncached() throws SQLException {
-        ArrayList<TestEntity> list = insert(100);
-        LazyList<TestEntity> listLazy = dao.queryBuilder().orderAsc(Properties.SimpleInteger).build()
-                .listLazyUncached();
-        testIerator(list, listLazy, true);
-        assertFalse(listLazy.isClosed());
-        listLazy.close();
-    }
-
-    protected void testIerator(ArrayList<TestEntity> list, LazyList<TestEntity> listLazy, boolean uncached) {
-        ListIterator<TestEntity> iterator = listLazy.listIterator();
-        try {
-            iterator.previous();
-            fail("previous should throw here");
-        } catch (NoSuchElementException expected) {
-            // OK
-        }
-        int size = list.size();
-        for (int i = 0; i < size; i++) {
-            assertTrue(iterator.hasNext());
-            assertEquals(i > 0, iterator.hasPrevious());
-            assertEquals(i, iterator.nextIndex());
-            assertEquals(i - 1, iterator.previousIndex());
-
-            if (i > 0) {
-                TestEntity entityPrevious = list.get(i - 1);
-                assertEquals(entityPrevious.getId(), iterator.previous().getId());
-                iterator.next();
-            }
-
-            TestEntity entity = list.get(i);
-            assertNull(listLazy.peak(i));
-            TestEntity lazyEntity = iterator.next();
-            if (uncached) {
-                assertNull(listLazy.peak(i));
-            } else {
-                assertNotNull(listLazy.peak(i));
-            }
-            assertEquals(entity.getId(), lazyEntity.getId());
-        }
-        assertFalse(iterator.hasNext());
-        try {
-            iterator.next();
-            fail("next should throw here");
-        } catch (NoSuchElementException expected) {
-            // OK
-        }
-    }
-
-    public void testEmpty() throws SQLException {
-        insert(1);
-
-        LazyList<TestEntity> listLazy = dao.queryBuilder().where(Properties.SimpleInteger.eq(-1)).build().listLazy();
-        assertTrue(listLazy.isEmpty());
-        assertTrue(listLazy.isClosed());
-        try {
-            listLazy.get(0);
-            fail("Not empty");
-        } catch (RuntimeException e) {
-            // Expected, OK
-        }
-
-    }
-
-    public void testUncached() throws SQLException {
-        insert(1);
-
-        LazyList<TestEntity> listLazy = dao.queryBuilder().build().listLazyUncached();
-        assertFalse(listLazy.isEmpty());
-        assertFalse(listLazy.isClosed());
-        TestEntity entity1 = listLazy.get(0);
-        TestEntity entity2 = listLazy.get(0);
-        assertEquals(entity1.getId(), entity2.getId());
-        if (identityScopeForDao == null) {
-            assertNotSame(entity1, entity2);
-        } else {
-            assertSame(entity1, entity2);
-        }
-        assertFalse(listLazy.isClosed());
-        try {
-            listLazy.loadRemaining();
-            fail("Not empty");
-        } catch (DaoException expected) {
-            // Expected, OK
-        }
-        listLazy.close();
-        assertTrue(listLazy.isClosed());
-    }
-
-    public void testClose() throws SQLException {
-        insert(1);
-
-        LazyList<TestEntity> listLazy = dao.queryBuilder().build().listLazy();
-        assertFalse(listLazy.isEmpty());
-        assertFalse(listLazy.isClosed());
-        listLazy.get(0);
-        assertTrue(listLazy.isClosed());
-
-        // Closing again should not harm
-        listLazy.close();
-        listLazy.close();
-    }
-
-    public void testAutoClose() throws SQLException {
-        insert(10);
-        LazyList<TestEntity> lazyList = dao.queryBuilder().build().listLazyUncached();
-        CloseableListIterator<TestEntity> iterator = lazyList.listIteratorAutoClose();
-        while (iterator.hasNext()) {
-            assertFalse(lazyList.isClosed());
-            iterator.next();
-        }
-        assertTrue(lazyList.isClosed());
-    }
-    
-}
diff --git a/DaoTest/src/de/greenrobot/daotest/query/QueryBuilderAndOrTest.java b/DaoTest/src/de/greenrobot/daotest/query/QueryBuilderAndOrTest.java
deleted file mode 100644
index 387245c8..00000000
--- a/DaoTest/src/de/greenrobot/daotest/query/QueryBuilderAndOrTest.java
+++ /dev/null
@@ -1,162 +0,0 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daotest.query;
-
-import java.sql.SQLException;
-import java.util.ArrayList;
-import java.util.List;
-
-import de.greenrobot.dao.query.QueryBuilder;
-import de.greenrobot.dao.test.AbstractDaoTest;
-import de.greenrobot.daotest.AbcdefEntity;
-import de.greenrobot.daotest.AbcdefEntityDao;
-import de.greenrobot.daotest.AbcdefEntityDao.Properties;
-
-public class QueryBuilderAndOrTest extends AbstractDaoTest<AbcdefEntityDao, AbcdefEntity, Long> {
-
-    public QueryBuilderAndOrTest() {
-        super(AbcdefEntityDao.class);
-        QueryBuilder.LOG_SQL = true;
-        QueryBuilder.LOG_VALUES = true;
-    }
-
-    protected ArrayList<AbcdefEntity> insert(int count) throws SQLException {
-        ArrayList<AbcdefEntity> list = new ArrayList<AbcdefEntity>();
-        for (int i = 0; i < count; i++) {
-            int base = i * 100;
-            AbcdefEntity entity = new AbcdefEntity(null, base + 1, base + 2, base + 3, base + 4, base + 5, base + 6,
-                    base + 7, base + 8, base + 9, base + 10, base + 11);
-            list.add(entity);
-        }
-        dao.insertInTx(list);
-        return list;
-    }
-
-    public void testSimpleQuery() throws SQLException {
-        insert(3);
-
-        QueryBuilder<AbcdefEntity> queryBuilder = dao.queryBuilder().where(Properties.A.eq(1)).orderAsc(Properties.A);
-        List<AbcdefEntity> result = queryBuilder.list();
-        assertEquals(1, result.size());
-        assertEquals(1, queryBuilder.count());
-
-        AbcdefEntity resultEntity = result.get(0);
-        assertEquals(1, (int) resultEntity.getA());
-
-        queryBuilder.buildDelete().executeDeleteWithoutDetachingEntities();
-    }
-
-    public void testOr() throws SQLException {
-        insert(3);
-
-        QueryBuilder<AbcdefEntity> queryBuilder = dao.queryBuilder();
-        queryBuilder.whereOr(Properties.A.eq(1), Properties.A.eq(101));
-        List<AbcdefEntity> result = queryBuilder.orderAsc(Properties.A).list();
-        assertEquals(2, result.size());
-        assertEquals(2, queryBuilder.count());
-
-        assertEquals(1, (int) result.get(0).getA());
-        assertEquals(101, (int) result.get(1).getA());
-
-        queryBuilder.buildDelete().executeDeleteWithoutDetachingEntities();
-    }
-
-    public void testOr3() throws SQLException {
-        insert(5);
-
-        QueryBuilder<AbcdefEntity> queryBuilder = dao.queryBuilder();
-        queryBuilder.whereOr(Properties.A.eq(1), Properties.A.eq(101), Properties.B.eq(302));
-        List<AbcdefEntity> result = queryBuilder.orderAsc(Properties.A).list();
-        assertEquals(3, result.size());
-        assertEquals(3, queryBuilder.count());
-
-        assertEquals(1, (int) result.get(0).getA());
-        assertEquals(101, (int) result.get(1).getA());
-        assertEquals(301, (int) result.get(2).getA());
-
-        queryBuilder.buildDelete().executeDeleteWithoutDetachingEntities();
-    }
-
-    public void testOrNested() throws SQLException {
-        insert(10);
-
-        QueryBuilder<AbcdefEntity> queryBuilder = dao.queryBuilder();
-        queryBuilder.whereOr(Properties.A.eq(101), //
-                Properties.B.eq(302), Properties.C.eq(603));
-        List<AbcdefEntity> result = queryBuilder.orderAsc(Properties.A).list();
-        assertEquals(3, result.size());
-        assertEquals(3, queryBuilder.count());
-
-        assertEquals(101, (int) result.get(0).getA());
-        assertEquals(301, (int) result.get(1).getA());
-        assertEquals(601, (int) result.get(2).getA());
-
-        queryBuilder.buildDelete().executeDeleteWithoutDetachingEntities();
-    }
-
-    public void testOrNestedNested() throws SQLException {
-        insert(10);
-
-        QueryBuilder<AbcdefEntity> queryBuilder = dao.queryBuilder();
-        queryBuilder.whereOr(Properties.A.eq(101), //
-                queryBuilder.or(Properties.B.eq(302), //
-                        queryBuilder.or(Properties.C.eq(503), Properties.D.eq(804))));
-        List<AbcdefEntity> result = queryBuilder.orderAsc(Properties.A).list();
-        assertEquals(4, result.size());
-        assertEquals(4, queryBuilder.count());
-
-        assertEquals(101, (int) result.get(0).getA());
-        assertEquals(301, (int) result.get(1).getA());
-        assertEquals(501, (int) result.get(2).getA());
-        assertEquals(801, (int) result.get(3).getA());
-
-        queryBuilder.buildDelete().executeDeleteWithoutDetachingEntities();
-    }
-
-    public void testAnd() throws SQLException {
-        insert(5);
-
-        QueryBuilder<AbcdefEntity> queryBuilder = dao.queryBuilder();
-        queryBuilder.where(Properties.A.eq(201), Properties.B.eq(202));
-        List<AbcdefEntity> result = queryBuilder.orderAsc(Properties.A).list();
-        assertEquals(1, result.size());
-        assertEquals(1, queryBuilder.count());
-
-        assertEquals(201, (int) result.get(0).getA());
-
-        queryBuilder.buildDelete().executeDeleteWithoutDetachingEntities();
-    }
-
-    public void testOrAnd() throws SQLException {
-        insert(10);
-
-        QueryBuilder<AbcdefEntity> queryBuilder = dao.queryBuilder();
-        queryBuilder.whereOr(Properties.A.eq(201), //
-                queryBuilder.and(Properties.B.gt(402), Properties.C.lt(703)));
-        List<AbcdefEntity> result = queryBuilder.orderAsc(Properties.A).list();
-        assertEquals(3, result.size());
-        assertEquals(3, queryBuilder.count());
-
-        assertEquals(201, (int) result.get(0).getA());
-        assertEquals(501, (int) result.get(1).getA());
-        assertEquals(601, (int) result.get(2).getA());
-
-        queryBuilder.buildDelete().executeDeleteWithoutDetachingEntities();
-    }
-
-}
diff --git a/DaoTest/src/de/greenrobot/daotest/query/QueryBuilderOrderTest.java b/DaoTest/src/de/greenrobot/daotest/query/QueryBuilderOrderTest.java
deleted file mode 100644
index 9533d27d..00000000
--- a/DaoTest/src/de/greenrobot/daotest/query/QueryBuilderOrderTest.java
+++ /dev/null
@@ -1,125 +0,0 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daotest.query;
-
-import java.sql.SQLException;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-
-import de.greenrobot.dao.query.QueryBuilder;
-import de.greenrobot.daotest.TestEntity;
-import de.greenrobot.daotest.TestEntityDao.Properties;
-import de.greenrobot.daotest.entity.TestEntityTestBase;
-
-public class QueryBuilderOrderTest extends TestEntityTestBase {
-    @Override
-    protected void setUp() throws Exception {
-        super.setUp();
-        QueryBuilder.LOG_SQL = true;
-        QueryBuilder.LOG_VALUES = true;
-    }
-
-    public void testOrderAsc() throws SQLException {
-        ArrayList<TestEntity> inserted = insert(2);
-        TestEntity entity = inserted.get(0);
-        List<TestEntity> result = dao.queryBuilder().orderAsc(Properties.SimpleInteger).list();
-        assertEquals(2, result.size());
-        assertEquals(entity.getId(), result.get(0).getId());
-        result = dao.queryBuilder().orderAsc(Properties.SimpleInteger, Properties.SimpleString).list();
-        assertEquals(2, result.size());
-        assertEquals(entity.getId(), result.get(0).getId());
-    }
-
-    public void testOrderDesc() throws SQLException {
-        ArrayList<TestEntity> inserted = insert(2);
-        TestEntity entity = inserted.get(1);
-        List<TestEntity> result = dao.queryBuilder().orderDesc(Properties.SimpleInteger).list();
-        assertEquals(2, result.size());
-        assertEquals(entity.getId(), result.get(0).getId());
-        result = dao.queryBuilder().orderDesc(Properties.SimpleInteger, Properties.SimpleString).list();
-        assertEquals(2, result.size());
-        assertEquals(entity.getId(), result.get(0).getId());
-    }
-
-    public void testOrderUpperLowercase() throws SQLException {
-        List<TestEntity> list = new ArrayList<TestEntity>();
-        TestEntity entityAA = addEntity(list, "aa");
-        TestEntity entityAB = addEntity(list, "Ab");
-        TestEntity entityAC = addEntity(list, "ac");
-        TestEntity entityZA = addEntity(list, "ZA");
-        TestEntity entityZB = addEntity(list, "zB");
-        TestEntity entityZC = addEntity(list, "ZC");
-        Collections.shuffle(list);
-        dao.insertInTx(list);
-
-        List<TestEntity> result = dao.queryBuilder().orderAsc(Properties.SimpleString).list();
-        assertEquals(list.size(), result.size());
-        assertEquals(entityAA.getId(), result.get(0).getId());
-        assertEquals(entityAB.getId(), result.get(1).getId());
-        assertEquals(entityAC.getId(), result.get(2).getId());
-        assertEquals(entityZA.getId(), result.get(3).getId());
-        assertEquals(entityZB.getId(), result.get(4).getId());
-        assertEquals(entityZC.getId(), result.get(5).getId());
-    }
-
-    public void testOrderUmlauts() throws SQLException {
-        List<TestEntity> list = new ArrayList<TestEntity>();
-        TestEntity entityV = addEntity(list, "V");
-        TestEntity entityB = addEntity(list, "B");
-        TestEntity entityUE = addEntity(list, "Ü");
-        TestEntity entityAE = addEntity(list, "Ä");
-        dao.insertInTx(list);
-
-        List<TestEntity> result = dao.queryBuilder().orderAsc(Properties.SimpleString).list();
-        assertEquals(list.size(), result.size());
-        assertEquals(entityAE.getId(), result.get(0).getId());
-        assertEquals(entityB.getId(), result.get(1).getId());
-        assertEquals(entityUE.getId(), result.get(2).getId());
-        assertEquals(entityV.getId(), result.get(3).getId());
-    }
-
-    public void testOrderCustom() throws SQLException {
-        List<TestEntity> list = new ArrayList<TestEntity>();
-        TestEntity entityAA = addEntity(list, "Aa");
-        TestEntity entityAB = addEntity(list, "ab");
-        TestEntity entityAC = addEntity(list, "Ac");
-        dao.insertInTx(list);
-
-        List<TestEntity> result = dao.queryBuilder().orderCustom(Properties.SimpleString, "ASC").list();
-        assertEquals(list.size(), result.size());
-        assertEquals(entityAA.getId(), result.get(0).getId());
-        assertEquals(entityAC.getId(), result.get(1).getId());
-        assertEquals(entityAB.getId(), result.get(2).getId());
-    }
-
-    public void testOrderRaw() throws SQLException {
-        ArrayList<TestEntity> inserted = insert(2);
-        TestEntity entity = inserted.get(0);
-        List<TestEntity> result = dao.queryBuilder().orderRaw(Properties.SimpleInteger.columnName + " ASC").list();
-        assertEquals(2, result.size());
-        assertEquals(entity.getId(), result.get(0).getId());
-    }
-
-    private TestEntity addEntity(List<TestEntity> list, String simpleString) {
-        TestEntity entityAB = createEntity(42, simpleString);
-        list.add(entityAB);
-        return entityAB;
-    }
-
-}
diff --git a/DaoTest/src/de/greenrobot/daotest/query/QueryBuilderSimpleTest.java b/DaoTest/src/de/greenrobot/daotest/query/QueryBuilderSimpleTest.java
deleted file mode 100644
index ad4fc02e..00000000
--- a/DaoTest/src/de/greenrobot/daotest/query/QueryBuilderSimpleTest.java
+++ /dev/null
@@ -1,219 +0,0 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daotest.query;
-
-import java.sql.SQLException;
-import java.util.ArrayList;
-import java.util.Date;
-import java.util.List;
-
-import de.greenrobot.dao.query.Query;
-import de.greenrobot.dao.query.QueryBuilder;
-import de.greenrobot.daotest.TestEntity;
-import de.greenrobot.daotest.TestEntityDao.Properties;
-import de.greenrobot.daotest.entity.TestEntityTestBase;
-
-public class QueryBuilderSimpleTest extends TestEntityTestBase {
-    @Override
-    protected void setUp() throws Exception {
-        super.setUp();
-        QueryBuilder.LOG_SQL = true;
-        QueryBuilder.LOG_VALUES = true;
-    }
-
-    public void testEqInteger() throws SQLException {
-        ArrayList<TestEntity> inserted = insert(3);
-        int value = getSimpleInteger(1);
-
-        List<TestEntity> result = dao.queryBuilder().where(Properties.SimpleInteger.eq(value)).list();
-        assertEquals(1, result.size());
-
-        TestEntity resultEntity = result.get(0);
-        assertEquals(value, (int) resultEntity.getSimpleInteger());
-        assertEquals(inserted.get(1).getId(), resultEntity.getId());
-    }
-
-    public void testEqString() throws SQLException {
-        ArrayList<TestEntity> inserted = insert(3);
-        String value = getSimpleString(1);
-
-        List<TestEntity> result = dao.queryBuilder().where(Properties.SimpleString.eq(value)).list();
-        assertEquals(1, result.size());
-
-        TestEntity resultEntity = result.get(0);
-        assertEquals(value, resultEntity.getSimpleString());
-        assertEquals(inserted.get(1).getId(), resultEntity.getId());
-    }
-
-    public void testIn() throws SQLException {
-        ArrayList<TestEntity> inserted = insert(10);
-        String value1 = getSimpleString(2);
-        String value2 = getSimpleString(8);
-        String value3 = getSimpleString(9);
-
-        List<TestEntity> result = dao.queryBuilder().where(Properties.SimpleString.in(value1, value2, value3))
-                .orderAsc(Properties.SimpleString).list();
-        assertEquals(3, result.size());
-
-        TestEntity resultEntity1 = result.get(0);
-        assertEquals(value1, resultEntity1.getSimpleString());
-        assertEquals(inserted.get(2).getId(), resultEntity1.getId());
-
-        TestEntity resultEntity2 = result.get(1);
-        assertEquals(value2, resultEntity2.getSimpleString());
-        assertEquals(inserted.get(8).getId(), resultEntity2.getId());
-
-        TestEntity resultEntity3 = result.get(2);
-        assertEquals(value3, resultEntity3.getSimpleString());
-        assertEquals(inserted.get(9).getId(), resultEntity3.getId());
-    }
-
-    public void testNotIn() throws SQLException {
-        ArrayList<TestEntity> inserted = insert(5);
-        String value1 = getSimpleString(0);
-        String value2 = getSimpleString(2);
-        String value3 = getSimpleString(4);
-
-        List<TestEntity> result = dao.queryBuilder().where(Properties.SimpleString.notIn(value1, value2, value3))
-                .orderAsc(Properties.SimpleString).list();
-        assertEquals(2, result.size());
-
-        TestEntity resultEntity1 = result.get(0);
-        assertEquals(inserted.get(1).getId(), resultEntity1.getId());
-
-        TestEntity resultEntity2 = result.get(1);
-        assertEquals(inserted.get(3).getId(), resultEntity2.getId());
-    }
-
-    public void testEqStringAndInteger() throws SQLException {
-        ArrayList<TestEntity> inserted = insert(3);
-        String valueStr = getSimpleString(1);
-        int valueInt = getSimpleInteger(1);
-
-        List<TestEntity> result = dao.queryBuilder()
-                .where(Properties.SimpleString.eq(valueStr), Properties.SimpleInteger.eq(valueInt)).list();
-        assertEquals(1, result.size());
-
-        TestEntity resultEntity = result.get(0);
-        assertEquals(inserted.get(1).getId(), resultEntity.getId());
-    }
-
-    public void testNotEqString() throws SQLException {
-        ArrayList<TestEntity> inserted = insert(3);
-        String value = getSimpleString(1);
-
-        List<TestEntity> result = dao.queryBuilder().where(Properties.SimpleString.notEq(value)).list();
-        assertEquals(2, result.size());
-
-        TestEntity resultEntity1 = result.get(0);
-        TestEntity resultEntity2 = result.get(1);
-        long loId = Math.min(resultEntity1.getId(), resultEntity2.getId());
-        long hiId = Math.max(resultEntity1.getId(), resultEntity2.getId());
-        assertEquals((long) inserted.get(0).getId(), loId);
-        assertEquals((long) inserted.get(2).getId(), hiId);
-    }
-
-    public void testEqDate() throws SQLException {
-        ArrayList<TestEntity> inserted = insert(3);
-        TestEntity testEntity = inserted.get(1);
-
-        Date date = new Date();
-        testEntity.setSimpleDate(date);
-        dao.update(testEntity);
-
-        TestEntity testEntity2 = dao.queryBuilder().where(Properties.SimpleDate.eq(date)).uniqueOrThrow();
-        assertEquals(testEntity.getId(), testEntity2.getId());
-
-        testEntity2 = dao.queryBuilder().where(Properties.SimpleDate.eq(date.getTime())).uniqueOrThrow();
-        assertEquals(testEntity.getId(), testEntity2.getId());
-    }
-
-    public void testEqBoolean() throws SQLException {
-        ArrayList<TestEntity> inserted = insert(3);
-        TestEntity testEntity = inserted.get(1);
-
-        testEntity.setSimpleBoolean(true);
-        dao.update(testEntity);
-
-        TestEntity testEntity2 = dao.queryBuilder().where(Properties.SimpleBoolean.eq(true)).uniqueOrThrow();
-        assertEquals(testEntity.getId(), testEntity2.getId());
-
-        testEntity2 = dao.queryBuilder().where(Properties.SimpleBoolean.eq(Boolean.TRUE)).uniqueOrThrow();
-        assertEquals(testEntity.getId(), testEntity2.getId());
-
-        testEntity2 = dao.queryBuilder().where(Properties.SimpleBoolean.eq("TRUE")).uniqueOrThrow();
-        assertEquals(testEntity.getId(), testEntity2.getId());
-
-        testEntity2 = dao.queryBuilder().where(Properties.SimpleBoolean.eq("truE")).uniqueOrThrow();
-        assertEquals(testEntity.getId(), testEntity2.getId());
-    }
-
-    public void testIsNullIsNotNull() throws SQLException {
-        ArrayList<TestEntity> inserted = insert(2);
-        TestEntity testEntityNull = inserted.get(0);
-        TestEntity testEntityNotNull = inserted.get(1);
-
-        testEntityNull.setSimpleInteger(null);
-        testEntityNotNull.setSimpleInteger(42);
-        dao.update(testEntityNull);
-        dao.update(testEntityNotNull);
-
-        TestEntity testEntityNull2 = dao.queryBuilder().where(Properties.SimpleInteger.isNull()).uniqueOrThrow();
-        assertEquals(testEntityNull.getId(), testEntityNull2.getId());
-
-        TestEntity testEntityNotNull2 = dao.queryBuilder().where(Properties.SimpleInteger.isNotNull()).uniqueOrThrow();
-        assertEquals(testEntityNotNull.getId(), testEntityNotNull2.getId());
-    }
-
-    public void testBuildTwice() throws SQLException {
-        insert(3);
-        String value = getSimpleString(1);
-
-        QueryBuilder<TestEntity> builder = dao.queryBuilder().where(Properties.SimpleString.eq(value));
-        Query<TestEntity> query1 = builder.build();
-        Query<TestEntity> query2 = builder.build();
-        List<TestEntity> list1 = query1.list();
-        List<TestEntity> list2 = query2.list();
-        assertEquals(1, list1.size());
-        assertEquals(1, list2.size());
-        assertEquals(list1.get(0).getId(), list2.get(0).getId());
-    }
-
-    public void testLike() throws SQLException {
-        TestEntity entity = insert(3).get(1);
-        entity.setSimpleString("greenrobot");
-        dao.update(entity);
-
-        Query<TestEntity> query = dao.queryBuilder().where(Properties.SimpleString.like("%robot")).build();
-        TestEntity entity2 = query.uniqueOrThrow();
-        assertEquals(entity.getId(), entity2.getId());
-        
-        query.setParameter(0, "green%");
-        entity2 = query.uniqueOrThrow();
-        assertEquals(entity.getId(), entity2.getId());
-        
-        query.setParameter(0, "%enrob%");
-        entity2 = query.uniqueOrThrow();
-        assertEquals(entity.getId(), entity2.getId());
-        
-        query.setParameter(0, "%nothere%");
-        entity2 = query.unique();
-        assertNull(entity2);
-    }
-
-}
diff --git a/DaoTest/src/de/greenrobot/daotest/query/QueryForThreadTest.java b/DaoTest/src/de/greenrobot/daotest/query/QueryForThreadTest.java
deleted file mode 100644
index 5154054a..00000000
--- a/DaoTest/src/de/greenrobot/daotest/query/QueryForThreadTest.java
+++ /dev/null
@@ -1,172 +0,0 @@
-/*
- * Copyright (C) 2011-2013 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daotest.query;
-
-import java.lang.reflect.Field;
-import java.lang.reflect.Method;
-import java.sql.SQLException;
-
-import android.util.SparseArray;
-import de.greenrobot.dao.DaoException;
-import de.greenrobot.dao.DaoLog;
-import de.greenrobot.dao.query.Query;
-import de.greenrobot.dao.query.QueryBuilder;
-import de.greenrobot.daotest.TestEntity;
-import de.greenrobot.daotest.TestEntityDao.Properties;
-import de.greenrobot.daotest.entity.TestEntityTestBase;
-
-public class QueryForThreadTest extends TestEntityTestBase {
-    /** Takes longer when activated */
-    private final static boolean DO_LEAK_TESTS = false;
-    private final static int LEAK_TEST_ITERATIONS = DO_LEAK_TESTS ? 100000 : 2500;
-
-    private Query<TestEntity> queryFromOtherThread;
-
-    public void testGetForCurrentThread_SameInstance() {
-        Query<TestEntity> query = dao.queryBuilder().build();
-        assertSame(query, query.forCurrentThread());
-    }
-
-    public void testGetForCurrentThread_ParametersAreReset() throws SQLException {
-        insert(3);
-        int value = getSimpleInteger(1);
-        Query<TestEntity> query = dao.queryBuilder().where(Properties.SimpleInteger.eq(value)).build();
-        query.setParameter(0, value + 1);
-        TestEntity entityFor2 = query.unique();
-        assertEquals(value + 1, (int) entityFor2.getSimpleInteger());
-        query = query.forCurrentThread();
-        TestEntity entityFor1 = query.unique();
-    }
-
-    public void testGetForCurrentThread_ManyThreadsDontLeak() throws Exception {
-        QueryBuilder<TestEntity> builder = dao.queryBuilder().where(Properties.SimpleInteger.eq("dummy"));
-        final Query<TestEntity> query = builder.build();
-        for (int i = 1; i <= LEAK_TEST_ITERATIONS; i++) {
-            Thread thread = new Thread() {
-                public void run() {
-                    query.forCurrentThread();
-                };
-            };
-            thread.start();
-            if (i % 10 == 0) {
-                thread.join();
-            }
-        }
-        Field queryDataField = Query.class.getDeclaredField("queryData");
-        queryDataField.setAccessible(true);
-        Object queryData = queryDataField.get(query);
-        Class<?> dataSuperclass = queryData.getClass().getSuperclass();
-        Field mapField = dataSuperclass.getDeclaredField("queriesForThreads");
-        mapField.setAccessible(true);
-
-        Method gcMethod = dataSuperclass.getDeclaredMethod("gc");
-        gcMethod.setAccessible(true);
-        SparseArray<?> map = (SparseArray<?>) mapField.get(queryData);
-        for (int i = 0; map.size() > 1 && i < 1000; i++) {
-            DaoLog.d("Queries left after " + i + ". GC: " + map.size());
-            System.gc();
-            gcMethod.invoke(queryData);
-        }
-        assertEquals(1, map.size());
-    }
-
-    public void testBuildQueryDoesntLeak() {
-        QueryBuilder<TestEntity> builder = dao.queryBuilder().where(Properties.SimpleInteger.eq("dummy"));
-        for (int i = 0; i < LEAK_TEST_ITERATIONS; i++) {
-            builder.build();
-        }
-    }
-
-    public void testGetForCurrentThread_TwoThreads() throws InterruptedException, SQLException {
-        insert(3);
-        createQueryFromOtherThread();
-        Query<TestEntity> query = queryFromOtherThread.forCurrentThread();
-        assertNotSame(queryFromOtherThread, query);
-        query.setLimit(10);
-        query.setOffset(0);
-        assertEquals(getSimpleInteger(1), (int) query.uniqueOrThrow().getSimpleInteger());
-        int expected = getSimpleInteger(2);
-        query.setParameter(0, expected);
-        assertEquals(expected, (int) query.list().get(0).getSimpleInteger());
-        assertEquals(expected, (int) query.listLazy().get(0).getSimpleInteger());
-        assertEquals(expected, (int) query.listLazyUncached().get(0).getSimpleInteger());
-        assertEquals(expected, (int) query.unique().getSimpleInteger());
-        assertEquals(expected, (int) query.uniqueOrThrow().getSimpleInteger());
-    }
-
-    public void testThrowOutsideOwnerThread() throws InterruptedException, SQLException {
-        createQueryFromOtherThread();
-        try {
-            queryFromOtherThread.list();
-            fail("Did not throw");
-        } catch (DaoException expected) {
-        }
-        try {
-            queryFromOtherThread.listIterator();
-            fail("Did not throw");
-        } catch (DaoException expected) {
-        }
-        try {
-            queryFromOtherThread.listLazyUncached();
-            fail("Did not throw");
-        } catch (DaoException expected) {
-        }
-        try {
-            queryFromOtherThread.setLimit(2);
-            fail("Did not throw");
-        } catch (DaoException expected) {
-        }
-        try {
-            queryFromOtherThread.setOffset(2);
-            fail("Did not throw");
-        } catch (DaoException expected) {
-        }
-        try {
-            queryFromOtherThread.setParameter(0, 42);
-            fail("Did not throw");
-        } catch (DaoException expected) {
-        }
-        try {
-            queryFromOtherThread.unique();
-            fail("Did not throw");
-        } catch (DaoException expected) {
-        }
-        try {
-            queryFromOtherThread.uniqueOrThrow();
-            fail("Did not throw");
-        } catch (DaoException expected) {
-        }
-    }
-
-    private void createQueryFromOtherThread() throws InterruptedException {
-        Thread thread = new Thread() {
-
-            @Override
-            public void run() {
-                QueryBuilder<TestEntity> builder = dao.queryBuilder();
-                builder.where(Properties.SimpleInteger.eq(getSimpleInteger(1)));
-                builder.limit(10).offset(20);
-                queryFromOtherThread = builder.build();
-            }
-        };
-        thread.start();
-        thread.join();
-        assertNotNull(queryFromOtherThread);
-    }
-
-}
diff --git a/DaoTest/src/de/greenrobot/daotest/query/QueryLimitOffsetTest.java b/DaoTest/src/de/greenrobot/daotest/query/QueryLimitOffsetTest.java
deleted file mode 100644
index d83bc185..00000000
--- a/DaoTest/src/de/greenrobot/daotest/query/QueryLimitOffsetTest.java
+++ /dev/null
@@ -1,125 +0,0 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daotest.query;
-
-import java.sql.SQLException;
-import java.util.List;
-
-import de.greenrobot.dao.query.Query;
-import de.greenrobot.dao.query.QueryBuilder;
-import de.greenrobot.daotest.TestEntity;
-import de.greenrobot.daotest.TestEntityDao.Properties;
-import de.greenrobot.daotest.entity.TestEntityTestBase;
-
-public class QueryLimitOffsetTest extends TestEntityTestBase {
-    
-    @Override
-    protected void setUp() throws Exception {
-        super.setUp();
-        QueryBuilder.LOG_SQL = true;
-        QueryBuilder.LOG_VALUES = true;
-    }
-
-    public void testQueryBuilderLimit() throws SQLException {
-        insert(10);
-        List<TestEntity> result = dao.queryBuilder().limit(3).orderAsc(Properties.SimpleInt).list();
-        assertEquals(3, result.size());
-
-        assertEquals(getSimpleInteger(0), result.get(0).getSimpleInteger().intValue());
-        assertEquals(getSimpleInteger(1), result.get(1).getSimpleInteger().intValue());
-        assertEquals(getSimpleInteger(2), result.get(2).getSimpleInteger().intValue());
-    }
-
-    public void testQueryBuilderOffsetAndLimit() throws SQLException {
-        insert(10);
-        List<TestEntity> result = dao.queryBuilder().offset(3).limit(3).orderAsc(Properties.SimpleInt).list();
-        assertEquals(3, result.size());
-
-        assertEquals(getSimpleInteger(3), result.get(0).getSimpleInteger().intValue());
-        assertEquals(getSimpleInteger(4), result.get(1).getSimpleInteger().intValue());
-        assertEquals(getSimpleInteger(5), result.get(2).getSimpleInteger().intValue());
-    }
-
-    public void testQueryBuilderOffsetAndLimitWithWhere() throws SQLException {
-        insert(10);
-        List<TestEntity> result = dao.queryBuilder().where(Properties.SimpleInteger.gt(getSimpleInteger(1))).offset(2)
-                .limit(3).orderAsc(Properties.SimpleInt).list();
-        assertEquals(3, result.size());
-
-        assertEquals(getSimpleInteger(4), result.get(0).getSimpleInteger().intValue());
-        assertEquals(getSimpleInteger(5), result.get(1).getSimpleInteger().intValue());
-        assertEquals(getSimpleInteger(6), result.get(2).getSimpleInteger().intValue());
-    }
-
-    public void testQueryOffsetAndLimit() throws SQLException {
-        insert(10);
-        Query<TestEntity> query = dao.queryBuilder().where(Properties.SimpleInteger.gt(getSimpleInteger(-1))).offset(-1)
-                .limit(-1).orderAsc(Properties.SimpleInt).build(); 
-        query.setParameter(0, getSimpleInteger(1));
-        query.setLimit(3);
-        query.setOffset(2);
-        List<TestEntity> result = query.list();
-        assertEquals(3, result.size());
-
-        assertEquals(getSimpleInteger(4), result.get(0).getSimpleInteger().intValue());
-        assertEquals(getSimpleInteger(5), result.get(1).getSimpleInteger().intValue());
-        assertEquals(getSimpleInteger(6), result.get(2).getSimpleInteger().intValue());
-    }
-    
-    public void testQueryBuilderOffsetWithoutLimit() {
-        try{
-            dao.queryBuilder().offset(7).orderAsc(Properties.SimpleInt).build();
-            fail("Offset may not be set alone");
-        } catch(RuntimeException expected) {
-            //OK
-        }
-    }
-    
-    public void testQueryLimitAndSetParameter() {
-        Query<TestEntity> query = dao.queryBuilder().limit(5).offset(1).build();
-        try{
-            query.setParameter(0, null);
-            fail("Offset/limit parameters must not interfere with user parameters");
-        } catch(RuntimeException expected) {
-            //OK
-        }
-    }
-    
-    public void testQueryUnsetLimit() {
-        Query<TestEntity> query = dao.queryBuilder().build();
-        try{
-            query.setLimit(1);
-            fail("Limit must be defined in builder first");
-        } catch(RuntimeException expected) {
-            //OK
-        }
-    } 
-
-    public void testQueryUnsetOffset() {
-        Query<TestEntity> query = dao.queryBuilder().limit(1).build();
-        try{
-            query.setOffset(1);
-            fail("Offset must be defined in builder first");
-        } catch(RuntimeException expected) {
-            //OK
-        }
-    } 
-
-
-
-}
diff --git a/DaoTest/src/de/greenrobot/daotest/query/QuerySpecialNamesTest.java b/DaoTest/src/de/greenrobot/daotest/query/QuerySpecialNamesTest.java
deleted file mode 100644
index c941447e..00000000
--- a/DaoTest/src/de/greenrobot/daotest/query/QuerySpecialNamesTest.java
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daotest.query;
-
-import java.sql.SQLException;
-
-import de.greenrobot.dao.query.QueryBuilder;
-import de.greenrobot.dao.test.AbstractDaoTest;
-import de.greenrobot.daotest.SpecialNamesEntity;
-import de.greenrobot.daotest.SpecialNamesEntityDao;
-import de.greenrobot.daotest.SpecialNamesEntityDao.Properties;
-
-public class QuerySpecialNamesTest extends AbstractDaoTest<SpecialNamesEntityDao, SpecialNamesEntity, Long> {
-
-    public QuerySpecialNamesTest() {
-        super(SpecialNamesEntityDao.class);
-    }
-
-    @Override
-    protected void setUp() throws Exception {
-        super.setUp();
-        QueryBuilder.LOG_SQL = true;
-        QueryBuilder.LOG_VALUES = true;
-    }
-
-    public void testWhereWithSpecialNames() throws SQLException {
-        QueryBuilder<SpecialNamesEntity> queryBuilder = dao.queryBuilder();
-        queryBuilder.where(Properties.Avg.isNotNull());
-        queryBuilder.where(Properties.Count.isNotNull());
-        queryBuilder.where(Properties.Distinct.isNotNull());
-        queryBuilder.where(Properties.Index.isNotNull());
-        queryBuilder.where(Properties.Join.isNotNull());
-        queryBuilder.where(Properties.On.isNotNull());
-        queryBuilder.where(Properties.Select.isNotNull());
-        queryBuilder.where(Properties.Sum.isNotNull());
-        queryBuilder.where(Properties.Order.isNotNull());
-        queryBuilder.list();
-        queryBuilder.buildCount().count();
-        queryBuilder.buildDelete().executeDeleteWithoutDetachingEntities();
-    }
-
-    public void testWhereWithSpecialNamesWithValues() throws SQLException {
-        QueryBuilder<SpecialNamesEntity> queryBuilder = dao.queryBuilder();
-        queryBuilder.where(Properties.Avg.eq("test"));
-        queryBuilder.where(Properties.Count.notIn("test", "test2"));
-        queryBuilder.where(Properties.Distinct.ge("test"));
-        queryBuilder.where(Properties.Index.le("test"));
-        queryBuilder.where(Properties.Join.like("test"));
-        queryBuilder.where(Properties.On.notEq("test"));
-        queryBuilder.where(Properties.Select.in("test", "test2"));
-        queryBuilder.where(Properties.Sum.lt(1));
-        queryBuilder.where(Properties.Order.gt(1));
-        queryBuilder.list();
-        queryBuilder.buildCount().count();
-        queryBuilder.buildDelete().executeDeleteWithoutDetachingEntities();
-    }
-
-    public void testOrderWithSpecialNames() throws SQLException {
-        QueryBuilder<SpecialNamesEntity> queryBuilder = dao.queryBuilder();
-        queryBuilder.orderAsc(Properties.Avg);
-        queryBuilder.orderAsc(Properties.Count);
-        queryBuilder.orderAsc(Properties.Distinct);
-        queryBuilder.orderAsc(Properties.Index);
-        queryBuilder.orderAsc(Properties.Join);
-        queryBuilder.orderAsc(Properties.On);
-        queryBuilder.orderAsc(Properties.Select);
-        queryBuilder.orderAsc(Properties.Sum);
-        queryBuilder.orderAsc(Properties.Order);
-        queryBuilder.list();
-    }
-
-}
diff --git a/DaoTest/src/de/greenrobot/daotest/query/RawQueryTest.java b/DaoTest/src/de/greenrobot/daotest/query/RawQueryTest.java
deleted file mode 100644
index 8fa65184..00000000
--- a/DaoTest/src/de/greenrobot/daotest/query/RawQueryTest.java
+++ /dev/null
@@ -1,91 +0,0 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daotest.query;
-
-import java.sql.SQLException;
-import java.util.ArrayList;
-import java.util.List;
-
-import de.greenrobot.dao.query.LazyList;
-import de.greenrobot.dao.query.Query;
-import de.greenrobot.dao.query.QueryBuilder;
-import de.greenrobot.daotest.TestEntity;
-import de.greenrobot.daotest.TestEntityDao.Properties;
-import de.greenrobot.daotest.entity.TestEntityTestBase;
-
-public class RawQueryTest extends TestEntityTestBase {
-    @Override
-    protected void setUp() throws Exception {
-        super.setUp();
-        QueryBuilder.LOG_SQL = true;
-        QueryBuilder.LOG_VALUES = true;
-    }
-
-    public void testRawQueryEmptySql() throws SQLException {
-        insert(3);
-        Query<TestEntity> query = dao.queryRawCreate("");
-        List<TestEntity> result = query.list();
-        assertEquals(3, result.size());
-    }
-
-    public void testRawQueryEqualsString() throws SQLException {
-        ArrayList<TestEntity> inserted = insert(3);
-        String value = getSimpleString(1);
-
-        String sql = "WHERE " + Properties.SimpleString.columnName + "=?";
-        List<TestEntity> result = dao.queryRawCreate(sql, value).list();
-        assertEquals(1, result.size());
-
-        TestEntity resultEntity = result.get(0);
-        assertEquals(value, resultEntity.getSimpleString());
-        assertEquals(inserted.get(1).getId(), resultEntity.getId());
-    }
-
-    public void testRawQueryCreate_setParameterInQuery() throws SQLException {
-        insert(3);
-        String value = getSimpleString(2);
-
-        String sql = "WHERE " + Properties.SimpleString.columnName + "=?";
-        Query<TestEntity> query = dao.queryRawCreate(sql, getSimpleString(1));
-        query.list();
-
-        query.setParameter(0, value);
-        List<TestEntity> result = query.list();
-
-        assertEquals(1, result.size());
-        assertEquals(value, result.get(0).getSimpleString());
-    }
-    
-    public void testRawQueryLazyList() throws SQLException {
-        ArrayList<TestEntity> list = insert(2);
-
-        LazyList<TestEntity> listLazy = dao.queryRawCreate("").listLazy();
-        assertEquals(list.size(), listLazy.size());
-        assertNull(listLazy.peak(0));
-        assertNull(listLazy.peak(1));
-
-        assertNotNull(listLazy.get(1));
-        assertNull(listLazy.peak(0));
-        assertNotNull(listLazy.peak(1));
-
-        assertNotNull(listLazy.get(0));
-        assertNotNull(listLazy.peak(0));
-        assertNotNull(listLazy.peak(1));
-    }
-
-}
diff --git a/DaoTest/src/de/greenrobot/daotest2/entity/KeepEntityTest.java b/DaoTest/src/de/greenrobot/daotest2/entity/KeepEntityTest.java
index de181c1b..3d331242 100644
--- a/DaoTest/src/de/greenrobot/daotest2/entity/KeepEntityTest.java
+++ b/DaoTest/src/de/greenrobot/daotest2/entity/KeepEntityTest.java
@@ -1,24 +1,7 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
 package de.greenrobot.daotest2.entity;
 
-import android.os.Build;
 import de.greenrobot.dao.test.AbstractDaoTestLongPk;
+
 import de.greenrobot.daotest2.KeepEntity;
 import de.greenrobot.daotest2.dao.KeepEntityDao;
 
@@ -35,9 +18,4 @@ protected KeepEntity createEntity(Long key) {
         return entity;
     }
 
-    public void testKeepSectionAvailable() {
-        KeepEntity keepEntity = new KeepEntity(42l);
-        assertEquals("KeepEntity ID=42 (extra="+Build.VERSION.SDK+")", keepEntity.toString());
-    }
-
 }
