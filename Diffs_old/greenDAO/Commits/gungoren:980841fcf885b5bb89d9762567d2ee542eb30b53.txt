diff --git a/DaoGenerator/src-template/kotlin/content-provider.ftl b/DaoGenerator/src-template/kotlin/content-provider.ftl
new file mode 100644
index 00000000..1d6a3088
--- /dev/null
+++ b/DaoGenerator/src-template/kotlin/content-provider.ftl
@@ -0,0 +1,221 @@
+<#-- @ftlvariable name="entity" type="org.greenrobot.greendao.generator.Entity" -->
+<#-- @ftlvariable name="contentProvider" type="org.greenrobot.greendao.generator.ContentProvider" -->
+<#-- @ftlvariable name="schema" type="org.greenrobot.greendao.generator.Schema" -->
+package ${contentProvider.javaPackage};
+
+import android.content.ContentProvider;
+import android.content.ContentResolver;
+import android.content.ContentValues;
+import android.content.UriMatcher;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteQueryBuilder;
+import android.net.Uri;
+
+import org.greenrobot.greendao.DaoLog;
+import org.greenrobot.greendao.database.StandardDatabase;
+import org.greenrobot.greendao.database.Database;
+
+import ${schema.defaultJavaPackageDao}.${schema.prefix}DaoSession;
+import ${entity.javaPackageDao}.${entity.classNameDao};
+
+/* Copy this code snippet into your AndroidManifest.xml inside the <application> element:
+
+    <provider
+        android:name="${contentProvider.javaPackage}.${contentProvider.className}"
+        android:authorities="${contentProvider.authority}" />
+*/
+
+public class ${contentProvider.className} extends ContentProvider {
+
+    public static final String AUTHORITY = "${contentProvider.authority}";
+    public static final String BASE_PATH = "${contentProvider.basePath}";
+    public static final Uri CONTENT_URI = Uri.parse("content://" + AUTHORITY + "/" + BASE_PATH);
+    public static final String CONTENT_TYPE = ContentResolver.CURSOR_DIR_BASE_TYPE
+            + "/" + BASE_PATH;
+    public static final String CONTENT_ITEM_TYPE = ContentResolver.CURSOR_ITEM_BASE_TYPE
+            + "/" + BASE_PATH;
+
+    private static final String TABLENAME = ${entity.classNameDao}.TABLENAME;
+    private static final String PK = ${entity.classNameDao}.Properties.${entity.pkProperty.propertyName?cap_first}.columnName;
+
+<#assign counter = 0>
+    private static final int ${entity.className?upper_case}_DIR = ${counter};
+    private static final int ${entity.className?upper_case}_ID = ${counter+1};
+
+    private static final UriMatcher sURIMatcher;
+
+    static {
+        sURIMatcher = new UriMatcher(UriMatcher.NO_MATCH);
+        sURIMatcher.addURI(AUTHORITY, BASE_PATH, ${entity.className?upper_case}_DIR);
+        sURIMatcher.addURI(AUTHORITY, BASE_PATH + "/#", ${entity.className?upper_case}_ID);
+    }
+
+    /**
+    * This must be set from outside, it's recommended to do this inside your Application object.
+    * Subject to change (static isn't nice).
+    */
+    public static ${schema.prefix}DaoSession daoSession;
+
+    @Override
+    public boolean onCreate() {
+        // if(daoSession == null) {
+        //     throw new IllegalStateException("${schema.prefix}DaoSession must be set before content provider is created");
+        // }
+        DaoLog.d("Content Provider started: " + CONTENT_URI);
+        return true;
+    }
+
+    protected Database getDatabase() {
+        if(daoSession == null) {
+            throw new IllegalStateException("${schema.prefix}DaoSession must be set during content provider is active");
+        }
+        return daoSession.getDatabase();
+    }
+
+<#--
+##########################################
+########## Insert ##############
+##########################################
+-->
+    @Override
+    public Uri insert(Uri uri, ContentValues values) {
+<#if contentProvider.isReadOnly()>
+        throw new UnsupportedOperationException("This content provider is readonly");
+<#else>
+        int uriType = sURIMatcher.match(uri);
+        long id = 0;
+        String path = "";
+        switch (uriType) {
+        case ${entity.className?upper_case}_DIR:
+            id = getDatabase().insert(TABLENAME, null, values);
+            path = BASE_PATH + "/" + id;
+            break;
+        default:
+            throw new IllegalArgumentException("Unknown URI: " + uri);
+        }
+        getContext().getContentResolver().notifyChange(uri, null);
+        return Uri.parse(path);
+
+</#if>
+    }
+
+<#--
+##########################################
+########## Delete ##############
+##########################################
+-->
+    @Override
+    public int delete(Uri uri, String selection, String[] selectionArgs) {
+<#if contentProvider.isReadOnly()>
+        throw new UnsupportedOperationException("This content provider is readonly");
+<#else>
+        int uriType = sURIMatcher.match(uri);
+        Database db = getDatabase();
+        int rowsDeleted = 0;
+        String id;
+        switch (uriType) {
+        case ${entity.className?upper_case}_DIR:
+                rowsDeleted = db.delete(TABLENAME, selection, selectionArgs);
+                break;
+        case ${entity.className?upper_case}_ID:
+            id = uri.getLastPathSegment();
+            if (TextUtils.isEmpty(selection)) {
+                rowsDeleted = db.delete(TABLENAME, PK + "=" + id, null);
+            } else {
+                rowsDeleted = db.delete(TABLENAME, PK + "=" + id + " and "
+                                + selection, selectionArgs);
+            }
+            break;
+        default:
+            throw new IllegalArgumentException("Unknown URI: " + uri);
+        }
+        getContext().getContentResolver().notifyChange(uri, null);
+        return rowsDeleted;
+</#if>
+    }
+
+    <#--
+##########################################
+########## Update ##############
+##########################################
+-->
+    @Override
+    public int update(Uri uri, ContentValues values, String selection,
+            String[] selectionArgs) {
+<#if contentProvider.isReadOnly()>
+        throw new UnsupportedOperationException("This content provider is readonly");
+<#else>
+        int uriType = sURIMatcher.match(uri);
+        Database db = getDatabase();
+        int rowsUpdated = 0;
+        String id;
+        switch (uriType) {
+        case ${entity.className?upper_case}_DIR:
+            rowsUpdated = db.update(TABLENAME, values, selection, selectionArgs);
+            break;
+        case ${entity.className?upper_case}_ID:
+            id = uri.getLastPathSegment();
+            if (TextUtils.isEmpty(selection)) {
+                    rowsUpdated = db.update(TABLENAME, values, PK + "=" + id, null);
+            } else {
+                    rowsUpdated = db.update(TABLENAME, values, PK + "=" + id
+                                    + " and " + selection, selectionArgs);
+            }
+            break;
+        default:
+            throw new IllegalArgumentException("Unknown URI: " + uri);
+        }
+        getContext().getContentResolver().notifyChange(uri, null);
+        return rowsUpdated;
+</#if>
+    }
+
+     <#--
+##########################################
+########## Query ##############
+##########################################
+-->
+    @Override
+    public Cursor query(Uri uri, String[] projection, String selection,
+            String[] selectionArgs, String sortOrder) {
+
+        SQLiteQueryBuilder queryBuilder = new SQLiteQueryBuilder();
+        int uriType = sURIMatcher.match(uri);
+        switch (uriType) {
+        case ${entity.className?upper_case}_DIR:
+            queryBuilder.setTables(TABLENAME);
+            break;
+        case ${entity.className?upper_case}_ID:
+            queryBuilder.setTables(TABLENAME);
+            queryBuilder.appendWhere(PK + "="
+                    + uri.getLastPathSegment());
+            break;
+        default:
+            throw new IllegalArgumentException("Unknown URI: " + uri);
+        }
+
+        Database db = getDatabase();
+        Cursor cursor = queryBuilder.query(((StandardDatabase) db).getSQLiteDatabase(), projection, selection,
+                selectionArgs, null, null, sortOrder);
+        cursor.setNotificationUri(getContext().getContentResolver(), uri);
+
+        return cursor;
+    }
+
+    <#--
+##########################################
+########## GetType ##############
+##########################################
+-->
+    @Override
+    public final String getType(Uri uri) {
+        switch (sURIMatcher.match(uri)) {
+        case ${entity.className?upper_case}_DIR:
+            return CONTENT_TYPE;
+        case ${entity.className?upper_case}_ID:
+            return CONTENT_ITEM_TYPE;
+        default :
+            throw new IllegalArgumentException("Unsupported URI: " + uri);
+        }
+    }
+}
diff --git a/DaoGenerator/src-template/kotlin/dao-deep.ftl b/DaoGenerator/src-template/kotlin/dao-deep.ftl
new file mode 100644
index 00000000..2a447654
--- /dev/null
+++ b/DaoGenerator/src-template/kotlin/dao-deep.ftl
@@ -0,0 +1,129 @@
+<#--
+
+Copyright (C) 2011-2015 Markus Junginger, greenrobot (http://greenrobot.de)
+                                                                           
+This file is part of greenDAO Generator.                                   
+                                                                           
+greenDAO Generator is free software: you can redistribute it and/or modify 
+it under the terms of the GNU General Public License as published by       
+the Free Software Foundation, either version 3 of the License, or          
+(at your option) any later version.                                        
+greenDAO Generator is distributed in the hope that it will be useful,      
+but WITHOUT ANY WARRANTY; without even the implied warranty of             
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              
+GNU General Public License for more details.                               
+                                                                           
+You should have received a copy of the GNU General Public License          
+along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+
+-->
+<#if entity.toOneRelations?has_content>
+    private String selectDeep;
+
+    protected String getSelectDeep() {
+        if (selectDeep == null) {
+            StringBuilder builder = new StringBuilder("SELECT ");
+            SqlUtils.appendColumns(builder, "T", getAllColumns());
+            builder.append(',');
+<#list entity.toOneRelations as toOne>
+            SqlUtils.appendColumns(builder, "T${toOne_index}", daoSession.get${toOne.targetEntity.classNameDao}().getAllColumns());
+<#if toOne_has_next>
+            builder.append(',');
+</#if>
+</#list>
+            builder.append(" FROM ${entity.dbName} T");
+<#list entity.toOneRelations as toOne>
+            builder.append(" LEFT JOIN ${toOne.targetEntity.dbName} T${toOne_index}<#--
+--> ON T.\"${toOne.fkProperties[0].dbName}\"=T${toOne_index}.\"${toOne.targetEntity.pkProperty.dbName}\"");
+</#list>
+            builder.append(' ');
+            selectDeep = builder.toString();
+        }
+        return selectDeep;
+    }
+    
+    protected ${entity.className} loadCurrentDeep(Cursor cursor, boolean lock) {
+        ${entity.className} entity = loadCurrent(cursor, 0, lock);
+        int offset = getAllColumns().length;
+
+<#list entity.toOneRelations as toOne>
+        ${toOne.targetEntity.className} ${toOne.name} = loadCurrentOther(daoSession.get${toOne.targetEntity.classNameDao}(), cursor, offset);
+<#if toOne.fkProperties[0].notNull>         if(${toOne.name} != null) {
+    </#if>        entity.set${toOne.name?cap_first}(${toOne.name});
+<#if toOne.fkProperties[0].notNull>
+        }
+</#if>
+<#if toOne_has_next>
+        offset += daoSession.get${toOne.targetEntity.classNameDao}().getAllColumns().length;
+</#if>
+
+</#list>
+        return entity;    
+    }
+
+    public ${entity.className} loadDeep(Long key) {
+        assertSinglePk();
+        if (key == null) {
+            return null;
+        }
+
+        StringBuilder builder = new StringBuilder(getSelectDeep());
+        builder.append("WHERE ");
+        SqlUtils.appendColumnsEqValue(builder, "T", getPkColumns());
+        String sql = builder.toString();
+        
+        String[] keyArray = new String[] { key.toString() };
+        Cursor cursor = db.rawQuery(sql, keyArray);
+        
+        try {
+            boolean available = cursor.moveToFirst();
+            if (!available) {
+                return null;
+            } else if (!cursor.isLast()) {
+                throw new IllegalStateException("Expected unique result, but count was " + cursor.getCount());
+            }
+            return loadCurrentDeep(cursor, true);
+        } finally {
+            cursor.close();
+        }
+    }
+    
+    /** Reads all available rows from the given cursor and returns a list of new ImageTO objects. */
+    public List<${entity.className}> loadAllDeepFromCursor(Cursor cursor) {
+        int count = cursor.getCount();
+        List<${entity.className}> list = new ArrayList<${entity.className}>(count);
+        
+        if (cursor.moveToFirst()) {
+            if (identityScope != null) {
+                identityScope.lock();
+                identityScope.reserveRoom(count);
+            }
+            try {
+                do {
+                    list.add(loadCurrentDeep(cursor, false));
+                } while (cursor.moveToNext());
+            } finally {
+                if (identityScope != null) {
+                    identityScope.unlock();
+                }
+            }
+        }
+        return list;
+    }
+    
+    protected List<${entity.className}> loadDeepAllAndCloseCursor(Cursor cursor) {
+        try {
+            return loadAllDeepFromCursor(cursor);
+        } finally {
+            cursor.close();
+        }
+    }
+    
+
+    /** A raw-style query where you can pass any WHERE clause and arguments. */
+    public List<${entity.className}> queryDeep(String where, String... selectionArg) {
+        Cursor cursor = db.rawQuery(getSelectDeep() + where, selectionArg);
+        return loadDeepAllAndCloseCursor(cursor);
+    }
+ 
+</#if>
\ No newline at end of file
diff --git a/DaoGenerator/src-template/kotlin/dao-master.ftl b/DaoGenerator/src-template/kotlin/dao-master.ftl
new file mode 100644
index 00000000..34444935
--- /dev/null
+++ b/DaoGenerator/src-template/kotlin/dao-master.ftl
@@ -0,0 +1,120 @@
+<#--
+
+Copyright (C) 2011-2016 Markus Junginger, greenrobot (http://greenrobot.org)
+                                                                           
+This file is part of greenDAO Generator.                                   
+                                                                           
+greenDAO Generator is free software: you can redistribute it and/or modify 
+it under the terms of the GNU General Public License as published by       
+the Free Software Foundation, either version 3 of the License, or          
+(at your option) any later version.                                        
+greenDAO Generator is distributed in the hope that it will be useful,      
+but WITHOUT ANY WARRANTY; without even the implied warranty of             
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              
+GNU General Public License for more details.                               
+                                                                           
+You should have received a copy of the GNU General Public License          
+along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+
+-->
+<#-- @ftlvariable name="schema" type="org.greenrobot.greendao.generator.Schema" -->
+package ${schema.defaultJavaPackageDao}
+
+import android.content.Context
+import android.database.sqlite.SQLiteDatabase
+import android.database.sqlite.SQLiteDatabase.CursorFactory
+import android.util.Log
+
+import org.greenrobot.greendao.AbstractDaoMaster
+import org.greenrobot.greendao.database.StandardDatabase
+import org.greenrobot.greendao.database.Database
+import org.greenrobot.greendao.database.DatabaseOpenHelper
+import org.greenrobot.greendao.identityscope.IdentityScopeType
+
+<#list schema.entities as entity>
+<#if schema.defaultJavaPackageDao != entity.javaPackageDao>
+import ${entity.javaPackageDao}.${entity.classNameDao}
+</#if>
+</#list>
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+/**
+ * Master of DAO (schema version ${schema.version?c}): knows all DAOs.
+ */
+class ${schema.prefix}DaoMaster: AbstractDaoMaster {
+
+    companion object {
+        const val SCHEMA_VERSION = ${schema.version?c}
+
+        /** Creates underlying database table using DAOs. */
+        fun createAllTables(db:Database, ifNotExists:Boolean) {
+    <#list schema.entities as entity>
+    <#if !entity.skipCreationInDb>
+            ${entity.classNameDao}.createTable(db, ifNotExists)
+    </#if>
+    </#list>
+        }
+
+        /** Drops underlying database table using DAOs. */
+        fun dropAllTables(db:Database, ifExists:Boolean) {
+    <#list schema.entities as entity>
+    <#if !entity.skipCreationInDb>
+            ${entity.classNameDao}.dropTable(db, ifExists)
+    </#if>
+    </#list>
+        }
+
+        /**
+         * WARNING: Drops all table on Upgrade! Use only during development.
+         * Convenience method using a {@link DevOpenHelper}.
+         */
+        fun newDevSession(Context context, String name) : ${schema.prefix}DaoSession {
+            val db:Database = DevOpenHelper(context, name).getWritableDb()
+            val daoMaster:${schema.prefix}DaoMaster = ${schema.prefix}DaoMaster(db)
+            return daoMaster.newSession()
+        }
+
+        /**
+         * Calls {@link #createAllTables(Database, boolean)} in {@link #onCreate(Database)} -
+         */
+        abstract class OpenHelper: DatabaseOpenHelper {
+            constructor(context:Context, name:String ) : super(context, name, SCHEMA_VERSION)
+
+            constructor(context:Context, name:String , factory:CursorFactory): super(context, name, factory, SCHEMA_VERSION)
+
+            override fun onCreate(db:Database) {
+                Log.i("greenDAO", "Creating tables for schema version $SCHEMA_VERSION")
+                createAllTables(db, false)
+            }
+        }
+
+        /** WARNING: Drops all table on Upgrade! Use only during development. */
+        class DevOpenHelper: OpenHelper {
+
+            constructor(context:Context, name:String ) : super(context, name)
+            constructor(context:Context, name:String, factory:CursorFactory) : super(context, name, factory )
+
+            override fun onUpgrade(db:Database, oldVersion:Int, newVersion:Int) {
+                Log.i("greenDAO", "Upgrading schema from version $oldVersion to $newVersion by dropping all tables")
+                dropAllTables(db, true)
+                onCreate(db)
+            }
+        }
+     }
+
+    constructor (db:SQLiteDatabase) : this(StandardDatabase(db))
+
+    constructor (db:Database ) : super(db, SCHEMA_VERSION) {
+<#list schema.entities as entity>
+        registerDaoClass(${entity.classNameDao}::class.java)
+</#list>
+    }
+
+    fun newSession() : ${schema.prefix}DaoSession {
+        return ${schema.prefix}DaoSession(db, IdentityScopeType.Session, daoConfigMap)
+    }
+
+    fun newSession(IdentityScopeType type) : ${schema.prefix}DaoSession {
+        return ${schema.prefix}DaoSession(db, type, daoConfigMap)
+    }
+}
diff --git a/DaoGenerator/src-template/kotlin/dao-session.ftl b/DaoGenerator/src-template/kotlin/dao-session.ftl
new file mode 100644
index 00000000..18b5b14d
--- /dev/null
+++ b/DaoGenerator/src-template/kotlin/dao-session.ftl
@@ -0,0 +1,66 @@
+<#--
+
+Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)     
+                                                                           
+This file is part of greenDAO Generator.                                   
+                                                                           
+greenDAO Generator is free software: you can redistribute it and/or modify 
+it under the terms of the GNU General Public License as published by       
+the Free Software Foundation, either version 3 of the License, or          
+(at your option) any later version.                                        
+greenDAO Generator is distributed in the hope that it will be useful,      
+but WITHOUT ANY WARRANTY; without even the implied warranty of             
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              
+GNU General Public License for more details.                               
+                                                                           
+You should have received a copy of the GNU General Public License          
+along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+
+-->
+package ${schema.defaultJavaPackageDao}
+
+import java.util.Map
+
+import org.greenrobot.greendao.AbstractDao
+import org.greenrobot.greendao.AbstractDaoSession
+import org.greenrobot.greendao.database.Database
+import org.greenrobot.greendao.identityscope.IdentityScopeType
+import org.greenrobot.greendao.internal.DaoConfig
+
+<#list schema.entities as entity>
+import ${entity.javaPackage}.${entity.className}
+</#list>
+
+<#list schema.entities as entity>
+import ${entity.javaPackageDao}.${entity.classNameDao}
+</#list>
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+
+/**
+ * {@inheritDoc}
+ * 
+ * @see org.greenrobot.greendao.AbstractDaoSession
+ */
+class ${schema.prefix}DaoSession (db:Database?, type:IdentityScopeType?, daoConfigMap: Map<Class<out AbstractDao<*, *>?>?, DaoConfig?> ) : AbstractDaoSession(db) {
+
+<#list schema.entities as entity>
+    private var ${entity.classNameDao?uncap_first}Config: DaoConfig = map.get(${entity.classNameDao}::class.java) as DaoConfig
+    var ${entity.classNameDao?uncap_first}: ${entity.classNameDao}
+</#list>        
+
+    init {
+
+<#list schema.entities as entity>
+        ${entity.classNameDao?uncap_first}Config.initIdentityScope(type)
+        ${entity.classNameDao?uncap_first} = ${entity.classNameDao}(${entity.classNameDao?uncap_first}Config, this)
+        registerDao(${entity.className}::class.java, ${entity.classNameDao?uncap_first})
+</#list>
+    }
+    
+    fun clear() {
+<#list schema.entities as entity>
+        ${entity.classNameDao?uncap_first}Config.clearIdentityScope()
+</#list>    
+    }
+}
diff --git a/DaoGenerator/src-template/kotlin/dao-unit-test.ftl b/DaoGenerator/src-template/kotlin/dao-unit-test.ftl
new file mode 100644
index 00000000..0480ca70
--- /dev/null
+++ b/DaoGenerator/src-template/kotlin/dao-unit-test.ftl
@@ -0,0 +1,53 @@
+<#--
+
+Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)     
+                                                                           
+This file is part of greenDAO Generator.                                   
+                                                                           
+greenDAO Generator is free software: you can redistribute it and/or modify 
+it under the terms of the GNU General Public License as published by       
+the Free Software Foundation, either version 3 of the License, or          
+(at your option) any later version.                                        
+greenDAO Generator is distributed in the hope that it will be useful,      
+but WITHOUT ANY WARRANTY; without even the implied warranty of             
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              
+GNU General Public License for more details.                               
+                                                                           
+You should have received a copy of the GNU General Public License          
+along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+
+-->
+package ${entity.javaPackageTest};
+
+<#assign isStringPK = entity.pkProperty?? && entity.pkProperty.propertyType == "String" />
+<#if isStringPK>
+import org.greenrobot.greendao.test.AbstractDaoTestStringPk;
+<#else>
+import org.greenrobot.greendao.test.AbstractDaoTestLongPk;
+</#if>
+
+import ${entity.javaPackage}.${entity.className};
+import ${entity.javaPackageDao}.${entity.classNameDao};
+
+public class ${entity.classNameTest} extends <#if
+isStringPK>AbstractDaoTestStringPk<${entity.classNameDao}, ${entity.className}><#else>AbstractDaoTestLongPk<${entity.classNameDao}, ${entity.className}></#if> {
+
+    public ${entity.classNameTest}() {
+        super(${entity.classNameDao}.class);
+    }
+
+    @Override
+    protected ${entity.className} createEntity(<#if isStringPK>String<#else>Long</#if> key) {
+        ${entity.className} entity = new ${entity.className}();
+<#if entity.pkProperty??>
+        entity.set${entity.pkProperty.propertyName?cap_first}(key);
+</#if>
+<#list entity.properties as property>
+<#if property.notNull>
+        entity.set${property.propertyName?cap_first}();
+</#if> 
+</#list>
+        return entity;
+    }
+
+}
diff --git a/DaoGenerator/src-template/kotlin/dao.ftl b/DaoGenerator/src-template/kotlin/dao.ftl
new file mode 100644
index 00000000..a3234e6a
--- /dev/null
+++ b/DaoGenerator/src-template/kotlin/dao.ftl
@@ -0,0 +1,318 @@
+<#--
+
+Copyright (C) 2011-2016 Markus Junginger, greenrobot (http://greenrobot.org)
+                                                                           
+This file is part of greenDAO Generator.                                   
+                                                                           
+greenDAO Generator is free software: you can redistribute it and/or modify 
+it under the terms of the GNU General Public License as published by       
+the Free Software Foundation, either version 3 of the License, or          
+(at your option) any later version.                                        
+greenDAO Generator is distributed in the hope that it will be useful,      
+but WITHOUT ANY WARRANTY; without even the implied warranty of             
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              
+GNU General Public License for more details.                               
+                                                                           
+You should have received a copy of the GNU General Public License          
+along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+
+-->
+<#-- @ftlvariable name="entity" type="org.greenrobot.greendao.generator.Entity" -->
+<#-- @ftlvariable name="schema" type="org.greenrobot.greendao.generator.Schema" -->
+
+<#assign toBindType = {"Boolean":"Long", "Byte":"Long", "Short":"Long", "Int":"Long", "Long":"Long", "Float":"Double", "Double":"Double", "String":"String", "ByteArray":"Blob", "Date": "Long" } />
+<#assign toCursorType = {"Boolean":"Short", "Byte":"Short", "Short":"Short", "Int":"Int", "Long":"Long", "Float":"Float", "Double":"Double", "String":"String", "ByteArray":"Blob", "Date": "Long"  } />
+package ${entity.javaPackageDao}
+
+<#if entity.toOneRelations?has_content || entity.incomingToManyRelations?has_content>
+import java.util.List
+</#if>
+<#if entity.toOneRelations?has_content>
+import java.util.ArrayList
+</#if>
+import android.database.Cursor
+import android.database.sqlite.SQLiteStatement
+
+import org.greenrobot.greendao.AbstractDao
+import org.greenrobot.greendao.Property
+<#if entity.toOneRelations?has_content>
+import org.greenrobot.greendao.internal.SqlUtils
+</#if>
+import org.greenrobot.greendao.internal.DaoConfig
+import org.greenrobot.greendao.database.Database
+import org.greenrobot.greendao.database.DatabaseStatement
+<#if entity.incomingToManyRelations?has_content>
+import org.greenrobot.greendao.query.Query
+import org.greenrobot.greendao.query.QueryBuilder
+</#if>
+
+<#if entity.javaPackageDao != schema.defaultJavaPackageDao>
+import ${schema.defaultJavaPackageDao}.${schema.prefix}DaoSession
+
+</#if>
+<#if entity.additionalImportsDao?has_content>
+<#list entity.additionalImportsDao as additionalImport>
+import ${additionalImport}
+</#list>
+
+</#if>
+<#if entity.javaPackageDao != entity.javaPackage>
+import ${entity.javaPackage}.${entity.className}
+
+</#if>
+<#if entity.protobuf>
+import ${entity.javaPackage}.${entity.className}.Builder
+
+</#if>
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+/** 
+ * DAO for table "${entity.dbName}".
+*/
+class ${entity.classNameDao}: AbstractDao<${entity.className}, ${entity.pkType}> {
+
+    companion object {
+        const val TABLENAME = "${entity.dbName}"
+
+<#if !entity.skipCreationInDb>
+        /** Creates the underlying database table. */
+        fun createTable(db:Database, ifNotExists:Boolean) {
+            var constraint = ifNotExists? "IF NOT EXISTS ": ""
+            db.execSQL("CREATE TABLE $constraint\"${entity.dbName}\" (" + //
+<#list entity.propertiesColumns as property>
+                    "\"${property.dbName}\" ${property.dbType}<#if property.constraints??> ${property.constraints} </#if><#if property_has_next>," +<#else>)")</#if> // ${property_index}: ${property.propertyName}
+</#list>
+<#if entity.indexes?has_content >
+            // Add Indexes
+<#list entity.indexes as index>
+            db.execSQL("CREATE <#if index.unique>UNIQUE </#if>INDEX $constraint ${index.name} ON \"${entity.dbName}\"" +
+                    " (<#list index.properties
+    as property>\"${property.dbName}\"<#if (index.propertiesOrder[property_index])??> ${index.propertiesOrder[property_index]}</#if><#sep>,</#list>)")
+</#list>
+</#if>
+        }
+
+        /** Drops the underlying database table. */
+        fun dropTable(db:Database, ifExists:Boolean) {
+            String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "\"${entity.dbName}\""
+            db.execSQL(sql)
+        }
+</#if>
+    }
+
+
+    /**
+     * Properties of entity ${entity.className}.<br/>
+     * Can be used for QueryBuilder and for referencing column names.
+     */
+    class Properties {
+        companion object {
+<#list entity.propertiesColumns as property>
+            @JvmField val  ${property.propertyName?cap_first} = Property(${property_index}, ${property.javaType}::class.java, "${property.propertyName}", ${property.primaryKey?string}, "${property.dbName}")
+</#list>
+        }
+    }
+
+<#if entity.active>
+    var daoSession:${schema.prefix}DaoSession
+</#if>
+<#list entity.properties as property><#if property.customType?has_content><#--
+-->    const val ${property.propertyName}Converter: ${property.converterClassName} = ${property.converterClassName}()
+</#if></#list>
+<#list entity.incomingToManyRelations as toMany>
+    private var ${toMany.sourceEntity.className?uncap_first}_${toMany.name?cap_first}Query:Query<${toMany.targetEntity.className}>
+</#list>
+
+    constructor (config: DaoConfig ) : super(config)
+    
+    constructor (config: DaoConfig, daoSession:${schema.prefix}DaoSession) : super(config, daoSession)
+<#if entity.active>
+    {
+        this.daoSession = daoSession
+    }
+</#if>
+
+<#assign stmtTypes = ["DatabaseStatement", "SQLiteStatement"] />
+<#list stmtTypes as stmtType>
+    override fun bindValues(stmt:${stmtType}, entity:${entity.className}) {
+        stmt.clearBindings()
+<#list entity.properties as property>
+<#if property.notNull || entity.protobuf>
+<#if entity.protobuf>
+        if(entity.is${property.propertyName?cap_first}) {
+    </#if>        stmt.bind${toBindType[property.propertyType]}(${property_index + 1}, ${property.databaseValueExpressionNotNull})
+<#if entity.protobuf>
+        }
+</#if>
+<#else> <#-- nullable, non-protobuff -->
+        var ${property.propertyName}:${property.javaTypeInEntity}? = entity.${property.propertyName}
+        if (${property.propertyName} != null) {
+            stmt.bind${toBindType[property.propertyType]}(${property_index + 1}, ${property.databaseValueExpression});
+        }
+</#if>
+</#list>
+<#list entity.toOneRelations as toOne>
+<#if !toOne.fkProperties?has_content>
+
+        ${toOne.targetEntity.className} ${toOne.name} = entity.peak${toOne.name?cap_first}();
+        if(${toOne.name} != null) {
+            ${toOne.targetEntity.pkProperty.javaType} ${toOne.name}__targetKey = ${toOne.name}.get${toOne.targetEntity.pkProperty.propertyName?cap_first}();
+<#if !toOne.targetEntity.pkProperty.notNull>
+            if(${toOne.name}__targetKey != null) {
+                // TODO bind ${toOne.name}__targetKey
+            }
+<#else>
+            // TODO bind ${toOne.name}__targetKey
+</#if>
+        }
+</#if>
+</#list>
+    }
+
+</#list>
+<#if entity.active && !entity.protobuf>
+    protected override final fun attachEntity(entity:${entity.className}) : super.attachEntity(entity) {
+        entity.__setDaoSession(daoSession)
+    }
+
+</#if>
+    override fun readKey(cursor:Cursor, offset:Int) : ${entity.pkType}{
+<#if entity.pkProperty??>
+        return <#if !entity.pkProperty.notNull>cursor.isNull(offset + ${entity.pkProperty.ordinal}) ? null : </#if><#if
+            entity.pkProperty.propertyType == "Byte">(byte) </#if><#if
+            entity.pkProperty.propertyType == "Date">new java.util.Date(</#if>cursor.get${toCursorType[entity.pkProperty.propertyType]}(offset + ${entity.pkProperty.ordinal})<#if
+            entity.pkProperty.propertyType == "Boolean"> != 0</#if><#if
+            entity.pkProperty.propertyType == "Date">)</#if>
+<#else>
+        return null
+</#if>  
+    }    
+
+    override fun readEntity(cursor:Cursor, offset:Int) : ${entity.className}{
+<#if entity.protobuf>
+        var builder:Builder = ${entity.className}.newBuilder()
+<#list entity.properties as property>
+<#if !property.notNull>
+        if (!cursor.isNull(offset + ${property_index})) {
+    </#if>        builder.set${property.propertyName?cap_first}(cursor.get${toCursorType[property.propertyType]}(offset + ${property_index}))
+<#if !property.notNull>
+        }
+</#if>        
+</#list>        
+        return builder.build()
+<#elseif entity.constructors>
+<#--
+############################## readEntity non-protobuff, constructor ############################## 
+-->
+        val entity:${entity.className} = ${entity.className}( //
+<#list entity.properties as property>
+            <#if !property.notNull>cursor.isNull(offset + ${property_index}) ? null : </#if><#--
+            -->${property.getEntityValueExpression("cursor.get${toCursorType[property.propertyType]}(offset + ${property_index})")}<#--
+            --><#if property_has_next>,</#if> // ${property.propertyName}
+</#list>        
+        )
+        return entity
+<#else>
+<#--
+############################## readEntity non-protobuff, setters ############################## 
+-->
+        var entity = ${entity.className}()
+        readEntity(cursor, entity, offset)
+        return entity
+</#if>
+    }
+
+    override fun readEntity(cursor:Cursor, entity:${entity.className}, offset:Int) {
+<#if entity.protobuf>
+        throw new UnsupportedOperationException("Protobuf objects cannot be modified");
+<#else> 
+<#list entity.properties as property>
+        entity.${property.propertyName} = <#if !property.notNull>cursor.isNull(offset + ${property_index}) ? null : </#if><#--
+            -->${property.getEntityValueExpression("cursor.get${toCursorType[property.propertyType]}(offset + ${property_index})")}
+</#list>
+</#if>
+     }
+
+    protected override final fun updateKeyAfterInsert(entity:${entity.className}, rowId:Long) : ${entity.pkType} {
+<#if entity.pkProperty??>
+<#if entity.pkProperty.propertyType == "Long">
+<#if !entity.protobuf>
+        entity.${entity.pkProperty.propertyName} = rowId
+</#if>
+        return rowId
+<#else>
+        return entity.${entity.pkProperty.propertyName}
+</#if>
+<#else>
+        // Unsupported or missing PK type
+        return null
+</#if>
+    }
+
+    override fun getKey(entity: ${entity.className}?) : ${entity.pkType} {
+<#if entity.pkProperty??>
+        return entity?.${entity.pkProperty.propertyName}
+<#else>
+        return null
+</#if>    
+    }
+
+    override fun hasKey(entity:${entity.className}) : Boolean {
+<#if entity.pkProperty??>
+<#if entity.pkProperty.notNull>
+        throw new UnsupportedOperationException("Unsupported for entities with a non-null key");
+<#else>
+<#if entity.protobuf>
+        return entity.is${entity.pkProperty.propertyName}
+<#else>
+        return entity.${entity.pkProperty.propertyName} != null;
+</#if>
+</#if>
+<#else>
+        // TODO
+        return false
+</#if>
+    }
+
+    protected override final isEntityUpdateable() : Boolean {
+        return ${(!entity.protobuf)?string}
+    }
+    
+<#list entity.incomingToManyRelations as toMany>
+    /** Internal query to resolve the "${toMany.name}" to-many relationship of ${toMany.sourceEntity.className}. */
+    public List<${toMany.targetEntity.className}> _query${toMany.sourceEntity.className?cap_first}_${toMany.name?cap_first}(<#--
+    --><#if toMany.targetProperties??><#list toMany.targetProperties as property><#--
+    -->${property.javaType} ${property.propertyName}<#if property_has_next>, </#if></#list><#else><#--
+    -->${toMany.sourceProperty.javaType} ${toMany.sourceProperty.propertyName}</#if>) {
+        synchronized (this) {
+            if (${toMany.sourceEntity.className?uncap_first}_${toMany.name?cap_first}Query == null) {
+                QueryBuilder<${toMany.targetEntity.className}> queryBuilder = queryBuilder();
+<#if toMany.targetProperties??>
+    <#list toMany.targetProperties as property>
+                queryBuilder.where(Properties.${property.propertyName?cap_first}.eq(null));
+    </#list>
+<#else>
+                queryBuilder.join(${toMany.joinEntity.className}.class, ${toMany.joinEntity.classNameDao}.Properties.${toMany.targetProperty.propertyName?cap_first})
+                    .where(${toMany.joinEntity.classNameDao}.Properties.${toMany.sourceProperty.propertyName?cap_first}.eq(${toMany.sourceProperty.propertyName}));
+</#if>
+<#if toMany.order?has_content>
+                queryBuilder.orderRaw("${toMany.order}");
+</#if>
+                ${toMany.sourceEntity.className?uncap_first}_${toMany.name?cap_first}Query = queryBuilder.build();
+            }
+        }
+        Query<${toMany.targetEntity.className}> query = ${toMany.sourceEntity.className?uncap_first}_${toMany.name?cap_first}Query.forCurrentThread();
+<#if toMany.targetProperties??>
+    <#list toMany.targetProperties as property>
+        query.setParameter(${property_index}, ${property.propertyName});
+    </#list>
+<#else>
+        query.setParameter(0, ${toMany.sourceProperty.propertyName});
+</#if>
+        return query.list();
+    }
+
+</#list>   
+<#if entity.toOneRelations?has_content>
+    <#include "dao-deep.ftl">
+</#if>
+}
diff --git a/DaoGenerator/src-template/kotlin/entity.ftl b/DaoGenerator/src-template/kotlin/entity.ftl
new file mode 100644
index 00000000..f23cfc8f
--- /dev/null
+++ b/DaoGenerator/src-template/kotlin/entity.ftl
@@ -0,0 +1,383 @@
+<#--
+
+Copyright (C) 2011-2016 Markus Junginger, greenrobot (http://greenrobot.org)
+                                                                           
+This file is part of greenDAO Generator.                                   
+                                                                           
+greenDAO Generator is free software: you can redistribute it and/or modify 
+it under the terms of the GNU General Public License as published by       
+the Free Software Foundation, either version 3 of the License, or          
+(at your option) any later version.                                        
+greenDAO Generator is distributed in the hope that it will be useful,      
+but WITHOUT ANY WARRANTY; without even the implied warranty of             
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              
+GNU General Public License for more details.                               
+                                                                           
+You should have received a copy of the GNU General Public License          
+along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+
+-->
+<#-- @ftlvariable name="entity" type="org.greenrobot.greendao.generator.Entity" -->
+<#-- @ftlvariable name="schema" type="org.greenrobot.greendao.generator.Schema" -->
+
+<#assign toBindType = {"Boolean":"Long", "Byte":"Long", "Short":"Long", "Int":"Long", "Long":"Long", "Float":"Double", "Double":"Double", "String":"String", "ByteArray":"Blob" }/>
+<#assign toCursorType = {"Boolean":"Short", "Byte":"Short", "Short":"Short", "Int":"Int", "Long":"Long", "Float":"Float", "Double":"Double", "String":"String", "ByteArray":"Blob" }/>
+<#assign primitiveTypes = ["boolean", "byte", "int", "long", "float", "double", "short"]/>
+<#macro multiIndexes>
+{
+<#list entity.multiIndexes as index>
+    @Index(value = "${index.orderSpec}"<#if index.nonDefaultName>, name = "${index.name}"</#if><#if index.unique>, unique = true</#if>)<#sep>,
+</#list>
+
+}</#macro>
+package ${entity.javaPackage};
+
+import org.greenrobot.greendao.annotation.*;
+
+<#if entity.toManyRelations?has_content>
+import java.util.List;
+</#if>
+<#if entity.active>
+import ${schema.defaultJavaPackageDao}.${schema.prefix}DaoSession;
+import org.greenrobot.greendao.DaoException;
+
+</#if>
+<#if entity.additionalImportsEntity?has_content>
+<#list entity.additionalImportsEntity as additionalImport>
+import ${additionalImport};
+</#list>
+
+</#if>
+<#if entity.hasKeepSections>
+// THIS CODE IS GENERATED BY greenDAO, EDIT ONLY INSIDE THE "KEEP"-SECTIONS
+
+// KEEP INCLUDES - put your custom includes here
+<#if keepIncludes?has_content>${keepIncludes!}</#if>// KEEP INCLUDES END
+<#else>
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit.
+</#if>
+
+<#if entity.javaDoc ??>
+${entity.javaDoc}
+<#else>
+/**
+ * Entity mapped to table "${entity.dbName}".
+ */
+</#if>
+<#if entity.codeBeforeClass ??>
+${entity.codeBeforeClass}
+</#if>
+<#assign entityAttrs = []>
+<#if schema.name != "default"><#assign entityAttrs = entityAttrs + ["schema = \"${schema.name}\""]></#if>
+<#if entity.active><#assign entityAttrs = entityAttrs + ["active = true"]></#if>
+<#if entity.nonDefaultDbName><#assign entityAttrs = entityAttrs + ["nameInDb = \"${entity.dbName}\""]></#if>
+<#if (entity.multiIndexes?size > 0)>
+    <#assign idxAttr>indexes = <@multiIndexes/></#assign>
+    <#assign entityAttrs = entityAttrs + [idxAttr]>
+</#if>
+<#if entity.skipCreationInDb><#assign entityAttrs = entityAttrs + ["createInDb = false"]></#if>
+@Entity<#if (entityAttrs?size > 0)>(${entityAttrs?join(", ")})</#if>
+public class ${entity.className}<#if
+entity.superclass?has_content> extends ${entity.superclass} </#if><#if
+entity.interfacesToImplement?has_content> implements <#list entity.interfacesToImplement
+as ifc>${ifc}<#if ifc_has_next>, </#if></#list></#if> {
+<#list entity.properties as property>
+<#assign notNull = property.notNull && !primitiveTypes?seq_contains(property.javaTypeInEntity)>
+<#if property.primaryKey||notNull||property.unique||property.index??||property.nonDefaultDbName||property.converter??>
+
+</#if>
+<#if property.javaDocField ??>
+${property.javaDocField}
+</#if>
+<#if property.codeBeforeField ??>
+    ${property.codeBeforeField}
+</#if>
+<#if property.primaryKey>
+    @Id<#if property.autoincrement>(autoincrement = true)</#if>
+</#if>
+<#if property.nonDefaultDbName>
+    @Property(nameInDb = "${property.dbName}")
+</#if>
+<#if property.converter??>
+    @Convert(converter = ${property.converter}.class, columnType = ${property.javaType}.class)
+</#if>
+<#if notNull>
+    @NotNull
+</#if>
+<#if property.unique>
+    @Unique
+</#if>
+<#if ((property.index.nonDefaultName)!false) && (property.index.unique)!false>
+    @Index(name = "${property.index.name}", unique = true)
+<#elseif (property.index.nonDefaultName)!false>
+    @Index(name = "${property.index.name}")
+<#elseif (property.index.unique)!false>
+    @Index(unique = true)
+<#elseif property.index??>
+    @Index
+</#if>
+    private ${property.javaTypeInEntity} ${property.propertyName};
+</#list>
+
+<#if entity.active>
+    /** Used to resolve relations */
+    @Generated
+    private transient ${schema.prefix}DaoSession daoSession;
+
+    /** Used for active entity operations. */
+    @Generated
+    private transient ${entity.classNameDao} myDao;
+<#list entity.toOneRelations as toOne>
+
+<#if toOne.useFkProperty>
+    @ToOne(joinProperty = "${toOne.fkProperties[0].propertyName}")
+    private ${toOne.targetEntity.className} ${toOne.name};
+
+    @Generated
+    private transient ${toOne.resolvedKeyJavaType[0]} ${toOne.name}__resolvedKey;
+<#else>
+    @ToOne
+<#if toOne.fkProperties[0].nonDefaultDbName>
+    @Property(nameInDb = "${toOne.fkProperties[0].dbName}")
+</#if>
+<#if toOne.fkProperties[0].unique>
+    @Unique
+</#if>
+<#if toOne.fkProperties[0].notNull>
+    @NotNull
+</#if>
+    private ${toOne.targetEntity.className} ${toOne.name};
+
+    @Generated
+    private transient boolean ${toOne.name}__refreshed;
+</#if>
+</#list>
+<#list entity.toManyRelations as toMany>
+
+<#if toMany.sourceProperties??>
+    @ToMany(joinProperties = {
+<#list toMany.sourceProperties as sourceProperty>
+        @JoinProperty(name = "${sourceProperty.propertyName}", referencedName = "${toMany.targetProperties[sourceProperty_index].propertyName}")<#sep>,
+</#list>
+
+    })
+<#elseif toMany.targetProperties??>
+    @ToMany(mappedBy = "${toMany.targetProperties[0]}")
+<#else>
+    @ToMany
+    @JoinEntity(entity = ${toMany.joinEntity.className}.class, sourceProperty = "${toMany.sourceProperty.propertyName}", targetProperty = "${toMany.targetProperty.propertyName}")
+</#if>
+<#assign orderSpec = (toMany.orderSpec)!"0">
+<#if orderSpec != "0">
+    @OrderBy("${orderSpec}")
+</#if>
+    private List<${toMany.targetEntity.className}> ${toMany.name};
+</#list>
+
+</#if>
+<#if entity.hasKeepSections>
+    // KEEP FIELDS - put your custom fields here
+${keepFields!}    // KEEP FIELDS END
+
+</#if>
+<#if entity.constructors>
+    @Generated
+    public ${entity.className}() {
+    }
+<#if entity.propertiesPk?has_content && entity.propertiesPk?size != entity.properties?size>
+
+    public ${entity.className}(<#list entity.propertiesPk as
+property>${property.javaType} ${property.propertyName}<#if property_has_next>, </#if></#list>) {
+<#list entity.propertiesPk as property>
+        this.${property.propertyName} = ${property.propertyName};
+</#list>
+    }
+</#if>
+
+    @Generated
+    public ${entity.className}(<#list entity.properties as
+property>${property.javaTypeInEntity} ${property.propertyName}<#if property_has_next>, </#if></#list>) {
+<#list entity.properties as property>
+        this.${property.propertyName} = ${property.propertyName};
+</#list>
+    }
+</#if>
+
+<#if entity.active>
+    /** called by internal mechanisms, do not call yourself. */
+    @Generated
+    public void __setDaoSession(${schema.prefix}DaoSession daoSession) {
+        this.daoSession = daoSession;
+        myDao = daoSession != null ? daoSession.get${entity.classNameDao?cap_first}() : null;
+    }
+
+</#if>
+<#list entity.properties as property>
+<#if property.javaDocGetter ??>
+${property.javaDocGetter}
+</#if>
+<#if property.codeBeforeGetter ??>
+    ${property.codeBeforeGetter}
+</#if>
+<#if property.notNull && !primitiveTypes?seq_contains(property.javaTypeInEntity)>
+    @NotNull
+</#if>
+    public ${property.javaTypeInEntity} get${property.propertyName?cap_first}() {
+        return ${property.propertyName};
+    }
+
+<#if property.notNull && !primitiveTypes?seq_contains(property.javaTypeInEntity)>
+    /** Not-null value; ensure this value is available before it is saved to the database. */
+</#if>
+<#if property.javaDocSetter ??>
+${property.javaDocSetter}
+</#if>
+<#if property.codeBeforeSetter ??>
+    ${property.codeBeforeSetter}
+</#if>
+    public void set${property.propertyName?cap_first}(<#if property.notNull && !primitiveTypes?seq_contains(property.javaTypeInEntity)>@NotNull </#if>${property.javaTypeInEntity} ${property.propertyName}) {
+        this.${property.propertyName} = ${property.propertyName};
+    }
+
+</#list>
+<#--
+##########################################
+########## To-One Relations ##############
+##########################################
+-->
+<#list entity.toOneRelations as toOne>
+    /** To-one relationship, resolved on first access. */
+    @Generated
+    public ${toOne.targetEntity.className} get${toOne.name?cap_first}() {
+<#if toOne.useFkProperty>
+        ${toOne.fkProperties[0].javaType} __key = this.${toOne.fkProperties[0].propertyName};
+        if (${toOne.name}__resolvedKey == null || <#--
+        --><#if toOne.resolvedKeyUseEquals[0]>!${toOne.name}__resolvedKey.equals(__key)<#--
+        --><#else>${toOne.name}__resolvedKey != __key</#if>) {
+            __throwIfDetached();
+            ${toOne.targetEntity.classNameDao} targetDao = daoSession.get${toOne.targetEntity.classNameDao?cap_first}();
+            ${toOne.targetEntity.className} ${toOne.name}New = targetDao.load(__key);
+            synchronized (this) {
+                ${toOne.name} = ${toOne.name}New;
+            	${toOne.name}__resolvedKey = __key;
+            }
+        }
+<#else>
+        if (${toOne.name} != null || !${toOne.name}__refreshed) {
+            __throwIfDetached();
+            ${toOne.targetEntity.classNameDao} targetDao = daoSession.get${toOne.targetEntity.classNameDao?cap_first}();
+            targetDao.refresh(${toOne.name});
+            ${toOne.name}__refreshed = true;
+        }
+</#if>
+        return ${toOne.name};
+    }
+<#if !toOne.useFkProperty>
+
+    /** To-one relationship, returned entity is not refreshed and may carry only the PK property. */
+    @Generated
+    public ${toOne.targetEntity.className} peak${toOne.name?cap_first}() {
+        return ${toOne.name};
+    }
+</#if>
+
+    @Generated
+    public void set${toOne.name?cap_first}(<#if toOne.fkProperties[0].notNull && !primitiveTypes?seq_contains(toOne.fkProperties[0].javaTypeInEntity)>@NotNull </#if>${toOne.targetEntity.className} ${toOne.name}) {
+<#if toOne.fkProperties[0].notNull>
+        if (${toOne.name} == null) {
+            throw new DaoException("To-one property '${toOne.fkProperties[0].propertyName}' has not-null constraint; cannot set to-one to null");
+        }
+</#if>
+        synchronized (this) {
+            this.${toOne.name} = ${toOne.name};
+<#if toOne.useFkProperty>        
+            ${toOne.fkProperties[0].propertyName} = <#if !toOne.fkProperties[0].notNull>${toOne.name} == null ? null : </#if>${toOne.name}.get${toOne.targetEntity.pkProperty.propertyName?cap_first}();
+            ${toOne.name}__resolvedKey = ${toOne.fkProperties[0].propertyName};
+<#else>
+            ${toOne.name}__refreshed = true;
+</#if>
+        }
+    }
+
+</#list>
+<#--
+##########################################
+########## To-Many Relations #############
+##########################################
+-->
+<#list entity.toManyRelations as toMany>
+    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
+    @Generated
+    public List<${toMany.targetEntity.className}> get${toMany.name?cap_first}() {
+        if (${toMany.name} == null) {
+            __throwIfDetached();
+            ${toMany.targetEntity.classNameDao} targetDao = daoSession.get${toMany.targetEntity.classNameDao?cap_first}();
+            List<${toMany.targetEntity.className}> ${toMany.name}New = targetDao._query${toMany.sourceEntity.className?cap_first}_${toMany.name?cap_first}(<#--
+                --><#if toMany.sourceProperties??><#list toMany.sourceProperties as property>${property.propertyName}<#if property_has_next>, </#if></#list><#else><#--
+                -->${entity.pkProperty.propertyName}</#if>);
+            synchronized (this) {<#-- Check if another thread was faster, we cannot lock while doing the query to prevent deadlocks -->
+                if(${toMany.name} == null) {
+                    ${toMany.name} = ${toMany.name}New;
+                }
+            }
+        }
+        return ${toMany.name};
+    }
+
+    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
+    @Generated
+    public synchronized void reset${toMany.name?cap_first}() {
+        ${toMany.name} = null;
+    }
+
+</#list>
+<#--
+##########################################
+########## Active entity operations ######
+##########################################
+-->
+<#if entity.active>
+    /**
+    * Convenient call for {@link org.greenrobot.greendao.AbstractDao#delete(Object)}.
+    * Entity must attached to an entity context.
+    */
+    @Generated
+    public void delete() {
+        __throwIfDetached();
+        myDao.delete(this);
+    }
+
+    /**
+    * Convenient call for {@link org.greenrobot.greendao.AbstractDao#update(Object)}.
+    * Entity must attached to an entity context.
+    */
+    @Generated
+    public void update() {
+        __throwIfDetached();
+        myDao.update(this);
+    }
+
+    /**
+    * Convenient call for {@link org.greenrobot.greendao.AbstractDao#refresh(Object)}.
+    * Entity must attached to an entity context.
+    */
+    @Generated
+    public void refresh() {
+        __throwIfDetached();
+        myDao.refresh(this);
+    }
+
+    @Generated
+    private void __throwIfDetached() {
+        if (myDao == null) {
+            throw new DaoException("Entity is detached from DAO context");
+        }
+    }
+
+</#if>
+<#if entity.hasKeepSections>
+    // KEEP METHODS - put your custom methods here
+${keepMethods!}    // KEEP METHODS END
+
+</#if>
+}
diff --git a/DaoGenerator/src-test/org/greenrobot/greendao/generator/SimpleDaoGeneratorTest.java b/DaoGenerator/src-test/org/greenrobot/greendao/generator/SimpleDaoGeneratorTest.java
index 7567169d..696cd120 100644
--- a/DaoGenerator/src-test/org/greenrobot/greendao/generator/SimpleDaoGeneratorTest.java
+++ b/DaoGenerator/src-test/org/greenrobot/greendao/generator/SimpleDaoGeneratorTest.java
@@ -41,11 +41,11 @@ public void testMinimalSchema() throws Exception {
         File outputDir = new File("build/test-out");
         outputDir.mkdirs();
 
-        File daoFile = new File(outputDir, "org/greenrobot/testdao/" + addressEntity.getClassName() + "Dao.java");
+        File daoFile = new File(outputDir, "org/greenrobot/testdao/" + addressEntity.getClassName() + "Dao.kt");
         daoFile.delete();
         assertFalse(daoFile.exists());
 
-        new DaoGenerator().generateAll(schema, outputDir.getPath());
+        new DaoGenerator(true).generateAll(schema, outputDir.getPath());
 
         assertEquals("PRIMARY KEY", idProperty.getConstraints());
         assertTrue(daoFile.toString(), daoFile.exists());
diff --git a/DaoGenerator/src/org/greenrobot/greendao/generator/DaoGenerator.java b/DaoGenerator/src/org/greenrobot/greendao/generator/DaoGenerator.java
index bc49738e..66373f0d 100644
--- a/DaoGenerator/src/org/greenrobot/greendao/generator/DaoGenerator.java
+++ b/DaoGenerator/src/org/greenrobot/greendao/generator/DaoGenerator.java
@@ -50,7 +50,18 @@
     private Template templateDaoUnitTest;
     private Template templateContentProvider;
 
+    private boolean isKotlin = false;
+
     public DaoGenerator() throws IOException {
+        init("");
+    }
+
+    public DaoGenerator(boolean isKotlin) throws IOException {
+        this.isKotlin = isKotlin;
+        init(isKotlin ? "kotlin/" : "");
+    }
+
+    private void init(String baseFolder) throws IOException {
         System.out.println("greenDAO Generator");
         System.out.println("Copyright 2011-2016 Markus Junginger, greenrobot.de. Licensed under GPL V3.");
         System.out.println("This program comes with ABSOLUTELY NO WARRANTY");
@@ -60,9 +71,9 @@ public DaoGenerator() throws IOException {
         patternKeepMethods = compilePattern("METHODS");
 
         Configuration config = getConfiguration("dao.ftl");
-        templateDao = config.getTemplate("dao.ftl");
-        templateDaoMaster = config.getTemplate("dao-master.ftl");
-        templateDaoSession = config.getTemplate("dao-session.ftl");
+        templateDao = config.getTemplate(baseFolder + "dao.ftl");
+        templateDaoMaster = config.getTemplate(baseFolder + "dao-master.ftl");
+        templateDaoSession = config.getTemplate(baseFolder + "dao-session.ftl");
         templateEntity = config.getTemplate("entity.ftl");
         templateDaoUnitTest = config.getTemplate("dao-unit-test.ftl");
         templateContentProvider = config.getTemplate("content-provider.ftl");
@@ -126,11 +137,11 @@ public void generateAll(Schema schema, String outDir, String outDirEntity, Strin
             if (outDirTestFile != null && !entity.isSkipGenerationTest()) {
                 String javaPackageTest = entity.getJavaPackageTest();
                 String classNameTest = entity.getClassNameTest();
-                File javaFilename = toJavaFilename(outDirTestFile, javaPackageTest, classNameTest);
-                if (!javaFilename.exists()) {
+                File filename = toFilename(outDirTestFile, javaPackageTest, classNameTest);
+                if (!filename.exists()) {
                     generate(templateDaoUnitTest, outDirTestFile, javaPackageTest, classNameTest, schema, entity);
                 } else {
-                    System.out.println("Skipped " + javaFilename.getCanonicalPath());
+                    System.out.println("Skipped " + filename.getCanonicalPath());
                 }
             }
             for (ContentProvider contentProvider : entity.getContentProviders()) {
@@ -172,7 +183,7 @@ private void generate(Template template, File outDirFile, String javaPackage, St
             root.putAll(additionalObjectsForTemplate);
         }
         try {
-            File file = toJavaFilename(outDirFile, javaPackage, javaClassName);
+            File file = toFilename(outDirFile, javaPackage, javaClassName);
             //noinspection ResultOfMethodCallIgnored
             file.getParentFile().mkdirs();
 
@@ -223,10 +234,10 @@ private void checkKeepSections(File file, Map<String, Object> root) {
         }
     }
 
-    protected File toJavaFilename(File outDirFile, String javaPackage, String javaClassName) {
+    protected File toFilename(File outDirFile, String javaPackage, String javaClassName) {
         String packageSubPath = javaPackage.replace('.', '/');
         File packagePath = new File(outDirFile, packageSubPath);
-        return new File(packagePath, javaClassName + ".java");
+        return new File(packagePath, javaClassName + (isKotlin ? ".kt" : ".java"));
     }
 
 }
