diff --git a/DaoCore/src/de/greenrobot/dao/AbstractDao.java b/DaoCore/src/de/greenrobot/dao/AbstractDao.java
index 95c29eb2..314ec15c 100644
--- a/DaoCore/src/de/greenrobot/dao/AbstractDao.java
+++ b/DaoCore/src/de/greenrobot/dao/AbstractDao.java
@@ -16,21 +16,18 @@
 
 package de.greenrobot.dao;
 
+import java.sql.Connection;
+import java.sql.PreparedStatement;
+import java.sql.ResultSet;
+import java.sql.SQLException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.List;
 
-import android.database.CrossProcessCursor;
-import android.database.Cursor;
-import android.database.CursorWindow;
-import android.database.DatabaseUtils;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteStatement;
 import de.greenrobot.dao.identityscope.IdentityScope;
 import de.greenrobot.dao.identityscope.IdentityScopeLong;
 import de.greenrobot.dao.internal.DaoConfig;
-import de.greenrobot.dao.internal.FastCursor;
 import de.greenrobot.dao.internal.TableStatements;
 import de.greenrobot.dao.query.Query;
 import de.greenrobot.dao.query.QueryBuilder;
@@ -57,7 +54,7 @@
  * 3.) identityScope
  */
 public abstract class AbstractDao<T, K> {
-    protected final SQLiteDatabase db;
+    protected final Connection connection;
     protected final DaoConfig config;
     protected IdentityScope<K, T> identityScope;
     protected IdentityScopeLong<T> identityScopeLong;
@@ -74,7 +71,7 @@ public AbstractDao(DaoConfig config) {
     public AbstractDao(DaoConfig config, AbstractDaoSession daoSession) {
         this.config = config;
         this.session = daoSession;
-        db = config.db;
+        connection = config.connection;
         identityScope = (IdentityScope<K, T>) config.getIdentityScope();
         if (identityScope instanceof IdentityScopeLong) {
             identityScopeLong = (IdentityScopeLong<T>) identityScope;
@@ -121,8 +118,9 @@ public Property getPkProperty() {
      * @param key
      *            a PK value or null
      * @return The entity or null, if no entity matched the PK value
+     * @throws SQLException 
      */
-    public T load(K key) {
+    public T load(K key) throws SQLException {
         assertSinglePk();
         if (key == null) {
             return null;
@@ -134,39 +132,45 @@ public T load(K key) {
             }
         }
         String sql = statements.getSelectByKey();
-        String[] keyArray = new String[] { key.toString() };
-        Cursor cursor = db.rawQuery(sql, keyArray);
-        return loadUniqueAndCloseCursor(cursor);
+        PreparedStatement statement = connection.prepareStatement( sql );
+        statement.setString( 0, key.toString() );
+        ResultSet resultSet = statement.executeQuery();
+        return loadUniqueAndCloseCursor(resultSet);
     }
 
-    public T loadByRowId(long rowId) {
-        String[] idArray = new String[] { Long.toString(rowId) };
-        Cursor cursor = db.rawQuery(statements.getSelectByRowId(), idArray);
-        return loadUniqueAndCloseCursor(cursor);
+    public T loadByRowId(long rowId) throws SQLException {
+        String sql = statements.getSelectByRowId();
+        PreparedStatement statement = connection.prepareStatement( sql );
+        statement.setString( 0, Long.toString(rowId) );
+        ResultSet resultSet = statement.executeQuery();
+        return loadUniqueAndCloseCursor(resultSet);
     }
 
-    protected T loadUniqueAndCloseCursor(Cursor cursor) {
+    protected T loadUniqueAndCloseCursor(ResultSet resultSet) throws SQLException {
         try {
-            return loadUnique(cursor);
+            return loadUnique(resultSet);
         } finally {
-            cursor.close();
+            resultSet.close();
         }
     }
 
-    protected T loadUnique(Cursor cursor) {
-        boolean available = cursor.moveToFirst();
+    protected T loadUnique(ResultSet resultSet) throws SQLException {
+        boolean available = resultSet.next();
         if (!available) {
             return null;
-        } else if (!cursor.isLast()) {
-            throw new DaoException("Expected unique result, but count was " + cursor.getCount());
+        } else if (!resultSet.isLast()) {
+            throw new DaoException("Expected unique result, but count was " + resultSet.getFetchSize());
         }
-        return loadCurrent(cursor, 0, true);
+        return loadCurrent(resultSet, 0, true);
     }
 
-    /** Loads all available entities from the database. */
-    public List<T> loadAll() {
-        Cursor cursor = db.rawQuery(statements.getSelectAll(), null);
-        return loadAllAndCloseCursor(cursor);
+    /** Loads all available entities from the database. 
+     * @throws SQLException */
+    public List<T> loadAll() throws SQLException {
+        String sql = statements.getSelectAll();
+        PreparedStatement statement = connection.prepareStatement( sql );
+        ResultSet resultSet = statement.executeQuery();
+        return loadAllAndCloseCursor(resultSet);
     }
 
     /** Detaches an entity from the identity scope (session). Subsequent query results won't return this object. */
@@ -179,11 +183,11 @@ public boolean detach(T entity) {
         }
     }
 
-    protected List<T> loadAllAndCloseCursor(Cursor cursor) {
+    protected List<T> loadAllAndCloseCursor(ResultSet resultSet) throws SQLException {
         try {
-            return loadAllFromCursor(cursor);
+            return loadAllFromCursor(resultSet);
         } finally {
-            cursor.close();
+            resultSet.close();
         }
     }
 
@@ -192,8 +196,9 @@ public boolean detach(T entity) {
      * 
      * @param entities
      *            The entities to insert.
+     * @throws SQLException 
      */
-    public void insertInTx(Iterable<T> entities) {
+    public void insertInTx(Iterable<T> entities) throws SQLException {
         insertInTx(entities, isEntityUpdateable());
     }
 
@@ -202,8 +207,9 @@ public void insertInTx(Iterable<T> entities) {
      * 
      * @param entities
      *            The entities to insert.
+     * @throws SQLException 
      */
-    public void insertInTx(T... entities) {
+    public void insertInTx(T... entities) throws SQLException {
         insertInTx(Arrays.asList(entities), isEntityUpdateable());
     }
 
@@ -215,9 +221,10 @@ public void insertInTx(T... entities) {
      *            The entities to insert.
      * @param setPrimaryKey
      *            if true, the PKs of the given will be set after the insert; pass false to improve performance.
+     * @throws SQLException 
      */
-    public void insertInTx(Iterable<T> entities, boolean setPrimaryKey) {
-        SQLiteStatement stmt = statements.getInsertStatement();
+    public void insertInTx(Iterable<T> entities, boolean setPrimaryKey) throws SQLException {
+        PreparedStatement stmt = statements.getInsertStatement();
         executeInsertInTx(stmt, entities, setPrimaryKey);
     }
 
@@ -229,9 +236,10 @@ public void insertInTx(Iterable<T> entities, boolean setPrimaryKey) {
      *            The entities to insert.
      * @param setPrimaryKey
      *            if true, the PKs of the given will be set after the insert; pass false to improve performance.
+     * @throws SQLException 
      */
-    public void insertOrReplaceInTx(Iterable<T> entities, boolean setPrimaryKey) {
-        SQLiteStatement stmt = statements.getInsertOrReplaceStatement();
+    public void insertOrReplaceInTx(Iterable<T> entities, boolean setPrimaryKey) throws SQLException {
+    	PreparedStatement stmt = statements.getInsertOrReplaceStatement();
         executeInsertInTx(stmt, entities, setPrimaryKey);
     }
 
@@ -240,8 +248,9 @@ public void insertOrReplaceInTx(Iterable<T> entities, boolean setPrimaryKey) {
      * 
      * @param entities
      *            The entities to insert.
+     * @throws SQLException 
      */
-    public void insertOrReplaceInTx(Iterable<T> entities) {
+    public void insertOrReplaceInTx(Iterable<T> entities) throws SQLException {
         insertOrReplaceInTx(entities, isEntityUpdateable());
     }
 
@@ -250,13 +259,15 @@ public void insertOrReplaceInTx(Iterable<T> entities) {
      * 
      * @param entities
      *            The entities to insert.
+     * @throws SQLException 
      */
-    public void insertOrReplaceInTx(T... entities) {
+    public void insertOrReplaceInTx(T... entities) throws SQLException {
         insertOrReplaceInTx(Arrays.asList(entities), isEntityUpdateable());
     }
 
-    private void executeInsertInTx(SQLiteStatement stmt, Iterable<T> entities, boolean setPrimaryKey) {
-        db.beginTransaction();
+//	TODO transaction
+    private void executeInsertInTx(PreparedStatement stmt, Iterable<T> entities, boolean setPrimaryKey) {
+//    	connection.beginTransaction();
         try {
             synchronized (stmt) {
                 if (identityScope != null) {
@@ -266,21 +277,26 @@ private void executeInsertInTx(SQLiteStatement stmt, Iterable<T> entities, boole
                     for (T entity : entities) {
                         bindValues(stmt, entity);
                         if (setPrimaryKey) {
-                            long rowId = stmt.executeInsert();
+                            long rowId = stmt.executeUpdate();
                             updateKeyAfterInsertAndAttach(entity, rowId, false);
                         } else {
                             stmt.execute();
                         }
                     }
-                } finally {
+                }
+				catch ( SQLException e )
+				{
+					e.printStackTrace();
+					// rollback?!
+				} finally {
                     if (identityScope != null) {
                         identityScope.unlock();
                     }
                 }
             }
-            db.setTransactionSuccessful();
+//            db.setTransactionSuccessful();
         } finally {
-            db.endTransaction();
+//            db.endTransaction();
         }
     }
 
@@ -288,8 +304,9 @@ private void executeInsertInTx(SQLiteStatement stmt, Iterable<T> entities, boole
      * Insert an entity into the table associated with a concrete DAO.
      * 
      * @return row ID of newly inserted entity
+     * @throws SQLException 
      */
-    public long insert(T entity) {
+    public long insert(T entity) throws SQLException {
         return executeInsert(entity, statements.getInsertStatement());
     }
 
@@ -298,26 +315,30 @@ public long insert(T entity) {
      * may be faster, but the entity should not be used anymore. The entity also won't be attached to identy scope.
      * 
      * @return row ID of newly inserted entity
+     * @throws SQLException 
      */
-    public long insertWithoutSettingPk(T entity) {
-        SQLiteStatement stmt = statements.getInsertStatement();
+    public long insertWithoutSettingPk(T entity) throws SQLException {
+    	PreparedStatement stmt = statements.getInsertStatement();
         long rowId;
-        if (db.isDbLockedByCurrentThread()) {
+        // FIXME not sure what to do here...
+//        if (db.isDbLockedByCurrentThread()) {
+        if (!connection.isClosed()) {
             synchronized (stmt) {
                 bindValues(stmt, entity);
-                rowId = stmt.executeInsert();
+                rowId = stmt.executeUpdate();
             }
         } else {
             // Do TX to acquire a connection before locking the stmt to avoid deadlocks
-            db.beginTransaction();
+// TODO transaction        	
+//            db.beginTransaction();
             try {
                 synchronized (stmt) {
                     bindValues(stmt, entity);
-                    rowId = stmt.executeInsert();
+                    rowId = stmt.executeUpdate();
                 }
-                db.setTransactionSuccessful();
+//                db.setTransactionSuccessful();
             } finally {
-                db.endTransaction();
+//                db.endTransaction();
             }
         }
         return rowId;
@@ -327,29 +348,33 @@ public long insertWithoutSettingPk(T entity) {
      * Insert an entity into the table associated with a concrete DAO.
      * 
      * @return row ID of newly inserted entity
+     * @throws SQLException 
      */
-    public long insertOrReplace(T entity) {
+    public long insertOrReplace(T entity) throws SQLException {
         return executeInsert(entity, statements.getInsertOrReplaceStatement());
     }
 
-    private long executeInsert(T entity, SQLiteStatement stmt) {
+    private long executeInsert(T entity, PreparedStatement stmt) throws SQLException {
         long rowId;
-        if (db.isDbLockedByCurrentThread()) {
+        // FIXME not sure what to do here...
+//        if (connection.isDbLockedByCurrentThread()) {
+        if (!connection.isClosed()) {
             synchronized (stmt) {
                 bindValues(stmt, entity);
-                rowId = stmt.executeInsert();
+                rowId = stmt.executeUpdate();
             }
         } else {
             // Do TX to acquire a connection before locking the stmt to avoid deadlocks
-            db.beginTransaction();
+// TODO transaction
+//            db.beginTransaction();
             try {
                 synchronized (stmt) {
                     bindValues(stmt, entity);
-                    rowId = stmt.executeInsert();
+                    rowId = stmt.executeUpdate();
                 }
-                db.setTransactionSuccessful();
+//                db.setTransactionSuccessful();
             } finally {
-                db.endTransaction();
+//                db.endTransaction();
             }
         }
         updateKeyAfterInsertAndAttach(entity, rowId, true);
@@ -366,30 +391,21 @@ protected void updateKeyAfterInsertAndAttach(T entity, long rowId, boolean lock)
         }
     }
 
-    /** Reads all available rows from the given cursor and returns a list of entities. */
-    protected List<T> loadAllFromCursor(Cursor cursor) {
-        int count = cursor.getCount();
+    /** Reads all available rows from the given cursor and returns a list of entities. 
+     * @throws SQLException */
+    protected List<T> loadAllFromCursor(ResultSet resultSet) throws SQLException {
+        int count = resultSet.getFetchSize();
         List<T> list = new ArrayList<T>(count);
-        if (cursor instanceof CrossProcessCursor) {
-            CursorWindow window = ((CrossProcessCursor) cursor).getWindow();
-            if (window != null) { // E.g. Roboelectric has no Window at this point
-                if (window.getNumRows() == count) {
-                    cursor = new FastCursor(window);
-                } else {
-                    DaoLog.d("Window vs. result size: " + window.getNumRows() + "/" + count);
-                }
-            }
-        }
-
-        if (cursor.moveToFirst()) {
+        
+        if (resultSet.next()) {
             if (identityScope != null) {
                 identityScope.lock();
                 identityScope.reserveRoom(count);
             }
             try {
                 do {
-                    list.add(loadCurrent(cursor, 0, false));
-                } while (cursor.moveToNext());
+                    list.add(loadCurrent(resultSet, 0, false));
+                } while (resultSet.next());
             } finally {
                 if (identityScope != null) {
                     identityScope.unlock();
@@ -399,22 +415,23 @@ protected void updateKeyAfterInsertAndAttach(T entity, long rowId, boolean lock)
         return list;
     }
 
-    /** Internal use only. Considers identity scope. */
-    final protected T loadCurrent(Cursor cursor, int offset, boolean lock) {
+    /** Internal use only. Considers identity scope. 
+     * @throws SQLException */
+    final protected T loadCurrent(ResultSet resultSet, int offset, boolean lock) throws SQLException {
         if (identityScopeLong != null) {
             if (offset != 0) {
                 // Occurs with deep loads (left outer joins)
-                if (cursor.isNull(pkOrdinal + offset)) {
+                if (resultSet.getObject(pkOrdinal + offset) == null) {
                     return null;
                 }
             }
 
-            long key = cursor.getLong(pkOrdinal + offset);
+            long key = resultSet.getLong(pkOrdinal + offset);
             T entity = lock ? identityScopeLong.get2(key) : identityScopeLong.get2NoLock(key);
             if (entity != null) {
                 return entity;
             } else {
-                entity = readEntity(cursor, offset);
+                entity = readEntity(resultSet, offset);
                 attachEntity(entity);
                 if (lock) {
                     identityScopeLong.put2(key, entity);
@@ -424,7 +441,7 @@ final protected T loadCurrent(Cursor cursor, int offset, boolean lock) {
                 return entity;
             }
         } else if (identityScope != null) {
-            K key = readKey(cursor, offset);
+            K key = readKey(resultSet, offset);
             if (offset != 0 && key == null) {
                 // Occurs with deep loads (left outer joins)
                 return null;
@@ -433,34 +450,42 @@ final protected T loadCurrent(Cursor cursor, int offset, boolean lock) {
             if (entity != null) {
                 return entity;
             } else {
-                entity = readEntity(cursor, offset);
+                entity = readEntity(resultSet, offset);
                 attachEntity(key, entity, lock);
                 return entity;
             }
         } else {
             // Check offset, assume a value !=0 indicating a potential outer join, so check PK
             if (offset != 0) {
-                K key = readKey(cursor, offset);
+                K key = readKey(resultSet, offset);
                 if (key == null) {
                     // Occurs with deep loads (left outer joins)
                     return null;
                 }
             }
-            T entity = readEntity(cursor, offset);
+            T entity = readEntity(resultSet, offset);
             attachEntity(entity);
             return entity;
         }
     }
 
-    /** Internal use only. Considers identity scope. */
-    final protected <O> O loadCurrentOther(AbstractDao<O, ?> dao, Cursor cursor, int offset) {
-        return dao.loadCurrent(cursor, offset, /* TODO check this */true);
+    /** Internal use only. Considers identity scope. 
+     * @throws SQLException */
+    final protected <O> O loadCurrentOther(AbstractDao<O, ?> dao, ResultSet resultSet, int offset) throws SQLException {
+        return dao.loadCurrent(resultSet, offset, /* TODO check this */true);
     }
 
-    /** A raw-style query where you can pass any WHERE clause and arguments. */
-    public List<T> queryRaw(String where, String... selectionArg) {
-        Cursor cursor = db.rawQuery(statements.getSelectAll() + where, selectionArg);
-        return loadAllAndCloseCursor(cursor);
+    /** A raw-style query where you can pass any WHERE clause and arguments. 
+     * @throws SQLException */
+    public List<T> queryRaw(String where, String... selectionArg) throws SQLException {
+		String sql = statements.getSelectAll() + where;
+		PreparedStatement statement = connection.prepareStatement( sql );
+		for ( int i = 0; i < selectionArg.length; i++ )
+		{
+			statement.setString( i, selectionArg[i] );
+		}
+		ResultSet resultSet = statement.executeQuery();
+		return loadAllAndCloseCursor(resultSet);
     }
 
     /**
@@ -480,41 +505,46 @@ final protected T loadCurrent(Cursor cursor, int offset, boolean lock) {
         return Query.internalCreate(this, statements.getSelectAll() + where, selectionArg.toArray());
     }
 
-    public void deleteAll() {
+    public void deleteAll() throws SQLException {
         // String sql = SqlUtils.createSqlDelete(config.tablename, null);
         // db.execSQL(sql);
 
-        db.execSQL("DELETE FROM '" + config.tablename + "'");
+    	connection.createStatement().execute( "DELETE FROM '" + config.tablename + "'" );
         if (identityScope != null) {
             identityScope.clear();
         }
     }
 
-    /** Deletes the given entity from the database. Currently, only single value PK entities are supported. */
-    public void delete(T entity) {
+    /** Deletes the given entity from the database. Currently, only single value PK entities are supported. 
+     * @throws SQLException */
+    public void delete(T entity) throws SQLException {
         assertSinglePk();
         K key = getKeyVerified(entity);
         deleteByKey(key);
     }
 
-    /** Deletes an entity with the given PK from the database. Currently, only single value PK entities are supported. */
-    public void deleteByKey(K key) {
+    /** Deletes an entity with the given PK from the database. Currently, only single value PK entities are supported. 
+     * @throws SQLException */
+    public void deleteByKey(K key) throws SQLException {
         assertSinglePk();
-        SQLiteStatement stmt = statements.getDeleteStatement();
-        if (db.isDbLockedByCurrentThread()) {
+        PreparedStatement stmt = statements.getDeleteStatement();
+        // FIXME not sure what to do here...
+//        if (db.isDbLockedByCurrentThread()) {
+        if (!connection.isClosed()) {
             synchronized (stmt) {
                 deleteByKeyInsideSynchronized(key, stmt);
             }
         } else {
             // Do TX to acquire a connection before locking the stmt to avoid deadlocks
-            db.beginTransaction();
+// TODO transaction
+//            db.beginTransaction();
             try {
                 synchronized (stmt) {
                     deleteByKeyInsideSynchronized(key, stmt);
                 }
-                db.setTransactionSuccessful();
+//                db.setTransactionSuccessful();
             } finally {
-                db.endTransaction();
+//                db.endTransaction();
             }
         }
         if (identityScope != null) {
@@ -522,22 +552,23 @@ public void deleteByKey(K key) {
         }
     }
 
-    private void deleteByKeyInsideSynchronized(K key, SQLiteStatement stmt) {
+    private void deleteByKeyInsideSynchronized(K key, PreparedStatement stmt) throws SQLException {
         if (key instanceof Long) {
-            stmt.bindLong(1, (Long) key);
+            stmt.setLong(1, (Long) key);
         } else if (key == null) {
             throw new DaoException("Cannot delete entity, key is null");
         } else {
-            stmt.bindString(1, key.toString());
+            stmt.setString(1, key.toString());
         }
         stmt.execute();
     }
 
-    private void deleteInTxInternal(Iterable<T> entities, Iterable<K> keys) {
+    private void deleteInTxInternal(Iterable<T> entities, Iterable<K> keys) throws SQLException {
         assertSinglePk();
-        SQLiteStatement stmt = statements.getDeleteStatement();
+        PreparedStatement stmt = statements.getDeleteStatement();
         List<K> keysToRemoveFromIdentityScope = null;
-        db.beginTransaction();
+// TODO transaction
+//        db.beginTransaction();
         try {
             synchronized (stmt) {
                 if (identityScope != null) {
@@ -568,12 +599,12 @@ private void deleteInTxInternal(Iterable<T> entities, Iterable<K> keys) {
                     }
                 }
             }
-            db.setTransactionSuccessful();
+//            db.setTransactionSuccessful();
             if (keysToRemoveFromIdentityScope != null && identityScope != null) {
                 identityScope.remove(keysToRemoveFromIdentityScope);
             }
         } finally {
-            db.endTransaction();
+//            db.endTransaction();
         }
     }
 
@@ -582,8 +613,9 @@ private void deleteInTxInternal(Iterable<T> entities, Iterable<K> keys) {
      * 
      * @param entities
      *            The entities to delete.
+     * @throws SQLException 
      */
-    public void deleteInTx(Iterable<T> entities) {
+    public void deleteInTx(Iterable<T> entities) throws SQLException {
         deleteInTxInternal(entities, null);
     }
 
@@ -592,8 +624,9 @@ public void deleteInTx(Iterable<T> entities) {
      * 
      * @param entities
      *            The entities to delete.
+     * @throws SQLException 
      */
-    public void deleteInTx(T... entities) {
+    public void deleteInTx(T... entities) throws SQLException {
         deleteInTxInternal(Arrays.asList(entities), null);
     }
 
@@ -602,8 +635,9 @@ public void deleteInTx(T... entities) {
      * 
      * @param keys
      *            Keys of the entities to delete.
+     * @throws SQLException 
      */
-    public void deleteByKeyInTx(Iterable<K> keys) {
+    public void deleteByKeyInTx(Iterable<K> keys) throws SQLException {
         deleteInTxInternal(null, keys);
     }
 
@@ -612,50 +646,56 @@ public void deleteByKeyInTx(Iterable<K> keys) {
      * 
      * @param keys
      *            Keys of the entities to delete.
+     * @throws SQLException 
      */
-    public void deleteByKeyInTx(K... keys) {
+    public void deleteByKeyInTx(K... keys) throws SQLException {
         deleteInTxInternal(null, Arrays.asList(keys));
     }
 
-    /** Resets all locally changed properties of the entity by reloading the values from the database. */
-    public void refresh(T entity) {
+    /** Resets all locally changed properties of the entity by reloading the values from the database. 
+     * @throws SQLException */
+    public void refresh(T entity) throws SQLException {
         assertSinglePk();
         K key = getKeyVerified(entity);
         String sql = statements.getSelectByKey();
-        String[] keyArray = new String[] { key.toString() };
-        Cursor cursor = db.rawQuery(sql, keyArray);
+        PreparedStatement statement = connection.prepareStatement( sql );
+        statement.setString( 0, key.toString() );
+        ResultSet resultSet = statement.executeQuery();
         try {
-            boolean available = cursor.moveToFirst();
+            boolean available = resultSet.next();
             if (!available) {
                 throw new DaoException("Entity does not exist in the database anymore: " + entity.getClass()
                         + " with key " + key);
-            } else if (!cursor.isLast()) {
-                throw new DaoException("Expected unique result, but count was " + cursor.getCount());
+            } else if (!resultSet.isLast()) {
+                throw new DaoException("Expected unique result, but count was " + resultSet.getFetchSize());
             }
-            readEntity(cursor, entity, 0);
+            readEntity(resultSet, entity, 0);
             attachEntity(key, entity, true);
         } finally {
-            cursor.close();
+            resultSet.close();
         }
     }
 
-    public void update(T entity) {
+    public void update(T entity) throws SQLException {
         assertSinglePk();
-        SQLiteStatement stmt = statements.getUpdateStatement();
-        if (db.isDbLockedByCurrentThread()) {
+        PreparedStatement stmt = statements.getUpdateStatement();
+// FIXME not sure what to do here...        
+//        if (db.isDbLockedByCurrentThread()) {
+        if (!connection.isClosed()) {
             synchronized (stmt) {
                 updateInsideSynchronized(entity, stmt, true);
             }
         } else {
             // Do TX to acquire a connection before locking the stmt to avoid deadlocks
-            db.beginTransaction();
+// TODO transaction        	
+//            db.beginTransaction();
             try {
                 synchronized (stmt) {
                     updateInsideSynchronized(entity, stmt, true);
                 }
-                db.setTransactionSuccessful();
+//                db.setTransactionSuccessful();
             } finally {
-                db.endTransaction();
+//                db.endTransaction();
             }
         }
     }
@@ -664,17 +704,17 @@ public void update(T entity) {
         return QueryBuilder.internalCreate(this);
     }
 
-    protected void updateInsideSynchronized(T entity, SQLiteStatement stmt, boolean lock) {
+    protected void updateInsideSynchronized(T entity, PreparedStatement stmt, boolean lock) throws SQLException {
         // To do? Check if it's worth not to bind PKs here (performance).
         bindValues(stmt, entity);
         int index = config.allColumns.length + 1;
         K key = getKey(entity);
         if (key instanceof Long) {
-            stmt.bindLong(index, (Long) key);
+            stmt.setLong(index, (Long) key);
         } else if (key == null) {
             throw new DaoException("Cannot update entity without key - was it inserted before?");
         } else {
-            stmt.bindString(index, key.toString());
+            stmt.setString(index, key.toString());
         }
         stmt.execute();
         attachEntity(key, entity, lock);
@@ -714,10 +754,12 @@ protected void attachEntity(T entity) {
      * 
      * @param entities
      *            The entities to insert.
+     * @throws SQLException 
      */
-    public void updateInTx(Iterable<T> entities) {
-        SQLiteStatement stmt = statements.getUpdateStatement();
-        db.beginTransaction();
+    public void updateInTx(Iterable<T> entities) throws SQLException {
+        PreparedStatement stmt = statements.getUpdateStatement();
+// TODO transaction        
+//        db.beginTransaction();
         try {
             synchronized (stmt) {
                 if (identityScope != null) {
@@ -733,9 +775,9 @@ public void updateInTx(Iterable<T> entities) {
                     }
                 }
             }
-            db.setTransactionSuccessful();
+//            db.setTransactionSuccessful();
         } finally {
-            db.endTransaction();
+//            db.endTransaction();
         }
     }
 
@@ -744,8 +786,9 @@ public void updateInTx(Iterable<T> entities) {
      * 
      * @param entities
      *            The entities to update.
+     * @throws SQLException 
      */
-    public void updateInTx(T... entities) {
+    public void updateInTx(T... entities) throws SQLException {
         updateInTx(Arrays.asList(entities));
     }
 
@@ -755,8 +798,20 @@ protected void assertSinglePk() {
         }
     }
 
-    public long count() {
-        return DatabaseUtils.queryNumEntries(db, '\'' + config.tablename + '\'');
+    public long count() throws SQLException {
+    	long result = 0L;
+    	try {
+    		PreparedStatement statement = connection.prepareStatement( "SELECT count(*) as counter FROM " + config.tablename );
+    		ResultSet resultSet = statement.executeQuery();
+    		if (resultSet.next())
+    		{
+    			result = resultSet.getLong( "counter" );
+    		}
+    	} catch (SQLException e) {
+    		e.printStackTrace();
+    	}
+    	return result;
+//        return DatabaseUtils.queryNumEntries(db, '\'' + config.tablename + '\'');
     }
 
     /** See {@link #getKey(Object)}, but guarantees that the returned key is never null (throws if null). */
@@ -774,21 +829,21 @@ protected K getKeyVerified(T entity) {
     }
 
     /** Gets the SQLiteDatabase for custom database access. Not needed for greenDAO entities. */
-    public SQLiteDatabase getDatabase() {
-        return db;
+    public Connection getConnection() {
+        return connection;
     }
 
     /** Reads the values from the current position of the given cursor and returns a new entity. */
-    abstract protected T readEntity(Cursor cursor, int offset);
+    abstract protected T readEntity(ResultSet resultSet, int offset);
 
     /** Reads the key from the current position of the given cursor, or returns null if there's no single-value key. */
-    abstract protected K readKey(Cursor cursor, int offset);
+    abstract protected K readKey(ResultSet resultSet, int offset);
 
     /** Reads the values from the current position of the given cursor into an existing entity. */
-    abstract protected void readEntity(Cursor cursor, T entity, int offset);
+    abstract protected void readEntity(ResultSet resultSet, T entity, int offset);
 
     /** Binds the entity's values to the statement. Make sure to synchronize the statement outside of the method. */
-    abstract protected void bindValues(SQLiteStatement stmt, T entity);
+    abstract protected void bindValues(PreparedStatement stmt, T entity);
 
     /**
      * Updates the entity's key if possible (only for Long PKs currently). This method must always return the entity's
diff --git a/DaoCore/src/de/greenrobot/dao/AbstractDaoMaster.java b/DaoCore/src/de/greenrobot/dao/AbstractDaoMaster.java
index 5b635bcd..0014dfeb 100644
--- a/DaoCore/src/de/greenrobot/dao/AbstractDaoMaster.java
+++ b/DaoCore/src/de/greenrobot/dao/AbstractDaoMaster.java
@@ -16,10 +16,10 @@
 
 package de.greenrobot.dao;
 
+import java.sql.Connection;
 import java.util.HashMap;
 import java.util.Map;
 
-import android.database.sqlite.SQLiteDatabase;
 import de.greenrobot.dao.identityscope.IdentityScopeType;
 import de.greenrobot.dao.internal.DaoConfig;
 
@@ -29,19 +29,19 @@
  * @author Markus
  */
 public abstract class AbstractDaoMaster {
-    protected final SQLiteDatabase db;
+    protected final Connection connection;
     protected final int schemaVersion;
     protected final Map<Class<? extends AbstractDao<?, ?>>, DaoConfig> daoConfigMap;
 
-    public AbstractDaoMaster(SQLiteDatabase db, int schemaVersion) {
-        this.db = db;
+    public AbstractDaoMaster(Connection connection, int schemaVersion) {
+        this.connection = connection;
         this.schemaVersion = schemaVersion;
 
         daoConfigMap = new HashMap<Class<? extends AbstractDao<?, ?>>, DaoConfig>();
     }
 
     protected void registerDaoClass(Class<? extends AbstractDao<?, ?>> daoClass) {
-        DaoConfig daoConfig = new DaoConfig(db, daoClass);
+        DaoConfig daoConfig = new DaoConfig(connection, daoClass);
         daoConfigMap.put(daoClass, daoConfig);
     }
 
@@ -50,8 +50,8 @@ public int getSchemaVersion() {
     }
 
     /** Gets the SQLiteDatabase for custom database access. Not needed for greenDAO entities. */
-    public SQLiteDatabase getDatabase() {
-        return db;
+    public Connection getConnection() {
+        return connection;
     }
 
     public abstract AbstractDaoSession newSession();
diff --git a/DaoCore/src/de/greenrobot/dao/AbstractDaoSession.java b/DaoCore/src/de/greenrobot/dao/AbstractDaoSession.java
index 6a37ef2a..19f19421 100644
--- a/DaoCore/src/de/greenrobot/dao/AbstractDaoSession.java
+++ b/DaoCore/src/de/greenrobot/dao/AbstractDaoSession.java
@@ -15,12 +15,13 @@
  */
 package de.greenrobot.dao;
 
+import java.sql.Connection;
+import java.sql.SQLException;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.Callable;
 
-import android.database.sqlite.SQLiteDatabase;
 import de.greenrobot.dao.async.AsyncSession;
 import de.greenrobot.dao.query.QueryBuilder;
 
@@ -44,11 +45,11 @@
  * 
  */
 public class AbstractDaoSession {
-    private final SQLiteDatabase db;
+    private final Connection connection;
     private final Map<Class<?>, AbstractDao<?, ?>> entityToDao;
 
-    public AbstractDaoSession(SQLiteDatabase db) {
-        this.db = db;
+    public AbstractDaoSession(Connection connection) {
+        this.connection = connection;
         this.entityToDao = new HashMap<Class<?>, AbstractDao<?, ?>>();
     }
 
@@ -56,64 +57,73 @@ public AbstractDaoSession(SQLiteDatabase db) {
         entityToDao.put(entityClass, dao);
     }
 
-    /** Convenient call for {@link AbstractDao#insert(Object)}. */
-    public <T> long insert(T entity) {
+    /** Convenient call for {@link AbstractDao#insert(Object)}. 
+     * @throws SQLException */
+    public <T> long insert(T entity) throws SQLException {
         @SuppressWarnings("unchecked")
         AbstractDao<T, ?> dao = (AbstractDao<T, ?>) getDao(entity.getClass());
         return dao.insert(entity);
     }
 
-    /** Convenient call for {@link AbstractDao#insertOrReplace(Object)}. */
-    public <T> long insertOrReplace(T entity) {
+    /** Convenient call for {@link AbstractDao#insertOrReplace(Object)}. 
+     * @throws SQLException */
+    public <T> long insertOrReplace(T entity) throws SQLException {
         @SuppressWarnings("unchecked")
         AbstractDao<T, ?> dao = (AbstractDao<T, ?>) getDao(entity.getClass());
         return dao.insertOrReplace(entity);
     }
 
-    /** Convenient call for {@link AbstractDao#refresh(Object)}. */
-    public <T> void refresh(T entity) {
+    /** Convenient call for {@link AbstractDao#refresh(Object)}. 
+     * @throws SQLException */
+    public <T> void refresh(T entity) throws SQLException {
         @SuppressWarnings("unchecked")
         AbstractDao<T, ?> dao = (AbstractDao<T, ?>) getDao(entity.getClass());
         dao.refresh(entity);
     }
 
-    /** Convenient call for {@link AbstractDao#update(Object)}. */
-    public <T> void update(T entity) {
+    /** Convenient call for {@link AbstractDao#update(Object)}. 
+     * @throws SQLException */
+    public <T> void update(T entity) throws SQLException {
         @SuppressWarnings("unchecked")
         AbstractDao<T, ?> dao = (AbstractDao<T, ?>) getDao(entity.getClass());
         dao.update(entity);
     }
 
-    /** Convenient call for {@link AbstractDao#delete(Object)}. */
-    public <T> void delete(T entity) {
+    /** Convenient call for {@link AbstractDao#delete(Object)}. 
+     * @throws SQLException */
+    public <T> void delete(T entity) throws SQLException {
         @SuppressWarnings("unchecked")
         AbstractDao<T, ?> dao = (AbstractDao<T, ?>) getDao(entity.getClass());
         dao.delete(entity);
     }
 
-    /** Convenient call for {@link AbstractDao#deleteAll()}. */
-    public <T> void deleteAll(Class<T> entityClass) {
+    /** Convenient call for {@link AbstractDao#deleteAll()}. 
+     * @throws SQLException */
+    public <T> void deleteAll(Class<T> entityClass) throws SQLException {
         @SuppressWarnings("unchecked")
         AbstractDao<T, ?> dao = (AbstractDao<T, ?>) getDao(entityClass);
         dao.deleteAll();
     }
 
-    /** Convenient call for {@link AbstractDao#load(Object)}. */
-    public <T, K> T load(Class<T> entityClass, K key) {
+    /** Convenient call for {@link AbstractDao#load(Object)}. 
+     * @throws SQLException */
+    public <T, K> T load(Class<T> entityClass, K key) throws SQLException {
         @SuppressWarnings("unchecked")
         AbstractDao<T, K> dao = (AbstractDao<T, K>) getDao(entityClass);
         return dao.load(key);
     }
 
-    /** Convenient call for {@link AbstractDao#loadAll()}. */
-    public <T, K> List<T> loadAll(Class<T> entityClass) {
+    /** Convenient call for {@link AbstractDao#loadAll()}. 
+     * @throws SQLException */
+    public <T, K> List<T> loadAll(Class<T> entityClass) throws SQLException {
         @SuppressWarnings("unchecked")
         AbstractDao<T, K> dao = (AbstractDao<T, K>) getDao(entityClass);
         return dao.loadAll();
     }
 
-    /** Convenient call for {@link AbstractDao#queryRaw(String, String...)}. */
-    public <T, K> List<T> queryRaw(Class<T> entityClass, String where, String... selectionArgs) {
+    /** Convenient call for {@link AbstractDao#queryRaw(String, String...)}. 
+     * @throws SQLException */
+    public <T, K> List<T> queryRaw(Class<T> entityClass, String where, String... selectionArgs) throws SQLException {
         @SuppressWarnings("unchecked")
         AbstractDao<T, K> dao = (AbstractDao<T, K>) getDao(entityClass);
         return dao.queryRaw(where, selectionArgs);
@@ -138,12 +148,13 @@ public AbstractDaoSession(SQLiteDatabase db) {
      * Run the given Runnable inside a database transaction. If you except a result, consider callInTx.
      */
     public void runInTx(Runnable runnable) {
-        db.beginTransaction();
+    	// TODO transaction
+//        connection.beginTransaction();
         try {
             runnable.run();
-            db.setTransactionSuccessful();
+//            connection.setTransactionSuccessful();
         } finally {
-            db.endTransaction();
+//            connection.endTransaction();
         }
     }
 
@@ -152,13 +163,14 @@ public void runInTx(Runnable runnable) {
      * except a result, consider runInTx.
      */
     public <V> V callInTx(Callable<V> callable) throws Exception {
-        db.beginTransaction();
+// TODO transaction
+//    	connection.beginTransaction();
         try {
             V result = callable.call();
-            db.setTransactionSuccessful();
+//            connection.setTransactionSuccessful();
             return result;
         } finally {
-            db.endTransaction();
+//            connection.endTransaction();
         }
     }
 
@@ -167,7 +179,8 @@ public void runInTx(Runnable runnable) {
      * DaoException).
      */
     public <V> V callInTxNoException(Callable<V> callable) {
-        db.beginTransaction();
+// TODO transaction
+//    	connection.beginTransaction();
         try {
             V result;
             try {
@@ -175,16 +188,16 @@ public void runInTx(Runnable runnable) {
             } catch (Exception e) {
                 throw new DaoException("Callable failed", e);
             }
-            db.setTransactionSuccessful();
+//            connection.setTransactionSuccessful();
             return result;
         } finally {
-            db.endTransaction();
+//            connection.endTransaction();
         }
     }
 
     /** Gets the SQLiteDatabase for custom database access. Not needed for greenDAO entities. */
-    public SQLiteDatabase getDatabase() {
-        return db;
+    public Connection getConnection() {
+        return connection;
     }
 
     /**
diff --git a/DaoCore/src/de/greenrobot/dao/DbUtils.java b/DaoCore/src/de/greenrobot/dao/DbUtils.java
index 62e5c976..126a3358 100644
--- a/DaoCore/src/de/greenrobot/dao/DbUtils.java
+++ b/DaoCore/src/de/greenrobot/dao/DbUtils.java
@@ -20,10 +20,9 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
+import java.sql.Connection;
 
 import android.content.Context;
-import android.database.Cursor;
-import android.database.DatabaseUtils;
 import android.database.sqlite.SQLiteDatabase;
 
 /** Database utils, for example to execute SQL scripts */
@@ -123,14 +122,15 @@ public static int copyAllBytes(InputStream in, OutputStream out) throws IOExcept
         }
     }
 
-    public static void logTableDump(SQLiteDatabase db, String tablename) {
-        Cursor cursor = db.query(tablename, null, null, null, null, null, null);
-        try {
-            String dump = DatabaseUtils.dumpCursorToString(cursor);
-            DaoLog.d(dump);
-        } finally {
-            cursor.close();
-        }
+    public static void logTableDump(Connection connection, String tablename) {
+// FIXME need to JDBCfy this...
+//        Cursor cursor = connection.query(tablename, null, null, null, null, null, null);
+//        try {
+//            String dump = DatabaseUtils.dumpCursorToString(cursor);
+//            DaoLog.d(dump);
+//        } finally {
+//            cursor.close();
+//        }
     }
 
 }
diff --git a/DaoCore/src/de/greenrobot/dao/InternalQueryDaoAccess.java b/DaoCore/src/de/greenrobot/dao/InternalQueryDaoAccess.java
index d1896079..07582930 100644
--- a/DaoCore/src/de/greenrobot/dao/InternalQueryDaoAccess.java
+++ b/DaoCore/src/de/greenrobot/dao/InternalQueryDaoAccess.java
@@ -1,8 +1,9 @@
 package de.greenrobot.dao;
 
+import java.sql.ResultSet;
+import java.sql.SQLException;
 import java.util.List;
 
-import android.database.Cursor;
 import de.greenrobot.dao.internal.TableStatements;
 
 /** For internal use by greenDAO only. */
@@ -13,16 +14,16 @@ public InternalQueryDaoAccess(AbstractDao<T, ?> abstractDao) {
         dao = abstractDao;
     }
 
-    public T loadCurrent(Cursor cursor, int offset, boolean lock) {
-        return dao.loadCurrent(cursor, offset, lock);
+    public T loadCurrent(ResultSet resultSet, int offset, boolean lock) throws SQLException {
+        return dao.loadCurrent(resultSet, offset, lock);
     }
 
-    public List<T> loadAllAndCloseCursor(Cursor cursor) {
-        return dao.loadAllAndCloseCursor(cursor);
+    public List<T> loadAllAndCloseCursor(ResultSet resultSet) throws SQLException {
+        return dao.loadAllAndCloseCursor(resultSet);
     }
 
-    public T loadUniqueAndCloseCursor(Cursor cursor) {
-        return dao.loadUniqueAndCloseCursor(cursor);
+    public T loadUniqueAndCloseCursor(ResultSet resultSet) throws SQLException {
+        return dao.loadUniqueAndCloseCursor(resultSet);
     }
 
     public TableStatements getStatements() {
diff --git a/DaoCore/src/de/greenrobot/dao/InternalUnitTestDaoAccess.java b/DaoCore/src/de/greenrobot/dao/InternalUnitTestDaoAccess.java
index 78df9030..abbc018d 100644
--- a/DaoCore/src/de/greenrobot/dao/InternalUnitTestDaoAccess.java
+++ b/DaoCore/src/de/greenrobot/dao/InternalUnitTestDaoAccess.java
@@ -17,9 +17,9 @@
 package de.greenrobot.dao;
 
 import java.lang.reflect.Constructor;
+import java.sql.Connection;
+import java.sql.ResultSet;
 
-import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
 import de.greenrobot.dao.identityscope.IdentityScope;
 import de.greenrobot.dao.internal.DaoConfig;
 
@@ -27,9 +27,9 @@
 public class InternalUnitTestDaoAccess<T, K> {
     private final AbstractDao<T, K> dao;
 
-    public InternalUnitTestDaoAccess(SQLiteDatabase db, Class<AbstractDao<T, K>> daoClass, IdentityScope<?, ?> identityScope)
+    public InternalUnitTestDaoAccess(Connection connection, Class<AbstractDao<T, K>> daoClass, IdentityScope<?, ?> identityScope)
             throws Exception {
-        DaoConfig daoConfig = new DaoConfig(db, daoClass);
+        DaoConfig daoConfig = new DaoConfig(connection, daoClass);
         daoConfig.setIdentityScope(identityScope);
         Constructor<AbstractDao<T, K>> constructor = daoClass.getConstructor(DaoConfig.class);
         dao = constructor.newInstance(daoConfig);
@@ -47,12 +47,12 @@ public boolean isEntityUpdateable() {
         return dao.isEntityUpdateable();
     }
 
-    public T readEntity(Cursor cursor, int offset) {
-        return dao.readEntity(cursor, offset);
+    public T readEntity(ResultSet resultSet, int offset) {
+        return dao.readEntity(resultSet, offset);
     }
 
-    public K readKey(Cursor cursor, int offset) {
-        return dao.readKey(cursor, offset);
+    public K readKey(ResultSet resultSet, int offset) {
+        return dao.readKey(resultSet, offset);
     }
 
     public AbstractDao<T, K> getDao() {
diff --git a/DaoCore/src/de/greenrobot/dao/async/AsyncOperation.java b/DaoCore/src/de/greenrobot/dao/async/AsyncOperation.java
index 7f1b1c02..af4c1708 100644
--- a/DaoCore/src/de/greenrobot/dao/async/AsyncOperation.java
+++ b/DaoCore/src/de/greenrobot/dao/async/AsyncOperation.java
@@ -16,7 +16,8 @@
 
 package de.greenrobot.dao.async;
 
-import android.database.sqlite.SQLiteDatabase;
+import java.sql.Connection;
+
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.DaoException;
 
@@ -48,7 +49,7 @@
 
     final OperationType type;
     final AbstractDao<Object, Object> dao;
-    private final SQLiteDatabase database;
+    private final Connection connection;
     /** Entity, Iterable<Entity>, Entity[], or Runnable. */
     final Object parameter;
     final int flags;
@@ -67,13 +68,13 @@
         this.type = type;
         this.flags = flags;
         this.dao = (AbstractDao<Object, Object>) dao;
-        this.database = null;
+        this.connection = null;
         this.parameter = parameter;
     }
 
-    AsyncOperation(OperationType type, SQLiteDatabase database, Object parameter, int flags) {
+    AsyncOperation(OperationType type, Connection connection, Object parameter, int flags) {
         this.type = type;
-        this.database = database;
+        this.connection = connection;
         this.flags = flags;
         this.dao = null;
         this.parameter = parameter;
@@ -117,8 +118,8 @@ public boolean isMergeTx() {
         return (flags & FLAG_MERGE_TX) != 0;
     }
 
-    SQLiteDatabase getDatabase() {
-        return database != null ? database : dao.getDatabase();
+    Connection getConnection() {
+        return connection != null ? connection : dao.getConnection();
     }
 
     /**
@@ -126,7 +127,7 @@ SQLiteDatabase getDatabase() {
      *         and if the database instances match.
      */
     boolean isMergeableWith(AsyncOperation other) {
-        return other != null && isMergeTx() && other.isMergeTx() && getDatabase() == other.getDatabase();
+        return other != null && isMergeTx() && other.isMergeTx() && getConnection() == other.getConnection();
     }
 
     public long getTimeStarted() {
diff --git a/DaoCore/src/de/greenrobot/dao/async/AsyncOperationExecutor.java b/DaoCore/src/de/greenrobot/dao/async/AsyncOperationExecutor.java
index b63ec1b4..e0fbc794 100644
--- a/DaoCore/src/de/greenrobot/dao/async/AsyncOperationExecutor.java
+++ b/DaoCore/src/de/greenrobot/dao/async/AsyncOperationExecutor.java
@@ -23,7 +23,6 @@
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.TimeUnit;
 
-import android.database.sqlite.SQLiteDatabase;
 import android.os.Handler;
 import android.os.Looper;
 import android.os.Message;
@@ -178,8 +177,9 @@ private void mergeTxAndExecute(AsyncOperation operation1, AsyncOperation operati
         mergedOps.add(operation1);
         mergedOps.add(operation2);
 
-        SQLiteDatabase db = operation1.getDatabase();
-        db.beginTransaction();
+// TODO transaction
+//        Connection connection = operation1.getConnection();
+//        connection.beginTransaction();
         boolean failed = false;
         try {
             for (int i = 0; i < mergedOps.size(); i++) {
@@ -201,12 +201,12 @@ private void mergeTxAndExecute(AsyncOperation operation1, AsyncOperation operati
                         mergedOps.add(removedOp);
                     } else {
                         // No more ops in the queue to merge, finish it
-                        db.setTransactionSuccessful();
+//                        connection.setTransactionSuccessful();
                     }
                 }
             }
         } finally {
-            db.endTransaction();
+//            connection.endTransaction();
         }
         if (failed) {
             DaoLog.i("Revered merged transaction because one of the operations failed. Executing operations one by one instead...");
@@ -332,25 +332,27 @@ private void executeOperation(AsyncOperation operation) {
     }
 
     private void executeTransactionRunnable(AsyncOperation operation) {
-        SQLiteDatabase db = operation.getDatabase();
-        db.beginTransaction();
+// TODO transaction
+//    	Connection connection = operation.getConnection();
+//      connection.beginTransaction();
         try {
             ((Runnable) operation.parameter).run();
-            db.setTransactionSuccessful();
+//            connection.setTransactionSuccessful();
         } finally {
-            db.endTransaction();
+//            connection.endTransaction();
         }
     }
 
     @SuppressWarnings("unchecked")
     private void executeTransactionCallable(AsyncOperation operation) throws Exception {
-        SQLiteDatabase db = operation.getDatabase();
-        db.beginTransaction();
+// TODO transaction
+//        Connection connection = operation.getConnection();
+//        connection.beginTransaction();
         try {
             operation.result = ((Callable<Object>) operation.parameter).call();
-            db.setTransactionSuccessful();
+//            connection.setTransactionSuccessful();
         } finally {
-            db.endTransaction();
+//            connection.endTransaction();
         }
     }
 
diff --git a/DaoCore/src/de/greenrobot/dao/async/AsyncSession.java b/DaoCore/src/de/greenrobot/dao/async/AsyncSession.java
index f606a7a6..6c9ebfe6 100644
--- a/DaoCore/src/de/greenrobot/dao/async/AsyncSession.java
+++ b/DaoCore/src/de/greenrobot/dao/async/AsyncSession.java
@@ -303,7 +303,7 @@ public AsyncOperation refresh(Object entity, int flags) {
     }
 
     private AsyncOperation enqueueDatabaseOperation(OperationType type, Object param, int flags) {
-        AsyncOperation operation = new AsyncOperation(type, daoSession.getDatabase(), param, flags);
+        AsyncOperation operation = new AsyncOperation(type, daoSession.getConnection(), param, flags);
         executor.enqueue(operation);
         return operation;
     }
diff --git a/DaoCore/src/de/greenrobot/dao/internal/DaoConfig.java b/DaoCore/src/de/greenrobot/dao/internal/DaoConfig.java
index 96473029..ce5cd101 100644
--- a/DaoCore/src/de/greenrobot/dao/internal/DaoConfig.java
+++ b/DaoCore/src/de/greenrobot/dao/internal/DaoConfig.java
@@ -17,10 +17,10 @@
 
 import java.lang.reflect.Field;
 import java.lang.reflect.Modifier;
+import java.sql.Connection;
 import java.util.ArrayList;
 import java.util.List;
 
-import android.database.sqlite.SQLiteDatabase;
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.DaoException;
 import de.greenrobot.dao.Property;
@@ -35,7 +35,7 @@
  */
 public final class DaoConfig implements Cloneable {
 
-    public final SQLiteDatabase db;
+    public final Connection connection;
     public final String tablename;
     public final Property[] properties;
 
@@ -50,8 +50,8 @@
 
     private IdentityScope<?, ?> identityScope;
 
-    public DaoConfig(SQLiteDatabase db, Class<? extends AbstractDao<?, ?>> daoClass) {
-        this.db = db;
+    public DaoConfig(Connection connection, Class<? extends AbstractDao<?, ?>> daoClass) {
+        this.connection = connection;
         try {
             this.tablename = (String) daoClass.getField("TABLENAME").get(null);
             Property[] properties = reflectProperties(daoClass);
@@ -79,7 +79,7 @@ public DaoConfig(SQLiteDatabase db, Class<? extends AbstractDao<?, ?>> daoClass)
             pkColumns = pkColumnList.toArray(pkColumnsArray);
 
             pkProperty = pkColumns.length == 1 ? lastPkProperty : null;
-            statements = new TableStatements(db, tablename, allColumns, pkColumns);
+            statements = new TableStatements(connection, tablename, allColumns, pkColumns);
 
             if (pkProperty != null) {
                 Class<?> type = pkProperty.type;
@@ -124,7 +124,7 @@ public DaoConfig(SQLiteDatabase db, Class<? extends AbstractDao<?, ?>> daoClass)
 
     /** Does not copy identity scope. */
     public DaoConfig(DaoConfig source) {
-        db = source.db;
+        connection = source.connection;
         tablename = source.tablename;
         properties = source.properties;
         allColumns = source.allColumns;
diff --git a/DaoCore/src/de/greenrobot/dao/internal/TableStatements.java b/DaoCore/src/de/greenrobot/dao/internal/TableStatements.java
index 9414f1f7..659b94a8 100644
--- a/DaoCore/src/de/greenrobot/dao/internal/TableStatements.java
+++ b/DaoCore/src/de/greenrobot/dao/internal/TableStatements.java
@@ -15,61 +15,62 @@
  */
 package de.greenrobot.dao.internal;
 
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteStatement;
+import java.sql.Connection;
+import java.sql.PreparedStatement;
+import java.sql.SQLException;
 
 /** Helper class to create SQL statements for specific tables (used by greenDAO internally). */
 public class TableStatements {
-    private final SQLiteDatabase db;
+    private final Connection connection;
     private final String tablename;
     private final String[] allColumns;
     private final String[] pkColumns;
 
-    private SQLiteStatement insertStatement;
-    private SQLiteStatement insertOrReplaceStatement;
-    private SQLiteStatement updateStatement;
-    private SQLiteStatement deleteStatement;
+    private PreparedStatement insertStatement;
+    private PreparedStatement insertOrReplaceStatement;
+    private PreparedStatement updateStatement;
+    private PreparedStatement deleteStatement;
 
     private volatile String selectAll;
     private volatile String selectByKey;
     private volatile String selectByRowId;
     private volatile String selectKeys;
 
-    public TableStatements(SQLiteDatabase db, String tablename, String[] allColumns, String[] pkColumns) {
-        this.db = db;
+    public TableStatements(Connection connection, String tablename, String[] allColumns, String[] pkColumns) {
+        this.connection = connection;
         this.tablename = tablename;
         this.allColumns = allColumns;
         this.pkColumns = pkColumns;
     }
 
-    public SQLiteStatement getInsertStatement() {
+    public PreparedStatement getInsertStatement() throws SQLException {
         if (insertStatement == null) {
             String sql = SqlUtils.createSqlInsert("INSERT INTO ", tablename, allColumns);
-            insertStatement = db.compileStatement(sql);
+            insertStatement = connection.prepareStatement( sql );
         }
         return insertStatement;
     }
 
-    public SQLiteStatement getInsertOrReplaceStatement() {
+    public PreparedStatement getInsertOrReplaceStatement() throws SQLException {
         if (insertOrReplaceStatement == null) {
             String sql = SqlUtils.createSqlInsert("INSERT OR REPLACE INTO ", tablename, allColumns);
-            insertOrReplaceStatement = db.compileStatement(sql);
+            insertOrReplaceStatement = connection.prepareStatement(sql);
         }
         return insertOrReplaceStatement;
     }
 
-    public SQLiteStatement getDeleteStatement() {
+    public PreparedStatement getDeleteStatement() throws SQLException {
         if (deleteStatement == null) {
             String sql = SqlUtils.createSqlDelete(tablename, pkColumns);
-            deleteStatement = db.compileStatement(sql);
+            deleteStatement = connection.prepareStatement(sql);
         }
         return deleteStatement;
     }
 
-    public SQLiteStatement getUpdateStatement() {
+    public PreparedStatement getUpdateStatement() throws SQLException {
         if (updateStatement == null) {
             String sql = SqlUtils.createSqlUpdate(tablename, allColumns, pkColumns);
-            updateStatement = db.compileStatement(sql);
+            updateStatement = connection.prepareStatement(sql);
         }
         return updateStatement;
     }
diff --git a/DaoCore/src/de/greenrobot/dao/query/CountQuery.java b/DaoCore/src/de/greenrobot/dao/query/CountQuery.java
index effc537b..96df16db 100644
--- a/DaoCore/src/de/greenrobot/dao/query/CountQuery.java
+++ b/DaoCore/src/de/greenrobot/dao/query/CountQuery.java
@@ -1,6 +1,10 @@
 package de.greenrobot.dao.query;
 
-import android.database.Cursor;
+import java.sql.Connection;
+import java.sql.PreparedStatement;
+import java.sql.ResultSet;
+import java.sql.SQLException;
+
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.DaoException;
 
@@ -34,17 +38,24 @@ private CountQuery(QueryData<T> queryData, AbstractDao<T, ?> dao, String sql, St
         return queryData.forCurrentThread(this);
     }
 
-    /** Returns the count (number of results matching the query). Uses SELECT COUNT (*) sematics. */
-    public long count() {
+    /** Returns the count (number of results matching the query). Uses SELECT COUNT (*) sematics. 
+     * @throws SQLException */
+    public long count() throws SQLException {
         checkThread();
-        Cursor cursor = dao.getDatabase().rawQuery(sql, parameters);
+        Connection connection = dao.getConnection();
+        PreparedStatement statement = connection.prepareStatement( sql );
+        for ( int i = 0; i < parameters.length; i++ )
+		{
+			statement.setString( i, parameters[i] );
+		}
+		ResultSet cursor = statement.executeQuery();
         try {
-            if (!cursor.moveToNext()) {
+            if (!cursor.next()) {
                 throw new DaoException("No result for count");
             } else if (!cursor.isLast()) {
-                throw new DaoException("Unexpected row count: " + cursor.getCount());
-            } else if (cursor.getColumnCount() != 1) {
-                throw new DaoException("Unexpected column count: " + cursor.getColumnCount());
+                throw new DaoException("Unexpected row count: " + cursor.getFetchSize());
+            } else if (cursor.getFetchSize() != 1) {
+                throw new DaoException("Unexpected column count: " + cursor.getMetaData().getColumnCount());
             }
             return cursor.getLong(0);
         } finally {
diff --git a/DaoCore/src/de/greenrobot/dao/query/DeleteQuery.java b/DaoCore/src/de/greenrobot/dao/query/DeleteQuery.java
index 983e3720..3dec1363 100644
--- a/DaoCore/src/de/greenrobot/dao/query/DeleteQuery.java
+++ b/DaoCore/src/de/greenrobot/dao/query/DeleteQuery.java
@@ -15,7 +15,10 @@
  */
 package de.greenrobot.dao.query;
 
-import android.database.sqlite.SQLiteDatabase;
+import java.sql.Connection;
+import java.sql.PreparedStatement;
+import java.sql.SQLException;
+
 import de.greenrobot.dao.AbstractDao;
 
 /**
@@ -60,21 +63,35 @@ private DeleteQuery(QueryData<T> queryData, AbstractDao<T, ?> dao, String sql, S
      * Deletes all matching entities without detaching them from the identity scope (aka session/cache). Note that this
      * method may lead to stale entity objects in the session cache. Stale entities may be returned when loaded by their
      * primary key, but not using queries.
+     * @throws SQLException 
      */
-    public void executeDeleteWithoutDetachingEntities() {
+    public void executeDeleteWithoutDetachingEntities() throws SQLException {
         checkThread();
-        SQLiteDatabase db = dao.getDatabase();
-        if (db.isDbLockedByCurrentThread()) {
-            dao.getDatabase().execSQL(sql, parameters);
+        Connection connection = dao.getConnection();
+// FIXME not sure what to do here...
+//        if (connection.isDbLockedByCurrentThread()) {
+        if (!connection.isClosed()) {
+        	PreparedStatement statement = connection.prepareStatement( sql );
+        	for ( int i = 0; i < parameters.length; i++ )
+			{
+				statement.setString( i, parameters[i] );
+			}
+            statement.executeUpdate();
         } else {
             // Do TX to acquire a connection before locking this to avoid deadlocks
             // Locking order as described in AbstractDao
-            db.beginTransaction();
+// TODO transaction (it might need to open a new connection too)
+//        	connection.beginTransaction();
             try {
-                dao.getDatabase().execSQL(sql, parameters);
-                db.setTransactionSuccessful();
+            	PreparedStatement statement = connection.prepareStatement( sql );
+            	for ( int i = 0; i < parameters.length; i++ )
+    			{
+    				statement.setString( i, parameters[i] );
+    			}
+                statement.executeUpdate();
+//                connection.setTransactionSuccessful();
             } finally {
-                db.endTransaction();
+//                connection.endTransaction();
             }
         }
     }
diff --git a/DaoCore/src/de/greenrobot/dao/query/LazyList.java b/DaoCore/src/de/greenrobot/dao/query/LazyList.java
index 9bf12337..38ecfc31 100644
--- a/DaoCore/src/de/greenrobot/dao/query/LazyList.java
+++ b/DaoCore/src/de/greenrobot/dao/query/LazyList.java
@@ -16,6 +16,8 @@
 package de.greenrobot.dao.query;
 
 import java.io.Closeable;
+import java.sql.ResultSet;
+import java.sql.SQLException;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Iterator;
@@ -24,7 +26,6 @@
 import java.util.NoSuchElementException;
 import java.util.concurrent.locks.ReentrantLock;
 
-import android.database.Cursor;
 import de.greenrobot.dao.DaoException;
 import de.greenrobot.dao.InternalQueryDaoAccess;
 
@@ -123,16 +124,16 @@ public void close() {
     }
 
     private final InternalQueryDaoAccess<E> daoAccess;
-    private final Cursor cursor;
+    private final ResultSet resultSet;
     private final List<E> entities;
     private final int size;
     private final ReentrantLock lock;
     private volatile int loadedCount;
 
-    LazyList(InternalQueryDaoAccess<E> daoAccess, Cursor cursor, boolean cacheEntities) {
-        this.cursor = cursor;
+    LazyList(InternalQueryDaoAccess<E> daoAccess, ResultSet resultSet, boolean cacheEntities) throws SQLException {
+        this.resultSet = resultSet;
         this.daoAccess = daoAccess;
-        size = cursor.getCount();
+        size = resultSet.getFetchSize();
         if (cacheEntities) {
             entities = new ArrayList<E>(size);
             for (int i = 0; i < size; i++) {
@@ -142,7 +143,7 @@ public void close() {
             entities = null;
         }
         if (size == 0) {
-            cursor.close();
+            resultSet.close();
         }
 
         lock = new ReentrantLock();
@@ -175,11 +176,19 @@ public E peak(int location) {
     @Override
     /** Closes the underlying cursor: do not try to get entities not loaded (using get) before. */
     public void close() {
-        cursor.close();
+        try
+		{
+			resultSet.close();
+		}
+		catch ( SQLException e )
+		{
+			e.printStackTrace();
+		}
     }
 
     public boolean isClosed() {
-        return cursor.isClosed();
+//        return resultSet.isClosed();
+    	return false; // result set is always open
     }
 
     public int getLoadedCount() {
@@ -241,22 +250,34 @@ public E get(int location) {
                         // Ignore FindBugs: increment of volatile is fine here because we use a lock
                         loadedCount++;
                         if (loadedCount == size) {
-                            cursor.close();
+                            resultSet.close();
                         }
                     }
-                } finally {
+                }
+				catch ( SQLException e )
+				{
+					e.printStackTrace();
+				} finally {
                     lock.unlock();
                 }
             }
             return entity;
         } else {
-            return loadEntity(location);
+            try
+			{
+				return loadEntity(location);
+			}
+			catch ( SQLException e )
+			{
+				e.printStackTrace();
+				return null;
+			}
         }
     }
 
-    protected E loadEntity(int location) {
-        cursor.moveToPosition(location);
-        E entity = daoAccess.loadCurrent(cursor, 0, true);
+    protected E loadEntity(int location) throws SQLException {
+        resultSet.absolute(location);
+        E entity = daoAccess.loadCurrent(resultSet, 0, true);
         if (entity == null) {
             throw new DaoException("Loading of entity failed (null) at position " + location);
         }
diff --git a/DaoCore/src/de/greenrobot/dao/query/Query.java b/DaoCore/src/de/greenrobot/dao/query/Query.java
index 4d36b1b0..03aa7e08 100644
--- a/DaoCore/src/de/greenrobot/dao/query/Query.java
+++ b/DaoCore/src/de/greenrobot/dao/query/Query.java
@@ -15,10 +15,12 @@
  */
 package de.greenrobot.dao.query;
 
+import java.sql.Connection;
+import java.sql.PreparedStatement;
+import java.sql.ResultSet;
+import java.sql.SQLException;
 import java.util.List;
 
-import android.database.Cursor;
-import android.os.Process;
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.DaoException;
 
@@ -114,39 +116,61 @@ public void setOffset(int offset) {
         parameters[offsetPosition] = Integer.toString(offset);
     }
 
-    /** Executes the query and returns the result as a list containing all entities loaded into memory. */
-    public List<T> list() {
+    /** Executes the query and returns the result as a list containing all entities loaded into memory. 
+     * @throws SQLException */
+    public List<T> list() throws SQLException {
         checkThread();
-        Cursor cursor = dao.getDatabase().rawQuery(sql, parameters);
-        return daoAccess.loadAllAndCloseCursor(cursor);
+        Connection connection = dao.getConnection();
+        PreparedStatement statement = connection.prepareStatement( sql );
+        for ( int i = 0; i < parameters.length; i++ )
+		{
+			statement.setString( i, parameters[i] );
+		}
+        ResultSet resultSet = statement.executeQuery();
+        return daoAccess.loadAllAndCloseCursor(resultSet);
     }
 
     /**
      * Executes the query and returns the result as a list that lazy loads the entities on first access. Entities are
      * cached, so accessing the same entity more than once will not result in loading an entity from the underlying
      * cursor again.Make sure to close it to close the underlying cursor.
+     * @throws SQLException 
      */
-    public LazyList<T> listLazy() {
+    public LazyList<T> listLazy() throws SQLException {
         checkThread();
-        Cursor cursor = dao.getDatabase().rawQuery(sql, parameters);
-        return new LazyList<T>(daoAccess, cursor, true);
+        Connection connection = dao.getConnection();
+        PreparedStatement statement = connection.prepareStatement( sql );
+        for ( int i = 0; i < parameters.length; i++ )
+		{
+			statement.setString( i, parameters[i] );
+		}
+        ResultSet resultSet = statement.executeQuery();
+        return new LazyList<T>(daoAccess, resultSet, true);
     }
 
     /**
      * Executes the query and returns the result as a list that lazy loads the entities on every access (uncached). Make
      * sure to close the list to close the underlying cursor.
+     * @throws SQLException 
      */
-    public LazyList<T> listLazyUncached() {
+    public LazyList<T> listLazyUncached() throws SQLException {
         checkThread();
-        Cursor cursor = dao.getDatabase().rawQuery(sql, parameters);
-        return new LazyList<T>(daoAccess, cursor, false);
+        Connection connection = dao.getConnection();
+        PreparedStatement statement = connection.prepareStatement( sql );
+        for ( int i = 0; i < parameters.length; i++ )
+		{
+			statement.setString( i, parameters[i] );
+		}
+        ResultSet resultSet = statement.executeQuery();
+        return new LazyList<T>(daoAccess, resultSet, false);
     }
 
     /**
      * Executes the query and returns the result as a list iterator; make sure to close it to close the underlying
      * cursor. The cursor is closed once the iterator is fully iterated through.
+     * @throws SQLException 
      */
-    public CloseableListIterator<T> listIterator() {
+    public CloseableListIterator<T> listIterator() throws SQLException {
         return listLazyUncached().listIteratorAutoClose();
     }
 
@@ -156,11 +180,18 @@ public void setOffset(int offset) {
      * @throws DaoException
      *             if the result is not unique
      * @return Entity or null if no matching entity was found
+     * @throws SQLException 
      */
-    public T unique() {
+    public T unique() throws SQLException {
         checkThread();
-        Cursor cursor = dao.getDatabase().rawQuery(sql, parameters);
-        return daoAccess.loadUniqueAndCloseCursor(cursor);
+        Connection connection = dao.getConnection();
+        PreparedStatement statement = connection.prepareStatement( sql );
+        for ( int i = 0; i < parameters.length; i++ )
+		{
+			statement.setString( i, parameters[i] );
+		}
+        ResultSet resultSet = statement.executeQuery();
+        return daoAccess.loadUniqueAndCloseCursor(resultSet);
     }
 
     /**
@@ -169,8 +200,9 @@ public T unique() {
      * @throws DaoException
      *             if the result is not unique or no entity was found
      * @return Entity
+     * @throws SQLException 
      */
-    public T uniqueOrThrow() {
+    public T uniqueOrThrow() throws SQLException {
         T entity = unique();
         if (entity == null) {
             throw new DaoException("No entity found for query");
diff --git a/DaoCore/src/de/greenrobot/dao/query/QueryBuilder.java b/DaoCore/src/de/greenrobot/dao/query/QueryBuilder.java
index fdd58004..3bd4a659 100644
--- a/DaoCore/src/de/greenrobot/dao/query/QueryBuilder.java
+++ b/DaoCore/src/de/greenrobot/dao/query/QueryBuilder.java
@@ -15,6 +15,7 @@
  */
 package de.greenrobot.dao.query;
 
+import java.sql.SQLException;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.ListIterator;
@@ -369,8 +370,9 @@ private void appendWhereClause(StringBuilder builder, String tablePrefixOrNull)
      * Shorthand for {@link QueryBuilder#build() build()}.{@link Query#list() list()}; see {@link Query#list()} for
      * details. To execute a query more than once, you should build the query and keep the {@link Query} object for
      * efficiency reasons.
+     * @throws SQLException 
      */
-    public List<T> list() {
+    public List<T> list() throws SQLException {
         return build().list();
     }
 
@@ -378,8 +380,9 @@ private void appendWhereClause(StringBuilder builder, String tablePrefixOrNull)
      * Shorthand for {@link QueryBuilder#build() build()}.{@link Query#listLazy() listLazy()}; see
      * {@link Query#listLazy()} for details. To execute a query more than once, you should build the query and keep the
      * {@link Query} object for efficiency reasons.
+     * @throws SQLException 
      */
-    public LazyList<T> listLazy() {
+    public LazyList<T> listLazy() throws SQLException {
         return build().listLazy();
     }
 
@@ -387,8 +390,9 @@ private void appendWhereClause(StringBuilder builder, String tablePrefixOrNull)
      * Shorthand for {@link QueryBuilder#build() build()}.{@link Query#listLazyUncached() listLazyUncached()}; see
      * {@link Query#listLazyUncached()} for details. To execute a query more than once, you should build the query and
      * keep the {@link Query} object for efficiency reasons.
+     * @throws SQLException 
      */
-    public LazyList<T> listLazyUncached() {
+    public LazyList<T> listLazyUncached() throws SQLException {
         return build().listLazyUncached();
     }
 
@@ -396,8 +400,9 @@ private void appendWhereClause(StringBuilder builder, String tablePrefixOrNull)
      * Shorthand for {@link QueryBuilder#build() build()}.{@link Query#listIterator() listIterator()}; see
      * {@link Query#listIterator()} for details. To execute a query more than once, you should build the query and keep
      * the {@link Query} object for efficiency reasons.
+     * @throws SQLException 
      */
-    public CloseableListIterator<T> listIterator() {
+    public CloseableListIterator<T> listIterator() throws SQLException {
         return build().listIterator();
     }
 
@@ -405,8 +410,9 @@ private void appendWhereClause(StringBuilder builder, String tablePrefixOrNull)
      * Shorthand for {@link QueryBuilder#build() build()}.{@link Query#unique() unique()}; see {@link Query#unique()}
      * for details. To execute a query more than once, you should build the query and keep the {@link Query} object for
      * efficiency reasons.
+     * @throws SQLException 
      */
-    public T unique() {
+    public T unique() throws SQLException {
         return build().unique();
     }
 
@@ -414,8 +420,9 @@ public T unique() {
      * Shorthand for {@link QueryBuilder#build() build()}.{@link Query#uniqueOrThrow() uniqueOrThrow()}; see
      * {@link Query#uniqueOrThrow()} for details. To execute a query more than once, you should build the query and keep
      * the {@link Query} object for efficiency reasons.
+     * @throws SQLException 
      */
-    public T uniqueOrThrow() {
+    public T uniqueOrThrow() throws SQLException {
         return build().uniqueOrThrow();
     }
 
@@ -423,8 +430,9 @@ public T uniqueOrThrow() {
      * Shorthand for {@link QueryBuilder#buildCount() buildCount()}.{@link CountQuery#count() count()}; see
      * {@link CountQuery#count()} for details. To execute a query more than once, you should build the query and keep
      * the {@link CountQuery} object for efficiency reasons.
+     * @throws SQLException 
      */
-    public long count() {
+    public long count() throws SQLException {
         return buildCount().count();
     }
 
diff --git a/DaoCore/src/de/greenrobot/dao/test/AbstractDaoSessionTest.java b/DaoCore/src/de/greenrobot/dao/test/AbstractDaoSessionTest.java
index aa94a156..f647710d 100644
--- a/DaoCore/src/de/greenrobot/dao/test/AbstractDaoSessionTest.java
+++ b/DaoCore/src/de/greenrobot/dao/test/AbstractDaoSessionTest.java
@@ -18,6 +18,7 @@
 
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Method;
+import java.sql.Connection;
 
 import android.database.sqlite.SQLiteDatabase;
 import de.greenrobot.dao.AbstractDaoMaster;
@@ -52,11 +53,11 @@ public AbstractDaoSessionTest(Class<T> daoMasterClass, boolean inMemory) {
     protected void setUp() throws Exception {
         super.setUp();
         try {
-            Constructor<T> constructor = daoMasterClass.getConstructor(SQLiteDatabase.class);
-            daoMaster = constructor.newInstance(db);
+            Constructor<T> constructor = daoMasterClass.getConstructor(Connection.class);
+            daoMaster = constructor.newInstance(connection);
 
             Method createTableMethod = daoMasterClass.getMethod("createAllTables", SQLiteDatabase.class, boolean.class);
-            createTableMethod.invoke(null, db, false);
+            createTableMethod.invoke(null, connection, false);
         } catch (Exception e) {
             throw new RuntimeException("Could not prepare DAO session test", e);
         }
diff --git a/DaoCore/src/de/greenrobot/dao/test/AbstractDaoTest.java b/DaoCore/src/de/greenrobot/dao/test/AbstractDaoTest.java
index 6c301da7..3e49d86e 100644
--- a/DaoCore/src/de/greenrobot/dao/test/AbstractDaoTest.java
+++ b/DaoCore/src/de/greenrobot/dao/test/AbstractDaoTest.java
@@ -64,7 +64,7 @@ protected void setUp() throws Exception {
         super.setUp();
         try {
             setUpTableForDao();
-            daoAccess = new InternalUnitTestDaoAccess<T, K>(db, (Class<AbstractDao<T, K>>) daoClass, identityScopeForDao);
+            daoAccess = new InternalUnitTestDaoAccess<T, K>(connection, (Class<AbstractDao<T, K>>) daoClass, identityScopeForDao);
             dao = (D) daoAccess.getDao();
         } catch (Exception e) {
             throw new RuntimeException("Could not prepare DAO Test", e);
@@ -74,7 +74,7 @@ protected void setUp() throws Exception {
     protected void setUpTableForDao() throws Exception {
         try {
             Method createTableMethod = daoClass.getMethod("createTable", SQLiteDatabase.class, boolean.class);
-            createTableMethod.invoke(null, db, false);
+            createTableMethod.invoke(null, connection, false);
         } catch (NoSuchMethodException e) {
             DaoLog.i("No createTable method");
         }
diff --git a/DaoCore/src/de/greenrobot/dao/test/AbstractDaoTestLongPk.java b/DaoCore/src/de/greenrobot/dao/test/AbstractDaoTestLongPk.java
index 6be8b3d5..32302e92 100644
--- a/DaoCore/src/de/greenrobot/dao/test/AbstractDaoTestLongPk.java
+++ b/DaoCore/src/de/greenrobot/dao/test/AbstractDaoTestLongPk.java
@@ -16,6 +16,8 @@
 
 package de.greenrobot.dao.test;
 
+import java.sql.SQLException;
+
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.DaoLog;
 
@@ -40,7 +42,7 @@ protected Long createRandomPk() {
         return random.nextLong();
     }
     
-    public void testAssignPk() {
+    public void testAssignPk() throws SQLException {
         if (daoAccess.isEntityUpdateable()) {
             T entity1 = createEntity(null);
             if (entity1 != null) {
diff --git a/DaoCore/src/de/greenrobot/dao/test/AbstractDaoTestSinglePk.java b/DaoCore/src/de/greenrobot/dao/test/AbstractDaoTestSinglePk.java
index f1d05b43..507b1a48 100644
--- a/DaoCore/src/de/greenrobot/dao/test/AbstractDaoTestSinglePk.java
+++ b/DaoCore/src/de/greenrobot/dao/test/AbstractDaoTestSinglePk.java
@@ -16,18 +16,19 @@
 
 package de.greenrobot.dao.test;
 
-import android.database.Cursor;
-import android.database.DatabaseUtils;
-import android.database.SQLException;
-import de.greenrobot.dao.AbstractDao;
-import de.greenrobot.dao.Property;
-import de.greenrobot.dao.internal.SqlUtils;
-
+import java.sql.PreparedStatement;
+import java.sql.ResultSet;
+import java.sql.SQLException;
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 
+import android.database.DatabaseUtils;
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.Property;
+import de.greenrobot.dao.internal.SqlUtils;
+
 /**
  * Default tests for single-PK entities.
  *
@@ -63,7 +64,7 @@ protected void setUp() throws Exception {
         }
     }
 
-    public void testInsertAndLoad() {
+    public void testInsertAndLoad() throws SQLException {
         K pk = nextPk();
         T entity = createEntity(pk);
         dao.insert(entity);
@@ -73,7 +74,7 @@ public void testInsertAndLoad() {
         assertEquals(daoAccess.getKey(entity), daoAccess.getKey(entity2));
     }
 
-    public void testInsertInTx() {
+    public void testInsertInTx() throws SQLException {
         dao.deleteAll();
         List<T> list = new ArrayList<T>();
         for (int i = 0; i < 20; i++) {
@@ -83,7 +84,7 @@ public void testInsertInTx() {
         assertEquals(list.size(), dao.count());
     }
 
-    public void testCount() {
+    public void testCount() throws SQLException {
         dao.deleteAll();
         assertEquals(0, dao.count());
         dao.insert(createEntityWithRandomPk());
@@ -92,7 +93,7 @@ public void testCount() {
         assertEquals(2, dao.count());
     }
 
-    public void testInsertTwice() {
+    public void testInsertTwice() throws SQLException {
         K pk = nextPk();
         T entity = createEntity(pk);
         dao.insert(entity);
@@ -104,7 +105,7 @@ public void testInsertTwice() {
         }
     }
 
-    public void testInsertOrReplaceTwice() {
+    public void testInsertOrReplaceTwice() throws SQLException {
         T entity = createEntityWithRandomPk();
         long rowId1 = dao.insert(entity);
         long rowId2 = dao.insertOrReplace(entity);
@@ -113,7 +114,7 @@ public void testInsertOrReplaceTwice() {
         }
     }
 
-    public void testInsertOrReplaceInTx() {
+    public void testInsertOrReplaceInTx() throws SQLException {
         dao.deleteAll();
         List<T> listPartial = new ArrayList<T>();
         List<T> listAll = new ArrayList<T>();
@@ -129,7 +130,7 @@ public void testInsertOrReplaceInTx() {
         assertEquals(listAll.size(), dao.count());
     }
 
-    public void testDelete() {
+    public void testDelete() throws SQLException {
         K pk = nextPk();
         dao.deleteByKey(pk);
         T entity = createEntity(pk);
@@ -139,7 +140,7 @@ public void testDelete() {
         assertNull(dao.load(pk));
     }
 
-    public void testDeleteAll() {
+    public void testDeleteAll() throws SQLException {
         List<T> entityList = new ArrayList<T>();
         for (int i = 0; i < 10; i++) {
             T entity = createEntityWithRandomPk();
@@ -155,7 +156,7 @@ public void testDeleteAll() {
         }
     }
 
-    public void testDeleteInTx() {
+    public void testDeleteInTx() throws SQLException {
         List<T> entityList = new ArrayList<T>();
         for (int i = 0; i < 10; i++) {
             T entity = createEntityWithRandomPk();
@@ -176,7 +177,7 @@ public void testDeleteInTx() {
         }
     }
 
-    public void testDeleteByKeyInTx() {
+    public void testDeleteByKeyInTx() throws SQLException {
         List<T> entityList = new ArrayList<T>();
         for (int i = 0; i < 10; i++) {
             T entity = createEntityWithRandomPk();
@@ -196,7 +197,7 @@ public void testDeleteByKeyInTx() {
         }
     }
 
-    public void testRowId() {
+    public void testRowId() throws SQLException {
         T entity1 = createEntityWithRandomPk();
         T entity2 = createEntityWithRandomPk();
         long rowId1 = dao.insert(entity1);
@@ -204,7 +205,7 @@ public void testRowId() {
         assertTrue(rowId1 != rowId2);
     }
 
-    public void testLoadAll() {
+    public void testLoadAll() throws SQLException {
         dao.deleteAll();
         List<T> list = new ArrayList<T>();
         for (int i = 0; i < 15; i++) {
@@ -216,7 +217,7 @@ public void testLoadAll() {
         assertEquals(list.size(), loaded.size());
     }
 
-    public void testQuery() {
+    public void testQuery() throws SQLException {
         dao.insert(createEntityWithRandomPk());
         K pkForQuery = nextPk();
         dao.insert(createEntity(pkForQuery));
@@ -228,7 +229,7 @@ public void testQuery() {
         assertEquals(pkForQuery, daoAccess.getKey(list.get(0)));
     }
 
-    public void testUpdate() {
+    public void testUpdate() throws SQLException {
         dao.deleteAll();
         T entity = createEntityWithRandomPk();
         dao.insert(entity);
@@ -236,43 +237,43 @@ public void testUpdate() {
         assertEquals(1, dao.count());
     }
 
-    public void testReadWithOffset() {
+    public void testReadWithOffset() throws SQLException {
         K pk = nextPk();
         T entity = createEntity(pk);
         dao.insert(entity);
 
-        Cursor cursor = queryWithDummyColumnsInFront(5, "42", pk);
+        ResultSet resultSet = queryWithDummyColumnsInFront(5, "42", pk);
         try {
-            T entity2 = daoAccess.readEntity(cursor, 5);
+            T entity2 = daoAccess.readEntity(resultSet, 5);
             assertEquals(pk, daoAccess.getKey(entity2));
         } finally {
-            cursor.close();
+            resultSet.close();
         }
     }
 
-    public void testLoadPkWithOffset() {
+    public void testLoadPkWithOffset() throws SQLException {
         runLoadPkTest(10);
     }
 
-    public void testLoadPk() {
+    public void testLoadPk() throws SQLException {
         runLoadPkTest(0);
     }
 
-    protected void runLoadPkTest(int offset) {
+    protected void runLoadPkTest(int offset) throws SQLException {
         K pk = nextPk();
         T entity = createEntity(pk);
         dao.insert(entity);
 
-        Cursor cursor = queryWithDummyColumnsInFront(offset, "42", pk);
+        ResultSet resultSet = queryWithDummyColumnsInFront(offset, "42", pk);
         try {
-            K pk2 = daoAccess.readKey(cursor, offset);
+            K pk2 = daoAccess.readKey(resultSet, offset);
             assertEquals(pk, pk2);
         } finally {
-            cursor.close();
+            resultSet.close();
         }
     }
 
-    protected Cursor queryWithDummyColumnsInFront(int dummyCount, String valueForColumn, K pk) {
+    protected ResultSet queryWithDummyColumnsInFront(int dummyCount, String valueForColumn, K pk) throws SQLException {
         StringBuilder builder = new StringBuilder("SELECT ");
         for (int i = 0; i < dummyCount; i++) {
             builder.append(valueForColumn).append(",");
@@ -288,20 +289,21 @@ protected Cursor queryWithDummyColumnsInFront(int dummyCount, String valueForCol
         }
 
         String select = builder.toString();
-        Cursor cursor = db.rawQuery(select, null);
-        assertTrue(cursor.moveToFirst());
+        PreparedStatement statement = connection.prepareStatement( select );
+        ResultSet resultSet = statement.executeQuery();
+        assertTrue(resultSet.next());
         try {
             for (int i = 0; i < dummyCount; i++) {
-                assertEquals(valueForColumn, cursor.getString(i));
+                assertEquals(valueForColumn, resultSet.getString(i));
             }
             if (pk != null) {
-                assertEquals(1, cursor.getCount());
+                assertEquals(1, resultSet.getFetchSize());
             }
         } catch (RuntimeException ex) {
-            cursor.close();
+            resultSet.close();
             throw ex;
         }
-        return cursor;
+        return resultSet;
     }
 
     /** Provides a collision free PK () not returned before in the current test. */
diff --git a/DaoCore/src/de/greenrobot/dao/test/DbTest.java b/DaoCore/src/de/greenrobot/dao/test/DbTest.java
index 6788eca0..0736ec86 100644
--- a/DaoCore/src/de/greenrobot/dao/test/DbTest.java
+++ b/DaoCore/src/de/greenrobot/dao/test/DbTest.java
@@ -16,14 +16,18 @@
 
 package de.greenrobot.dao.test;
 
+import java.io.File;
+import java.sql.Connection;
+import java.sql.Driver;
+import java.sql.DriverManager;
+import java.sql.SQLException;
+import java.util.Random;
+
 import android.app.Application;
 import android.app.Instrumentation;
-import android.database.sqlite.SQLiteDatabase;
 import android.test.AndroidTestCase;
 import de.greenrobot.dao.DbUtils;
 
-import java.util.Random;
-
 /**
  * Base class for database related testing, which prepares an in-memory or an file-based DB (using the test {@link
  * android.content.Context}). Also, offers some convenience methods to create new {@link Application} objects similar to
@@ -41,7 +45,7 @@
 
     protected final Random random;
     protected final boolean inMemory;
-    protected SQLiteDatabase db;
+    protected Connection connection;
 
     private Application application;
 
@@ -57,7 +61,7 @@ public DbTest(boolean inMemory) {
     @Override
     protected void setUp() throws Exception {
         super.setUp();
-        db = createDatabase();
+        connection = createConnection();
     }
 
     /** Returns a prepared application with the onCreate method already called. */
@@ -87,14 +91,48 @@ public void terminateApplication() {
         return (T) application;
     }
 
-    /** May be overriden by sub classes to set up a different db. */
-    protected SQLiteDatabase createDatabase() {
-        if (inMemory) {
-            return SQLiteDatabase.create(null);
-        } else {
-            getContext().deleteDatabase(DB_NAME);
-            return getContext().openOrCreateDatabase(DB_NAME, 0, null);
-        }
+    /** May be overriden by sub classes to set up a different db. 
+     * @throws SQLException */
+    protected Connection createConnection() throws SQLException {
+//        if (inMemory) {
+//            return SQLiteDatabase.create(null);
+//        } else {
+//            getContext().deleteDatabase(DB_NAME);
+//            return getContext().openOrCreateDatabase(DB_NAME, 0, null);
+//        }
+        
+     // setup
+		File f = new File(DB_NAME);
+		 if ( f.exists() ) {
+		   f.delete();
+		 } else {
+			 if (null != f.getParent()) {
+		       f.getParentFile().mkdirs();
+			 }
+		 }    
+		 // Loads and registers the JDBC driver
+		try
+		{
+			DriverManager.registerDriver((Driver)(Class.forName("org.sqldroid.SQLDroidDriver", true, getClass().getClassLoader()).newInstance()));
+		}
+		catch ( SQLException e )
+		{
+			e.printStackTrace();
+		}
+		catch ( IllegalAccessException e )
+		{
+			e.printStackTrace();
+		}
+		catch ( InstantiationException e )
+		{
+			e.printStackTrace();
+		}
+		catch ( ClassNotFoundException e )
+		{
+			e.printStackTrace();
+		}
+		
+		return DriverManager.getConnection("jdbc:sqlite:" + DB_NAME);
     }
 
     @Override
@@ -103,7 +141,7 @@ protected void tearDown() throws Exception {
         if (application != null) {
             terminateApplication();
         }
-        db.close();
+        connection.close();
         if (!inMemory) {
             getContext().deleteDatabase(DB_NAME);
         }
@@ -111,7 +149,7 @@ protected void tearDown() throws Exception {
     }
 
     protected void logTableDump(String tablename) {
-        DbUtils.logTableDump(db, tablename);
+        DbUtils.logTableDump(connection, tablename);
     }
 
 }
\ No newline at end of file
