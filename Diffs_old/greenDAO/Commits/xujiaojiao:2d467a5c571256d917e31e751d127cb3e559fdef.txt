diff --git a/DaoCore/src/main/java/de/greenrobot/dao/internal/SqlUtils.java b/DaoCore/src/main/java/de/greenrobot/dao/internal/SqlUtils.java
index 23d68949..b9cdf407 100644
--- a/DaoCore/src/main/java/de/greenrobot/dao/internal/SqlUtils.java
+++ b/DaoCore/src/main/java/de/greenrobot/dao/internal/SqlUtils.java
@@ -20,6 +20,7 @@
 
 /** Helper class to create SQL statements as used by greenDAO internally. */
 public class SqlUtils {
+    private final static char[] HEX_ARRAY = "0123456789ABCDEF".toCharArray();
 
     public static StringBuilder appendProperty(StringBuilder builder, String tablePrefix, Property property) {
         if (tablePrefix != null) {
@@ -146,4 +147,17 @@ public static String createSqlUpdate(String tablename, String[] updateColumns, S
         return builder.toString();
     }
 
+    public static String escapeBlobArgument(byte[] bytes) {
+        return "X'" + toHex(bytes) + '\'';
+    }
+
+    public static String toHex(byte[] bytes) {
+        char[] hexChars = new char[bytes.length * 2];
+        for (int i = 0; i < bytes.length; i++) {
+            int byteValue = bytes[i] & 0xFF;
+            hexChars[i * 2] = HEX_ARRAY[byteValue >>> 4];
+            hexChars[i * 2 + 1] = HEX_ARRAY[byteValue & 0x0F];
+        }
+        return new String(hexChars);
+    }
 }
diff --git a/DaoCore/src/main/java/de/greenrobot/dao/query/WhereCondition.java b/DaoCore/src/main/java/de/greenrobot/dao/query/WhereCondition.java
index aa234d07..49f17a73 100644
--- a/DaoCore/src/main/java/de/greenrobot/dao/query/WhereCondition.java
+++ b/DaoCore/src/main/java/de/greenrobot/dao/query/WhereCondition.java
@@ -99,7 +99,7 @@ private static Object checkValueForType(Property property, Object value) {
                         return 0;
                     } else {
                         throw new DaoException(
-                                "Illegal boolean value: Strings must be \"TRUE\" or \"FALSE\" (case insesnsitive), but was "
+                                "Illegal boolean value: Strings must be \"TRUE\" or \"FALSE\" (case insensitive), but was "
                                         + value);
                     }
                 }
diff --git a/DaoTest/build.gradle b/DaoTest/build.gradle
index 0947debd..74707af2 100644
--- a/DaoTest/build.gradle
+++ b/DaoTest/build.gradle
@@ -12,6 +12,7 @@ apply plugin: 'com.android.application'
 
 dependencies {
     androidTestCompile project(':DaoCore')
+    androidTestCompile project(':PerformanceTests:Common')
 
     testCompile project(':DaoCore')
     testCompile 'org.robolectric:robolectric:3.0'
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/DaoMaster.java b/DaoTest/src-gen/de/greenrobot/daotest/DaoMaster.java
index 9df78105..9a9bfdc6 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/DaoMaster.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/DaoMaster.java
@@ -25,6 +25,7 @@
 import de.greenrobot.daotest.AutoincrementEntityDao;
 import de.greenrobot.daotest.SqliteMasterDao;
 import de.greenrobot.daotest.CustomTypeEntityDao;
+import de.greenrobot.daotest.IndexedStringEntityDao;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
@@ -51,6 +52,7 @@ public static void createAllTables(SQLiteDatabase db, boolean ifNotExists) {
         StringKeyValueEntityDao.createTable(db, ifNotExists);
         AutoincrementEntityDao.createTable(db, ifNotExists);
         CustomTypeEntityDao.createTable(db, ifNotExists);
+        IndexedStringEntityDao.createTable(db, ifNotExists);
     }
     
     /** Drops underlying database table using DAOs. */
@@ -71,6 +73,7 @@ public static void dropAllTables(SQLiteDatabase db, boolean ifExists) {
         StringKeyValueEntityDao.dropTable(db, ifExists);
         AutoincrementEntityDao.dropTable(db, ifExists);
         CustomTypeEntityDao.dropTable(db, ifExists);
+        IndexedStringEntityDao.dropTable(db, ifExists);
     }
     
     public static abstract class OpenHelper extends SQLiteOpenHelper {
@@ -119,6 +122,7 @@ public DaoMaster(SQLiteDatabase db) {
         registerDaoClass(AutoincrementEntityDao.class);
         registerDaoClass(SqliteMasterDao.class);
         registerDaoClass(CustomTypeEntityDao.class);
+        registerDaoClass(IndexedStringEntityDao.class);
     }
     
     public DaoSession newSession() {
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/DaoSession.java b/DaoTest/src-gen/de/greenrobot/daotest/DaoSession.java
index 951c4b6e..0e608cb9 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/DaoSession.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/DaoSession.java
@@ -26,6 +26,7 @@
 import de.greenrobot.daotest.AutoincrementEntity;
 import de.greenrobot.daotest.SqliteMaster;
 import de.greenrobot.daotest.CustomTypeEntity;
+import de.greenrobot.daotest.IndexedStringEntity;
 
 import de.greenrobot.daotest.SimpleEntityDao;
 import de.greenrobot.daotest.SimpleEntityNotNullDao;
@@ -44,6 +45,7 @@
 import de.greenrobot.daotest.AutoincrementEntityDao;
 import de.greenrobot.daotest.SqliteMasterDao;
 import de.greenrobot.daotest.CustomTypeEntityDao;
+import de.greenrobot.daotest.IndexedStringEntityDao;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 
@@ -71,6 +73,7 @@
     private final DaoConfig autoincrementEntityDaoConfig;
     private final DaoConfig sqliteMasterDaoConfig;
     private final DaoConfig customTypeEntityDaoConfig;
+    private final DaoConfig indexedStringEntityDaoConfig;
 
     private final SimpleEntityDao simpleEntityDao;
     private final SimpleEntityNotNullDao simpleEntityNotNullDao;
@@ -89,6 +92,7 @@
     private final AutoincrementEntityDao autoincrementEntityDao;
     private final SqliteMasterDao sqliteMasterDao;
     private final CustomTypeEntityDao customTypeEntityDao;
+    private final IndexedStringEntityDao indexedStringEntityDao;
 
     public DaoSession(SQLiteDatabase db, IdentityScopeType type, Map<Class<? extends AbstractDao<?, ?>>, DaoConfig>
             daoConfigMap) {
@@ -145,6 +149,9 @@ public DaoSession(SQLiteDatabase db, IdentityScopeType type, Map<Class<? extends
         customTypeEntityDaoConfig = daoConfigMap.get(CustomTypeEntityDao.class).clone();
         customTypeEntityDaoConfig.initIdentityScope(type);
 
+        indexedStringEntityDaoConfig = daoConfigMap.get(IndexedStringEntityDao.class).clone();
+        indexedStringEntityDaoConfig.initIdentityScope(type);
+
         simpleEntityDao = new SimpleEntityDao(simpleEntityDaoConfig, this);
         simpleEntityNotNullDao = new SimpleEntityNotNullDao(simpleEntityNotNullDaoConfig, this);
         testEntityDao = new TestEntityDao(testEntityDaoConfig, this);
@@ -162,6 +169,7 @@ public DaoSession(SQLiteDatabase db, IdentityScopeType type, Map<Class<? extends
         autoincrementEntityDao = new AutoincrementEntityDao(autoincrementEntityDaoConfig, this);
         sqliteMasterDao = new SqliteMasterDao(sqliteMasterDaoConfig, this);
         customTypeEntityDao = new CustomTypeEntityDao(customTypeEntityDaoConfig, this);
+        indexedStringEntityDao = new IndexedStringEntityDao(indexedStringEntityDaoConfig, this);
 
         registerDao(SimpleEntity.class, simpleEntityDao);
         registerDao(SimpleEntityNotNull.class, simpleEntityNotNullDao);
@@ -180,6 +188,7 @@ public DaoSession(SQLiteDatabase db, IdentityScopeType type, Map<Class<? extends
         registerDao(AutoincrementEntity.class, autoincrementEntityDao);
         registerDao(SqliteMaster.class, sqliteMasterDao);
         registerDao(CustomTypeEntity.class, customTypeEntityDao);
+        registerDao(IndexedStringEntity.class, indexedStringEntityDao);
     }
     
     public void clear() {
@@ -200,6 +209,7 @@ public void clear() {
         autoincrementEntityDaoConfig.getIdentityScope().clear();
         sqliteMasterDaoConfig.getIdentityScope().clear();
         customTypeEntityDaoConfig.getIdentityScope().clear();
+        indexedStringEntityDaoConfig.getIdentityScope().clear();
     }
 
     public SimpleEntityDao getSimpleEntityDao() {
@@ -270,4 +280,8 @@ public CustomTypeEntityDao getCustomTypeEntityDao() {
         return customTypeEntityDao;
     }
 
+    public IndexedStringEntityDao getIndexedStringEntityDao() {
+        return indexedStringEntityDao;
+    }
+
 }
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/IndexedStringEntity.java b/DaoTest/src-gen/de/greenrobot/daotest/IndexedStringEntity.java
new file mode 100644
index 00000000..7aeb7cde
--- /dev/null
+++ b/DaoTest/src-gen/de/greenrobot/daotest/IndexedStringEntity.java
@@ -0,0 +1,40 @@
+package de.greenrobot.daotest;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
+/**
+ * Entity mapped to table "INDEXED_STRING_ENTITY".
+ */
+public class IndexedStringEntity {
+
+    private Long id;
+    private String indexedString;
+
+    public IndexedStringEntity() {
+    }
+
+    public IndexedStringEntity(Long id) {
+        this.id = id;
+    }
+
+    public IndexedStringEntity(Long id, String indexedString) {
+        this.id = id;
+        this.indexedString = indexedString;
+    }
+
+    public Long getId() {
+        return id;
+    }
+
+    public void setId(Long id) {
+        this.id = id;
+    }
+
+    public String getIndexedString() {
+        return indexedString;
+    }
+
+    public void setIndexedString(String indexedString) {
+        this.indexedString = indexedString;
+    }
+
+}
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/IndexedStringEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/IndexedStringEntityDao.java
new file mode 100644
index 00000000..3724a9af
--- /dev/null
+++ b/DaoTest/src-gen/de/greenrobot/daotest/IndexedStringEntityDao.java
@@ -0,0 +1,118 @@
+package de.greenrobot.daotest;
+
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteStatement;
+
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.Property;
+import de.greenrobot.dao.internal.DaoConfig;
+
+import de.greenrobot.daotest.IndexedStringEntity;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+/** 
+ * DAO for table "INDEXED_STRING_ENTITY".
+*/
+public class IndexedStringEntityDao extends AbstractDao<IndexedStringEntity, Long> {
+
+    public static final String TABLENAME = "INDEXED_STRING_ENTITY";
+
+    /**
+     * Properties of entity IndexedStringEntity.<br/>
+     * Can be used for QueryBuilder and for referencing column names.
+    */
+    public static class Properties {
+        public final static Property Id = new Property(0, Long.class, "id", true, "_id");
+        public final static Property IndexedString = new Property(1, String.class, "indexedString", false, "INDEXED_STRING");
+    };
+
+
+    public IndexedStringEntityDao(DaoConfig config) {
+        super(config);
+    }
+    
+    public IndexedStringEntityDao(DaoConfig config, DaoSession daoSession) {
+        super(config, daoSession);
+    }
+
+    /** Creates the underlying database table. */
+    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+        String constraint = ifNotExists? "IF NOT EXISTS ": "";
+        db.execSQL("CREATE TABLE " + constraint + "\"INDEXED_STRING_ENTITY\" (" + //
+                "\"_id\" INTEGER PRIMARY KEY ," + // 0: id
+                "\"INDEXED_STRING\" TEXT);"); // 1: indexedString
+        // Add Indexes
+        db.execSQL("CREATE INDEX " + constraint + "IDX_INDEXED_STRING_ENTITY_INDEXED_STRING ON INDEXED_STRING_ENTITY" +
+                " (\"INDEXED_STRING\");");
+    }
+
+    /** Drops the underlying database table. */
+    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "\"INDEXED_STRING_ENTITY\"";
+        db.execSQL(sql);
+    }
+
+    /** @inheritdoc */
+    @Override
+    protected void bindValues(SQLiteStatement stmt, IndexedStringEntity entity) {
+        stmt.clearBindings();
+ 
+        Long id = entity.getId();
+        if (id != null) {
+            stmt.bindLong(1, id);
+        }
+ 
+        String indexedString = entity.getIndexedString();
+        if (indexedString != null) {
+            stmt.bindString(2, indexedString);
+        }
+    }
+
+    /** @inheritdoc */
+    @Override
+    public Long readKey(Cursor cursor, int offset) {
+        return cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0);
+    }    
+
+    /** @inheritdoc */
+    @Override
+    public IndexedStringEntity readEntity(Cursor cursor, int offset) {
+        IndexedStringEntity entity = new IndexedStringEntity( //
+            cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0), // id
+            cursor.isNull(offset + 1) ? null : cursor.getString(offset + 1) // indexedString
+        );
+        return entity;
+    }
+     
+    /** @inheritdoc */
+    @Override
+    public void readEntity(Cursor cursor, IndexedStringEntity entity, int offset) {
+        entity.setId(cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0));
+        entity.setIndexedString(cursor.isNull(offset + 1) ? null : cursor.getString(offset + 1));
+     }
+    
+    /** @inheritdoc */
+    @Override
+    protected Long updateKeyAfterInsert(IndexedStringEntity entity, long rowId) {
+        entity.setId(rowId);
+        return rowId;
+    }
+    
+    /** @inheritdoc */
+    @Override
+    public Long getKey(IndexedStringEntity entity) {
+        if(entity != null) {
+            return entity.getId();
+        } else {
+            return null;
+        }
+    }
+
+    /** @inheritdoc */
+    @Override    
+    protected boolean isEntityUpdateable() {
+        return true;
+    }
+    
+}
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/TestEntity.java b/DaoTest/src-gen/de/greenrobot/daotest/TestEntity.java
index 5e7688d0..748cee08 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/TestEntity.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/TestEntity.java
@@ -16,6 +16,7 @@
     private String indexedStringAscUnique;
     private java.util.Date simpleDate;
     private Boolean simpleBoolean;
+    private byte[] simpleByteArray;
 
     public TestEntity() {
     }
@@ -24,7 +25,7 @@ public TestEntity(Long id) {
         this.id = id;
     }
 
-    public TestEntity(Long id, int simpleInt, Integer simpleInteger, String simpleStringNotNull, String simpleString, String indexedString, String indexedStringAscUnique, java.util.Date simpleDate, Boolean simpleBoolean) {
+    public TestEntity(Long id, int simpleInt, Integer simpleInteger, String simpleStringNotNull, String simpleString, String indexedString, String indexedStringAscUnique, java.util.Date simpleDate, Boolean simpleBoolean, byte[] simpleByteArray) {
         this.id = id;
         this.simpleInt = simpleInt;
         this.simpleInteger = simpleInteger;
@@ -34,6 +35,7 @@ public TestEntity(Long id, int simpleInt, Integer simpleInteger, String simpleSt
         this.indexedStringAscUnique = indexedStringAscUnique;
         this.simpleDate = simpleDate;
         this.simpleBoolean = simpleBoolean;
+        this.simpleByteArray = simpleByteArray;
     }
 
     public Long getId() {
@@ -110,4 +112,12 @@ public void setSimpleBoolean(Boolean simpleBoolean) {
         this.simpleBoolean = simpleBoolean;
     }
 
+    public byte[] getSimpleByteArray() {
+        return simpleByteArray;
+    }
+
+    public void setSimpleByteArray(byte[] simpleByteArray) {
+        this.simpleByteArray = simpleByteArray;
+    }
+
 }
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/TestEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/TestEntityDao.java
index dd904651..5febaa8b 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/TestEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/TestEntityDao.java
@@ -32,6 +32,7 @@
         public final static Property IndexedStringAscUnique = new Property(6, String.class, "indexedStringAscUnique", false, "INDEXED_STRING_ASC_UNIQUE");
         public final static Property SimpleDate = new Property(7, java.util.Date.class, "simpleDate", false, "SIMPLE_DATE");
         public final static Property SimpleBoolean = new Property(8, Boolean.class, "simpleBoolean", false, "SIMPLE_BOOLEAN");
+        public final static Property SimpleByteArray = new Property(9, byte[].class, "simpleByteArray", false, "SIMPLE_BYTE_ARRAY");
     };
 
 
@@ -55,7 +56,8 @@ public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
                 "\"INDEXED_STRING\" TEXT," + // 5: indexedString
                 "\"INDEXED_STRING_ASC_UNIQUE\" TEXT," + // 6: indexedStringAscUnique
                 "\"SIMPLE_DATE\" INTEGER," + // 7: simpleDate
-                "\"SIMPLE_BOOLEAN\" INTEGER);"); // 8: simpleBoolean
+                "\"SIMPLE_BOOLEAN\" INTEGER," + // 8: simpleBoolean
+                "\"SIMPLE_BYTE_ARRAY\" BLOB);"); // 9: simpleByteArray
         // Add Indexes
         db.execSQL("CREATE INDEX " + constraint + "IDX_TEST_ENTITY_INDEXED_STRING ON TEST_ENTITY" +
                 " (\"INDEXED_STRING\");");
@@ -110,6 +112,11 @@ protected void bindValues(SQLiteStatement stmt, TestEntity entity) {
         if (simpleBoolean != null) {
             stmt.bindLong(9, simpleBoolean ? 1L: 0L);
         }
+ 
+        byte[] simpleByteArray = entity.getSimpleByteArray();
+        if (simpleByteArray != null) {
+            stmt.bindBlob(10, simpleByteArray);
+        }
     }
 
     /** @inheritdoc */
@@ -130,7 +137,8 @@ public TestEntity readEntity(Cursor cursor, int offset) {
             cursor.isNull(offset + 5) ? null : cursor.getString(offset + 5), // indexedString
             cursor.isNull(offset + 6) ? null : cursor.getString(offset + 6), // indexedStringAscUnique
             cursor.isNull(offset + 7) ? null : new java.util.Date(cursor.getLong(offset + 7)), // simpleDate
-            cursor.isNull(offset + 8) ? null : cursor.getShort(offset + 8) != 0 // simpleBoolean
+            cursor.isNull(offset + 8) ? null : cursor.getShort(offset + 8) != 0, // simpleBoolean
+            cursor.isNull(offset + 9) ? null : cursor.getBlob(offset + 9) // simpleByteArray
         );
         return entity;
     }
@@ -147,6 +155,7 @@ public void readEntity(Cursor cursor, TestEntity entity, int offset) {
         entity.setIndexedStringAscUnique(cursor.isNull(offset + 6) ? null : cursor.getString(offset + 6));
         entity.setSimpleDate(cursor.isNull(offset + 7) ? null : new java.util.Date(cursor.getLong(offset + 7)));
         entity.setSimpleBoolean(cursor.isNull(offset + 8) ? null : cursor.getShort(offset + 8) != 0);
+        entity.setSimpleByteArray(cursor.isNull(offset + 9) ? null : cursor.getBlob(offset + 9));
      }
     
     /** @inheritdoc */
diff --git a/DaoTest/src/de/greenrobot/daotest/DaoSessionConcurrentTest.java b/DaoTest/src/de/greenrobot/daotest/DaoSessionConcurrentTest.java
index ffa9e718..e243c4c5 100644
--- a/DaoTest/src/de/greenrobot/daotest/DaoSessionConcurrentTest.java
+++ b/DaoTest/src/de/greenrobot/daotest/DaoSessionConcurrentTest.java
@@ -5,6 +5,7 @@
 import android.database.sqlite.SQLiteDatabase;
 import android.database.sqlite.SQLiteStatement;
 import android.os.SystemClock;
+
 import de.greenrobot.dao.DaoLog;
 import de.greenrobot.dao.query.DeleteQuery;
 import de.greenrobot.dao.query.Query;
@@ -209,17 +210,14 @@ public void run() {
         latchThreadsDone.await();
     }
 
-    // No connection for read can be acquired while TX is active; this will deadlock!
-    public void _testConcurrentLockAndQueryDuringTx() throws InterruptedException {
+    public void testConcurrentLockAndQueryDuringTx() throws InterruptedException {
         final TestEntity entity = createEntity(null);
         dao.insert(entity);
         final Query<TestEntity> query = dao.queryBuilder().build();
         Runnable runnable1 = new Runnable() {
             @Override
             public void run() {
-                synchronized (query) {
-                    query.list();
-                }
+                query.forCurrentThread().list();
             }
         };
 
@@ -229,9 +227,7 @@ public void run() {
         doTx(new Runnable() {
             @Override
             public void run() {
-                synchronized (query) {
-                    query.list();
-                }
+                query.list();
             }
         });
         latchThreadsDone.await();
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/IndexedStringEntityTest.java b/DaoTest/src/de/greenrobot/daotest/entity/IndexedStringEntityTest.java
new file mode 100644
index 00000000..437de999
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/entity/IndexedStringEntityTest.java
@@ -0,0 +1,21 @@
+package de.greenrobot.daotest.entity;
+
+import de.greenrobot.dao.test.AbstractDaoTestLongPk;
+
+import de.greenrobot.daotest.IndexedStringEntity;
+import de.greenrobot.daotest.IndexedStringEntityDao;
+
+public class IndexedStringEntityTest extends AbstractDaoTestLongPk<IndexedStringEntityDao, IndexedStringEntity> {
+
+    public IndexedStringEntityTest() {
+        super(IndexedStringEntityDao.class);
+    }
+
+    @Override
+    protected IndexedStringEntity createEntity(Long key) {
+        IndexedStringEntity entity = new IndexedStringEntity();
+        entity.setId(key);
+        return entity;
+    }
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/performance/IndexedStringPerformanceTest.java b/DaoTest/src/de/greenrobot/daotest/performance/IndexedStringPerformanceTest.java
new file mode 100644
index 00000000..1a0822ec
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/performance/IndexedStringPerformanceTest.java
@@ -0,0 +1,73 @@
+package de.greenrobot.daotest.performance;
+
+import de.greenrobot.dao.DaoLog;
+import de.greenrobot.dao.test.AbstractDaoTest;
+import de.greenrobot.daotest.IndexedStringEntity;
+import de.greenrobot.daotest.IndexedStringEntityDao;
+import de.greenrobot.performance.StringGenerator;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Stores entities with an indexed string property and measures the duration to query them by this
+ * string. The generated strings are in a fixed random sequence. The strings to query for are also
+ * in a fixed random sequence.
+ */
+public class IndexedStringPerformanceTest
+        extends AbstractDaoTest<IndexedStringEntityDao, IndexedStringEntity, Long> {
+
+    private static final int BATCH_SIZE = 10000;
+    private static final int QUERY_COUNT = 1000;
+    private static final int RUNS = 8;
+
+    public IndexedStringPerformanceTest() {
+        super(IndexedStringEntityDao.class, false);
+    }
+
+    public void testIndexedStringEntityQuery() {
+        // disabled for regular builds
+//        DaoLog.d("--------Indexed Queries: Start");
+//        for (int i = 0; i < RUNS; i++) {
+//            DaoLog.d("----Run " + (i + 1) + " of " + RUNS);
+//            doIndexedStringEntityQuery();
+//        }
+//        DaoLog.d("--------Indexed Queries: End");
+    }
+
+    private void doIndexedStringEntityQuery() {
+        // create entities
+        List<IndexedStringEntity> entities = new ArrayList<>(BATCH_SIZE);
+        String[] fixedRandomStrings = StringGenerator.createFixedRandomStrings(BATCH_SIZE);
+        for (int i = 0; i < BATCH_SIZE; i++) {
+            IndexedStringEntity entity = new IndexedStringEntity();
+            entity.setId((long) i);
+            entity.setIndexedString(fixedRandomStrings[i]);
+            entities.add(entity);
+        }
+        DaoLog.d("Built entities.");
+
+        // insert entities
+        dao.insertInTx(entities);
+        DaoLog.d("Inserted entities.");
+
+        // query for entities by indexed string at random
+        int[] randomIndices = StringGenerator.getFixedRandomIndices(QUERY_COUNT, BATCH_SIZE - 1);
+
+        long start = System.currentTimeMillis();
+        for (int i = 0; i < QUERY_COUNT; i++) {
+            int nextIndex = randomIndices[i];
+            //noinspection unused
+            List<IndexedStringEntity> query = dao.queryBuilder()
+                    .where(IndexedStringEntityDao.Properties.IndexedString.eq(
+                            fixedRandomStrings[nextIndex]))
+                    .list();
+        }
+        long time = System.currentTimeMillis() - start;
+        DaoLog.d("Queried for " + QUERY_COUNT + " of " + BATCH_SIZE + " indexed entities in " + time
+                + " ms.");
+
+        // delete all entities
+        dao.deleteAll();
+        DaoLog.d("Deleted all entities.");
+    }
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/query/QueryBuilderSimpleTest.java b/DaoTest/src/de/greenrobot/daotest/query/QueryBuilderSimpleTest.java
index 93106d13..a8dbcc4b 100644
--- a/DaoTest/src/de/greenrobot/daotest/query/QueryBuilderSimpleTest.java
+++ b/DaoTest/src/de/greenrobot/daotest/query/QueryBuilderSimpleTest.java
@@ -21,10 +21,11 @@
 import java.util.Date;
 import java.util.List;
 
+import de.greenrobot.dao.internal.SqlUtils;
 import de.greenrobot.dao.query.Query;
 import de.greenrobot.dao.query.QueryBuilder;
+import de.greenrobot.dao.query.WhereCondition;
 import de.greenrobot.daotest.TestEntity;
-import de.greenrobot.daotest.TestEntityDao;
 import de.greenrobot.daotest.TestEntityDao.Properties;
 import de.greenrobot.daotest.entity.TestEntityTestBase;
 
@@ -171,6 +172,31 @@ public void testEqBoolean() {
         assertEquals(testEntity.getId(), testEntity2.getId());
     }
 
+    // TODO fix byte arrays? Android is doing String args everywhere
+    public void testEqByteArray() {
+        ArrayList<TestEntity> inserted = insert(3);
+        TestEntity testEntity = inserted.get(1);
+
+        byte[] byteArray = {96, 77, 37, -21};
+        testEntity.setSimpleByteArray(byteArray);
+        dao.update(testEntity);
+
+        // Unsupported: Query<TestEntity> query = dao.queryBuilder().where(Properties.SimpleByteArray.eq(byteArray)).build();
+
+        // Works, but probably voids any index on BLOBs (Note: there's no hex2blob function and X'?' is bad syntax):
+        // String conditionString = "HEX(" + Properties.SimpleByteArray.columnName + ")=?";
+        // WhereCondition condition = new WhereCondition.StringCondition(conditionString, SqlUtils.toHex(byteArray));
+
+        String conditionString = Properties.SimpleByteArray.columnName + '=' + SqlUtils.escapeBlobArgument(byteArray);
+        WhereCondition condition = new WhereCondition.StringCondition(conditionString);
+        Query<TestEntity> query = dao.queryBuilder().where(condition).build();
+        TestEntity testEntity2 = query.uniqueOrThrow();
+        assertEquals(testEntity.getId(), testEntity2.getId());
+
+        // Unsupported: query.setParameter(0, new byte[]{96, 77, 37, -21, 99});
+        // Unsupported: assertNull(query.unique());
+    }
+
     public void testIsNullIsNotNull() {
         ArrayList<TestEntity> inserted = insert(2);
         TestEntity testEntityNull = inserted.get(0);
@@ -210,15 +236,15 @@ public void testLike() {
         Query<TestEntity> query = dao.queryBuilder().where(Properties.SimpleString.like("%robot")).build();
         TestEntity entity2 = query.uniqueOrThrow();
         assertEquals(entity.getId(), entity2.getId());
-        
+
         query.setParameter(0, "green%");
         entity2 = query.uniqueOrThrow();
         assertEquals(entity.getId(), entity2.getId());
-        
+
         query.setParameter(0, "%enrob%");
         entity2 = query.uniqueOrThrow();
         assertEquals(entity.getId(), entity2.getId());
-        
+
         query.setParameter(0, "%nothere%");
         entity2 = query.unique();
         assertNull(entity2);
diff --git a/DaoTestGenerator/src/de/greenrobot/daogenerator/gentest/TestDaoGenerator.java b/DaoTestGenerator/src/de/greenrobot/daogenerator/gentest/TestDaoGenerator.java
index bfaf9419..88ba6080 100644
--- a/DaoTestGenerator/src/de/greenrobot/daogenerator/gentest/TestDaoGenerator.java
+++ b/DaoTestGenerator/src/de/greenrobot/daogenerator/gentest/TestDaoGenerator.java
@@ -60,6 +60,7 @@ public TestDaoGenerator() {
         createAutoincrement();
         createSqliteMaster();
         createCustomType();
+        createIndexedString();
 
         schema2 = createSchema2();
         schemaUnitTest = createSchemaUnitTest();
@@ -113,6 +114,7 @@ protected Entity createTest() {
         testEntity.addStringProperty("indexedStringAscUnique").indexAsc(null, true);
         testEntity.addDateProperty("simpleDate");
         testEntity.addBooleanProperty("simpleBoolean");
+        testEntity.addByteArrayProperty("simpleByteArray");
         return testEntity;
     }
 
@@ -261,6 +263,12 @@ protected void createCustomType() {
                 "de.greenrobot.daotest.customtype.MyTimestampConverter");
     }
 
+    protected void createIndexedString() {
+        Entity entity = schema.addEntity("IndexedStringEntity");
+        entity.addIdProperty();
+        entity.addStringProperty("indexedString").index();
+    }
+
     private Schema createSchema2() {
         Schema schema2 = new Schema(1, "de.greenrobot.daotest2");
         schema2.setDefaultJavaPackageTest("de.greenrobot.daotest2.entity");
diff --git a/PerformanceTests/ActiveAndroid/build.gradle b/PerformanceTests/ActiveAndroid/build.gradle
index f069bb23..6f1023b2 100644
--- a/PerformanceTests/ActiveAndroid/build.gradle
+++ b/PerformanceTests/ActiveAndroid/build.gradle
@@ -30,6 +30,7 @@ android {
 }
 
 dependencies {
-    androidTestCompile 'com.android.support:support-v4:22.2.1'
+    androidTestCompile project(':PerformanceTests:Common')
+    androidTestCompile 'com.android.support:support-v4:23.0.1'
     androidTestCompile 'com.michaelpardo:activeandroid:3.1.0-SNAPSHOT'
 }
diff --git a/PerformanceTests/ActiveAndroid/src/androidTest/java/de/greenrobot/performance/activeandroid/IndexedStringEntity.java b/PerformanceTests/ActiveAndroid/src/androidTest/java/de/greenrobot/performance/activeandroid/IndexedStringEntity.java
new file mode 100644
index 00000000..1f953ed9
--- /dev/null
+++ b/PerformanceTests/ActiveAndroid/src/androidTest/java/de/greenrobot/performance/activeandroid/IndexedStringEntity.java
@@ -0,0 +1,16 @@
+package de.greenrobot.performance.activeandroid;
+
+import com.activeandroid.Model;
+import com.activeandroid.annotation.Column;
+import com.activeandroid.annotation.Table;
+
+/**
+ * Simple entity with a string property that is indexed.
+ */
+@Table(name = "INDEXED_STRING_ENTITY")
+public class IndexedStringEntity extends Model {
+
+    @Column(name = "INDEXED_STRING", index =  true)
+    public String indexedString;
+
+}
diff --git a/PerformanceTests/ActiveAndroid/src/androidTest/java/de/greenrobot/performance/activeandroid/PerformanceTestActiveAndroid.java b/PerformanceTests/ActiveAndroid/src/androidTest/java/de/greenrobot/performance/activeandroid/PerformanceTestActiveAndroid.java
index 9c84784c..8964ede6 100644
--- a/PerformanceTests/ActiveAndroid/src/androidTest/java/de/greenrobot/performance/activeandroid/PerformanceTestActiveAndroid.java
+++ b/PerformanceTests/ActiveAndroid/src/androidTest/java/de/greenrobot/performance/activeandroid/PerformanceTestActiveAndroid.java
@@ -4,16 +4,25 @@
 import android.test.ApplicationTestCase;
 import android.util.Log;
 import com.activeandroid.ActiveAndroid;
+import com.activeandroid.Cache;
 import com.activeandroid.Configuration;
 import com.activeandroid.query.Select;
+import de.greenrobot.performance.StringGenerator;
 import java.sql.SQLException;
 import java.util.ArrayList;
 import java.util.List;
 
+/**
+ * https://github.com/pardom/ActiveAndroid/wiki/Getting-started
+ */
 public class PerformanceTestActiveAndroid extends ApplicationTestCase<Application> {
 
+    private static final String TAG = "PerfTestActiveAndroid";
+
     private static final int BATCH_SIZE = 10000;
+    private static final int QUERY_COUNT = 1000;
     private static final int RUNS = 8;
+
     private static final String DATABASE_NAME = "active-android.db";
 
     public PerformanceTestActiveAndroid() {
@@ -23,55 +32,118 @@ public PerformanceTestActiveAndroid() {
     @Override
     protected void setUp() throws Exception {
         super.setUp();
+
         createApplication();
-        setupDatabase();
     }
 
-    protected void setupDatabase() {
+    @Override
+    protected void tearDown() throws Exception {
+        if (Cache.isInitialized()) {
+            ActiveAndroid.dispose();
+        }
+        getApplication().deleteDatabase(DATABASE_NAME);
+
+        super.tearDown();
+    }
+
+    public void testIndexedStringEntityQuery() {
+        //noinspection PointlessBooleanExpression
+        if (!BuildConfig.RUN_PERFORMANCE_TESTS) {
+            Log.d(TAG, "Performance tests are disabled.");
+            return;
+        }
+        Log.d(TAG, "--------Indexed Queries: Start");
+
+        // set up database
         Configuration dbConfiguration = new Configuration.Builder(getContext())
                 .setDatabaseName(DATABASE_NAME)
-                .addModelClass(SimpleEntityNotNull.class)
+                .addModelClass(IndexedStringEntity.class)
                 .create();
         ActiveAndroid.initialize(dbConfiguration);
+        Log.d(TAG, "Set up database.");
+
+        for (int i = 0; i < RUNS; i++) {
+            Log.d(TAG, "----Run " + (i + 1) + " of " + RUNS);
+            doIndexedStringEntityQuery();
+        }
+
+        Log.d(TAG, "--------Indexed Queries: End");
     }
 
-    @Override
-    protected void tearDown() throws Exception {
-        ActiveAndroid.dispose();
-        getApplication().deleteDatabase(DATABASE_NAME);
-        super.tearDown();
+    private void doIndexedStringEntityQuery() {
+        // create entities
+        List<IndexedStringEntity> entities = new ArrayList<>(BATCH_SIZE);
+        String[] fixedRandomStrings = StringGenerator.createFixedRandomStrings(BATCH_SIZE);
+        for (int i = 0; i < BATCH_SIZE; i++) {
+            IndexedStringEntity entity = new IndexedStringEntity();
+            entity.indexedString = fixedRandomStrings[i];
+            entities.add(entity);
+        }
+        Log.d(TAG, "Built entities.");
+
+        // insert entities
+        ActiveAndroid.beginTransaction();
+        try {
+            for (int i = 0; i < BATCH_SIZE; i++) {
+                entities.get(i).save();
+            }
+            ActiveAndroid.setTransactionSuccessful();
+        } finally {
+            ActiveAndroid.endTransaction();
+        }
+        Log.d(TAG, "Inserted entities.");
+
+        // query for entities by indexed string at random
+        int[] randomIndices = StringGenerator.getFixedRandomIndices(QUERY_COUNT, BATCH_SIZE - 1);
+
+        long start = System.currentTimeMillis();
+        for (int i = 0; i < QUERY_COUNT; i++) {
+            int nextIndex = randomIndices[i];
+            //noinspection unused
+            List<IndexedStringEntity> query = new Select()
+                    .from(IndexedStringEntity.class)
+                    .where("INDEXED_STRING = ?", fixedRandomStrings[nextIndex])
+                    .execute();
+            // ActiveAndroid already builds all entities when executing the query, so move on
+        }
+        long time = System.currentTimeMillis() - start;
+        Log.d(TAG,
+                "Queried for " + QUERY_COUNT + " of " + BATCH_SIZE + " indexed entities in " + time
+                        + " ms.");
+
+        // delete all entities
+        ActiveAndroid.execSQL("DELETE FROM INDEXED_STRING_ENTITY");
+        Log.d(TAG, "Deleted all entities.");
     }
 
     public void testPerformance() throws Exception {
         //noinspection PointlessBooleanExpression
         if (!BuildConfig.RUN_PERFORMANCE_TESTS) {
-            Log.d("DAO", "ActiveAndroid performance tests are disabled.");
+            Log.d(TAG, "Performance tests are disabled.");
             return;
         }
+        Log.d(TAG, "---------------Start");
 
-        runTests(100); // Warmup
+        // set up database
+        Configuration dbConfiguration = new Configuration.Builder(getContext())
+                .setDatabaseName(DATABASE_NAME)
+                .addModelClass(SimpleEntityNotNull.class)
+                .create();
+        ActiveAndroid.initialize(dbConfiguration);
 
         for (int i = 0; i < RUNS; i++) {
-            deleteAll();
             runTests(BATCH_SIZE);
         }
-        deleteAll();
-        Log.d("DAO", "---------------End");
-    }
 
-    protected void deleteAll() {
-        long start = System.currentTimeMillis();
-        ActiveAndroid.execSQL("DELETE FROM SIMPLE_ENTITY_NOT_NULL");
-        long time = System.currentTimeMillis() - start;
-        Log.d("DAO", "ActiveAndroid: Deleted all entities in " + time + " ms");
+        Log.d(TAG, "---------------End");
     }
 
     protected void runTests(int entityCount) throws Exception {
-        Log.d("DAO", "---------------Start: " + entityCount);
+        Log.d(TAG, "---------------Start: " + entityCount);
 
         long start, time;
 
-        final List<SimpleEntityNotNull> list = new ArrayList<SimpleEntityNotNull>();
+        final List<SimpleEntityNotNull> list = new ArrayList<>();
         for (int i = 0; i < entityCount; i++) {
             list.add(SimpleEntityNotNullHelper.createEntity());
         }
@@ -93,8 +165,7 @@ protected void runTests(int entityCount) throws Exception {
             ActiveAndroid.endTransaction();
         }
         time = System.currentTimeMillis() - start;
-        Log.d("DAO",
-                "ActiveAndroid: Created (batch) " + list.size() + " entities in " + time + " ms");
+        Log.d(TAG, "Created (batch) " + list.size() + " entities in " + time + " ms");
 
         start = System.currentTimeMillis();
         ActiveAndroid.beginTransaction();
@@ -107,8 +178,7 @@ protected void runTests(int entityCount) throws Exception {
             ActiveAndroid.endTransaction();
         }
         time = System.currentTimeMillis() - start;
-        Log.d("DAO",
-                "ActiveAndroid: Updated (batch) " + list.size() + " entities in " + time + " ms");
+        Log.d(TAG, "Updated (batch) " + list.size() + " entities in " + time + " ms");
 
         start = System.currentTimeMillis();
         List<SimpleEntityNotNull> reloaded = new Select()
@@ -116,8 +186,7 @@ protected void runTests(int entityCount) throws Exception {
                 .from(SimpleEntityNotNull.class)
                 .execute();
         time = System.currentTimeMillis() - start;
-        Log.d("DAO", "ActiveAndroid: Loaded (batch) " + reloaded.size() + " entities in " + time
-                + " ms");
+        Log.d(TAG, "Loaded (batch) " + reloaded.size() + " entities in " + time + " ms");
 
         start = System.currentTimeMillis();
         for (int i = 0; i < reloaded.size(); i++) {
@@ -134,12 +203,19 @@ protected void runTests(int entityCount) throws Exception {
             entity.getSimpleByteArray();
         }
         time = System.currentTimeMillis() - start;
-        Log.d("DAO",
-                "ActiveAndroid: Accessed properties of " + reloaded.size() + " entities in " + time
-                        + " ms");
+        Log.d(TAG, "Accessed properties of " + reloaded.size() + " entities in " + time + " ms");
+
+        deleteAll();
 
         System.gc();
-        Log.d("DAO", "---------------End: " + entityCount);
+        Log.d(TAG, "---------------End: " + entityCount);
+    }
+
+    protected void deleteAll() {
+        long start = System.currentTimeMillis();
+        ActiveAndroid.execSQL("DELETE FROM SIMPLE_ENTITY_NOT_NULL");
+        long time = System.currentTimeMillis() - start;
+        Log.d(TAG, "Deleted all entities in " + time + " ms");
     }
 
     protected void runOneByOne(List<SimpleEntityNotNull> list, int count) throws SQLException {
@@ -150,15 +226,13 @@ protected void runOneByOne(List<SimpleEntityNotNull> list, int count) throws SQL
             list.get(i).save();
         }
         time = System.currentTimeMillis() - start;
-        Log.d("DAO",
-                "ActiveAndroid: Inserted (one-by-one) " + count + " entities in " + time + " ms");
+        Log.d(TAG, "Inserted (one-by-one) " + count + " entities in " + time + " ms");
 
         start = System.currentTimeMillis();
         for (int i = 0; i < count; i++) {
             list.get(i).save();
         }
         time = System.currentTimeMillis() - start;
-        Log.d("DAO",
-                "ActiveAndroid: Updated (one-by-one) " + count + " entities in " + time + " ms");
+        Log.d(TAG, "Updated (one-by-one) " + count + " entities in " + time + " ms");
     }
 }
diff --git a/PerformanceTests/Common/build.gradle b/PerformanceTests/Common/build.gradle
new file mode 100644
index 00000000..af4cae34
--- /dev/null
+++ b/PerformanceTests/Common/build.gradle
@@ -0,0 +1,24 @@
+buildscript {
+    repositories {
+        jcenter()
+    }
+
+    dependencies {
+        classpath 'com.android.tools.build:gradle:1.3.1'
+    }
+}
+
+apply plugin: 'com.android.library'
+
+android {
+    buildToolsVersion rootProject.ext.buildToolsVersion
+    compileSdkVersion rootProject.ext.compileSdkVersion
+
+    defaultConfig {
+        minSdkVersion rootProject.ext.minSdkVersion
+    }
+}
+
+dependencies {
+    compile 'org.apache.commons:commons-lang3:3.4'
+}
diff --git a/PerformanceTests/Common/src/main/AndroidManifest.xml b/PerformanceTests/Common/src/main/AndroidManifest.xml
new file mode 100644
index 00000000..69883fe4
--- /dev/null
+++ b/PerformanceTests/Common/src/main/AndroidManifest.xml
@@ -0,0 +1,3 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="de.greenrobot.performance.common"/>
diff --git a/PerformanceTests/Common/src/main/java/de/greenrobot/performance/StringGenerator.java b/PerformanceTests/Common/src/main/java/de/greenrobot/performance/StringGenerator.java
new file mode 100644
index 00000000..8b19d819
--- /dev/null
+++ b/PerformanceTests/Common/src/main/java/de/greenrobot/performance/StringGenerator.java
@@ -0,0 +1,57 @@
+package de.greenrobot.performance;
+
+import java.util.Random;
+import org.apache.commons.lang3.RandomStringUtils;
+
+/**
+ * Helper class to generate a pre-determined set of random strings.
+ */
+public class StringGenerator {
+
+    // Fixed seed so we generate the same set of strings every time.
+    public static final long SEED = -2662502316022774L;
+    private static final int MIN_LENGTH = 5;
+    private static final int MAX_LENGTH = 500;
+    // limit to a fixed set of chars
+    private static final char[] CHARS = new char[] { '0', '1', '2', '3', '4', '5', '6', '7', '8',
+            '9', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p',
+            'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z' };
+
+    /**
+     * Creates the same random sequence of strings.
+     */
+    public static String[] createFixedRandomStrings(int count) {
+        String[] strings = new String[count];
+
+        Random lengthRandom = new Random();
+        lengthRandom.setSeed(SEED);
+
+        Random stringRandom = new Random();
+        stringRandom.setSeed(SEED);
+
+        for (int i = 0; i < count; i++) {
+            int nextLength = lengthRandom.nextInt(MAX_LENGTH - MIN_LENGTH - 1);
+            nextLength += MIN_LENGTH;
+            strings[i] = RandomStringUtils.random(nextLength, 0, CHARS.length, true, true, CHARS,
+                    stringRandom);
+        }
+        return strings;
+    }
+
+    /**
+     * Creates the same random sequence of indexes. To be used to select strings by {@link
+     * #createFixedRandomStrings(int)}.
+     */
+    public static int[] getFixedRandomIndices(int count, int maxIndex) {
+        int[] indices = new int[count];
+
+        Random random = new Random();
+        random.setSeed(StringGenerator.SEED);
+
+        for (int i = 0; i < count; i++) {
+            indices[i] = random.nextInt(maxIndex + 1);
+        }
+
+        return indices;
+    }
+}
diff --git a/PerformanceTests/Couchbase/build.gradle b/PerformanceTests/Couchbase/build.gradle
index 9403d1d9..5f4a9048 100644
--- a/PerformanceTests/Couchbase/build.gradle
+++ b/PerformanceTests/Couchbase/build.gradle
@@ -33,5 +33,6 @@ android {
 }
 
 dependencies {
+    androidTestCompile project(':PerformanceTests:Common')
     androidTestCompile 'com.couchbase.lite:couchbase-lite-android:1.1.0'
 }
diff --git a/PerformanceTests/Couchbase/src/androidTest/java/de/greenrobot/performance/couchbase/PerformanceTestCouchbase.java b/PerformanceTests/Couchbase/src/androidTest/java/de/greenrobot/performance/couchbase/PerformanceTestCouchbase.java
index 643d8c92..a004cd8f 100644
--- a/PerformanceTests/Couchbase/src/androidTest/java/de/greenrobot/performance/couchbase/PerformanceTestCouchbase.java
+++ b/PerformanceTests/Couchbase/src/androidTest/java/de/greenrobot/performance/couchbase/PerformanceTestCouchbase.java
@@ -6,11 +6,15 @@
 import com.couchbase.lite.CouchbaseLiteException;
 import com.couchbase.lite.Database;
 import com.couchbase.lite.Document;
+import com.couchbase.lite.Emitter;
 import com.couchbase.lite.Manager;
+import com.couchbase.lite.Mapper;
 import com.couchbase.lite.Query;
 import com.couchbase.lite.QueryEnumerator;
 import com.couchbase.lite.QueryRow;
+import com.couchbase.lite.View;
 import com.couchbase.lite.android.AndroidContext;
+import de.greenrobot.performance.StringGenerator;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.HashMap;
@@ -25,7 +29,8 @@
 
     private static final String TAG = "PerfTestCouchbase";
 
-    private static final int BATCH_SIZE = 1000;
+    private static final int BATCH_SIZE = 10000;
+    private static final int QUERY_COUNT = 1000;
     private static final int RUNS = 8;
 
     private static final String DB_NAME = "couchbase-test";
@@ -59,6 +64,74 @@ protected void tearDown() throws Exception {
         super.tearDown();
     }
 
+    public void testIndexedStringEntityQuery() throws CouchbaseLiteException {
+        //noinspection PointlessBooleanExpression
+        if (!BuildConfig.RUN_PERFORMANCE_TESTS) {
+            Log.d(TAG, "Performance tests are disabled.");
+            return;
+        }
+        Log.d(TAG, "--------Indexed Queries: Start");
+
+        // set up index on string property
+        View indexedStringView = database.getView("indexedStringView");
+        indexedStringView.setMap(new Mapper() {
+            @Override
+            public void map(Map<String, Object> document, Emitter emitter) {
+                String indexedString = (String) document.get("indexedString");
+                // only need an index of strings mapped to the document, so provide no value
+                emitter.emit(indexedString, null);
+            }
+        }, "1");
+        Log.d(TAG, "Set up view.");
+
+        for (int i = 0; i < RUNS; i++) {
+            Log.d(TAG, "----Run " + (i + 1) + " of " + RUNS);
+            doIndexedStringEntityQuery(indexedStringView);
+        }
+
+        Log.d(TAG, "--------Indexed Queries: End");
+    }
+
+    private void doIndexedStringEntityQuery(View indexedStringView) throws CouchbaseLiteException {
+        // create entities
+        String[] fixedRandomStrings = StringGenerator.createFixedRandomStrings(BATCH_SIZE);
+        database.beginTransaction();
+        for (int i = 0; i < BATCH_SIZE; i++) {
+            Document entity = database.getDocument(String.valueOf(i));
+            Map<String, Object> properties = new HashMap<>();
+            properties.put("indexedString", fixedRandomStrings[i]);
+            entity.putProperties(properties);
+        }
+        database.endTransaction(true);
+        Log.d(TAG, "Built and inserted entities.");
+
+        // query for entities by indexed string at random
+        int[] randomIndices = StringGenerator.getFixedRandomIndices(QUERY_COUNT, BATCH_SIZE - 1);
+
+        long start = System.currentTimeMillis();
+        for (int i = 0; i < QUERY_COUNT; i++) {
+            int nextIndex = randomIndices[i];
+            List<Object> keyToQuery = new ArrayList<>(1);
+            keyToQuery.add(fixedRandomStrings[nextIndex]);
+
+            Query query = indexedStringView.createQuery();
+            query.setKeys(keyToQuery);
+            QueryEnumerator result = query.run();
+            while (result.hasNext()) {
+                QueryRow row = result.next();
+                //noinspection unused
+                Document document = row.getDocument();
+            }
+        }
+        long time = System.currentTimeMillis() - start;
+        Log.d(TAG,
+                "Queried for " + QUERY_COUNT + " of " + BATCH_SIZE + " indexed entities in " + time
+                        + " ms.");
+
+        // delete all entities
+        deleteAll();
+    }
+
     public void testPerformance() throws Exception {
         //noinspection PointlessBooleanExpression
         if (!BuildConfig.RUN_PERFORMANCE_TESTS) {
@@ -78,28 +151,33 @@ protected void runTests(int entityCount) throws Exception {
 
         long start, time;
 
-        // In Couchbase there is no such thing as batching,
-        // each document has to be created on its own.
-        // Hence we can only measure one-by-one creation time.
-
         // precreate property maps for documents
         List<Map<String, Object>> maps = new ArrayList<>(entityCount);
         for (int i = 0; i < entityCount; i++) {
             maps.add(createDocumentMap(i));
         }
+        System.gc();
+
+        runOneByOne(maps, entityCount / 10);
+
+        System.gc();
+        deleteAll();
 
         start = System.currentTimeMillis();
         List<Document> documents = new ArrayList<>(entityCount);
+        database.beginTransaction();
         for (int i = 0; i < entityCount; i++) {
             // use our own ids (use .createDocument() for random UUIDs)
             Document document = database.getDocument(String.valueOf(i));
             document.putProperties(maps.get(i));
             documents.add(document);
         }
+        database.endTransaction(true);
         time = System.currentTimeMillis() - start;
-        Log.d(TAG, "Created (one-by-one) " + documents.size() + " entities in " + time + " ms");
+        Log.d(TAG, "Created (batch) " + BATCH_SIZE + " entities in " + time + " ms");
 
         start = System.currentTimeMillis();
+        database.beginTransaction();
         for (int i = 0; i < entityCount; i++) {
             Document document = documents.get(i);
             Map<String, Object> updatedProperties = new HashMap<>();
@@ -108,8 +186,9 @@ protected void runTests(int entityCount) throws Exception {
             updatedProperties.putAll(maps.get(i));
             document.putProperties(updatedProperties);
         }
+        database.endTransaction(true);
         time = System.currentTimeMillis() - start;
-        Log.d(TAG, "Updated (one-by-one) " + documents.size() + " entities in " + time + " ms");
+        Log.d(TAG, "Updated (batch) " + BATCH_SIZE + " entities in " + time + " ms");
 
         start = System.currentTimeMillis();
         List<Document> reloaded = new ArrayList<>();
@@ -144,15 +223,45 @@ protected void runTests(int entityCount) throws Exception {
         Log.d(TAG, "---------------End: " + entityCount);
     }
 
+    private void runOneByOne(List<Map<String, Object>> maps, int count)
+            throws CouchbaseLiteException {
+        long start;
+        long time;
+        start = System.currentTimeMillis();
+        List<Document> documents = new ArrayList<>(count);
+        for (int i = 0; i < count; i++) {
+            // use our own ids (use .createDocument() for random UUIDs)
+            Document document = database.getDocument(String.valueOf(i));
+            document.putProperties(maps.get(i));
+            documents.add(document);
+        }
+        time = System.currentTimeMillis() - start;
+        Log.d(TAG, "Inserted (one-by-one) " + count + " entities in " + time + " ms");
+
+        start = System.currentTimeMillis();
+        for (int i = 0; i < count; i++) {
+            Document document = documents.get(i);
+            Map<String, Object> updatedProperties = new HashMap<>();
+            // copy existing properties to get _rev property
+            updatedProperties.putAll(document.getProperties());
+            updatedProperties.putAll(maps.get(i));
+            document.putProperties(updatedProperties);
+        }
+        time = System.currentTimeMillis() - start;
+        Log.d(TAG, "Updated (one-by-one) " + count + " entities in " + time + " ms");
+    }
+
     protected void deleteAll() throws CouchbaseLiteException {
         long start = System.currentTimeMillis();
         // query all documents, mark them as deleted
         Query query = database.createAllDocumentsQuery();
         QueryEnumerator result = query.run();
+        database.beginTransaction();
         while (result.hasNext()) {
             QueryRow row = result.next();
-            row.getDocument().delete();
+            row.getDocument().purge();
         }
+        database.endTransaction(true);
         long time = System.currentTimeMillis() - start;
         Log.d(TAG, "Deleted all entities in " + time + " ms");
     }
diff --git a/PerformanceTests/Cupboard/build.gradle b/PerformanceTests/Cupboard/build.gradle
index e6f7e7e8..07e6977f 100644
--- a/PerformanceTests/Cupboard/build.gradle
+++ b/PerformanceTests/Cupboard/build.gradle
@@ -26,5 +26,6 @@ android {
 }
 
 dependencies {
+    androidTestCompile project(':PerformanceTests:Common')
     androidTestCompile 'nl.qbusict:cupboard:2.1.2'
 }
diff --git a/PerformanceTests/Cupboard/src/androidTest/java/de/greenrobot/performance/cupboard/DbHelper.java b/PerformanceTests/Cupboard/src/androidTest/java/de/greenrobot/performance/cupboard/DbHelper.java
deleted file mode 100644
index 6275e4ca..00000000
--- a/PerformanceTests/Cupboard/src/androidTest/java/de/greenrobot/performance/cupboard/DbHelper.java
+++ /dev/null
@@ -1,32 +0,0 @@
-package de.greenrobot.performance.cupboard;
-
-import android.content.Context;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteOpenHelper;
-
-import static nl.qbusict.cupboard.CupboardFactory.cupboard;
-
-public class DbHelper extends SQLiteOpenHelper {
-
-    static {
-        // register our models
-        cupboard().register(SimpleEntityNotNull.class);
-    }
-
-    public DbHelper(Context context, String databaseName, int databaseVersion) {
-        super(context, databaseName, null, databaseVersion);
-    }
-
-    @Override
-    public void onCreate(SQLiteDatabase db) {
-        // this will ensure that all tables are created
-        cupboard().withDatabase(db).createTables();
-    }
-
-    @Override
-    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
-        // this will upgrade tables, adding columns and new tables.
-        // Note that existing columns will not be converted
-        cupboard().withDatabase(db).upgradeTables();
-    }
-}
diff --git a/PerformanceTests/Cupboard/src/androidTest/java/de/greenrobot/performance/cupboard/IndexedStringEntity.java b/PerformanceTests/Cupboard/src/androidTest/java/de/greenrobot/performance/cupboard/IndexedStringEntity.java
new file mode 100644
index 00000000..9cdaf006
--- /dev/null
+++ b/PerformanceTests/Cupboard/src/androidTest/java/de/greenrobot/performance/cupboard/IndexedStringEntity.java
@@ -0,0 +1,15 @@
+package de.greenrobot.performance.cupboard;
+
+import nl.qbusict.cupboard.annotation.Index;
+
+/**
+ * Simple entity with a string property that is indexed.
+ */
+public class IndexedStringEntity {
+
+    public Long _id;
+
+    @Index
+    public String indexedString;
+
+}
diff --git a/PerformanceTests/Cupboard/src/androidTest/java/de/greenrobot/performance/cupboard/PerformanceTestCupboard.java b/PerformanceTests/Cupboard/src/androidTest/java/de/greenrobot/performance/cupboard/PerformanceTestCupboard.java
index 2b9f9626..896a085b 100644
--- a/PerformanceTests/Cupboard/src/androidTest/java/de/greenrobot/performance/cupboard/PerformanceTestCupboard.java
+++ b/PerformanceTests/Cupboard/src/androidTest/java/de/greenrobot/performance/cupboard/PerformanceTestCupboard.java
@@ -1,28 +1,34 @@
 package de.greenrobot.performance.cupboard;
 
 import android.app.Application;
+import android.content.Context;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteOpenHelper;
 import android.test.ApplicationTestCase;
 import android.util.Log;
-
+import de.greenrobot.performance.StringGenerator;
 import java.sql.SQLException;
 import java.util.ArrayList;
 import java.util.List;
-
+import nl.qbusict.cupboard.Cupboard;
+import nl.qbusict.cupboard.CupboardBuilder;
 import nl.qbusict.cupboard.DatabaseCompartment;
 
-import static nl.qbusict.cupboard.CupboardFactory.cupboard;
-
+/**
+ * https://bitbucket.org/qbusict/cupboard/wiki/GettingStarted
+ */
 public class PerformanceTestCupboard extends ApplicationTestCase<Application> {
 
-    private static final String TAG = "PerformanceTestCupboard";
+    private static final String TAG = "PerfTestCupboard";
 
     private static final int BATCH_SIZE = 10000;
+    private static final int QUERY_COUNT = 1000;
     private static final int RUNS = 8;
 
     private static final String DATABASE_NAME = "cupboard.db";
     private static final int DATABASE_VERSION = 1;
 
-    private DatabaseCompartment database;
+    private Cupboard cupboard;
 
     public PerformanceTestCupboard() {
         super(Application.class);
@@ -31,60 +37,117 @@ public PerformanceTestCupboard() {
     @Override
     protected void setUp() throws Exception {
         super.setUp();
+
         createApplication();
-        prepareDb();
+        setUpCupboard();
     }
 
-    protected void prepareDb() {
-        DbHelper dbHelper = new DbHelper(getApplication(), DATABASE_NAME, DATABASE_VERSION);
-        database = cupboard().withDatabase(dbHelper.getWritableDatabase());
+    private void setUpCupboard() {
+        cupboard = new CupboardBuilder().useAnnotations().build();
     }
 
     @Override
     protected void tearDown() throws Exception {
         getApplication().deleteDatabase(DATABASE_NAME);
+
         super.tearDown();
     }
 
-    public void testPerformance() throws Exception {
+    public void testIndexedStringEntityQuery() {
         //noinspection PointlessBooleanExpression
         if (!BuildConfig.RUN_PERFORMANCE_TESTS) {
             Log.d(TAG, "Performance tests are disabled.");
             return;
         }
+        Log.d(TAG, "--------Indexed Queries: Start");
 
-        runTests(100); // Warmup
+        // set up database
+        cupboard.register(IndexedStringEntity.class);
+        DbHelper dbHelper = new DbHelper(getApplication(), DATABASE_NAME, DATABASE_VERSION);
+        DatabaseCompartment database = cupboard.withDatabase(dbHelper.getWritableDatabase());
+        Log.d(TAG, "Set up database.");
 
         for (int i = 0; i < RUNS; i++) {
-            deleteAll();
-            runTests(BATCH_SIZE);
+            Log.d(TAG, "----Run " + (i + 1) + " of " + RUNS);
+            doIndexedStringEntityQuery(database);
         }
-        deleteAll();
-        Log.d(TAG, "---------------End");
+
+        Log.d(TAG, "--------Indexed Queries: End");
     }
 
-    protected void deleteAll() {
+    public void doIndexedStringEntityQuery(DatabaseCompartment database) {
+        // create entities
+        List<IndexedStringEntity> entities = new ArrayList<>(BATCH_SIZE);
+        String[] fixedRandomStrings = StringGenerator.createFixedRandomStrings(BATCH_SIZE);
+        for (int i = 0; i < BATCH_SIZE; i++) {
+            IndexedStringEntity entity = new IndexedStringEntity();
+            entity._id = (long) i;
+            entity.indexedString = fixedRandomStrings[i];
+            entities.add(entity);
+        }
+        Log.d(TAG, "Built entities.");
+
+        // insert entities
+        database.put(entities);
+        Log.d(TAG, "Inserted entities.");
+
+        // query for entities by indexed string at random
+        int[] randomIndices = StringGenerator.getFixedRandomIndices(QUERY_COUNT, BATCH_SIZE - 1);
+
         long start = System.currentTimeMillis();
-        database.delete(SimpleEntityNotNull.class, "");
+        for (int i = 0; i < QUERY_COUNT; i++) {
+            int nextIndex = randomIndices[i];
+            //noinspection unused
+            List<IndexedStringEntity> query = database.query(
+                    IndexedStringEntity.class)
+                    .withSelection("indexedString = ?", fixedRandomStrings[nextIndex])
+                    .list();
+        }
         long time = System.currentTimeMillis() - start;
-        Log.d(TAG, "Deleted all entities in " + time + " ms");
+        Log.d(TAG,
+                "Queried for " + QUERY_COUNT + " of " + BATCH_SIZE + " indexed entities in " + time
+                        + " ms.");
+
+        // delete all entities
+        database.delete(IndexedStringEntity.class, "");
+        Log.d(TAG, "Deleted all entities.");
+    }
+
+    public void testPerformance() throws Exception {
+        //noinspection PointlessBooleanExpression
+        if (!BuildConfig.RUN_PERFORMANCE_TESTS) {
+            Log.d(TAG, "Performance tests are disabled.");
+            return;
+        }
+        Log.d(TAG, "---------------Start");
+
+        // set up database
+        cupboard.register(SimpleEntityNotNull.class);
+        DbHelper dbHelper = new DbHelper(getApplication(), DATABASE_NAME, DATABASE_VERSION);
+        DatabaseCompartment database = cupboard.withDatabase(dbHelper.getWritableDatabase());
+
+        for (int i = 0; i < RUNS; i++) {
+            runTests(database, BATCH_SIZE);
+        }
+
+        Log.d(TAG, "---------------End");
     }
 
-    protected void runTests(int entityCount) throws Exception {
+    private void runTests(DatabaseCompartment database, int entityCount) throws Exception {
         Log.d(TAG, "---------------Start: " + entityCount);
 
         long start, time;
 
-        final List<SimpleEntityNotNull> list = new ArrayList<SimpleEntityNotNull>();
+        final List<SimpleEntityNotNull> list = new ArrayList<>();
         for (int i = 0; i < entityCount; i++) {
             list.add(SimpleEntityNotNullHelper.createEntity((long) i));
         }
         System.gc();
 
-        runOneByOne(list, entityCount / 10);
+        runOneByOne(database, list, entityCount / 10);
 
         System.gc();
-        deleteAll();
+        deleteAll(database);
 
         start = System.currentTimeMillis();
         database.put(list);
@@ -118,11 +181,22 @@ protected void runTests(int entityCount) throws Exception {
         time = System.currentTimeMillis() - start;
 
         Log.d(TAG, "Accessed properties of " + reloaded.size() + " entities in " + time + " ms");
+
+        deleteAll(database);
+
         System.gc();
         Log.d(TAG, "---------------End: " + entityCount);
     }
 
-    protected void runOneByOne(List<SimpleEntityNotNull> list, int count) throws SQLException {
+    private void deleteAll(DatabaseCompartment database) {
+        long start = System.currentTimeMillis();
+        database.delete(SimpleEntityNotNull.class, "");
+        long time = System.currentTimeMillis() - start;
+        Log.d(TAG, "Deleted all entities in " + time + " ms");
+    }
+
+    private void runOneByOne(DatabaseCompartment database, List<SimpleEntityNotNull> list,
+            int count) throws SQLException {
         long start;
         long time;
         start = System.currentTimeMillis();
@@ -139,4 +213,20 @@ protected void runOneByOne(List<SimpleEntityNotNull> list, int count) throws SQL
         time = System.currentTimeMillis() - start;
         Log.d(TAG, "Updated (one-by-one) " + count + " entities in " + time + " ms");
     }
+
+    private class DbHelper extends SQLiteOpenHelper {
+        public DbHelper(Context context, String name, int version) {
+            super(context, name, null, version);
+        }
+
+        @Override
+        public void onCreate(SQLiteDatabase db) {
+            cupboard.withDatabase(db).createTables();
+        }
+
+        @Override
+        public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+            cupboard.withDatabase(db).upgradeTables();
+        }
+    }
 }
diff --git a/PerformanceTests/Firebase/build.gradle b/PerformanceTests/Firebase/build.gradle
index 0f98c8d1..1382041c 100644
--- a/PerformanceTests/Firebase/build.gradle
+++ b/PerformanceTests/Firebase/build.gradle
@@ -32,5 +32,6 @@ android {
 }
 
 dependencies {
+    androidTestCompile project(':PerformanceTests:Common')
     androidTestCompile 'com.firebase:firebase-client-android:2.3.1'
 }
diff --git a/PerformanceTests/Firebase/src/androidTest/java/de/greenrobot/performance/firebase/IndexedStringEntity.java b/PerformanceTests/Firebase/src/androidTest/java/de/greenrobot/performance/firebase/IndexedStringEntity.java
new file mode 100644
index 00000000..c2e2cc20
--- /dev/null
+++ b/PerformanceTests/Firebase/src/androidTest/java/de/greenrobot/performance/firebase/IndexedStringEntity.java
@@ -0,0 +1,13 @@
+package de.greenrobot.performance.firebase;
+
+
+/**
+ * Simple entity with a string property that is indexed.
+ */
+public class IndexedStringEntity {
+
+    public long _id;
+
+    public String indexedString;
+
+}
diff --git a/PerformanceTests/Firebase/src/androidTest/java/de/greenrobot/performance/firebase/PerformanceTestFirebase.java b/PerformanceTests/Firebase/src/androidTest/java/de/greenrobot/performance/firebase/PerformanceTestFirebase.java
index 0765743f..7d8643de 100644
--- a/PerformanceTests/Firebase/src/androidTest/java/de/greenrobot/performance/firebase/PerformanceTestFirebase.java
+++ b/PerformanceTests/Firebase/src/androidTest/java/de/greenrobot/performance/firebase/PerformanceTestFirebase.java
@@ -3,16 +3,22 @@
 import android.app.Application;
 import android.test.ApplicationTestCase;
 import android.util.Log;
+import com.firebase.client.ChildEventListener;
 import com.firebase.client.DataSnapshot;
 import com.firebase.client.Firebase;
 import com.firebase.client.FirebaseError;
+import com.firebase.client.Query;
 import com.firebase.client.ValueEventListener;
+import de.greenrobot.performance.StringGenerator;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 
 /**
+ * Make sure to run the performance tests while in AIRPLANE MODE, as
+ * <code>Firebase.goOffline()</code> does not seem to work as expected.
+ *
  * https://www.firebase.com/docs/android/guide/
  */
 public class PerformanceTestFirebase extends ApplicationTestCase<Application> {
@@ -20,12 +26,12 @@
     private static final String TAG = "PerfTestFirebase";
 
     private static final int BATCH_SIZE = 10000;
+    // reduced query count as local datastore can not be indexed, resulting in low performance
+    private static final int QUERY_COUNT = 100;
     private static final int RUNS = 8;
 
     private Firebase rootFirebaseRef;
-    private Firebase simpleEntityRef;
 
-    private CountDownLatch loadLock;
     private List<SimpleEntityNotNull> reloaded;
 
     public PerformanceTestFirebase() {
@@ -49,7 +55,6 @@ private void setupFirebase() {
         Firebase.goOffline();
 
         rootFirebaseRef = new Firebase("https://luminous-inferno-2264.firebaseio.com");
-        simpleEntityRef = rootFirebaseRef.child("simpleEntities");
     }
 
     @Override
@@ -62,28 +67,115 @@ protected void tearDown() throws Exception {
         super.tearDown();
     }
 
-    public void testPerformance() throws Exception {
+    public void testIndexedStringEntityQuery() throws InterruptedException {
+        // Firebase does not support defining indexes locally, only in the cloud component
+        // We measure the local datastore query time anyhow, but WITHOUT INDEXES.
+
         //noinspection PointlessBooleanExpression
         if (!BuildConfig.RUN_PERFORMANCE_TESTS) {
             Log.d(TAG, "Performance tests are disabled.");
             return;
         }
+        Log.d(TAG, "--------Indexed Queries: Start");
+
+        // set up node for entities
+        Firebase entityRef = rootFirebaseRef.child("indexedStringEntity");
 
-        Log.d(TAG, "---------------Start");
         for (int i = 0; i < RUNS; i++) {
-            runTests(BATCH_SIZE);
+            Log.d(TAG, "----Run " + (i + 1) + " of " + RUNS);
+            doIndexedStringEntityQuery(entityRef);
         }
-        Log.d(TAG, "---------------End");
+
+        Log.d(TAG, "--------Indexed Queries: End");
     }
 
-    protected void deleteAll() {
+    public void doIndexedStringEntityQuery(Firebase entityRef) throws InterruptedException {
+        // create entities
+        List<IndexedStringEntity> entities = new ArrayList<>(BATCH_SIZE);
+        String[] fixedRandomStrings = StringGenerator.createFixedRandomStrings(BATCH_SIZE);
+        for (int i = 0; i < BATCH_SIZE; i++) {
+            IndexedStringEntity entity = new IndexedStringEntity();
+            entity._id = (long) i;
+            entity.indexedString = fixedRandomStrings[i];
+            entities.add(entity);
+        }
+        Log.d(TAG, "Built entities.");
+
+        // insert entities
+        entityRef.setValue(entities);
+        Log.d(TAG, "Inserted entities.");
+
+        // query for entities by indexed string at random
+        int[] randomIndices = StringGenerator.getFixedRandomIndices(QUERY_COUNT, BATCH_SIZE - 1);
+
         long start = System.currentTimeMillis();
-        simpleEntityRef.removeValue();
+        for (int i = 0; i < QUERY_COUNT; i++) {
+            int nextIndex = randomIndices[i];
+
+            final CountDownLatch queryLock = new CountDownLatch(1);
+            Query query = entityRef.orderByChild("indexedString");
+            query.equalTo(fixedRandomStrings[nextIndex]);
+            ChildEventListener queryEventListener = new ChildEventListener() {
+                @Override
+                public void onChildAdded(DataSnapshot dataSnapshot, String s) {
+                    //noinspection unused
+                    IndexedStringEntity entity = dataSnapshot.getValue(IndexedStringEntity.class);
+                    queryLock.countDown();
+                }
+
+                @Override
+                public void onChildChanged(DataSnapshot dataSnapshot, String s) {
+
+                }
+
+                @Override
+                public void onChildRemoved(DataSnapshot dataSnapshot) {
+
+                }
+
+                @Override
+                public void onChildMoved(DataSnapshot dataSnapshot, String s) {
+
+                }
+
+                @Override
+                public void onCancelled(FirebaseError firebaseError) {
+
+                }
+            };
+            query.addChildEventListener(queryEventListener);
+            // wait until there are query results
+            queryLock.await();
+            query.removeEventListener(queryEventListener);
+        }
         long time = System.currentTimeMillis() - start;
-        Log.d(TAG, "Deleted all entities in " + time + " ms");
+        Log.d(TAG,
+                "Queried for " + QUERY_COUNT + " of " + BATCH_SIZE + " indexed entities in " + time
+                        + " ms.");
+
+        // delete all entities
+        entityRef.setValue(null);
+        Log.d(TAG, "Deleted all entities.");
+    }
+
+    public void testPerformance() throws Exception {
+        //noinspection PointlessBooleanExpression
+        if (!BuildConfig.RUN_PERFORMANCE_TESTS) {
+            Log.d(TAG, "Performance tests are disabled.");
+            return;
+        }
+        Log.d(TAG, "---------------Start");
+
+        // set up node for entities
+        Firebase simpleEntityRef = rootFirebaseRef.child("simpleEntities");
+
+        for (int i = 0; i < RUNS; i++) {
+            runTests(simpleEntityRef, BATCH_SIZE);
+        }
+        Log.d(TAG, "---------------End");
     }
 
-    protected void runTests(final int entityCount) throws Exception {
+    protected void runTests(Firebase simpleEntityRef, final int entityCount) throws Exception {
         Log.d(TAG, "---------------Start: " + entityCount);
 
         long start, time;
@@ -94,10 +186,10 @@ protected void runTests(final int entityCount) throws Exception {
         }
         System.gc();
 
-        runOneByOne(list, entityCount / 10);
+        runOneByOne(simpleEntityRef, list, entityCount / 10);
 
         System.gc();
-        deleteAll();
+        deleteAll(simpleEntityRef);
 
         // there is no such thing as batch storing of items in Firebase
         // so store the whole list of entities at once
@@ -113,7 +205,7 @@ protected void runTests(final int entityCount) throws Exception {
         time = System.currentTimeMillis() - start;
         Log.d(TAG, "Updated (batch) " + list.size() + " entities in " + time + " ms");
 
-        loadLock = new CountDownLatch(1);
+        final CountDownLatch loadLock = new CountDownLatch(1);
         start = System.currentTimeMillis();
         reloaded = new ArrayList<>(entityCount);
         simpleEntityRef.addListenerForSingleValueEvent(new ValueEventListener() {
@@ -151,13 +243,14 @@ public void onCancelled(FirebaseError firebaseError) {
         time = System.currentTimeMillis() - start;
         Log.d(TAG, "Accessed properties of " + childrenCount + " entities in " + time + " ms");
 
-        deleteAll();
+        deleteAll(simpleEntityRef);
 
         System.gc();
         Log.d(TAG, "---------------End: " + entityCount);
     }
 
-    protected void runOneByOne(List<SimpleEntityNotNull> list, int count) {
+    protected void runOneByOne(Firebase simpleEntityRef, List<SimpleEntityNotNull> list,
+            int count) {
         long start;
         long time;
         start = System.currentTimeMillis();
@@ -178,4 +271,11 @@ protected void runOneByOne(List<SimpleEntityNotNull> list, int count) {
         time = System.currentTimeMillis() - start;
         Log.d(TAG, "Updated (one-by-one) " + count + " entities in " + time + " ms");
     }
+
+    protected void deleteAll(Firebase simpleEntityRef) throws InterruptedException {
+        long start = System.currentTimeMillis();
+        simpleEntityRef.setValue(null);
+        long time = System.currentTimeMillis() - start;
+        Log.d(TAG, "Deleted all entities in " + time + " ms");
+    }
 }
diff --git a/PerformanceTests/OrmLite/build.gradle b/PerformanceTests/OrmLite/build.gradle
index c97392e6..c7591751 100644
--- a/PerformanceTests/OrmLite/build.gradle
+++ b/PerformanceTests/OrmLite/build.gradle
@@ -26,5 +26,6 @@ android {
 }
 
 dependencies {
+    androidTestCompile project(':PerformanceTests:Common')
     androidTestCompile 'com.j256.ormlite:ormlite-android:4.48'
 }
diff --git a/PerformanceTests/OrmLite/src/androidTest/java/de/greenrobot/performance/ormlite/DbHelper.java b/PerformanceTests/OrmLite/src/androidTest/java/de/greenrobot/performance/ormlite/DbHelper.java
index e14c25d7..f4842747 100644
--- a/PerformanceTests/OrmLite/src/androidTest/java/de/greenrobot/performance/ormlite/DbHelper.java
+++ b/PerformanceTests/OrmLite/src/androidTest/java/de/greenrobot/performance/ormlite/DbHelper.java
@@ -2,38 +2,42 @@
 
 import android.content.Context;
 import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteOpenHelper;
+import com.j256.ormlite.android.apptools.OrmLiteSqliteOpenHelper;
+import com.j256.ormlite.support.ConnectionSource;
+import com.j256.ormlite.table.TableUtils;
+import java.sql.SQLException;
 
-public class DbHelper extends SQLiteOpenHelper {
+/**
+ * https://github.com/j256/ormlite-examples/blob/master/android/HelloAndroid/src/com/example/helloandroid/DatabaseHelper.java
+ */
+public class DbHelper extends OrmLiteSqliteOpenHelper {
 
     public DbHelper(Context context, String name) {
         super(context, name, null, 1);
     }
 
     @Override
-    public void onCreate(SQLiteDatabase db) {
-        String sql = "CREATE TABLE SIMPLE_ENTITY_NOT_NULL (" + //
-                "_id INTEGER PRIMARY KEY NOT NULL ," + // 0
-                "SIMPLE_BOOLEAN INTEGER NOT NULL ," + // 1
-                "SIMPLE_BYTE INTEGER NOT NULL ," + // 2
-                "SIMPLE_SHORT INTEGER NOT NULL ," + // 3
-                "SIMPLE_INT INTEGER NOT NULL ," + // 4
-                "SIMPLE_LONG INTEGER NOT NULL ," + // 5
-                "SIMPLE_FLOAT REAL NOT NULL ," + // 6
-                "SIMPLE_DOUBLE REAL NOT NULL ," + // 7
-                "SIMPLE_STRING TEXT NOT NULL ," + // 8
-                "SIMPLE_BYTE_ARRAY BLOB NOT NULL )"; // 9
-        db.execSQL(sql);
-        
-        String sql2 = "CREATE TABLE MINIMAL_ENTITY (_id INTEGER PRIMARY KEY)";
-        db.execSQL(sql2);
+    public void onCreate(SQLiteDatabase sqLiteDatabase, ConnectionSource connectionSource) {
+        try {
+            TableUtils.createTable(connectionSource, IndexedStringEntity.class);
+            TableUtils.createTable(connectionSource, SimpleEntityNotNull.class);
+            TableUtils.createTable(connectionSource, MinimalEntity.class);
+        } catch (SQLException e) {
+            throw new RuntimeException(e);
+        }
     }
 
     @Override
-    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
-        db.execSQL("DROP TABLE IF EXISTS SIMPLE_ENTITY_NOT_NULL");
-        db.execSQL("DROP TABLE IF EXISTS MINIMAL_ENTITY");
-        onCreate(db);
+    public void onUpgrade(SQLiteDatabase db, ConnectionSource connectionSource, int oldVersion,
+            int newVersion) {
+        try {
+            TableUtils.dropTable(connectionSource, IndexedStringEntity.class, true);
+            TableUtils.dropTable(connectionSource, SimpleEntityNotNull.class, true);
+            TableUtils.dropTable(connectionSource, MinimalEntity.class, true);
+            // after we drop the old databases, we create the new ones
+            onCreate(db, connectionSource);
+        } catch (SQLException e) {
+            throw new RuntimeException(e);
+        }
     }
-
 }
diff --git a/PerformanceTests/OrmLite/src/androidTest/java/de/greenrobot/performance/ormlite/IndexedStringEntity.java b/PerformanceTests/OrmLite/src/androidTest/java/de/greenrobot/performance/ormlite/IndexedStringEntity.java
new file mode 100644
index 00000000..39834469
--- /dev/null
+++ b/PerformanceTests/OrmLite/src/androidTest/java/de/greenrobot/performance/ormlite/IndexedStringEntity.java
@@ -0,0 +1,18 @@
+package de.greenrobot.performance.ormlite;
+
+import com.j256.ormlite.field.DatabaseField;
+import com.j256.ormlite.table.DatabaseTable;
+
+/**
+ * Simple entity with a string property that is indexed.
+ */
+@DatabaseTable(tableName = "INDEXED_STRING_ENTITY")
+public class IndexedStringEntity {
+
+    @DatabaseField(id = true)
+    public Long _id;
+
+    @DatabaseField(columnName="INDEXED_STRING", index = true)
+    public String indexedString;
+
+}
diff --git a/PerformanceTests/OrmLite/src/androidTest/java/de/greenrobot/performance/ormlite/MinimalEntity.java b/PerformanceTests/OrmLite/src/androidTest/java/de/greenrobot/performance/ormlite/MinimalEntity.java
index d8e1ad59..60baa6c9 100644
--- a/PerformanceTests/OrmLite/src/androidTest/java/de/greenrobot/performance/ormlite/MinimalEntity.java
+++ b/PerformanceTests/OrmLite/src/androidTest/java/de/greenrobot/performance/ormlite/MinimalEntity.java
@@ -6,7 +6,7 @@
 @DatabaseTable(tableName = "MINIMAL_ENTITY")
 public class MinimalEntity {
 
-    @DatabaseField(id = true, columnName="_id")
+    @DatabaseField(generatedId = true, columnName="_id")
     private Long id;
 
     public Long getId() {
diff --git a/PerformanceTests/OrmLite/src/androidTest/java/de/greenrobot/performance/ormlite/PerformanceTestOrmLite.java b/PerformanceTests/OrmLite/src/androidTest/java/de/greenrobot/performance/ormlite/PerformanceTestOrmLite.java
index 7fa3069b..f2098850 100644
--- a/PerformanceTests/OrmLite/src/androidTest/java/de/greenrobot/performance/ormlite/PerformanceTestOrmLite.java
+++ b/PerformanceTests/OrmLite/src/androidTest/java/de/greenrobot/performance/ormlite/PerformanceTestOrmLite.java
@@ -1,28 +1,28 @@
 package de.greenrobot.performance.ormlite;
 
-import de.greenrobot.performance.ormlite.BuildConfig;
-import java.sql.SQLException;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.concurrent.Callable;
-
 import android.app.Application;
 import android.test.ApplicationTestCase;
 import android.util.Log;
-
-import com.j256.ormlite.android.AndroidConnectionSource;
 import com.j256.ormlite.dao.Dao;
-import com.j256.ormlite.dao.DaoManager;
+import de.greenrobot.performance.StringGenerator;
+import java.sql.SQLException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.Callable;
 
+/**
+ * http://ormlite.com/sqlite_java_android_orm.shtml https://github.com/j256/ormlite-examples
+ */
 public class PerformanceTestOrmLite extends ApplicationTestCase<Application> {
 
+    private static final String TAG = "PerfTestOrmLite";
+
     private static final int BATCH_SIZE = 10000;
+    private static final int QUERY_COUNT = 1000;
     private static final int RUNS = 8;
 
-    private Dao<SimpleEntityNotNull, Long> dao;
     private boolean inMemory;
     private DbHelper dbHelper;
-    private AndroidConnectionSource connectionSource;
 
     public PerformanceTestOrmLite() {
         super(Application.class);
@@ -32,11 +32,12 @@ public PerformanceTestOrmLite() {
     @Override
     protected void setUp() throws Exception {
         super.setUp();
+
         createApplication();
-        prepareDb();
+        setUpOrmLite();
     }
 
-    protected void prepareDb() {
+    protected void setUpOrmLite() {
         String name;
         if (inMemory) {
             name = null;
@@ -45,12 +46,6 @@ protected void prepareDb() {
             getApplication().deleteDatabase(name);
         }
         dbHelper = new DbHelper(getApplication(), name);
-        connectionSource = new AndroidConnectionSource(dbHelper);
-        try {
-            dao = DaoManager.createDao(connectionSource, SimpleEntityNotNull.class);
-        } catch (SQLException e) {
-            throw new RuntimeException(e);
-        }
     }
 
     @Override
@@ -58,45 +53,107 @@ protected void tearDown() throws Exception {
         if (!inMemory) {
             getApplication().deleteDatabase("test-db");
         }
+
         super.tearDown();
     }
 
-    public void testPerformance() throws Exception {
+    public void testIndexedStringEntityQuery() throws Exception {
         //noinspection PointlessBooleanExpression
         if (!BuildConfig.RUN_PERFORMANCE_TESTS) {
-            Log.d("DAO", "ORMLite performance tests are disabled.");
+            Log.d(TAG, "Performance tests are disabled.");
             return;
         }
+        Log.d(TAG, "--------Indexed Queries: Start");
 
-        runTests(100); // Warmup
+        // set up data access
+        final Dao<IndexedStringEntity, Long> dao = dbHelper.getDao(IndexedStringEntity.class);
+        Log.d(TAG, "Set up data access.");
 
         for (int i = 0; i < RUNS; i++) {
-            deleteAll();
-            runTests(BATCH_SIZE);
+            Log.d(TAG, "----Run " + (i + 1) + " of " + RUNS);
+            doIndexedStringEntityQuery(dao);
         }
-        deleteAll();
-        Log.d("DAO", "---------------End");
+
+        Log.d(TAG, "--------Indexed Queries: End");
     }
 
-    protected void deleteAll() {
+    public void doIndexedStringEntityQuery(final Dao<IndexedStringEntity, Long> dao)
+            throws Exception {
+        // create entities
+        final List<IndexedStringEntity> entities = new ArrayList<>(BATCH_SIZE);
+        String[] fixedRandomStrings = StringGenerator.createFixedRandomStrings(BATCH_SIZE);
+        for (int i = 0; i < BATCH_SIZE; i++) {
+            IndexedStringEntity entity = new IndexedStringEntity();
+            entity._id = (long) i;
+            entity.indexedString = fixedRandomStrings[i];
+            entities.add(entity);
+        }
+        Log.d(TAG, "Built entities.");
+
+        // insert entities
+        dao.callBatchTasks(new Callable<Void>() {
+            @Override
+            public Void call() throws Exception {
+                for (IndexedStringEntity entity : entities) {
+                    dao.create(entity);
+                }
+                return null;
+            }
+        });
+        Log.d(TAG, "Inserted entities.");
+
+        // query for entities by indexed string at random
+        int[] randomIndices = StringGenerator.getFixedRandomIndices(QUERY_COUNT, BATCH_SIZE - 1);
+
         long start = System.currentTimeMillis();
-        dbHelper.getWritableDatabase().execSQL("DELETE FROM SIMPLE_ENTITY_NOT_NULL");
+        for (int i = 0; i < QUERY_COUNT; i++) {
+            int nextIndex = randomIndices[i];
+            //noinspection unused
+            List<IndexedStringEntity> query = dao.queryBuilder()
+                    .where()
+                    .eq("INDEXED_STRING", fixedRandomStrings[nextIndex])
+                    .query();
+            // ORMLite already builds all entities when executing the query, so move on
+        }
         long time = System.currentTimeMillis() - start;
-        Log.d("DAO", "ORMLite: Deleted all entities in " + time + " ms");
+        Log.d(TAG,
+                "Queried for " + QUERY_COUNT + " of " + BATCH_SIZE + " indexed entities in " + time
+                        + " ms.");
+
+        // delete all entities
+        dbHelper.getWritableDatabase().execSQL("DELETE FROM INDEXED_STRING_ENTITY");
+        Log.d(TAG, "Deleted all entities.");
     }
 
-    protected void runTests(int entityCount) throws Exception {
-        Log.d("DAO", "---------------Start: " + entityCount);
+    public void testPerformance() throws Exception {
+        //noinspection PointlessBooleanExpression
+        if (!BuildConfig.RUN_PERFORMANCE_TESTS) {
+            Log.d(TAG, "Performance tests are disabled.");
+            return;
+        }
+        Log.d(TAG, "---------------Start");
+
+        Dao<SimpleEntityNotNull, Long> dao = dbHelper.getDao(SimpleEntityNotNull.class);
+
+        for (int i = 0; i < RUNS; i++) {
+            runTests(dao, BATCH_SIZE);
+        }
+        Log.d(TAG, "---------------End");
+    }
+
+    protected void runTests(final Dao<SimpleEntityNotNull, Long> dao, int entityCount)
+            throws Exception {
+        Log.d(TAG, "---------------Start: " + entityCount);
 
         long start, time;
 
-        final List<SimpleEntityNotNull> list = new ArrayList<SimpleEntityNotNull>();
+        final List<SimpleEntityNotNull> list = new ArrayList<>();
         for (int i = 0; i < entityCount; i++) {
             list.add(SimpleEntityNotNullHelper.createEntity((long) i));
         }
         System.gc();
 
-        runOneByOne(list, entityCount / 10);
+        runOneByOne(dao, list, entityCount / 10);
 
         System.gc();
         deleteAll();
@@ -113,7 +170,7 @@ public Void call() throws Exception {
             }
         });
         time = System.currentTimeMillis() - start;
-        Log.d("DAO", "ORMLite: Created (batch) " + list.size() + " entities in " + time + " ms");
+        Log.d(TAG, "Created (batch) " + list.size() + " entities in " + time + " ms");
 
         start = System.currentTimeMillis();
         dao.callBatchTasks(new Callable<Void>() {
@@ -127,12 +184,12 @@ public Void call() throws Exception {
             }
         });
         time = System.currentTimeMillis() - start;
-        Log.d("DAO", "ORMLite: Updated (batch) " + list.size() + " entities in " + time + " ms");
+        Log.d(TAG, "Updated (batch) " + list.size() + " entities in " + time + " ms");
 
         start = System.currentTimeMillis();
         List<SimpleEntityNotNull> reloaded = dao.queryForAll();
         time = System.currentTimeMillis() - start;
-        Log.d("DAO", "ORMLite: Loaded (batch) " + reloaded.size() + " entities in " + time + " ms");
+        Log.d(TAG, "Loaded (batch) " + reloaded.size() + " entities in " + time + " ms");
 
         start = System.currentTimeMillis();
         for (int i = 0; i < reloaded.size(); i++) {
@@ -149,14 +206,16 @@ public Void call() throws Exception {
             entity.getSimpleByteArray();
         }
         time = System.currentTimeMillis() - start;
-        Log.d("DAO", "ORMLite: Accessed properties of " + reloaded.size() + " entities in " + time
-                + " ms");
+        Log.d(TAG, "Accessed properties of " + reloaded.size() + " entities in " + time + " ms");
+
+        deleteAll();
 
         System.gc();
-        Log.d("DAO", "---------------End: " + entityCount);
+        Log.d(TAG, "---------------End: " + entityCount);
     }
 
-    protected void runOneByOne(List<SimpleEntityNotNull> list, int count) throws SQLException {
+    protected void runOneByOne(Dao<SimpleEntityNotNull, Long> dao, List<SimpleEntityNotNull> list,
+            int count) throws SQLException {
         long start;
         long time;
         start = System.currentTimeMillis();
@@ -164,27 +223,35 @@ protected void runOneByOne(List<SimpleEntityNotNull> list, int count) throws SQL
             dao.create(list.get(i));
         }
         time = System.currentTimeMillis() - start;
-        Log.d("DAO", "ORMLite: Inserted (one-by-one) " + count + " entities in " + time + " ms");
+        Log.d(TAG, "Inserted (one-by-one) " + count + " entities in " + time + " ms");
 
         start = System.currentTimeMillis();
         for (int i = 0; i < count; i++) {
             dao.update(list.get(i));
         }
         time = System.currentTimeMillis() - start;
-        Log.d("DAO", "ORMLite: Updated (one-by-one) " + count + " entities in " + time + " ms");
+        Log.d(TAG, "Updated (one-by-one) " + count + " entities in " + time + " ms");
+    }
+
+    protected void deleteAll() {
+        long start = System.currentTimeMillis();
+        dbHelper.getWritableDatabase().execSQL("DELETE FROM SIMPLE_ENTITY_NOT_NULL");
+        long time = System.currentTimeMillis() - start;
+        Log.d(TAG, "Deleted all entities in " + time + " ms");
     }
 
     public void testSemantics() {
         try {
-            Dao<MinimalEntity, Long> minimalDao = DaoManager.createDao(connectionSource,
-                    MinimalEntity.class);
+            Dao<MinimalEntity, Long> minimalDao = dbHelper.getDao(MinimalEntity.class);
             MinimalEntity data = new MinimalEntity();
             minimalDao.create(data);
-            assertNull(data.getId()); // ORMLite does not update PK after insert
+            // ORMLite does update PK after insert if set to generatedId
+            assertNotNull(data.getId());
             MinimalEntity data2 = minimalDao.queryForAll().get(0);
             MinimalEntity data3 = minimalDao.queryForId(data2.getId());
+            // ORMLite does not provide object equality
             assertNotSame(data, data2);
-            assertNotSame(data2, data3); // ORMLite does not provide object equality
+            assertNotSame(data2, data3);
             assertEquals(data2.getId(), data3.getId());
         } catch (SQLException e) {
             throw new RuntimeException(e);
diff --git a/PerformanceTests/Parse/build.gradle b/PerformanceTests/Parse/build.gradle
index 257485f9..8ffc8e4c 100644
--- a/PerformanceTests/Parse/build.gradle
+++ b/PerformanceTests/Parse/build.gradle
@@ -29,7 +29,8 @@ android {
 }
 
 dependencies {
+    androidTestCompile project(':PerformanceTests:Common')
     compile 'com.parse.bolts:bolts-android:1.2.1'
-    compile 'com.parse:parse-android:1.10.1'
+    compile 'com.parse:parse-android:1.10.2'
 }
 
diff --git a/PerformanceTests/Parse/src/androidTest/java/de/greenrobot/performance/parse/IndexedStringEntity.java b/PerformanceTests/Parse/src/androidTest/java/de/greenrobot/performance/parse/IndexedStringEntity.java
new file mode 100644
index 00000000..48f990fd
--- /dev/null
+++ b/PerformanceTests/Parse/src/androidTest/java/de/greenrobot/performance/parse/IndexedStringEntity.java
@@ -0,0 +1,23 @@
+package de.greenrobot.performance.parse;
+
+import com.parse.ParseClassName;
+import com.parse.ParseObject;
+
+/**
+ * Simple entity with a string property.
+ */
+@ParseClassName("IndexedStringEntity")
+public class IndexedStringEntity extends ParseObject {
+
+    // Parse does not seem to support manual definition of indexes, so NOT actually indexed
+    public static final String INDEXED_STRING = "indexedString";
+
+    public String getIndexedString() {
+        return getString(INDEXED_STRING);
+    }
+
+    public void setIndexedString(String value) {
+        put(INDEXED_STRING, value);
+    }
+
+}
diff --git a/PerformanceTests/Parse/src/androidTest/java/de/greenrobot/performance/parse/PerformanceTestParse.java b/PerformanceTests/Parse/src/androidTest/java/de/greenrobot/performance/parse/PerformanceTestParse.java
index 477c42fb..8b876a15 100644
--- a/PerformanceTests/Parse/src/androidTest/java/de/greenrobot/performance/parse/PerformanceTestParse.java
+++ b/PerformanceTests/Parse/src/androidTest/java/de/greenrobot/performance/parse/PerformanceTestParse.java
@@ -9,6 +9,7 @@
 import com.parse.ParseObject;
 import com.parse.ParseQuery;
 import com.parse.ParseUser;
+import de.greenrobot.performance.StringGenerator;
 import java.util.ArrayList;
 import java.util.List;
 
@@ -19,7 +20,10 @@
 
     private static final String TAG = "PerfTestParse";
 
-    private static final int BATCH_SIZE = 10000;
+    // reduced batch size due to memory leak when pinning (of bolts.Task?)
+    private static final int BATCH_SIZE = 1000;
+    // reduced query count due to slow performance
+    private static final int QUERY_COUNT = 100;
     private static final int RUNS = 8;
 
     public PerformanceTestParse() {
@@ -55,30 +59,87 @@ private void setupParse() {
         ParseACL.setDefaultACL(defaultACL, true);
     }
 
-    public void testPerformance() throws Exception {
+    public void testIndexedStringEntityQuery() throws ParseException {
+        // According to the documentation, Parse does NOT support defining indexes manually
+        // or for the local datastore.
+        // We still are going to determine query performance WITHOUT AN INDEX.
+
+        //noinspection PointlessBooleanExpression
+        if (!BuildConfig.RUN_PERFORMANCE_TESTS) {
+            Log.d(TAG, "Performance tests are disabled.");
+            return;
+        }
+        Log.d(TAG, "--------Indexed Queries: Start");
+
         // set up parse inside of test
         // setting it up in setUp() breaks Parse, as it keeps its init state between tests
         // in hidden ParsePlugins
+        ParseObject.registerSubclass(IndexedStringEntity.class);
         setupParse();
 
+        for (int i = 0; i < RUNS; i++) {
+            Log.d(TAG, "----Run " + (i + 1) + " of " + RUNS);
+            doIndexedStringEntityQuery();
+        }
+
+        Log.d(TAG, "--------Indexed Queries: End");
+    }
+
+    private void doIndexedStringEntityQuery() throws ParseException {
+        // create entities
+        List<IndexedStringEntity> entities = new ArrayList<>(BATCH_SIZE);
+        String[] fixedRandomStrings = StringGenerator.createFixedRandomStrings(BATCH_SIZE);
+        for (int i = 0; i < BATCH_SIZE; i++) {
+            IndexedStringEntity entity = new IndexedStringEntity();
+            entity.setIndexedString(fixedRandomStrings[i]);
+            entities.add(entity);
+        }
+        Log.d(TAG, "Built entities.");
+
+        // insert entities
+        ParseObject.pinAll(entities);
+        Log.d(TAG, "Inserted entities.");
+
+        // query for entities by indexed string at random
+        int[] randomIndices = StringGenerator.getFixedRandomIndices(QUERY_COUNT, BATCH_SIZE - 1);
+
+        long start = System.currentTimeMillis();
+        for (int i = 0; i < QUERY_COUNT; i++) {
+            int nextIndex = randomIndices[i];
+
+            ParseQuery<IndexedStringEntity> query = ParseQuery.getQuery(IndexedStringEntity.class);
+            query.whereEqualTo(IndexedStringEntity.INDEXED_STRING, fixedRandomStrings[nextIndex]);
+            //noinspection unused
+            List<IndexedStringEntity> result = query.find();
+        }
+        long time = System.currentTimeMillis() - start;
+        Log.d(TAG,
+                "Queried for " + QUERY_COUNT + " of " + BATCH_SIZE + " UNINDEXED entities in "
+                        + time + " ms.");
+
+        // delete all entities
+        ParseObject.unpinAll();
+        Log.d(TAG, "Deleted all entities.");
+    }
+
+    public void testPerformance() throws Exception {
         //noinspection PointlessBooleanExpression
         if (!BuildConfig.RUN_PERFORMANCE_TESTS) {
             Log.d(TAG, "Performance tests are disabled.");
             return;
         }
-
         Log.d(TAG, "---------------Start");
+
+        // set up parse inside of test
+        // setting it up in setUp() breaks Parse, as it keeps its init state between tests
+        // in hidden ParsePlugins
+        setupParse();
+
         for (int i = 0; i < RUNS; i++) {
             runTests(BATCH_SIZE);
         }
-        Log.d(TAG, "---------------End");
-    }
 
-    private void deleteAll() throws ParseException {
-        long start = System.currentTimeMillis();
-        ParseObject.unpinAll();
-        long time = System.currentTimeMillis() - start;
-        Log.d(TAG, "Deleted all entities in " + time + " ms");
+        Log.d(TAG, "---------------End");
     }
 
     private void runTests(int entityCount) throws ParseException {
@@ -154,6 +215,13 @@ private void runOneByOne(List<ParseObject> list, int count) throws ParseExceptio
         Log.d(TAG, "Updated (one-by-one) " + count + " entities in " + time + " ms");
     }
 
+    private void deleteAll() throws ParseException {
+        long start = System.currentTimeMillis();
+        ParseObject.unpinAll();
+        long time = System.currentTimeMillis() - start;
+        Log.d(TAG, "Deleted all entities in " + time + " ms");
+    }
+
     private ParseObject createEntity(int nr) {
         ParseObject entity = new ParseObject("SimpleEntity");
         entity.put("simpleBoolean", true);
diff --git a/PerformanceTests/Realm/build.gradle b/PerformanceTests/Realm/build.gradle
index a751d1eb..071e7910 100644
--- a/PerformanceTests/Realm/build.gradle
+++ b/PerformanceTests/Realm/build.gradle
@@ -26,5 +26,6 @@ android {
 }
 
 dependencies {
-    androidTestCompile 'io.realm:realm-android:0.82.1'
+    androidTestCompile project(':PerformanceTests:Common')
+    androidTestCompile 'io.realm:realm-android:0.82.2'
 }
diff --git a/PerformanceTests/Realm/src/androidTest/java/de/greenrobot/performance/realm/IndexedStringEntity.java b/PerformanceTests/Realm/src/androidTest/java/de/greenrobot/performance/realm/IndexedStringEntity.java
new file mode 100644
index 00000000..3626e997
--- /dev/null
+++ b/PerformanceTests/Realm/src/androidTest/java/de/greenrobot/performance/realm/IndexedStringEntity.java
@@ -0,0 +1,36 @@
+package de.greenrobot.performance.realm;
+
+import io.realm.RealmObject;
+import io.realm.annotations.Index;
+import io.realm.annotations.PrimaryKey;
+
+/**
+ * Simple entity with a string property that is indexed.
+ */
+public class IndexedStringEntity extends RealmObject {
+
+    @PrimaryKey
+    private long id;
+
+    @Index
+    private String indexedString;
+
+    // Be aware that the getters and setters will be overridden by the generated proxy class
+    // used in the back by RealmObjects, so any custom logic you add to the getters & setters
+    // will not actually be executed
+    public long getId() {
+        return id;
+    }
+
+    public void setId(long id) {
+        this.id = id;
+    }
+
+    public String getIndexedString() {
+        return indexedString;
+    }
+
+    public void setIndexedString(String indexedString) {
+        this.indexedString = indexedString;
+    }
+}
diff --git a/PerformanceTests/Realm/src/androidTest/java/de/greenrobot/performance/realm/PerformanceTestRealm.java b/PerformanceTests/Realm/src/androidTest/java/de/greenrobot/performance/realm/PerformanceTestRealm.java
index 904403b4..dcc521f2 100644
--- a/PerformanceTests/Realm/src/androidTest/java/de/greenrobot/performance/realm/PerformanceTestRealm.java
+++ b/PerformanceTests/Realm/src/androidTest/java/de/greenrobot/performance/realm/PerformanceTestRealm.java
@@ -3,17 +3,25 @@
 import android.app.Application;
 import android.test.ApplicationTestCase;
 import android.util.Log;
+import de.greenrobot.performance.StringGenerator;
 import io.realm.Realm;
 import io.realm.RealmConfiguration;
+import io.realm.RealmQuery;
 import io.realm.RealmResults;
 import java.io.File;
 import java.sql.SQLException;
 import java.util.ArrayList;
 import java.util.List;
 
+/**
+ * https://realm.io/docs/java/latest/ https://github.com/realm/realm-java/
+ */
 public class PerformanceTestRealm extends ApplicationTestCase<Application> {
 
+    private static final String TAG = "PerfTestRealm";
+
     private static final int BATCH_SIZE = 10000;
+    private static final int QUERY_COUNT = 1000;
     private static final int RUNS = 8;
 
     private Realm realm;
@@ -27,6 +35,7 @@ public PerformanceTestRealm() {
     @Override
     protected void setUp() throws Exception {
         super.setUp();
+
         createApplication();
         createRealm();
     }
@@ -53,41 +62,93 @@ protected void tearDown() throws Exception {
                 new File(path).delete();
             }
         }
+
         super.tearDown();
     }
 
-    public void testPerformance() throws Exception {
+    public void testIndexedStringEntityQuery() {
         //noinspection PointlessBooleanExpression
         if (!BuildConfig.RUN_PERFORMANCE_TESTS) {
-            Log.d("DAO", "Realm performance tests are disabled.");
+            Log.d(TAG, "Performance tests are disabled.");
             return;
         }
-
-        runTests(100); // Warmup
+        Log.d(TAG, "--------Indexed Queries: Start");
 
         for (int i = 0; i < RUNS; i++) {
-            deleteAll();
-            runTests(BATCH_SIZE);
+            Log.d(TAG, "----Run " + (i + 1) + " of " + RUNS);
+            doIndexedStringEntityQuery();
         }
-        deleteAll();
-        Log.d("DAO", "---------------End");
+
+        Log.d(TAG, "--------Indexed Queries: End");
     }
 
-    protected void deleteAll() {
-        long start = System.currentTimeMillis();
+    public void doIndexedStringEntityQuery() {
+        // create entities
+        List<IndexedStringEntity> entities = new ArrayList<>(BATCH_SIZE);
+        String[] fixedRandomStrings = StringGenerator.createFixedRandomStrings(BATCH_SIZE);
+        for (int i = 0; i < BATCH_SIZE; i++) {
+            IndexedStringEntity entity = new IndexedStringEntity();
+            entity.setId((long) i);
+            entity.setIndexedString(fixedRandomStrings[i]);
+            entities.add(entity);
+        }
+        Log.d(TAG, "Built entities.");
+
+        // insert entities
         realm.beginTransaction();
-        realm.allObjects(SimpleEntityNotNull.class).clear();
+        realm.copyToRealm(entities);
         realm.commitTransaction();
+        Log.d(TAG, "Inserted entities.");
+
+        // query for entities by indexed string at random
+        int[] randomIndices = StringGenerator.getFixedRandomIndices(QUERY_COUNT, BATCH_SIZE - 1);
+
+        long start = System.currentTimeMillis();
+        for (int i = 0; i < QUERY_COUNT; i++) {
+            int nextIndex = randomIndices[i];
+            RealmQuery<IndexedStringEntity> query = realm.where(IndexedStringEntity.class);
+            query.equalTo("indexedString", fixedRandomStrings[nextIndex]);
+            RealmResults<IndexedStringEntity> result = query.findAll();
+            for (int j = 0, resultSize = result.size(); j < resultSize; j++) {
+                // actually get each entity so its object is reconstructed, same with properties
+                IndexedStringEntity entity = result.get(j);
+                entity.getId();
+                entity.getIndexedString();
+            }
+        }
         long time = System.currentTimeMillis() - start;
-        Log.d("DAO", "Realm: Deleted all entities in " + time + " ms");
+        Log.d(TAG,
+                "Queried for " + QUERY_COUNT + " of " + BATCH_SIZE + " indexed entities in " + time
+                        + " ms.");
+
+        // delete all entities
+        realm.beginTransaction();
+        realm.allObjects(IndexedStringEntity.class).clear();
+        realm.commitTransaction();
+        Log.d(TAG, "Deleted all entities.");
+    }
+
+    public void testPerformance() throws Exception {
+        //noinspection PointlessBooleanExpression
+        if (!BuildConfig.RUN_PERFORMANCE_TESTS) {
+            Log.d(TAG, "Performance tests are disabled.");
+            return;
+        }
+        Log.d(TAG, "---------------Start");
+
+        for (int i = 0; i < RUNS; i++) {
+            runTests(BATCH_SIZE);
+        }
+
+        Log.d(TAG, "---------------End");
     }
 
     protected void runTests(int entityCount) throws Exception {
-        Log.d("DAO", "---------------Start: " + entityCount);
+        Log.d(TAG, "---------------Start: " + entityCount);
 
         long start, time;
 
-        final List<SimpleEntityNotNull> list = new ArrayList<SimpleEntityNotNull>();
+        final List<SimpleEntityNotNull> list = new ArrayList<>();
         for (int i = 0; i < entityCount; i++) {
             list.add(SimpleEntityNotNullHelper.createEntity((long) i));
         }
@@ -103,19 +164,19 @@ protected void runTests(int entityCount) throws Exception {
         realm.copyToRealm(list);
         realm.commitTransaction();
         time = System.currentTimeMillis() - start;
-        Log.d("DAO", "Realm: Created (batch) " + list.size() + " entities in " + time + " ms");
+        Log.d(TAG, "Created (batch) " + list.size() + " entities in " + time + " ms");
 
         start = System.currentTimeMillis();
         realm.beginTransaction();
         realm.copyToRealmOrUpdate(list);
         realm.commitTransaction();
         time = System.currentTimeMillis() - start;
-        Log.d("DAO", "Realm: Updated (batch) " + list.size() + " entities in " + time + " ms");
+        Log.d(TAG, "Updated (batch) " + list.size() + " entities in " + time + " ms");
 
         start = System.currentTimeMillis();
         RealmResults<SimpleEntityNotNull> reloaded = realm.allObjects(SimpleEntityNotNull.class);
         time = System.currentTimeMillis() - start;
-        Log.d("DAO", "Realm: Loaded (batch) " + reloaded.size() + " entities in " + time + " ms");
+        Log.d(TAG, "Loaded (batch) " + reloaded.size() + " entities in " + time + " ms");
 
         // as Realm is not actually loading data, just referencing it,
         // at least make sure we access every property to force it being loaded
@@ -134,11 +195,12 @@ protected void runTests(int entityCount) throws Exception {
             entity.getSimpleByteArray();
         }
         time = System.currentTimeMillis() - start;
-        Log.d("DAO",
-                "Realm: Accessed properties of " + reloaded.size() + " entities in " + time + " ms");
+        Log.d(TAG, "Accessed properties of " + reloaded.size() + " entities in " + time + " ms");
+
+        deleteAll();
 
         System.gc();
-        Log.d("DAO", "---------------End: " + entityCount);
+        Log.d(TAG, "---------------End: " + entityCount);
     }
 
     protected void runOneByOne(List<SimpleEntityNotNull> list, int count) throws SQLException {
@@ -151,7 +213,7 @@ protected void runOneByOne(List<SimpleEntityNotNull> list, int count) throws SQL
             realm.commitTransaction();
         }
         time = System.currentTimeMillis() - start;
-        Log.d("DAO", "Realm: Inserted (one-by-one) " + count + " entities in " + time + " ms");
+        Log.d(TAG, "Inserted (one-by-one) " + count + " entities in " + time + " ms");
 
         start = System.currentTimeMillis();
         for (int i = 0; i < count; i++) {
@@ -160,6 +222,15 @@ protected void runOneByOne(List<SimpleEntityNotNull> list, int count) throws SQL
             realm.commitTransaction();
         }
         time = System.currentTimeMillis() - start;
-        Log.d("DAO", "Realm: Updated (one-by-one) " + count + " entities in " + time + " ms");
+        Log.d(TAG, "Updated (one-by-one) " + count + " entities in " + time + " ms");
+    }
+
+    protected void deleteAll() {
+        long start = System.currentTimeMillis();
+        realm.beginTransaction();
+        realm.allObjects(SimpleEntityNotNull.class).clear();
+        realm.commitTransaction();
+        long time = System.currentTimeMillis() - start;
+        Log.d(TAG, "Deleted all entities in " + time + " ms");
     }
 }
diff --git a/PerformanceTests/Sqlite/build.gradle b/PerformanceTests/Sqlite/build.gradle
new file mode 100644
index 00000000..58b55778
--- /dev/null
+++ b/PerformanceTests/Sqlite/build.gradle
@@ -0,0 +1,30 @@
+buildscript {
+    repositories {
+        jcenter()
+    }
+
+    dependencies {
+        classpath 'com.android.tools.build:gradle:1.3.1'
+    }
+}
+
+apply plugin: 'com.android.application'
+
+android {
+    buildToolsVersion rootProject.ext.buildToolsVersion
+    compileSdkVersion rootProject.ext.compileSdkVersion
+
+    defaultConfig {
+        applicationId 'de.greenrobot.performance.sqlite'
+        minSdkVersion rootProject.ext.minSdkVersion
+        targetSdkVersion rootProject.ext.targetSdkVersion
+
+        testInstrumentationRunner 'android.test.InstrumentationTestRunner'
+
+        buildConfigField "boolean", "RUN_PERFORMANCE_TESTS", "false"
+    }
+}
+
+dependencies {
+    androidTestCompile project(':PerformanceTests:Common')
+}
diff --git a/PerformanceTests/Sqlite/src/androidTest/java/de/greenrobot/performance/sqlite/IndexedStringEntity.java b/PerformanceTests/Sqlite/src/androidTest/java/de/greenrobot/performance/sqlite/IndexedStringEntity.java
new file mode 100644
index 00000000..6cc3179d
--- /dev/null
+++ b/PerformanceTests/Sqlite/src/androidTest/java/de/greenrobot/performance/sqlite/IndexedStringEntity.java
@@ -0,0 +1,12 @@
+package de.greenrobot.performance.sqlite;
+
+/**
+ * Simple entity with a string property that is indexed.
+ */
+public class IndexedStringEntity {
+
+    public Long _id;
+
+    public String indexedString;
+
+}
diff --git a/PerformanceTests/Sqlite/src/androidTest/java/de/greenrobot/performance/sqlite/PerformanceTestSqlite.java b/PerformanceTests/Sqlite/src/androidTest/java/de/greenrobot/performance/sqlite/PerformanceTestSqlite.java
new file mode 100644
index 00000000..c830f813
--- /dev/null
+++ b/PerformanceTests/Sqlite/src/androidTest/java/de/greenrobot/performance/sqlite/PerformanceTestSqlite.java
@@ -0,0 +1,387 @@
+package de.greenrobot.performance.sqlite;
+
+import android.app.Application;
+import android.content.ContentValues;
+import android.content.Context;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteOpenHelper;
+import android.test.ApplicationTestCase;
+import android.util.Log;
+import de.greenrobot.performance.StringGenerator;
+import java.sql.SQLException;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * https://bitbucket.org/qbusict/cupboard/wiki/GettingStarted
+ */
+public class PerformanceTestSqlite extends ApplicationTestCase<Application> {
+
+    private static final String TAG = "PerfTestSqlite";
+
+    private static final int BATCH_SIZE = 10000;
+    private static final int QUERY_COUNT = 1000;
+    private static final int RUNS = 8;
+
+    private static final String DATABASE_NAME = "sqlite.db";
+    private static final int DATABASE_VERSION = 1;
+
+    public PerformanceTestSqlite() {
+        super(Application.class);
+    }
+
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+
+        createApplication();
+    }
+
+    @Override
+    protected void tearDown() throws Exception {
+        getApplication().deleteDatabase(DATABASE_NAME);
+
+        super.tearDown();
+    }
+
+    public void testIndexedStringEntityQuery() {
+        //noinspection PointlessBooleanExpression
+        if (!BuildConfig.RUN_PERFORMANCE_TESTS) {
+            Log.d(TAG, "Performance tests are disabled.");
+            return;
+        }
+        Log.d(TAG, "--------Indexed Queries: Start");
+
+        // set up database
+        DbHelper dbHelper = new DbHelper(getApplication(), DATABASE_NAME, DATABASE_VERSION);
+        SQLiteDatabase database = dbHelper.getWritableDatabase();
+        Log.d(TAG, "Set up database.");
+
+        for (int i = 0; i < RUNS; i++) {
+            Log.d(TAG, "----Run " + (i + 1) + " of " + RUNS);
+            doIndexedStringEntityQuery(database);
+        }
+
+        Log.d(TAG, "--------Indexed Queries: End");
+    }
+
+    public void doIndexedStringEntityQuery(SQLiteDatabase database) {
+        // create entities
+        List<IndexedStringEntity> entities = new ArrayList<>(BATCH_SIZE);
+        String[] fixedRandomStrings = StringGenerator.createFixedRandomStrings(BATCH_SIZE);
+        for (int i = 0; i < BATCH_SIZE; i++) {
+            IndexedStringEntity entity = new IndexedStringEntity();
+            entity._id = (long) i;
+            entity.indexedString = fixedRandomStrings[i];
+            entities.add(entity);
+        }
+        Log.d(TAG, "Built entities.");
+
+        // insert entities
+        database.beginTransaction();
+        try {
+            ContentValues values = new ContentValues();
+            for (int i = 0; i < BATCH_SIZE; i++) {
+                IndexedStringEntity entity = entities.get(i);
+                values.put(DbHelper.IndexedEntityColumns._ID, entity._id);
+                values.put(DbHelper.IndexedEntityColumns.INDEXED_STRING, entity.indexedString);
+
+                database.insert(DbHelper.Tables.INDEXED_ENTITY, null, values);
+
+                values.clear();
+            }
+            database.setTransactionSuccessful();
+        } finally {
+            database.endTransaction();
+        }
+        Log.d(TAG, "Inserted entities.");
+
+        // query for entities by indexed string at random
+        int[] randomIndices = StringGenerator.getFixedRandomIndices(QUERY_COUNT, BATCH_SIZE - 1);
+
+        long start = System.currentTimeMillis();
+        for (int i = 0; i < QUERY_COUNT; i++) {
+            int nextIndex = randomIndices[i];
+
+            Cursor query = database.query(DbHelper.Tables.INDEXED_ENTITY,
+                    IndexedQuery.PROJECTION, DbHelper.IndexedEntityColumns.INDEXED_STRING + "=?",
+                    new String[] { fixedRandomStrings[nextIndex] }, null, null, null, null);
+            // do NO null checks and count checks, should throw to indicate something is incorrect
+            query.moveToFirst();
+
+            // reconstruct entity
+            IndexedStringEntity entity = new IndexedStringEntity();
+            entity._id = query.getLong(0);
+            entity.indexedString = query.getString(1);
+
+            query.close();
+        }
+        long time = System.currentTimeMillis() - start;
+        Log.d(TAG,
+                "Queried for " + QUERY_COUNT + " of " + BATCH_SIZE + " indexed entities in " + time
+                        + " ms.");
+
+        // delete all entities
+        database.delete(DbHelper.Tables.INDEXED_ENTITY, null, null);
+        Log.d(TAG, "Deleted all entities.");
+    }
+
+    public void testPerformance() throws Exception {
+        //noinspection PointlessBooleanExpression
+        if (!BuildConfig.RUN_PERFORMANCE_TESTS) {
+            Log.d(TAG, "Performance tests are disabled.");
+            return;
+        }
+        Log.d(TAG, "---------------Start");
+
+        // set up database
+        DbHelper dbHelper = new DbHelper(getApplication(), DATABASE_NAME, DATABASE_VERSION);
+        SQLiteDatabase database = dbHelper.getWritableDatabase();
+
+        for (int i = 0; i < RUNS; i++) {
+            runTests(database, BATCH_SIZE);
+        }
+
+        Log.d(TAG, "---------------End");
+    }
+
+    private void runTests(SQLiteDatabase database, int entityCount) throws Exception {
+        Log.d(TAG, "---------------Start: " + entityCount);
+
+        long start, time;
+
+        final List<SimpleEntityNotNull> list = new ArrayList<>();
+        for (int i = 0; i < entityCount; i++) {
+            list.add(SimpleEntityNotNullHelper.createEntity((long) i));
+        }
+        System.gc();
+
+        runOneByOne(database, list, entityCount / 10);
+
+        System.gc();
+        deleteAll(database);
+
+        start = System.currentTimeMillis();
+        database.beginTransaction();
+        try {
+            ContentValues values = new ContentValues();
+            for (int i = 0; i < BATCH_SIZE; i++) {
+                SimpleEntityNotNull entity = list.get(i);
+                values.put(DbHelper.SimpleEntityColumns._ID, entity.getId());
+                buildContentValues(values, entity);
+                database.insert(DbHelper.Tables.SIMPLE_ENTITY, null, values);
+                values.clear();
+            }
+            database.setTransactionSuccessful();
+        } finally {
+            database.endTransaction();
+        }
+        time = System.currentTimeMillis() - start;
+        Log.d(TAG, "Created (batch) " + list.size() + " entities in " + time + " ms");
+
+        start = System.currentTimeMillis();
+        database.beginTransaction();
+        try {
+            ContentValues values = new ContentValues();
+            for (int i = 0; i < BATCH_SIZE; i++) {
+                SimpleEntityNotNull entity = list.get(i);
+                buildContentValues(values, entity);
+                database.update(DbHelper.Tables.SIMPLE_ENTITY, values,
+                        DbHelper.SimpleEntityColumns._ID + "=" + entity.getId(),
+                        null);
+                values.clear();
+            }
+            database.setTransactionSuccessful();
+        } finally {
+            database.endTransaction();
+        }
+        time = System.currentTimeMillis() - start;
+        Log.d(TAG, "Updated (batch) " + list.size() + " entities in " + time + " ms");
+
+        start = System.currentTimeMillis();
+        List<SimpleEntityNotNull> reloaded = new ArrayList<>(BATCH_SIZE);
+        Cursor query = database.query(DbHelper.Tables.SIMPLE_ENTITY, SimpleQuery.PROJECTION, null,
+                null, null, null, null, null);
+        while (query.moveToNext()) {
+            SimpleEntityNotNull entity = new SimpleEntityNotNull();
+            entity.setId(query.getLong(0));
+            entity.setSimpleBoolean(query.getInt(1) == 1);
+            entity.setSimpleByte((byte) query.getInt(2));
+            entity.setSimpleShort(query.getShort(3));
+            entity.setSimpleInt(query.getInt(4));
+            entity.setSimpleLong(query.getLong(5));
+            entity.setSimpleFloat(query.getFloat(6));
+            entity.setSimpleDouble(query.getDouble(7));
+            entity.setSimpleString(query.getString(8));
+            entity.setSimpleByteArray(query.getBlob(9));
+            reloaded.add(entity);
+        }
+        query.close();
+        time = System.currentTimeMillis() - start;
+        Log.d(TAG, "Loaded (batch) " + reloaded.size() + " entities in " + time + " ms");
+
+        start = System.currentTimeMillis();
+        for (int i = 0; i < reloaded.size(); i++) {
+            SimpleEntityNotNull entity = reloaded.get(i);
+            entity.getId();
+            entity.getSimpleBoolean();
+            entity.getSimpleByte();
+            entity.getSimpleShort();
+            entity.getSimpleInt();
+            entity.getSimpleLong();
+            entity.getSimpleFloat();
+            entity.getSimpleDouble();
+            entity.getSimpleString();
+            entity.getSimpleByteArray();
+        }
+        time = System.currentTimeMillis() - start;
+
+        Log.d(TAG, "Accessed properties of " + reloaded.size() + " entities in " + time + " ms");
+
+        deleteAll(database);
+
+        System.gc();
+        Log.d(TAG, "---------------End: " + entityCount);
+    }
+
+    private void deleteAll(SQLiteDatabase database) {
+        long start = System.currentTimeMillis();
+        database.delete(DbHelper.Tables.SIMPLE_ENTITY, null, null);
+        long time = System.currentTimeMillis() - start;
+        Log.d(TAG, "Deleted all entities in " + time + " ms");
+    }
+
+    private void runOneByOne(SQLiteDatabase database, List<SimpleEntityNotNull> list,
+            int count) throws SQLException {
+        long start;
+        long time;
+        start = System.currentTimeMillis();
+        ContentValues values = new ContentValues();
+        for (int i = 0; i < count; i++) {
+            SimpleEntityNotNull entity = list.get(i);
+            values.put(DbHelper.SimpleEntityColumns._ID, entity.getId());
+            buildContentValues(values, entity);
+            database.insert(DbHelper.Tables.SIMPLE_ENTITY, null, values);
+            values.clear();
+        }
+        time = System.currentTimeMillis() - start;
+        Log.d(TAG, "Inserted (one-by-one) " + count + " entities in " + time + " ms");
+
+        start = System.currentTimeMillis();
+        for (int i = 0; i < count; i++) {
+            SimpleEntityNotNull entity = list.get(i);
+            buildContentValues(values, entity);
+            database.update(DbHelper.Tables.SIMPLE_ENTITY, values,
+                    DbHelper.SimpleEntityColumns._ID + "=" + entity.getId(),
+                    null);
+            values.clear();
+        }
+        time = System.currentTimeMillis() - start;
+        Log.d(TAG, "Updated (one-by-one) " + count + " entities in " + time + " ms");
+    }
+
+    private void buildContentValues(ContentValues values, SimpleEntityNotNull entity) {
+        values.put(DbHelper.SimpleEntityColumns.SIMPLE_BOOLEAN, entity.getSimpleBoolean());
+        values.put(DbHelper.SimpleEntityColumns.SIMPLE_BYTE, entity.getSimpleByte());
+        values.put(DbHelper.SimpleEntityColumns.SIMPLE_SHORT, entity.getSimpleShort());
+        values.put(DbHelper.SimpleEntityColumns.SIMPLE_INT, entity.getSimpleInt());
+        values.put(DbHelper.SimpleEntityColumns.SIMPLE_LONG, entity.getSimpleLong());
+        values.put(DbHelper.SimpleEntityColumns.SIMPLE_FLOAT, entity.getSimpleFloat());
+        values.put(DbHelper.SimpleEntityColumns.SIMPLE_DOUBLE, entity.getSimpleDouble());
+        values.put(DbHelper.SimpleEntityColumns.SIMPLE_STRING, entity.getSimpleString());
+        values.put(DbHelper.SimpleEntityColumns.SIMPLE_BYTE_ARRAY, entity.getSimpleByteArray());
+    }
+
+    private interface IndexedQuery {
+        String[] PROJECTION = new String[] {
+                DbHelper.IndexedEntityColumns._ID, // 0
+                DbHelper.IndexedEntityColumns.INDEXED_STRING // 1
+        };
+    }
+
+    private interface SimpleQuery {
+        String[] PROJECTION = new String[] {
+                DbHelper.SimpleEntityColumns._ID, // 0
+                DbHelper.SimpleEntityColumns.SIMPLE_BOOLEAN,
+                DbHelper.SimpleEntityColumns.SIMPLE_BYTE, // 2
+                DbHelper.SimpleEntityColumns.SIMPLE_SHORT,
+                DbHelper.SimpleEntityColumns.SIMPLE_INT, // 4
+                DbHelper.SimpleEntityColumns.SIMPLE_LONG,
+                DbHelper.SimpleEntityColumns.SIMPLE_FLOAT, // 6
+                DbHelper.SimpleEntityColumns.SIMPLE_DOUBLE,
+                DbHelper.SimpleEntityColumns.SIMPLE_STRING, // 8
+                DbHelper.SimpleEntityColumns.SIMPLE_BYTE_ARRAY
+        };
+    }
+
+    private static class DbHelper extends SQLiteOpenHelper {
+
+        public interface Tables {
+            String SIMPLE_ENTITY = "SIMPLE_ENTITY_NOT_NULL";
+            String INDEXED_ENTITY = "INDEXED_STRING_ENTITY";
+        }
+
+        public interface SimpleEntityColumns {
+            String _ID = "_id";
+            String SIMPLE_BOOLEAN = "SIMPLE_BOOLEAN";
+            String SIMPLE_BYTE = "SIMPLE_BYTE";
+            String SIMPLE_SHORT = "SIMPLE_SHORT";
+            String SIMPLE_INT = "SIMPLE_INT";
+            String SIMPLE_LONG = "SIMPLE_LONG";
+            String SIMPLE_FLOAT = "SIMPLE_FLOAT";
+            String SIMPLE_DOUBLE = "SIMPLE_DOUBLE";
+            String SIMPLE_STRING = "SIMPLE_STRING";
+            String SIMPLE_BYTE_ARRAY = "SIMPLE_BYTE_ARRAY";
+        }
+
+        public interface IndexedEntityColumns {
+            String _ID = "_id";
+            String INDEXED_STRING = "INDEXED_STRING";
+        }
+
+        private static final String CREATE_SIMPLE_ENTITY_TABLE =
+                "CREATE TABLE " + Tables.SIMPLE_ENTITY
+                        + " ("
+                        + SimpleEntityColumns._ID + " INTEGER PRIMARY KEY NOT NULL ,"  // 0
+                        + SimpleEntityColumns.SIMPLE_BOOLEAN + " INTEGER NOT NULL ,"  // 1
+                        + SimpleEntityColumns.SIMPLE_BYTE + " INTEGER NOT NULL ,"  // 2
+                        + SimpleEntityColumns.SIMPLE_SHORT + " INTEGER NOT NULL ,"  // 3
+                        + SimpleEntityColumns.SIMPLE_INT + " INTEGER NOT NULL ,"  // 4
+                        + SimpleEntityColumns.SIMPLE_LONG + " INTEGER NOT NULL ,"  // 5
+                        + SimpleEntityColumns.SIMPLE_FLOAT + " REAL NOT NULL ,"  // 6
+                        + SimpleEntityColumns.SIMPLE_DOUBLE + " REAL NOT NULL ,"  // 7
+                        + SimpleEntityColumns.SIMPLE_STRING + " TEXT NOT NULL ,"  // 8
+                        + SimpleEntityColumns.SIMPLE_BYTE_ARRAY + " BLOB NOT NULL" // 9
+                        + ")";
+
+        private static final String CREATE_INDEXED_STRING_ENTITY_TABLE =
+                "CREATE TABLE " + Tables.INDEXED_ENTITY
+                        + " ("
+                        + IndexedEntityColumns._ID + " INTEGER PRIMARY KEY NOT NULL ," // 0
+                        + IndexedEntityColumns.INDEXED_STRING + " TEXT NOT NULL " // 1
+                        + ")";
+
+        private static final String CREATE_INDEX_ON_STRING =
+                "CREATE INDEX indexed_string ON " + Tables.INDEXED_ENTITY + "("
+                        + IndexedEntityColumns.INDEXED_STRING + ")";
+
+        public DbHelper(Context context, String name, int version) {
+            super(context, name, null, version);
+        }
+
+        @Override
+        public void onCreate(SQLiteDatabase db) {
+            db.execSQL(CREATE_SIMPLE_ENTITY_TABLE);
+            db.execSQL(CREATE_INDEXED_STRING_ENTITY_TABLE);
+            db.execSQL(CREATE_INDEX_ON_STRING);
+        }
+
+        @Override
+        public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+            db.execSQL("DROP TABLE IF EXISTS " + Tables.SIMPLE_ENTITY);
+            db.execSQL("DROP TABLE IF EXISTS " + Tables.INDEXED_ENTITY);
+            onCreate(db);
+        }
+    }
+}
diff --git a/PerformanceTests/Sqlite/src/androidTest/java/de/greenrobot/performance/sqlite/SimpleEntityNotNull.java b/PerformanceTests/Sqlite/src/androidTest/java/de/greenrobot/performance/sqlite/SimpleEntityNotNull.java
new file mode 100644
index 00000000..71f5611f
--- /dev/null
+++ b/PerformanceTests/Sqlite/src/androidTest/java/de/greenrobot/performance/sqlite/SimpleEntityNotNull.java
@@ -0,0 +1,98 @@
+package de.greenrobot.performance.sqlite;
+
+/**
+ * Simple entity for performance testing.
+ */
+public class SimpleEntityNotNull {
+
+    public Long _id;
+    public boolean simpleBoolean;
+    public byte simpleByte;
+    public short simpleShort;
+    public int simpleInt;
+    public long simpleLong;
+    public float simpleFloat;
+    public double simpleDouble;
+    public String simpleString;
+    public byte[] simpleByteArray;
+
+    public Long getId() {
+        return _id;
+    }
+
+    public boolean getSimpleBoolean() {
+        return simpleBoolean;
+    }
+
+    public void setSimpleBoolean(boolean simpleBoolean) {
+        this.simpleBoolean = simpleBoolean;
+    }
+
+    public byte getSimpleByte() {
+        return simpleByte;
+    }
+
+    public void setSimpleByte(byte simpleByte) {
+        this.simpleByte = simpleByte;
+    }
+
+    public short getSimpleShort() {
+        return simpleShort;
+    }
+
+    public void setId(Long id) {
+        this._id = id;
+    }
+
+    public void setSimpleShort(short simpleShort) {
+        this.simpleShort = simpleShort;
+    }
+
+    public int getSimpleInt() {
+        return simpleInt;
+    }
+
+    public void setSimpleInt(int simpleInt) {
+        this.simpleInt = simpleInt;
+    }
+
+    public long getSimpleLong() {
+        return simpleLong;
+    }
+
+    public void setSimpleLong(long simpleLong) {
+        this.simpleLong = simpleLong;
+    }
+
+    public float getSimpleFloat() {
+        return simpleFloat;
+    }
+
+    public void setSimpleFloat(float simpleFloat) {
+        this.simpleFloat = simpleFloat;
+    }
+
+    public double getSimpleDouble() {
+        return simpleDouble;
+    }
+
+    public void setSimpleDouble(double simpleDouble) {
+        this.simpleDouble = simpleDouble;
+    }
+
+    public String getSimpleString() {
+        return simpleString;
+    }
+
+    public void setSimpleString(String simpleString) {
+        this.simpleString = simpleString;
+    }
+
+    public byte[] getSimpleByteArray() {
+        return simpleByteArray;
+    }
+
+    public void setSimpleByteArray(byte[] simpleByteArray) {
+        this.simpleByteArray = simpleByteArray;
+    }
+}
diff --git a/PerformanceTests/Sqlite/src/androidTest/java/de/greenrobot/performance/sqlite/SimpleEntityNotNullHelper.java b/PerformanceTests/Sqlite/src/androidTest/java/de/greenrobot/performance/sqlite/SimpleEntityNotNullHelper.java
new file mode 100644
index 00000000..c0e2c907
--- /dev/null
+++ b/PerformanceTests/Sqlite/src/androidTest/java/de/greenrobot/performance/sqlite/SimpleEntityNotNullHelper.java
@@ -0,0 +1,22 @@
+package de.greenrobot.performance.sqlite;
+
+public class SimpleEntityNotNullHelper {
+    protected static SimpleEntityNotNull createEntity(Long key) {
+        if (key == null) {
+            return null;
+        }
+        SimpleEntityNotNull entity = new SimpleEntityNotNull();
+        entity.setId(key);
+        entity.setSimpleBoolean(true);
+        entity.setSimpleByte(Byte.MAX_VALUE);
+        entity.setSimpleShort(Short.MAX_VALUE);
+        entity.setSimpleInt(Integer.MAX_VALUE);
+        entity.setSimpleLong(Long.MAX_VALUE);
+        entity.setSimpleFloat(Float.MAX_VALUE);
+        entity.setSimpleDouble(Double.MAX_VALUE);
+        entity.setSimpleString("greenrobot greenDAO");
+        byte[] bytes = { 42, -17, 23, 0, 127, -128 };
+        entity.setSimpleByteArray(bytes);
+        return entity;
+    }
+}
diff --git a/PerformanceTests/Sqlite/src/main/AndroidManifest.xml b/PerformanceTests/Sqlite/src/main/AndroidManifest.xml
new file mode 100644
index 00000000..5587d7f5
--- /dev/null
+++ b/PerformanceTests/Sqlite/src/main/AndroidManifest.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="de.greenrobot.performance.sqlite">
+
+    <application>
+        <!-- empty application tag -->
+    </application>
+</manifest>
diff --git a/settings.gradle b/settings.gradle
index c59ee95d..660b6cd5 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -2,6 +2,7 @@ include 'DaoCore', 'DaoGenerator', 'DaoExampleGenerator'
 include 'DaoTest' // Travis needs some Android setup for this
 include 'DaoTestGenerator'
 include ':DaoExample'
+include ':PerformanceTests:Common'
 include ':PerformanceTests:ActiveAndroid'
 include ':PerformanceTests:Couchbase'
 include ':PerformanceTests:Cupboard'
@@ -9,3 +10,4 @@ include ':PerformanceTests:Firebase'
 include ':PerformanceTests:OrmLite'
 include ':PerformanceTests:Parse'
 include ':PerformanceTests:Realm'
+include ':PerformanceTests:Sqlite'
