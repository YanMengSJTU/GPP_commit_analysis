diff --git a/DaoCore/src/de/greenrobot/dao/AbstractDao.java b/DaoCore/src/de/greenrobot/dao/AbstractDao.java
index bbf5c5c7..fd6c1267 100644
--- a/DaoCore/src/de/greenrobot/dao/AbstractDao.java
+++ b/DaoCore/src/de/greenrobot/dao/AbstractDao.java
@@ -54,6 +54,7 @@
  * 
  * 3.) identityScope
  */
+//FIXME: Find all cases of non-inTX methods that call connection.setAutoCommit( false ); and make it conditional (or hide details inside the driver), ie: setting auto commit to false on a connection that already has it to false just creates a nested transaction that when committed doesn't do anything and lets the parent transaction handle it)
 public abstract class AbstractDao<T, K> {
     protected final Connection connection;
     protected final DaoConfig config;
diff --git a/DaoCore/src/de/greenrobot/dao/AbstractDaoSession.java b/DaoCore/src/de/greenrobot/dao/AbstractDaoSession.java
index 7fb39558..0edf5da0 100644
--- a/DaoCore/src/de/greenrobot/dao/AbstractDaoSession.java
+++ b/DaoCore/src/de/greenrobot/dao/AbstractDaoSession.java
@@ -151,12 +151,19 @@ public AbstractDaoSession(Connection connection) {
      */
     public void runInTx(Runnable runnable) throws SQLException {
     	connection.setAutoCommit( false );
+    	
         try {
             runnable.run();
-            connection.commit();
+        	if ( !connection.getAutoCommit() ) //FIXME: HACK: happens if the operation inside the runnable already reset this back to true 
+        	{
+        		connection.commit();
+        	}
         } catch(SQLException e) {
-        	connection.rollback();
         	e.printStackTrace();
+        	if ( !connection.getAutoCommit() ) //FIXME: HACK: happens if the operation inside the runnable already reset this back to true 
+        	{
+        		connection.rollback();
+        	}
         } finally {
         	connection.setAutoCommit( true );
         }
