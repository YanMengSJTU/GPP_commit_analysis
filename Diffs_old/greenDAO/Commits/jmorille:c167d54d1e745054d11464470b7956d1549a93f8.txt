diff --git a/DaoCore/.classpath b/DaoCore/.classpath
index 8981741b..7bc01d9a 100644
--- a/DaoCore/.classpath
+++ b/DaoCore/.classpath
@@ -1,8 +1,9 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="src" path="gen"/>
-	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
-	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
-	<classpathentry kind="output" path="bin/classes"/>
-</classpath>
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="src" path="gen"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
+	<classpathentry kind="output" path="bin/classes"/>
+</classpath>
diff --git a/DaoCore/build.gradle b/DaoCore/build.gradle
index 32cd349f..4ee47c8d 100644
--- a/DaoCore/build.gradle
+++ b/DaoCore/build.gradle
@@ -3,7 +3,7 @@ apply plugin: 'maven'
 apply plugin: 'signing'
 
 group = 'de.greenrobot'
-version = '1.3.1'
+version = '1.3.3'
 sourceCompatibility = 1.6
 
 def isSnapshot = version.endsWith('-SNAPSHOT')
@@ -23,6 +23,7 @@ repositories {
 // Like this, it won't appear at all in the POM
 configurations {
     provided
+    deployerJars
 }
 
 dependencies {
@@ -30,6 +31,8 @@ dependencies {
     provided 'com.google.android:android-test:4.1.1.4'
     provided 'com.google.android:annotations:4.1.1.4'
     provided 'com.google.android:support-v4:r7'
+    // deployerJars 'org.apache.maven.wagon:wagon-webdav-jackrabbit:2.4'
+    deployerJars 'org.apache.maven.wagon:wagon-webdav:1.0-beta-2'
 }
 
 sourceSets {
@@ -76,8 +79,13 @@ signing {
 uploadArchives {
     repositories {
         mavenDeployer {
-            // We must check if authentication info is available
-            if(project.hasProperty('sonatypeUsername') && project.hasProperty('sonatypePassword')) {
+            if(project.hasProperty('preferedRepo') && project.hasProperty('preferedUsername') 
+                && project.hasProperty('preferedPassword')) {
+                configuration = configurations.deployerJars
+                repository(url: preferedRepo) {
+                    authentication(userName: preferedUsername, password: preferedPassword)
+                }
+            } else if(project.hasProperty('sonatypeUsername') && project.hasProperty('sonatypePassword')) {
                 beforeDeployment { MavenDeployment deployment -> signing.signPom(deployment) }
                 repository(url: sonatypeRepositoryUrl) {
                     authentication(userName: sonatypeUsername, password: sonatypePassword)
diff --git a/DaoCore/src/de/greenrobot/dao/AbstractDao.java b/DaoCore/src/de/greenrobot/dao/AbstractDao.java
index 042d4c3e..95c29eb2 100644
--- a/DaoCore/src/de/greenrobot/dao/AbstractDao.java
+++ b/DaoCore/src/de/greenrobot/dao/AbstractDao.java
@@ -415,12 +415,12 @@ final protected T loadCurrent(Cursor cursor, int offset, boolean lock) {
                 return entity;
             } else {
                 entity = readEntity(cursor, offset);
+                attachEntity(entity);
                 if (lock) {
                     identityScopeLong.put2(key, entity);
                 } else {
                     identityScopeLong.put2NoLock(key, entity);
                 }
-                attachEntity(entity);
                 return entity;
             }
         } else if (identityScope != null) {
@@ -689,6 +689,7 @@ protected void updateInsideSynchronized(T entity, SQLiteStatement stmt, boolean
      *            The entitiy to attach
      * */
     protected final void attachEntity(K key, T entity, boolean lock) {
+        attachEntity(entity);
         if (identityScope != null && key != null) {
             if (lock) {
                 identityScope.put(key, entity);
@@ -696,11 +697,11 @@ protected final void attachEntity(K key, T entity, boolean lock) {
                 identityScope.putNoLock(key, entity);
             }
         }
-        attachEntity(entity);
     }
 
     /**
-     * Sub classes with relations additionally set the DaoMaster here.
+     * Sub classes with relations additionally set the DaoMaster here. Must be called before the entity is attached to
+     * the identity scope.
      * 
      * @param entity
      *            The entitiy to attach
diff --git a/DaoCore/src/de/greenrobot/dao/internal/SqlUtils.java b/DaoCore/src/de/greenrobot/dao/internal/SqlUtils.java
index 365f9490..fe1fd406 100644
--- a/DaoCore/src/de/greenrobot/dao/internal/SqlUtils.java
+++ b/DaoCore/src/de/greenrobot/dao/internal/SqlUtils.java
@@ -106,11 +106,16 @@ public static String createSqlSelect(String tablename, String tableAlias, String
     }
 
     /** Creates SELECT COUNT(*) with a trailing space. */
-    public static String createSqlSelectCountStar(String tablename) {
+    public static String createSqlSelectCountStar(String tablename, String tableAliasOrNull) {
         StringBuilder builder = new StringBuilder("SELECT COUNT(*) FROM ");
-        return builder.append(tablename).append(' ').toString();
+        builder.append(tablename).append(' ');
+        if(tableAliasOrNull != null) {
+            builder.append(tableAliasOrNull).append(' ');
+        }
+        return builder.toString();
     }
 
+    /** Remember: SQLite does not support joins nor table alias for DELETE. */
     public static String createSqlDelete(String tablename, String[] columns) {
         StringBuilder builder = new StringBuilder("DELETE FROM ");
         builder.append(tablename);
diff --git a/DaoCore/src/de/greenrobot/dao/query/AbstractQueryData.java b/DaoCore/src/de/greenrobot/dao/query/AbstractQueryData.java
new file mode 100644
index 00000000..7a4736ec
--- /dev/null
+++ b/DaoCore/src/de/greenrobot/dao/query/AbstractQueryData.java
@@ -0,0 +1,60 @@
+package de.greenrobot.dao.query;
+
+import java.lang.ref.WeakReference;
+
+import android.os.Process;
+import android.util.SparseArray;
+import de.greenrobot.dao.AbstractDao;
+
+abstract class AbstractQueryData<T, Q extends AbstractQuery<T>> {
+    final String sql;
+    final AbstractDao<T, ?> dao;
+    final String[] initialValues;
+    final SparseArray<WeakReference<Q>> queriesForThreads;
+
+    AbstractQueryData(AbstractDao<T, ?> dao, String sql, String[] initialValues) {
+        this.dao = dao;
+        this.sql = sql;
+        this.initialValues = initialValues;
+        queriesForThreads = new SparseArray<WeakReference<Q>>();
+    }
+
+    /** Just an optimized version, which performs faster if the current thread is already the query's owner thread. */
+    Q forCurrentThread(Q query) {
+        if (Thread.currentThread() == query.ownerThread) {
+            System.arraycopy(initialValues, 0, query.parameters, 0, initialValues.length);
+            return query;
+        } else {
+            return forCurrentThread();
+        }
+    }
+
+    Q forCurrentThread() {
+        int threadId = Process.myTid();
+        synchronized (queriesForThreads) {
+            WeakReference<Q> queryRef = queriesForThreads.get(threadId);
+            Q query = queryRef != null ? queryRef.get() : null;
+            if (query == null) {
+                gc();
+                query = createQuery();
+                queriesForThreads.put(threadId, new WeakReference<Q>(query));
+            } else {
+                System.arraycopy(initialValues, 0, query.parameters, 0, initialValues.length);
+            }
+            return query;
+        }
+    }
+
+    abstract protected Q createQuery();
+
+    void gc() {
+        synchronized (queriesForThreads) {
+            for (int i = queriesForThreads.size() - 1; i >= 0; i--) {
+                if (queriesForThreads.valueAt(i).get() == null) {
+                    queriesForThreads.remove(queriesForThreads.keyAt(i));
+                }
+            }
+        }
+    }
+
+}
diff --git a/DaoCore/src/de/greenrobot/dao/query/CountQuery.java b/DaoCore/src/de/greenrobot/dao/query/CountQuery.java
index ece51d72..effc537b 100644
--- a/DaoCore/src/de/greenrobot/dao/query/CountQuery.java
+++ b/DaoCore/src/de/greenrobot/dao/query/CountQuery.java
@@ -6,40 +6,32 @@
 
 public class CountQuery<T> extends AbstractQuery<T> {
 
-    private final static class ThreadLocalQuery<T2> extends ThreadLocal<CountQuery<T2>> {
-        private final String sql;
-        private final AbstractDao<T2, ?> dao;
-        private final String[] initialValues;
-
-        private ThreadLocalQuery(AbstractDao<T2, ?> dao, String sql, String[] initialValues) {
-            this.dao = dao;
-            this.sql = sql;
-            this.initialValues = initialValues;
+    private final static class QueryData<T2> extends AbstractQueryData<T2, CountQuery<T2>> {
+
+        private QueryData(AbstractDao<T2, ?> dao, String sql, String[] initialValues) {
+            super(dao, sql, initialValues);
         }
 
         @Override
-        protected CountQuery<T2> initialValue() {
+        protected CountQuery<T2> createQuery() {
             return new CountQuery<T2>(this, dao, sql, initialValues.clone());
         }
     }
 
     static <T2> CountQuery<T2> create(AbstractDao<T2, ?> dao, String sql, Object[] initialValues) {
-        ThreadLocalQuery<T2> threadLocal = new ThreadLocalQuery<T2>(dao, sql, toStringArray(initialValues));
-        return threadLocal.get();
+        QueryData<T2> queryData = new QueryData<T2>(dao, sql, toStringArray(initialValues));
+        return queryData.forCurrentThread();
     }
 
-    private final ThreadLocalQuery<T> threadLocalQuery;
+    private final QueryData<T> queryData;
 
-    private CountQuery(ThreadLocalQuery<T> threadLocalQuery, AbstractDao<T, ?> dao, String sql, String[] initialValues) {
+    private CountQuery(QueryData<T> queryData, AbstractDao<T, ?> dao, String sql, String[] initialValues) {
         super(dao, sql, initialValues);
-        this.threadLocalQuery = threadLocalQuery;
+        this.queryData = queryData;
     }
 
     public CountQuery<T> forCurrentThread() {
-        CountQuery<T> query = threadLocalQuery.get();
-        String[] initialValues = threadLocalQuery.initialValues;
-        System.arraycopy(initialValues, 0, query.parameters, 0, initialValues.length);
-        return query;
+        return queryData.forCurrentThread(this);
     }
 
     /** Returns the count (number of results matching the query). Uses SELECT COUNT (*) sematics. */
diff --git a/DaoCore/src/de/greenrobot/dao/query/DeleteQuery.java b/DaoCore/src/de/greenrobot/dao/query/DeleteQuery.java
index 66dbe312..1ce3d7fe 100644
--- a/DaoCore/src/de/greenrobot/dao/query/DeleteQuery.java
+++ b/DaoCore/src/de/greenrobot/dao/query/DeleteQuery.java
@@ -29,41 +29,33 @@
  *            The enitity class the query will delete from.
  */
 public class DeleteQuery<T> extends AbstractQuery<T> {
-    private final static class ThreadLocalQuery<T2> extends ThreadLocal<DeleteQuery<T2>> {
-        private final String sql;
-        private final AbstractDao<T2, ?> dao;
-        private final String[] initialValues;
+    private final static class QueryData<T2> extends AbstractQueryData<T2, DeleteQuery<T2>> {
 
-        private ThreadLocalQuery(AbstractDao<T2, ?> dao, String sql, String[] initialValues) {
-            this.dao = dao;
-            this.sql = sql;
-            this.initialValues = initialValues;
+        private QueryData(AbstractDao<T2, ?> dao, String sql, String[] initialValues) {
+            super(dao, sql, initialValues);
         }
 
         @Override
-        protected DeleteQuery<T2> initialValue() {
+        protected DeleteQuery<T2> createQuery() {
             return new DeleteQuery<T2>(this, dao, sql, initialValues.clone());
         }
     }
 
     static <T2> DeleteQuery<T2> create(AbstractDao<T2, ?> dao, String sql, Object[] initialValues) {
-        ThreadLocalQuery<T2> threadLocal = new ThreadLocalQuery<T2>(dao, sql, toStringArray(initialValues));
-        return threadLocal.get();
+        QueryData<T2> queryData = new QueryData<T2>(dao, sql, toStringArray(initialValues));
+        return queryData.forCurrentThread();
     }
 
+    private final QueryData<T> queryData;
     private SQLiteStatement compiledStatement;
-    private final ThreadLocalQuery<T> threadLocalQuery;
 
-    private DeleteQuery(ThreadLocalQuery<T> threadLocalQuery, AbstractDao<T, ?> dao, String sql, String[] initialValues) {
+    private DeleteQuery(QueryData<T> queryData, AbstractDao<T, ?> dao, String sql, String[] initialValues) {
         super(dao, sql, initialValues);
-        this.threadLocalQuery = threadLocalQuery;
+        this.queryData = queryData;
     }
 
     public DeleteQuery<T> forCurrentThread() {
-        DeleteQuery<T> query = threadLocalQuery.get();
-        String[] initialValues = threadLocalQuery.initialValues;
-        System.arraycopy(initialValues, 0, query.parameters, 0, initialValues.length);
-        return query;
+        return queryData.forCurrentThread(this);
     }
 
     /**
@@ -89,7 +81,7 @@ public void executeDeleteWithoutDetachingEntities() {
         }
     }
 
-    private synchronized void executeDeleteWithoutDetachingEntitiesInsideTx() {
+    private void executeDeleteWithoutDetachingEntitiesInsideTx() {
         if (compiledStatement != null) {
             compiledStatement.clearBindings();
         } else {
diff --git a/DaoCore/src/de/greenrobot/dao/query/Query.java b/DaoCore/src/de/greenrobot/dao/query/Query.java
index 15abe639..4d36b1b0 100644
--- a/DaoCore/src/de/greenrobot/dao/query/Query.java
+++ b/DaoCore/src/de/greenrobot/dao/query/Query.java
@@ -18,6 +18,7 @@
 import java.util.List;
 
 import android.database.Cursor;
+import android.os.Process;
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.DaoException;
 
@@ -32,27 +33,23 @@
 // TODO support long, double and other types, not just Strings, for parameters
 // TODO Make parameters setable by Property (if unique in paramaters)
 // TODO Query for PKs/ROW IDs
+// TODO Make query compilable
 public class Query<T> extends AbstractQuery<T> {
-    private final static class ThreadLocalQuery<T2> extends ThreadLocal<Query<T2>> {
-        private final String sql;
-        private final AbstractDao<T2, ?> dao;
-        private final String[] initialValues;
+    private final static class QueryData<T2> extends AbstractQueryData<T2, Query<T2>> {
         private final int limitPosition;
         private final int offsetPosition;
 
-        private ThreadLocalQuery(AbstractDao<T2, ?> dao, String sql, String[] initialValues, int limitPosition,
-                int offsetPosition) {
-            this.dao = dao;
-            this.sql = sql;
-            this.initialValues = initialValues;
+        QueryData(AbstractDao<T2, ?> dao, String sql, String[] initialValues, int limitPosition, int offsetPosition) {
+            super(dao,sql,initialValues);
             this.limitPosition = limitPosition;
             this.offsetPosition = offsetPosition;
         }
 
         @Override
-        protected Query<T2> initialValue() {
+        protected Query<T2> createQuery() {
             return new Query<T2>(this, dao, sql, initialValues.clone(), limitPosition, offsetPosition);
         }
+
     }
 
     /** For internal use by greenDAO only. */
@@ -62,32 +59,25 @@ private ThreadLocalQuery(AbstractDao<T2, ?> dao, String sql, String[] initialVal
 
     static <T2> Query<T2> create(AbstractDao<T2, ?> dao, String sql, Object[] initialValues, int limitPosition,
             int offsetPosition) {
-        ThreadLocalQuery<T2> threadLocal = new ThreadLocalQuery<T2>(dao, sql, toStringArray(initialValues),
-                limitPosition, offsetPosition);
-        return threadLocal.get();
+        QueryData<T2> queryData = new QueryData<T2>(dao, sql, toStringArray(initialValues), limitPosition,
+                offsetPosition);
+        return queryData.forCurrentThread();
     }
 
     private final int limitPosition;
     private final int offsetPosition;
-    private final ThreadLocalQuery<T> threadLocalQuery;
+    private final QueryData<T> queryData;
 
-    private Query(ThreadLocalQuery<T> threadLocalQuery, AbstractDao<T, ?> dao, String sql, String[] initialValues,
-            int limitPosition, int offsetPosition) {
+    private Query(QueryData<T> queryData, AbstractDao<T, ?> dao, String sql, String[] initialValues, int limitPosition,
+            int offsetPosition) {
         super(dao, sql, initialValues);
-        this.threadLocalQuery = threadLocalQuery;
+        this.queryData = queryData;
         this.limitPosition = limitPosition;
         this.offsetPosition = offsetPosition;
     }
 
-    // public void compile() {
-    // // TODO implement compile
-    // }
-
     public Query<T> forCurrentThread() {
-        Query<T> query = threadLocalQuery.get();
-        String[] initialValues = threadLocalQuery.initialValues;
-        System.arraycopy(initialValues, 0, query.parameters, 0, initialValues.length);
-        return query;
+        return queryData.forCurrentThread(this);
     }
 
     /**
diff --git a/DaoCore/src/de/greenrobot/dao/query/QueryBuilder.java b/DaoCore/src/de/greenrobot/dao/query/QueryBuilder.java
index 2fcea5e2..c875e360 100644
--- a/DaoCore/src/de/greenrobot/dao/query/QueryBuilder.java
+++ b/DaoCore/src/de/greenrobot/dao/query/QueryBuilder.java
@@ -65,7 +65,7 @@
     private Integer limit;
 
     private Integer offset;
-    
+
     /** For internal use by greenDAO only. */
     public static <T2> QueryBuilder<T2> internalCreate(AbstractDao<T2, ?> dao) {
         return new QueryBuilder<T2>(dao);
@@ -310,6 +310,10 @@ protected void checkProperty(Property property) {
         appendWhereClause(builder, tablename);
         String sql = builder.toString();
 
+        // Remove table aliases, not supported for DELETE queries.
+        // TODO(?): don't create table aliases in the first place.
+        sql = sql.replace(tablePrefix + ".'", tablename + ".'");
+
         if (LOG_SQL) {
             DaoLog.d("Built SQL for delete query: " + sql);
         }
@@ -326,9 +330,9 @@ protected void checkProperty(Property property) {
      */
     public CountQuery<T> buildCount() {
         String tablename = dao.getTablename();
-        String baseSql = SqlUtils.createSqlSelectCountStar(tablename);
+        String baseSql = SqlUtils.createSqlSelectCountStar(tablename, tablePrefix);
         StringBuilder builder = new StringBuilder(baseSql);
-        appendWhereClause(builder, tablename);
+        appendWhereClause(builder, tablePrefix);
         String sql = builder.toString();
 
         if (LOG_SQL) {
diff --git a/DaoCore/src/de/greenrobot/dao/test/DbTest.java b/DaoCore/src/de/greenrobot/dao/test/DbTest.java
index df55ae36..ee3a29df 100644
--- a/DaoCore/src/de/greenrobot/dao/test/DbTest.java
+++ b/DaoCore/src/de/greenrobot/dao/test/DbTest.java
@@ -35,6 +35,7 @@
     protected SQLiteDatabase db;
     protected Random random;
     protected final boolean inMemory;
+    private boolean dontCreateApp;
 
     public DbTest() {
         this(true);
@@ -51,6 +52,10 @@ public DbTest(Class<T> appClass, boolean inMemory) {
         random = new Random();
     }
 
+    protected void dontCreateApplicationDuringSetUp() {
+        dontCreateApp = true;
+    }
+
     @Override
     protected void setUp() {
         try {
@@ -58,7 +63,9 @@ protected void setUp() {
         } catch (Exception e) {
             throw new RuntimeException(e);
         }
-        createApplication();
+        if (!dontCreateApp) {
+            createApplication();
+        }
         setUpDb();
     }
 
diff --git a/DaoExample/.classpath b/DaoExample/.classpath
index 9ccb91e4..6a988e59 100644
--- a/DaoExample/.classpath
+++ b/DaoExample/.classpath
@@ -1,11 +1,11 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <classpath>
-	<classpathentry kind="src" path="gen"/>
 	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="src" path="gen"/>
 	<classpathentry kind="src" path="src-gen"/>
+	<classpathentry kind="src" path="src-test"/>
 	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
 	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
-	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
-	<classpathentry exported="true" kind="con" path="org.springsource.ide.eclipse.gradle.classpathcontainer"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
 	<classpathentry kind="output" path="bin/classes"/>
 </classpath>
diff --git a/DaoExampleGenerator/.settings/org.eclipse.jdt.groovy.core.prefs b/DaoExampleGenerator/.settings/org.eclipse.jdt.groovy.core.prefs
index 7d7ee6dc..65c6dc88 100644
--- a/DaoExampleGenerator/.settings/org.eclipse.jdt.groovy.core.prefs
+++ b/DaoExampleGenerator/.settings/org.eclipse.jdt.groovy.core.prefs
@@ -1,2 +1,2 @@
 eclipse.preferences.version=1
-groovy.compiler.level=18
+groovy.compiler.level=-1
diff --git a/DaoGenerator/.classpath b/DaoGenerator/.classpath
index 0012de0c..a82e8447 100644
--- a/DaoGenerator/.classpath
+++ b/DaoGenerator/.classpath
@@ -3,6 +3,7 @@
 	<classpathentry kind="src" path="src"/>
 	<classpathentry kind="src" path="src-template"/>
 	<classpathentry kind="src" path="src-test"/>
+	<classpathentry kind="src" path="src-generator-testentities"/>
 	<classpathentry kind="con" path="GROOVY_DSL_SUPPORT"/>
 	<classpathentry kind="con" path="GROOVY_SUPPORT"/>
 	<classpathentry kind="con" path="org.eclipse.jdt.junit.JUNIT_CONTAINER/4"/>
diff --git a/DaoGenerator/.freemarker-ide.xml b/DaoGenerator/.freemarker-ide.xml
index 5e0b3f7e..43d77411 100644
--- a/DaoGenerator/.freemarker-ide.xml
+++ b/DaoGenerator/.freemarker-ide.xml
@@ -3,6 +3,11 @@
 		<resource path="src-template/dao-master.ftl">
 			<value key="schema" object-class="de.greenrobot.daogenerator.Schema"/>
 		</resource>
+		<resource path="src-template/content-provider.ftl">
+			<value key="entity" object-class="de.greenrobot.daogenerator.Entity"/>
+			<value key="contentProvider" object-class="de.greenrobot.daogenerator.ContentProvider"/>
+			<value key="schema" object-class="de.greenrobot.daogenerator.Schema"/>
+		</resource>
 		<resource path="src-template/dao.ftl">
 			<value key="entity" object-class="de.greenrobot.daogenerator.Entity"/>
 			<value key="schema" object-class="de.greenrobot.daogenerator.Schema"/>
diff --git a/DaoGenerator/.settings/org.eclipse.jdt.groovy.core.prefs b/DaoGenerator/.settings/org.eclipse.jdt.groovy.core.prefs
index 7d7ee6dc..65c6dc88 100644
--- a/DaoGenerator/.settings/org.eclipse.jdt.groovy.core.prefs
+++ b/DaoGenerator/.settings/org.eclipse.jdt.groovy.core.prefs
@@ -1,2 +1,2 @@
 eclipse.preferences.version=1
-groovy.compiler.level=18
+groovy.compiler.level=-1
diff --git a/DaoGenerator/build.gradle b/DaoGenerator/build.gradle
index 2593ad2d..6647ac11 100644
--- a/DaoGenerator/build.gradle
+++ b/DaoGenerator/build.gradle
@@ -3,7 +3,7 @@ apply plugin: 'maven'
 apply plugin: 'signing'
 
 group = 'de.greenrobot'
-version = '1.3.0-ttbox'
+version = '1.3.1-ttbox'
 sourceCompatibility = 1.6
 
 def isSnapshot = version.endsWith('-SNAPSHOT')
@@ -18,9 +18,18 @@ repositories {
     mavenCentral()
 }
 
+// provided is not supported in Gradle 1.4, see http://issues.gradle.org/browse/GRADLE-784
+// Like this, it won't appear at all in the POM
+configurations {
+    provided
+    deployerJars
+}
+
 dependencies {
     compile ('org.freemarker:freemarker:2.3.19')
     testCompile 'junit:junit:4.11'
+    // deployerJars 'org.apache.maven.wagon:wagon-webdav-jackrabbit:2.4'
+    deployerJars 'org.apache.maven.wagon:wagon-webdav:1.0-beta-2'
 }
 
 sourceSets {
@@ -83,9 +92,14 @@ signing {
 uploadArchives {
     repositories {
         mavenDeployer {
-            beforeDeployment { MavenDeployment deployment -> signing.signPom(deployment) }
-            // We must check if authentication info is available
-            if(project.hasProperty('sonatypeUsername') && project.hasProperty('sonatypePassword')) {
+            if(project.hasProperty('preferedRepo') && project.hasProperty('preferedUsername') 
+                && project.hasProperty('preferedPassword')) {
+                configuration = configurations.deployerJars
+                repository(url: preferedRepo) {
+                    authentication(userName: preferedUsername, password: preferedPassword)
+                }
+            } else if(project.hasProperty('sonatypeUsername') && project.hasProperty('sonatypePassword')) {
+                beforeDeployment { MavenDeployment deployment -> signing.signPom(deployment) }
                 repository(url: sonatypeRepositoryUrl) {
                     authentication(userName: sonatypeUsername, password: sonatypePassword)
                 }
diff --git a/DaoGenerator/src-generator-testentities/de/greenrobot/daogenerator/gentest/TestDaoGenerator.java b/DaoGenerator/src-generator-testentities/de/greenrobot/daogenerator/gentest/TestDaoGenerator.java
index ef92bf31..47bba961 100644
--- a/DaoGenerator/src-generator-testentities/de/greenrobot/daogenerator/gentest/TestDaoGenerator.java
+++ b/DaoGenerator/src-generator-testentities/de/greenrobot/daogenerator/gentest/TestDaoGenerator.java
@@ -79,6 +79,8 @@ protected void createSimple() {
         simple.addDoubleProperty("simpleDouble");
         simple.addStringProperty("simpleString");
         simple.addByteArrayProperty("simpleByteArray");
+        
+        simple.addContentProvider().readOnly();
     }
 
     protected void createSimpleNotNull() {
diff --git a/DaoGenerator/src-template/content-provider.ftl b/DaoGenerator/src-template/content-provider.ftl
new file mode 100644
index 00000000..93396f73
--- /dev/null
+++ b/DaoGenerator/src-template/content-provider.ftl
@@ -0,0 +1,217 @@
+package ${contentProvider.javaPackage};
+
+import android.content.ContentProvider;
+import android.content.ContentResolver;
+import android.content.ContentValues;
+import android.content.UriMatcher;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteQueryBuilder;
+import android.net.Uri;
+
+import de.greenrobot.dao.DaoLog;
+
+import ${schema.defaultJavaPackageDao}.DaoSession;
+import ${entity.javaPackageDao}.${entity.classNameDao};
+
+/* Copy this code snippet into your AndroidManifest.xml inside the
+<application> element:
+
+    <provider
+            android:name="${contentProvider.javaPackage}.${contentProvider.className}"
+            android:authorities="${contentProvider.authority}"/>
+    */
+
+    public class ${contentProvider.className} extends ContentProvider {
+
+    public static final String AUTHORITY = "${contentProvider.authority}";
+    public static final String BASE_PATH = "${contentProvider.basePath}";
+    public static final Uri CONTENT_URI = Uri.parse("content://" + AUTHORITY + "/" + BASE_PATH);
+    public static final String CONTENT_TYPE = ContentResolver.CURSOR_DIR_BASE_TYPE
+    + "/" + BASE_PATH;
+    public static final String CONTENT_ITEM_TYPE = ContentResolver.CURSOR_ITEM_BASE_TYPE
+    + "/" + BASE_PATH;
+
+    private static final String TABLENAME = ${entity.classNameDao}.TABLENAME;
+    private static final String PK = ${entity.classNameDao}.Properties.${entity.pkProperty.propertyName?cap_first}
+    .columnName;
+
+<#assign counter = 0>
+    private static final int ${entity.className?upper_case}_DIR = ${counter};
+    private static final int ${entity.className?upper_case}_ID = ${counter+1};
+
+    private static final UriMatcher sURIMatcher;
+
+    static {
+    sURIMatcher = new UriMatcher(UriMatcher.NO_MATCH);
+    sURIMatcher.addURI(AUTHORITY, BASE_PATH, ${entity.className?upper_case}_DIR);
+    sURIMatcher.addURI(AUTHORITY, BASE_PATH + "/#", ${entity.className?upper_case}_ID);
+    }
+
+    /**
+    * This must be set from outside, it's recommended to do this inside your Application object.
+    * Subject to change (static isn't nice).
+    */
+    public static DaoSession daoSession;
+
+    @Override
+    public boolean onCreate() {
+    // if(daoSession == null) {
+    // throw new IllegalStateException("DaoSession must be set before content provider is created");
+    // }
+    DaoLog.d("Content Provider started: " + CONTENT_URI);
+    return true;
+    }
+
+    protected SQLiteDatabase getDatabase() {
+    if(daoSession == null) {
+    throw new IllegalStateException("DaoSession must be set during content provider is active");
+    }
+    return daoSession.getDatabase();
+    }
+
+<#--
+##########################################
+########## Insert ##############
+##########################################
+-->
+    @Override
+    public Uri insert(Uri uri, ContentValues values) {
+<#if contentProvider.isReadOnly()>
+    throw new UnsupportedOperationException("This content provider is readonly");
+<#else>
+    int uriType = sURIMatcher.match(uri);
+    long id = 0;
+    String path = "";
+    switch (uriType) {
+    case ${entity.className?upper_case}_DIR:
+    id = getDatabase().insert(TABLENAME, null, values);
+    path = BASE_PATH + "/" + id;
+    break;
+    default:
+    throw new IllegalArgumentException("Unknown URI: " + uri);
+    }
+    getContext().getContentResolver().notifyChange(uri, null);
+    return Uri.parse(path);
+</#if>
+    }
+
+<#--
+##########################################
+########## Delete ##############
+##########################################
+-->
+    @Override
+    public int delete(Uri uri, String selection, String[] selectionArgs) {
+<#if contentProvider.isReadOnly()>
+    throw new UnsupportedOperationException("This content provider is readonly");
+<#else>
+    int uriType = sURIMatcher.match(uri);
+    SQLiteDatabase db = getDatabase();
+    int rowsDeleted = 0;
+    String id;
+    switch (uriType) {
+    case ${entity.className?upper_case}_DIR:
+    rowsDeleted = db.delete(TABLENAME, selection, selectionArgs);
+    break;
+    case ${entity.className?upper_case}_ID:
+    id = uri.getLastPathSegment();
+    if (TextUtils.isEmpty(selection)) {
+    rowsDeleted = db.delete(TABLENAME, PK + "=" + id, null);
+    } else {
+    rowsDeleted = db.delete(TABLENAME, PK + "=" + id + " and "
+    + selection, selectionArgs);
+    }
+    break;
+    default:
+    throw new IllegalArgumentException("Unknown URI: " + uri);
+    }
+    getContext().getContentResolver().notifyChange(uri, null);
+    return rowsDeleted;
+</#if>
+    }
+
+<#--
+##########################################
+########## Update ##############
+##########################################
+-->
+    @Override
+    public int update(Uri uri, ContentValues values, String selection,
+    String[] selectionArgs) {
+<#if contentProvider.isReadOnly()>
+    throw new UnsupportedOperationException("This content provider is readonly");
+<#else>
+    int uriType = sURIMatcher.match(uri);
+    SQLiteDatabase db = getDatabase();
+    int rowsUpdated = 0;
+    String id;
+    switch (uriType) {
+    case ${entity.className?upper_case}_DIR:
+    rowsUpdated = db.update(TABLENAME, values, selection, selectionArgs);
+    break;
+    case ${entity.className?upper_case}_ID:
+    id = uri.getLastPathSegment();
+    if (TextUtils.isEmpty(selection)) {
+    rowsUpdated = db.update(TABLENAME, values, PK + "=" + id, null);
+    } else {
+    rowsUpdated = db.update(TABLENAME, values, PK + "=" + id
+    + " and " + selection, selectionArgs);
+    }
+    break;
+    default:
+    throw new IllegalArgumentException("Unknown URI: " + uri);
+    }
+    getContext().getContentResolver().notifyChange(uri, null);
+    return rowsUpdated;
+</#if>
+    }
+<#--
+##########################################
+########## Query ##############
+##########################################
+-->
+    @Override
+    public Cursor query(Uri uri, String[] projection, String selection,
+    String[] selectionArgs, String sortOrder) {
+
+    SQLiteQueryBuilder queryBuilder = new SQLiteQueryBuilder();
+    int uriType = sURIMatcher.match(uri);
+    switch (uriType) {
+    case ${entity.className?upper_case}_DIR:
+    queryBuilder.setTables(TABLENAME);
+    break;
+    case ${entity.className?upper_case}_ID:
+    queryBuilder.setTables(TABLENAME);
+    queryBuilder.appendWhere(PK + "="
+    + uri.getLastPathSegment());
+    break;
+    default:
+    throw new IllegalArgumentException("Unknown URI: " + uri);
+    }
+
+    SQLiteDatabase db = getDatabase();
+    Cursor cursor = queryBuilder.query(db, projection, selection,
+    selectionArgs, null, null, sortOrder);
+    cursor.setNotificationUri(getContext().getContentResolver(), uri);
+
+    return cursor;
+    }
+
+<#--
+##########################################
+########## GetType ##############
+##########################################
+-->
+    @Override
+    public final String getType(Uri uri) {
+    switch (sURIMatcher.match(uri)) {
+    case ${entity.className?upper_case}_DIR:
+    return CONTENT_TYPE;
+    case ${entity.className?upper_case}_ID:
+    return CONTENT_ITEM_TYPE;
+    default :
+    throw new IllegalArgumentException("Unsupported URI: " + uri);
+    }
+    }
+    }
diff --git a/DaoGenerator/src/de/greenrobot/daogenerator/ContentProvider.java b/DaoGenerator/src/de/greenrobot/daogenerator/ContentProvider.java
new file mode 100644
index 00000000..d0483c2d
--- /dev/null
+++ b/DaoGenerator/src/de/greenrobot/daogenerator/ContentProvider.java
@@ -0,0 +1,79 @@
+package de.greenrobot.daogenerator;
+
+import java.util.List;
+
+public class ContentProvider {
+    private final List<Entity> entities;
+    private String authority;
+    private String basePath;
+    private String className;
+    private String javaPackage;
+    private boolean readOnly;
+    private Schema schema;
+
+    public ContentProvider(Schema schema, List<Entity> entities) {
+        this.schema = schema;
+        this.entities = entities;
+    }
+
+    public String getAuthority() {
+        return authority;
+    }
+
+    public void setAuthority(String authority) {
+        this.authority = authority;
+    }
+
+    public String getBasePath() {
+        return basePath;
+    }
+
+    public void setBasePath(String basePath) {
+        this.basePath = basePath;
+    }
+
+    public String getClassName() {
+        return className;
+    }
+
+    public void setClassName(String className) {
+        this.className = className;
+    }
+
+    public String getJavaPackage() {
+        return javaPackage;
+    }
+
+    public void setJavaPackage(String javaPackage) {
+        this.javaPackage = javaPackage;
+    }
+
+    public boolean isReadOnly() {
+        return readOnly;
+    }
+
+    public void readOnly() {
+        this.readOnly = true;
+    }
+
+    public List<Entity> getEntities() {
+        return entities;
+    }
+
+    public void init2ndPass() {
+        if (authority == null) {
+            authority = schema.getDefaultJavaPackage() + ".provider";
+        }
+        if (basePath == null) {
+            basePath = "";
+        }
+        if (className == null) {
+            className = "EntityContentProvider";
+        }
+        if (javaPackage == null) {
+            javaPackage = schema.getDefaultJavaPackage();
+        }
+
+    }
+
+}
diff --git a/DaoGenerator/src/de/greenrobot/daogenerator/DaoGenerator.java b/DaoGenerator/src/de/greenrobot/daogenerator/DaoGenerator.java
index 52797205..d1604d54 100644
--- a/DaoGenerator/src/de/greenrobot/daogenerator/DaoGenerator.java
+++ b/DaoGenerator/src/de/greenrobot/daogenerator/DaoGenerator.java
@@ -47,6 +47,7 @@
     private Template templateDaoSession;
     private Template templateEntity;
     private Template templateDaoUnitTest;
+    private Template templateContentProvider;
 
     public DaoGenerator() throws IOException {
         System.out.println("greenDAO Generator");
@@ -66,6 +67,7 @@ public DaoGenerator() throws IOException {
         templateDaoSession = config.getTemplate("dao-session.ftl");
         templateEntity = config.getTemplate("entity.ftl");
         templateDaoUnitTest = config.getTemplate("dao-unit-test.ftl");
+        templateContentProvider = config.getTemplate("content-provider.ftl");
     }
 
     private Pattern compilePattern(String sectionName) {
@@ -111,6 +113,12 @@ public void generateAll(Schema schema, String outDir, String outDirTest) throws
                     System.out.println("Skipped " + javaFilename.getCanonicalPath());
                 }
             }
+            for (ContentProvider contentProvider : entity.getContentProviders()) {
+                Map<String, Object> additionalObjectsForTemplate = new HashMap<String, Object>();
+                additionalObjectsForTemplate.put("contentProvider", contentProvider);
+                generate(templateContentProvider, outDirFile, entity.getJavaPackage(), entity.getClassName()
+                        + "ContentProvider", schema, entity, additionalObjectsForTemplate);
+            }
         }
         generate(templateDaoMaster, outDirFile, schema.getDefaultJavaPackageDao(), "DaoMaster", schema, null);
         generate(templateDaoSession, outDirFile, schema.getDefaultJavaPackageDao(), "DaoSession", schema, null);
@@ -123,21 +131,28 @@ protected File toFileForceExists(String filename) throws IOException {
         File file = new File(filename);
         if (!file.exists()) {
             throw new IOException(filename
-                    + " does not exist. This check is to prevent accidential file generation into a wrong path.");
+                    + " does not exist. This check is to prevent accidental file generation into a wrong path.");
         }
         return file;
     }
 
     private void generate(Template template, File outDirFile, String javaPackage, String javaClassName, Schema schema,
             Entity entity) throws Exception {
+        generate(template, outDirFile, javaPackage, javaClassName, schema, entity, null);
+    }
+
+    private void generate(Template template, File outDirFile, String javaPackage, String javaClassName, Schema schema,
+            Entity entity, Map<String, Object> additionalObjectsForTemplate) throws Exception {
+        Map<String, Object> root = new HashMap<String, Object>();
+        root.put("schema", schema);
+        root.put("entity", entity);
+        if (additionalObjectsForTemplate != null) {
+            root.putAll(additionalObjectsForTemplate);
+        }
         try {
             File file = toJavaFilename(outDirFile, javaPackage, javaClassName);
             file.getParentFile().mkdirs();
 
-            Map<String, Object> root = new HashMap<String, Object>();
-            root.put("schema", schema);
-            root.put("entity", entity);
-
             if (entity != null && entity.getHasKeepSections()) {
                 checkKeepSections(file, root);
             }
@@ -151,6 +166,7 @@ private void generate(Template template, File outDirFile, String javaPackage, St
                 writer.close();
             }
         } catch (Exception ex) {
+            System.err.println("Data map for template: " + root);
             System.err.println("Error while generating " + javaPackage + "." + javaClassName + " ("
                     + outDirFile.getCanonicalPath() + ")");
             throw ex;
diff --git a/DaoGenerator/src/de/greenrobot/daogenerator/Entity.java b/DaoGenerator/src/de/greenrobot/daogenerator/Entity.java
index b30e4a68..786cb588 100644
--- a/DaoGenerator/src/de/greenrobot/daogenerator/Entity.java
+++ b/DaoGenerator/src/de/greenrobot/daogenerator/Entity.java
@@ -17,30 +17,19 @@
  */
 package de.greenrobot.daogenerator;
 
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Set;
-import java.util.TreeSet;
-
 import de.greenrobot.daogenerator.Property.PropertyBuilder;
 
+import java.util.*;
+
 /**
  * Model class for an entity: a Java data object mapped to a data base table. A new entity is added to a {@link Schema}
  * by the method {@link Schema#addEntity(String)} (there is no public constructor for {@link Entity} itself). <br/>
- * <br/>
- * Use the various addXXX methods to add entity properties, indexes, and relations to other entities (addToOne,
- * addToMany).<br/>
- * <br/>
- * There are further configuration possibilities:
- * <ul>
- * <li>{@link Entity#implementsInterface(String...)} and {@link #implementsSerializable()} to specify interfaces the
- * entity will implement</li>
- * <li>{@link #setSuperclass(String)} to specify a class of which the entity will extend from</li>
- * <li>Various setXXX methods</li>
- * </ul>
- * 
+ * <br/> Use the various addXXX methods to add entity properties, indexes, and relations to other entities (addToOne,
+ * addToMany).<br/> <br/> There are further configuration possibilities: <ul> <li>{@link
+ * Entity#implementsInterface(String...)} and {@link #implementsSerializable()} to specify interfaces the entity will
+ * implement</li> <li>{@link #setSuperclass(String)} to specify a class of which the entity will extend from</li>
+ * <li>Various setXXX methods</li> </ul>
+ *
  * @see <a href="http://greendao-orm.com/documentation/modelling-entities/">Modelling Entities (Documentation page)</a>
  * @see <a href="http://greendao-orm.com/documentation/relations/">Relations (Documentation page)</a>
  */
@@ -59,6 +48,7 @@
     private final Collection<String> additionalImportsEntity;
     private final Collection<String> additionalImportsDao;
     private final List<String> interfacesToImplement;
+    private final List<ContentProvider> contentProviders;
 
     private String tableName;
     private String classNameDao;
@@ -93,6 +83,7 @@
         additionalImportsEntity = new TreeSet<String>();
         additionalImportsDao = new TreeSet<String>();
         interfacesToImplement = new ArrayList<String>();
+        contentProviders = new ArrayList<ContentProvider>();
         constructors = true;
     }
 
@@ -154,13 +145,13 @@ public PropertyBuilder addIdProperty() {
 
     /** Adds a to-many relationship; the target entity is joined to the PK property of this entity (typically the ID). */
     public ToMany addToMany(Entity target, Property targetProperty) {
-        Property[] targetProperties = { targetProperty };
+        Property[] targetProperties = {targetProperty};
         return addToMany(null, target, targetProperties);
     }
 
     /**
-     * Convenience method for {@link Entity#addToMany(Entity, Property)} with a subsequent call to
-     * {@link ToMany#setName(String)}.
+     * Convenience method for {@link Entity#addToMany(Entity, Property)} with a subsequent call to {@link
+     * ToMany#setName(String)}.
      */
     public ToMany addToMany(Entity target, Property targetProperty, String name) {
         ToMany toMany = addToMany(target, targetProperty);
@@ -173,13 +164,13 @@ public ToMany addToMany(Entity target, Property targetProperty, String name) {
      * and given source property (of this entity).
      */
     public ToMany addToMany(Property sourceProperty, Entity target, Property targetProperty) {
-        Property[] sourceProperties = { sourceProperty };
-        Property[] targetProperties = { targetProperty };
+        Property[] sourceProperties = {sourceProperty};
+        Property[] targetProperties = {targetProperty};
         return addToMany(sourceProperties, target, targetProperties);
     }
 
     public ToMany addToMany(Property[] sourceProperties, Entity target, Property[] targetProperties) {
-        if(protobuf) {
+        if (protobuf) {
             throw new IllegalStateException("Protobuf entities do not support realtions, currently");
         }
 
@@ -194,11 +185,11 @@ public ToMany addToMany(Property[] sourceProperties, Entity target, Property[] t
      * to this entity).
      */
     public ToOne addToOne(Entity target, Property fkProperty) {
-        if(protobuf) {
+        if (protobuf) {
             throw new IllegalStateException("Protobuf entities do not support realtions, currently");
         }
 
-        Property[] fkProperties = { fkProperty };
+        Property[] fkProperties = {fkProperty};
         ToOne toOne = new ToOne(schema, this, target, fkProperties, true);
         toOneRelations.add(toOne);
         return toOne;
@@ -216,7 +207,7 @@ public ToOne addToOneWithoutProperty(String name, Entity target, String fkColumn
     }
 
     public ToOne addToOneWithoutProperty(String name, Entity target, String fkColumnName, boolean notNull,
-            boolean unique) {
+                                         boolean unique) {
         PropertyBuilder propertyBuilder = new PropertyBuilder(schema, this, null, name);
         if (notNull) {
             propertyBuilder.notNull();
@@ -226,7 +217,7 @@ public ToOne addToOneWithoutProperty(String name, Entity target, String fkColumn
         }
         propertyBuilder.columnName(fkColumnName);
         Property column = propertyBuilder.getProperty();
-        Property[] fkColumns = { column };
+        Property[] fkColumns = {column};
         ToOne toOne = new ToOne(schema, this, target, fkColumns, false);
         toOne.setName(name);
         toOneRelations.add(toOne);
@@ -237,9 +228,14 @@ protected void addIncomingToMany(ToMany toMany) {
         incomingToManyRelations.add(toMany);
     }
 
-    /**
-     * Adds a new index to the entity.
-     */
+    public ContentProvider addContentProvider() {
+        List<Entity> entities = new ArrayList<Entity>();
+        ContentProvider contentProvider = new ContentProvider(schema, entities);
+        contentProviders.add(contentProvider);
+        return contentProvider;
+    }
+
+    /** Adds a new index to the entity. */
     public Entity addIndex(Index index) {
         indexes.add(index);
         return this;
@@ -364,13 +360,11 @@ public void setSkipGeneration(boolean skipGeneration) {
         this.skipGeneration = skipGeneration;
     }
 
-    /**
-     * Flag if CREATE & DROP TABLE scripts should be skipped in Dao.
-     */
+    /** Flag if CREATE & DROP TABLE scripts should be skipped in Dao. */
     public void setSkipTableCreation(boolean skipTableCreation) {
         this.skipTableCreation = skipTableCreation;
     }
-    
+
     public boolean isSkipTableCreation() {
         return skipTableCreation;
     }
@@ -427,6 +421,10 @@ public void setHasKeepSections(Boolean hasKeepSections) {
         return interfacesToImplement;
     }
 
+    public List<ContentProvider> getContentProviders() {
+        return contentProviders;
+    }
+
     public void implementsInterface(String... interfaces) {
         for (String interfaceToImplement : interfaces) {
             interfacesToImplement.add(interfaceToImplement);
@@ -503,6 +501,10 @@ void init2ndPass() {
         }
 
         init2ndPassIndexNamesWithDefaults();
+
+        for (ContentProvider contentProvider : contentProviders) {
+            contentProvider.init2ndPass();
+        }
     }
 
     protected void init2nPassNamesWithDefaults() {
diff --git a/DaoTest/.classpath b/DaoTest/.classpath
index 96ce885e..80819056 100644
--- a/DaoTest/.classpath
+++ b/DaoTest/.classpath
@@ -4,6 +4,7 @@
 	<classpathentry kind="src" path="gen"/>
 	<classpathentry kind="src" path="src-gen"/>
 	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
-	<classpathentry kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
 	<classpathentry kind="output" path="bin/classes"/>
 </classpath>
diff --git a/DaoTest/AndroidManifest.xml b/DaoTest/AndroidManifest.xml
index ac5936ec..c701be68 100644
--- a/DaoTest/AndroidManifest.xml
+++ b/DaoTest/AndroidManifest.xml
@@ -1,12 +1,24 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
-      package="de.greenrobot.daotest"
-      android:versionCode="1"
-      android:versionName="1.0">
+    package="de.greenrobot.daotest"
+    android:versionCode="1"
+    android:versionName="1.0" >
+
     <uses-sdk android:minSdkVersion="4" />
-    <instrumentation android:targetPackage="de.greenrobot.daotest" android:name="android.test.InstrumentationTestRunner" />
-    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"></uses-permission>
+
+    <instrumentation
+        android:name="android.test.InstrumentationTestRunner"
+        android:targetPackage="de.greenrobot.daotest" />
+
+    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" >
+    </uses-permission>
+
     <application>
         <uses-library android:name="android.test.runner" />
+
+        <provider
+            android:name="de.greenrobot.daotest.SimpleEntityContentProvider"
+            android:authorities="de.greenrobot.daotest" />
     </application>
+
 </manifest>
\ No newline at end of file
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntityContentProvider.java b/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntityContentProvider.java
new file mode 100644
index 00000000..1375e1cf
--- /dev/null
+++ b/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntityContentProvider.java
@@ -0,0 +1,123 @@
+package de.greenrobot.daotest;
+
+import android.content.ContentProvider;
+import android.content.ContentResolver;
+import android.content.ContentValues;
+import android.content.UriMatcher;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteQueryBuilder;
+import android.net.Uri;
+
+import de.greenrobot.dao.DaoLog;
+
+import de.greenrobot.daotest.SimpleEntityDao;
+
+/* Copy this code snippet into your AndroidManifest.xml inside the <application> element:
+
+    <provider
+        android:name="de.greenrobot.daotest.SimpleEntityContentProvider"
+        android:authorities="de.greenrobot.daotest" />
+*/
+
+public class SimpleEntityContentProvider extends ContentProvider {
+
+    public static final String AUTHORITY = "de.greenrobot.daotest";
+    public static final String BASE_PATH = "SimpleEntity";
+    public static final Uri CONTENT_URI = Uri.parse("content://" + AUTHORITY + "/" + BASE_PATH);
+    public static final String CONTENT_TYPE = ContentResolver.CURSOR_DIR_BASE_TYPE
+            + "/" + BASE_PATH;
+    public static final String CONTENT_ITEM_TYPE = ContentResolver.CURSOR_ITEM_BASE_TYPE
+            + "/" + BASE_PATH;
+            
+    private static final String TABLENAME = SimpleEntityDao.TABLENAME;
+    private static final String PK = SimpleEntityDao.Properties.Id.columnName;
+
+    private static final int SIMPLEENTITY_DIR = 0;
+    private static final int SIMPLEENTITY_ID = 1;
+
+    private static final UriMatcher sURIMatcher;
+     
+    static {
+        sURIMatcher = new UriMatcher(UriMatcher.NO_MATCH);      
+        sURIMatcher.addURI(AUTHORITY, BASE_PATH, SIMPLEENTITY_DIR);
+        sURIMatcher.addURI(AUTHORITY, BASE_PATH + "/#", SIMPLEENTITY_ID);
+    }
+    
+    /** 
+    * This must be set from outside, it's recommended to do this inside your Application object.
+    * Subject to change (static isn't nice).
+    */
+    public static DaoSession daoSession;
+    
+    @Override
+    public boolean onCreate() {
+        // if(daoSession == null) {
+        //     throw new IllegalStateException("DaoSession must be set before content provider is created");
+        // }
+        DaoLog.d("Content Provider started: " + CONTENT_URI);
+        return true;
+    }
+    
+    protected SQLiteDatabase getDatabase() {
+        if(daoSession == null) {
+            throw new IllegalStateException("DaoSession must be set during content provider is active");
+        }
+        return daoSession.getDatabase();
+    }
+        
+    @Override
+    public Uri insert(Uri uri, ContentValues values) {
+        throw new UnsupportedOperationException("This content provider is readonly");
+    }
+
+    @Override
+    public int delete(Uri uri, String selection, String[] selectionArgs) {
+        throw new UnsupportedOperationException("This content provider is readonly");
+    }
+    
+    @Override
+    public int update(Uri uri, ContentValues values, String selection,
+            String[] selectionArgs) {
+        throw new UnsupportedOperationException("This content provider is readonly");
+    }
+ 
+    @Override
+    public Cursor query(Uri uri, String[] projection, String selection,
+            String[] selectionArgs, String sortOrder) {
+
+        SQLiteQueryBuilder queryBuilder = new SQLiteQueryBuilder();
+        int uriType = sURIMatcher.match(uri);
+        switch (uriType) {
+        case SIMPLEENTITY_DIR:
+            queryBuilder.setTables(TABLENAME);
+            break;
+        case SIMPLEENTITY_ID:
+            queryBuilder.setTables(TABLENAME);
+            queryBuilder.appendWhere(PK + "="
+                    + uri.getLastPathSegment());
+            break;
+        default:
+            throw new IllegalArgumentException("Unknown URI: " + uri);
+        }
+
+        SQLiteDatabase db = getDatabase();
+        Cursor cursor = queryBuilder.query(db, projection, selection,
+                selectionArgs, null, null, sortOrder);
+        cursor.setNotificationUri(getContext().getContentResolver(), uri);
+
+        return cursor;
+    }
+    
+    @Override
+    public final String getType(Uri uri) {
+        switch (sURIMatcher.match(uri)) {
+        case SIMPLEENTITY_DIR:
+            return CONTENT_TYPE;
+        case SIMPLEENTITY_ID:
+            return CONTENT_ITEM_TYPE;
+        default :
+            throw new IllegalArgumentException("Unsupported URI: " + uri);
+        }
+    }
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/contentprovider/SimpleEntityContentProviderTest.java b/DaoTest/src/de/greenrobot/daotest/contentprovider/SimpleEntityContentProviderTest.java
new file mode 100644
index 00000000..e1feb66e
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/contentprovider/SimpleEntityContentProviderTest.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.contentprovider;
+
+import android.app.Application;
+import android.database.Cursor;
+import de.greenrobot.dao.test.AbstractDaoSessionTest;
+import de.greenrobot.daotest.DaoMaster;
+import de.greenrobot.daotest.DaoSession;
+import de.greenrobot.daotest.SimpleEntity;
+import de.greenrobot.daotest.SimpleEntityContentProvider;
+import de.greenrobot.daotest.SimpleEntityDao;
+
+public class SimpleEntityContentProviderTest extends AbstractDaoSessionTest<Application, DaoMaster, DaoSession> {
+
+    public SimpleEntityContentProviderTest() {
+        super(DaoMaster.class);
+    }
+
+    @Override
+    protected void setUp() {
+        super.setUp();
+        SimpleEntityContentProvider.daoSession = daoSession;
+    }
+
+    public void testQuery() {
+        SimpleEntity entity = new SimpleEntity();
+        entity.setSimpleString("hello");
+        daoSession.insert(entity);
+        long id = entity.getId();
+
+        SimpleEntity entity2 = new SimpleEntity();
+        entity2.setSimpleString("content");
+        daoSession.insert(entity2);
+        long id2 = entity2.getId();
+
+        Cursor cursor = getApplication().getContentResolver().query(SimpleEntityContentProvider.CONTENT_URI, null,
+                null, null, "_id");
+        assertEquals(2, cursor.getCount());
+        int idxId = cursor.getColumnIndexOrThrow(SimpleEntityDao.Properties.Id.columnName);
+        int idxString = cursor.getColumnIndexOrThrow(SimpleEntityDao.Properties.SimpleString.columnName);
+
+        assertTrue(cursor.moveToFirst());
+        assertEquals("hello", cursor.getString(idxString));
+        assertEquals(id, cursor.getLong(idxId));
+
+        assertTrue(cursor.moveToNext());
+        assertEquals("content", cursor.getString(idxString));
+        assertEquals(id2, cursor.getLong(idxId));
+    }
+
+}
\ No newline at end of file
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/AnActiveEntityMultithreadingTest.java b/DaoTest/src/de/greenrobot/daotest/entity/AnActiveEntityMultithreadingTest.java
new file mode 100644
index 00000000..ea91d851
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/entity/AnActiveEntityMultithreadingTest.java
@@ -0,0 +1,129 @@
+/*
+ * Copyright (C) 2013 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.entity;
+
+import java.lang.reflect.Field;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+import android.app.Application;
+import de.greenrobot.dao.DaoLog;
+import de.greenrobot.dao.test.AbstractDaoSessionTest;
+import de.greenrobot.daotest.AnActiveEntity;
+import de.greenrobot.daotest.AnActiveEntityDao;
+import de.greenrobot.daotest.DaoMaster;
+import de.greenrobot.daotest.DaoSession;
+
+public class AnActiveEntityMultithreadingTest extends AbstractDaoSessionTest<Application, DaoMaster, DaoSession> {
+
+    /** Serious multithreading tests require this set to true. */
+    private static final boolean LONG_RUNNING = false;
+    private static final int ENTITIES_TO_CHECK = LONG_RUNNING ? 1000000 : 10000;
+
+    private AnActiveEntityDao dao;
+    private CountDownLatch latch = new CountDownLatch(2);
+    volatile boolean running = true;
+
+    public AnActiveEntityMultithreadingTest() {
+        super(DaoMaster.class);
+    }
+
+    @Override
+    protected void setUp() {
+        super.setUp();
+        dao = daoSession.getAnActiveEntityDao();
+    }
+
+    public void testAlwaysAttachedWithInsertDelete() throws Exception {
+        doTestAlwaysAttached(new InsertDeleteThread());
+    }
+
+    public void testAlwaysAttachedWithDetach() throws Exception {
+        doTestAlwaysAttached(new DetachThread());
+    }
+
+    private void doTestAlwaysAttached(Thread thread) throws Exception {
+        thread.start();
+
+        Field daoSessionField = AnActiveEntity.class.getDeclaredField("daoSession");
+        daoSessionField.setAccessible(true);
+
+        int countEntity = 0;
+        countDownAndAwaitLatch();
+
+        try {
+            assertTrue(latch.await(10, TimeUnit.SECONDS));
+            for (int i = 0;; i++) {
+                AnActiveEntity entity = dao.load(1l);
+                if (entity != null) {
+                    countEntity++;
+                    assertNotNull(daoSessionField.get(entity));
+                }
+                if (i == 1000000 && countEntity == 0) {
+                    fail("No entity available");
+                }
+                if (countEntity % 10000 == 0) {
+                    DaoLog.d("Checked entities " + countEntity + " in " + i + " iterations");
+                }
+                if (countEntity == ENTITIES_TO_CHECK) {
+                    break;
+                }
+            }
+        } finally {
+            running = false;
+            thread.join();
+        }
+    }
+
+    private void countDownAndAwaitLatch() {
+        latch.countDown();
+        try {
+            assertTrue(latch.await(10, TimeUnit.SECONDS));
+        } catch (InterruptedException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    class InsertDeleteThread extends Thread {
+        @Override
+        public void run() {
+            countDownAndAwaitLatch();
+
+            while (running) {
+                AnActiveEntity entity = null;
+                entity = new AnActiveEntity(1l);
+                dao.insert(entity);
+                dao.delete(entity);
+            }
+        }
+    }
+
+    class DetachThread extends Thread {
+        @Override
+        public void run() {
+            countDownAndAwaitLatch();
+
+            AnActiveEntity entity = new AnActiveEntity(1l);
+            dao.insert(entity);
+            while (running) {
+                dao.detach(entity);
+                entity = dao.load(1l);
+            }
+        }
+    }
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/StringKeyValueEntityIdentityScopeTest.java b/DaoTest/src/de/greenrobot/daotest/entity/StringKeyValueEntityIdentityScopeTest.java
index 70cd0728..94ee3e40 100644
--- a/DaoTest/src/de/greenrobot/daotest/entity/StringKeyValueEntityIdentityScopeTest.java
+++ b/DaoTest/src/de/greenrobot/daotest/entity/StringKeyValueEntityIdentityScopeTest.java
@@ -37,6 +37,17 @@ public void testLoadIdScope() {
         assertSame(entity2, entity3);
     }
 
+    public void testLoadIdScope_load() {
+        StringKeyValueEntity entity = createEntityWithRandomPk();
+        dao.insert(entity);
+        dao.detach(entity);
+        StringKeyValueEntity entity2 = dao.load(entity.getKey());
+        StringKeyValueEntity entity3 = dao.load(entity.getKey());
+
+        assertNotSame(entity, entity2);
+        assertSame(entity2, entity3);
+    }
+
     public void testDetach() {
         StringKeyValueEntity entity = createEntityWithRandomPk();
         dao.insert(entity);
diff --git a/DaoTest/src/de/greenrobot/daotest/query/CountQueryTest.java b/DaoTest/src/de/greenrobot/daotest/query/CountQueryTest.java
index 0218bd46..c8d66267 100644
--- a/DaoTest/src/de/greenrobot/daotest/query/CountQueryTest.java
+++ b/DaoTest/src/de/greenrobot/daotest/query/CountQueryTest.java
@@ -51,6 +51,51 @@ public void testCountQuerySimple() {
         assertEquals(0, query.count());
     }
 
+    public void testCountQueryTwoParameters() {
+        int value = getSimpleInteger(1);
+        String valueString = getSimpleString(1);
+        
+        QueryBuilder<TestEntity> queryBuilder = dao.queryBuilder();
+        queryBuilder.where(Properties.SimpleInteger.eq(value), Properties.SimpleString.eq(valueString));
+        CountQuery<TestEntity> query = queryBuilder.buildCount();
+        assertEquals(0, query.count());
+
+        ArrayList<TestEntity> inserted = insert(3);
+        assertEquals(1, query.count());
+
+        inserted.get(2).setSimpleInteger(value);
+        dao.update(inserted.get(2));
+        assertEquals(1, query.count());
+        
+        inserted.get(2).setSimpleString(valueString);
+        dao.update(inserted.get(2));
+        assertEquals(2, query.count());
+
+        dao.deleteAll();
+        assertEquals(0, query.count());
+    }
+
+    public void testCountQueryTwoParametersOr() {
+        int value = getSimpleInteger(1);
+        String valueString = getSimpleString(2);
+        
+        QueryBuilder<TestEntity> queryBuilder = dao.queryBuilder();
+        queryBuilder.whereOr(Properties.SimpleInteger.eq(value), Properties.SimpleString.eq(valueString));
+        CountQuery<TestEntity> query = queryBuilder.buildCount();
+        assertEquals(0, query.count());
+
+        ArrayList<TestEntity> inserted = insert(3);
+        assertEquals(2, query.count());
+
+        inserted.get(1).setSimpleInteger(getSimpleInteger(2));
+        dao.update(inserted.get(1));
+        assertEquals(1, query.count());
+        
+        inserted.get(2).setSimpleString(getSimpleString(3));
+        dao.update(inserted.get(2));
+        assertEquals(0, query.count());
+    }
+
     public void testCountQueryChangeParameter() {
         insert(3);
 
diff --git a/DaoTest/src/de/greenrobot/daotest/query/DeleteQueryTest.java b/DaoTest/src/de/greenrobot/daotest/query/DeleteQueryTest.java
index bf86e687..12e2a651 100644
--- a/DaoTest/src/de/greenrobot/daotest/query/DeleteQueryTest.java
+++ b/DaoTest/src/de/greenrobot/daotest/query/DeleteQueryTest.java
@@ -1,102 +1,118 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daotest.query;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import de.greenrobot.dao.query.DeleteQuery;
-import de.greenrobot.dao.query.Query;
-import de.greenrobot.dao.query.QueryBuilder;
-import de.greenrobot.daotest.TestEntity;
-import de.greenrobot.daotest.TestEntityDao.Properties;
-import de.greenrobot.daotest.entity.TestEntityTestBase;
-
-// TODO more tests
-public class DeleteQueryTest extends TestEntityTestBase {
-    @Override
-    protected void setUp() {
-        super.setUp();
-        QueryBuilder.LOG_SQL = true;
-        QueryBuilder.LOG_VALUES = true;
-    }
-
-    public void testDeleteQuerySimple() {
-        ArrayList<TestEntity> inserted = insert(3);
-        int value = getSimpleInteger(1);
-        inserted.get(2).setSimpleInteger(value);
-        dao.update(inserted.get(2));
-
-        DeleteQuery<TestEntity> deleteQuery = dao.queryBuilder().where(Properties.SimpleInteger.eq(value))
-                .buildDelete();
-
-        deleteQuery.executeDeleteWithoutDetachingEntities();
-
-        List<TestEntity> allAfterDelete = dao.loadAll();
-        assertEquals(1, allAfterDelete.size());
-        assertEquals(getSimpleInteger(0), (int) allAfterDelete.get(0).getSimpleInteger());
-    }
-
-    public void testDeleteQueryExecutingMultipleTimes() {
-        insert(3);
-
-        String value = getSimpleString(1);
-        DeleteQuery<TestEntity> deleteQuery = dao.queryBuilder().where(Properties.SimpleString.eq(value)).buildDelete();
-        deleteQuery.executeDeleteWithoutDetachingEntities();
-        assertEquals(2, dao.count());
-
-        deleteQuery.executeDeleteWithoutDetachingEntities();
-        assertEquals(2, dao.count());
-
-        insert(3);
-        assertEquals(5, dao.count());
-
-        deleteQuery.executeDeleteWithoutDetachingEntities();
-        assertEquals(4, dao.count());
-    }
-
-    public void testDeleteQueryChangeParameter() {
-        insert(3);
-
-        String value = getSimpleString(1);
-        DeleteQuery<TestEntity> deleteQuery = dao.queryBuilder().where(Properties.SimpleString.eq(value)).buildDelete();
-        deleteQuery.executeDeleteWithoutDetachingEntities();
-        assertEquals(2, dao.count());
-
-        deleteQuery.setParameter(0, getSimpleString(0));
-        deleteQuery.executeDeleteWithoutDetachingEntities();
-        assertEquals(1, dao.count());
-
-        TestEntity remaining = dao.loadAll().get(0);
-        assertEquals(getSimpleString(2), remaining.getSimpleString());
-    }
-    
-    public void testBuildQueryAndDeleteQuery() {
-        insert(3);
-        int value = getSimpleInteger(1);
-
-        QueryBuilder<TestEntity> builder = dao.queryBuilder().where(Properties.SimpleInteger.eq(value));
-        Query<TestEntity> query = builder.build();
-        DeleteQuery<TestEntity> deleteQuery = builder.buildDelete();
-
-        assertEquals(1, query.list().size());
-        deleteQuery.executeDeleteWithoutDetachingEntities();
-        assertEquals(0, query.list().size());
-    }
-
-}
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.query;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import de.greenrobot.dao.query.DeleteQuery;
+import de.greenrobot.dao.query.Query;
+import de.greenrobot.dao.query.QueryBuilder;
+import de.greenrobot.daotest.TestEntity;
+import de.greenrobot.daotest.TestEntityDao.Properties;
+import de.greenrobot.daotest.entity.TestEntityTestBase;
+
+// TODO more tests
+public class DeleteQueryTest extends TestEntityTestBase {
+    @Override
+    protected void setUp() {
+        super.setUp();
+        QueryBuilder.LOG_SQL = true;
+        QueryBuilder.LOG_VALUES = true;
+    }
+
+    public void testDeleteQuerySimple() {
+        ArrayList<TestEntity> inserted = insert(3);
+        int value = getSimpleInteger(1);
+        inserted.get(2).setSimpleInteger(value);
+        dao.update(inserted.get(2));
+
+        DeleteQuery<TestEntity> deleteQuery = dao.queryBuilder().where(Properties.SimpleInteger.eq(value))
+                .buildDelete();
+
+        deleteQuery.executeDeleteWithoutDetachingEntities();
+
+        List<TestEntity> allAfterDelete = dao.loadAll();
+        assertEquals(1, allAfterDelete.size());
+        assertEquals(getSimpleInteger(0), (int) allAfterDelete.get(0).getSimpleInteger());
+    }
+
+    public void testDeleteQueryOr() {
+        ArrayList<TestEntity> inserted = insert(3);
+
+        QueryBuilder<TestEntity> queryBuilder = dao.queryBuilder();
+        Integer value1 = inserted.get(0).getSimpleInteger();
+        Integer value2 = inserted.get(2).getSimpleInteger();
+        queryBuilder.whereOr(Properties.SimpleInteger.eq(value1), Properties.SimpleInteger.eq(value2));
+        DeleteQuery<TestEntity> deleteQuery = queryBuilder.buildDelete();
+
+        deleteQuery.executeDeleteWithoutDetachingEntities();
+
+        List<TestEntity> allAfterDelete = dao.loadAll();
+        assertEquals(1, allAfterDelete.size());
+        assertEquals(inserted.get(1).getSimpleInteger(), allAfterDelete.get(0).getSimpleInteger());
+    }
+
+    public void testDeleteQueryExecutingMultipleTimes() {
+        insert(3);
+
+        String value = getSimpleString(1);
+        DeleteQuery<TestEntity> deleteQuery = dao.queryBuilder().where(Properties.SimpleString.eq(value)).buildDelete();
+        deleteQuery.executeDeleteWithoutDetachingEntities();
+        assertEquals(2, dao.count());
+
+        deleteQuery.executeDeleteWithoutDetachingEntities();
+        assertEquals(2, dao.count());
+
+        insert(3);
+        assertEquals(5, dao.count());
+
+        deleteQuery.executeDeleteWithoutDetachingEntities();
+        assertEquals(4, dao.count());
+    }
+
+    public void testDeleteQueryChangeParameter() {
+        insert(3);
+
+        String value = getSimpleString(1);
+        DeleteQuery<TestEntity> deleteQuery = dao.queryBuilder().where(Properties.SimpleString.eq(value)).buildDelete();
+        deleteQuery.executeDeleteWithoutDetachingEntities();
+        assertEquals(2, dao.count());
+
+        deleteQuery.setParameter(0, getSimpleString(0));
+        deleteQuery.executeDeleteWithoutDetachingEntities();
+        assertEquals(1, dao.count());
+
+        TestEntity remaining = dao.loadAll().get(0);
+        assertEquals(getSimpleString(2), remaining.getSimpleString());
+    }
+
+    public void testBuildQueryAndDeleteQuery() {
+        insert(3);
+        int value = getSimpleInteger(1);
+
+        QueryBuilder<TestEntity> builder = dao.queryBuilder().where(Properties.SimpleInteger.eq(value));
+        Query<TestEntity> query = builder.build();
+        DeleteQuery<TestEntity> deleteQuery = builder.buildDelete();
+
+        assertEquals(1, query.list().size());
+        deleteQuery.executeDeleteWithoutDetachingEntities();
+        assertEquals(0, query.list().size());
+    }
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/query/QueryBuilderAndOrTest.java b/DaoTest/src/de/greenrobot/daotest/query/QueryBuilderAndOrTest.java
index ffb7a7c1..d9e946b2 100644
--- a/DaoTest/src/de/greenrobot/daotest/query/QueryBuilderAndOrTest.java
+++ b/DaoTest/src/de/greenrobot/daotest/query/QueryBuilderAndOrTest.java
@@ -1,139 +1,161 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daotest.query;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import de.greenrobot.dao.query.QueryBuilder;
-import de.greenrobot.dao.test.AbstractDaoTest;
-import de.greenrobot.daotest.AbcdefEntity;
-import de.greenrobot.daotest.AbcdefEntityDao;
-import de.greenrobot.daotest.AbcdefEntityDao.Properties;
-
-public class QueryBuilderAndOrTest extends AbstractDaoTest<AbcdefEntityDao, AbcdefEntity, Long> {
-
-    public QueryBuilderAndOrTest() {
-        super(AbcdefEntityDao.class);
-        QueryBuilder.LOG_SQL = true;
-        QueryBuilder.LOG_VALUES = true;
-    }
-
-    protected ArrayList<AbcdefEntity> insert(int count) {
-        ArrayList<AbcdefEntity> list = new ArrayList<AbcdefEntity>();
-        for (int i = 0; i < count; i++) {
-            int base = i * 100;
-            AbcdefEntity entity = new AbcdefEntity(null, base + 1, base + 2, base + 3, base + 4, base + 5, base + 6,
-                    base + 7, base + 8, base + 9, base + 10, base + 11);
-            list.add(entity);
-        }
-        dao.insertInTx(list);
-        return list;
-    }
-
-    public void testSimpleQuery() {
-        insert(3);
-
-        List<AbcdefEntity> result = dao.queryBuilder().where(Properties.A.eq(1)).orderAsc(Properties.A).list();
-        assertEquals(1, result.size());
-
-        AbcdefEntity resultEntity = result.get(0);
-        assertEquals(1, (int) resultEntity.getA());
-    }
-
-    public void testOr() {
-        insert(3);
-
-        QueryBuilder<AbcdefEntity> qb = dao.queryBuilder();
-        qb.whereOr(Properties.A.eq(1), Properties.A.eq(101));
-        List<AbcdefEntity> result = qb.orderAsc(Properties.A).list();
-        assertEquals(2, result.size());
-
-        assertEquals(1, (int) result.get(0).getA());
-        assertEquals(101, (int) result.get(1).getA());
-    }
-
-    public void testOr3() {
-        insert(5);
-
-        QueryBuilder<AbcdefEntity> qb = dao.queryBuilder();
-        qb.whereOr(Properties.A.eq(1), Properties.A.eq(101), Properties.B.eq(302));
-        List<AbcdefEntity> result = qb.orderAsc(Properties.A).list();
-        assertEquals(3, result.size());
-
-        assertEquals(1, (int) result.get(0).getA());
-        assertEquals(101, (int) result.get(1).getA());
-        assertEquals(301, (int) result.get(2).getA());
-    }
-
-    public void testOrNested() {
-        insert(10);
-
-        QueryBuilder<AbcdefEntity> qb = dao.queryBuilder();
-        qb.whereOr(Properties.A.eq(101), //
-                Properties.B.eq(302), Properties.C.eq(603));
-        List<AbcdefEntity> result = qb.orderAsc(Properties.A).list();
-        assertEquals(3, result.size());
-
-        assertEquals(101, (int) result.get(0).getA());
-        assertEquals(301, (int) result.get(1).getA());
-        assertEquals(601, (int) result.get(2).getA());
-    }
-
-    public void testOrNestedNested() {
-        insert(10);
-
-        QueryBuilder<AbcdefEntity> qb = dao.queryBuilder();
-        qb.whereOr(Properties.A.eq(101), //
-                qb.or(Properties.B.eq(302), //
-                        qb.or(Properties.C.eq(503), Properties.D.eq(804))));
-        List<AbcdefEntity> result = qb.orderAsc(Properties.A).list();
-        assertEquals(4, result.size());
-
-        assertEquals(101, (int) result.get(0).getA());
-        assertEquals(301, (int) result.get(1).getA());
-        assertEquals(501, (int) result.get(2).getA());
-        assertEquals(801, (int) result.get(3).getA());
-    }
-
-    public void testAnd() {
-        insert(5);
-
-        QueryBuilder<AbcdefEntity> qb = dao.queryBuilder();
-        qb.where(Properties.A.eq(201), Properties.B.eq(202));
-        List<AbcdefEntity> result = qb.orderAsc(Properties.A).list();
-        assertEquals(1, result.size());
-
-        assertEquals(201, (int) result.get(0).getA());
-    }
-
-    public void testOrAnd() {
-        insert(10);
-
-        QueryBuilder<AbcdefEntity> qb = dao.queryBuilder();
-        qb.whereOr(Properties.A.eq(201), //
-                qb.and(Properties.B.gt(402), Properties.C.lt(703)));
-        List<AbcdefEntity> result = qb.orderAsc(Properties.A).list();
-        assertEquals(3, result.size());
-
-        assertEquals(201, (int) result.get(0).getA());
-        assertEquals(501, (int) result.get(1).getA());
-        assertEquals(601, (int) result.get(2).getA());
-    }
-
-}
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.query;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import de.greenrobot.dao.query.QueryBuilder;
+import de.greenrobot.dao.test.AbstractDaoTest;
+import de.greenrobot.daotest.AbcdefEntity;
+import de.greenrobot.daotest.AbcdefEntityDao;
+import de.greenrobot.daotest.AbcdefEntityDao.Properties;
+
+public class QueryBuilderAndOrTest extends AbstractDaoTest<AbcdefEntityDao, AbcdefEntity, Long> {
+
+    public QueryBuilderAndOrTest() {
+        super(AbcdefEntityDao.class);
+        QueryBuilder.LOG_SQL = true;
+        QueryBuilder.LOG_VALUES = true;
+    }
+
+    protected ArrayList<AbcdefEntity> insert(int count) {
+        ArrayList<AbcdefEntity> list = new ArrayList<AbcdefEntity>();
+        for (int i = 0; i < count; i++) {
+            int base = i * 100;
+            AbcdefEntity entity = new AbcdefEntity(null, base + 1, base + 2, base + 3, base + 4, base + 5, base + 6,
+                    base + 7, base + 8, base + 9, base + 10, base + 11);
+            list.add(entity);
+        }
+        dao.insertInTx(list);
+        return list;
+    }
+
+    public void testSimpleQuery() {
+        insert(3);
+
+        QueryBuilder<AbcdefEntity> queryBuilder = dao.queryBuilder().where(Properties.A.eq(1)).orderAsc(Properties.A);
+        List<AbcdefEntity> result = queryBuilder.list();
+        assertEquals(1, result.size());
+        assertEquals(1, queryBuilder.count());
+
+        AbcdefEntity resultEntity = result.get(0);
+        assertEquals(1, (int) resultEntity.getA());
+
+        queryBuilder.buildDelete().executeDeleteWithoutDetachingEntities();
+    }
+
+    public void testOr() {
+        insert(3);
+
+        QueryBuilder<AbcdefEntity> queryBuilder = dao.queryBuilder();
+        queryBuilder.whereOr(Properties.A.eq(1), Properties.A.eq(101));
+        List<AbcdefEntity> result = queryBuilder.orderAsc(Properties.A).list();
+        assertEquals(2, result.size());
+        assertEquals(2, queryBuilder.count());
+
+        assertEquals(1, (int) result.get(0).getA());
+        assertEquals(101, (int) result.get(1).getA());
+
+        queryBuilder.buildDelete().executeDeleteWithoutDetachingEntities();
+    }
+
+    public void testOr3() {
+        insert(5);
+
+        QueryBuilder<AbcdefEntity> queryBuilder = dao.queryBuilder();
+        queryBuilder.whereOr(Properties.A.eq(1), Properties.A.eq(101), Properties.B.eq(302));
+        List<AbcdefEntity> result = queryBuilder.orderAsc(Properties.A).list();
+        assertEquals(3, result.size());
+        assertEquals(3, queryBuilder.count());
+
+        assertEquals(1, (int) result.get(0).getA());
+        assertEquals(101, (int) result.get(1).getA());
+        assertEquals(301, (int) result.get(2).getA());
+
+        queryBuilder.buildDelete().executeDeleteWithoutDetachingEntities();
+    }
+
+    public void testOrNested() {
+        insert(10);
+
+        QueryBuilder<AbcdefEntity> queryBuilder = dao.queryBuilder();
+        queryBuilder.whereOr(Properties.A.eq(101), //
+                Properties.B.eq(302), Properties.C.eq(603));
+        List<AbcdefEntity> result = queryBuilder.orderAsc(Properties.A).list();
+        assertEquals(3, result.size());
+        assertEquals(3, queryBuilder.count());
+
+        assertEquals(101, (int) result.get(0).getA());
+        assertEquals(301, (int) result.get(1).getA());
+        assertEquals(601, (int) result.get(2).getA());
+
+        queryBuilder.buildDelete().executeDeleteWithoutDetachingEntities();
+    }
+
+    public void testOrNestedNested() {
+        insert(10);
+
+        QueryBuilder<AbcdefEntity> queryBuilder = dao.queryBuilder();
+        queryBuilder.whereOr(Properties.A.eq(101), //
+                queryBuilder.or(Properties.B.eq(302), //
+                        queryBuilder.or(Properties.C.eq(503), Properties.D.eq(804))));
+        List<AbcdefEntity> result = queryBuilder.orderAsc(Properties.A).list();
+        assertEquals(4, result.size());
+        assertEquals(4, queryBuilder.count());
+
+        assertEquals(101, (int) result.get(0).getA());
+        assertEquals(301, (int) result.get(1).getA());
+        assertEquals(501, (int) result.get(2).getA());
+        assertEquals(801, (int) result.get(3).getA());
+
+        queryBuilder.buildDelete().executeDeleteWithoutDetachingEntities();
+    }
+
+    public void testAnd() {
+        insert(5);
+
+        QueryBuilder<AbcdefEntity> queryBuilder = dao.queryBuilder();
+        queryBuilder.where(Properties.A.eq(201), Properties.B.eq(202));
+        List<AbcdefEntity> result = queryBuilder.orderAsc(Properties.A).list();
+        assertEquals(1, result.size());
+        assertEquals(1, queryBuilder.count());
+
+        assertEquals(201, (int) result.get(0).getA());
+
+        queryBuilder.buildDelete().executeDeleteWithoutDetachingEntities();
+    }
+
+    public void testOrAnd() {
+        insert(10);
+
+        QueryBuilder<AbcdefEntity> queryBuilder = dao.queryBuilder();
+        queryBuilder.whereOr(Properties.A.eq(201), //
+                queryBuilder.and(Properties.B.gt(402), Properties.C.lt(703)));
+        List<AbcdefEntity> result = queryBuilder.orderAsc(Properties.A).list();
+        assertEquals(3, result.size());
+        assertEquals(3, queryBuilder.count());
+
+        assertEquals(201, (int) result.get(0).getA());
+        assertEquals(501, (int) result.get(1).getA());
+        assertEquals(601, (int) result.get(2).getA());
+
+        queryBuilder.buildDelete().executeDeleteWithoutDetachingEntities();
+    }
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/query/QueryThreadLocalTest.java b/DaoTest/src/de/greenrobot/daotest/query/QueryForThreadTest.java
similarity index 69%
rename from DaoTest/src/de/greenrobot/daotest/query/QueryThreadLocalTest.java
rename to DaoTest/src/de/greenrobot/daotest/query/QueryForThreadTest.java
index 90f8d276..c99e2747 100644
--- a/DaoTest/src/de/greenrobot/daotest/query/QueryThreadLocalTest.java
+++ b/DaoTest/src/de/greenrobot/daotest/query/QueryForThreadTest.java
@@ -17,14 +17,23 @@
  */
 package de.greenrobot.daotest.query;
 
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+
+import android.util.SparseArray;
 import de.greenrobot.dao.DaoException;
+import de.greenrobot.dao.DaoLog;
 import de.greenrobot.dao.query.Query;
 import de.greenrobot.dao.query.QueryBuilder;
 import de.greenrobot.daotest.TestEntity;
 import de.greenrobot.daotest.TestEntityDao.Properties;
 import de.greenrobot.daotest.entity.TestEntityTestBase;
 
-public class QueryThreadLocalTest extends TestEntityTestBase {
+public class QueryForThreadTest extends TestEntityTestBase {
+    /** Takes longer when activated */
+    private final static boolean DO_LEAK_TESTS = false;
+    private final static int LEAK_TEST_ITERATIONS = DO_LEAK_TESTS ? 100000 : 2500;
+
     private Query<TestEntity> queryFromOtherThread;
 
     public void testGetForCurrentThread_SameInstance() {
@@ -41,7 +50,45 @@ public void testGetForCurrentThread_ParametersAreReset() {
         assertEquals(value + 1, (int) entityFor2.getSimpleInteger());
         query = query.forCurrentThread();
         TestEntity entityFor1 = query.unique();
-        assertEquals(value, (int) entityFor1.getSimpleInteger());
+    }
+
+    public void testGetForCurrentThread_ManyThreadsDontLeak() throws Exception {
+        QueryBuilder<TestEntity> builder = dao.queryBuilder().where(Properties.SimpleInteger.eq("dummy"));
+        final Query<TestEntity> query = builder.build();
+        for (int i = 1; i <= LEAK_TEST_ITERATIONS; i++) {
+            Thread thread = new Thread() {
+                public void run() {
+                    query.forCurrentThread();
+                };
+            };
+            thread.start();
+            if (i % 10 == 0) {
+                thread.join();
+            }
+        }
+        Field queryDataField = Query.class.getDeclaredField("queryData");
+        queryDataField.setAccessible(true);
+        Object queryData = queryDataField.get(query);
+        Class<?> dataSuperclass = queryData.getClass().getSuperclass();
+        Field mapField = dataSuperclass.getDeclaredField("queriesForThreads");
+        mapField.setAccessible(true);
+
+        Method gcMethod = dataSuperclass.getDeclaredMethod("gc");
+        gcMethod.setAccessible(true);
+        SparseArray<?> map = (SparseArray<?>) mapField.get(queryData);
+        for (int i = 0; map.size() > 1 && i < 1000; i++) {
+            DaoLog.d("Queries left after " + i + ". GC: " + map.size());
+            System.gc();
+            gcMethod.invoke(queryData);
+        }
+        assertEquals(1, map.size());
+    }
+
+    public void testBuildQueryDoesntLeak() {
+        QueryBuilder<TestEntity> builder = dao.queryBuilder().where(Properties.SimpleInteger.eq("dummy"));
+        for (int i = 0; i < LEAK_TEST_ITERATIONS; i++) {
+            builder.build();
+        }
     }
 
     public void testGetForCurrentThread_TwoThreads() throws InterruptedException {
diff --git a/DaoTest/src/de/greenrobot/daotest/query/QuerySpecialNamesTest.java b/DaoTest/src/de/greenrobot/daotest/query/QuerySpecialNamesTest.java
index 0b250ca5..3dba11dd 100644
--- a/DaoTest/src/de/greenrobot/daotest/query/QuerySpecialNamesTest.java
+++ b/DaoTest/src/de/greenrobot/daotest/query/QuerySpecialNamesTest.java
@@ -1,81 +1,85 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daotest.query;
-
-import de.greenrobot.dao.query.QueryBuilder;
-import de.greenrobot.dao.test.AbstractDaoTest;
-import de.greenrobot.daotest.SpecialNamesEntity;
-import de.greenrobot.daotest.SpecialNamesEntityDao;
-import de.greenrobot.daotest.SpecialNamesEntityDao.Properties;
-
-public class QuerySpecialNamesTest extends AbstractDaoTest<SpecialNamesEntityDao, SpecialNamesEntity, Long> {
-
-    public QuerySpecialNamesTest() {
-        super(SpecialNamesEntityDao.class);
-    }
-
-    @Override
-    protected void setUp() {
-        super.setUp();
-        QueryBuilder.LOG_SQL = true;
-        QueryBuilder.LOG_VALUES = true;
-    }
-
-    public void testWhereWithSpecialNames() {
-        QueryBuilder<SpecialNamesEntity> queryBuilder = dao.queryBuilder();
-        queryBuilder.where(Properties.Avg.isNotNull());
-        queryBuilder.where(Properties.Count.isNotNull());
-        queryBuilder.where(Properties.Distinct.isNotNull());
-        queryBuilder.where(Properties.Index.isNotNull());
-        queryBuilder.where(Properties.Join.isNotNull());
-        queryBuilder.where(Properties.On.isNotNull());
-        queryBuilder.where(Properties.Select.isNotNull());
-        queryBuilder.where(Properties.Sum.isNotNull());
-        queryBuilder.where(Properties.Order.isNotNull());
-        queryBuilder.list();
-    }
-
-    public void testWhereWithSpecialNamesWithValues() {
-        QueryBuilder<SpecialNamesEntity> queryBuilder = dao.queryBuilder();
-        queryBuilder.where(Properties.Avg.eq("test"));
-        queryBuilder.where(Properties.Count.notIn("test", "test2"));
-        queryBuilder.where(Properties.Distinct.ge("test"));
-        queryBuilder.where(Properties.Index.le("test"));
-        queryBuilder.where(Properties.Join.like("test"));
-        queryBuilder.where(Properties.On.notEq("test"));
-        queryBuilder.where(Properties.Select.in("test", "test2"));
-        queryBuilder.where(Properties.Sum.lt(1));
-        queryBuilder.where(Properties.Order.gt(1));
-        queryBuilder.list();
-    }
-
-    public void testOrderWithSpecialNames() {
-        QueryBuilder<SpecialNamesEntity> queryBuilder = dao.queryBuilder();
-        queryBuilder.orderAsc(Properties.Avg);
-        queryBuilder.orderAsc(Properties.Count);
-        queryBuilder.orderAsc(Properties.Distinct);
-        queryBuilder.orderAsc(Properties.Index);
-        queryBuilder.orderAsc(Properties.Join);
-        queryBuilder.orderAsc(Properties.On);
-        queryBuilder.orderAsc(Properties.Select);
-        queryBuilder.orderAsc(Properties.Sum);
-        queryBuilder.orderAsc(Properties.Order);
-        queryBuilder.list();
-    }
-
-}
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.query;
+
+import de.greenrobot.dao.query.QueryBuilder;
+import de.greenrobot.dao.test.AbstractDaoTest;
+import de.greenrobot.daotest.SpecialNamesEntity;
+import de.greenrobot.daotest.SpecialNamesEntityDao;
+import de.greenrobot.daotest.SpecialNamesEntityDao.Properties;
+
+public class QuerySpecialNamesTest extends AbstractDaoTest<SpecialNamesEntityDao, SpecialNamesEntity, Long> {
+
+    public QuerySpecialNamesTest() {
+        super(SpecialNamesEntityDao.class);
+    }
+
+    @Override
+    protected void setUp() {
+        super.setUp();
+        QueryBuilder.LOG_SQL = true;
+        QueryBuilder.LOG_VALUES = true;
+    }
+
+    public void testWhereWithSpecialNames() {
+        QueryBuilder<SpecialNamesEntity> queryBuilder = dao.queryBuilder();
+        queryBuilder.where(Properties.Avg.isNotNull());
+        queryBuilder.where(Properties.Count.isNotNull());
+        queryBuilder.where(Properties.Distinct.isNotNull());
+        queryBuilder.where(Properties.Index.isNotNull());
+        queryBuilder.where(Properties.Join.isNotNull());
+        queryBuilder.where(Properties.On.isNotNull());
+        queryBuilder.where(Properties.Select.isNotNull());
+        queryBuilder.where(Properties.Sum.isNotNull());
+        queryBuilder.where(Properties.Order.isNotNull());
+        queryBuilder.list();
+        queryBuilder.buildCount().count();
+        queryBuilder.buildDelete().executeDeleteWithoutDetachingEntities();
+    }
+
+    public void testWhereWithSpecialNamesWithValues() {
+        QueryBuilder<SpecialNamesEntity> queryBuilder = dao.queryBuilder();
+        queryBuilder.where(Properties.Avg.eq("test"));
+        queryBuilder.where(Properties.Count.notIn("test", "test2"));
+        queryBuilder.where(Properties.Distinct.ge("test"));
+        queryBuilder.where(Properties.Index.le("test"));
+        queryBuilder.where(Properties.Join.like("test"));
+        queryBuilder.where(Properties.On.notEq("test"));
+        queryBuilder.where(Properties.Select.in("test", "test2"));
+        queryBuilder.where(Properties.Sum.lt(1));
+        queryBuilder.where(Properties.Order.gt(1));
+        queryBuilder.list();
+        queryBuilder.buildCount().count();
+        queryBuilder.buildDelete().executeDeleteWithoutDetachingEntities();
+    }
+
+    public void testOrderWithSpecialNames() {
+        QueryBuilder<SpecialNamesEntity> queryBuilder = dao.queryBuilder();
+        queryBuilder.orderAsc(Properties.Avg);
+        queryBuilder.orderAsc(Properties.Count);
+        queryBuilder.orderAsc(Properties.Distinct);
+        queryBuilder.orderAsc(Properties.Index);
+        queryBuilder.orderAsc(Properties.Join);
+        queryBuilder.orderAsc(Properties.On);
+        queryBuilder.orderAsc(Properties.Select);
+        queryBuilder.orderAsc(Properties.Sum);
+        queryBuilder.orderAsc(Properties.Order);
+        queryBuilder.list();
+    }
+
+}
diff --git a/PerformanceTestOrmLite/.classpath b/PerformanceTestOrmLite/.classpath
index 96ad9c10..2a829e2f 100644
--- a/PerformanceTestOrmLite/.classpath
+++ b/PerformanceTestOrmLite/.classpath
@@ -1,10 +1,11 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="src" path="gen"/>
-	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
-	<classpathentry kind="lib" path="lib/ormlite-android-4.34-SNAPSHOT.jar"/>
-	<classpathentry kind="lib" path="lib/ormlite-core-4.34-SNAPSHOT.jar"/>
-	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
-	<classpathentry kind="output" path="bin/classes"/>
-</classpath>
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="src" path="gen"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry kind="lib" path="lib/ormlite-android-4.34-SNAPSHOT.jar"/>
+	<classpathentry kind="lib" path="lib/ormlite-core-4.34-SNAPSHOT.jar"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
+	<classpathentry kind="output" path="bin/classes"/>
+</classpath>
diff --git a/README.md b/README.md
index 7734bd21..55754a34 100644
--- a/README.md
+++ b/README.md
@@ -16,6 +16,17 @@ Work in progress
 
 Release History
 ---------------
+### V1.3.3 (2013-10-18): Bugfix
+* Fixed a memory leak affecting Query class that was introduced in 1.3.0 (#93)
+* Fixed a rare race condition that can lead to "Entity is detached from DAO context" DaoException (#101)
+
+### V1.3.2 (2013-08-28): Bugfix
+* Fixed building CountQueries with combined AND/OR conditions
+* Some secret inoffical work in progress
+
+### V1.3.1 (2013-03-02): Fixed Gradle dependencies
+* Don't use Gradle's "compile" dependency scope
+
 ### V1.3.0 (2013-02-24): Multithreading robustness and refactoring (breaking changes!)
 * Reworked internal locking of insert/update/delete methods
 * Fixed potential deadlocks when transactions are executed concurrently to one of the various insert/update/delete calls
