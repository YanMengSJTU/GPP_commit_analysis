diff --git a/DaoCore/src/de/greenrobot/dao/DbUtils.java b/DaoCore/src/de/greenrobot/dao/DbUtils.java
index 0c1928a3..4cddca5a 100644
--- a/DaoCore/src/de/greenrobot/dao/DbUtils.java
+++ b/DaoCore/src/de/greenrobot/dao/DbUtils.java
@@ -28,6 +28,8 @@
 // TODO add unit tests
 public class DbUtils {
 
+    private static ExceptionListener exceptionListener;
+
     public static void vacuum(SQLiteDatabase db) {
         db.execSQL("VACUUM");
     }
@@ -152,6 +154,9 @@ public static void logTableDump(SQLiteDatabase db, String tablename) {
         try {
             return serialize(o);
         } catch(IOException ioe) {
+            if(exceptionListener != null) {
+                exceptionListener.onSerializationError(ioe);
+            }
             Log.e("DBUTIL", "error" + ioe == null ? "null" : ioe.getMessage());
             throw new RuntimeException(ioe == null ? "cannot serialize object. FATAL:" : "cannot serialize object, FATAL: " + ioe.getMessage());
         }
@@ -174,9 +179,15 @@ public static Object deserializeObject(byte[] b) {
         try {
             return deserialize(b);
         } catch(ClassNotFoundException cnfe) {
-            return null;
+            if(exceptionListener != null) {
+                exceptionListener.onDeserializationError(cnfe);
+            }
+            throw new RuntimeException("inconsisitent db detected");
         } catch(IOException ioe) {
-            return null;
+            if(exceptionListener != null) {
+                exceptionListener.onDeserializationError(ioe);
+            }
+            throw new RuntimeException("inconsisitent db detected");
         }
     }
 
@@ -190,4 +201,14 @@ private static void closeQuietly(Closeable c) {
             }
         }
     }
+
+    public static void setExceptionListener(ExceptionListener exceptionListener) {
+        DbUtils.exceptionListener = exceptionListener;
+    }
+
+    public static interface ExceptionListener {
+        public void onSerializationError(IOException ioException);
+        public void onDeserializationError(ClassNotFoundException cnfException);
+        public void onDeserializationError(IOException ioException);
+    }
 }
diff --git a/DaoCore/src/de/greenrobot/dao/Query.java b/DaoCore/src/de/greenrobot/dao/Query.java
index 60285755..ace315be 100644
--- a/DaoCore/src/de/greenrobot/dao/Query.java
+++ b/DaoCore/src/de/greenrobot/dao/Query.java
@@ -22,9 +22,9 @@
 
 /**
  * A repeatable query returning entities.
- * 
+ *
  * @author Markus
- * 
+ *
  * @param <T>
  *            The enitity class the query will return results for.
  */
@@ -32,6 +32,8 @@
 // TODO Make parameters setable by Property (if unique in paramaters)
 // TODO Query for PKs/ROW IDs
 public class Query<T> extends AbstractQuery<T> {
+    private static QueryListener queryListener;
+
     private int limitPosition = -1;
     private int offsetPosition = -1;
 
@@ -89,8 +91,14 @@ public void setOffset(int offset) {
 
     /** Executes the query and returns the result as a list containing all entities loaded into memory. */
     public List<T> list() {
+        long start = System.nanoTime();
         Cursor cursor = dao.db.rawQuery(sql, parameters);
-        return dao.loadAllAndCloseCursor(cursor);
+        long queryEnd = System.nanoTime();
+        List<T> result = dao.loadAllAndCloseCursor(cursor);
+        if(queryListener != null) {
+            queryListener.onList(this, queryEnd - start, System.nanoTime() - start);
+        }
+        return result;
     }
 
     /**
@@ -99,8 +107,13 @@ public void setOffset(int offset) {
      * cursor again.Make sure to close it to close the underlying cursor.
      */
     public LazyList<T> listLazy() {
+        long start = System.nanoTime();
         Cursor cursor = dao.db.rawQuery(sql, parameters);
-        return new LazyList<T>(dao, cursor, true);
+        LazyList<T> result = new LazyList<T>(dao, cursor, true);
+        if(queryListener != null) {
+            queryListener.onListLazy(this, System.nanoTime() - start);
+        }
+        return result;
     }
 
     /**
@@ -108,8 +121,13 @@ public void setOffset(int offset) {
      * sure to close the list to close the underlying cursor.
      */
     public LazyList<T> listLazyUncached() {
+        long start = System.nanoTime();
         Cursor cursor = dao.db.rawQuery(sql, parameters);
-        return new LazyList<T>(dao, cursor, false);
+        LazyList<T> result = new LazyList<T>(dao, cursor, false);
+        if(queryListener != null) {
+            queryListener.onListLazy(this, System.nanoTime() - start);
+        }
+        return result;
     }
 
     /**
@@ -122,19 +140,25 @@ public void setOffset(int offset) {
 
     /**
      * Executes the query and returns the unique result or null.
-     * 
+     *
      * @throws DaoException
      *             if the result is not unique
      * @return Entity or null if no matching entity was found
      */
     public T unique() {
+        long start = System.nanoTime();
         Cursor cursor = dao.db.rawQuery(sql, parameters);
-        return dao.loadUniqueAndCloseCursor(cursor);
+        long queryEnd = System.nanoTime();
+        T result =  dao.loadUniqueAndCloseCursor(cursor);
+        if(queryListener != null) {
+            queryListener.onUnique(this, queryEnd - start, System.nanoTime() - start);
+        }
+        return result;
     }
 
     /**
      * Executes the query and returns the unique result (never null).
-     * 
+     *
      * @throws DaoException
      *             if the result is not unique or no entity was found
      * @return Entity
@@ -147,4 +171,13 @@ public T uniqueOrThrow() {
         return entity;
     }
 
+    public static void setQueryListener(QueryListener listener) {
+        Query.queryListener = listener;
+    }
+
+    public static interface QueryListener {
+        public void onList(Query query, long dbQueryTimeInNS, long totalExecutionTimeInNS);
+        public void onListLazy(Query query, long dbQueryTimeInNS);
+        public void onUnique(Query query, long dbQueryTimeInNS, long totalExecutionTimeInNS);
+    }
 }
