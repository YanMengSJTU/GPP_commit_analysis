diff --git a/DaoCore/src/de/greenrobot/dao/AbstractDao.java b/DaoCore/src/de/greenrobot/dao/AbstractDao.java
index 042d4c3e..d13fa197 100644
--- a/DaoCore/src/de/greenrobot/dao/AbstractDao.java
+++ b/DaoCore/src/de/greenrobot/dao/AbstractDao.java
@@ -477,7 +477,7 @@ final protected T loadCurrent(Cursor cursor, int offset, boolean lock) {
      * arguments.
      */
     public Query<T> queryRawCreateListArgs(String where, Collection<Object> selectionArg) {
-        return Query.internalCreate(this, statements.getSelectAll() + where, selectionArg.toArray());
+        return Query.internalCreate(this, statements.getSelectAll() + where, statements.getSelectKey(getPkProperty()), selectionArg.toArray());
     }
 
     public void deleteAll() {
@@ -803,5 +803,27 @@ public SQLiteDatabase getDatabase() {
 
     /** Returns true if the Entity class can be updated, e.g. for setting the PK after insert. */
     abstract protected boolean isEntityUpdateable();
+    
+    /**
+     * Returns the primary keys from the given cursor 
+     * @param cursor the cursor to read keys from
+     * @param close if the cursor should be closed after reading the keys
+     * @return a list of primary keys or empty list
+     */
+	protected List<K> readKeys(Cursor cursor, boolean close) {
+		List<K> keys = new ArrayList<K>();
+    	if (cursor.moveToFirst()) {
+            try {
+                do {
+                	keys.add(readKey(cursor, 0));
+                } while (cursor.moveToNext());
+            } finally {
+            	if (close) {
+            		cursor.close();
+            	}
+            }
+        }
+    	return keys;
+	}
 
 }
diff --git a/DaoCore/src/de/greenrobot/dao/InternalQueryDaoAccess.java b/DaoCore/src/de/greenrobot/dao/InternalQueryDaoAccess.java
index d1896079..036bea93 100644
--- a/DaoCore/src/de/greenrobot/dao/InternalQueryDaoAccess.java
+++ b/DaoCore/src/de/greenrobot/dao/InternalQueryDaoAccess.java
@@ -29,8 +29,13 @@ public TableStatements getStatements() {
         return dao.getStatements();
     }
 
-    public static <T2> TableStatements getStatements(AbstractDao<T2, ?> dao) {
+    public static <T2, K2> TableStatements getStatements(AbstractDao<T2, K2> dao) {
         return dao.getStatements();
     }
+    
+	@SuppressWarnings("unchecked")
+	public <K> List<K> readKeys(Cursor cursor, boolean close) {
+		return (List<K>) dao.readKeys(cursor, close);
+	}
 
 }
\ No newline at end of file
diff --git a/DaoCore/src/de/greenrobot/dao/internal/TableStatements.java b/DaoCore/src/de/greenrobot/dao/internal/TableStatements.java
index 1d86ffb4..10f7ac8f 100644
--- a/DaoCore/src/de/greenrobot/dao/internal/TableStatements.java
+++ b/DaoCore/src/de/greenrobot/dao/internal/TableStatements.java
@@ -15,6 +15,7 @@
  */
 package de.greenrobot.dao.internal;
 
+import de.greenrobot.dao.Property;
 import android.database.sqlite.SQLiteDatabase;
 import android.database.sqlite.SQLiteStatement;
 
@@ -30,6 +31,7 @@
     private SQLiteStatement updateStatement;
     private SQLiteStatement deleteStatement;
 
+    private volatile String selectPk;
     private volatile String selectAll;
     private volatile String selectByKey;
     private volatile String selectByRowId;
@@ -73,6 +75,14 @@ public SQLiteStatement getUpdateStatement() {
         return updateStatement;
     }
 
+
+	public String getSelectKey(Property pkProperty) {
+		if (selectPk == null) {
+			selectPk = SqlUtils.createSqlSelect(tablename, "T", new String[] { pkProperty.columnName });
+        }
+        return selectPk;
+	}
+    
     /** ends with an space to simplify appending to this string. */
     public String getSelectAll() {
         if (selectAll == null) {
diff --git a/DaoCore/src/de/greenrobot/dao/query/Query.java b/DaoCore/src/de/greenrobot/dao/query/Query.java
index 15abe639..223d831c 100644
--- a/DaoCore/src/de/greenrobot/dao/query/Query.java
+++ b/DaoCore/src/de/greenrobot/dao/query/Query.java
@@ -35,15 +35,17 @@
 public class Query<T> extends AbstractQuery<T> {
     private final static class ThreadLocalQuery<T2> extends ThreadLocal<Query<T2>> {
         private final String sql;
+        private final String keySql;
         private final AbstractDao<T2, ?> dao;
         private final String[] initialValues;
         private final int limitPosition;
         private final int offsetPosition;
 
-        private ThreadLocalQuery(AbstractDao<T2, ?> dao, String sql, String[] initialValues, int limitPosition,
+        private ThreadLocalQuery(AbstractDao<T2, ?> dao, String sql, String keySql, String[] initialValues, int limitPosition,
                 int offsetPosition) {
             this.dao = dao;
             this.sql = sql;
+            this.keySql = keySql;
             this.initialValues = initialValues;
             this.limitPosition = limitPosition;
             this.offsetPosition = offsetPosition;
@@ -51,29 +53,31 @@ private ThreadLocalQuery(AbstractDao<T2, ?> dao, String sql, String[] initialVal
 
         @Override
         protected Query<T2> initialValue() {
-            return new Query<T2>(this, dao, sql, initialValues.clone(), limitPosition, offsetPosition);
+            return new Query<T2>(this, dao, sql, keySql, initialValues.clone(), limitPosition, offsetPosition);
         }
     }
 
     /** For internal use by greenDAO only. */
-    public static <T2> Query<T2> internalCreate(AbstractDao<T2, ?> dao, String sql, Object[] initialValues) {
-        return create(dao, sql, initialValues, -1, -1);
+    public static <T2> Query<T2> internalCreate(AbstractDao<T2, ?> dao, String sql, String keySql, Object[] initialValues) {
+        return create(dao, sql, keySql, initialValues, -1, -1);
     }
 
-    static <T2> Query<T2> create(AbstractDao<T2, ?> dao, String sql, Object[] initialValues, int limitPosition,
+    static <T2> Query<T2> create(AbstractDao<T2, ?> dao, String sql, String keySql, Object[] initialValues, int limitPosition,
             int offsetPosition) {
-        ThreadLocalQuery<T2> threadLocal = new ThreadLocalQuery<T2>(dao, sql, toStringArray(initialValues),
+        ThreadLocalQuery<T2> threadLocal = new ThreadLocalQuery<T2>(dao, sql, keySql, toStringArray(initialValues),
                 limitPosition, offsetPosition);
         return threadLocal.get();
     }
 
+    private final String keySql;
     private final int limitPosition;
     private final int offsetPosition;
     private final ThreadLocalQuery<T> threadLocalQuery;
 
-    private Query(ThreadLocalQuery<T> threadLocalQuery, AbstractDao<T, ?> dao, String sql, String[] initialValues,
+    private Query(ThreadLocalQuery<T> threadLocalQuery, AbstractDao<T, ?> dao, String sql, String keysSql, String[] initialValues,
             int limitPosition, int offsetPosition) {
         super(dao, sql, initialValues);
+        this.keySql = keysSql;
         this.threadLocalQuery = threadLocalQuery;
         this.limitPosition = limitPosition;
         this.offsetPosition = offsetPosition;
@@ -187,5 +191,16 @@ public T uniqueOrThrow() {
         }
         return entity;
     }
+    
+    /**
+     * Executes an optimized query that returns the keys of the selected rows.
+     * 
+     * @return List containing the keys of the selected rows or an empty list if no rows are found.
+     */
+    public <K> List<K> listKeys() {
+    	checkThread();
+    	Cursor cursor = dao.getDatabase().rawQuery(keySql, parameters);
+    	return daoAccess.readKeys(cursor, true);
+    }
 
 }
diff --git a/DaoCore/src/de/greenrobot/dao/query/QueryBuilder.java b/DaoCore/src/de/greenrobot/dao/query/QueryBuilder.java
index 2fcea5e2..4b503e23 100644
--- a/DaoCore/src/de/greenrobot/dao/query/QueryBuilder.java
+++ b/DaoCore/src/de/greenrobot/dao/query/QueryBuilder.java
@@ -257,13 +257,21 @@ protected void checkProperty(Property property) {
      */
     public Query<T> build() {
         String select;
+        String selectKeys = null;
         if (joinBuilder == null || joinBuilder.length() == 0) {
             select = InternalQueryDaoAccess.getStatements(dao).getSelectAll();
+            if (dao.getPkProperty() != null) {
+            	selectKeys = InternalQueryDaoAccess.getStatements(dao).getSelectKey(dao.getPkProperty());
+            }
         } else {
             select = SqlUtils.createSqlSelect(dao.getTablename(), tablePrefix, dao.getAllColumns());
+            if (dao.getPkProperty() != null) {
+            	selectKeys = SqlUtils.createSqlSelect(dao.getTablename(), tablePrefix, new String[] { dao.getPkProperty().columnName });
+            }
         }
-        StringBuilder builder = new StringBuilder(select);
-
+        
+        StringBuilder builder = new StringBuilder();
+        
         appendWhereClause(builder, tablePrefix);
 
         if (orderBuilder != null && orderBuilder.length() > 0) {
@@ -287,16 +295,27 @@ protected void checkProperty(Property property) {
             offsetPosition = values.size() - 1;
         }
 
-        String sql = builder.toString();
+        String params = builder.toString();
+        
+        String sql = select + params;
+        String keySql = null;
+        if (selectKeys != null) {
+        	keySql = selectKeys + params;
+        }
+
+        
         if (LOG_SQL) {
             DaoLog.d("Built SQL for query: " + sql);
+            if (keySql != null) {
+            	DaoLog.d("Built SQL for pk query: " + keySql);
+            }
         }
 
         if (LOG_VALUES) {
             DaoLog.d("Values for query: " + values);
         }
 
-        return Query.create(dao, sql, values.toArray(), limitPosition, offsetPosition);
+        return Query.create(dao, sql, keySql, values.toArray(), limitPosition, offsetPosition);
     }
 
     /**
@@ -419,5 +438,14 @@ public T uniqueOrThrow() {
     public long count() {
         return buildCount().count();
     }
+    
+    /**
+     * Shorthand for {@link QueryBuilder#listKeys() listKeys()}.{@link Query#listKeys() listKeys()}; see {@link Query#listKeys()} for
+     * details. To execute a query more than once, you should build the query and keep the {@link Query} object for
+     * efficiency reasons.
+     */
+    public <K> List<K> listKeys() {
+        return build().listKeys();
+    }
 
 }
diff --git a/DaoTest/src/de/greenrobot/daotest/query/QueryBuilderListKeysObjectsTest.java b/DaoTest/src/de/greenrobot/daotest/query/QueryBuilderListKeysObjectsTest.java
new file mode 100644
index 00000000..996a6141
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/query/QueryBuilderListKeysObjectsTest.java
@@ -0,0 +1,87 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.query;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import de.greenrobot.dao.query.QueryBuilder;
+import de.greenrobot.dao.test.AbstractDaoTestStringPk;
+import de.greenrobot.daotest.StringKeyValueEntity;
+import de.greenrobot.daotest.StringKeyValueEntityDao;
+
+public class QueryBuilderListKeysObjectsTest extends AbstractDaoTestStringPk<StringKeyValueEntityDao, StringKeyValueEntity> {
+
+    public QueryBuilderListKeysObjectsTest() {
+        super(StringKeyValueEntityDao.class);
+    }
+	
+    @Override
+    protected void setUp() {
+        super.setUp();
+        
+        QueryBuilder.LOG_SQL = true;
+        QueryBuilder.LOG_VALUES = true;
+    }
+    
+    public void testSize() {
+    	insert(3);
+    	
+    	List<String> keys = dao.queryBuilder().orderAsc(StringKeyValueEntityDao.Properties.Key).listKeys();
+    	
+    	assertEquals(3, keys.size());
+    }
+    
+    public void testValues() {
+    	insert(3);
+    	
+    	List<String> keys = dao.queryBuilder().orderAsc(StringKeyValueEntityDao.Properties.Key).listKeys();    	
+    	
+    	assertEquals("key0", keys.get(0));
+    	assertEquals("key1", keys.get(1));
+    	assertEquals("key2", keys.get(2));
+    }
+    
+    public void testEmpty() {
+    	dao.deleteAll();
+    	
+    	List<String> keys = dao.queryBuilder().listKeys();
+    	assertTrue(keys.isEmpty());
+    }
+
+	@Override
+	protected StringKeyValueEntity createEntity(String key) {
+		return createEntity(key, "default");
+	}
+	
+	protected StringKeyValueEntity createEntity(String key, String value) {
+		StringKeyValueEntity entity = new StringKeyValueEntity();
+		entity.setKey(key);
+		entity.setValue(value);
+		return entity;
+	}
+	
+	protected void insert(int num) {
+		List<StringKeyValueEntity> entities = new ArrayList<StringKeyValueEntity>();
+		for(int i = 0; i < num; i++) {
+			entities.add(createEntity("key" + i, "value" + i));
+		}
+		dao.insertInTx(entities);
+	}
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/query/QueryBuilderListKeysTest.java b/DaoTest/src/de/greenrobot/daotest/query/QueryBuilderListKeysTest.java
new file mode 100644
index 00000000..56c303bc
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/query/QueryBuilderListKeysTest.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.query;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import de.greenrobot.dao.query.Query;
+import de.greenrobot.dao.query.QueryBuilder;
+import de.greenrobot.daotest.TestEntity;
+import de.greenrobot.daotest.TestEntityDao;
+import de.greenrobot.daotest.entity.TestEntityTestBase;
+
+public class QueryBuilderListKeysTest extends TestEntityTestBase {
+	
+    @Override
+    protected void setUp() {
+        super.setUp();
+        
+        QueryBuilder.LOG_SQL = true;
+        QueryBuilder.LOG_VALUES = true;
+    }
+
+    public void testSize() {
+    	insert(3);
+    	
+    	List<Long> keys = dao.queryBuilder().listKeys();
+    	assertEquals(3, keys.size());
+    }
+    public void testValues() {        
+        List<TestEntity> entities = new ArrayList<TestEntity>();
+        entities.add(createEntity(1));
+        entities.add(createEntity(9));
+        entities.add(createEntity(12));
+        dao.insertInTx(entities);
+        
+        List<Long> keys = dao.queryBuilder().orderAsc(TestEntityDao.Properties.Id).listKeys();
+        assertEquals(3, keys.size());
+        assertEquals(Long.valueOf(1), (Long) keys.get(0));
+        assertEquals(Long.valueOf(9), (Long) keys.get(1));
+        assertEquals(Long.valueOf(12), (Long) keys.get(2));
+    }
+    
+    private TestEntity createEntity(long id) {
+    	TestEntity entity = new TestEntity();
+    	entity.setId(id);
+    	entity.setSimpleStringNotNull("green");
+    	return entity;
+    }
+
+    public void testBuildTwice() {
+        insert(3);
+
+        QueryBuilder<TestEntity> builder = dao.queryBuilder();
+        Query<TestEntity> query1 = builder.build();
+        Query<TestEntity> query2 = builder.build();
+        List<Long> keys1 = query1.listKeys();
+        List<Long> keys2 = query2.listKeys();
+        assertEquals(3, keys1.size());
+        assertEquals(3, keys2.size());
+        assertSame(keys1.get(1), keys2.get(1));
+    }
+    
+    public void testEmpty() {
+    	dao.deleteAll();
+    	
+    	List<Long> keys = dao.queryBuilder().listKeys();
+    	assertTrue(keys.isEmpty());
+    }
+
+}
