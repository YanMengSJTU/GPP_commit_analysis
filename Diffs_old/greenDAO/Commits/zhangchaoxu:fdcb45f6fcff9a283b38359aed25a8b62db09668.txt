diff --git a/DaoCore/src/de/greenrobot/dao/AbstractDao.java b/DaoCore/src/de/greenrobot/dao/AbstractDao.java
index 95c29eb2..51349dfb 100644
--- a/DaoCore/src/de/greenrobot/dao/AbstractDao.java
+++ b/DaoCore/src/de/greenrobot/dao/AbstractDao.java
@@ -37,11 +37,11 @@
 
 /**
  * Base class for all DAOs: Implements entity operations like insert, load, delete, and query.
- * 
+ *
  * This class is thread-safe.
- * 
+ *
  * @author Markus
- * 
+ *
  * @param <T>
  *            Entity type
  * @param <K>
@@ -117,7 +117,7 @@ public Property getPkProperty() {
 
     /**
      * Loads and entity for the given PK.
-     * 
+     *
      * @param key
      *            a PK value or null
      * @return The entity or null, if no entity matched the PK value
@@ -189,7 +189,7 @@ public boolean detach(T entity) {
 
     /**
      * Inserts the given entities in the database using a transaction.
-     * 
+     *
      * @param entities
      *            The entities to insert.
      */
@@ -199,7 +199,7 @@ public void insertInTx(Iterable<T> entities) {
 
     /**
      * Inserts the given entities in the database using a transaction.
-     * 
+     *
      * @param entities
      *            The entities to insert.
      */
@@ -210,7 +210,7 @@ public void insertInTx(T... entities) {
     /**
      * Inserts the given entities in the database using a transaction. The given entities will become tracked if the PK
      * is set.
-     * 
+     *
      * @param entities
      *            The entities to insert.
      * @param setPrimaryKey
@@ -224,7 +224,7 @@ public void insertInTx(Iterable<T> entities, boolean setPrimaryKey) {
     /**
      * Inserts or replaces the given entities in the database using a transaction. The given entities will become
      * tracked if the PK is set.
-     * 
+     *
      * @param entities
      *            The entities to insert.
      * @param setPrimaryKey
@@ -237,7 +237,7 @@ public void insertOrReplaceInTx(Iterable<T> entities, boolean setPrimaryKey) {
 
     /**
      * Inserts or replaces the given entities in the database using a transaction.
-     * 
+     *
      * @param entities
      *            The entities to insert.
      */
@@ -247,7 +247,7 @@ public void insertOrReplaceInTx(Iterable<T> entities) {
 
     /**
      * Inserts or replaces the given entities in the database using a transaction.
-     * 
+     *
      * @param entities
      *            The entities to insert.
      */
@@ -286,7 +286,7 @@ private void executeInsertInTx(SQLiteStatement stmt, Iterable<T> entities, boole
 
     /**
      * Insert an entity into the table associated with a concrete DAO.
-     * 
+     *
      * @return row ID of newly inserted entity
      */
     public long insert(T entity) {
@@ -296,7 +296,7 @@ public long insert(T entity) {
     /**
      * Insert an entity into the table associated with a concrete DAO <b>without</b> setting key property. Warning: This
      * may be faster, but the entity should not be used anymore. The entity also won't be attached to identy scope.
-     * 
+     *
      * @return row ID of newly inserted entity
      */
     public long insertWithoutSettingPk(T entity) {
@@ -325,7 +325,7 @@ public long insertWithoutSettingPk(T entity) {
 
     /**
      * Insert an entity into the table associated with a concrete DAO.
-     * 
+     *
      * @return row ID of newly inserted entity
      */
     public long insertOrReplace(T entity) {
@@ -579,7 +579,7 @@ private void deleteInTxInternal(Iterable<T> entities, Iterable<K> keys) {
 
     /**
      * Deletes the given entities in the database using a transaction.
-     * 
+     *
      * @param entities
      *            The entities to delete.
      */
@@ -589,7 +589,7 @@ public void deleteInTx(Iterable<T> entities) {
 
     /**
      * Deletes the given entities in the database using a transaction.
-     * 
+     *
      * @param entities
      *            The entities to delete.
      */
@@ -599,7 +599,7 @@ public void deleteInTx(T... entities) {
 
     /**
      * Deletes all entities with the given keys in the database using a transaction.
-     * 
+     *
      * @param keys
      *            Keys of the entities to delete.
      */
@@ -609,7 +609,7 @@ public void deleteByKeyInTx(Iterable<K> keys) {
 
     /**
      * Deletes all entities with the given keys in the database using a transaction.
-     * 
+     *
      * @param keys
      *            Keys of the entities to delete.
      */
@@ -682,7 +682,7 @@ protected void updateInsideSynchronized(T entity, SQLiteStatement stmt, boolean
 
     /**
      * Attaches the entity to the identity scope. Calls attachEntity(T entity).
-     * 
+     *
      * @param key
      *            Needed only for identity scope, pass null if there's none.
      * @param entity
@@ -702,7 +702,7 @@ protected final void attachEntity(K key, T entity, boolean lock) {
     /**
      * Sub classes with relations additionally set the DaoMaster here. Must be called before the entity is attached to
      * the identity scope.
-     * 
+     *
      * @param entity
      *            The entitiy to attach
      * */
@@ -711,13 +711,14 @@ protected void attachEntity(T entity) {
 
     /**
      * Updates the given entities in the database using a transaction.
-     * 
+     *
      * @param entities
      *            The entities to insert.
      */
     public void updateInTx(Iterable<T> entities) {
         SQLiteStatement stmt = statements.getUpdateStatement();
         db.beginTransaction();
+        RuntimeException txEx = null;
         try {
             synchronized (stmt) {
                 if (identityScope != null) {
@@ -734,14 +735,25 @@ public void updateInTx(Iterable<T> entities) {
                 }
             }
             db.setTransactionSuccessful();
+        } catch (RuntimeException e) {
+            txEx = e;
         } finally {
-            db.endTransaction();
+            try {
+                db.endTransaction();
+            } catch (RuntimeException e) {
+                if (txEx != null) {
+                    DaoLog.w("Could not end transaction (rethrowing initial exception)", e);
+                    throw txEx;
+                } else {
+                    throw e;
+                }
+            }
         }
     }
 
     /**
      * Updates the given entities in the database using a transaction.
-     * 
+     *
      * @param entities
      *            The entities to update.
      */
diff --git a/DaoCore/src/de/greenrobot/dao/async/AsyncOperation.java b/DaoCore/src/de/greenrobot/dao/async/AsyncOperation.java
index 7f1b1c02..38136065 100644
--- a/DaoCore/src/de/greenrobot/dao/async/AsyncOperation.java
+++ b/DaoCore/src/de/greenrobot/dao/async/AsyncOperation.java
@@ -22,9 +22,8 @@
 
 /**
  * An operation that will be enqueued for asynchronous execution.
- * 
+ *
  * @author Markus
- * 
  * @see AsyncSession
  */
 // TODO Implement Future<V>
@@ -45,6 +44,7 @@
 
     /** TODO unused, just an idea */
     public static final int FLAG_STOP_QUEUE_ON_EXCEPTION = 1 << 1;
+    public static final int FLAG_TRACK_CREATOR_STACKTRACE = 1 << 2;
 
     final OperationType type;
     final AbstractDao<Object, Object> dao;
@@ -57,26 +57,21 @@
     volatile long timeCompleted;
     private volatile boolean completed;
     volatile Throwable throwable;
+    final Exception creatorStacktrace;
     volatile Object result;
     volatile int mergedOperationsCount;
 
     int sequenceNumber;
 
     @SuppressWarnings("unchecked")
-    AsyncOperation(OperationType type, AbstractDao<?, ?> dao, Object parameter, int flags) {
+    /** Either supply dao or database (set other to null). */
+    AsyncOperation(OperationType type, AbstractDao<?, ?> dao, SQLiteDatabase database, Object parameter, int flags) {
         this.type = type;
         this.flags = flags;
         this.dao = (AbstractDao<Object, Object>) dao;
-        this.database = null;
-        this.parameter = parameter;
-    }
-
-    AsyncOperation(OperationType type, SQLiteDatabase database, Object parameter, int flags) {
-        this.type = type;
         this.database = database;
-        this.flags = flags;
-        this.dao = null;
         this.parameter = parameter;
+        creatorStacktrace = (flags & FLAG_TRACK_CREATOR_STACKTRACE) != 0 ? new Exception("AsyncOperation was created here") : null;
     }
 
     public Throwable getThrowable() {
@@ -97,7 +92,7 @@ public Object getParameter() {
 
     /**
      * The operation's result after it has completed. Waits until a result is available.
-     * 
+     *
      * @return The operation's result or null if the operation type does not produce any result.
      * @throws {@link AsyncDaoException} if the operation produced an exception
      * @see #waitForCompletion()
@@ -123,7 +118,7 @@ SQLiteDatabase getDatabase() {
 
     /**
      * @return true if this operation is mergeable with the given operation. Checks for null, {@link #FLAG_MERGE_TX},
-     *         and if the database instances match.
+     * and if the database instances match.
      */
     boolean isMergeableWith(AsyncOperation other) {
         return other != null && isMergeTx() && other.isMergeTx() && getDatabase() == other.getDatabase();
@@ -156,7 +151,7 @@ public boolean isCompleted() {
     /**
      * Waits until the operation is complete. If the thread gets interrupted, any {@link InterruptedException} will be
      * rethrown as a {@link DaoException}.
-     * 
+     *
      * @return Result if any, see {@link #getResult()}
      */
     public synchronized Object waitForCompletion() {
@@ -173,7 +168,7 @@ public synchronized Object waitForCompletion() {
     /**
      * Waits until the operation is complete, but at most the given amount of milliseconds.If the thread gets
      * interrupted, any {@link InterruptedException} will be rethrown as a {@link DaoException}.
-     * 
+     *
      * @return true if the operation completed in the given time frame.
      */
     public synchronized boolean waitForCompletion(int maxMillis) {
@@ -223,4 +218,11 @@ void reset() {
         mergedOperationsCount = 0;
     }
 
+    /**
+     * The stacktrace is captured using an exception if {@link #FLAG_TRACK_CREATOR_STACKTRACE} was used (null
+     * otherwise).
+     */
+    public Exception getCreatorStacktrace() {
+        return creatorStacktrace;
+    }
 }
diff --git a/DaoCore/src/de/greenrobot/dao/async/AsyncOperationExecutor.java b/DaoCore/src/de/greenrobot/dao/async/AsyncOperationExecutor.java
index b63ec1b4..d57c1f74 100644
--- a/DaoCore/src/de/greenrobot/dao/async/AsyncOperationExecutor.java
+++ b/DaoCore/src/de/greenrobot/dao/async/AsyncOperationExecutor.java
@@ -15,14 +15,6 @@
  */
 package de.greenrobot.dao.async;
 
-import java.util.ArrayList;
-import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.Callable;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.TimeUnit;
-
 import android.database.sqlite.SQLiteDatabase;
 import android.os.Handler;
 import android.os.Looper;
@@ -31,6 +23,14 @@
 import de.greenrobot.dao.DaoLog;
 import de.greenrobot.dao.query.Query;
 
+import java.util.ArrayList;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.TimeUnit;
+
 class AsyncOperationExecutor implements Runnable, Handler.Callback {
 
     private static ExecutorService executorService = Executors.newCachedThreadPool();
@@ -119,7 +119,7 @@ public synchronized void waitForCompletion() {
     /**
      * Waits until all enqueued operations are complete, but at most the given amount of milliseconds. If the thread
      * gets interrupted, any {@link InterruptedException} will be rethrown as a {@link DaoException}.
-     * 
+     *
      * @return true if operations completed in the given time frame.
      */
     public synchronized boolean waitForCompletion(int maxMillis) {
@@ -141,9 +141,10 @@ public void run() {
                     AsyncOperation operation = queue.poll(1, TimeUnit.SECONDS);
                     if (operation == null) {
                         synchronized (this) {
-                            // Check again, this time in synchronized
+                            // Check again, this time in synchronized to be in sync with enqueue(AsyncOperation)
                             operation = queue.poll();
                             if (operation == null) {
+                                // set flag while still inside synchronized
                                 executorRunning = false;
                                 return;
                             }
@@ -173,6 +174,8 @@ public void run() {
         }
     }
 
+
+    /** Also checks for other operations in the queue that can be merged into the transaction. */
     private void mergeTxAndExecute(AsyncOperation operation1, AsyncOperation operation2) {
         ArrayList<AsyncOperation> mergedOps = new ArrayList<AsyncOperation>();
         mergedOps.add(operation1);
@@ -180,14 +183,13 @@ private void mergeTxAndExecute(AsyncOperation operation1, AsyncOperation operati
 
         SQLiteDatabase db = operation1.getDatabase();
         db.beginTransaction();
-        boolean failed = false;
+        boolean success = false;
         try {
             for (int i = 0; i < mergedOps.size(); i++) {
                 AsyncOperation operation = mergedOps.get(i);
                 executeOperation(operation);
                 if (operation.isFailed()) {
                     // Operation may still have changed the DB, roll back everything
-                    failed = true;
                     break;
                 }
                 if (i == mergedOps.size() - 1) {
@@ -202,24 +204,32 @@ private void mergeTxAndExecute(AsyncOperation operation1, AsyncOperation operati
                     } else {
                         // No more ops in the queue to merge, finish it
                         db.setTransactionSuccessful();
+                        success = true;
+                        break;
                     }
                 }
             }
         } finally {
-            db.endTransaction();
-        }
-        if (failed) {
-            DaoLog.i("Revered merged transaction because one of the operations failed. Executing operations one by one instead...");
-            for (AsyncOperation asyncOperation : mergedOps) {
-                asyncOperation.reset();
-                executeOperationAndPostCompleted(asyncOperation);
+            try {
+                db.endTransaction();
+            } catch (RuntimeException e) {
+                DaoLog.i("Async transaction could not be ended, success so far was: " + success, e);
+                success = false;
             }
-        } else {
+        }
+        if (success) {
             int mergedCount = mergedOps.size();
             for (AsyncOperation asyncOperation : mergedOps) {
                 asyncOperation.mergedOperationsCount = mergedCount;
                 handleOperationCompleted(asyncOperation);
             }
+        } else {
+            DaoLog.i("Reverted merged transaction because one of the operations failed. Executing operations one by " +
+                    "one instead...");
+            for (AsyncOperation asyncOperation : mergedOps) {
+                asyncOperation.reset();
+                executeOperationAndPostCompleted(asyncOperation);
+            }
         }
     }
 
@@ -250,79 +260,79 @@ private void executeOperationAndPostCompleted(AsyncOperation operation) {
         handleOperationCompleted(operation);
     }
 
-    @SuppressWarnings({ "unchecked", "rawtypes" })
+    @SuppressWarnings({"unchecked", "rawtypes"})
     private void executeOperation(AsyncOperation operation) {
         operation.timeStarted = System.currentTimeMillis();
         try {
             switch (operation.type) {
-            case Delete:
-                operation.dao.delete(operation.parameter);
-                break;
-            case DeleteInTxIterable:
-                operation.dao.deleteInTx((Iterable<Object>) operation.parameter);
-                break;
-            case DeleteInTxArray:
-                operation.dao.deleteInTx((Object[]) operation.parameter);
-                break;
-            case Insert:
-                operation.dao.insert(operation.parameter);
-                break;
-            case InsertInTxIterable:
-                operation.dao.insertInTx((Iterable<Object>) operation.parameter);
-                break;
-            case InsertInTxArray:
-                operation.dao.insertInTx((Object[]) operation.parameter);
-                break;
-            case InsertOrReplace:
-                operation.dao.insertOrReplace(operation.parameter);
-                break;
-            case InsertOrReplaceInTxIterable:
-                operation.dao.insertOrReplaceInTx((Iterable<Object>) operation.parameter);
-                break;
-            case InsertOrReplaceInTxArray:
-                operation.dao.insertOrReplaceInTx((Object[]) operation.parameter);
-                break;
-            case Update:
-                operation.dao.update(operation.parameter);
-                break;
-            case UpdateInTxIterable:
-                operation.dao.updateInTx((Iterable<Object>) operation.parameter);
-                break;
-            case UpdateInTxArray:
-                operation.dao.updateInTx((Object[]) operation.parameter);
-                break;
-            case TransactionRunnable:
-                executeTransactionRunnable(operation);
-                break;
-            case TransactionCallable:
-                executeTransactionCallable(operation);
-                break;
-            case QueryList:
-                operation.result = ((Query) operation.parameter).list();
-                break;
-            case QueryUnique:
-                operation.result = ((Query) operation.parameter).unique();
-                break;
-            case DeleteByKey:
-                operation.dao.deleteByKey(operation.parameter);
-                break;
-            case DeleteAll:
-                operation.dao.deleteAll();
-                break;
-            case Load:
-                operation.result = operation.dao.load(operation.parameter);
-                break;
-            case LoadAll:
-                operation.result = operation.dao.loadAll();
-                break;
-            case Count:
-                operation.result = operation.dao.count();
-                break;
-            case Refresh:
-                operation.dao.refresh(operation.parameter);
-                break;
-            default:
-                throw new DaoException("Unsupported operation: " + operation.type);
+                case Delete:
+                    operation.dao.delete(operation.parameter);
+                    break;
+                case DeleteInTxIterable:
+                    operation.dao.deleteInTx((Iterable<Object>) operation.parameter);
+                    break;
+                case DeleteInTxArray:
+                    operation.dao.deleteInTx((Object[]) operation.parameter);
+                    break;
+                case Insert:
+                    operation.dao.insert(operation.parameter);
+                    break;
+                case InsertInTxIterable:
+                    operation.dao.insertInTx((Iterable<Object>) operation.parameter);
+                    break;
+                case InsertInTxArray:
+                    operation.dao.insertInTx((Object[]) operation.parameter);
+                    break;
+                case InsertOrReplace:
+                    operation.dao.insertOrReplace(operation.parameter);
+                    break;
+                case InsertOrReplaceInTxIterable:
+                    operation.dao.insertOrReplaceInTx((Iterable<Object>) operation.parameter);
+                    break;
+                case InsertOrReplaceInTxArray:
+                    operation.dao.insertOrReplaceInTx((Object[]) operation.parameter);
+                    break;
+                case Update:
+                    operation.dao.update(operation.parameter);
+                    break;
+                case UpdateInTxIterable:
+                    operation.dao.updateInTx((Iterable<Object>) operation.parameter);
+                    break;
+                case UpdateInTxArray:
+                    operation.dao.updateInTx((Object[]) operation.parameter);
+                    break;
+                case TransactionRunnable:
+                    executeTransactionRunnable(operation);
+                    break;
+                case TransactionCallable:
+                    executeTransactionCallable(operation);
+                    break;
+                case QueryList:
+                    operation.result = ((Query) operation.parameter).list();
+                    break;
+                case QueryUnique:
+                    operation.result = ((Query) operation.parameter).unique();
+                    break;
+                case DeleteByKey:
+                    operation.dao.deleteByKey(operation.parameter);
+                    break;
+                case DeleteAll:
+                    operation.dao.deleteAll();
+                    break;
+                case Load:
+                    operation.result = operation.dao.load(operation.parameter);
+                    break;
+                case LoadAll:
+                    operation.result = operation.dao.loadAll();
+                    break;
+                case Count:
+                    operation.result = operation.dao.count();
+                    break;
+                case Refresh:
+                    operation.dao.refresh(operation.parameter);
+                    break;
+                default:
+                    throw new DaoException("Unsupported operation: " + operation.type);
             }
         } catch (Throwable th) {
             operation.throwable = th;
diff --git a/DaoCore/src/de/greenrobot/dao/async/AsyncOperationListener.java b/DaoCore/src/de/greenrobot/dao/async/AsyncOperationListener.java
index cd8a91d8..b043f92d 100644
--- a/DaoCore/src/de/greenrobot/dao/async/AsyncOperationListener.java
+++ b/DaoCore/src/de/greenrobot/dao/async/AsyncOperationListener.java
@@ -15,6 +15,11 @@
  */
 package de.greenrobot.dao.async;
 
+/** Listener being called after completion of {@link de.greenrobot.dao.async.AsyncOperation}. */
 public interface AsyncOperationListener {
+    /**
+     * Note, that the operation may not have been successful, check
+     * {@link AsyncOperation#isFailed()} and/or {@link AsyncOperation#getThrowable()} for error situations.
+     */
     void onAsyncOperationCompleted(AsyncOperation operation);
 }
diff --git a/DaoCore/src/de/greenrobot/dao/async/AsyncSession.java b/DaoCore/src/de/greenrobot/dao/async/AsyncSession.java
index f606a7a6..e21257a6 100644
--- a/DaoCore/src/de/greenrobot/dao/async/AsyncSession.java
+++ b/DaoCore/src/de/greenrobot/dao/async/AsyncSession.java
@@ -1,27 +1,29 @@
 package de.greenrobot.dao.async;
 
-import java.util.concurrent.Callable;
-
+import android.database.sqlite.SQLiteDatabase;
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.AbstractDaoSession;
 import de.greenrobot.dao.DaoException;
 import de.greenrobot.dao.async.AsyncOperation.OperationType;
 import de.greenrobot.dao.query.Query;
 
+import java.util.concurrent.Callable;
+
 /**
  * Asynchronous interface to entity operations. All operations will enqueued a @link {@link AsyncOperation} and return
  * immediately (fine to call on the UI/main thread). The queue will be processed in a (single) background thread. The
- * processing order is the call order of the operations. It's possible to start multiple AsyncSessions that will execute
+ * processing order is the call order of the operations. It's possible to start multiple AsyncSessions that will
+ * execute
  * concurrently.
- * 
+ *
  * @author Markus
- * 
  * @see AbstractDaoSession#startAsyncSession()
  */
 // Facade to AsyncOperationExecutor: prepares operations and delegates work to AsyncOperationExecutor.
 public class AsyncSession {
     private final AbstractDaoSession daoSession;
     private final AsyncOperationExecutor executor;
+    private int sessionFlags;
 
     public AsyncSession(AbstractDaoSession daoSession) {
         this.daoSession = daoSession;
@@ -75,7 +77,7 @@ public void waitForCompletion() {
     /**
      * Waits until all enqueued operations are complete, but at most the given amount of milliseconds. If the thread
      * gets interrupted, any {@link InterruptedException} will be rethrown as a {@link DaoException}.
-     * 
+     *
      * @return true if operations completed in the given time frame.
      */
     public boolean waitForCompletion(int maxMillis) {
@@ -303,7 +305,8 @@ public AsyncOperation refresh(Object entity, int flags) {
     }
 
     private AsyncOperation enqueueDatabaseOperation(OperationType type, Object param, int flags) {
-        AsyncOperation operation = new AsyncOperation(type, daoSession.getDatabase(), param, flags);
+        SQLiteDatabase database = daoSession.getDatabase();
+        AsyncOperation operation = new AsyncOperation(type, null, database, param, flags | sessionFlags);
         executor.enqueue(operation);
         return operation;
     }
@@ -314,9 +317,18 @@ private AsyncOperation enqueueEntityOperation(OperationType type, Object entity,
 
     private <E> AsyncOperation enqueEntityOperation(OperationType type, Class<E> entityClass, Object param, int flags) {
         AbstractDao<?, ?> dao = daoSession.getDao(entityClass);
-        AsyncOperation operation = new AsyncOperation(type, dao, param, flags);
+        AsyncOperation operation = new AsyncOperation(type, dao, null, param, flags | sessionFlags);
         executor.enqueue(operation);
         return operation;
     }
 
+    /** {@link de.greenrobot.dao.async.AsyncOperation} flags set for all operations (will be ORed with call flags). */
+    public int getSessionFlags() {
+        return sessionFlags;
+    }
+
+    /** {@link de.greenrobot.dao.async.AsyncOperation} flags set for all operations (will be ORed with call flags). */
+    public void setSessionFlags(int sessionFlags) {
+        this.sessionFlags = sessionFlags;
+    }
 }
diff --git a/DaoCore/src/de/greenrobot/dao/query/LazyList.java b/DaoCore/src/de/greenrobot/dao/query/LazyList.java
index 9bf12337..6c76ae71 100644
--- a/DaoCore/src/de/greenrobot/dao/query/LazyList.java
+++ b/DaoCore/src/de/greenrobot/dao/query/LazyList.java
@@ -250,12 +250,21 @@ public E get(int location) {
             }
             return entity;
         } else {
-            return loadEntity(location);
+            lock.lock();
+            try {
+                return loadEntity(location);
+            } finally {
+                lock.unlock();
+            }
         }
     }
 
+    /** Lock must be locked when entering this method. */
     protected E loadEntity(int location) {
-        cursor.moveToPosition(location);
+        boolean ok = cursor.moveToPosition(location);
+        if(!ok) {
+            throw new DaoException("Could not move to cursor location " + location);
+        }
         E entity = daoAccess.loadCurrent(cursor, 0, true);
         if (entity == null) {
             throw new DaoException("Loading of entity failed (null) at position " + location);
diff --git a/DaoTest/build.gradle b/DaoTest/build.gradle
index a1f62bca..4ba40c49 100644
--- a/DaoTest/build.gradle
+++ b/DaoTest/build.gradle
@@ -4,7 +4,7 @@ buildscript {
     }
 
     dependencies {
-        classpath 'com.android.tools.build:gradle:0.10.2'
+        classpath 'com.android.tools.build:gradle:0.13.3'
     }
 }
 
@@ -15,7 +15,7 @@ dependencies {
 }
 
 android {
-    buildToolsVersion '19.1.0'
+    buildToolsVersion '20.0.0'
     compileSdkVersion 19
 
     sourceSets {
@@ -32,7 +32,7 @@ android {
     }
 
     defaultConfig {
-        testPackageName "de.greenrobot.daotest"
+        testApplicationId "de.greenrobot.daotest"
         testInstrumentationRunner "android.test.InstrumentationTestRunner"
     }
 }
diff --git a/DaoTest/src/de/greenrobot/daotest/async/BasicAsyncTest.java b/DaoTest/src/de/greenrobot/daotest/async/BasicAsyncTest.java
index 5a181ee8..e42ea4f9 100644
--- a/DaoTest/src/de/greenrobot/daotest/async/BasicAsyncTest.java
+++ b/DaoTest/src/de/greenrobot/daotest/async/BasicAsyncTest.java
@@ -95,6 +95,29 @@ public void testAsyncException() {
         assertNotNull(operation.getThrowable());
     }
 
+    public void testAsyncExceptionCreator() {
+        SimpleEntity entity = new SimpleEntity();
+        daoSession.insert(entity);
+        AsyncOperation operation = asyncSession.insert(entity);
+        assertWaitForCompletion1Sec();
+        assertNull(operation.getCreatorStacktrace());
+
+        operation = asyncSession.insert(entity, AsyncOperation.FLAG_TRACK_CREATOR_STACKTRACE);
+        assertWaitForCompletion1Sec();
+        assertNotNull(operation.getCreatorStacktrace());
+
+        asyncSession.setSessionFlags(AsyncOperation.FLAG_TRACK_CREATOR_STACKTRACE);
+        operation = asyncSession.insert(entity);
+        assertWaitForCompletion1Sec();
+        assertNotNull(operation.getCreatorStacktrace());
+        StackTraceElement[] stack = operation.getCreatorStacktrace().getStackTrace();
+        boolean found = false;
+        for (StackTraceElement stackTraceElement : stack) {
+            found |= stackTraceElement.getClassName().equals(getClass().getName());
+        }
+        assertTrue(found);
+    }
+
     public void testAsyncOperationWaitMillis() {
         AsyncOperation operation = asyncSession.insert(new SimpleEntity());
         assertTrue(asyncSession.waitForCompletion(1000));
@@ -153,4 +176,6 @@ public synchronized void onAsyncOperationCompleted(AsyncOperation operation) {
             }
         }
     }
+
+
 }
diff --git a/README.md b/README.md
index 48fee8b3..b59d691d 100644
--- a/README.md
+++ b/README.md
@@ -2,12 +2,12 @@ greenDAO
 ========
 greenDAO is a light & fast ORM solution for Android that maps objects to SQLite databases. Being highly optimized for Android, greenDAO offers great performance and consumes minimal memory.
 
-Home page, documentation, and support links: http://greendao-orm.com/
+**<font size="+1">Home page, documentation, and support links: http://greendao-orm.com/</font>**
 
 [![Build Status](https://travis-ci.org/greenrobot/greenDAO.svg?branch=master)](https://travis-ci.org/greenrobot/greenDAO)
 
-Upcoming features
------------------
+Upcoming features (already available in beta quality)
+-----------------------------------------------------
 New features ahead for the brave: documentation and test coverage may be lacking. Give it a shot if you dare. API may change in the future. 
 ### Asynchronous API
 * New AsyncSession (acquired from DaoSession.startAsyncSession()) provides most operations for DAOs, Queries, and transactions in a asynchronously variant
@@ -17,9 +17,20 @@ New features ahead for the brave: documentation and test coverage may be lacking
 * Asynchronous operations can be merged in single transactions (details follow)
 * Added raw SQL queries returning a Query object (LazyList support etc.)
 
+More Open Source by greenrobot
+==============================
+[__EventBus__](https://github.com/greenrobot/EventBus) is a central publish/subscribe bus for Android with optional delivery threads, priorities, and sticky events. A great tool to decouple components (e.g. Activities, Fragments, logic components) from each other.
+
+[__greenrobot-common__](https://github.com/greenrobot/greenrobot-common) is a set of utility classes and hash functions for Android & Java projects.
+
+[Follow us on Google+](https://plus.google.com/b/114381455741141514652/+GreenrobotDe/posts) to stay up to date.
+
 Release History
 ---------------
-### Generator V1.3.1 (2015-05-24): Bugfix
+### Future release
+* Added Flag for AsyncOperation to track the caller's stacktrace (useful for debugging)
+
+### Generator V1.3.1 (2014-05-24): Bugfix
 * Fix schema version >= 1000
 
 ### V1.3.7 (2013-11-27): Bugfix
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index aacac335..54df5249 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -3,4 +3,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=http\://services.gradle.org/distributions/gradle-1.12-all.zip
+distributionUrl=http\://services.gradle.org/distributions/gradle-2.1-all.zip
