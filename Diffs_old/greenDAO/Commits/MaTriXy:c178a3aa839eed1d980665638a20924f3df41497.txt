diff --git a/.travis.yml b/.travis.yml
index 08e76626..6483132d 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,12 +1,19 @@
 language: android
+# Use the Travis Container-Based Infrastructure
+sudo: false
 jdk:
   - oraclejdk7
 env:
+  global:
+    # increase adb timeout (2 minutes by default)
+    - ADB_INSTALL_TIMEOUT=8
   matrix:
-    - ANDROID_SDKS=android-19,sysimg-19  ANDROID_TARGET=android-19  ANDROID_ABI=armeabi-v7a
+    - ANDROID_SDKS=android-23,sysimg-23  ANDROID_TARGET=android-19  ANDROID_ABI=armeabi-v7a
 android:
   components:
-    - build-tools-19.1.0
+    - build-tools-23.0.1
+    - android-23
+    - extra-android-m2repository
 before_install:
   - echo no | android create avd --force -n test -t $ANDROID_TARGET --abi $ANDROID_ABI
   - emulator -avd test -no-skin -no-audio -no-window &
@@ -16,4 +23,4 @@ before_script:
   - ./ci/wait_for_emulator
   - adb shell input keyevent 82 &
 script:
-    - TERM=dumb ./gradlew connectedCheck
\ No newline at end of file
+    - TERM=dumb ./gradlew connectedCheck
diff --git a/CHANGELOG.md b/CHANGELOG.md
new file mode 100644
index 00000000..7abf0ec5
--- /dev/null
+++ b/CHANGELOG.md
@@ -0,0 +1,119 @@
+Release History
+---------------
+### V2.x.x Minor feature and bugfix release (2016-??-??))
+* Query.setParameter returns the query to allow a more fluent API
+* New DAO method detachAll to detach all entities of a specific type
+
+### V2.1.0 Minor feature and bugfix release (2015-11-12, both core and generator)
+* Official Robolectric support: workaround for a broken system call in Robolectric triggered by Query.forCurrentThread
+* QueryBuilder now allows to create DISTINCT queries to avoid duplicate entities returned
+* CursorQuery (beta, API might change)
+* Deadlock prevention when loading a list of entities while doing concurrent updates
+* Fixed async queries
+* Better Android Studio support
+* Generator: Possibility to supply custom JavaDoc for entities and their properties
+* Generator: Fixed codeBeforeGetter, added codeBeforeGetterAndSetter
+
+### V2.0.0 Major feature release (2015-07-30, both core and generator)
+* Join for queries: relate a query to other entities (or joins)
+* To-Many relations using a join entity (useful for M:N relationships)
+* Custom types for properties: by implementing PropertyConverter, entities can have properties of any type, e.g. enums, BigInteger, alternative time/date classes, JSON objects, serialized objects, ...
+* Add custom code to fields, getters, and setters of entity properties to add custom annotations or JavaDoc
+* Add additional imports to entities without keep sections
+* Fixes for table names matching a SQL keyword (e.g. "order", "transaction")
+* Several bug fixes
+* Added Flag for AsyncOperation to track the caller's stacktrace (useful for debugging)
+
+### Generator V1.3.1 (2014-05-24): Bugfix
+* Fix schema version >= 1000
+
+### V1.3.7 (2013-11-27): Bugfix
+* Fixed building defect DeleteQuery for tables ending with character 'T' (bug introduced in 1.3.3)
+* Prepared Fast Cursor for API level 19
+
+### V1.3.6 (2013-11-15): Bugfix
+* Fixed leaked statement in DeleteQuery
+
+### V1.3.5 (2013-11-14): Bugfix
+* Because of an issue with ApplicationTestCase, the base test class DbTest does not extend this class anymore.
+Note: This refactoring may require you to adjust some test classes if your tests depend on DbTest or its subclasses.
+
+### V1.3.4 (2013-10-28): Bugfix
+* Redeployment of 1.3.3 artifacts without some old class leftovers
+
+### V1.3.3 (2013-10-18): Bugfix
+* Fixed a memory leak affecting Query class that was introduced in 1.3.0 (#93)
+* Fixed a rare race condition that can lead to "Entity is detached from DAO context" DaoException (#101)
+
+### V1.3.2 (2013-08-28): Bugfix
+* Fixed building CountQueries with combined AND/OR conditions
+* Some secret inoffical work in progress
+
+### V1.3.1 (2013-03-02): Fixed Gradle dependencies
+* Don't use Gradle's "compile" dependency scope
+
+### V1.3.0 (2013-02-24): Multithreading robustness and refactoring (breaking changes!)
+* Reworked internal locking of insert/update/delete methods
+* Fixed potential deadlocks when transactions are executed concurrently to one of the various insert/update/delete calls
+* Reworked queries to be used without locking, query instances are now bound to their owner thread (breaking change!)
+* Relations use the new lock-free query API
+* Query classes were moved into the new query subpackage (breaking change!)
+* Introduced Gradle build scripts for DaoCore and DaoGenerator projects
+* Maven artifacts are pushed to Maven Central starting with this version
+* Added two packages for classes used internally (identityscope and internal)
+* Added new deleteByKeyInTx DAO method to efficiently delete multiple entities using their keys
+* Added some checks to throw exceptions with nicer messages telling what's wrong
+* Added Travis CI
+
+### V1.2.0 (2012-06-08): Feature release
+* Limited support of String PKs (no relations using String FKs yet)
+* Fixed index creation (please update your schema)
+* Added CountQuery for creating SELECT COUNT (*) queries with QueryBuilder
+* Added getDatabase in DaoMaster, DaoSession, and Dao
+* Added insertOrReplaceInTx in Dao
+* Added deleteInTx in Dao
+* Added autoincrement() creating AUTOINCREMENT PKs
+* Made DAOs and DaoSessions in active entities transient (allows serialization of entities)
+* Minor fixes
+
+### V1.1.2 (2012-03-26): ADT 17 support for demo project
+* Demo projects works with ADT 17 (moved greendao.jar into libs)
+* CREATE/DROP TABLE may be skipped for entity types: This allows having multiple entity types operate on the same table
+* Minor improvements
+
+### V1.1.1 (2012-02-14): Mini bugfix&feature release
+* Added NOT IN condition for QueryBuilder
+* Fix for Roboelectric (Issue #22)
+* Minor fix (Issue #5)
+
+### V1.1.0 (2012-02-13): Feature release
+* DeleteQuery for bulk deletes
+* Entities may implement Java interfaces
+* Entities may extend a Java class
+* Added LIMIT and OFFSET support for QueryBuilder and Query
+* Convenience methods to add named relationships
+* SQL scripts are executed in a transaction by default
+* Fixed queries with special column names (SQL keywords)
+* Changed default names for to-many relations to end with "List"
+* ORDER BY uses LOCALIZED collation for strings by default
+
+### V1.0.1 (2011-10-30): Bugfix release
+* Fixed generation of to-many relations
+* Fixed generated import statements when entities/DAO are not in the same package
+
+### V1.0.0 (2011-10-24): First open source release
+* To-many relations (lazily loaded on the entities)
+* To-many relations with custom join properties
+* Active entities can be updated, refreshed, and deleted directly
+* Significant performance improvements (faster identity scope, faster database result parser)
+* "Keep sections" for custom code in entities were added that won't be overwritten during code generation
+* Other minor improvements
+
+### Third preview (2011-08-19)
+http://greendao-orm.com/2011/08/19/query-builder-and-lazy-loading-lists/
+
+### Second preview (2011-08-12)
+http://greendao-orm.com/2011/08/12/greendao-2nd-preview/
+
+### First public release (2011-08-04)
+http://greendao-orm.com/2011/08/04/greendao-public-release/
\ No newline at end of file
diff --git a/DaoCore/.classpath b/DaoCore/.classpath
deleted file mode 100644
index 7bc01d9a..00000000
--- a/DaoCore/.classpath
+++ /dev/null
@@ -1,9 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="src" path="gen"/>
-	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
-	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
-	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
-	<classpathentry kind="output" path="bin/classes"/>
-</classpath>
diff --git a/DaoCore/.project b/DaoCore/.project
deleted file mode 100644
index 6fdcae5d..00000000
--- a/DaoCore/.project
+++ /dev/null
@@ -1,39 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<projectDescription>
-	<name>DaoCore</name>
-	<comment></comment>
-	<projects>
-	</projects>
-	<buildSpec>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>org.eclipse.jdt.core.javabuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>edu.umd.cs.findbugs.plugin.eclipse.findbugsBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-	</buildSpec>
-	<natures>
-		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
-		<nature>org.eclipse.jdt.core.javanature</nature>
-		<nature>edu.umd.cs.findbugs.plugin.eclipse.findbugsNature</nature>
-	</natures>
-</projectDescription>
diff --git a/DaoCore/.settings/org.eclipse.core.resources.prefs b/DaoCore/.settings/org.eclipse.core.resources.prefs
deleted file mode 100644
index 3d916f29..00000000
--- a/DaoCore/.settings/org.eclipse.core.resources.prefs
+++ /dev/null
@@ -1,2 +0,0 @@
-eclipse.preferences.version=1
-encoding/<project>=Cp1252
diff --git a/DaoCore/.settings/org.eclipse.jdt.core.prefs b/DaoCore/.settings/org.eclipse.jdt.core.prefs
deleted file mode 100644
index 641b1fef..00000000
--- a/DaoCore/.settings/org.eclipse.jdt.core.prefs
+++ /dev/null
@@ -1,12 +0,0 @@
-#Sat Jan 28 16:28:19 CET 2012
-eclipse.preferences.version=1
-org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
-org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.6
-org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
-org.eclipse.jdt.core.compiler.compliance=1.6
-org.eclipse.jdt.core.compiler.debug.lineNumber=generate
-org.eclipse.jdt.core.compiler.debug.localVariable=generate
-org.eclipse.jdt.core.compiler.debug.sourceFile=generate
-org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
-org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
-org.eclipse.jdt.core.compiler.source=1.6
diff --git a/DaoCore/NOTICE b/DaoCore/NOTICE
index 8e27d4ce..f4109c2c 100644
--- a/DaoCore/NOTICE
+++ b/DaoCore/NOTICE
@@ -1,4 +1,4 @@
-greenrobot greenDAO
-Copyright 2011 greenrobot.de
-
+greenrobot greenDAO
+Copyright 2011 greenrobot.de
+
 This product includes software developed at greenrobot.de (http://greenrobot.de/).
\ No newline at end of file
diff --git a/DaoCore/build.gradle b/DaoCore/build.gradle
index 82f43a50..072a988b 100644
--- a/DaoCore/build.gradle
+++ b/DaoCore/build.gradle
@@ -3,7 +3,8 @@ apply plugin: 'maven'
 apply plugin: 'signing'
 
 group = 'de.greenrobot'
-version = '1.3.8-SNAPSHOT'
+archivesBaseName = 'greendao'
+version = '2.1.1-SNAPSHOT'
 sourceCompatibility = 1.6
 
 def isSnapshot = version.endsWith('-SNAPSHOT')
@@ -18,7 +19,6 @@ repositories {
     mavenCentral()
 }
 
-
 // provided is not supported in Gradle 1.4, see http://issues.gradle.org/browse/GRADLE-784
 // Like this, it won't appear at all in the POM
 configurations {
@@ -38,16 +38,14 @@ dependencies {
 sourceSets {
     main {
         compileClasspath += configurations.provided
-        java {
-            srcDir 'src'
-        }
     }
 }
 
 javadoc {
+    failOnError = false
     classpath += configurations.provided
     title = " greenDAO ${version} API"
-	options.bottom = 'Available under the Apache License, Version 2.0 - <i>Copyright &#169; 2011-2013 <a href="http://greenrobot.de/">greenrobot.de</a>. All Rights Reserved.</i>'
+	options.bottom = 'Available under the Apache License, Version 2.0 - <i>Copyright &#169; 2011-2016 <a href="http://greenrobot.de/">greenrobot.de</a>. All Rights Reserved.</i>'
 	excludes = ['de/greenrobot/dao/internal','de/greenrobot/dao/Internal*']
 }
 
diff --git a/DaoCore/java-formater.xml b/DaoCore/java-formater.xml
deleted file mode 100644
index 9eabc7e4..00000000
--- a/DaoCore/java-formater.xml
+++ /dev/null
@@ -1,291 +0,0 @@
-<?xml version="1.0" encoding="UTF-8" standalone="no"?>
-<profiles version="12">
-<profile kind="CodeFormatterProfile" name="greenrobot" version="12">
-<setting id="org.eclipse.jdt.core.formatter.comment.insert_new_line_before_root_tags" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.disabling_tag" value="@formatter:off"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_annotation" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_type_parameters" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_type_declaration" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_type_arguments" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.brace_position_for_anonymous_type_declaration" value="end_of_line"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_colon_in_case" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_brace_in_array_initializer" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.comment.new_lines_at_block_boundaries" value="true"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_new_line_in_empty_annotation_declaration" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_new_line_before_closing_brace_in_array_initializer" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_annotation" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.blank_lines_before_field" value="0"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_while" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.use_on_off_tags" value="true"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_annotation_type_member_declaration" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_new_line_before_else_in_if_statement" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_prefix_operator" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.keep_else_statement_on_same_line" value="false"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_ellipsis" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.comment.insert_new_line_for_parameter" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_annotation_type_declaration" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.indent_breaks_compare_to_cases" value="true"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_at_in_annotation" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.alignment_for_multiple_fields" value="16"/>
-<setting id="org.eclipse.jdt.core.formatter.alignment_for_expressions_in_array_initializer" value="16"/>
-<setting id="org.eclipse.jdt.core.formatter.alignment_for_conditional_expression" value="80"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_for" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_binary_operator" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_question_in_wildcard" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.brace_position_for_array_initializer" value="end_of_line"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_enum_constant" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_new_line_before_finally_in_try_statement" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_local_variable" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_new_line_before_catch_in_try_statement" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_while" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.blank_lines_after_package" value="1"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_type_parameters" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.continuation_indentation" value="2"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_postfix_operator" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.alignment_for_arguments_in_method_invocation" value="16"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_type_arguments" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_superinterfaces" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.blank_lines_before_new_chunk" value="1"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_binary_operator" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.blank_lines_before_package" value="0"/>
-<setting id="org.eclipse.jdt.core.compiler.source" value="1.7"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_enum_constant_arguments" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_constructor_declaration" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.comment.format_line_comments" value="true"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_closing_angle_bracket_in_type_arguments" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_enum_declarations" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.join_wrapped_lines" value="true"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_block" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.alignment_for_arguments_in_explicit_constructor_call" value="16"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_invocation_arguments" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.blank_lines_before_member_type" value="1"/>
-<setting id="org.eclipse.jdt.core.formatter.align_type_members_on_columns" value="false"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_enum_constant" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_for" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_method_declaration" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.alignment_for_selector_in_method_invocation" value="16"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_switch" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_unary_operator" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_colon_in_case" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.comment.indent_parameter_description" value="true"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_method_declaration" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_switch" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_enum_declaration" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_type_parameters" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.comment.clear_blank_lines_in_block_comment" value="false"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_new_line_in_empty_type_declaration" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.lineSplit" value="120"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_if" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_between_brackets_in_array_type_reference" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_parenthesized_expression" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_explicitconstructorcall_arguments" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_constructor_declaration" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.blank_lines_before_first_class_body_declaration" value="0"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_method" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.indentation.size" value="4"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_method_declaration" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.enabling_tag" value="@formatter:on"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_enum_constant" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.alignment_for_superclass_in_type_declaration" value="16"/>
-<setting id="org.eclipse.jdt.core.formatter.alignment_for_assignment" value="0"/>
-<setting id="org.eclipse.jdt.core.compiler.problem.assertIdentifier" value="error"/>
-<setting id="org.eclipse.jdt.core.formatter.tabulation.char" value="space"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_constructor_declaration_parameters" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_semicolon_in_try_resources" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_prefix_operator" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.indent_statements_compare_to_body" value="true"/>
-<setting id="org.eclipse.jdt.core.formatter.blank_lines_before_method" value="1"/>
-<setting id="org.eclipse.jdt.core.formatter.wrap_outer_expressions_when_nested" value="true"/>
-<setting id="org.eclipse.jdt.core.formatter.format_guardian_clause_on_one_line" value="false"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_colon_in_for" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_cast" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.alignment_for_parameters_in_constructor_declaration" value="16"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_colon_in_labeled_statement" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.brace_position_for_annotation_type_declaration" value="end_of_line"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_new_line_in_empty_method_body" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.alignment_for_method_declaration" value="0"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_method_invocation" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_try" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_bracket_in_array_allocation_expression" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_enum_constant" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_annotation" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_at_in_annotation_type_declaration" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_declaration_throws" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_if" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.brace_position_for_switch" value="end_of_line"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_declaration_throws" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_parenthesized_expression_in_return" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_annotation" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_question_in_conditional" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_question_in_wildcard" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_try" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_bracket_in_array_allocation_expression" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.comment.preserve_white_space_between_code_and_line_comments" value="false"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_parenthesized_expression_in_throw" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_type_arguments" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.compiler.problem.enumIdentifier" value="error"/>
-<setting id="org.eclipse.jdt.core.formatter.indent_switchstatements_compare_to_switch" value="false"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_ellipsis" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.brace_position_for_block" value="end_of_line"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_for_inits" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.brace_position_for_method_declaration" value="end_of_line"/>
-<setting id="org.eclipse.jdt.core.formatter.compact_else_if" value="true"/>
-<setting id="org.eclipse.jdt.core.formatter.wrap_before_or_operator_multicatch" value="true"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_array_initializer" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_for_increments" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.format_line_comment_starting_on_first_column" value="true"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_bracket_in_array_reference" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_field" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.brace_position_for_enum_constant" value="end_of_line"/>
-<setting id="org.eclipse.jdt.core.formatter.comment.indent_root_tags" value="true"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_enum_declarations" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.alignment_for_union_type_in_multicatch" value="16"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_explicitconstructorcall_arguments" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_switch" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_declaration_parameters" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_superinterfaces" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_allocation_expression" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.tabulation.size" value="4"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_type_reference" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_opening_brace_in_array_initializer" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_closing_brace_in_block" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_reference" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_new_line_in_empty_enum_constant" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_type_arguments" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_constructor_declaration" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_constructor_declaration_throws" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_if" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.comment.clear_blank_lines_in_javadoc_comment" value="false"/>
-<setting id="org.eclipse.jdt.core.formatter.alignment_for_throws_clause_in_constructor_declaration" value="16"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_assignment_operator" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_assignment_operator" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.indent_empty_lines" value="false"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_synchronized" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_closing_paren_in_cast" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_declaration_parameters" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.brace_position_for_block_in_case" value="end_of_line"/>
-<setting id="org.eclipse.jdt.core.formatter.number_of_empty_lines_to_preserve" value="1"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_method_declaration" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_catch" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_constructor_declaration" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_method_invocation" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_bracket_in_array_reference" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.alignment_for_arguments_in_qualified_allocation_expression" value="16"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_and_in_type_parameter" value="insert"/>
-<setting id="org.eclipse.jdt.core.compiler.compliance" value="1.7"/>
-<setting id="org.eclipse.jdt.core.formatter.continuation_indentation_for_array_initializer" value="2"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_between_empty_brackets_in_array_allocation_expression" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_at_in_annotation_type_declaration" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.alignment_for_arguments_in_allocation_expression" value="16"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_cast" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_unary_operator" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_parameterized_type_reference" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_anonymous_type_declaration" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.keep_empty_array_initializer_on_one_line" value="false"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_new_line_in_empty_enum_declaration" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.keep_imple_if_on_one_line" value="false"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_constructor_declaration_parameters" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_closing_angle_bracket_in_type_parameters" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_new_line_at_end_of_file_if_missing" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_colon_in_for" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_colon_in_labeled_statement" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_parameterized_type_reference" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.alignment_for_superinterfaces_in_type_declaration" value="16"/>
-<setting id="org.eclipse.jdt.core.formatter.alignment_for_binary_expression" value="16"/>
-<setting id="org.eclipse.jdt.core.formatter.brace_position_for_enum_declaration" value="end_of_line"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_type" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_while" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode" value="enabled"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_try" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.put_empty_statement_on_new_line" value="true"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_label" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_parameter" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_type_parameters" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_method_invocation" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_new_line_before_while_in_do_statement" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.alignment_for_arguments_in_enum_constant" value="16"/>
-<setting id="org.eclipse.jdt.core.formatter.comment.format_javadoc_comments" value="true"/>
-<setting id="org.eclipse.jdt.core.formatter.comment.line_length" value="120"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_package" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.blank_lines_between_import_groups" value="1"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_enum_constant_arguments" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_semicolon" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.brace_position_for_constructor_declaration" value="end_of_line"/>
-<setting id="org.eclipse.jdt.core.formatter.number_of_blank_lines_at_beginning_of_method_body" value="0"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_colon_in_conditional" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_type_header" value="true"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_annotation_type_member_declaration" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.wrap_before_binary_operator" value="true"/>
-<setting id="org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_enum_declaration_header" value="true"/>
-<setting id="org.eclipse.jdt.core.formatter.blank_lines_between_type_declarations" value="1"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_synchronized" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.indent_statements_compare_to_block" value="true"/>
-<setting id="org.eclipse.jdt.core.formatter.alignment_for_superinterfaces_in_enum_declaration" value="16"/>
-<setting id="org.eclipse.jdt.core.formatter.join_lines_in_comments" value="true"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_question_in_conditional" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_multiple_field_declarations" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.alignment_for_compact_if" value="16"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_for_inits" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.indent_switchstatements_compare_to_cases" value="true"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_array_initializer" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_colon_in_default" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_and_in_type_parameter" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_constructor_declaration" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.blank_lines_before_imports" value="1"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_colon_in_assert" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.comment.format_html" value="true"/>
-<setting id="org.eclipse.jdt.core.formatter.alignment_for_throws_clause_in_method_declaration" value="16"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_type_parameters" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_allocation_expression" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_new_line_in_empty_anonymous_type_declaration" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_colon_in_conditional" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_parameterized_type_reference" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_for" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_postfix_operator" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.comment.format_source_code" value="true"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_synchronized" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_allocation_expression" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_constructor_declaration_throws" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.alignment_for_parameters_in_method_declaration" value="16"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_brace_in_array_initializer" value="insert"/>
-<setting id="org.eclipse.jdt.core.compiler.codegen.targetPlatform" value="1.7"/>
-<setting id="org.eclipse.jdt.core.formatter.alignment_for_resources_in_try" value="80"/>
-<setting id="org.eclipse.jdt.core.formatter.use_tabs_only_for_leading_indentations" value="true"/>
-<setting id="org.eclipse.jdt.core.formatter.alignment_for_arguments_in_annotation" value="0"/>
-<setting id="org.eclipse.jdt.core.formatter.comment.format_header" value="false"/>
-<setting id="org.eclipse.jdt.core.formatter.comment.format_block_comments" value="true"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_enum_constant" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.alignment_for_enum_constants" value="0"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_new_line_in_empty_block" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_annotation_declaration_header" value="true"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_parenthesized_expression" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_parenthesized_expression" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_catch" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_multiple_local_declarations" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_switch" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_for_increments" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_method_invocation" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_colon_in_assert" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.brace_position_for_type_declaration" value="end_of_line"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_array_initializer" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_between_empty_braces_in_array_initializer" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_method_declaration" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_semicolon_in_for" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_catch" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_parameterized_type_reference" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_multiple_field_declarations" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_annotation" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_parameterized_type_reference" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_invocation_arguments" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.comment.new_lines_at_javadoc_boundaries" value="true"/>
-<setting id="org.eclipse.jdt.core.formatter.blank_lines_after_imports" value="1"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_multiple_local_declarations" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_enum_constant_header" value="true"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_semicolon_in_for" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.never_indent_line_comments_on_first_column" value="false"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_semicolon_in_try_resources" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_type_arguments" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.never_indent_block_comments_on_first_column" value="false"/>
-<setting id="org.eclipse.jdt.core.formatter.keep_then_statement_on_same_line" value="false"/>
-</profile>
-</profiles>
diff --git a/DaoCore/settings.gradle b/DaoCore/settings.gradle
deleted file mode 100644
index 48427d6a..00000000
--- a/DaoCore/settings.gradle
+++ /dev/null
@@ -1 +0,0 @@
-rootProject.name = 'greendao'
\ No newline at end of file
diff --git a/DaoCore/src/de/greenrobot/dao/AbstractDao.java b/DaoCore/src/main/java/de/greenrobot/dao/AbstractDao.java
similarity index 85%
rename from DaoCore/src/de/greenrobot/dao/AbstractDao.java
rename to DaoCore/src/main/java/de/greenrobot/dao/AbstractDao.java
index 95c29eb2..ac957da6 100644
--- a/DaoCore/src/de/greenrobot/dao/AbstractDao.java
+++ b/DaoCore/src/main/java/de/greenrobot/dao/AbstractDao.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2013 Markus Junginger, greenrobot (http://greenrobot.de)
+ * Copyright (C) 2011-2016 Markus Junginger, greenrobot (http://greenrobot.de)
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,17 +16,18 @@
 
 package de.greenrobot.dao;
 
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.List;
-
 import android.database.CrossProcessCursor;
 import android.database.Cursor;
 import android.database.CursorWindow;
 import android.database.DatabaseUtils;
 import android.database.sqlite.SQLiteDatabase;
 import android.database.sqlite.SQLiteStatement;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.List;
+
 import de.greenrobot.dao.identityscope.IdentityScope;
 import de.greenrobot.dao.identityscope.IdentityScopeLong;
 import de.greenrobot.dao.internal.DaoConfig;
@@ -37,15 +38,12 @@
 
 /**
  * Base class for all DAOs: Implements entity operations like insert, load, delete, and query.
- * 
+ * <p/>
  * This class is thread-safe.
- * 
+ *
+ * @param <T> Entity type
+ * @param <K> Primary key (PK) type; use Void if entity does not have exactly one PK
  * @author Markus
- * 
- * @param <T>
- *            Entity type
- * @param <K>
- *            Primary key (PK) type; use Void if entity does not have exactly one PK
  */
 /*
  * When operating on TX, statements, or identity scope the following locking order must be met to avoid deadlocks:
@@ -117,9 +115,8 @@ public Property getPkProperty() {
 
     /**
      * Loads and entity for the given PK.
-     * 
-     * @param key
-     *            a PK value or null
+     *
+     * @param key a PK value or null
      * @return The entity or null, if no entity matched the PK value
      */
     public T load(K key) {
@@ -134,13 +131,13 @@ public T load(K key) {
             }
         }
         String sql = statements.getSelectByKey();
-        String[] keyArray = new String[] { key.toString() };
+        String[] keyArray = new String[]{key.toString()};
         Cursor cursor = db.rawQuery(sql, keyArray);
         return loadUniqueAndCloseCursor(cursor);
     }
 
     public T loadByRowId(long rowId) {
-        String[] idArray = new String[] { Long.toString(rowId) };
+        String[] idArray = new String[]{Long.toString(rowId)};
         Cursor cursor = db.rawQuery(statements.getSelectByRowId(), idArray);
         return loadUniqueAndCloseCursor(cursor);
     }
@@ -179,6 +176,16 @@ public boolean detach(T entity) {
         }
     }
 
+    /**
+     * Detaches all entities (of type T) from the identity scope (session). Subsequent query results won't return any
+     * previously loaded objects.
+     */
+    public void detachAll() {
+        if (identityScope != null) {
+            identityScope.clear();
+        }
+    }
+
     protected List<T> loadAllAndCloseCursor(Cursor cursor) {
         try {
             return loadAllFromCursor(cursor);
@@ -189,9 +196,8 @@ public boolean detach(T entity) {
 
     /**
      * Inserts the given entities in the database using a transaction.
-     * 
-     * @param entities
-     *            The entities to insert.
+     *
+     * @param entities The entities to insert.
      */
     public void insertInTx(Iterable<T> entities) {
         insertInTx(entities, isEntityUpdateable());
@@ -199,9 +205,8 @@ public void insertInTx(Iterable<T> entities) {
 
     /**
      * Inserts the given entities in the database using a transaction.
-     * 
-     * @param entities
-     *            The entities to insert.
+     *
+     * @param entities The entities to insert.
      */
     public void insertInTx(T... entities) {
         insertInTx(Arrays.asList(entities), isEntityUpdateable());
@@ -210,11 +215,10 @@ public void insertInTx(T... entities) {
     /**
      * Inserts the given entities in the database using a transaction. The given entities will become tracked if the PK
      * is set.
-     * 
-     * @param entities
-     *            The entities to insert.
-     * @param setPrimaryKey
-     *            if true, the PKs of the given will be set after the insert; pass false to improve performance.
+     *
+     * @param entities      The entities to insert.
+     * @param setPrimaryKey if true, the PKs of the given will be set after the insert; pass false to improve
+     *                      performance.
      */
     public void insertInTx(Iterable<T> entities, boolean setPrimaryKey) {
         SQLiteStatement stmt = statements.getInsertStatement();
@@ -224,11 +228,10 @@ public void insertInTx(Iterable<T> entities, boolean setPrimaryKey) {
     /**
      * Inserts or replaces the given entities in the database using a transaction. The given entities will become
      * tracked if the PK is set.
-     * 
-     * @param entities
-     *            The entities to insert.
-     * @param setPrimaryKey
-     *            if true, the PKs of the given will be set after the insert; pass false to improve performance.
+     *
+     * @param entities      The entities to insert.
+     * @param setPrimaryKey if true, the PKs of the given will be set after the insert; pass false to improve
+     *                      performance.
      */
     public void insertOrReplaceInTx(Iterable<T> entities, boolean setPrimaryKey) {
         SQLiteStatement stmt = statements.getInsertOrReplaceStatement();
@@ -237,9 +240,8 @@ public void insertOrReplaceInTx(Iterable<T> entities, boolean setPrimaryKey) {
 
     /**
      * Inserts or replaces the given entities in the database using a transaction.
-     * 
-     * @param entities
-     *            The entities to insert.
+     *
+     * @param entities The entities to insert.
      */
     public void insertOrReplaceInTx(Iterable<T> entities) {
         insertOrReplaceInTx(entities, isEntityUpdateable());
@@ -247,9 +249,8 @@ public void insertOrReplaceInTx(Iterable<T> entities) {
 
     /**
      * Inserts or replaces the given entities in the database using a transaction.
-     * 
-     * @param entities
-     *            The entities to insert.
+     *
+     * @param entities The entities to insert.
      */
     public void insertOrReplaceInTx(T... entities) {
         insertOrReplaceInTx(Arrays.asList(entities), isEntityUpdateable());
@@ -286,7 +287,7 @@ private void executeInsertInTx(SQLiteStatement stmt, Iterable<T> entities, boole
 
     /**
      * Insert an entity into the table associated with a concrete DAO.
-     * 
+     *
      * @return row ID of newly inserted entity
      */
     public long insert(T entity) {
@@ -294,9 +295,11 @@ public long insert(T entity) {
     }
 
     /**
-     * Insert an entity into the table associated with a concrete DAO <b>without</b> setting key property. Warning: This
-     * may be faster, but the entity should not be used anymore. The entity also won't be attached to identy scope.
-     * 
+     * Insert an entity into the table associated with a concrete DAO <b>without</b> setting key property.
+     *
+     * Warning: This may be faster, but the entity should not be used anymore. The entity also won't be attached to
+     * identity scope.
+     *
      * @return row ID of newly inserted entity
      */
     public long insertWithoutSettingPk(T entity) {
@@ -325,7 +328,7 @@ public long insertWithoutSettingPk(T entity) {
 
     /**
      * Insert an entity into the table associated with a concrete DAO.
-     * 
+     *
      * @return row ID of newly inserted entity
      */
     public long insertOrReplace(T entity) {
@@ -369,12 +372,18 @@ protected void updateKeyAfterInsertAndAttach(T entity, long rowId, boolean lock)
     /** Reads all available rows from the given cursor and returns a list of entities. */
     protected List<T> loadAllFromCursor(Cursor cursor) {
         int count = cursor.getCount();
+        if (count == 0) {
+            return new ArrayList<T>();
+        }
         List<T> list = new ArrayList<T>(count);
+        CursorWindow window = null;
+        boolean useFastCursor = false;
         if (cursor instanceof CrossProcessCursor) {
-            CursorWindow window = ((CrossProcessCursor) cursor).getWindow();
-            if (window != null) { // E.g. Roboelectric has no Window at this point
+            window = ((CrossProcessCursor) cursor).getWindow();
+            if (window != null) { // E.g. Robolectric has no Window at this point
                 if (window.getNumRows() == count) {
                     cursor = new FastCursor(window);
+                    useFastCursor = true;
                 } else {
                     DaoLog.d("Window vs. result size: " + window.getNumRows() + "/" + count);
                 }
@@ -386,10 +395,15 @@ protected void updateKeyAfterInsertAndAttach(T entity, long rowId, boolean lock)
                 identityScope.lock();
                 identityScope.reserveRoom(count);
             }
+
             try {
-                do {
-                    list.add(loadCurrent(cursor, 0, false));
-                } while (cursor.moveToNext());
+                if (!useFastCursor && window != null && identityScope != null) {
+                    loadAllUnlockOnWindowBounds(cursor, window, list);
+                } else {
+                    do {
+                        list.add(loadCurrent(cursor, 0, false));
+                    } while (cursor.moveToNext());
+                }
             } finally {
                 if (identityScope != null) {
                     identityScope.unlock();
@@ -399,6 +413,42 @@ protected void updateKeyAfterInsertAndAttach(T entity, long rowId, boolean lock)
         return list;
     }
 
+    private void loadAllUnlockOnWindowBounds(Cursor cursor, CursorWindow window, List<T> list) {
+        int windowEnd = window.getStartPosition() + window.getNumRows();
+        for (int row = 0; ; row++) {
+            list.add(loadCurrent(cursor, 0, false));
+            row++;
+            if (row >= windowEnd) {
+                window = moveToNextUnlocked(cursor);
+                if (window == null) {
+                    break;
+                }
+                windowEnd = window.getStartPosition() + window.getNumRows();
+            } else {
+                if (!cursor.moveToNext()) {
+                    break;
+                }
+            }
+        }
+    }
+
+    /**
+     * Unlock identityScope during cursor.moveToNext() when it is about to fill the window (needs a db connection):
+     * We should not hold the lock while trying to acquire a db connection to avoid deadlocks.
+     */
+    private CursorWindow moveToNextUnlocked(Cursor cursor) {
+        identityScope.unlock();
+        try {
+            if (cursor.moveToNext()) {
+                return ((CrossProcessCursor) cursor).getWindow();
+            } else {
+                return null;
+            }
+        } finally {
+            identityScope.lock();
+        }
+    }
+
     /** Internal use only. Considers identity scope. */
     final protected T loadCurrent(Cursor cursor, int offset, boolean lock) {
         if (identityScopeLong != null) {
@@ -579,9 +629,8 @@ private void deleteInTxInternal(Iterable<T> entities, Iterable<K> keys) {
 
     /**
      * Deletes the given entities in the database using a transaction.
-     * 
-     * @param entities
-     *            The entities to delete.
+     *
+     * @param entities The entities to delete.
      */
     public void deleteInTx(Iterable<T> entities) {
         deleteInTxInternal(entities, null);
@@ -589,9 +638,8 @@ public void deleteInTx(Iterable<T> entities) {
 
     /**
      * Deletes the given entities in the database using a transaction.
-     * 
-     * @param entities
-     *            The entities to delete.
+     *
+     * @param entities The entities to delete.
      */
     public void deleteInTx(T... entities) {
         deleteInTxInternal(Arrays.asList(entities), null);
@@ -599,9 +647,8 @@ public void deleteInTx(T... entities) {
 
     /**
      * Deletes all entities with the given keys in the database using a transaction.
-     * 
-     * @param keys
-     *            Keys of the entities to delete.
+     *
+     * @param keys Keys of the entities to delete.
      */
     public void deleteByKeyInTx(Iterable<K> keys) {
         deleteInTxInternal(null, keys);
@@ -609,9 +656,8 @@ public void deleteByKeyInTx(Iterable<K> keys) {
 
     /**
      * Deletes all entities with the given keys in the database using a transaction.
-     * 
-     * @param keys
-     *            Keys of the entities to delete.
+     *
+     * @param keys Keys of the entities to delete.
      */
     public void deleteByKeyInTx(K... keys) {
         deleteInTxInternal(null, Arrays.asList(keys));
@@ -622,7 +668,7 @@ public void refresh(T entity) {
         assertSinglePk();
         K key = getKeyVerified(entity);
         String sql = statements.getSelectByKey();
-        String[] keyArray = new String[] { key.toString() };
+        String[] keyArray = new String[]{key.toString()};
         Cursor cursor = db.rawQuery(sql, keyArray);
         try {
             boolean available = cursor.moveToFirst();
@@ -682,12 +728,10 @@ protected void updateInsideSynchronized(T entity, SQLiteStatement stmt, boolean
 
     /**
      * Attaches the entity to the identity scope. Calls attachEntity(T entity).
-     * 
-     * @param key
-     *            Needed only for identity scope, pass null if there's none.
-     * @param entity
-     *            The entitiy to attach
-     * */
+     *
+     * @param key    Needed only for identity scope, pass null if there's none.
+     * @param entity The entitiy to attach
+     */
     protected final void attachEntity(K key, T entity, boolean lock) {
         attachEntity(entity);
         if (identityScope != null && key != null) {
@@ -702,22 +746,21 @@ protected final void attachEntity(K key, T entity, boolean lock) {
     /**
      * Sub classes with relations additionally set the DaoMaster here. Must be called before the entity is attached to
      * the identity scope.
-     * 
-     * @param entity
-     *            The entitiy to attach
-     * */
+     *
+     * @param entity The entitiy to attach
+     */
     protected void attachEntity(T entity) {
     }
 
     /**
      * Updates the given entities in the database using a transaction.
-     * 
-     * @param entities
-     *            The entities to insert.
+     *
+     * @param entities The entities to insert.
      */
     public void updateInTx(Iterable<T> entities) {
         SQLiteStatement stmt = statements.getUpdateStatement();
         db.beginTransaction();
+        RuntimeException txEx = null;
         try {
             synchronized (stmt) {
                 if (identityScope != null) {
@@ -734,16 +777,26 @@ public void updateInTx(Iterable<T> entities) {
                 }
             }
             db.setTransactionSuccessful();
+        } catch (RuntimeException e) {
+            txEx = e;
         } finally {
-            db.endTransaction();
+            try {
+                db.endTransaction();
+            } catch (RuntimeException e) {
+                if (txEx != null) {
+                    DaoLog.w("Could not end transaction (rethrowing initial exception)", e);
+                    throw txEx;
+                } else {
+                    throw e;
+                }
+            }
         }
     }
 
     /**
      * Updates the given entities in the database using a transaction.
-     * 
-     * @param entities
-     *            The entities to update.
+     *
+     * @param entities The entities to update.
      */
     public void updateInTx(T... entities) {
         updateInTx(Arrays.asList(entities));
diff --git a/DaoCore/src/de/greenrobot/dao/AbstractDaoMaster.java b/DaoCore/src/main/java/de/greenrobot/dao/AbstractDaoMaster.java
similarity index 100%
rename from DaoCore/src/de/greenrobot/dao/AbstractDaoMaster.java
rename to DaoCore/src/main/java/de/greenrobot/dao/AbstractDaoMaster.java
diff --git a/DaoCore/src/de/greenrobot/dao/AbstractDaoSession.java b/DaoCore/src/main/java/de/greenrobot/dao/AbstractDaoSession.java
similarity index 94%
rename from DaoCore/src/de/greenrobot/dao/AbstractDaoSession.java
rename to DaoCore/src/main/java/de/greenrobot/dao/AbstractDaoSession.java
index 6a37ef2a..c3a3d5ce 100644
--- a/DaoCore/src/de/greenrobot/dao/AbstractDaoSession.java
+++ b/DaoCore/src/main/java/de/greenrobot/dao/AbstractDaoSession.java
@@ -15,6 +15,8 @@
  */
 package de.greenrobot.dao;
 
+import java.util.Collection;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
@@ -25,14 +27,14 @@
 import de.greenrobot.dao.query.QueryBuilder;
 
 /**
- * DaoSession gives you access to your DAOs, offers convenient persistence methods, and also serves as a session cache.<br/>
- * <br/>
- * To access the DAOs, call the get{entity}Dao methods by the generated DaoSession sub class.<br/>
- * <br/>
+ * DaoSession gives you access to your DAOs, offers convenient persistence methods, and also serves as a session cache.<br>
+ * <br>
+ * To access the DAOs, call the get{entity}Dao methods by the generated DaoSession sub class.<br>
+ * <br>
  * DaoSession offers many of the available persistence operations on entities as a convenience. Consider using DAOs
  * directly to access all available operations, especially if you call a lot of operations on a single entity type to
- * avoid the overhead imposed by DaoSession (the overhead is small, but it may add up).<br/>
- * <br/>
+ * avoid the overhead imposed by DaoSession (the overhead is small, but it may add up).<br>
+ * <br>
  * By default, the DaoSession has a session cache (IdentityScopeType.Session). The session cache is not just a plain
  * data cache to improve performance, but also manages object identities. For example, if you load the same entity twice
  * in a query, you will get a single Java object instead of two when using a session cache. This is particular useful
@@ -187,6 +189,11 @@ public SQLiteDatabase getDatabase() {
         return db;
     }
 
+    /** Allows to inspect the meta model using DAOs (e.g. querying table names or properties). */
+    public Collection<AbstractDao<?, ?>> getAllDaos() {
+        return Collections.unmodifiableCollection(entityToDao.values());
+    }
+
     /**
      * Creates a new {@link AsyncSession} to issue asynchronous entity operations. See {@link AsyncSession} for details.
      */
diff --git a/DaoCore/src/de/greenrobot/dao/DaoException.java b/DaoCore/src/main/java/de/greenrobot/dao/DaoException.java
similarity index 96%
rename from DaoCore/src/de/greenrobot/dao/DaoException.java
rename to DaoCore/src/main/java/de/greenrobot/dao/DaoException.java
index 0b3acac6..a428d1b7 100644
--- a/DaoCore/src/de/greenrobot/dao/DaoException.java
+++ b/DaoCore/src/main/java/de/greenrobot/dao/DaoException.java
@@ -1,55 +1,55 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package de.greenrobot.dao;
-
-import android.database.SQLException;
-
-/**
- * Exception thrown when something goes wrong in the DAO/ORM layer.
- * 
- * @author Markus
- * 
- */
-public class DaoException extends SQLException {
-
-    private static final long serialVersionUID = -5877937327907457779L;
-
-    public DaoException() {
-    }
-
-    public DaoException(String error) {
-        super(error);
-    }
-
-    public DaoException(String error, Throwable cause) {
-        super(error);
-        safeInitCause(cause);
-    }
-
-    public DaoException(Throwable th) {
-        safeInitCause(th);
-    }
-
-    protected void safeInitCause(Throwable cause) {
-        try {
-            initCause(cause);
-        } catch (Throwable e) {
-            DaoLog.e("Could not set initial cause", e);
-            DaoLog.e( "Initial cause is:", cause);
-        }
-    }
-
-}
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.dao;
+
+import android.database.SQLException;
+
+/**
+ * Exception thrown when something goes wrong in the DAO/ORM layer.
+ * 
+ * @author Markus
+ * 
+ */
+public class DaoException extends SQLException {
+
+    private static final long serialVersionUID = -5877937327907457779L;
+
+    public DaoException() {
+    }
+
+    public DaoException(String error) {
+        super(error);
+    }
+
+    public DaoException(String error, Throwable cause) {
+        super(error);
+        safeInitCause(cause);
+    }
+
+    public DaoException(Throwable th) {
+        safeInitCause(th);
+    }
+
+    protected void safeInitCause(Throwable cause) {
+        try {
+            initCause(cause);
+        } catch (Throwable e) {
+            DaoLog.e("Could not set initial cause", e);
+            DaoLog.e( "Initial cause is:", cause);
+        }
+    }
+
+}
diff --git a/DaoCore/src/de/greenrobot/dao/DaoLog.java b/DaoCore/src/main/java/de/greenrobot/dao/DaoLog.java
similarity index 96%
rename from DaoCore/src/de/greenrobot/dao/DaoLog.java
rename to DaoCore/src/main/java/de/greenrobot/dao/DaoLog.java
index 7a19cf52..e46f6e93 100644
--- a/DaoCore/src/de/greenrobot/dao/DaoLog.java
+++ b/DaoCore/src/main/java/de/greenrobot/dao/DaoLog.java
@@ -1,93 +1,93 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package de.greenrobot.dao;
-
-import android.util.Log;
-
-/**
- * Internal greenDAO logger class. A wrapper around the Android Log class providing a static Log Tag.
- * 
- * @author markus
- * 
- */
-public class DaoLog {
-    private final static String TAG = "greenDAO";
-
-    public static final int VERBOSE = 2;
-    public static final int DEBUG = 3;
-    public static final int INFO = 4;
-    public static final int WARN = 5;
-    public static final int ERROR = 6;
-    public static final int ASSERT = 7;
-
-    public static boolean isLoggable(int level) {
-        return Log.isLoggable(TAG, level);
-    }
-
-    public static String getStackTraceString(Throwable th) {
-        return Log.getStackTraceString(th);
-    }
-
-    public static int println(int level, String msg) {
-        return Log.println(level, TAG, msg);
-    }
-
-    public static int v(String msg) {
-        return Log.v(TAG, msg);
-    }
-
-    public static int v(String msg, Throwable th) {
-        return Log.v(TAG, msg, th);
-    }
-
-    public static int d(String msg) {
-        return Log.d(TAG, msg);
-    }
-
-    public static int d(String msg, Throwable th) {
-        return Log.d(TAG, msg, th);
-    }
-
-    public static int i(String msg) {
-        return Log.i(TAG, msg);
-    }
-
-    public static int i(String msg, Throwable th) {
-        return Log.i(TAG, msg, th);
-    }
-
-    public static int w(String msg) {
-        return Log.w(TAG, msg);
-    }
-
-    public static int w(String msg, Throwable th) {
-        return Log.w(TAG, msg, th);
-    }
-
-    public static int w(Throwable th) {
-        return Log.w(TAG, th);
-    }
-
-    public static int e(String msg) {
-        return Log.w(TAG, msg);
-    }
-
-    public static int e(String msg, Throwable th) {
-        return Log.e(TAG, msg, th);
-    }
-
-}
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package de.greenrobot.dao;
+
+import android.util.Log;
+
+/**
+ * Internal greenDAO logger class. A wrapper around the Android Log class providing a static Log Tag.
+ * 
+ * @author markus
+ * 
+ */
+public class DaoLog {
+    private final static String TAG = "greenDAO";
+
+    public static final int VERBOSE = 2;
+    public static final int DEBUG = 3;
+    public static final int INFO = 4;
+    public static final int WARN = 5;
+    public static final int ERROR = 6;
+    public static final int ASSERT = 7;
+
+    public static boolean isLoggable(int level) {
+        return Log.isLoggable(TAG, level);
+    }
+
+    public static String getStackTraceString(Throwable th) {
+        return Log.getStackTraceString(th);
+    }
+
+    public static int println(int level, String msg) {
+        return Log.println(level, TAG, msg);
+    }
+
+    public static int v(String msg) {
+        return Log.v(TAG, msg);
+    }
+
+    public static int v(String msg, Throwable th) {
+        return Log.v(TAG, msg, th);
+    }
+
+    public static int d(String msg) {
+        return Log.d(TAG, msg);
+    }
+
+    public static int d(String msg, Throwable th) {
+        return Log.d(TAG, msg, th);
+    }
+
+    public static int i(String msg) {
+        return Log.i(TAG, msg);
+    }
+
+    public static int i(String msg, Throwable th) {
+        return Log.i(TAG, msg, th);
+    }
+
+    public static int w(String msg) {
+        return Log.w(TAG, msg);
+    }
+
+    public static int w(String msg, Throwable th) {
+        return Log.w(TAG, msg, th);
+    }
+
+    public static int w(Throwable th) {
+        return Log.w(TAG, th);
+    }
+
+    public static int e(String msg) {
+        return Log.w(TAG, msg);
+    }
+
+    public static int e(String msg, Throwable th) {
+        return Log.e(TAG, msg, th);
+    }
+
+}
diff --git a/DaoCore/src/de/greenrobot/dao/DbUtils.java b/DaoCore/src/main/java/de/greenrobot/dao/DbUtils.java
similarity index 97%
rename from DaoCore/src/de/greenrobot/dao/DbUtils.java
rename to DaoCore/src/main/java/de/greenrobot/dao/DbUtils.java
index 62e5c976..4cf4a389 100644
--- a/DaoCore/src/de/greenrobot/dao/DbUtils.java
+++ b/DaoCore/src/main/java/de/greenrobot/dao/DbUtils.java
@@ -1,136 +1,136 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package de.greenrobot.dao;
-
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-
-import android.content.Context;
-import android.database.Cursor;
-import android.database.DatabaseUtils;
-import android.database.sqlite.SQLiteDatabase;
-
-/** Database utils, for example to execute SQL scripts */
-// TODO add unit tests
-public class DbUtils {
-
-    public static void vacuum(SQLiteDatabase db) {
-        db.execSQL("VACUUM");
-    }
-
-    /**
-     * Calls {@link #executeSqlScript(Context, SQLiteDatabase, String, boolean)} with transactional set to true.
-     * 
-     * @return number of statements executed.
-     */
-    public static int executeSqlScript(Context context, SQLiteDatabase db, String assetFilename) throws IOException {
-        return executeSqlScript(context, db, assetFilename, true);
-    }
-
-    /**
-     * Executes the given SQL asset in the given database (SQL file should be UTF-8). The database file may contain
-     * multiple SQL statements. Statements are split using a simple regular expression (something like
-     * "semicolon before a line break"), not by analyzing the SQL syntax. This will work for many SQL files, but check
-     * yours.
-     * 
-     * @return number of statements executed.
-     */
-    public static int executeSqlScript(Context context, SQLiteDatabase db, String assetFilename, boolean transactional)
-            throws IOException {
-        byte[] bytes = readAsset(context, assetFilename);
-        String sql = new String(bytes, "UTF-8");
-        String[] lines = sql.split(";(\\s)*[\n\r]");
-        int count;
-        if (transactional) {
-            count = executeSqlStatementsInTx(db, lines);
-        } else {
-            count = executeSqlStatements(db, lines);
-        }
-        DaoLog.i("Executed " + count + " statements from SQL script '" + assetFilename + "'");
-        return count;
-    }
-
-    public static int executeSqlStatementsInTx(SQLiteDatabase db, String[] statements) {
-        db.beginTransaction();
-        try {
-            int count = executeSqlStatements(db, statements);
-            db.setTransactionSuccessful();
-            return count;
-        } finally {
-            db.endTransaction();
-        }
-    }
-
-    public static int executeSqlStatements(SQLiteDatabase db, String[] statements) {
-        int count = 0;
-        for (String line : statements) {
-            line = line.trim();
-            if (line.length() > 0) {
-                db.execSQL(line);
-                count++;
-            }
-        }
-        return count;
-    }
-
-    /**
-     * Copies all available data from in to out without closing any stream.
-     * 
-     * @return number of bytes copied
-     */
-    public static int copyAllBytes(InputStream in, OutputStream out) throws IOException {
-        int byteCount = 0;
-        byte[] buffer = new byte[4096];
-        while (true) {
-            int read = in.read(buffer);
-            if (read == -1) {
-                break;
-            }
-            out.write(buffer, 0, read);
-            byteCount += read;
-        }
-        return byteCount;
-    }
-
-    public static byte[] readAllBytes(InputStream in) throws IOException {
-        ByteArrayOutputStream out = new ByteArrayOutputStream();
-        copyAllBytes(in, out);
-        return out.toByteArray();
-    }
-
-    public static byte[] readAsset(Context context, String filename) throws IOException {
-        InputStream in = context.getResources().getAssets().open(filename);
-        try {
-            return readAllBytes(in);
-        } finally {
-            in.close();
-        }
-    }
-
-    public static void logTableDump(SQLiteDatabase db, String tablename) {
-        Cursor cursor = db.query(tablename, null, null, null, null, null, null);
-        try {
-            String dump = DatabaseUtils.dumpCursorToString(cursor);
-            DaoLog.d(dump);
-        } finally {
-            cursor.close();
-        }
-    }
-
-}
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package de.greenrobot.dao;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+
+import android.content.Context;
+import android.database.Cursor;
+import android.database.DatabaseUtils;
+import android.database.sqlite.SQLiteDatabase;
+
+/** Database utils, for example to execute SQL scripts */
+// TODO add unit tests
+public class DbUtils {
+
+    public static void vacuum(SQLiteDatabase db) {
+        db.execSQL("VACUUM");
+    }
+
+    /**
+     * Calls {@link #executeSqlScript(Context, SQLiteDatabase, String, boolean)} with transactional set to true.
+     * 
+     * @return number of statements executed.
+     */
+    public static int executeSqlScript(Context context, SQLiteDatabase db, String assetFilename) throws IOException {
+        return executeSqlScript(context, db, assetFilename, true);
+    }
+
+    /**
+     * Executes the given SQL asset in the given database (SQL file should be UTF-8). The database file may contain
+     * multiple SQL statements. Statements are split using a simple regular expression (something like
+     * "semicolon before a line break"), not by analyzing the SQL syntax. This will work for many SQL files, but check
+     * yours.
+     * 
+     * @return number of statements executed.
+     */
+    public static int executeSqlScript(Context context, SQLiteDatabase db, String assetFilename, boolean transactional)
+            throws IOException {
+        byte[] bytes = readAsset(context, assetFilename);
+        String sql = new String(bytes, "UTF-8");
+        String[] lines = sql.split(";(\\s)*[\n\r]");
+        int count;
+        if (transactional) {
+            count = executeSqlStatementsInTx(db, lines);
+        } else {
+            count = executeSqlStatements(db, lines);
+        }
+        DaoLog.i("Executed " + count + " statements from SQL script '" + assetFilename + "'");
+        return count;
+    }
+
+    public static int executeSqlStatementsInTx(SQLiteDatabase db, String[] statements) {
+        db.beginTransaction();
+        try {
+            int count = executeSqlStatements(db, statements);
+            db.setTransactionSuccessful();
+            return count;
+        } finally {
+            db.endTransaction();
+        }
+    }
+
+    public static int executeSqlStatements(SQLiteDatabase db, String[] statements) {
+        int count = 0;
+        for (String line : statements) {
+            line = line.trim();
+            if (line.length() > 0) {
+                db.execSQL(line);
+                count++;
+            }
+        }
+        return count;
+    }
+
+    /**
+     * Copies all available data from in to out without closing any stream.
+     * 
+     * @return number of bytes copied
+     */
+    public static int copyAllBytes(InputStream in, OutputStream out) throws IOException {
+        int byteCount = 0;
+        byte[] buffer = new byte[4096];
+        while (true) {
+            int read = in.read(buffer);
+            if (read == -1) {
+                break;
+            }
+            out.write(buffer, 0, read);
+            byteCount += read;
+        }
+        return byteCount;
+    }
+
+    public static byte[] readAllBytes(InputStream in) throws IOException {
+        ByteArrayOutputStream out = new ByteArrayOutputStream();
+        copyAllBytes(in, out);
+        return out.toByteArray();
+    }
+
+    public static byte[] readAsset(Context context, String filename) throws IOException {
+        InputStream in = context.getResources().getAssets().open(filename);
+        try {
+            return readAllBytes(in);
+        } finally {
+            in.close();
+        }
+    }
+
+    public static void logTableDump(SQLiteDatabase db, String tablename) {
+        Cursor cursor = db.query(tablename, null, null, null, null, null, null);
+        try {
+            String dump = DatabaseUtils.dumpCursorToString(cursor);
+            DaoLog.d(dump);
+        } finally {
+            cursor.close();
+        }
+    }
+
+}
diff --git a/DaoCore/src/de/greenrobot/dao/InternalQueryDaoAccess.java b/DaoCore/src/main/java/de/greenrobot/dao/InternalQueryDaoAccess.java
similarity index 100%
rename from DaoCore/src/de/greenrobot/dao/InternalQueryDaoAccess.java
rename to DaoCore/src/main/java/de/greenrobot/dao/InternalQueryDaoAccess.java
diff --git a/DaoCore/src/de/greenrobot/dao/InternalUnitTestDaoAccess.java b/DaoCore/src/main/java/de/greenrobot/dao/InternalUnitTestDaoAccess.java
similarity index 100%
rename from DaoCore/src/de/greenrobot/dao/InternalUnitTestDaoAccess.java
rename to DaoCore/src/main/java/de/greenrobot/dao/InternalUnitTestDaoAccess.java
diff --git a/DaoCore/src/de/greenrobot/dao/Property.java b/DaoCore/src/main/java/de/greenrobot/dao/Property.java
similarity index 100%
rename from DaoCore/src/de/greenrobot/dao/Property.java
rename to DaoCore/src/main/java/de/greenrobot/dao/Property.java
diff --git a/DaoCore/src/de/greenrobot/dao/async/AsyncDaoException.java b/DaoCore/src/main/java/de/greenrobot/dao/async/AsyncDaoException.java
similarity index 96%
rename from DaoCore/src/de/greenrobot/dao/async/AsyncDaoException.java
rename to DaoCore/src/main/java/de/greenrobot/dao/async/AsyncDaoException.java
index a36a994c..48335b4a 100644
--- a/DaoCore/src/de/greenrobot/dao/async/AsyncDaoException.java
+++ b/DaoCore/src/main/java/de/greenrobot/dao/async/AsyncDaoException.java
@@ -1,41 +1,41 @@
-/*
- * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package de.greenrobot.dao.async;
-
-import de.greenrobot.dao.DaoException;
-
-/**
- * Used here: {@link AsyncOperation#getResult()}.
- * 
- * @author Markus
- */
-public class AsyncDaoException extends DaoException {
-
-    private static final long serialVersionUID = 5872157552005102382L;
-
-    private final AsyncOperation failedOperation;
-
-    public AsyncDaoException(AsyncOperation failedOperation, Throwable cause) {
-        super(cause);
-        this.failedOperation = failedOperation;
-    }
-
-    public AsyncOperation getFailedOperation() {
-        return failedOperation;
-    }
-
-}
+/*
+ * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package de.greenrobot.dao.async;
+
+import de.greenrobot.dao.DaoException;
+
+/**
+ * Used here: {@link AsyncOperation#getResult()}.
+ * 
+ * @author Markus
+ */
+public class AsyncDaoException extends DaoException {
+
+    private static final long serialVersionUID = 5872157552005102382L;
+
+    private final AsyncOperation failedOperation;
+
+    public AsyncDaoException(AsyncOperation failedOperation, Throwable cause) {
+        super(cause);
+        this.failedOperation = failedOperation;
+    }
+
+    public AsyncOperation getFailedOperation() {
+        return failedOperation;
+    }
+
+}
diff --git a/DaoCore/src/de/greenrobot/dao/async/AsyncOperation.java b/DaoCore/src/main/java/de/greenrobot/dao/async/AsyncOperation.java
similarity index 90%
rename from DaoCore/src/de/greenrobot/dao/async/AsyncOperation.java
rename to DaoCore/src/main/java/de/greenrobot/dao/async/AsyncOperation.java
index 7f1b1c02..38136065 100644
--- a/DaoCore/src/de/greenrobot/dao/async/AsyncOperation.java
+++ b/DaoCore/src/main/java/de/greenrobot/dao/async/AsyncOperation.java
@@ -22,9 +22,8 @@
 
 /**
  * An operation that will be enqueued for asynchronous execution.
- * 
+ *
  * @author Markus
- * 
  * @see AsyncSession
  */
 // TODO Implement Future<V>
@@ -45,6 +44,7 @@
 
     /** TODO unused, just an idea */
     public static final int FLAG_STOP_QUEUE_ON_EXCEPTION = 1 << 1;
+    public static final int FLAG_TRACK_CREATOR_STACKTRACE = 1 << 2;
 
     final OperationType type;
     final AbstractDao<Object, Object> dao;
@@ -57,26 +57,21 @@
     volatile long timeCompleted;
     private volatile boolean completed;
     volatile Throwable throwable;
+    final Exception creatorStacktrace;
     volatile Object result;
     volatile int mergedOperationsCount;
 
     int sequenceNumber;
 
     @SuppressWarnings("unchecked")
-    AsyncOperation(OperationType type, AbstractDao<?, ?> dao, Object parameter, int flags) {
+    /** Either supply dao or database (set other to null). */
+    AsyncOperation(OperationType type, AbstractDao<?, ?> dao, SQLiteDatabase database, Object parameter, int flags) {
         this.type = type;
         this.flags = flags;
         this.dao = (AbstractDao<Object, Object>) dao;
-        this.database = null;
-        this.parameter = parameter;
-    }
-
-    AsyncOperation(OperationType type, SQLiteDatabase database, Object parameter, int flags) {
-        this.type = type;
         this.database = database;
-        this.flags = flags;
-        this.dao = null;
         this.parameter = parameter;
+        creatorStacktrace = (flags & FLAG_TRACK_CREATOR_STACKTRACE) != 0 ? new Exception("AsyncOperation was created here") : null;
     }
 
     public Throwable getThrowable() {
@@ -97,7 +92,7 @@ public Object getParameter() {
 
     /**
      * The operation's result after it has completed. Waits until a result is available.
-     * 
+     *
      * @return The operation's result or null if the operation type does not produce any result.
      * @throws {@link AsyncDaoException} if the operation produced an exception
      * @see #waitForCompletion()
@@ -123,7 +118,7 @@ SQLiteDatabase getDatabase() {
 
     /**
      * @return true if this operation is mergeable with the given operation. Checks for null, {@link #FLAG_MERGE_TX},
-     *         and if the database instances match.
+     * and if the database instances match.
      */
     boolean isMergeableWith(AsyncOperation other) {
         return other != null && isMergeTx() && other.isMergeTx() && getDatabase() == other.getDatabase();
@@ -156,7 +151,7 @@ public boolean isCompleted() {
     /**
      * Waits until the operation is complete. If the thread gets interrupted, any {@link InterruptedException} will be
      * rethrown as a {@link DaoException}.
-     * 
+     *
      * @return Result if any, see {@link #getResult()}
      */
     public synchronized Object waitForCompletion() {
@@ -173,7 +168,7 @@ public synchronized Object waitForCompletion() {
     /**
      * Waits until the operation is complete, but at most the given amount of milliseconds.If the thread gets
      * interrupted, any {@link InterruptedException} will be rethrown as a {@link DaoException}.
-     * 
+     *
      * @return true if the operation completed in the given time frame.
      */
     public synchronized boolean waitForCompletion(int maxMillis) {
@@ -223,4 +218,11 @@ void reset() {
         mergedOperationsCount = 0;
     }
 
+    /**
+     * The stacktrace is captured using an exception if {@link #FLAG_TRACK_CREATOR_STACKTRACE} was used (null
+     * otherwise).
+     */
+    public Exception getCreatorStacktrace() {
+        return creatorStacktrace;
+    }
 }
diff --git a/DaoCore/src/de/greenrobot/dao/async/AsyncOperationExecutor.java b/DaoCore/src/main/java/de/greenrobot/dao/async/AsyncOperationExecutor.java
similarity index 72%
rename from DaoCore/src/de/greenrobot/dao/async/AsyncOperationExecutor.java
rename to DaoCore/src/main/java/de/greenrobot/dao/async/AsyncOperationExecutor.java
index b63ec1b4..6e3b277a 100644
--- a/DaoCore/src/de/greenrobot/dao/async/AsyncOperationExecutor.java
+++ b/DaoCore/src/main/java/de/greenrobot/dao/async/AsyncOperationExecutor.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
+ * Copyright (C) 2011-2015 Markus Junginger, greenrobot (http://greenrobot.de)
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -15,14 +15,6 @@
  */
 package de.greenrobot.dao.async;
 
-import java.util.ArrayList;
-import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.Callable;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.TimeUnit;
-
 import android.database.sqlite.SQLiteDatabase;
 import android.os.Handler;
 import android.os.Looper;
@@ -31,6 +23,14 @@
 import de.greenrobot.dao.DaoLog;
 import de.greenrobot.dao.query.Query;
 
+import java.util.ArrayList;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.TimeUnit;
+
 class AsyncOperationExecutor implements Runnable, Handler.Callback {
 
     private static ExecutorService executorService = Executors.newCachedThreadPool();
@@ -119,7 +119,7 @@ public synchronized void waitForCompletion() {
     /**
      * Waits until all enqueued operations are complete, but at most the given amount of milliseconds. If the thread
      * gets interrupted, any {@link InterruptedException} will be rethrown as a {@link DaoException}.
-     * 
+     *
      * @return true if operations completed in the given time frame.
      */
     public synchronized boolean waitForCompletion(int maxMillis) {
@@ -141,9 +141,10 @@ public void run() {
                     AsyncOperation operation = queue.poll(1, TimeUnit.SECONDS);
                     if (operation == null) {
                         synchronized (this) {
-                            // Check again, this time in synchronized
+                            // Check again, this time in synchronized to be in sync with enqueue(AsyncOperation)
                             operation = queue.poll();
                             if (operation == null) {
+                                // set flag while still inside synchronized
                                 executorRunning = false;
                                 return;
                             }
@@ -173,6 +174,8 @@ public void run() {
         }
     }
 
+
+    /** Also checks for other operations in the queue that can be merged into the transaction. */
     private void mergeTxAndExecute(AsyncOperation operation1, AsyncOperation operation2) {
         ArrayList<AsyncOperation> mergedOps = new ArrayList<AsyncOperation>();
         mergedOps.add(operation1);
@@ -180,14 +183,13 @@ private void mergeTxAndExecute(AsyncOperation operation1, AsyncOperation operati
 
         SQLiteDatabase db = operation1.getDatabase();
         db.beginTransaction();
-        boolean failed = false;
+        boolean success = false;
         try {
             for (int i = 0; i < mergedOps.size(); i++) {
                 AsyncOperation operation = mergedOps.get(i);
                 executeOperation(operation);
                 if (operation.isFailed()) {
                     // Operation may still have changed the DB, roll back everything
-                    failed = true;
                     break;
                 }
                 if (i == mergedOps.size() - 1) {
@@ -202,24 +204,32 @@ private void mergeTxAndExecute(AsyncOperation operation1, AsyncOperation operati
                     } else {
                         // No more ops in the queue to merge, finish it
                         db.setTransactionSuccessful();
+                        success = true;
+                        break;
                     }
                 }
             }
         } finally {
-            db.endTransaction();
-        }
-        if (failed) {
-            DaoLog.i("Revered merged transaction because one of the operations failed. Executing operations one by one instead...");
-            for (AsyncOperation asyncOperation : mergedOps) {
-                asyncOperation.reset();
-                executeOperationAndPostCompleted(asyncOperation);
+            try {
+                db.endTransaction();
+            } catch (RuntimeException e) {
+                DaoLog.i("Async transaction could not be ended, success so far was: " + success, e);
+                success = false;
             }
-        } else {
+        }
+        if (success) {
             int mergedCount = mergedOps.size();
             for (AsyncOperation asyncOperation : mergedOps) {
                 asyncOperation.mergedOperationsCount = mergedCount;
                 handleOperationCompleted(asyncOperation);
             }
+        } else {
+            DaoLog.i("Reverted merged transaction because one of the operations failed. Executing operations one by " +
+                    "one instead...");
+            for (AsyncOperation asyncOperation : mergedOps) {
+                asyncOperation.reset();
+                executeOperationAndPostCompleted(asyncOperation);
+            }
         }
     }
 
@@ -250,79 +260,79 @@ private void executeOperationAndPostCompleted(AsyncOperation operation) {
         handleOperationCompleted(operation);
     }
 
-    @SuppressWarnings({ "unchecked", "rawtypes" })
+    @SuppressWarnings({"unchecked", "rawtypes"})
     private void executeOperation(AsyncOperation operation) {
         operation.timeStarted = System.currentTimeMillis();
         try {
             switch (operation.type) {
-            case Delete:
-                operation.dao.delete(operation.parameter);
-                break;
-            case DeleteInTxIterable:
-                operation.dao.deleteInTx((Iterable<Object>) operation.parameter);
-                break;
-            case DeleteInTxArray:
-                operation.dao.deleteInTx((Object[]) operation.parameter);
-                break;
-            case Insert:
-                operation.dao.insert(operation.parameter);
-                break;
-            case InsertInTxIterable:
-                operation.dao.insertInTx((Iterable<Object>) operation.parameter);
-                break;
-            case InsertInTxArray:
-                operation.dao.insertInTx((Object[]) operation.parameter);
-                break;
-            case InsertOrReplace:
-                operation.dao.insertOrReplace(operation.parameter);
-                break;
-            case InsertOrReplaceInTxIterable:
-                operation.dao.insertOrReplaceInTx((Iterable<Object>) operation.parameter);
-                break;
-            case InsertOrReplaceInTxArray:
-                operation.dao.insertOrReplaceInTx((Object[]) operation.parameter);
-                break;
-            case Update:
-                operation.dao.update(operation.parameter);
-                break;
-            case UpdateInTxIterable:
-                operation.dao.updateInTx((Iterable<Object>) operation.parameter);
-                break;
-            case UpdateInTxArray:
-                operation.dao.updateInTx((Object[]) operation.parameter);
-                break;
-            case TransactionRunnable:
-                executeTransactionRunnable(operation);
-                break;
-            case TransactionCallable:
-                executeTransactionCallable(operation);
-                break;
-            case QueryList:
-                operation.result = ((Query) operation.parameter).list();
-                break;
-            case QueryUnique:
-                operation.result = ((Query) operation.parameter).unique();
-                break;
-            case DeleteByKey:
-                operation.dao.deleteByKey(operation.parameter);
-                break;
-            case DeleteAll:
-                operation.dao.deleteAll();
-                break;
-            case Load:
-                operation.result = operation.dao.load(operation.parameter);
-                break;
-            case LoadAll:
-                operation.result = operation.dao.loadAll();
-                break;
-            case Count:
-                operation.result = operation.dao.count();
-                break;
-            case Refresh:
-                operation.dao.refresh(operation.parameter);
-                break;
-            default:
-                throw new DaoException("Unsupported operation: " + operation.type);
+                case Delete:
+                    operation.dao.delete(operation.parameter);
+                    break;
+                case DeleteInTxIterable:
+                    operation.dao.deleteInTx((Iterable<Object>) operation.parameter);
+                    break;
+                case DeleteInTxArray:
+                    operation.dao.deleteInTx((Object[]) operation.parameter);
+                    break;
+                case Insert:
+                    operation.dao.insert(operation.parameter);
+                    break;
+                case InsertInTxIterable:
+                    operation.dao.insertInTx((Iterable<Object>) operation.parameter);
+                    break;
+                case InsertInTxArray:
+                    operation.dao.insertInTx((Object[]) operation.parameter);
+                    break;
+                case InsertOrReplace:
+                    operation.dao.insertOrReplace(operation.parameter);
+                    break;
+                case InsertOrReplaceInTxIterable:
+                    operation.dao.insertOrReplaceInTx((Iterable<Object>) operation.parameter);
+                    break;
+                case InsertOrReplaceInTxArray:
+                    operation.dao.insertOrReplaceInTx((Object[]) operation.parameter);
+                    break;
+                case Update:
+                    operation.dao.update(operation.parameter);
+                    break;
+                case UpdateInTxIterable:
+                    operation.dao.updateInTx((Iterable<Object>) operation.parameter);
+                    break;
+                case UpdateInTxArray:
+                    operation.dao.updateInTx((Object[]) operation.parameter);
+                    break;
+                case TransactionRunnable:
+                    executeTransactionRunnable(operation);
+                    break;
+                case TransactionCallable:
+                    executeTransactionCallable(operation);
+                    break;
+                case QueryList:
+                    operation.result = ((Query) operation.parameter).forCurrentThread().list();
+                    break;
+                case QueryUnique:
+                    operation.result = ((Query) operation.parameter).forCurrentThread().unique();
+                    break;
+                case DeleteByKey:
+                    operation.dao.deleteByKey(operation.parameter);
+                    break;
+                case DeleteAll:
+                    operation.dao.deleteAll();
+                    break;
+                case Load:
+                    operation.result = operation.dao.load(operation.parameter);
+                    break;
+                case LoadAll:
+                    operation.result = operation.dao.loadAll();
+                    break;
+                case Count:
+                    operation.result = operation.dao.count();
+                    break;
+                case Refresh:
+                    operation.dao.refresh(operation.parameter);
+                    break;
+                default:
+                    throw new DaoException("Unsupported operation: " + operation.type);
             }
         } catch (Throwable th) {
             operation.throwable = th;
diff --git a/DaoCore/src/de/greenrobot/dao/async/AsyncOperationListener.java b/DaoCore/src/main/java/de/greenrobot/dao/async/AsyncOperationListener.java
similarity index 72%
rename from DaoCore/src/de/greenrobot/dao/async/AsyncOperationListener.java
rename to DaoCore/src/main/java/de/greenrobot/dao/async/AsyncOperationListener.java
index cd8a91d8..0321892f 100644
--- a/DaoCore/src/de/greenrobot/dao/async/AsyncOperationListener.java
+++ b/DaoCore/src/main/java/de/greenrobot/dao/async/AsyncOperationListener.java
@@ -1,20 +1,25 @@
-/*
- * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package de.greenrobot.dao.async;
-
-public interface AsyncOperationListener {
-    void onAsyncOperationCompleted(AsyncOperation operation);
-}
+/*
+ * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.dao.async;
+
+/** Listener being called after completion of {@link de.greenrobot.dao.async.AsyncOperation}. */
+public interface AsyncOperationListener {
+    /**
+     * Note, that the operation may not have been successful, check
+     * {@link AsyncOperation#isFailed()} and/or {@link AsyncOperation#getThrowable()} for error situations.
+     */
+    void onAsyncOperationCompleted(AsyncOperation operation);
+}
diff --git a/DaoCore/src/de/greenrobot/dao/async/AsyncSession.java b/DaoCore/src/main/java/de/greenrobot/dao/async/AsyncSession.java
similarity index 94%
rename from DaoCore/src/de/greenrobot/dao/async/AsyncSession.java
rename to DaoCore/src/main/java/de/greenrobot/dao/async/AsyncSession.java
index f606a7a6..45e7dfc2 100644
--- a/DaoCore/src/de/greenrobot/dao/async/AsyncSession.java
+++ b/DaoCore/src/main/java/de/greenrobot/dao/async/AsyncSession.java
@@ -1,322 +1,334 @@
-package de.greenrobot.dao.async;
-
-import java.util.concurrent.Callable;
-
-import de.greenrobot.dao.AbstractDao;
-import de.greenrobot.dao.AbstractDaoSession;
-import de.greenrobot.dao.DaoException;
-import de.greenrobot.dao.async.AsyncOperation.OperationType;
-import de.greenrobot.dao.query.Query;
-
-/**
- * Asynchronous interface to entity operations. All operations will enqueued a @link {@link AsyncOperation} and return
- * immediately (fine to call on the UI/main thread). The queue will be processed in a (single) background thread. The
- * processing order is the call order of the operations. It's possible to start multiple AsyncSessions that will execute
- * concurrently.
- * 
- * @author Markus
- * 
- * @see AbstractDaoSession#startAsyncSession()
- */
-// Facade to AsyncOperationExecutor: prepares operations and delegates work to AsyncOperationExecutor.
-public class AsyncSession {
-    private final AbstractDaoSession daoSession;
-    private final AsyncOperationExecutor executor;
-
-    public AsyncSession(AbstractDaoSession daoSession) {
-        this.daoSession = daoSession;
-        this.executor = new AsyncOperationExecutor();
-    }
-
-    public int getMaxOperationCountToMerge() {
-        return executor.getMaxOperationCountToMerge();
-    }
-
-    public void setMaxOperationCountToMerge(int maxOperationCountToMerge) {
-        executor.setMaxOperationCountToMerge(maxOperationCountToMerge);
-    }
-
-    public int getWaitForMergeMillis() {
-        return executor.getWaitForMergeMillis();
-    }
-
-    public void setWaitForMergeMillis(int waitForMergeMillis) {
-        executor.setWaitForMergeMillis(waitForMergeMillis);
-    }
-
-    public AsyncOperationListener getListener() {
-        return executor.getListener();
-    }
-
-    public void setListener(AsyncOperationListener listener) {
-        executor.setListener(listener);
-    }
-
-    public AsyncOperationListener getListenerMainThread() {
-        return executor.getListenerMainThread();
-    }
-
-    public void setListenerMainThread(AsyncOperationListener listenerMainThread) {
-        executor.setListenerMainThread(listenerMainThread);
-    }
-
-    public boolean isCompleted() {
-        return executor.isCompleted();
-    }
-
-    /**
-     * Waits until all enqueued operations are complete. If the thread gets interrupted, any
-     * {@link InterruptedException} will be rethrown as a {@link DaoException}.
-     */
-    public void waitForCompletion() {
-        executor.waitForCompletion();
-    }
-
-    /**
-     * Waits until all enqueued operations are complete, but at most the given amount of milliseconds. If the thread
-     * gets interrupted, any {@link InterruptedException} will be rethrown as a {@link DaoException}.
-     * 
-     * @return true if operations completed in the given time frame.
-     */
-    public boolean waitForCompletion(int maxMillis) {
-        return executor.waitForCompletion(maxMillis);
-    }
-
-    /** Asynchronous version of {@link AbstractDao#insert(Object)}. */
-    public AsyncOperation insert(Object entity) {
-        return insert(entity, 0);
-    }
-
-    /** Asynchronous version of {@link AbstractDao#insert(Object)}. */
-    public AsyncOperation insert(Object entity, int flags) {
-        return enqueueEntityOperation(OperationType.Insert, entity, flags);
-    }
-
-    /** Asynchronous version of {@link AbstractDao#insertInTx(Object...)}. */
-    public <E> AsyncOperation insertInTx(Class<E> entityClass, E... entities) {
-        return insertInTx(entityClass, 0, entities);
-    }
-
-    /** Asynchronous version of {@link AbstractDao#insertInTx(Object...)}. */
-    public <E> AsyncOperation insertInTx(Class<E> entityClass, int flags, E... entities) {
-        return enqueEntityOperation(OperationType.InsertInTxArray, entityClass, entities, flags);
-    }
-
-    /** Asynchronous version of {@link AbstractDao#insertInTx(Iterable)}. */
-    public <E> AsyncOperation insertInTx(Class<E> entityClass, Iterable<E> entities) {
-        return insertInTx(entityClass, entities, 0);
-    }
-
-    /** Asynchronous version of {@link AbstractDao#insertInTx(Iterable)}. */
-    public <E> AsyncOperation insertInTx(Class<E> entityClass, Iterable<E> entities, int flags) {
-        return enqueEntityOperation(OperationType.InsertInTxIterable, entityClass, entities, flags);
-    }
-
-    /** Asynchronous version of {@link AbstractDao#insertOrReplace(Object)}. */
-    public AsyncOperation insertOrReplace(Object entity) {
-        return insertOrReplace(entity, 0);
-    }
-
-    /** Asynchronous version of {@link AbstractDao#insertOrReplace(Object)}. */
-    public AsyncOperation insertOrReplace(Object entity, int flags) {
-        return enqueueEntityOperation(OperationType.InsertOrReplace, entity, flags);
-    }
-
-    /** Asynchronous version of {@link AbstractDao#insertOrReplaceInTx(Object...)}. */
-    public <E> AsyncOperation insertOrReplaceInTx(Class<E> entityClass, E... entities) {
-        return insertOrReplaceInTx(entityClass, 0, entities);
-    }
-
-    /** Asynchronous version of {@link AbstractDao#insertOrReplaceInTx(Object...)}. */
-    public <E> AsyncOperation insertOrReplaceInTx(Class<E> entityClass, int flags, E... entities) {
-        return enqueEntityOperation(OperationType.InsertOrReplaceInTxArray, entityClass, entities, flags);
-    }
-
-    /** Asynchronous version of {@link AbstractDao#insertOrReplaceInTx(Iterable)}. */
-    public <E> AsyncOperation insertOrReplaceInTx(Class<E> entityClass, Iterable<E> entities) {
-        return insertOrReplaceInTx(entityClass, entities, 0);
-    }
-
-    /** Asynchronous version of {@link AbstractDao#insertOrReplaceInTx(Iterable)}. */
-    public <E> AsyncOperation insertOrReplaceInTx(Class<E> entityClass, Iterable<E> entities, int flags) {
-        return enqueEntityOperation(OperationType.InsertOrReplaceInTxIterable, entityClass, entities, flags);
-    }
-
-    /** Asynchronous version of {@link AbstractDao#update(Object)}. */
-    public AsyncOperation update(Object entity) {
-        return update(entity, 0);
-    }
-
-    /** Asynchronous version of {@link AbstractDao#update(Object)}. */
-    public AsyncOperation update(Object entity, int flags) {
-        return enqueueEntityOperation(OperationType.Update, entity, flags);
-    }
-
-    /** Asynchronous version of {@link AbstractDao#updateInTx(Object...)}. */
-    public <E> AsyncOperation updateInTx(Class<E> entityClass, E... entities) {
-        return updateInTx(entityClass, 0, entities);
-    }
-
-    /** Asynchronous version of {@link AbstractDao#updateInTx(Object...)}. */
-    public <E> AsyncOperation updateInTx(Class<E> entityClass, int flags, E... entities) {
-        return enqueEntityOperation(OperationType.UpdateInTxArray, entityClass, entities, flags);
-    }
-
-    /** Asynchronous version of {@link AbstractDao#updateInTx(Iterable)}. */
-    public <E> AsyncOperation updateInTx(Class<E> entityClass, Iterable<E> entities) {
-        return updateInTx(entityClass, entities, 0);
-    }
-
-    /** Asynchronous version of {@link AbstractDao#updateInTx(Iterable)}. */
-    public <E> AsyncOperation updateInTx(Class<E> entityClass, Iterable<E> entities, int flags) {
-        return enqueEntityOperation(OperationType.UpdateInTxIterable, entityClass, entities, flags);
-    }
-
-    /** Asynchronous version of {@link AbstractDao#delete(Object)}. */
-    public AsyncOperation delete(Object entity) {
-        return delete(entity, 0);
-    }
-
-    /** Asynchronous version of {@link AbstractDao#delete(Object)}. */
-    public AsyncOperation delete(Object entity, int flags) {
-        return enqueueEntityOperation(OperationType.Delete, entity, flags);
-    }
-
-    /** Asynchronous version of {@link AbstractDao#deleteByKey(Object)}. */
-    public AsyncOperation deleteByKey(Object key) {
-        return deleteByKey(key, 0);
-    }
-
-    /** Asynchronous version of {@link AbstractDao#deleteByKey(Object)}. */
-    public AsyncOperation deleteByKey(Object key, int flags) {
-        return enqueueEntityOperation(OperationType.DeleteByKey, key, flags);
-    }
-
-    /** Asynchronous version of {@link AbstractDao#deleteInTx(Object...)}. */
-    public <E> AsyncOperation deleteInTx(Class<E> entityClass, E... entities) {
-        return deleteInTx(entityClass, 0, entities);
-    }
-
-    /** Asynchronous version of {@link AbstractDao#deleteInTx(Object...)}. */
-    public <E> AsyncOperation deleteInTx(Class<E> entityClass, int flags, E... entities) {
-        return enqueEntityOperation(OperationType.DeleteInTxArray, entityClass, entities, flags);
-    }
-
-    /** Asynchronous version of {@link AbstractDao#deleteInTx(Iterable)}. */
-    public <E> AsyncOperation deleteInTx(Class<E> entityClass, Iterable<E> entities) {
-        return deleteInTx(entityClass, entities, 0);
-    }
-
-    /** Asynchronous version of {@link AbstractDao#deleteInTx(Iterable)}. */
-    public <E> AsyncOperation deleteInTx(Class<E> entityClass, Iterable<E> entities, int flags) {
-        return enqueEntityOperation(OperationType.DeleteInTxIterable, entityClass, entities, flags);
-    }
-
-    /** Asynchronous version of {@link AbstractDao#deleteAll()}. */
-    public <E> AsyncOperation deleteAll(Class<E> entityClass) {
-        return deleteAll(entityClass, 0);
-    }
-
-    /** Asynchronous version of {@link AbstractDao#deleteAll()}. */
-    public <E> AsyncOperation deleteAll(Class<E> entityClass, int flags) {
-        return enqueEntityOperation(OperationType.DeleteAll, entityClass, null, flags);
-    }
-
-    /** Asynchronous version of {@link AbstractDaoSession#runInTx(Runnable)}. */
-    public AsyncOperation runInTx(Runnable runnable) {
-        return runInTx(runnable, 0);
-    }
-
-    /** Asynchronous version of {@link AbstractDaoSession#runInTx(Runnable)}. */
-    public AsyncOperation runInTx(Runnable runnable, int flags) {
-        return enqueueDatabaseOperation(OperationType.TransactionRunnable, runnable, flags);
-    }
-
-    /** Asynchronous version of {@link AbstractDaoSession#callInTx(Callable)}. */
-    public AsyncOperation callInTx(Callable<?> callable) {
-        return callInTx(callable, 0);
-    }
-
-    /** Asynchronous version of {@link AbstractDaoSession#callInTx(Callable)}. */
-    public AsyncOperation callInTx(Callable<?> callable, int flags) {
-        return enqueueDatabaseOperation(OperationType.TransactionCallable, callable, flags);
-    }
-
-    /** Asynchronous version of {@link Query#list()}. */
-    public AsyncOperation queryList(Query<?> query) {
-        return queryList(query, 0);
-    }
-
-    /** Asynchronous version of {@link Query#list()}. */
-    public AsyncOperation queryList(Query<?> query, int flags) {
-        return enqueueDatabaseOperation(OperationType.QueryList, query, flags);
-    }
-
-    /** Asynchronous version of {@link Query#unique()}. */
-    public AsyncOperation queryUnique(Query<?> query) {
-        return queryUnique(query, 0);
-    }
-
-    /** Asynchronous version of {@link Query#unique()}. */
-    public AsyncOperation queryUnique(Query<?> query, int flags) {
-        return enqueueDatabaseOperation(OperationType.QueryUnique, query, flags);
-    }
-
-    /** Asynchronous version of {@link AbstractDao#load(Object)}. */
-    public AsyncOperation load(Class<?> entityClass, Object key) {
-        return load(entityClass, key, 0);
-    }
-
-    /** Asynchronous version of {@link AbstractDao#load(Object)}. */
-    public AsyncOperation load(Class<?> entityClass, Object key, int flags) {
-        return enqueEntityOperation(OperationType.Load, entityClass, key, flags);
-    }
-
-    /** Asynchronous version of {@link AbstractDao#loadAll()}. */
-    public AsyncOperation loadAll(Class<?> entityClass) {
-        return loadAll(entityClass, 0);
-    }
-
-    /** Asynchronous version of {@link AbstractDao#loadAll()}. */
-    public AsyncOperation loadAll(Class<?> entityClass, int flags) {
-        return enqueEntityOperation(OperationType.LoadAll, entityClass, null, flags);
-    }
-
-    /** Asynchronous version of {@link AbstractDao#count()}. */
-    public AsyncOperation count(Class<?> entityClass) {
-        return count(entityClass, 0);
-    }
-
-    /** Asynchronous version of {@link AbstractDao#count()}. */
-    public AsyncOperation count(Class<?> entityClass, int flags) {
-        return enqueEntityOperation(OperationType.Count, entityClass, null, flags);
-    }
-
-    /** Asynchronous version of {@link AbstractDao#refresh(Object)}. */
-    public AsyncOperation refresh(Object entity) {
-        return refresh(entity, 0);
-    }
-
-    /** Asynchronous version of {@link AbstractDao#refresh(Object)}. */
-    public AsyncOperation refresh(Object entity, int flags) {
-        return enqueueEntityOperation(OperationType.Refresh, entity, flags);
-    }
-
-    private AsyncOperation enqueueDatabaseOperation(OperationType type, Object param, int flags) {
-        AsyncOperation operation = new AsyncOperation(type, daoSession.getDatabase(), param, flags);
-        executor.enqueue(operation);
-        return operation;
-    }
-
-    private AsyncOperation enqueueEntityOperation(OperationType type, Object entity, int flags) {
-        return enqueEntityOperation(type, entity.getClass(), entity, flags);
-    }
-
-    private <E> AsyncOperation enqueEntityOperation(OperationType type, Class<E> entityClass, Object param, int flags) {
-        AbstractDao<?, ?> dao = daoSession.getDao(entityClass);
-        AsyncOperation operation = new AsyncOperation(type, dao, param, flags);
-        executor.enqueue(operation);
-        return operation;
-    }
-
-}
+package de.greenrobot.dao.async;
+
+import android.database.sqlite.SQLiteDatabase;
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.AbstractDaoSession;
+import de.greenrobot.dao.DaoException;
+import de.greenrobot.dao.async.AsyncOperation.OperationType;
+import de.greenrobot.dao.query.Query;
+
+import java.util.concurrent.Callable;
+
+/**
+ * Asynchronous interface to entity operations. All operations will enqueued a @link {@link AsyncOperation} and return
+ * immediately (fine to call on the UI/main thread). The queue will be processed in a (single) background thread. The
+ * processing order is the call order of the operations. It's possible to start multiple AsyncSessions that will
+ * execute
+ * concurrently.
+ *
+ * @author Markus
+ * @see AbstractDaoSession#startAsyncSession()
+ */
+// Facade to AsyncOperationExecutor: prepares operations and delegates work to AsyncOperationExecutor.
+public class AsyncSession {
+    private final AbstractDaoSession daoSession;
+    private final AsyncOperationExecutor executor;
+    private int sessionFlags;
+
+    public AsyncSession(AbstractDaoSession daoSession) {
+        this.daoSession = daoSession;
+        this.executor = new AsyncOperationExecutor();
+    }
+
+    public int getMaxOperationCountToMerge() {
+        return executor.getMaxOperationCountToMerge();
+    }
+
+    public void setMaxOperationCountToMerge(int maxOperationCountToMerge) {
+        executor.setMaxOperationCountToMerge(maxOperationCountToMerge);
+    }
+
+    public int getWaitForMergeMillis() {
+        return executor.getWaitForMergeMillis();
+    }
+
+    public void setWaitForMergeMillis(int waitForMergeMillis) {
+        executor.setWaitForMergeMillis(waitForMergeMillis);
+    }
+
+    public AsyncOperationListener getListener() {
+        return executor.getListener();
+    }
+
+    public void setListener(AsyncOperationListener listener) {
+        executor.setListener(listener);
+    }
+
+    public AsyncOperationListener getListenerMainThread() {
+        return executor.getListenerMainThread();
+    }
+
+    public void setListenerMainThread(AsyncOperationListener listenerMainThread) {
+        executor.setListenerMainThread(listenerMainThread);
+    }
+
+    public boolean isCompleted() {
+        return executor.isCompleted();
+    }
+
+    /**
+     * Waits until all enqueued operations are complete. If the thread gets interrupted, any
+     * {@link InterruptedException} will be rethrown as a {@link DaoException}.
+     */
+    public void waitForCompletion() {
+        executor.waitForCompletion();
+    }
+
+    /**
+     * Waits until all enqueued operations are complete, but at most the given amount of milliseconds. If the thread
+     * gets interrupted, any {@link InterruptedException} will be rethrown as a {@link DaoException}.
+     *
+     * @return true if operations completed in the given time frame.
+     */
+    public boolean waitForCompletion(int maxMillis) {
+        return executor.waitForCompletion(maxMillis);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#insert(Object)}. */
+    public AsyncOperation insert(Object entity) {
+        return insert(entity, 0);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#insert(Object)}. */
+    public AsyncOperation insert(Object entity, int flags) {
+        return enqueueEntityOperation(OperationType.Insert, entity, flags);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#insertInTx(Object...)}. */
+    public <E> AsyncOperation insertInTx(Class<E> entityClass, E... entities) {
+        return insertInTx(entityClass, 0, entities);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#insertInTx(Object...)}. */
+    public <E> AsyncOperation insertInTx(Class<E> entityClass, int flags, E... entities) {
+        return enqueEntityOperation(OperationType.InsertInTxArray, entityClass, entities, flags);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#insertInTx(Iterable)}. */
+    public <E> AsyncOperation insertInTx(Class<E> entityClass, Iterable<E> entities) {
+        return insertInTx(entityClass, entities, 0);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#insertInTx(Iterable)}. */
+    public <E> AsyncOperation insertInTx(Class<E> entityClass, Iterable<E> entities, int flags) {
+        return enqueEntityOperation(OperationType.InsertInTxIterable, entityClass, entities, flags);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#insertOrReplace(Object)}. */
+    public AsyncOperation insertOrReplace(Object entity) {
+        return insertOrReplace(entity, 0);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#insertOrReplace(Object)}. */
+    public AsyncOperation insertOrReplace(Object entity, int flags) {
+        return enqueueEntityOperation(OperationType.InsertOrReplace, entity, flags);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#insertOrReplaceInTx(Object...)}. */
+    public <E> AsyncOperation insertOrReplaceInTx(Class<E> entityClass, E... entities) {
+        return insertOrReplaceInTx(entityClass, 0, entities);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#insertOrReplaceInTx(Object...)}. */
+    public <E> AsyncOperation insertOrReplaceInTx(Class<E> entityClass, int flags, E... entities) {
+        return enqueEntityOperation(OperationType.InsertOrReplaceInTxArray, entityClass, entities, flags);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#insertOrReplaceInTx(Iterable)}. */
+    public <E> AsyncOperation insertOrReplaceInTx(Class<E> entityClass, Iterable<E> entities) {
+        return insertOrReplaceInTx(entityClass, entities, 0);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#insertOrReplaceInTx(Iterable)}. */
+    public <E> AsyncOperation insertOrReplaceInTx(Class<E> entityClass, Iterable<E> entities, int flags) {
+        return enqueEntityOperation(OperationType.InsertOrReplaceInTxIterable, entityClass, entities, flags);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#update(Object)}. */
+    public AsyncOperation update(Object entity) {
+        return update(entity, 0);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#update(Object)}. */
+    public AsyncOperation update(Object entity, int flags) {
+        return enqueueEntityOperation(OperationType.Update, entity, flags);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#updateInTx(Object...)}. */
+    public <E> AsyncOperation updateInTx(Class<E> entityClass, E... entities) {
+        return updateInTx(entityClass, 0, entities);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#updateInTx(Object...)}. */
+    public <E> AsyncOperation updateInTx(Class<E> entityClass, int flags, E... entities) {
+        return enqueEntityOperation(OperationType.UpdateInTxArray, entityClass, entities, flags);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#updateInTx(Iterable)}. */
+    public <E> AsyncOperation updateInTx(Class<E> entityClass, Iterable<E> entities) {
+        return updateInTx(entityClass, entities, 0);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#updateInTx(Iterable)}. */
+    public <E> AsyncOperation updateInTx(Class<E> entityClass, Iterable<E> entities, int flags) {
+        return enqueEntityOperation(OperationType.UpdateInTxIterable, entityClass, entities, flags);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#delete(Object)}. */
+    public AsyncOperation delete(Object entity) {
+        return delete(entity, 0);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#delete(Object)}. */
+    public AsyncOperation delete(Object entity, int flags) {
+        return enqueueEntityOperation(OperationType.Delete, entity, flags);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#deleteByKey(Object)}. */
+    public AsyncOperation deleteByKey(Object key) {
+        return deleteByKey(key, 0);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#deleteByKey(Object)}. */
+    public AsyncOperation deleteByKey(Object key, int flags) {
+        return enqueueEntityOperation(OperationType.DeleteByKey, key, flags);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#deleteInTx(Object...)}. */
+    public <E> AsyncOperation deleteInTx(Class<E> entityClass, E... entities) {
+        return deleteInTx(entityClass, 0, entities);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#deleteInTx(Object...)}. */
+    public <E> AsyncOperation deleteInTx(Class<E> entityClass, int flags, E... entities) {
+        return enqueEntityOperation(OperationType.DeleteInTxArray, entityClass, entities, flags);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#deleteInTx(Iterable)}. */
+    public <E> AsyncOperation deleteInTx(Class<E> entityClass, Iterable<E> entities) {
+        return deleteInTx(entityClass, entities, 0);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#deleteInTx(Iterable)}. */
+    public <E> AsyncOperation deleteInTx(Class<E> entityClass, Iterable<E> entities, int flags) {
+        return enqueEntityOperation(OperationType.DeleteInTxIterable, entityClass, entities, flags);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#deleteAll()}. */
+    public <E> AsyncOperation deleteAll(Class<E> entityClass) {
+        return deleteAll(entityClass, 0);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#deleteAll()}. */
+    public <E> AsyncOperation deleteAll(Class<E> entityClass, int flags) {
+        return enqueEntityOperation(OperationType.DeleteAll, entityClass, null, flags);
+    }
+
+    /** Asynchronous version of {@link AbstractDaoSession#runInTx(Runnable)}. */
+    public AsyncOperation runInTx(Runnable runnable) {
+        return runInTx(runnable, 0);
+    }
+
+    /** Asynchronous version of {@link AbstractDaoSession#runInTx(Runnable)}. */
+    public AsyncOperation runInTx(Runnable runnable, int flags) {
+        return enqueueDatabaseOperation(OperationType.TransactionRunnable, runnable, flags);
+    }
+
+    /** Asynchronous version of {@link AbstractDaoSession#callInTx(Callable)}. */
+    public AsyncOperation callInTx(Callable<?> callable) {
+        return callInTx(callable, 0);
+    }
+
+    /** Asynchronous version of {@link AbstractDaoSession#callInTx(Callable)}. */
+    public AsyncOperation callInTx(Callable<?> callable, int flags) {
+        return enqueueDatabaseOperation(OperationType.TransactionCallable, callable, flags);
+    }
+
+    /** Asynchronous version of {@link Query#list()}. */
+    public AsyncOperation queryList(Query<?> query) {
+        return queryList(query, 0);
+    }
+
+    /** Asynchronous version of {@link Query#list()}. */
+    public AsyncOperation queryList(Query<?> query, int flags) {
+        return enqueueDatabaseOperation(OperationType.QueryList, query, flags);
+    }
+
+    /** Asynchronous version of {@link Query#unique()}. */
+    public AsyncOperation queryUnique(Query<?> query) {
+        return queryUnique(query, 0);
+    }
+
+    /** Asynchronous version of {@link Query#unique()}. */
+    public AsyncOperation queryUnique(Query<?> query, int flags) {
+        return enqueueDatabaseOperation(OperationType.QueryUnique, query, flags);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#load(Object)}. */
+    public AsyncOperation load(Class<?> entityClass, Object key) {
+        return load(entityClass, key, 0);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#load(Object)}. */
+    public AsyncOperation load(Class<?> entityClass, Object key, int flags) {
+        return enqueEntityOperation(OperationType.Load, entityClass, key, flags);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#loadAll()}. */
+    public AsyncOperation loadAll(Class<?> entityClass) {
+        return loadAll(entityClass, 0);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#loadAll()}. */
+    public AsyncOperation loadAll(Class<?> entityClass, int flags) {
+        return enqueEntityOperation(OperationType.LoadAll, entityClass, null, flags);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#count()}. */
+    public AsyncOperation count(Class<?> entityClass) {
+        return count(entityClass, 0);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#count()}. */
+    public AsyncOperation count(Class<?> entityClass, int flags) {
+        return enqueEntityOperation(OperationType.Count, entityClass, null, flags);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#refresh(Object)}. */
+    public AsyncOperation refresh(Object entity) {
+        return refresh(entity, 0);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#refresh(Object)}. */
+    public AsyncOperation refresh(Object entity, int flags) {
+        return enqueueEntityOperation(OperationType.Refresh, entity, flags);
+    }
+
+    private AsyncOperation enqueueDatabaseOperation(OperationType type, Object param, int flags) {
+        SQLiteDatabase database = daoSession.getDatabase();
+        AsyncOperation operation = new AsyncOperation(type, null, database, param, flags | sessionFlags);
+        executor.enqueue(operation);
+        return operation;
+    }
+
+    private AsyncOperation enqueueEntityOperation(OperationType type, Object entity, int flags) {
+        return enqueEntityOperation(type, entity.getClass(), entity, flags);
+    }
+
+    private <E> AsyncOperation enqueEntityOperation(OperationType type, Class<E> entityClass, Object param, int flags) {
+        AbstractDao<?, ?> dao = daoSession.getDao(entityClass);
+        AsyncOperation operation = new AsyncOperation(type, dao, null, param, flags | sessionFlags);
+        executor.enqueue(operation);
+        return operation;
+    }
+
+    /** {@link de.greenrobot.dao.async.AsyncOperation} flags set for all operations (will be ORed with call flags). */
+    public int getSessionFlags() {
+        return sessionFlags;
+    }
+
+    /** {@link de.greenrobot.dao.async.AsyncOperation} flags set for all operations (will be ORed with call flags). */
+    public void setSessionFlags(int sessionFlags) {
+        this.sessionFlags = sessionFlags;
+    }
+}
diff --git a/DaoCore/src/main/java/de/greenrobot/dao/converter/PropertyConverter.java b/DaoCore/src/main/java/de/greenrobot/dao/converter/PropertyConverter.java
new file mode 100644
index 00000000..25108ab0
--- /dev/null
+++ b/DaoCore/src/main/java/de/greenrobot/dao/converter/PropertyConverter.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2011-2015 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package de.greenrobot.dao.converter;
+
+/**
+ * To use custom types in your entity, implement this to convert db values to entity values and back.
+ * <p/>
+ * Notes for implementations:
+ * <ul>
+ * <li>Converters are created by the default constructor</li>
+ * <li>Converters must be implemented thread-safe</li>
+ * </ul>
+ */
+public interface PropertyConverter<P, D> {
+    P convertToEntityProperty(D databaseValue);
+
+    D convertToDatabaseValue(P entityProperty);
+}
diff --git a/DaoCore/src/de/greenrobot/dao/identityscope/IdentityScope.java b/DaoCore/src/main/java/de/greenrobot/dao/identityscope/IdentityScope.java
similarity index 100%
rename from DaoCore/src/de/greenrobot/dao/identityscope/IdentityScope.java
rename to DaoCore/src/main/java/de/greenrobot/dao/identityscope/IdentityScope.java
diff --git a/DaoCore/src/de/greenrobot/dao/identityscope/IdentityScopeLong.java b/DaoCore/src/main/java/de/greenrobot/dao/identityscope/IdentityScopeLong.java
similarity index 100%
rename from DaoCore/src/de/greenrobot/dao/identityscope/IdentityScopeLong.java
rename to DaoCore/src/main/java/de/greenrobot/dao/identityscope/IdentityScopeLong.java
diff --git a/DaoCore/src/de/greenrobot/dao/identityscope/IdentityScopeObject.java b/DaoCore/src/main/java/de/greenrobot/dao/identityscope/IdentityScopeObject.java
similarity index 100%
rename from DaoCore/src/de/greenrobot/dao/identityscope/IdentityScopeObject.java
rename to DaoCore/src/main/java/de/greenrobot/dao/identityscope/IdentityScopeObject.java
diff --git a/DaoCore/src/de/greenrobot/dao/identityscope/IdentityScopeType.java b/DaoCore/src/main/java/de/greenrobot/dao/identityscope/IdentityScopeType.java
similarity index 100%
rename from DaoCore/src/de/greenrobot/dao/identityscope/IdentityScopeType.java
rename to DaoCore/src/main/java/de/greenrobot/dao/identityscope/IdentityScopeType.java
diff --git a/DaoCore/src/de/greenrobot/dao/internal/DaoConfig.java b/DaoCore/src/main/java/de/greenrobot/dao/internal/DaoConfig.java
similarity index 100%
rename from DaoCore/src/de/greenrobot/dao/internal/DaoConfig.java
rename to DaoCore/src/main/java/de/greenrobot/dao/internal/DaoConfig.java
diff --git a/DaoCore/src/de/greenrobot/dao/internal/FastCursor.java b/DaoCore/src/main/java/de/greenrobot/dao/internal/FastCursor.java
similarity index 100%
rename from DaoCore/src/de/greenrobot/dao/internal/FastCursor.java
rename to DaoCore/src/main/java/de/greenrobot/dao/internal/FastCursor.java
diff --git a/DaoCore/src/de/greenrobot/dao/internal/LongHashMap.java b/DaoCore/src/main/java/de/greenrobot/dao/internal/LongHashMap.java
similarity index 100%
rename from DaoCore/src/de/greenrobot/dao/internal/LongHashMap.java
rename to DaoCore/src/main/java/de/greenrobot/dao/internal/LongHashMap.java
diff --git a/DaoCore/src/de/greenrobot/dao/internal/SqlUtils.java b/DaoCore/src/main/java/de/greenrobot/dao/internal/SqlUtils.java
similarity index 69%
rename from DaoCore/src/de/greenrobot/dao/internal/SqlUtils.java
rename to DaoCore/src/main/java/de/greenrobot/dao/internal/SqlUtils.java
index fe1fd406..3e328bc9 100644
--- a/DaoCore/src/de/greenrobot/dao/internal/SqlUtils.java
+++ b/DaoCore/src/main/java/de/greenrobot/dao/internal/SqlUtils.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ * Copyright (C) 2011-2015 Markus Junginger, greenrobot (http://greenrobot.de)
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,17 +16,27 @@
 package de.greenrobot.dao.internal;
 
 import de.greenrobot.dao.DaoException;
+import de.greenrobot.dao.Property;
 
 /** Helper class to create SQL statements as used by greenDAO internally. */
 public class SqlUtils {
+    private final static char[] HEX_ARRAY = "0123456789ABCDEF".toCharArray();
+
+    public static StringBuilder appendProperty(StringBuilder builder, String tablePrefix, Property property) {
+        if (tablePrefix != null) {
+            builder.append(tablePrefix).append('.');
+        }
+        builder.append('"').append(property.columnName).append('"');
+        return builder;
+    }
 
     public static StringBuilder appendColumn(StringBuilder builder, String column) {
-        builder.append('\'').append(column).append('\'');
+        builder.append('"').append(column).append('"');
         return builder;
     }
 
     public static StringBuilder appendColumn(StringBuilder builder, String tableAlias, String column) {
-        builder.append(tableAlias).append(".'").append(column).append('\'');
+        builder.append(tableAlias).append(".\"").append(column).append('"');
         return builder;
     }
 
@@ -44,7 +54,7 @@ public static StringBuilder appendColumns(StringBuilder builder, String tableAli
     public static StringBuilder appendColumns(StringBuilder builder, String[] columns) {
         int length = columns.length;
         for (int i = 0; i < length; i++) {
-            builder.append('\'').append(columns[i]).append('\'');
+            builder.append('"').append(columns[i]).append('"');
             if (i < length - 1) {
                 builder.append(',');
             }
@@ -85,7 +95,7 @@ public static StringBuilder appendColumnsEqValue(StringBuilder builder, String t
 
     public static String createSqlInsert(String insertInto, String tablename, String[] columns) {
         StringBuilder builder = new StringBuilder(insertInto);
-        builder.append(tablename).append(" (");
+        builder.append('"').append(tablename).append('"').append(" (");
         appendColumns(builder, columns);
         builder.append(") VALUES (");
         appendPlaceholders(builder, columns.length);
@@ -94,22 +104,22 @@ public static String createSqlInsert(String insertInto, String tablename, String
     }
 
     /** Creates an select for given columns with a trailing space */
-    public static String createSqlSelect(String tablename, String tableAlias, String[] columns) {
-        StringBuilder builder = new StringBuilder("SELECT ");
+    public static String createSqlSelect(String tablename, String tableAlias, String[] columns, boolean distinct) {
         if (tableAlias == null || tableAlias.length() < 0) {
             throw new DaoException("Table alias required");
         }
 
+        StringBuilder builder = new StringBuilder(distinct ? "SELECT DISTINCT " : "SELECT ");
         SqlUtils.appendColumns(builder, tableAlias, columns).append(" FROM ");
-        builder.append(tablename).append(' ').append(tableAlias).append(' ');
+        builder.append('"').append(tablename).append('"').append(' ').append(tableAlias).append(' ');
         return builder.toString();
     }
 
     /** Creates SELECT COUNT(*) with a trailing space. */
     public static String createSqlSelectCountStar(String tablename, String tableAliasOrNull) {
         StringBuilder builder = new StringBuilder("SELECT COUNT(*) FROM ");
-        builder.append(tablename).append(' ');
-        if(tableAliasOrNull != null) {
+        builder.append('"').append(tablename).append('"').append(' ');
+        if (tableAliasOrNull != null) {
             builder.append(tableAliasOrNull).append(' ');
         }
         return builder.toString();
@@ -117,22 +127,37 @@ public static String createSqlSelectCountStar(String tablename, String tableAlia
 
     /** Remember: SQLite does not support joins nor table alias for DELETE. */
     public static String createSqlDelete(String tablename, String[] columns) {
+        String quotedTablename = '"' + tablename + '"';
         StringBuilder builder = new StringBuilder("DELETE FROM ");
-        builder.append(tablename);
+        builder.append(quotedTablename);
         if (columns != null && columns.length > 0) {
             builder.append(" WHERE ");
-            appendColumnsEqValue(builder, tablename, columns);
+            appendColumnsEqValue(builder, quotedTablename, columns);
         }
         return builder.toString();
     }
 
     public static String createSqlUpdate(String tablename, String[] updateColumns, String[] whereColumns) {
+        String quotedTablename = '"' + tablename + '"';
         StringBuilder builder = new StringBuilder("UPDATE ");
-        builder.append(tablename).append(" SET ");
+        builder.append(quotedTablename).append(" SET ");
         appendColumnsEqualPlaceholders(builder, updateColumns);
         builder.append(" WHERE ");
-        appendColumnsEqValue(builder, tablename, whereColumns);
+        appendColumnsEqValue(builder, quotedTablename, whereColumns);
         return builder.toString();
     }
 
+    public static String escapeBlobArgument(byte[] bytes) {
+        return "X'" + toHex(bytes) + '\'';
+    }
+
+    public static String toHex(byte[] bytes) {
+        char[] hexChars = new char[bytes.length * 2];
+        for (int i = 0; i < bytes.length; i++) {
+            int byteValue = bytes[i] & 0xFF;
+            hexChars[i * 2] = HEX_ARRAY[byteValue >>> 4];
+            hexChars[i * 2 + 1] = HEX_ARRAY[byteValue & 0x0F];
+        }
+        return new String(hexChars);
+    }
 }
diff --git a/DaoCore/src/de/greenrobot/dao/internal/TableStatements.java b/DaoCore/src/main/java/de/greenrobot/dao/internal/TableStatements.java
similarity index 98%
rename from DaoCore/src/de/greenrobot/dao/internal/TableStatements.java
rename to DaoCore/src/main/java/de/greenrobot/dao/internal/TableStatements.java
index 9414f1f7..864b6e04 100644
--- a/DaoCore/src/de/greenrobot/dao/internal/TableStatements.java
+++ b/DaoCore/src/main/java/de/greenrobot/dao/internal/TableStatements.java
@@ -77,7 +77,7 @@ public SQLiteStatement getUpdateStatement() {
     /** ends with an space to simplify appending to this string. */
     public String getSelectAll() {
         if (selectAll == null) {
-            selectAll = SqlUtils.createSqlSelect(tablename, "T", allColumns);
+            selectAll = SqlUtils.createSqlSelect(tablename, "T", allColumns, false);
         }
         return selectAll;
     }
@@ -85,7 +85,7 @@ public String getSelectAll() {
     /** ends with an space to simplify appending to this string. */
     public String getSelectKeys() {
         if (selectKeys == null) {
-            selectKeys = SqlUtils.createSqlSelect(tablename, "T", pkColumns);
+            selectKeys = SqlUtils.createSqlSelect(tablename, "T", pkColumns, false);
         }
         return selectKeys;
     }
diff --git a/DaoCore/src/de/greenrobot/dao/query/AbstractQuery.java b/DaoCore/src/main/java/de/greenrobot/dao/query/AbstractQuery.java
similarity index 88%
rename from DaoCore/src/de/greenrobot/dao/query/AbstractQuery.java
rename to DaoCore/src/main/java/de/greenrobot/dao/query/AbstractQuery.java
index 2569011f..3d5c27e8 100644
--- a/DaoCore/src/de/greenrobot/dao/query/AbstractQuery.java
+++ b/DaoCore/src/main/java/de/greenrobot/dao/query/AbstractQuery.java
@@ -25,9 +25,11 @@
  * @author Markus
  * 
  * @param <T>
- *            The enitity class the query will return results for.
+ *            The entity class the query will return results for.
  */
-// TODO support long, double, blob types directly
+// TODO support long, double and other types, not just Strings, for parameters
+// TODO Make parameters setable by Property (if unique in parameters)
+// TODO Make query compilable
 abstract class AbstractQuery<T> {
     protected final AbstractDao<T, ?> dao;
     protected final InternalQueryDaoAccess<T> daoAccess;
@@ -64,13 +66,14 @@ protected AbstractQuery(AbstractDao<T, ?> dao, String sql, String[] parameters)
     /**
      * Sets the parameter (0 based) using the position in which it was added during building the query.
      */
-    public void setParameter(int index, Object parameter) {
+    public AbstractQuery<T> setParameter(int index, Object parameter) {
         checkThread();
         if (parameter != null) {
             parameters[index] = parameter.toString();
         } else {
             parameters[index] = null;
         }
+        return this;
     }
 
     protected void checkThread() {
diff --git a/DaoCore/src/de/greenrobot/dao/query/AbstractQueryData.java b/DaoCore/src/main/java/de/greenrobot/dao/query/AbstractQueryData.java
similarity index 85%
rename from DaoCore/src/de/greenrobot/dao/query/AbstractQueryData.java
rename to DaoCore/src/main/java/de/greenrobot/dao/query/AbstractQueryData.java
index 7a4736ec..460bc857 100644
--- a/DaoCore/src/de/greenrobot/dao/query/AbstractQueryData.java
+++ b/DaoCore/src/main/java/de/greenrobot/dao/query/AbstractQueryData.java
@@ -31,6 +31,14 @@ Q forCurrentThread(Q query) {
 
     Q forCurrentThread() {
         int threadId = Process.myTid();
+        if (threadId == 0) {
+            // Workaround for Robolectric, always returns 0
+            long id = Thread.currentThread().getId();
+            if (id < 0 || id > Integer.MAX_VALUE) {
+                throw new RuntimeException("Cannot handle thread ID: " + id);
+            }
+            threadId = (int) id;
+        }
         synchronized (queriesForThreads) {
             WeakReference<Q> queryRef = queriesForThreads.get(threadId);
             Q query = queryRef != null ? queryRef.get() : null;
diff --git a/DaoCore/src/main/java/de/greenrobot/dao/query/AbstractQueryWithLimit.java b/DaoCore/src/main/java/de/greenrobot/dao/query/AbstractQueryWithLimit.java
new file mode 100644
index 00000000..c1816812
--- /dev/null
+++ b/DaoCore/src/main/java/de/greenrobot/dao/query/AbstractQueryWithLimit.java
@@ -0,0 +1,87 @@
+/*
+ * Copyright (C) 2011-2015 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.dao.query;
+
+import de.greenrobot.dao.AbstractDao;
+
+import java.util.Date;
+
+/**
+ * Base class for queries returning data (entities or cursor).
+ *
+ * @param <T> The entity class the query will return results for.
+ * @author Markus
+ */
+// TODO Query for PKs/ROW IDs
+abstract class AbstractQueryWithLimit<T> extends AbstractQuery<T> {
+    protected final int limitPosition;
+    protected final int offsetPosition;
+
+    protected AbstractQueryWithLimit(AbstractDao<T, ?> dao, String sql, String[] initialValues, int limitPosition,
+                                     int offsetPosition) {
+        super(dao, sql, initialValues);
+        this.limitPosition = limitPosition;
+        this.offsetPosition = offsetPosition;
+    }
+
+    /**
+     * Sets the parameter (0 based) using the position in which it was added during building the query. Note: all
+     * standard WHERE parameters come first. After that come the WHERE parameters of joins (if any).
+     */
+    public AbstractQueryWithLimit<T> setParameter(int index, Object parameter) {
+        if (index >= 0 && (index == limitPosition || index == offsetPosition)) {
+            throw new IllegalArgumentException("Illegal parameter index: " + index);
+        }
+        return (AbstractQueryWithLimit<T>) super.setParameter(index, parameter);
+    }
+
+    public AbstractQueryWithLimit<T> setParameter(int index, Date parameter) {
+        Long converted = parameter != null ? parameter.getTime() : null;
+        return setParameter(index, converted);
+    }
+
+    public AbstractQueryWithLimit<T> setParameter(int index, Boolean parameter) {
+        Integer converted = parameter != null ? (parameter ? 1 : 0) : null;
+        return setParameter(index, converted);
+    }
+
+    /**
+     * Sets the limit of the maximum number of results returned by this Query. {@link
+     * de.greenrobot.dao.query.QueryBuilder#limit(int)} must
+     * have been called on the QueryBuilder that created this Query object.
+     */
+    public void setLimit(int limit) {
+        checkThread();
+        if (limitPosition == -1) {
+            throw new IllegalStateException("Limit must be set with QueryBuilder before it can be used here");
+        }
+        parameters[limitPosition] = Integer.toString(limit);
+    }
+
+    /**
+     * Sets the offset for results returned by this Query. {@link de.greenrobot.dao.query.QueryBuilder#offset(int)} must
+     * have been called on
+     * the QueryBuilder that created this Query object.
+     */
+    public void setOffset(int offset) {
+        checkThread();
+        if (offsetPosition == -1) {
+            throw new IllegalStateException("Offset must be set with QueryBuilder before it can be used here");
+        }
+        parameters[offsetPosition] = Integer.toString(offset);
+    }
+
+}
diff --git a/DaoCore/src/de/greenrobot/dao/query/CloseableListIterator.java b/DaoCore/src/main/java/de/greenrobot/dao/query/CloseableListIterator.java
similarity index 97%
rename from DaoCore/src/de/greenrobot/dao/query/CloseableListIterator.java
rename to DaoCore/src/main/java/de/greenrobot/dao/query/CloseableListIterator.java
index 31cf1ad1..d135004a 100644
--- a/DaoCore/src/de/greenrobot/dao/query/CloseableListIterator.java
+++ b/DaoCore/src/main/java/de/greenrobot/dao/query/CloseableListIterator.java
@@ -1,31 +1,31 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package de.greenrobot.dao.query;
-
-import java.io.Closeable;
-import java.util.ListIterator;
-
-/**
- * A list iterator that needs to be closed (or the associated list) to free underlying resources like a database cursor.
- * Typically used with LazyList.
- * 
- * @author Markus
- * 
- * @param <T>
- */
-public interface CloseableListIterator<T> extends ListIterator<T>, Closeable {
-
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.dao.query;
+
+import java.io.Closeable;
+import java.util.ListIterator;
+
+/**
+ * A list iterator that needs to be closed (or the associated list) to free underlying resources like a database cursor.
+ * Typically used with LazyList.
+ * 
+ * @author Markus
+ * 
+ * @param <T>
+ */
+public interface CloseableListIterator<T> extends ListIterator<T>, Closeable {
+
 }
\ No newline at end of file
diff --git a/DaoCore/src/de/greenrobot/dao/query/CountQuery.java b/DaoCore/src/main/java/de/greenrobot/dao/query/CountQuery.java
similarity index 100%
rename from DaoCore/src/de/greenrobot/dao/query/CountQuery.java
rename to DaoCore/src/main/java/de/greenrobot/dao/query/CountQuery.java
diff --git a/DaoCore/src/main/java/de/greenrobot/dao/query/CursorQuery.java b/DaoCore/src/main/java/de/greenrobot/dao/query/CursorQuery.java
new file mode 100644
index 00000000..9ca90917
--- /dev/null
+++ b/DaoCore/src/main/java/de/greenrobot/dao/query/CursorQuery.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2011-2015 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.dao.query;
+
+import android.database.Cursor;
+import de.greenrobot.dao.AbstractDao;
+
+/**
+ * A repeatable query returning a raw android.database.Cursor. Note, that using cursors is usually a hassle and
+ * greenDAO provides a higher level abstraction using entities (see {@link de.greenrobot.dao.query.Query}). This class
+ * can nevertheless be useful to work with legacy code that is based on Cursors or CursorLoaders.
+ *
+ * @param <T> The entity class the query will return results for.
+ * @author Markus
+ */
+public class CursorQuery<T> extends AbstractQueryWithLimit<T> {
+    private final static class QueryData<T2> extends AbstractQueryData<T2, CursorQuery<T2>> {
+        private final int limitPosition;
+        private final int offsetPosition;
+
+        QueryData(AbstractDao dao, String sql, String[] initialValues, int limitPosition, int offsetPosition) {
+            super(dao, sql, initialValues);
+            this.limitPosition = limitPosition;
+            this.offsetPosition = offsetPosition;
+        }
+
+        @Override
+        protected CursorQuery<T2> createQuery() {
+            return new CursorQuery<T2>(this, dao, sql, initialValues.clone(), limitPosition, offsetPosition);
+        }
+
+    }
+
+    /** For internal use by greenDAO only. */
+    public static <T2> CursorQuery<T2> internalCreate(AbstractDao<T2, ?> dao, String sql, Object[] initialValues) {
+        return create(dao, sql, initialValues, -1, -1);
+    }
+
+    static <T2> CursorQuery<T2> create(AbstractDao<T2, ?> dao, String sql, Object[] initialValues, int limitPosition,
+                                       int offsetPosition) {
+        QueryData<T2> queryData = new QueryData<T2>(dao, sql, toStringArray(initialValues), limitPosition,
+                offsetPosition);
+        return queryData.forCurrentThread();
+    }
+
+    private final QueryData<T> queryData;
+
+    private CursorQuery(QueryData<T> queryData, AbstractDao<T, ?> dao, String sql, String[] initialValues, int limitPosition,
+                        int offsetPosition) {
+        super(dao, sql, initialValues, limitPosition, offsetPosition);
+        this.queryData = queryData;
+    }
+
+    public CursorQuery forCurrentThread() {
+        return queryData.forCurrentThread(this);
+    }
+
+    /** Executes the query and returns a raw android.database.Cursor. Don't forget to close it. */
+    public Cursor query() {
+        checkThread();
+        return dao.getDatabase().rawQuery(sql, parameters);
+    }
+
+}
diff --git a/DaoCore/src/de/greenrobot/dao/query/DeleteQuery.java b/DaoCore/src/main/java/de/greenrobot/dao/query/DeleteQuery.java
similarity index 97%
rename from DaoCore/src/de/greenrobot/dao/query/DeleteQuery.java
rename to DaoCore/src/main/java/de/greenrobot/dao/query/DeleteQuery.java
index 983e3720..ae4960e8 100644
--- a/DaoCore/src/de/greenrobot/dao/query/DeleteQuery.java
+++ b/DaoCore/src/main/java/de/greenrobot/dao/query/DeleteQuery.java
@@ -25,7 +25,7 @@
  * @author Markus
  * 
  * @param <T>
- *            The enitity class the query will delete from.
+ *            The entity class the query will delete from.
  */
 public class DeleteQuery<T> extends AbstractQuery<T> {
     private final static class QueryData<T2> extends AbstractQueryData<T2, DeleteQuery<T2>> {
diff --git a/DaoCore/src/main/java/de/greenrobot/dao/query/Join.java b/DaoCore/src/main/java/de/greenrobot/dao/query/Join.java
new file mode 100644
index 00000000..04dba3fe
--- /dev/null
+++ b/DaoCore/src/main/java/de/greenrobot/dao/query/Join.java
@@ -0,0 +1,91 @@
+/*
+ * Copyright (C) 2011-2015 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.dao.query;
+
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.Property;
+
+/**
+ * A Join lets you relate to other entity types for queries, and allows using WHERE statements on the joined entity
+ * type.
+ */
+public class Join<SRC, DST> {
+
+    final String sourceTablePrefix;
+    final AbstractDao<DST, ?> daoDestination;
+
+    final Property joinPropertySource;
+    final Property joinPropertyDestination;
+    final String tablePrefix;
+    final WhereCollector<DST> whereCollector;
+
+    public Join(String sourceTablePrefix, Property sourceJoinProperty,
+                AbstractDao<DST, ?> daoDestination, Property destinationJoinProperty,
+                String joinTablePrefix) {
+        this.sourceTablePrefix = sourceTablePrefix;
+        this.joinPropertySource = sourceJoinProperty;
+        this.daoDestination = daoDestination;
+        this.joinPropertyDestination = destinationJoinProperty;
+        tablePrefix = joinTablePrefix;
+        whereCollector = new WhereCollector<DST>(daoDestination, joinTablePrefix);
+    }
+
+
+    /**
+     * Adds the given conditions to the where clause using an logical AND. To create new conditions, use the properties
+     * given in the generated dao classes.
+     */
+    public Join<SRC, DST> where(WhereCondition cond, WhereCondition... condMore) {
+        whereCollector.add(cond, condMore);
+        return this;
+    }
+
+    /**
+     * Adds the given conditions to the where clause using an logical OR. To create new conditions, use the properties
+     * given in the generated dao classes.
+     */
+    public Join<SRC, DST> whereOr(WhereCondition cond1, WhereCondition cond2, WhereCondition... condMore) {
+        whereCollector.add(or(cond1, cond2, condMore));
+        return this;
+    }
+
+    /**
+     * Creates a WhereCondition by combining the given conditions using OR. The returned WhereCondition must be used
+     * inside {@link #where(WhereCondition, WhereCondition...)} or
+     * {@link #whereOr(WhereCondition, WhereCondition, WhereCondition...)}.
+     */
+    public WhereCondition or(WhereCondition cond1, WhereCondition cond2, WhereCondition... condMore) {
+        return whereCollector.combineWhereConditions(" OR ", cond1, cond2, condMore);
+    }
+
+    /**
+     * Creates a WhereCondition by combining the given conditions using AND. The returned WhereCondition must be used
+     * inside {@link #where(WhereCondition, WhereCondition...)} or
+     * {@link #whereOr(WhereCondition, WhereCondition, WhereCondition...)}.
+     */
+    public WhereCondition and(WhereCondition cond1, WhereCondition cond2, WhereCondition... condMore) {
+        return whereCollector.combineWhereConditions(" AND ", cond1, cond2, condMore);
+    }
+
+    /**
+     * Usually you don't need this value; just in case you are mixing custom
+     * {@link de.greenrobot.dao.query.WhereCondition.StringCondition} into the query, this value allows to reference
+     * the joined (target) table.
+     */
+    public String getTablePrefix() {
+        return tablePrefix;
+    }
+}
diff --git a/DaoCore/src/de/greenrobot/dao/query/LazyList.java b/DaoCore/src/main/java/de/greenrobot/dao/query/LazyList.java
similarity index 95%
rename from DaoCore/src/de/greenrobot/dao/query/LazyList.java
rename to DaoCore/src/main/java/de/greenrobot/dao/query/LazyList.java
index 9bf12337..cb2a513c 100644
--- a/DaoCore/src/de/greenrobot/dao/query/LazyList.java
+++ b/DaoCore/src/main/java/de/greenrobot/dao/query/LazyList.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ * Copyright (C) 2011-2015 Markus Junginger, greenrobot (http://greenrobot.de)
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -250,12 +250,21 @@ public E get(int location) {
             }
             return entity;
         } else {
-            return loadEntity(location);
+            lock.lock();
+            try {
+                return loadEntity(location);
+            } finally {
+                lock.unlock();
+            }
         }
     }
 
+    /** Lock must be locked when entering this method. */
     protected E loadEntity(int location) {
-        cursor.moveToPosition(location);
+        boolean ok = cursor.moveToPosition(location);
+        if(!ok) {
+            throw new DaoException("Could not move to cursor location " + location);
+        }
         E entity = daoAccess.loadCurrent(cursor, 0, true);
         if (entity == null) {
             throw new DaoException("Loading of entity failed (null) at position " + location);
@@ -334,7 +343,7 @@ public int size() {
     public List<E> subList(int start, int end) {
         checkCached();
         for (int i = start; i < end; i++) {
-            entities.get(i);
+            get(i);
         }
         return entities.subList(start, end);
     }
diff --git a/DaoCore/src/de/greenrobot/dao/query/Query.java b/DaoCore/src/main/java/de/greenrobot/dao/query/Query.java
similarity index 63%
rename from DaoCore/src/de/greenrobot/dao/query/Query.java
rename to DaoCore/src/main/java/de/greenrobot/dao/query/Query.java
index 4d36b1b0..301712f5 100644
--- a/DaoCore/src/de/greenrobot/dao/query/Query.java
+++ b/DaoCore/src/main/java/de/greenrobot/dao/query/Query.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ * Copyright (C) 2011-2015 Markus Junginger, greenrobot (http://greenrobot.de)
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -15,32 +15,26 @@
  */
 package de.greenrobot.dao.query;
 
-import java.util.List;
-
 import android.database.Cursor;
-import android.os.Process;
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.DaoException;
 
+import java.util.Date;
+import java.util.List;
+
 /**
  * A repeatable query returning entities.
- * 
+ *
+ * @param <T> The entity class the query will return results for.
  * @author Markus
- * 
- * @param <T>
- *            The enitity class the query will return results for.
  */
-// TODO support long, double and other types, not just Strings, for parameters
-// TODO Make parameters setable by Property (if unique in paramaters)
-// TODO Query for PKs/ROW IDs
-// TODO Make query compilable
-public class Query<T> extends AbstractQuery<T> {
+public class Query<T> extends AbstractQueryWithLimit<T> {
     private final static class QueryData<T2> extends AbstractQueryData<T2, Query<T2>> {
         private final int limitPosition;
         private final int offsetPosition;
 
         QueryData(AbstractDao<T2, ?> dao, String sql, String[] initialValues, int limitPosition, int offsetPosition) {
-            super(dao,sql,initialValues);
+            super(dao, sql, initialValues);
             this.limitPosition = limitPosition;
             this.offsetPosition = offsetPosition;
         }
@@ -58,62 +52,24 @@
     }
 
     static <T2> Query<T2> create(AbstractDao<T2, ?> dao, String sql, Object[] initialValues, int limitPosition,
-            int offsetPosition) {
+                                 int offsetPosition) {
         QueryData<T2> queryData = new QueryData<T2>(dao, sql, toStringArray(initialValues), limitPosition,
                 offsetPosition);
         return queryData.forCurrentThread();
     }
 
-    private final int limitPosition;
-    private final int offsetPosition;
     private final QueryData<T> queryData;
 
     private Query(QueryData<T> queryData, AbstractDao<T, ?> dao, String sql, String[] initialValues, int limitPosition,
-            int offsetPosition) {
-        super(dao, sql, initialValues);
+                  int offsetPosition) {
+        super(dao, sql, initialValues, limitPosition, offsetPosition);
         this.queryData = queryData;
-        this.limitPosition = limitPosition;
-        this.offsetPosition = offsetPosition;
     }
 
     public Query<T> forCurrentThread() {
         return queryData.forCurrentThread(this);
     }
 
-    /**
-     * Sets the parameter (0 based) using the position in which it was added during building the query.
-     */
-    public void setParameter(int index, Object parameter) {
-        if (index >= 0 && (index == limitPosition || index == offsetPosition)) {
-            throw new IllegalArgumentException("Illegal parameter index: " + index);
-        }
-        super.setParameter(index, parameter);
-    }
-
-    /**
-     * Sets the limit of the maximum number of results returned by this Query. {@link QueryBuilder#limit(int)} must have
-     * been called on the QueryBuilder that created this Query object.
-     */
-    public void setLimit(int limit) {
-        checkThread();
-        if (limitPosition == -1) {
-            throw new IllegalStateException("Limit must be set with QueryBuilder before it can be used here");
-        }
-        parameters[limitPosition] = Integer.toString(limit);
-    }
-
-    /**
-     * Sets the offset for results returned by this Query. {@link QueryBuilder#offset(int)} must have been called on the
-     * QueryBuilder that created this Query object.
-     */
-    public void setOffset(int offset) {
-        checkThread();
-        if (offsetPosition == -1) {
-            throw new IllegalStateException("Offset must be set with QueryBuilder before it can be used here");
-        }
-        parameters[offsetPosition] = Integer.toString(offset);
-    }
-
     /** Executes the query and returns the result as a list containing all entities loaded into memory. */
     public List<T> list() {
         checkThread();
@@ -133,8 +89,8 @@ public void setOffset(int offset) {
     }
 
     /**
-     * Executes the query and returns the result as a list that lazy loads the entities on every access (uncached). Make
-     * sure to close the list to close the underlying cursor.
+     * Executes the query and returns the result as a list that lazy loads the entities on every access (uncached).
+     * Make sure to close the list to close the underlying cursor.
      */
     public LazyList<T> listLazyUncached() {
         checkThread();
@@ -152,10 +108,9 @@ public void setOffset(int offset) {
 
     /**
      * Executes the query and returns the unique result or null.
-     * 
-     * @throws DaoException
-     *             if the result is not unique
+     *
      * @return Entity or null if no matching entity was found
+     * @throws DaoException if the result is not unique
      */
     public T unique() {
         checkThread();
@@ -165,10 +120,9 @@ public T unique() {
 
     /**
      * Executes the query and returns the unique result (never null).
-     * 
-     * @throws DaoException
-     *             if the result is not unique or no entity was found
+     *
      * @return Entity
+     * @throws DaoException if the result is not unique or no entity was found
      */
     public T uniqueOrThrow() {
         T entity = unique();
@@ -178,4 +132,18 @@ public T uniqueOrThrow() {
         return entity;
     }
 
+    @Override
+    public Query<T> setParameter(int index, Object parameter) {
+        return (Query<T>) super.setParameter(index, parameter);
+    }
+
+    @Override
+    public Query<T> setParameter(int index, Date parameter) {
+        return (Query<T>) super.setParameter(index, parameter);
+    }
+
+    @Override
+    public Query<T> setParameter(int index, Boolean parameter) {
+        return (Query<T>) super.setParameter(index, parameter);
+    }
 }
diff --git a/DaoCore/src/de/greenrobot/dao/query/QueryBuilder.java b/DaoCore/src/main/java/de/greenrobot/dao/query/QueryBuilder.java
similarity index 64%
rename from DaoCore/src/de/greenrobot/dao/query/QueryBuilder.java
rename to DaoCore/src/main/java/de/greenrobot/dao/query/QueryBuilder.java
index fdd58004..2e621838 100644
--- a/DaoCore/src/de/greenrobot/dao/query/QueryBuilder.java
+++ b/DaoCore/src/main/java/de/greenrobot/dao/query/QueryBuilder.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2013 Markus Junginger, greenrobot (http://greenrobot.de)
+ * Copyright (C) 2011-2015 Markus Junginger, greenrobot (http://greenrobot.de)
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -15,18 +15,15 @@
  */
 package de.greenrobot.dao.query;
 
-import java.util.ArrayList;
-import java.util.List;
-import java.util.ListIterator;
-
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.AbstractDaoSession;
 import de.greenrobot.dao.DaoException;
 import de.greenrobot.dao.DaoLog;
-import de.greenrobot.dao.InternalQueryDaoAccess;
 import de.greenrobot.dao.Property;
 import de.greenrobot.dao.internal.SqlUtils;
-import de.greenrobot.dao.query.WhereCondition.PropertyCondition;
+
+import java.util.ArrayList;
+import java.util.List;
 
 /**
  * Builds custom entity queries using constraints and parameters and without SQL (QueryBuilder creates SQL for you). To
@@ -37,13 +34,11 @@
  * Example: Query for all users with the first name "Joe" ordered by their last name. (The class Properties is an inner
  * class of UserDao and should be imported before.)<br/>
  * <code>
- *  List<User> joes = dao.queryBuilder().where(Properties.FirstName.eq("Joe")).orderAsc(Properties.LastName).list();
- *  </code>
- * 
+ * List<User> joes = dao.queryBuilder().where(Properties.FirstName.eq("Joe")).orderAsc(Properties.LastName).list();
+ * </code>
+ *
+ * @param <T> Entity class to create an query for.
  * @author Markus
- * 
- * @param <T>
- *            Entity class to create an query for.
  */
 public class QueryBuilder<T> {
 
@@ -52,19 +47,18 @@
 
     /** Set to see the given values. */
     public static boolean LOG_VALUES;
+    private final WhereCollector<T> whereCollector;
 
     private StringBuilder orderBuilder;
-    private StringBuilder joinBuilder;
-
-    private final List<WhereCondition> whereConditions;
 
     private final List<Object> values;
+    private final List<Join<T, ?>> joins;
     private final AbstractDao<T, ?> dao;
     private final String tablePrefix;
 
     private Integer limit;
-
     private Integer offset;
+    private boolean distinct;
 
     /** For internal use by greenDAO only. */
     public static <T2> QueryBuilder<T2> internalCreate(AbstractDao<T2, ?> dao) {
@@ -79,7 +73,8 @@ protected QueryBuilder(AbstractDao<T, ?> dao, String tablePrefix) {
         this.dao = dao;
         this.tablePrefix = tablePrefix;
         values = new ArrayList<Object>();
-        whereConditions = new ArrayList<WhereCondition>();
+        joins = new ArrayList<Join<T, ?>>();
+        whereCollector = new WhereCollector<T>(dao, tablePrefix);
     }
 
     private void checkOrderBuilder() {
@@ -90,16 +85,18 @@ private void checkOrderBuilder() {
         }
     }
 
+    /** Use a SELECT DISTINCT to avoid duplicate entities returned, e.g. when doing joins. */
+    public QueryBuilder<T> distinct() {
+        distinct = true;
+        return this;
+    }
+
     /**
      * Adds the given conditions to the where clause using an logical AND. To create new conditions, use the properties
      * given in the generated dao classes.
      */
     public QueryBuilder<T> where(WhereCondition cond, WhereCondition... condMore) {
-        whereConditions.add(cond);
-        for (WhereCondition whereCondition : condMore) {
-            checkCondition(whereCondition);
-            whereConditions.add(whereCondition);
-        }
+        whereCollector.add(cond, condMore);
         return this;
     }
 
@@ -108,7 +105,7 @@ private void checkOrderBuilder() {
      * given in the generated dao classes.
      */
     public QueryBuilder<T> whereOr(WhereCondition cond1, WhereCondition cond2, WhereCondition... condMore) {
-        whereConditions.add(or(cond1, cond2, condMore));
+        whereCollector.add(or(cond1, cond2, condMore));
         return this;
     }
 
@@ -118,7 +115,7 @@ private void checkOrderBuilder() {
      * {@link #whereOr(WhereCondition, WhereCondition, WhereCondition...)}.
      */
     public WhereCondition or(WhereCondition cond1, WhereCondition cond2, WhereCondition... condMore) {
-        return combineWhereConditions(" OR ", cond1, cond2, condMore);
+        return whereCollector.combineWhereConditions(" OR ", cond1, cond2, condMore);
     }
 
     /**
@@ -127,50 +124,55 @@ public WhereCondition or(WhereCondition cond1, WhereCondition cond2, WhereCondit
      * {@link #whereOr(WhereCondition, WhereCondition, WhereCondition...)}.
      */
     public WhereCondition and(WhereCondition cond1, WhereCondition cond2, WhereCondition... condMore) {
-        return combineWhereConditions(" AND ", cond1, cond2, condMore);
+        return whereCollector.combineWhereConditions(" AND ", cond1, cond2, condMore);
     }
 
-    protected WhereCondition combineWhereConditions(String combineOp, WhereCondition cond1, WhereCondition cond2,
-            WhereCondition... condMore) {
-        StringBuilder builder = new StringBuilder("(");
-        List<Object> combinedValues = new ArrayList<Object>();
-
-        addCondition(builder, combinedValues, cond1);
-        builder.append(combineOp);
-        addCondition(builder, combinedValues, cond2);
-
-        for (WhereCondition cond : condMore) {
-            builder.append(combineOp);
-            addCondition(builder, combinedValues, cond);
-        }
-        builder.append(')');
-        return new WhereCondition.StringCondition(builder.toString(), combinedValues.toArray());
+    /**
+     * Expands the query to another entity type by using a JOIN. The primary key property of the primary entity for
+     * this QueryBuilder is used to match the given destinationProperty.
+     */
+    public <J> Join<T, J> join(Class<J> destinationEntityClass, Property destinationProperty) {
+        return join(dao.getPkProperty(), destinationEntityClass, destinationProperty);
     }
 
-    protected void addCondition(StringBuilder builder, List<Object> values, WhereCondition condition) {
-        checkCondition(condition);
-        condition.appendTo(builder, tablePrefix);
-        condition.appendValuesTo(values);
+    /**
+     * Expands the query to another entity type by using a JOIN. The given sourceProperty is used to match the primary
+     * key property of the given destinationEntity.
+     */
+    public <J> Join<T, J> join(Property sourceProperty, Class<J> destinationEntityClass) {
+        AbstractDao<J, ?> destinationDao = (AbstractDao<J, ?>) dao.getSession().getDao(destinationEntityClass);
+        Property destinationProperty = destinationDao.getPkProperty();
+        return addJoin(tablePrefix, sourceProperty, destinationDao, destinationProperty);
     }
 
-    protected void checkCondition(WhereCondition whereCondition) {
-        if (whereCondition instanceof PropertyCondition) {
-            checkProperty(((PropertyCondition) whereCondition).property);
-        }
+    /**
+     * Expands the query to another entity type by using a JOIN. The given sourceProperty is used to match the given
+     * destinationProperty of the given destinationEntity.
+     */
+    public <J> Join<T, J> join(Property sourceProperty, Class<J> destinationEntityClass, Property destinationProperty) {
+        AbstractDao<J, ?> destinationDao = (AbstractDao<J, ?>) dao.getSession().getDao(destinationEntityClass);
+        return addJoin(tablePrefix, sourceProperty, destinationDao, destinationProperty);
     }
 
-    /** Not supported yet. */
-    public <J> QueryBuilder<J> join(Class<J> entityClass, Property toOneProperty) {
-        throw new UnsupportedOperationException();
-        // return new QueryBuilder<J>();
+    /**
+     * Expands the query to another entity type by using a JOIN. The given sourceJoin's property is used to match the
+     * given destinationProperty of the given destinationEntity. Note that destination entity of the given join is used
+     * as the source for the new join to add. In this way, it is possible to compose complex "join of joins" across
+     * several entities if required.
+     */
+    public <J> Join<T, J> join(Join<?, T> sourceJoin, Property sourceProperty, Class<J> destinationEntityClass,
+                               Property destinationProperty) {
+        AbstractDao<J, ?> destinationDao = (AbstractDao<J, ?>) dao.getSession().getDao(destinationEntityClass);
+        return addJoin(sourceJoin.tablePrefix, sourceProperty, destinationDao, destinationProperty);
     }
 
-    /** Not supported yet. */
-    public <J> QueryBuilder<J> joinToMany(Class<J> entityClass, Property toManyProperty) {
-        throw new UnsupportedOperationException();
-        // @SuppressWarnings("unchecked")
-        // AbstractDao<J, ?> joinDao = (AbstractDao<J, ?>) dao.getSession().getDao(entityClass);
-        // return new QueryBuilder<J>(joinDao, "TX");
+    private <J> Join<T, J> addJoin(String sourceTablePrefix, Property sourceProperty, AbstractDao<J, ?> destinationDao,
+                                   Property destinationProperty) {
+        String joinTablePrefix = "J" + (joins.size() + 1);
+        Join<T, J> join = new Join<T, J>(sourceTablePrefix, sourceProperty, destinationDao, destinationProperty,
+                joinTablePrefix);
+        joins.add(join);
+        return join;
     }
 
     /** Adds the given properties to the ORDER BY section using ascending order. */
@@ -205,8 +207,8 @@ private void orderAscOrDesc(String ascOrDescWithLeadingSpace, Property... proper
     }
 
     /**
-     * Adds the given raw SQL string to the ORDER BY section. Do not use this for standard properties: ordedAsc and
-     * orderDesc are prefered.
+     * Adds the given raw SQL string to the ORDER BY section. Do not use this for standard properties: orderAsc and
+     * orderDesc are preferred.
      */
     public QueryBuilder<T> orderRaw(String rawOrder) {
         checkOrderBuilder();
@@ -215,26 +217,11 @@ private void orderAscOrDesc(String ascOrDescWithLeadingSpace, Property... proper
     }
 
     protected StringBuilder append(StringBuilder builder, Property property) {
-        checkProperty(property);
+        whereCollector.checkProperty(property);
         builder.append(tablePrefix).append('.').append('\'').append(property.columnName).append('\'');
         return builder;
     }
 
-    protected void checkProperty(Property property) {
-        if (dao != null) {
-            Property[] properties = dao.getProperties();
-            boolean found = false;
-            for (Property property2 : properties) {
-                if (property == property2) {
-                    found = true;
-                    break;
-                }
-            }
-            if (!found) {
-                throw new DaoException("Property '" + property.name + "' is not part of " + dao);
-            }
-        }
-    }
 
     /** Limits the number of results returned by queries. */
     public QueryBuilder<T> limit(int limit) {
@@ -256,27 +243,54 @@ protected void checkProperty(Property property) {
      * each execution.
      */
     public Query<T> build() {
-        String select;
-        if (joinBuilder == null || joinBuilder.length() == 0) {
-            select = InternalQueryDaoAccess.getStatements(dao).getSelectAll();
-        } else {
-            select = SqlUtils.createSqlSelect(dao.getTablename(), tablePrefix, dao.getAllColumns());
-        }
+        StringBuilder builder = createSelectBuilder();
+        int limitPosition = checkAddLimit(builder);
+        int offsetPosition = checkAddOffset(builder);
+
+        String sql = builder.toString();
+        checkLog(sql);
+
+        return Query.create(dao, sql, values.toArray(), limitPosition, offsetPosition);
+    }
+
+    /**
+     * Builds a reusable query object for low level android.database.Cursor access.
+     * (Query objects can be executed more efficiently than creating a QueryBuilder for each execution.
+     */
+    public CursorQuery buildCursor() {
+        StringBuilder builder = createSelectBuilder();
+        int limitPosition = checkAddLimit(builder);
+        int offsetPosition = checkAddOffset(builder);
+
+        String sql = builder.toString();
+        checkLog(sql);
+
+        return CursorQuery.create(dao, sql, values.toArray(), limitPosition, offsetPosition);
+    }
+
+    private StringBuilder createSelectBuilder() {
+        String select = SqlUtils.createSqlSelect(dao.getTablename(), tablePrefix, dao.getAllColumns(), distinct);
         StringBuilder builder = new StringBuilder(select);
 
-        appendWhereClause(builder, tablePrefix);
+        appendJoinsAndWheres(builder, tablePrefix);
 
         if (orderBuilder != null && orderBuilder.length() > 0) {
             builder.append(" ORDER BY ").append(orderBuilder);
         }
+        return builder;
+    }
 
+    private int checkAddLimit(StringBuilder builder) {
         int limitPosition = -1;
         if (limit != null) {
             builder.append(" LIMIT ?");
             values.add(limit);
             limitPosition = values.size() - 1;
         }
+        return limitPosition;
+    }
 
+    private int checkAddOffset(StringBuilder builder) {
         int offsetPosition = -1;
         if (offset != null) {
             if (limit == null) {
@@ -286,17 +300,7 @@ protected void checkProperty(Property property) {
             values.add(offset);
             offsetPosition = values.size() - 1;
         }
-
-        String sql = builder.toString();
-        if (LOG_SQL) {
-            DaoLog.d("Built SQL for query: " + sql);
-        }
-
-        if (LOG_VALUES) {
-            DaoLog.d("Values for query: " + values);
-        }
-
-        return Query.create(dao, sql, values.toArray(), limitPosition, offsetPosition);
+        return offsetPosition;
     }
 
     /**
@@ -304,26 +308,22 @@ protected void checkProperty(Property property) {
      * QueryBuilder for each execution.
      */
     public DeleteQuery<T> buildDelete() {
+        if (!joins.isEmpty()) {
+            throw new DaoException("JOINs are not supported for DELETE queries");
+        }
         String tablename = dao.getTablename();
         String baseSql = SqlUtils.createSqlDelete(tablename, null);
         StringBuilder builder = new StringBuilder(baseSql);
 
         // tablePrefix gets replaced by table name below. Don't use tableName here because it causes trouble when
         // table name ends with tablePrefix.
-        appendWhereClause(builder, tablePrefix);
+        appendJoinsAndWheres(builder, tablePrefix);
 
         String sql = builder.toString();
-
         // Remove table aliases, not supported for DELETE queries.
         // TODO(?): don't create table aliases in the first place.
-        sql = sql.replace(tablePrefix + ".'", tablename + ".'");
-
-        if (LOG_SQL) {
-            DaoLog.d("Built SQL for delete query: " + sql);
-        }
-        if (LOG_VALUES) {
-            DaoLog.d("Values for delete query: " + values);
-        }
+        sql = sql.replace(tablePrefix + ".\"", '"' + tablename + "\".\"");
+        checkLog(sql);
 
         return DeleteQuery.create(dao, sql, values.toArray());
     }
@@ -336,31 +336,45 @@ protected void checkProperty(Property property) {
         String tablename = dao.getTablename();
         String baseSql = SqlUtils.createSqlSelectCountStar(tablename, tablePrefix);
         StringBuilder builder = new StringBuilder(baseSql);
-        appendWhereClause(builder, tablePrefix);
+        appendJoinsAndWheres(builder, tablePrefix);
+
         String sql = builder.toString();
+        checkLog(sql);
 
+        return CountQuery.create(dao, sql, values.toArray());
+    }
+
+    private void checkLog(String sql) {
         if (LOG_SQL) {
-            DaoLog.d("Built SQL for count query: " + sql);
+            DaoLog.d("Built SQL for query: " + sql);
         }
         if (LOG_VALUES) {
-            DaoLog.d("Values for count query: " + values);
+            DaoLog.d("Values for query: " + values);
         }
-
-        return CountQuery.create(dao, sql, values.toArray());
     }
 
-    private void appendWhereClause(StringBuilder builder, String tablePrefixOrNull) {
+    private void appendJoinsAndWheres(StringBuilder builder, String tablePrefixOrNull) {
         values.clear();
-        if (!whereConditions.isEmpty()) {
+        for (Join<T, ?> join : joins) {
+            builder.append(" JOIN ").append(join.daoDestination.getTablename()).append(' ');
+            builder.append(join.tablePrefix).append(" ON ");
+            SqlUtils.appendProperty(builder, join.sourceTablePrefix, join.joinPropertySource).append('=');
+            SqlUtils.appendProperty(builder, join.tablePrefix, join.joinPropertyDestination);
+        }
+        boolean whereAppended = !whereCollector.isEmpty();
+        if (whereAppended) {
             builder.append(" WHERE ");
-            ListIterator<WhereCondition> iter = whereConditions.listIterator();
-            while (iter.hasNext()) {
-                if (iter.hasPrevious()) {
+            whereCollector.appendWhereClause(builder, tablePrefixOrNull, values);
+        }
+        for (Join<T, ?> join : joins) {
+            if (!join.whereCollector.isEmpty()) {
+                if (!whereAppended) {
+                    builder.append(" WHERE ");
+                    whereAppended = true;
+                } else {
                     builder.append(" AND ");
                 }
-                WhereCondition condition = iter.next();
-                condition.appendTo(builder, tablePrefixOrNull);
-                condition.appendValuesTo(values);
+                join.whereCollector.appendWhereClause(builder, join.tablePrefix, values);
             }
         }
     }
@@ -412,7 +426,8 @@ public T unique() {
 
     /**
      * Shorthand for {@link QueryBuilder#build() build()}.{@link Query#uniqueOrThrow() uniqueOrThrow()}; see
-     * {@link Query#uniqueOrThrow()} for details. To execute a query more than once, you should build the query and keep
+     * {@link Query#uniqueOrThrow()} for details. To execute a query more than once, you should build the query and
+     * keep
      * the {@link Query} object for efficiency reasons.
      */
     public T uniqueOrThrow() {
diff --git a/DaoCore/src/main/java/de/greenrobot/dao/query/WhereCollector.java b/DaoCore/src/main/java/de/greenrobot/dao/query/WhereCollector.java
new file mode 100644
index 00000000..21022d5e
--- /dev/null
+++ b/DaoCore/src/main/java/de/greenrobot/dao/query/WhereCollector.java
@@ -0,0 +1,108 @@
+/*
+ * Copyright (C) 2011-2015 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.dao.query;
+
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.DaoException;
+import de.greenrobot.dao.Property;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.ListIterator;
+
+/** Internal class to collect WHERE conditions. */
+class WhereCollector<T> {
+
+    private final AbstractDao<T, ?> dao;
+    private final List<WhereCondition> whereConditions;
+    private final String tablePrefix;
+
+    WhereCollector(AbstractDao<T, ?> dao, String tablePrefix) {
+        this.dao = dao;
+        this.tablePrefix = tablePrefix;
+        whereConditions = new ArrayList<WhereCondition>();
+    }
+
+    void add(WhereCondition cond, WhereCondition... condMore) {
+        checkCondition(cond);
+        whereConditions.add(cond);
+        for (WhereCondition whereCondition : condMore) {
+            checkCondition(whereCondition);
+            whereConditions.add(whereCondition);
+        }
+    }
+
+    WhereCondition combineWhereConditions(String combineOp, WhereCondition cond1, WhereCondition cond2,
+                                          WhereCondition... condMore) {
+        StringBuilder builder = new StringBuilder("(");
+        List<Object> combinedValues = new ArrayList<Object>();
+
+        addCondition(builder, combinedValues, cond1);
+        builder.append(combineOp);
+        addCondition(builder, combinedValues, cond2);
+
+        for (WhereCondition cond : condMore) {
+            builder.append(combineOp);
+            addCondition(builder, combinedValues, cond);
+        }
+        builder.append(')');
+        return new WhereCondition.StringCondition(builder.toString(), combinedValues.toArray());
+    }
+
+    void addCondition(StringBuilder builder, List<Object> values, WhereCondition condition) {
+        checkCondition(condition);
+        condition.appendTo(builder, tablePrefix);
+        condition.appendValuesTo(values);
+    }
+
+    void checkCondition(WhereCondition whereCondition) {
+        if (whereCondition instanceof WhereCondition.PropertyCondition) {
+            checkProperty(((WhereCondition.PropertyCondition) whereCondition).property);
+        }
+    }
+
+    void checkProperty(Property property) {
+        if (dao != null) {
+            Property[] properties = dao.getProperties();
+            boolean found = false;
+            for (Property property2 : properties) {
+                if (property == property2) {
+                    found = true;
+                    break;
+                }
+            }
+            if (!found) {
+                throw new DaoException("Property '" + property.name + "' is not part of " + dao);
+            }
+        }
+    }
+
+    void appendWhereClause(StringBuilder builder, String tablePrefixOrNull, List<Object> values) {
+        ListIterator<WhereCondition> iter = whereConditions.listIterator();
+        while (iter.hasNext()) {
+            if (iter.hasPrevious()) {
+                builder.append(" AND ");
+            }
+            WhereCondition condition = iter.next();
+            condition.appendTo(builder, tablePrefixOrNull);
+            condition.appendValuesTo(values);
+        }
+    }
+
+    boolean isEmpty() {
+        return whereConditions.isEmpty();
+    }
+}
diff --git a/DaoCore/src/de/greenrobot/dao/query/WhereCondition.java b/DaoCore/src/main/java/de/greenrobot/dao/query/WhereCondition.java
similarity index 93%
rename from DaoCore/src/de/greenrobot/dao/query/WhereCondition.java
rename to DaoCore/src/main/java/de/greenrobot/dao/query/WhereCondition.java
index 2a8b626a..49f17a73 100644
--- a/DaoCore/src/de/greenrobot/dao/query/WhereCondition.java
+++ b/DaoCore/src/main/java/de/greenrobot/dao/query/WhereCondition.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ * Copyright (C) 2011-2015 Markus Junginger, greenrobot (http://greenrobot.de)
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -20,6 +20,7 @@
 
 import de.greenrobot.dao.DaoException;
 import de.greenrobot.dao.Property;
+import de.greenrobot.dao.internal.SqlUtils;
 
 /**
  * Internal interface to model WHERE conditions used in queries. Use the {@link Property} objects in the DAO classes to
@@ -59,8 +60,7 @@ public AbstractCondition(Object[] values) {
         public void appendValuesTo(List<Object> valuesTarget) {
             if (hasSingleValue) {
                 valuesTarget.add(value);
-            }
-            if (values != null) {
+            } else if (values != null) {
                 for (Object value : values) {
                     valuesTarget.add(value);
                 }
@@ -99,7 +99,7 @@ private static Object checkValueForType(Property property, Object value) {
                         return 0;
                     } else {
                         throw new DaoException(
-                                "Illegal boolean value: Strings must be \"TRUE\" or \"FALSE\" (case insesnsitive), but was "
+                                "Illegal boolean value: Strings must be \"TRUE\" or \"FALSE\" (case insensitive), but was "
                                         + value);
                     }
                 }
@@ -136,10 +136,7 @@ public PropertyCondition(Property property, String op, Object[] values) {
 
         @Override
         public void appendTo(StringBuilder builder, String tableAlias) {
-            if (tableAlias != null) {
-                builder.append(tableAlias).append('.');
-            }
-            builder.append('\'').append(property.columnName).append('\'').append(op);
+            SqlUtils.appendProperty(builder, tableAlias, property).append(op);
         }
     }
 
diff --git a/DaoCore/src/de/greenrobot/dao/test/AbstractDaoSessionTest.java b/DaoCore/src/main/java/de/greenrobot/dao/test/AbstractDaoSessionTest.java
similarity index 97%
rename from DaoCore/src/de/greenrobot/dao/test/AbstractDaoSessionTest.java
rename to DaoCore/src/main/java/de/greenrobot/dao/test/AbstractDaoSessionTest.java
index aa94a156..08bc0ff9 100644
--- a/DaoCore/src/de/greenrobot/dao/test/AbstractDaoSessionTest.java
+++ b/DaoCore/src/main/java/de/greenrobot/dao/test/AbstractDaoSessionTest.java
@@ -1,66 +1,66 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package de.greenrobot.dao.test;
-
-import java.lang.reflect.Constructor;
-import java.lang.reflect.Method;
-
-import android.database.sqlite.SQLiteDatabase;
-import de.greenrobot.dao.AbstractDaoMaster;
-import de.greenrobot.dao.AbstractDaoSession;
-
-/**
- * Base class for DAO (master) related testing.
- * 
- * @author Markus
- * 
- * @param <T>
- *            Type of a concrete DAO master
- */
-public abstract class AbstractDaoSessionTest<T extends AbstractDaoMaster, S extends AbstractDaoSession>
-        extends DbTest {
-
-    private final Class<T> daoMasterClass;
-    protected T daoMaster;
-    protected S daoSession;
-
-    public AbstractDaoSessionTest(Class<T> daoMasterClass) {
-        this(daoMasterClass, true);
-    }
-
-    public AbstractDaoSessionTest(Class<T> daoMasterClass, boolean inMemory) {
-        super(inMemory);
-        this.daoMasterClass = daoMasterClass;
-    }
-
-	@SuppressWarnings("unchecked")
-    @Override
-    protected void setUp() throws Exception {
-        super.setUp();
-        try {
-            Constructor<T> constructor = daoMasterClass.getConstructor(SQLiteDatabase.class);
-            daoMaster = constructor.newInstance(db);
-
-            Method createTableMethod = daoMasterClass.getMethod("createAllTables", SQLiteDatabase.class, boolean.class);
-            createTableMethod.invoke(null, db, false);
-        } catch (Exception e) {
-            throw new RuntimeException("Could not prepare DAO session test", e);
-        }
-        daoSession = (S) daoMaster.newSession();
-    }
-
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package de.greenrobot.dao.test;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Method;
+
+import android.database.sqlite.SQLiteDatabase;
+import de.greenrobot.dao.AbstractDaoMaster;
+import de.greenrobot.dao.AbstractDaoSession;
+
+/**
+ * Base class for DAO (master) related testing.
+ * 
+ * @author Markus
+ * 
+ * @param <T>
+ *            Type of a concrete DAO master
+ */
+public abstract class AbstractDaoSessionTest<T extends AbstractDaoMaster, S extends AbstractDaoSession>
+        extends DbTest {
+
+    private final Class<T> daoMasterClass;
+    protected T daoMaster;
+    protected S daoSession;
+
+    public AbstractDaoSessionTest(Class<T> daoMasterClass) {
+        this(daoMasterClass, true);
+    }
+
+    public AbstractDaoSessionTest(Class<T> daoMasterClass, boolean inMemory) {
+        super(inMemory);
+        this.daoMasterClass = daoMasterClass;
+    }
+
+	@SuppressWarnings("unchecked")
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        try {
+            Constructor<T> constructor = daoMasterClass.getConstructor(SQLiteDatabase.class);
+            daoMaster = constructor.newInstance(db);
+
+            Method createTableMethod = daoMasterClass.getMethod("createAllTables", SQLiteDatabase.class, boolean.class);
+            createTableMethod.invoke(null, db, false);
+        } catch (Exception e) {
+            throw new RuntimeException("Could not prepare DAO session test", e);
+        }
+        daoSession = (S) daoMaster.newSession();
+    }
+
 }
\ No newline at end of file
diff --git a/DaoCore/src/de/greenrobot/dao/test/AbstractDaoTest.java b/DaoCore/src/main/java/de/greenrobot/dao/test/AbstractDaoTest.java
similarity index 100%
rename from DaoCore/src/de/greenrobot/dao/test/AbstractDaoTest.java
rename to DaoCore/src/main/java/de/greenrobot/dao/test/AbstractDaoTest.java
diff --git a/DaoCore/src/de/greenrobot/dao/test/AbstractDaoTestLongPk.java b/DaoCore/src/main/java/de/greenrobot/dao/test/AbstractDaoTestLongPk.java
similarity index 100%
rename from DaoCore/src/de/greenrobot/dao/test/AbstractDaoTestLongPk.java
rename to DaoCore/src/main/java/de/greenrobot/dao/test/AbstractDaoTestLongPk.java
diff --git a/DaoCore/src/de/greenrobot/dao/test/AbstractDaoTestSinglePk.java b/DaoCore/src/main/java/de/greenrobot/dao/test/AbstractDaoTestSinglePk.java
similarity index 99%
rename from DaoCore/src/de/greenrobot/dao/test/AbstractDaoTestSinglePk.java
rename to DaoCore/src/main/java/de/greenrobot/dao/test/AbstractDaoTestSinglePk.java
index f1d05b43..efdcae2b 100644
--- a/DaoCore/src/de/greenrobot/dao/test/AbstractDaoTestSinglePk.java
+++ b/DaoCore/src/main/java/de/greenrobot/dao/test/AbstractDaoTestSinglePk.java
@@ -278,7 +278,7 @@ protected Cursor queryWithDummyColumnsInFront(int dummyCount, String valueForCol
             builder.append(valueForColumn).append(",");
         }
         SqlUtils.appendColumns(builder, "T", dao.getAllColumns()).append(" FROM ");
-        builder.append(dao.getTablename()).append(" T");
+        builder.append('"').append(dao.getTablename()).append('"').append(" T");
         if (pk != null) {
             builder.append(" WHERE ");
 
diff --git a/DaoCore/src/de/greenrobot/dao/test/AbstractDaoTestStringPk.java b/DaoCore/src/main/java/de/greenrobot/dao/test/AbstractDaoTestStringPk.java
similarity index 96%
rename from DaoCore/src/de/greenrobot/dao/test/AbstractDaoTestStringPk.java
rename to DaoCore/src/main/java/de/greenrobot/dao/test/AbstractDaoTestStringPk.java
index e0c6ddff..f97b979c 100644
--- a/DaoCore/src/de/greenrobot/dao/test/AbstractDaoTestStringPk.java
+++ b/DaoCore/src/main/java/de/greenrobot/dao/test/AbstractDaoTestStringPk.java
@@ -1,48 +1,48 @@
-/*
- * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package de.greenrobot.dao.test;
-
-import de.greenrobot.dao.AbstractDao;
-
-/**
- * Base class for DAOs having a String as a PK.
- * 
- * @author Markus
- * 
- * @param <D>
- *            DAO class
- * @param <T>
- *            Entity type of the DAO
- */
-public abstract class AbstractDaoTestStringPk<D extends AbstractDao<T, String>, T> extends
-        AbstractDaoTestSinglePk<D, T, String> {
-
-    public AbstractDaoTestStringPk(Class<D> daoClass) {
-        super(daoClass);
-    }
-
-    @Override
-    protected String createRandomPk() {
-        int len = 1 + random.nextInt(30);
-        StringBuilder builder = new StringBuilder();
-        for (int i = 0; i < len; i++) {
-            char c = (char) ('a' + random.nextInt('z' - 'a'));
-            builder.append(c);
-        }
-        return builder.toString();
-    }
-
-}
+/*
+ * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.dao.test;
+
+import de.greenrobot.dao.AbstractDao;
+
+/**
+ * Base class for DAOs having a String as a PK.
+ * 
+ * @author Markus
+ * 
+ * @param <D>
+ *            DAO class
+ * @param <T>
+ *            Entity type of the DAO
+ */
+public abstract class AbstractDaoTestStringPk<D extends AbstractDao<T, String>, T> extends
+        AbstractDaoTestSinglePk<D, T, String> {
+
+    public AbstractDaoTestStringPk(Class<D> daoClass) {
+        super(daoClass);
+    }
+
+    @Override
+    protected String createRandomPk() {
+        int len = 1 + random.nextInt(30);
+        StringBuilder builder = new StringBuilder();
+        for (int i = 0; i < len; i++) {
+            char c = (char) ('a' + random.nextInt('z' - 'a'));
+            builder.append(c);
+        }
+        return builder.toString();
+    }
+
+}
diff --git a/DaoCore/src/de/greenrobot/dao/test/DbTest.java b/DaoCore/src/main/java/de/greenrobot/dao/test/DbTest.java
similarity index 100%
rename from DaoCore/src/de/greenrobot/dao/test/DbTest.java
rename to DaoCore/src/main/java/de/greenrobot/dao/test/DbTest.java
diff --git a/DaoExample/.classpath b/DaoExample/.classpath
deleted file mode 100644
index 6a988e59..00000000
--- a/DaoExample/.classpath
+++ /dev/null
@@ -1,11 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="src" path="gen"/>
-	<classpathentry kind="src" path="src-gen"/>
-	<classpathentry kind="src" path="src-test"/>
-	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
-	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
-	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
-	<classpathentry kind="output" path="bin/classes"/>
-</classpath>
diff --git a/DaoExample/.project b/DaoExample/.project
deleted file mode 100644
index 0d480710..00000000
--- a/DaoExample/.project
+++ /dev/null
@@ -1,33 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<projectDescription>
-	<name>DaoExample</name>
-	<comment></comment>
-	<projects>
-	</projects>
-	<buildSpec>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>org.eclipse.jdt.core.javabuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-	</buildSpec>
-	<natures>
-		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
-		<nature>org.eclipse.jdt.core.javanature</nature>
-	</natures>
-</projectDescription>
diff --git a/DaoExample/.settings/org.eclipse.core.resources.prefs b/DaoExample/.settings/org.eclipse.core.resources.prefs
deleted file mode 100644
index 3d916f29..00000000
--- a/DaoExample/.settings/org.eclipse.core.resources.prefs
+++ /dev/null
@@ -1,2 +0,0 @@
-eclipse.preferences.version=1
-encoding/<project>=Cp1252
diff --git a/DaoExample/.settings/org.eclipse.jdt.core.prefs b/DaoExample/.settings/org.eclipse.jdt.core.prefs
deleted file mode 100644
index e8465841..00000000
--- a/DaoExample/.settings/org.eclipse.jdt.core.prefs
+++ /dev/null
@@ -1,12 +0,0 @@
-#Sat Jan 28 16:28:37 CET 2012
-eclipse.preferences.version=1
-org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
-org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.6
-org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
-org.eclipse.jdt.core.compiler.compliance=1.6
-org.eclipse.jdt.core.compiler.debug.lineNumber=generate
-org.eclipse.jdt.core.compiler.debug.localVariable=generate
-org.eclipse.jdt.core.compiler.debug.sourceFile=generate
-org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
-org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
-org.eclipse.jdt.core.compiler.source=1.6
diff --git a/DaoExample/AndroidManifest.xml b/DaoExample/AndroidManifest.xml
deleted file mode 100644
index 28fb3a4f..00000000
--- a/DaoExample/AndroidManifest.xml
+++ /dev/null
@@ -1,18 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-      package="de.greenrobot.daoexample"
-      android:versionCode="1"
-      android:versionName="1.0">
-    <uses-sdk android:minSdkVersion="4" />
-
-    <instrumentation android:targetPackage="de.greenrobot.daoexample" android:name="android.test.InstrumentationTestRunner" />
-    <application android:icon="@drawable/icon" android:label="@string/app_name">
-        <activity android:name=".NoteActivity">
-            <intent-filter>
-                <action android:name="android.intent.action.MAIN" />
-                <category android:name="android.intent.category.LAUNCHER" />
-            </intent-filter>
-        </activity>
-        <uses-library android:name="android.test.runner" />
-    </application>
-</manifest>
\ No newline at end of file
diff --git a/DaoExample/build.gradle b/DaoExample/build.gradle
index 6bce52b3..aea03174 100644
--- a/DaoExample/build.gradle
+++ b/DaoExample/build.gradle
@@ -1,28 +1,40 @@
-// Just a dummy script building a useless jar file. Waiting for version 0.3 of Android's new build system. 
-apply plugin: 'java'
-apply plugin: 'maven'
+buildscript {
+    repositories {
+        mavenCentral()
+    }
+
+    dependencies {
+        classpath 'com.android.tools.build:gradle:1.3.1'
+    }
+}
 
-group = 'de.greenrobot'
-version = '1.3.0'
-sourceCompatibility = 1.6
+apply plugin: 'com.android.application'
 
 repositories {
     mavenCentral()
 }
 
-dependencies {
-    compile('de.greenrobot:greendao:1.3.0')
-}
+android {
+    buildToolsVersion rootProject.ext.buildToolsVersion
+    compileSdkVersion rootProject.ext.compileSdkVersion
 
-sourceSets {
-    main {
-        java {
-            srcDir 'src'
-            srcDir 'src-gen'
-            srcDir 'gen'
-        }
+    defaultConfig {
+        applicationId "de.greenrobot.daoexample"
+        minSdkVersion rootProject.ext.minSdkVersion
+        targetSdkVersion rootProject.ext.targetSdkVersion
+        versionCode 1
+        versionName "1.3.0"
+
+        testInstrumentationRunner "android.test.InstrumentationTestRunner"
+    }
+
+    compileOptions {
+        encoding = "UTF-8"
+        sourceCompatibility JavaVersion.VERSION_1_6
+        targetCompatibility JavaVersion.VERSION_1_6
     }
 }
-artifacts {
-    archives jar
-}
+
+dependencies {
+    compile('de.greenrobot:greendao:2.0.0')
+}
\ No newline at end of file
diff --git a/DaoExample/docs/greenDAO-javadoc.jar b/DaoExample/docs/greenDAO-javadoc.jar
deleted file mode 100644
index 51df4738..00000000
Binary files a/DaoExample/docs/greenDAO-javadoc.jar and /dev/null differ
diff --git a/DaoExample/libs/greendao-1.3.0-beta-1.jar b/DaoExample/libs/greendao-1.3.0-beta-1.jar
deleted file mode 100644
index 473993d4..00000000
Binary files a/DaoExample/libs/greendao-1.3.0-beta-1.jar and /dev/null differ
diff --git a/DaoExample/settings.gradle b/DaoExample/settings.gradle
deleted file mode 100644
index 96dff2be..00000000
--- a/DaoExample/settings.gradle
+++ /dev/null
@@ -1 +0,0 @@
-rootProject.name = 'greendao-example'
\ No newline at end of file
diff --git a/DaoExample/src-test/de/greenrobot/daoexample/CustomerOrderTest.java b/DaoExample/src/androidTest/Java/de/greenrobot/daoexample/CustomerOrderTest.java
similarity index 91%
rename from DaoExample/src-test/de/greenrobot/daoexample/CustomerOrderTest.java
rename to DaoExample/src/androidTest/Java/de/greenrobot/daoexample/CustomerOrderTest.java
index 0fc73a34..e24eca48 100644
--- a/DaoExample/src-test/de/greenrobot/daoexample/CustomerOrderTest.java
+++ b/DaoExample/src/androidTest/Java/de/greenrobot/daoexample/CustomerOrderTest.java
@@ -1,61 +1,61 @@
-package de.greenrobot.daoexample;
-
-import java.util.Date;
-import java.util.List;
-
-import android.app.Application;
-import de.greenrobot.dao.test.AbstractDaoSessionTest;
-
-public class CustomerOrderTest extends AbstractDaoSessionTest<Application, DaoMaster, DaoSession> {
-
-    public CustomerOrderTest() {
-        super(DaoMaster.class);
-    }
-
-    public void testCustomerToOrders() {
-        Customer customer = new Customer(null, "greenrobot");
-        daoSession.insert(customer);
-
-        addOrderToCustomer(customer);
-        addOrderToCustomer(customer);
-
-        List<Order> orders = customer.getOrders();
-        assertEquals(2, orders.size());
-    }
-
-    public void testOrderToCustomer() {
-        Customer customer = new Customer(null, "greenrobot");
-        daoSession.insert(customer);
-
-        Order order = addOrderToCustomer(customer);
-        Customer customer2 = order.getCustomer();
-        
-        assertSame(customer, customer2);
-    }
-
-    public void testUpdateBirectional() {
-        Customer customer = new Customer(null, "greenrobot");
-        daoSession.insert(customer);
-
-        addOrderToCustomer(customer);
-        List<Order> orders = customer.getOrders();
-        
-        Order newOrder = new Order();
-        newOrder.setCustomer(customer);
-        daoSession.insert(newOrder);
-        orders.add(newOrder);
-        assertEquals(2, orders.size());
-        
-        customer.resetOrders();
-        List<Order> orders2 = customer.getOrders();
-        assertEquals(orders.size(), orders2.size());
-    }
-
-    private Order addOrderToCustomer(Customer customer) {
-        Date date = new Date(System.currentTimeMillis() - ((long) (Math.random() * 1000 * 60 * 60 * 24 * 365)));
-        Order order = new Order(null, date, customer.getId());
-        daoSession.insert(order);
-        return order;
-    }
-
-}
+package de.greenrobot.daoexample;
+
+import java.util.Date;
+import java.util.List;
+
+import android.app.Application;
+import de.greenrobot.dao.test.AbstractDaoSessionTest;
+
+public class CustomerOrderTest extends AbstractDaoSessionTest<DaoMaster, DaoSession> {
+
+    public CustomerOrderTest() {
+        super(DaoMaster.class);
+    }
+
+    public void testCustomerToOrders() {
+        Customer customer = new Customer(null, "greenrobot");
+        daoSession.insert(customer);
+
+        addOrderToCustomer(customer);
+        addOrderToCustomer(customer);
+
+        List<Order> orders = customer.getOrders();
+        assertEquals(2, orders.size());
+    }
+
+    public void testOrderToCustomer() {
+        Customer customer = new Customer(null, "greenrobot");
+        daoSession.insert(customer);
+
+        Order order = addOrderToCustomer(customer);
+        Customer customer2 = order.getCustomer();
+        
+        assertSame(customer, customer2);
+    }
+
+    public void testUpdateBirectional() {
+        Customer customer = new Customer(null, "greenrobot");
+        daoSession.insert(customer);
+
+        addOrderToCustomer(customer);
+        List<Order> orders = customer.getOrders();
+        
+        Order newOrder = new Order();
+        newOrder.setCustomer(customer);
+        daoSession.insert(newOrder);
+        orders.add(newOrder);
+        assertEquals(2, orders.size());
+        
+        customer.resetOrders();
+        List<Order> orders2 = customer.getOrders();
+        assertEquals(orders.size(), orders2.size());
+    }
+
+    private Order addOrderToCustomer(Customer customer) {
+        Date date = new Date(System.currentTimeMillis() - ((long) (Math.random() * 1000 * 60 * 60 * 24 * 365)));
+        Order order = new Order(null, date, customer.getId());
+        daoSession.insert(order);
+        return order;
+    }
+
+}
diff --git a/DaoExample/src-test/de/greenrobot/daoexample/NoteTest.java b/DaoExample/src/androidTest/Java/de/greenrobot/daoexample/NoteTest.java
similarity index 96%
rename from DaoExample/src-test/de/greenrobot/daoexample/NoteTest.java
rename to DaoExample/src/androidTest/Java/de/greenrobot/daoexample/NoteTest.java
index 5ac19328..ab57058f 100644
--- a/DaoExample/src-test/de/greenrobot/daoexample/NoteTest.java
+++ b/DaoExample/src/androidTest/Java/de/greenrobot/daoexample/NoteTest.java
@@ -1,34 +1,34 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package de.greenrobot.daoexample;
-
-import de.greenrobot.dao.test.AbstractDaoTestLongPk;
-
-public class NoteTest extends AbstractDaoTestLongPk<NoteDao, Note> {
-
-    public NoteTest() {
-        super(NoteDao.class);
-    }
-
-    @Override
-    protected Note createEntity(Long key) {
-        Note entity = new Note();
-        entity.setId(key);
-        entity.setText("green note"); // Has to be set as it is "not null"
-        return entity;
-    }
-
-}
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.daoexample;
+
+import de.greenrobot.dao.test.AbstractDaoTestLongPk;
+
+public class NoteTest extends AbstractDaoTestLongPk<NoteDao, Note> {
+
+    public NoteTest() {
+        super(NoteDao.class);
+    }
+
+    @Override
+    protected Note createEntity(Long key) {
+        Note entity = new Note();
+        entity.setId(key);
+        entity.setText("green note"); // Has to be set as it is "not null"
+        return entity;
+    }
+
+}
diff --git a/DaoExample/src/main/AndroidManifest.xml b/DaoExample/src/main/AndroidManifest.xml
new file mode 100644
index 00000000..c46d2e15
--- /dev/null
+++ b/DaoExample/src/main/AndroidManifest.xml
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="de.greenrobot.daoexample">
+
+    <application
+        android:icon="@drawable/icon"
+        android:label="@string/app_name"
+        android:allowBackup="true">
+        <activity android:name=".NoteActivity">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+        </activity>
+    </application>
+
+</manifest>
\ No newline at end of file
diff --git a/DaoExample/src-gen/de/greenrobot/daoexample/Customer.java b/DaoExample/src/main/java/de/greenrobot/daoexample/Customer.java
similarity index 98%
rename from DaoExample/src-gen/de/greenrobot/daoexample/Customer.java
rename to DaoExample/src/main/java/de/greenrobot/daoexample/Customer.java
index ed2996f7..0198288d 100644
--- a/DaoExample/src-gen/de/greenrobot/daoexample/Customer.java
+++ b/DaoExample/src/main/java/de/greenrobot/daoexample/Customer.java
@@ -6,7 +6,7 @@
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
 /**
- * Entity mapped to table CUSTOMER.
+ * Entity mapped to table "CUSTOMER".
  */
 public class Customer {
 
diff --git a/DaoExample/src-gen/de/greenrobot/daoexample/CustomerDao.java b/DaoExample/src/main/java/de/greenrobot/daoexample/CustomerDao.java
similarity index 93%
rename from DaoExample/src-gen/de/greenrobot/daoexample/CustomerDao.java
rename to DaoExample/src/main/java/de/greenrobot/daoexample/CustomerDao.java
index 25a88fc3..f9df3d31 100644
--- a/DaoExample/src-gen/de/greenrobot/daoexample/CustomerDao.java
+++ b/DaoExample/src/main/java/de/greenrobot/daoexample/CustomerDao.java
@@ -12,7 +12,7 @@
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
- * DAO for table CUSTOMER.
+ * DAO for table "CUSTOMER".
 */
 public class CustomerDao extends AbstractDao<Customer, Long> {
 
@@ -42,14 +42,14 @@ public CustomerDao(DaoConfig config, DaoSession daoSession) {
     /** Creates the underlying database table. */
     public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
-        db.execSQL("CREATE TABLE " + constraint + "'CUSTOMER' (" + //
-                "'_id' INTEGER PRIMARY KEY ," + // 0: id
-                "'NAME' TEXT NOT NULL );"); // 1: name
+        db.execSQL("CREATE TABLE " + constraint + "\"CUSTOMER\" (" + //
+                "\"_id\" INTEGER PRIMARY KEY ," + // 0: id
+                "\"NAME\" TEXT NOT NULL );"); // 1: name
     }
 
     /** Drops the underlying database table. */
     public static void dropTable(SQLiteDatabase db, boolean ifExists) {
-        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'CUSTOMER'";
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "\"CUSTOMER\"";
         db.execSQL(sql);
     }
 
diff --git a/DaoExample/src-gen/de/greenrobot/daoexample/DaoMaster.java b/DaoExample/src/main/java/de/greenrobot/daoexample/DaoMaster.java
similarity index 100%
rename from DaoExample/src-gen/de/greenrobot/daoexample/DaoMaster.java
rename to DaoExample/src/main/java/de/greenrobot/daoexample/DaoMaster.java
diff --git a/DaoExample/src-gen/de/greenrobot/daoexample/DaoSession.java b/DaoExample/src/main/java/de/greenrobot/daoexample/DaoSession.java
similarity index 100%
rename from DaoExample/src-gen/de/greenrobot/daoexample/DaoSession.java
rename to DaoExample/src/main/java/de/greenrobot/daoexample/DaoSession.java
diff --git a/DaoExample/src-gen/de/greenrobot/daoexample/Note.java b/DaoExample/src/main/java/de/greenrobot/daoexample/Note.java
similarity index 97%
rename from DaoExample/src-gen/de/greenrobot/daoexample/Note.java
rename to DaoExample/src/main/java/de/greenrobot/daoexample/Note.java
index ed057058..e8d9e1e9 100644
--- a/DaoExample/src-gen/de/greenrobot/daoexample/Note.java
+++ b/DaoExample/src/main/java/de/greenrobot/daoexample/Note.java
@@ -2,7 +2,7 @@
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
 /**
- * Entity mapped to table NOTE.
+ * Entity mapped to table "NOTE".
  */
 public class Note {
 
diff --git a/DaoExample/src/de/greenrobot/daoexample/NoteActivity.java b/DaoExample/src/main/java/de/greenrobot/daoexample/NoteActivity.java
similarity index 100%
rename from DaoExample/src/de/greenrobot/daoexample/NoteActivity.java
rename to DaoExample/src/main/java/de/greenrobot/daoexample/NoteActivity.java
diff --git a/DaoExample/src-gen/de/greenrobot/daoexample/NoteDao.java b/DaoExample/src/main/java/de/greenrobot/daoexample/NoteDao.java
similarity index 92%
rename from DaoExample/src-gen/de/greenrobot/daoexample/NoteDao.java
rename to DaoExample/src/main/java/de/greenrobot/daoexample/NoteDao.java
index 0fcaceee..6d7d8306 100644
--- a/DaoExample/src-gen/de/greenrobot/daoexample/NoteDao.java
+++ b/DaoExample/src/main/java/de/greenrobot/daoexample/NoteDao.java
@@ -12,7 +12,7 @@
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
- * DAO for table NOTE.
+ * DAO for table "NOTE".
 */
 public class NoteDao extends AbstractDao<Note, Long> {
 
@@ -41,16 +41,16 @@ public NoteDao(DaoConfig config, DaoSession daoSession) {
     /** Creates the underlying database table. */
     public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
-        db.execSQL("CREATE TABLE " + constraint + "'NOTE' (" + //
-                "'_id' INTEGER PRIMARY KEY ," + // 0: id
-                "'TEXT' TEXT NOT NULL ," + // 1: text
-                "'COMMENT' TEXT," + // 2: comment
-                "'DATE' INTEGER);"); // 3: date
+        db.execSQL("CREATE TABLE " + constraint + "\"NOTE\" (" + //
+                "\"_id\" INTEGER PRIMARY KEY ," + // 0: id
+                "\"TEXT\" TEXT NOT NULL ," + // 1: text
+                "\"COMMENT\" TEXT," + // 2: comment
+                "\"DATE\" INTEGER);"); // 3: date
     }
 
     /** Drops the underlying database table. */
     public static void dropTable(SQLiteDatabase db, boolean ifExists) {
-        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'NOTE'";
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "\"NOTE\"";
         db.execSQL(sql);
     }
 
diff --git a/DaoExample/src-gen/de/greenrobot/daoexample/Order.java b/DaoExample/src/main/java/de/greenrobot/daoexample/Order.java
similarity index 98%
rename from DaoExample/src-gen/de/greenrobot/daoexample/Order.java
rename to DaoExample/src/main/java/de/greenrobot/daoexample/Order.java
index 95ecfb86..49dcd4f3 100644
--- a/DaoExample/src-gen/de/greenrobot/daoexample/Order.java
+++ b/DaoExample/src/main/java/de/greenrobot/daoexample/Order.java
@@ -5,7 +5,7 @@
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
 /**
- * Entity mapped to table ORDERS.
+ * Entity mapped to table "ORDERS".
  */
 public class Order {
 
diff --git a/DaoExample/src-gen/de/greenrobot/daoexample/OrderDao.java b/DaoExample/src/main/java/de/greenrobot/daoexample/OrderDao.java
similarity index 94%
rename from DaoExample/src-gen/de/greenrobot/daoexample/OrderDao.java
rename to DaoExample/src/main/java/de/greenrobot/daoexample/OrderDao.java
index d3ac55a7..9cb68bc3 100644
--- a/DaoExample/src-gen/de/greenrobot/daoexample/OrderDao.java
+++ b/DaoExample/src/main/java/de/greenrobot/daoexample/OrderDao.java
@@ -17,7 +17,7 @@
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
- * DAO for table ORDERS.
+ * DAO for table "ORDERS".
 */
 public class OrderDao extends AbstractDao<Order, Long> {
 
@@ -49,15 +49,15 @@ public OrderDao(DaoConfig config, DaoSession daoSession) {
     /** Creates the underlying database table. */
     public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
-        db.execSQL("CREATE TABLE " + constraint + "'ORDERS' (" + //
-                "'_id' INTEGER PRIMARY KEY ," + // 0: id
-                "'DATE' INTEGER," + // 1: date
-                "'CUSTOMER_ID' INTEGER NOT NULL );"); // 2: customerId
+        db.execSQL("CREATE TABLE " + constraint + "\"ORDERS\" (" + //
+                "\"_id\" INTEGER PRIMARY KEY ," + // 0: id
+                "\"DATE\" INTEGER," + // 1: date
+                "\"CUSTOMER_ID\" INTEGER NOT NULL );"); // 2: customerId
     }
 
     /** Drops the underlying database table. */
     public static void dropTable(SQLiteDatabase db, boolean ifExists) {
-        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'ORDERS'";
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "\"ORDERS\"";
         db.execSQL(sql);
     }
 
@@ -138,7 +138,7 @@ protected boolean isEntityUpdateable() {
             if (customer_OrdersQuery == null) {
                 QueryBuilder<Order> queryBuilder = queryBuilder();
                 queryBuilder.where(Properties.CustomerId.eq(null));
-                queryBuilder.orderRaw("DATE ASC");
+                queryBuilder.orderRaw("T.'DATE' ASC");
                 customer_OrdersQuery = queryBuilder.build();
             }
         }
@@ -156,7 +156,7 @@ protected String getSelectDeep() {
             builder.append(',');
             SqlUtils.appendColumns(builder, "T0", daoSession.getCustomerDao().getAllColumns());
             builder.append(" FROM ORDERS T");
-            builder.append(" LEFT JOIN CUSTOMER T0 ON T.'CUSTOMER_ID'=T0.'_id'");
+            builder.append(" LEFT JOIN CUSTOMER T0 ON T.\"CUSTOMER_ID\"=T0.\"_id\"");
             builder.append(' ');
             selectDeep = builder.toString();
         }
diff --git a/DaoExample/res/drawable-hdpi/icon.png b/DaoExample/src/main/res/drawable-hdpi/icon.png
similarity index 100%
rename from DaoExample/res/drawable-hdpi/icon.png
rename to DaoExample/src/main/res/drawable-hdpi/icon.png
diff --git a/DaoExample/res/drawable-ldpi/icon.png b/DaoExample/src/main/res/drawable-ldpi/icon.png
similarity index 100%
rename from DaoExample/res/drawable-ldpi/icon.png
rename to DaoExample/src/main/res/drawable-ldpi/icon.png
diff --git a/DaoExample/res/drawable-mdpi/icon.png b/DaoExample/src/main/res/drawable-mdpi/icon.png
similarity index 100%
rename from DaoExample/res/drawable-mdpi/icon.png
rename to DaoExample/src/main/res/drawable-mdpi/icon.png
diff --git a/DaoExample/res/layout/main.xml b/DaoExample/src/main/res/layout/main.xml
similarity index 100%
rename from DaoExample/res/layout/main.xml
rename to DaoExample/src/main/res/layout/main.xml
diff --git a/DaoExample/res/values/strings.xml b/DaoExample/src/main/res/values/strings.xml
similarity index 100%
rename from DaoExample/res/values/strings.xml
rename to DaoExample/src/main/res/values/strings.xml
diff --git a/DaoExampleGenerator/.classpath b/DaoExampleGenerator/.classpath
deleted file mode 100644
index 1fe2a4f1..00000000
--- a/DaoExampleGenerator/.classpath
+++ /dev/null
@@ -1,10 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="con" path="GROOVY_DSL_SUPPORT"/>
-	<classpathentry kind="con" path="GROOVY_SUPPORT"/>
-	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.6"/>
-	<classpathentry exported="true" kind="con" path="org.springsource.ide.eclipse.gradle.classpathcontainer"/>
-	<classpathentry kind="con" path="org.springsource.ide.eclipse.gradle.dsld.classpathcontainer"/>
-	<classpathentry kind="output" path="bin"/>
-</classpath>
diff --git a/DaoExampleGenerator/.project b/DaoExampleGenerator/.project
deleted file mode 100644
index e5d1de32..00000000
--- a/DaoExampleGenerator/.project
+++ /dev/null
@@ -1,19 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<projectDescription>
-	<name>DaoExampleGenerator</name>
-	<comment></comment>
-	<projects>
-	</projects>
-	<buildSpec>
-		<buildCommand>
-			<name>org.eclipse.jdt.core.javabuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-	</buildSpec>
-	<natures>
-		<nature>org.springsource.ide.eclipse.gradle.core.nature</nature>
-		<nature>org.eclipse.jdt.core.javanature</nature>
-		<nature>org.eclipse.jdt.groovy.core.groovyNature</nature>
-	</natures>
-</projectDescription>
diff --git a/DaoExampleGenerator/.settings/gradle/org.springsource.ide.eclipse.gradle.core.prefs b/DaoExampleGenerator/.settings/gradle/org.springsource.ide.eclipse.gradle.core.prefs
deleted file mode 100644
index c83b29e0..00000000
--- a/DaoExampleGenerator/.settings/gradle/org.springsource.ide.eclipse.gradle.core.prefs
+++ /dev/null
@@ -1,4 +0,0 @@
-#org.springsource.ide.eclipse.gradle.core.preferences.GradleProjectPreferences
-#Sun Feb 24 10:59:34 CET 2013
-org.springsource.ide.eclipse.gradle.linkedresources=
-org.springsource.ide.eclipse.gradle.rootprojectloc=
diff --git a/DaoExampleGenerator/.settings/gradle/org.springsource.ide.eclipse.gradle.refresh.prefs b/DaoExampleGenerator/.settings/gradle/org.springsource.ide.eclipse.gradle.refresh.prefs
deleted file mode 100644
index 1b0724ea..00000000
--- a/DaoExampleGenerator/.settings/gradle/org.springsource.ide.eclipse.gradle.refresh.prefs
+++ /dev/null
@@ -1,3 +0,0 @@
-#org.springsource.ide.eclipse.gradle.core.actions.GradleRefreshPreferences
-#Sun Feb 24 10:59:34 CET 2013
-enableDSLD=true
diff --git a/DaoExampleGenerator/.settings/org.eclipse.core.resources.prefs b/DaoExampleGenerator/.settings/org.eclipse.core.resources.prefs
deleted file mode 100644
index 3d916f29..00000000
--- a/DaoExampleGenerator/.settings/org.eclipse.core.resources.prefs
+++ /dev/null
@@ -1,2 +0,0 @@
-eclipse.preferences.version=1
-encoding/<project>=Cp1252
diff --git a/DaoExampleGenerator/.settings/org.eclipse.jdt.core.prefs b/DaoExampleGenerator/.settings/org.eclipse.jdt.core.prefs
deleted file mode 100644
index d022e4be..00000000
--- a/DaoExampleGenerator/.settings/org.eclipse.jdt.core.prefs
+++ /dev/null
@@ -1,12 +0,0 @@
-#Wed Aug 03 11:42:59 CEST 2011
-eclipse.preferences.version=1
-org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
-org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.6
-org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
-org.eclipse.jdt.core.compiler.compliance=1.6
-org.eclipse.jdt.core.compiler.debug.lineNumber=generate
-org.eclipse.jdt.core.compiler.debug.localVariable=generate
-org.eclipse.jdt.core.compiler.debug.sourceFile=generate
-org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
-org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
-org.eclipse.jdt.core.compiler.source=1.6
diff --git a/DaoExampleGenerator/.settings/org.eclipse.jdt.groovy.core.prefs b/DaoExampleGenerator/.settings/org.eclipse.jdt.groovy.core.prefs
deleted file mode 100644
index 65c6dc88..00000000
--- a/DaoExampleGenerator/.settings/org.eclipse.jdt.groovy.core.prefs
+++ /dev/null
@@ -1,2 +0,0 @@
-eclipse.preferences.version=1
-groovy.compiler.level=-1
diff --git a/DaoExampleGenerator/build.gradle b/DaoExampleGenerator/build.gradle
index f79e8e6e..48c83710 100644
--- a/DaoExampleGenerator/build.gradle
+++ b/DaoExampleGenerator/build.gradle
@@ -3,17 +3,13 @@ apply plugin: 'maven'
 apply plugin:'application'
 
 group = 'de.greenrobot'
-version = '1.3.1-SNAPSHOT'
+archivesBaseName = 'greendao-example-generator'
+version = '1.4.0-SNAPSHOT'
 sourceCompatibility = 1.6
 mainClassName = "de.greenrobot.daogenerator.gentest.ExampleDaoGenerator"
 
-repositories {
-    mavenLocal()
-    mavenCentral()
-}
-
 dependencies {
-    compile('de.greenrobot:greendao-generator:1.3.1-SNAPSHOT')
+    compile project(':DaoGenerator')
 }
 
 sourceSets {
diff --git a/DaoExampleGenerator/settings.gradle b/DaoExampleGenerator/settings.gradle
deleted file mode 100644
index 4cd77a8b..00000000
--- a/DaoExampleGenerator/settings.gradle
+++ /dev/null
@@ -1 +0,0 @@
-rootProject.name = 'greendao-example-generator'
\ No newline at end of file
diff --git a/DaoExampleGenerator/src/de/greenrobot/daogenerator/gentest/ExampleDaoGenerator.java b/DaoExampleGenerator/src/de/greenrobot/daogenerator/gentest/ExampleDaoGenerator.java
index 7dde5f94..23d957a7 100644
--- a/DaoExampleGenerator/src/de/greenrobot/daogenerator/gentest/ExampleDaoGenerator.java
+++ b/DaoExampleGenerator/src/de/greenrobot/daogenerator/gentest/ExampleDaoGenerator.java
@@ -1,67 +1,67 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package de.greenrobot.daogenerator.gentest;
-
-import de.greenrobot.daogenerator.DaoGenerator;
-import de.greenrobot.daogenerator.Entity;
-import de.greenrobot.daogenerator.Property;
-import de.greenrobot.daogenerator.Schema;
-import de.greenrobot.daogenerator.ToMany;
-
-/**
- * Generates entities and DAOs for the example project DaoExample.
- * 
- * Run it as a Java application (not Android).
- * 
- * @author Markus
- */
-public class ExampleDaoGenerator {
-
-    public static void main(String[] args) throws Exception {
-        Schema schema = new Schema(1000, "de.greenrobot.daoexample");
-
-        addNote(schema);
-        addCustomerOrder(schema);
-
-        new DaoGenerator().generateAll(schema, "../DaoExample/src-gen");
-    }
-
-    private static void addNote(Schema schema) {
-        Entity note = schema.addEntity("Note");
-        note.addIdProperty();
-        note.addStringProperty("text").notNull();
-        note.addStringProperty("comment");
-        note.addDateProperty("date");
-    }
-
-    private static void addCustomerOrder(Schema schema) {
-        Entity customer = schema.addEntity("Customer");
-        customer.addIdProperty();
-        customer.addStringProperty("name").notNull();
-
-        Entity order = schema.addEntity("Order");
-        order.setTableName("ORDERS"); // "ORDER" is a reserved keyword
-        order.addIdProperty();
-        Property orderDate = order.addDateProperty("date").getProperty();
-        Property customerId = order.addLongProperty("customerId").notNull().getProperty();
-        order.addToOne(customer, customerId);
-
-        ToMany customerToOrders = customer.addToMany(order, customerId);
-        customerToOrders.setName("orders");
-        customerToOrders.orderAsc(orderDate);
-    }
-
-}
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.daogenerator.gentest;
+
+import de.greenrobot.daogenerator.DaoGenerator;
+import de.greenrobot.daogenerator.Entity;
+import de.greenrobot.daogenerator.Property;
+import de.greenrobot.daogenerator.Schema;
+import de.greenrobot.daogenerator.ToMany;
+
+/**
+ * Generates entities and DAOs for the example project DaoExample.
+ * 
+ * Run it as a Java application (not Android).
+ * 
+ * @author Markus
+ */
+public class ExampleDaoGenerator {
+
+    public static void main(String[] args) throws Exception {
+        Schema schema = new Schema(1000, "de.greenrobot.daoexample");
+
+        addNote(schema);
+        addCustomerOrder(schema);
+
+        new DaoGenerator().generateAll(schema, "../DaoExample/src/main/java");
+    }
+
+    private static void addNote(Schema schema) {
+        Entity note = schema.addEntity("Note");
+        note.addIdProperty();
+        note.addStringProperty("text").notNull();
+        note.addStringProperty("comment");
+        note.addDateProperty("date");
+    }
+
+    private static void addCustomerOrder(Schema schema) {
+        Entity customer = schema.addEntity("Customer");
+        customer.addIdProperty();
+        customer.addStringProperty("name").notNull();
+
+        Entity order = schema.addEntity("Order");
+        order.setTableName("ORDERS"); // "ORDER" is a reserved keyword
+        order.addIdProperty();
+        Property orderDate = order.addDateProperty("date").getProperty();
+        Property customerId = order.addLongProperty("customerId").notNull().getProperty();
+        order.addToOne(customer, customerId);
+
+        ToMany customerToOrders = customer.addToMany(order, customerId);
+        customerToOrders.setName("orders");
+        customerToOrders.orderAsc(orderDate);
+    }
+
+}
diff --git a/DaoGenerator/.classpath b/DaoGenerator/.classpath
deleted file mode 100644
index a82e8447..00000000
--- a/DaoGenerator/.classpath
+++ /dev/null
@@ -1,14 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="src" path="src-template"/>
-	<classpathentry kind="src" path="src-test"/>
-	<classpathentry kind="src" path="src-generator-testentities"/>
-	<classpathentry kind="con" path="GROOVY_DSL_SUPPORT"/>
-	<classpathentry kind="con" path="GROOVY_SUPPORT"/>
-	<classpathentry kind="con" path="org.eclipse.jdt.junit.JUNIT_CONTAINER/4"/>
-	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.6"/>
-	<classpathentry exported="true" kind="con" path="org.springsource.ide.eclipse.gradle.classpathcontainer"/>
-	<classpathentry kind="con" path="org.springsource.ide.eclipse.gradle.dsld.classpathcontainer"/>
-	<classpathentry kind="output" path="bin"/>
-</classpath>
diff --git a/DaoGenerator/.project b/DaoGenerator/.project
deleted file mode 100644
index 4d909547..00000000
--- a/DaoGenerator/.project
+++ /dev/null
@@ -1,19 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<projectDescription>
-	<name>DaoGenerator</name>
-	<comment></comment>
-	<projects>
-	</projects>
-	<buildSpec>
-		<buildCommand>
-			<name>org.eclipse.jdt.core.javabuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-	</buildSpec>
-	<natures>
-		<nature>org.springsource.ide.eclipse.gradle.core.nature</nature>
-		<nature>org.eclipse.jdt.core.javanature</nature>
-		<nature>org.eclipse.jdt.groovy.core.groovyNature</nature>
-	</natures>
-</projectDescription>
diff --git a/DaoGenerator/.settings/gradle/org.springsource.ide.eclipse.gradle.core.prefs b/DaoGenerator/.settings/gradle/org.springsource.ide.eclipse.gradle.core.prefs
deleted file mode 100644
index 734e6cba..00000000
--- a/DaoGenerator/.settings/gradle/org.springsource.ide.eclipse.gradle.core.prefs
+++ /dev/null
@@ -1,4 +0,0 @@
-#org.springsource.ide.eclipse.gradle.core.preferences.GradleProjectPreferences
-#Sun Feb 24 10:56:04 CET 2013
-org.springsource.ide.eclipse.gradle.linkedresources=
-org.springsource.ide.eclipse.gradle.rootprojectloc=
diff --git a/DaoGenerator/.settings/gradle/org.springsource.ide.eclipse.gradle.refresh.prefs b/DaoGenerator/.settings/gradle/org.springsource.ide.eclipse.gradle.refresh.prefs
deleted file mode 100644
index f6b5aef6..00000000
--- a/DaoGenerator/.settings/gradle/org.springsource.ide.eclipse.gradle.refresh.prefs
+++ /dev/null
@@ -1,3 +0,0 @@
-#org.springsource.ide.eclipse.gradle.core.actions.GradleRefreshPreferences
-#Sun Feb 24 10:56:15 CET 2013
-enableDSLD=true
diff --git a/DaoGenerator/.settings/org.eclipse.core.resources.prefs b/DaoGenerator/.settings/org.eclipse.core.resources.prefs
deleted file mode 100644
index 3d916f29..00000000
--- a/DaoGenerator/.settings/org.eclipse.core.resources.prefs
+++ /dev/null
@@ -1,2 +0,0 @@
-eclipse.preferences.version=1
-encoding/<project>=Cp1252
diff --git a/DaoGenerator/.settings/org.eclipse.jdt.core.prefs b/DaoGenerator/.settings/org.eclipse.jdt.core.prefs
deleted file mode 100644
index e2f40406..00000000
--- a/DaoGenerator/.settings/org.eclipse.jdt.core.prefs
+++ /dev/null
@@ -1,12 +0,0 @@
-#Fri Jul 22 21:20:49 CEST 2011
-eclipse.preferences.version=1
-org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
-org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.6
-org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
-org.eclipse.jdt.core.compiler.compliance=1.6
-org.eclipse.jdt.core.compiler.debug.lineNumber=generate
-org.eclipse.jdt.core.compiler.debug.localVariable=generate
-org.eclipse.jdt.core.compiler.debug.sourceFile=generate
-org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
-org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
-org.eclipse.jdt.core.compiler.source=1.6
diff --git a/DaoGenerator/.settings/org.eclipse.jdt.groovy.core.prefs b/DaoGenerator/.settings/org.eclipse.jdt.groovy.core.prefs
deleted file mode 100644
index 65c6dc88..00000000
--- a/DaoGenerator/.settings/org.eclipse.jdt.groovy.core.prefs
+++ /dev/null
@@ -1,2 +0,0 @@
-eclipse.preferences.version=1
-groovy.compiler.level=-1
diff --git a/DaoGenerator/build.gradle b/DaoGenerator/build.gradle
index e25ff529..843f8141 100644
--- a/DaoGenerator/build.gradle
+++ b/DaoGenerator/build.gradle
@@ -3,8 +3,9 @@ apply plugin: 'maven'
 apply plugin: 'signing'
 
 group = 'de.greenrobot'
-version = '1.3.1'
-sourceCompatibility = 1.6
+archivesBaseName = 'greendao-generator'
+version = '2.1.1-SNAPSHOT'
+sourceCompatibility = 1.7
 
 def isSnapshot = version.endsWith('-SNAPSHOT')
 def sonatypeRepositoryUrl
@@ -26,8 +27,8 @@ configurations {
 }
 
 dependencies {
-    compile ('org.freemarker:freemarker:2.3.20')
-    testCompile 'junit:junit:4.11'
+    compile 'org.freemarker:freemarker:2.3.23'
+    testCompile 'junit:junit:4.12'
     // deployerJars 'org.apache.maven.wagon:wagon-webdav-jackrabbit:2.4'
     deployerJars 'org.apache.maven.wagon:wagon-webdav:1.0-beta-2'
 }
@@ -58,10 +59,11 @@ test {
 }
 
 javadoc {
+    failOnError = false
     title = "greenDAO Generator ${version} API"
     // Unfinished APIs:
     excludes = ['de/greenrobot/daogenerator/Query*']
-    options.bottom = 'Available under the GPLv3 - <i>Copyright &#169; 2011-2013 <a href="http://greenrobot.de/">greenrobot.de</a>. All Rights Reserved.</i>'
+    options.bottom = 'Available under the GPLv3 - <i>Copyright &#169; 2011-2015 <a href="http://greenrobot.de/">greenrobot.de</a>. All Rights Reserved.</i>'
 }
 
 task javadocJar(type: Jar, dependsOn: javadoc) {
diff --git a/DaoGenerator/java-formater.xml b/DaoGenerator/java-formater.xml
deleted file mode 100644
index 9eabc7e4..00000000
--- a/DaoGenerator/java-formater.xml
+++ /dev/null
@@ -1,291 +0,0 @@
-<?xml version="1.0" encoding="UTF-8" standalone="no"?>
-<profiles version="12">
-<profile kind="CodeFormatterProfile" name="greenrobot" version="12">
-<setting id="org.eclipse.jdt.core.formatter.comment.insert_new_line_before_root_tags" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.disabling_tag" value="@formatter:off"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_annotation" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_type_parameters" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_type_declaration" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_type_arguments" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.brace_position_for_anonymous_type_declaration" value="end_of_line"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_colon_in_case" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_brace_in_array_initializer" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.comment.new_lines_at_block_boundaries" value="true"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_new_line_in_empty_annotation_declaration" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_new_line_before_closing_brace_in_array_initializer" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_annotation" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.blank_lines_before_field" value="0"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_while" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.use_on_off_tags" value="true"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_annotation_type_member_declaration" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_new_line_before_else_in_if_statement" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_prefix_operator" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.keep_else_statement_on_same_line" value="false"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_ellipsis" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.comment.insert_new_line_for_parameter" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_annotation_type_declaration" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.indent_breaks_compare_to_cases" value="true"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_at_in_annotation" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.alignment_for_multiple_fields" value="16"/>
-<setting id="org.eclipse.jdt.core.formatter.alignment_for_expressions_in_array_initializer" value="16"/>
-<setting id="org.eclipse.jdt.core.formatter.alignment_for_conditional_expression" value="80"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_for" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_binary_operator" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_question_in_wildcard" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.brace_position_for_array_initializer" value="end_of_line"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_enum_constant" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_new_line_before_finally_in_try_statement" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_local_variable" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_new_line_before_catch_in_try_statement" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_while" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.blank_lines_after_package" value="1"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_type_parameters" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.continuation_indentation" value="2"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_postfix_operator" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.alignment_for_arguments_in_method_invocation" value="16"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_type_arguments" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_superinterfaces" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.blank_lines_before_new_chunk" value="1"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_binary_operator" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.blank_lines_before_package" value="0"/>
-<setting id="org.eclipse.jdt.core.compiler.source" value="1.7"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_enum_constant_arguments" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_constructor_declaration" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.comment.format_line_comments" value="true"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_closing_angle_bracket_in_type_arguments" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_enum_declarations" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.join_wrapped_lines" value="true"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_block" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.alignment_for_arguments_in_explicit_constructor_call" value="16"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_invocation_arguments" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.blank_lines_before_member_type" value="1"/>
-<setting id="org.eclipse.jdt.core.formatter.align_type_members_on_columns" value="false"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_enum_constant" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_for" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_method_declaration" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.alignment_for_selector_in_method_invocation" value="16"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_switch" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_unary_operator" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_colon_in_case" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.comment.indent_parameter_description" value="true"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_method_declaration" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_switch" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_enum_declaration" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_type_parameters" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.comment.clear_blank_lines_in_block_comment" value="false"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_new_line_in_empty_type_declaration" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.lineSplit" value="120"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_if" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_between_brackets_in_array_type_reference" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_parenthesized_expression" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_explicitconstructorcall_arguments" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_constructor_declaration" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.blank_lines_before_first_class_body_declaration" value="0"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_method" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.indentation.size" value="4"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_method_declaration" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.enabling_tag" value="@formatter:on"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_enum_constant" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.alignment_for_superclass_in_type_declaration" value="16"/>
-<setting id="org.eclipse.jdt.core.formatter.alignment_for_assignment" value="0"/>
-<setting id="org.eclipse.jdt.core.compiler.problem.assertIdentifier" value="error"/>
-<setting id="org.eclipse.jdt.core.formatter.tabulation.char" value="space"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_constructor_declaration_parameters" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_semicolon_in_try_resources" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_prefix_operator" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.indent_statements_compare_to_body" value="true"/>
-<setting id="org.eclipse.jdt.core.formatter.blank_lines_before_method" value="1"/>
-<setting id="org.eclipse.jdt.core.formatter.wrap_outer_expressions_when_nested" value="true"/>
-<setting id="org.eclipse.jdt.core.formatter.format_guardian_clause_on_one_line" value="false"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_colon_in_for" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_cast" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.alignment_for_parameters_in_constructor_declaration" value="16"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_colon_in_labeled_statement" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.brace_position_for_annotation_type_declaration" value="end_of_line"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_new_line_in_empty_method_body" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.alignment_for_method_declaration" value="0"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_method_invocation" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_try" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_bracket_in_array_allocation_expression" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_enum_constant" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_annotation" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_at_in_annotation_type_declaration" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_declaration_throws" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_if" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.brace_position_for_switch" value="end_of_line"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_declaration_throws" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_parenthesized_expression_in_return" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_annotation" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_question_in_conditional" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_question_in_wildcard" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_try" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_bracket_in_array_allocation_expression" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.comment.preserve_white_space_between_code_and_line_comments" value="false"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_parenthesized_expression_in_throw" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_type_arguments" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.compiler.problem.enumIdentifier" value="error"/>
-<setting id="org.eclipse.jdt.core.formatter.indent_switchstatements_compare_to_switch" value="false"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_ellipsis" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.brace_position_for_block" value="end_of_line"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_for_inits" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.brace_position_for_method_declaration" value="end_of_line"/>
-<setting id="org.eclipse.jdt.core.formatter.compact_else_if" value="true"/>
-<setting id="org.eclipse.jdt.core.formatter.wrap_before_or_operator_multicatch" value="true"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_array_initializer" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_for_increments" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.format_line_comment_starting_on_first_column" value="true"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_bracket_in_array_reference" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_field" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.brace_position_for_enum_constant" value="end_of_line"/>
-<setting id="org.eclipse.jdt.core.formatter.comment.indent_root_tags" value="true"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_enum_declarations" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.alignment_for_union_type_in_multicatch" value="16"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_explicitconstructorcall_arguments" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_switch" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_declaration_parameters" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_superinterfaces" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_allocation_expression" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.tabulation.size" value="4"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_type_reference" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_opening_brace_in_array_initializer" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_closing_brace_in_block" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_reference" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_new_line_in_empty_enum_constant" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_type_arguments" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_constructor_declaration" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_constructor_declaration_throws" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_if" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.comment.clear_blank_lines_in_javadoc_comment" value="false"/>
-<setting id="org.eclipse.jdt.core.formatter.alignment_for_throws_clause_in_constructor_declaration" value="16"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_assignment_operator" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_assignment_operator" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.indent_empty_lines" value="false"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_synchronized" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_closing_paren_in_cast" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_declaration_parameters" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.brace_position_for_block_in_case" value="end_of_line"/>
-<setting id="org.eclipse.jdt.core.formatter.number_of_empty_lines_to_preserve" value="1"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_method_declaration" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_catch" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_constructor_declaration" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_method_invocation" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_bracket_in_array_reference" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.alignment_for_arguments_in_qualified_allocation_expression" value="16"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_and_in_type_parameter" value="insert"/>
-<setting id="org.eclipse.jdt.core.compiler.compliance" value="1.7"/>
-<setting id="org.eclipse.jdt.core.formatter.continuation_indentation_for_array_initializer" value="2"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_between_empty_brackets_in_array_allocation_expression" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_at_in_annotation_type_declaration" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.alignment_for_arguments_in_allocation_expression" value="16"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_cast" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_unary_operator" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_parameterized_type_reference" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_anonymous_type_declaration" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.keep_empty_array_initializer_on_one_line" value="false"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_new_line_in_empty_enum_declaration" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.keep_imple_if_on_one_line" value="false"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_constructor_declaration_parameters" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_closing_angle_bracket_in_type_parameters" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_new_line_at_end_of_file_if_missing" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_colon_in_for" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_colon_in_labeled_statement" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_parameterized_type_reference" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.alignment_for_superinterfaces_in_type_declaration" value="16"/>
-<setting id="org.eclipse.jdt.core.formatter.alignment_for_binary_expression" value="16"/>
-<setting id="org.eclipse.jdt.core.formatter.brace_position_for_enum_declaration" value="end_of_line"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_type" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_while" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode" value="enabled"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_try" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.put_empty_statement_on_new_line" value="true"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_label" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_parameter" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_type_parameters" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_method_invocation" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_new_line_before_while_in_do_statement" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.alignment_for_arguments_in_enum_constant" value="16"/>
-<setting id="org.eclipse.jdt.core.formatter.comment.format_javadoc_comments" value="true"/>
-<setting id="org.eclipse.jdt.core.formatter.comment.line_length" value="120"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_package" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.blank_lines_between_import_groups" value="1"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_enum_constant_arguments" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_semicolon" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.brace_position_for_constructor_declaration" value="end_of_line"/>
-<setting id="org.eclipse.jdt.core.formatter.number_of_blank_lines_at_beginning_of_method_body" value="0"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_colon_in_conditional" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_type_header" value="true"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_annotation_type_member_declaration" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.wrap_before_binary_operator" value="true"/>
-<setting id="org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_enum_declaration_header" value="true"/>
-<setting id="org.eclipse.jdt.core.formatter.blank_lines_between_type_declarations" value="1"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_synchronized" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.indent_statements_compare_to_block" value="true"/>
-<setting id="org.eclipse.jdt.core.formatter.alignment_for_superinterfaces_in_enum_declaration" value="16"/>
-<setting id="org.eclipse.jdt.core.formatter.join_lines_in_comments" value="true"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_question_in_conditional" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_multiple_field_declarations" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.alignment_for_compact_if" value="16"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_for_inits" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.indent_switchstatements_compare_to_cases" value="true"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_array_initializer" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_colon_in_default" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_and_in_type_parameter" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_constructor_declaration" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.blank_lines_before_imports" value="1"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_colon_in_assert" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.comment.format_html" value="true"/>
-<setting id="org.eclipse.jdt.core.formatter.alignment_for_throws_clause_in_method_declaration" value="16"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_type_parameters" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_allocation_expression" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_new_line_in_empty_anonymous_type_declaration" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_colon_in_conditional" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_parameterized_type_reference" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_for" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_postfix_operator" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.comment.format_source_code" value="true"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_synchronized" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_allocation_expression" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_constructor_declaration_throws" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.alignment_for_parameters_in_method_declaration" value="16"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_brace_in_array_initializer" value="insert"/>
-<setting id="org.eclipse.jdt.core.compiler.codegen.targetPlatform" value="1.7"/>
-<setting id="org.eclipse.jdt.core.formatter.alignment_for_resources_in_try" value="80"/>
-<setting id="org.eclipse.jdt.core.formatter.use_tabs_only_for_leading_indentations" value="true"/>
-<setting id="org.eclipse.jdt.core.formatter.alignment_for_arguments_in_annotation" value="0"/>
-<setting id="org.eclipse.jdt.core.formatter.comment.format_header" value="false"/>
-<setting id="org.eclipse.jdt.core.formatter.comment.format_block_comments" value="true"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_enum_constant" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.alignment_for_enum_constants" value="0"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_new_line_in_empty_block" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_annotation_declaration_header" value="true"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_parenthesized_expression" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_parenthesized_expression" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_catch" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_multiple_local_declarations" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_switch" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_for_increments" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_method_invocation" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_colon_in_assert" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.brace_position_for_type_declaration" value="end_of_line"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_array_initializer" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_between_empty_braces_in_array_initializer" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_method_declaration" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_semicolon_in_for" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_catch" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_parameterized_type_reference" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_multiple_field_declarations" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_annotation" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_parameterized_type_reference" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_invocation_arguments" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.comment.new_lines_at_javadoc_boundaries" value="true"/>
-<setting id="org.eclipse.jdt.core.formatter.blank_lines_after_imports" value="1"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_multiple_local_declarations" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_enum_constant_header" value="true"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_after_semicolon_in_for" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.never_indent_line_comments_on_first_column" value="false"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_semicolon_in_try_resources" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_type_arguments" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.never_indent_block_comments_on_first_column" value="false"/>
-<setting id="org.eclipse.jdt.core.formatter.keep_then_statement_on_same_line" value="false"/>
-</profile>
-</profiles>
diff --git a/DaoGenerator/settings.gradle b/DaoGenerator/settings.gradle
deleted file mode 100644
index 86014829..00000000
--- a/DaoGenerator/settings.gradle
+++ /dev/null
@@ -1 +0,0 @@
-rootProject.name = 'greendao-generator'
\ No newline at end of file
diff --git a/DaoGenerator/src-template/dao-deep.ftl b/DaoGenerator/src-template/dao-deep.ftl
index eee5dc97..35123713 100644
--- a/DaoGenerator/src-template/dao-deep.ftl
+++ b/DaoGenerator/src-template/dao-deep.ftl
@@ -1,129 +1,129 @@
-<#--
-
-Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)     
-                                                                           
-This file is part of greenDAO Generator.                                   
-                                                                           
-greenDAO Generator is free software: you can redistribute it and/or modify 
-it under the terms of the GNU General Public License as published by       
-the Free Software Foundation, either version 3 of the License, or          
-(at your option) any later version.                                        
-greenDAO Generator is distributed in the hope that it will be useful,      
-but WITHOUT ANY WARRANTY; without even the implied warranty of             
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              
-GNU General Public License for more details.                               
-                                                                           
-You should have received a copy of the GNU General Public License          
-along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
-
--->
-<#if entity.toOneRelations?has_content>
-    private String selectDeep;
-
-    protected String getSelectDeep() {
-        if (selectDeep == null) {
-            StringBuilder builder = new StringBuilder("SELECT ");
-            SqlUtils.appendColumns(builder, "T", getAllColumns());
-            builder.append(',');
-<#list entity.toOneRelations as toOne>
-            SqlUtils.appendColumns(builder, "T${toOne_index}", daoSession.get${toOne.targetEntity.classNameDao}().getAllColumns());
-<#if toOne_has_next>
-            builder.append(',');
-</#if>
-</#list>
-            builder.append(" FROM ${entity.tableName} T");
-<#list entity.toOneRelations as toOne>
-            builder.append(" LEFT JOIN ${toOne.targetEntity.tableName} T${toOne_index}<#--
---> ON T.'${toOne.fkProperties[0].columnName}'=T${toOne_index}.'${toOne.targetEntity.pkProperty.columnName}'");
-</#list>
-            builder.append(' ');
-            selectDeep = builder.toString();
-        }
-        return selectDeep;
-    }
-    
-    protected ${entity.className} loadCurrentDeep(Cursor cursor, boolean lock) {
-        ${entity.className} entity = loadCurrent(cursor, 0, lock);
-        int offset = getAllColumns().length;
-
-<#list entity.toOneRelations as toOne>
-        ${toOne.targetEntity.className} ${toOne.name} = loadCurrentOther(daoSession.get${toOne.targetEntity.classNameDao}(), cursor, offset);
-<#if toOne.fkProperties[0].notNull>         if(${toOne.name} != null) {
-    </#if>        entity.set${toOne.name?cap_first}(${toOne.name});
-<#if toOne.fkProperties[0].notNull>
-        }
-</#if>
-<#if toOne_has_next>
-        offset += daoSession.get${toOne.targetEntity.classNameDao}().getAllColumns().length;
-</#if>
-
-</#list>
-        return entity;    
-    }
-
-    public ${entity.className} loadDeep(Long key) {
-        assertSinglePk();
-        if (key == null) {
-            return null;
-        }
-
-        StringBuilder builder = new StringBuilder(getSelectDeep());
-        builder.append("WHERE ");
-        SqlUtils.appendColumnsEqValue(builder, "T", getPkColumns());
-        String sql = builder.toString();
-        
-        String[] keyArray = new String[] { key.toString() };
-        Cursor cursor = db.rawQuery(sql, keyArray);
-        
-        try {
-            boolean available = cursor.moveToFirst();
-            if (!available) {
-                return null;
-            } else if (!cursor.isLast()) {
-                throw new IllegalStateException("Expected unique result, but count was " + cursor.getCount());
-            }
-            return loadCurrentDeep(cursor, true);
-        } finally {
-            cursor.close();
-        }
-    }
-    
-    /** Reads all available rows from the given cursor and returns a list of new ImageTO objects. */
-    public List<${entity.className}> loadAllDeepFromCursor(Cursor cursor) {
-        int count = cursor.getCount();
-        List<${entity.className}> list = new ArrayList<${entity.className}>(count);
-        
-        if (cursor.moveToFirst()) {
-            if (identityScope != null) {
-                identityScope.lock();
-                identityScope.reserveRoom(count);
-            }
-            try {
-                do {
-                    list.add(loadCurrentDeep(cursor, false));
-                } while (cursor.moveToNext());
-            } finally {
-                if (identityScope != null) {
-                    identityScope.unlock();
-                }
-            }
-        }
-        return list;
-    }
-    
-    protected List<${entity.className}> loadDeepAllAndCloseCursor(Cursor cursor) {
-        try {
-            return loadAllDeepFromCursor(cursor);
-        } finally {
-            cursor.close();
-        }
-    }
-    
-
-    /** A raw-style query where you can pass any WHERE clause and arguments. */
-    public List<${entity.className}> queryDeep(String where, String... selectionArg) {
-        Cursor cursor = db.rawQuery(getSelectDeep() + where, selectionArg);
-        return loadDeepAllAndCloseCursor(cursor);
-    }
- 
+<#--
+
+Copyright (C) 2011-2015 Markus Junginger, greenrobot (http://greenrobot.de)
+                                                                           
+This file is part of greenDAO Generator.                                   
+                                                                           
+greenDAO Generator is free software: you can redistribute it and/or modify 
+it under the terms of the GNU General Public License as published by       
+the Free Software Foundation, either version 3 of the License, or          
+(at your option) any later version.                                        
+greenDAO Generator is distributed in the hope that it will be useful,      
+but WITHOUT ANY WARRANTY; without even the implied warranty of             
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              
+GNU General Public License for more details.                               
+                                                                           
+You should have received a copy of the GNU General Public License          
+along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+
+-->
+<#if entity.toOneRelations?has_content>
+    private String selectDeep;
+
+    protected String getSelectDeep() {
+        if (selectDeep == null) {
+            StringBuilder builder = new StringBuilder("SELECT ");
+            SqlUtils.appendColumns(builder, "T", getAllColumns());
+            builder.append(',');
+<#list entity.toOneRelations as toOne>
+            SqlUtils.appendColumns(builder, "T${toOne_index}", daoSession.get${toOne.targetEntity.classNameDao}().getAllColumns());
+<#if toOne_has_next>
+            builder.append(',');
+</#if>
+</#list>
+            builder.append(" FROM ${entity.tableName} T");
+<#list entity.toOneRelations as toOne>
+            builder.append(" LEFT JOIN ${toOne.targetEntity.tableName} T${toOne_index}<#--
+--> ON T.\"${toOne.fkProperties[0].columnName}\"=T${toOne_index}.\"${toOne.targetEntity.pkProperty.columnName}\"");
+</#list>
+            builder.append(' ');
+            selectDeep = builder.toString();
+        }
+        return selectDeep;
+    }
+    
+    protected ${entity.className} loadCurrentDeep(Cursor cursor, boolean lock) {
+        ${entity.className} entity = loadCurrent(cursor, 0, lock);
+        int offset = getAllColumns().length;
+
+<#list entity.toOneRelations as toOne>
+        ${toOne.targetEntity.className} ${toOne.name} = loadCurrentOther(daoSession.get${toOne.targetEntity.classNameDao}(), cursor, offset);
+<#if toOne.fkProperties[0].notNull>         if(${toOne.name} != null) {
+    </#if>        entity.set${toOne.name?cap_first}(${toOne.name});
+<#if toOne.fkProperties[0].notNull>
+        }
+</#if>
+<#if toOne_has_next>
+        offset += daoSession.get${toOne.targetEntity.classNameDao}().getAllColumns().length;
+</#if>
+
+</#list>
+        return entity;    
+    }
+
+    public ${entity.className} loadDeep(Long key) {
+        assertSinglePk();
+        if (key == null) {
+            return null;
+        }
+
+        StringBuilder builder = new StringBuilder(getSelectDeep());
+        builder.append("WHERE ");
+        SqlUtils.appendColumnsEqValue(builder, "T", getPkColumns());
+        String sql = builder.toString();
+        
+        String[] keyArray = new String[] { key.toString() };
+        Cursor cursor = db.rawQuery(sql, keyArray);
+        
+        try {
+            boolean available = cursor.moveToFirst();
+            if (!available) {
+                return null;
+            } else if (!cursor.isLast()) {
+                throw new IllegalStateException("Expected unique result, but count was " + cursor.getCount());
+            }
+            return loadCurrentDeep(cursor, true);
+        } finally {
+            cursor.close();
+        }
+    }
+    
+    /** Reads all available rows from the given cursor and returns a list of new ImageTO objects. */
+    public List<${entity.className}> loadAllDeepFromCursor(Cursor cursor) {
+        int count = cursor.getCount();
+        List<${entity.className}> list = new ArrayList<${entity.className}>(count);
+        
+        if (cursor.moveToFirst()) {
+            if (identityScope != null) {
+                identityScope.lock();
+                identityScope.reserveRoom(count);
+            }
+            try {
+                do {
+                    list.add(loadCurrentDeep(cursor, false));
+                } while (cursor.moveToNext());
+            } finally {
+                if (identityScope != null) {
+                    identityScope.unlock();
+                }
+            }
+        }
+        return list;
+    }
+    
+    protected List<${entity.className}> loadDeepAllAndCloseCursor(Cursor cursor) {
+        try {
+            return loadAllDeepFromCursor(cursor);
+        } finally {
+            cursor.close();
+        }
+    }
+    
+
+    /** A raw-style query where you can pass any WHERE clause and arguments. */
+    public List<${entity.className}> queryDeep(String where, String... selectionArg) {
+        Cursor cursor = db.rawQuery(getSelectDeep() + where, selectionArg);
+        return loadDeepAllAndCloseCursor(cursor);
+    }
+ 
 </#if>
\ No newline at end of file
diff --git a/DaoGenerator/src-template/dao-unit-test.ftl b/DaoGenerator/src-template/dao-unit-test.ftl
index 376cf431..9e9d9c51 100644
--- a/DaoGenerator/src-template/dao-unit-test.ftl
+++ b/DaoGenerator/src-template/dao-unit-test.ftl
@@ -1,53 +1,53 @@
-<#--
-
-Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)     
-                                                                           
-This file is part of greenDAO Generator.                                   
-                                                                           
-greenDAO Generator is free software: you can redistribute it and/or modify 
-it under the terms of the GNU General Public License as published by       
-the Free Software Foundation, either version 3 of the License, or          
-(at your option) any later version.                                        
-greenDAO Generator is distributed in the hope that it will be useful,      
-but WITHOUT ANY WARRANTY; without even the implied warranty of             
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              
-GNU General Public License for more details.                               
-                                                                           
-You should have received a copy of the GNU General Public License          
-along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
-
--->
-package ${entity.javaPackageTest};
-
-<#assign isStringPK = entity.pkProperty?? && entity.pkProperty.propertyType == "String" />
-<#if isStringPK>
-import de.greenrobot.dao.test.AbstractDaoTestStringPk;
-<#else>
-import de.greenrobot.dao.test.AbstractDaoTestLongPk;
-</#if>
-
-import ${entity.javaPackage}.${entity.className};
-import ${entity.javaPackageDao}.${entity.classNameDao};
-
-public class ${entity.classNameTest} extends <#if
-isStringPK>AbstractDaoTestStringPk<${entity.classNameDao}, ${entity.className}><#else>AbstractDaoTestLongPk<${entity.classNameDao}, ${entity.className}></#if> {
-
-    public ${entity.classNameTest}() {
-        super(${entity.classNameDao}.class);
-    }
-
-    @Override
-    protected ${entity.className} createEntity(<#if isStringPK>String<#else>Long</#if> key) {
-        ${entity.className} entity = new ${entity.className}();
-<#if entity.pkProperty??>
-        entity.set${entity.pkProperty.propertyName?cap_first}(key);
-</#if>
-<#list entity.properties as property>
-<#if property.notNull>
-        entity.set${property.propertyName?cap_first}();
-</#if> 
-</#list>
-        return entity;
-    }
-
-}
+<#--
+
+Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)     
+                                                                           
+This file is part of greenDAO Generator.                                   
+                                                                           
+greenDAO Generator is free software: you can redistribute it and/or modify 
+it under the terms of the GNU General Public License as published by       
+the Free Software Foundation, either version 3 of the License, or          
+(at your option) any later version.                                        
+greenDAO Generator is distributed in the hope that it will be useful,      
+but WITHOUT ANY WARRANTY; without even the implied warranty of             
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              
+GNU General Public License for more details.                               
+                                                                           
+You should have received a copy of the GNU General Public License          
+along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+
+-->
+package ${entity.javaPackageTest};
+
+<#assign isStringPK = entity.pkProperty?? && entity.pkProperty.propertyType == "String" />
+<#if isStringPK>
+import de.greenrobot.dao.test.AbstractDaoTestStringPk;
+<#else>
+import de.greenrobot.dao.test.AbstractDaoTestLongPk;
+</#if>
+
+import ${entity.javaPackage}.${entity.className};
+import ${entity.javaPackageDao}.${entity.classNameDao};
+
+public class ${entity.classNameTest} extends <#if
+isStringPK>AbstractDaoTestStringPk<${entity.classNameDao}, ${entity.className}><#else>AbstractDaoTestLongPk<${entity.classNameDao}, ${entity.className}></#if> {
+
+    public ${entity.classNameTest}() {
+        super(${entity.classNameDao}.class);
+    }
+
+    @Override
+    protected ${entity.className} createEntity(<#if isStringPK>String<#else>Long</#if> key) {
+        ${entity.className} entity = new ${entity.className}();
+<#if entity.pkProperty??>
+        entity.set${entity.pkProperty.propertyName?cap_first}(key);
+</#if>
+<#list entity.properties as property>
+<#if property.notNull>
+        entity.set${property.propertyName?cap_first}();
+</#if> 
+</#list>
+        return entity;
+    }
+
+}
diff --git a/DaoGenerator/src-template/dao.ftl b/DaoGenerator/src-template/dao.ftl
index 443f74dc..60f7045b 100644
--- a/DaoGenerator/src-template/dao.ftl
+++ b/DaoGenerator/src-template/dao.ftl
@@ -1,6 +1,6 @@
 <#--
 
-Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)     
+Copyright (C) 2011-2015 Markus Junginger, greenrobot (http://greenrobot.de)
                                                                            
 This file is part of greenDAO Generator.                                   
                                                                            
@@ -59,7 +59,7 @@ import ${entity.javaPackage}.${entity.className}.Builder;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
- * DAO for table ${entity.tableName}.
+ * DAO for table "${entity.tableName}".
 */
 public class ${entity.classNameDao} extends AbstractDao<${entity.className}, ${entity.pkType}> {
 
@@ -79,6 +79,9 @@ public class ${entity.classNameDao} extends AbstractDao<${entity.className}, ${e
     private DaoSession daoSession;
 
 </#if>
+<#list entity.properties as property><#if property.customType?has_content><#--
+-->    private final ${property.converterClassName} ${property.propertyName}Converter = new ${property.converterClassName}();
+</#if></#list>
 <#list entity.incomingToManyRelations as toMany>
     private Query<${toMany.targetEntity.className}> ${toMany.sourceEntity.className?uncap_first}_${toMany.name?cap_first}Query;
 </#list>
@@ -98,23 +101,23 @@ public class ${entity.classNameDao} extends AbstractDao<${entity.className}, ${e
     /** Creates the underlying database table. */
     public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
-        db.execSQL("CREATE TABLE " + constraint + "'${entity.tableName}' (" + //
+        db.execSQL("CREATE TABLE " + constraint + "\"${entity.tableName}\" (" + //
 <#list entity.propertiesColumns as property>
-                "'${property.columnName}' ${property.columnType}<#if property.constraints??> ${property.constraints} </#if><#if property_has_next>," +<#else>);");</#if> // ${property_index}: ${property.propertyName}
+                "\"${property.columnName}\" ${property.columnType}<#if property.constraints??> ${property.constraints} </#if><#if property_has_next>," +<#else>);");</#if> // ${property_index}: ${property.propertyName}
 </#list>
 <#if entity.indexes?has_content >
         // Add Indexes
 <#list entity.indexes as index>
         db.execSQL("CREATE <#if index.unique>UNIQUE </#if>INDEX " + constraint + "${index.name} ON ${entity.tableName}" +
                 " (<#list index.properties 
-as property>${property.columnName}<#if property_has_next>,</#if></#list>);");
+as property>\"${property.columnName}\"<#if property_has_next>,</#if></#list>);");
 </#list>
 </#if>         
     }
 
     /** Drops the underlying database table. */
     public static void dropTable(SQLiteDatabase db, boolean ifExists) {
-        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'${entity.tableName}'";
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "\"${entity.tableName}\"";
         db.execSQL(sql);
     }
 
@@ -127,16 +130,14 @@ as property>${property.columnName}<#if property_has_next>,</#if></#list>);");
 <#if property.notNull || entity.protobuf>
 <#if entity.protobuf>
         if(entity.has${property.propertyName?cap_first}()) {
-    </#if>        stmt.bind${toBindType[property.propertyType]}(${property_index + 1}, entity.get${property.propertyName?cap_first}()<#if
-     property.propertyType == "Boolean"> ? 1l: 0l</#if><#if property.propertyType == "Date">.getTime()</#if>);
+    </#if>        stmt.bind${toBindType[property.propertyType]}(${property_index + 1}, ${property.databaseValueExpressionNotNull});
 <#if entity.protobuf>
         }
 </#if>
 <#else> <#-- nullable, non-protobuff -->
-        ${property.javaType} ${property.propertyName} = entity.get${property.propertyName?cap_first}();
+        ${property.javaTypeInEntity} ${property.propertyName} = entity.get${property.propertyName?cap_first}();
         if (${property.propertyName} != null) {
-            stmt.bind${toBindType[property.propertyType]}(${property_index + 1}, ${property.propertyName}<#if
- property.propertyType == "Boolean"> ? 1l: 0l</#if><#if property.propertyType == "Date">.getTime()</#if>);
+            stmt.bind${toBindType[property.propertyType]}(${property_index + 1}, ${property.databaseValueExpression});
         }
 </#if>
 </#list>
@@ -200,11 +201,9 @@ as property>${property.columnName}<#if property_has_next>,</#if></#list>);");
 -->
         ${entity.className} entity = new ${entity.className}( //
 <#list entity.properties as property>
-            <#if !property.notNull>cursor.isNull(offset + ${property_index}) ? null : </#if><#if
-            property.propertyType == "Byte">(byte) </#if><#if
-            property.propertyType == "Date">new java.util.Date(</#if>cursor.get${toCursorType[property.propertyType]}(offset + ${property_index})<#if
-            property.propertyType == "Boolean"> != 0</#if><#if
-            property.propertyType == "Date">)</#if><#if property_has_next>,</#if> // ${property.propertyName}
+            <#if !property.notNull>cursor.isNull(offset + ${property_index}) ? null : </#if><#--
+            -->${property.getEntityValueExpression("cursor.get${toCursorType[property.propertyType]}(offset + ${property_index})")}<#--
+            --><#if property_has_next>,</#if> // ${property.propertyName}
 </#list>        
         );
         return entity;
@@ -225,11 +224,8 @@ as property>${property.columnName}<#if property_has_next>,</#if></#list>);");
         throw new UnsupportedOperationException("Protobuf objects cannot be modified");
 <#else> 
 <#list entity.properties as property>
-        entity.set${property.propertyName?cap_first}(<#if !property.notNull>cursor.isNull(offset + ${property_index}) ? null : </#if><#if
-            property.propertyType == "Byte">(byte) </#if><#if
-            property.propertyType == "Date">new java.util.Date(</#if>cursor.get${toCursorType[property.propertyType]}(offset + ${property_index})<#if
-            property.propertyType == "Boolean"> != 0</#if><#if
-            property.propertyType == "Date">)</#if>);
+        entity.set${property.propertyName?cap_first}(<#if !property.notNull>cursor.isNull(offset + ${property_index}) ? null : </#if><#--
+            -->${property.getEntityValueExpression("cursor.get${toCursorType[property.propertyType]}(offset + ${property_index})")});
 </#list>
 </#if>
      }
@@ -275,13 +271,20 @@ as property>${property.columnName}<#if property_has_next>,</#if></#list>);");
 <#list entity.incomingToManyRelations as toMany>
     /** Internal query to resolve the "${toMany.name}" to-many relationship of ${toMany.sourceEntity.className}. */
     public List<${toMany.targetEntity.className}> _query${toMany.sourceEntity.className?cap_first}_${toMany.name?cap_first}(<#--
-    --><#list toMany.targetProperties as property>${property.javaType} ${property.propertyName}<#if property_has_next>, </#if></#list>) {
+    --><#if toMany.targetProperties??><#list toMany.targetProperties as property><#--
+    -->${property.javaType} ${property.propertyName}<#if property_has_next>, </#if></#list><#else><#--
+    -->${toMany.sourceProperty.javaType} ${toMany.sourceProperty.propertyName}</#if>) {
         synchronized (this) {
             if (${toMany.sourceEntity.className?uncap_first}_${toMany.name?cap_first}Query == null) {
                 QueryBuilder<${toMany.targetEntity.className}> queryBuilder = queryBuilder();
-<#list toMany.targetProperties as property>
+<#if toMany.targetProperties??>
+    <#list toMany.targetProperties as property>
                 queryBuilder.where(Properties.${property.propertyName?cap_first}.eq(null));
-</#list>
+    </#list>
+<#else>
+                queryBuilder.join(${toMany.joinEntity.className}.class, ${toMany.joinEntity.classNameDao}.Properties.${toMany.targetProperty.propertyName?cap_first})
+                    .where(${toMany.joinEntity.classNameDao}.Properties.${toMany.sourceProperty.propertyName?cap_first}.eq(${toMany.sourceProperty.propertyName}));
+</#if>
 <#if toMany.order?has_content>
                 queryBuilder.orderRaw("${toMany.order}");
 </#if>
@@ -289,9 +292,13 @@ as property>${property.columnName}<#if property_has_next>,</#if></#list>);");
             }
         }
         Query<${toMany.targetEntity.className}> query = ${toMany.sourceEntity.className?uncap_first}_${toMany.name?cap_first}Query.forCurrentThread();
-<#list toMany.targetProperties as property>
+<#if toMany.targetProperties??>
+    <#list toMany.targetProperties as property>
         query.setParameter(${property_index}, ${property.propertyName});
-</#list>
+    </#list>
+<#else>
+        query.setParameter(0, ${toMany.sourceProperty.propertyName});
+</#if>
         return query.list();
     }
 
diff --git a/DaoGenerator/src-template/entity.ftl b/DaoGenerator/src-template/entity.ftl
index e40c0a18..0e383d84 100644
--- a/DaoGenerator/src-template/entity.ftl
+++ b/DaoGenerator/src-template/entity.ftl
@@ -1,6 +1,6 @@
 <#--
 
-Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)     
+Copyright (C) 2011-2015 Markus Junginger, greenrobot (http://greenrobot.de)
                                                                            
 This file is part of greenDAO Generator.                                   
                                                                            
@@ -44,9 +44,17 @@ import ${additionalImport};
 <#else>
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
 </#if>
+<#if entity.javaDoc ??>
+
+${entity.javaDoc}
+<#else>
 /**
- * Entity mapped to table ${entity.tableName}.
+ * Entity mapped to table "${entity.tableName}".
  */
+</#if>
+<#if entity.codeBeforeClass ??>
+${entity.codeBeforeClass}
+</#if>
 public class ${entity.className}<#if
 entity.superclass?has_content> extends ${entity.superclass} </#if><#if
 entity.interfacesToImplement?has_content> implements <#list entity.interfacesToImplement
@@ -56,7 +64,13 @@ as ifc>${ifc}<#if ifc_has_next>, </#if></#list></#if> {
 <#if property.notNull && complexTypes?seq_contains(property.propertyType)>
     /** Not-null value. */
 </#if>
-    private ${property.javaType} ${property.propertyName};
+<#if property.javaDocField ??>
+${property.javaDocField}
+</#if>
+<#if property.codeBeforeField ??>
+     ${property.codeBeforeField}
+</#if>
+    private ${property.javaTypeInEntity} ${property.propertyName};
 </#list>
 
 <#if entity.active>
@@ -99,7 +113,7 @@ property>${property.javaType} ${property.propertyName}<#if property_has_next>, <
 </#if>
 
     public ${entity.className}(<#list entity.properties as
-property>${property.javaType} ${property.propertyName}<#if property_has_next>, </#if></#list>) {
+property>${property.javaTypeInEntity} ${property.propertyName}<#if property_has_next>, </#if></#list>) {
 <#list entity.properties as property>
         this.${property.propertyName} = ${property.propertyName};
 </#list>
@@ -118,14 +132,26 @@ property>${property.javaType} ${property.propertyName}<#if property_has_next>, <
 <#if property.notNull && complexTypes?seq_contains(property.propertyType)>
     /** Not-null value. */
 </#if>
-    public ${property.javaType} get${property.propertyName?cap_first}() {
+<#if property.javaDocGetter ??>
+${property.javaDocGetter}
+</#if>
+<#if property.codeBeforeGetter ??>
+    ${property.codeBeforeGetter}
+</#if>
+    public ${property.javaTypeInEntity} get${property.propertyName?cap_first}() {
         return ${property.propertyName};
     }
 
 <#if property.notNull && complexTypes?seq_contains(property.propertyType)>
     /** Not-null value; ensure this value is available before it is saved to the database. */
 </#if>
-    public void set${property.propertyName?cap_first}(${property.javaType} ${property.propertyName}) {
+<#if property.javaDocSetter ??>
+${property.javaDocSetter}
+</#if>
+<#if property.codeBeforeSetter ??>
+    ${property.codeBeforeSetter}
+</#if>
+    public void set${property.propertyName?cap_first}(${property.javaTypeInEntity} ${property.propertyName}) {
         this.${property.propertyName} = ${property.propertyName};
     }
 
@@ -205,7 +231,8 @@ property>${property.javaType} ${property.propertyName}<#if property_has_next>, <
             }
             ${toMany.targetEntity.classNameDao} targetDao = daoSession.get${toMany.targetEntity.classNameDao?cap_first}();
             List<${toMany.targetEntity.className}> ${toMany.name}New = targetDao._query${toMany.sourceEntity.className?cap_first}_${toMany.name?cap_first}(<#--
-                --><#list toMany.sourceProperties as property>${property.propertyName}<#if property_has_next>, </#if></#list>);
+                --><#if toMany.sourceProperties??><#list toMany.sourceProperties as property>${property.propertyName}<#if property_has_next>, </#if></#list><#else><#--
+                -->${entity.pkProperty.propertyName}</#if>);
             synchronized (this) {<#-- Check if another thread was faster, we cannot lock while doing the query to prevent deadlocks -->
                 if(${toMany.name} == null) {
                     ${toMany.name} = ${toMany.name}New;
diff --git a/DaoGenerator/src-test/de/greenrobot/daogenerator/test/SimpleDaoGeneratorTest.java b/DaoGenerator/src-test/de/greenrobot/daogenerator/test/SimpleDaoGeneratorTest.java
index 8f17eea5..b1a9f583 100644
--- a/DaoGenerator/src-test/de/greenrobot/daogenerator/test/SimpleDaoGeneratorTest.java
+++ b/DaoGenerator/src-test/de/greenrobot/daogenerator/test/SimpleDaoGeneratorTest.java
@@ -1,65 +1,69 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daogenerator.test;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-
-import java.io.File;
-
-import org.junit.Test;
-
-import de.greenrobot.daogenerator.DaoGenerator;
-import de.greenrobot.daogenerator.DaoUtil;
-import de.greenrobot.daogenerator.Entity;
-import de.greenrobot.daogenerator.Property;
-import de.greenrobot.daogenerator.Schema;
-
-public class SimpleDaoGeneratorTest {
-
-    @Test
-    public void testMinimalSchema() throws Exception {
-        Schema schema = new Schema(1, "de.greenrobot.testdao");
-        Entity adressTable = schema.addEntity("Adresse");
-        Property idProperty = adressTable.addIdProperty().getProperty();
-        adressTable.addIntProperty("count").index();
-        adressTable.addIntProperty("dummy").notNull();
-        assertEquals(1, schema.getEntities().size());
-        assertEquals(3, adressTable.getProperties().size());
-
-        File daoFile = new File("test-out/de/greenrobot/testdao/" + adressTable.getClassName() + "Dao.java");
-        daoFile.delete();
-        assertFalse(daoFile.exists());
-
-        new DaoGenerator().generateAll(schema, "test-out");
-
-        assertEquals("PRIMARY KEY", idProperty.getConstraints());
-        assertTrue(daoFile.toString(), daoFile.exists());
-    }
-
-    @Test
-    public void testDbName() {
-        assertEquals("NORMAL", DaoUtil.dbName("normal"));
-        assertEquals("NORMAL", DaoUtil.dbName("Normal"));
-        assertEquals("CAMEL_CASE", DaoUtil.dbName("CamelCase"));
-        assertEquals("CAMEL_CASE_THREE", DaoUtil.dbName("CamelCaseThree"));
-        assertEquals("CAMEL_CASE_XXXX", DaoUtil.dbName("CamelCaseXXXX"));
-    }
-
-}
+/*
+ * Copyright (C) 2011-2015 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daogenerator.test;
+
+import de.greenrobot.daogenerator.DaoGenerator;
+import de.greenrobot.daogenerator.DaoUtil;
+import de.greenrobot.daogenerator.Entity;
+import de.greenrobot.daogenerator.Property;
+import de.greenrobot.daogenerator.Schema;
+import org.junit.Test;
+
+import java.io.File;
+
+import static org.junit.Assert.*;
+
+public class SimpleDaoGeneratorTest {
+
+    @Test
+    public void testMinimalSchema() throws Exception {
+        Schema schema = new Schema(1, "de.greenrobot.testdao");
+        Entity addressEntity = schema.addEntity("Addresse");
+        Property idProperty = addressEntity.addIdProperty().getProperty();
+        addressEntity.addIntProperty("count").index();
+        addressEntity.addIntProperty("dummy").notNull();
+        assertEquals(1, schema.getEntities().size());
+        assertEquals(3, addressEntity.getProperties().size());
+
+        File daoFile = new File("test-out/de/greenrobot/testdao/" + addressEntity.getClassName() + "Dao.java");
+        daoFile.delete();
+        assertFalse(daoFile.exists());
+
+        new DaoGenerator().generateAll(schema, "test-out");
+
+        assertEquals("PRIMARY KEY", idProperty.getConstraints());
+        assertTrue(daoFile.toString(), daoFile.exists());
+    }
+
+    @Test
+    public void testDbName() {
+        assertEquals("NORMAL", DaoUtil.dbName("normal"));
+        assertEquals("NORMAL", DaoUtil.dbName("Normal"));
+        assertEquals("CAMEL_CASE", DaoUtil.dbName("CamelCase"));
+        assertEquals("CAMEL_CASE_THREE", DaoUtil.dbName("CamelCaseThree"));
+        assertEquals("CAMEL_CASE_XXXX", DaoUtil.dbName("CamelCaseXXXX"));
+    }
+
+    @Test(expected = RuntimeException.class)
+    public void testInterfacesError() throws Exception {
+        Schema schema = new Schema(1, "de.greenrobot.testdao");
+        Entity addressTable = schema.addEntity("Addresse");
+        addressTable.implementsInterface("Dummy");
+        addressTable.implementsInterface("Dummy");
+    }
+}
diff --git a/DaoGenerator/src/de/greenrobot/daogenerator/ContentProvider.java b/DaoGenerator/src/de/greenrobot/daogenerator/ContentProvider.java
index d0483c2d..8fd0a28a 100644
--- a/DaoGenerator/src/de/greenrobot/daogenerator/ContentProvider.java
+++ b/DaoGenerator/src/de/greenrobot/daogenerator/ContentProvider.java
@@ -68,7 +68,7 @@ public void init2ndPass() {
             basePath = "";
         }
         if (className == null) {
-            className = "EntityContentProvider";
+            className = entities.get(0).getClassName() + "ContentProvider";
         }
         if (javaPackage == null) {
             javaPackage = schema.getDefaultJavaPackage();
diff --git a/DaoGenerator/src/de/greenrobot/daogenerator/DaoGenerator.java b/DaoGenerator/src/de/greenrobot/daogenerator/DaoGenerator.java
index 0f9ecdd8..bb25fe9a 100644
--- a/DaoGenerator/src/de/greenrobot/daogenerator/DaoGenerator.java
+++ b/DaoGenerator/src/de/greenrobot/daogenerator/DaoGenerator.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ * Copyright (C) 2011-2015 Markus Junginger, greenrobot (http://greenrobot.de)
  *
  * This file is part of greenDAO Generator.
  * 
@@ -28,12 +28,11 @@
 import java.util.regex.Pattern;
 
 import freemarker.template.Configuration;
-import freemarker.template.DefaultObjectWrapper;
 import freemarker.template.Template;
 
 /**
  * Once you have your model created, use this class to generate entities and DAOs.
- * 
+ *
  * @author Markus
  */
 public class DaoGenerator {
@@ -51,16 +50,15 @@
 
     public DaoGenerator() throws IOException {
         System.out.println("greenDAO Generator");
-        System.out.println("Copyright 2011-2014 Markus Junginger, greenrobot.de. Licensed under GPL V3.");
+        System.out.println("Copyright 2011-2015 Markus Junginger, greenrobot.de. Licensed under GPL V3.");
         System.out.println("This program comes with ABSOLUTELY NO WARRANTY");
 
         patternKeepIncludes = compilePattern("INCLUDES");
         patternKeepFields = compilePattern("FIELDS");
         patternKeepMethods = compilePattern("METHODS");
 
-        Configuration config = new Configuration();
+        Configuration config = new Configuration(Configuration.VERSION_2_3_23);
         config.setClassForTemplateLoading(this.getClass(), "/");
-        config.setObjectWrapper(new DefaultObjectWrapper());
 
         templateDao = config.getTemplate("dao.ftl");
         templateDaoMaster = config.getTemplate("dao-master.ftl");
@@ -78,22 +76,19 @@ private Pattern compilePattern(String sectionName) {
 
     /** Generates all entities and DAOs for the given schema. */
     public void generateAll(Schema schema, String outDir) throws Exception {
-        generateAll(schema, outDir, null);
+        generateAll(schema, outDir, null, null);
     }
 
     /** Generates all entities and DAOs for the given schema. */
-    public void generateAll(Schema schema, String outDir, String outDirTest) throws Exception {
+    public void generateAll(Schema schema, String outDir, String outDirEntity, String outDirTest) throws Exception {
         long start = System.currentTimeMillis();
 
         File outDirFile = toFileForceExists(outDir);
-
-        File outDirTestFile = null;
-        if (outDirTest != null) {
-            outDirTestFile = toFileForceExists(outDirTest);
-        }
+        File outDirEntityFile = outDirEntity != null? toFileForceExists(outDirEntity): outDirFile;
+        File outDirTestFile = outDirTest != null ? toFileForceExists(outDirTest) : null;
 
         schema.init2ndPass();
-        schema.init3ndPass();
+        schema.init3rdPass();
 
         System.out.println("Processing schema version " + schema.getVersion() + "...");
 
@@ -101,7 +96,7 @@ public void generateAll(Schema schema, String outDir, String outDirTest) throws
         for (Entity entity : entities) {
             generate(templateDao, outDirFile, entity.getJavaPackageDao(), entity.getClassNameDao(), schema, entity);
             if (!entity.isProtobuf() && !entity.isSkipGeneration()) {
-                generate(templateEntity, outDirFile, entity.getJavaPackage(), entity.getClassName(), schema, entity);
+                generate(templateEntity, outDirEntityFile, entity.getJavaPackage(), entity.getClassName(), schema, entity);
             }
             if (outDirTestFile != null && !entity.isSkipGenerationTest()) {
                 String javaPackageTest = entity.getJavaPackageTest();
@@ -137,12 +132,12 @@ protected File toFileForceExists(String filename) throws IOException {
     }
 
     private void generate(Template template, File outDirFile, String javaPackage, String javaClassName, Schema schema,
-            Entity entity) throws Exception {
+                          Entity entity) throws Exception {
         generate(template, outDirFile, javaPackage, javaClassName, schema, entity, null);
     }
 
     private void generate(Template template, File outDirFile, String javaPackage, String javaClassName, Schema schema,
-            Entity entity, Map<String, Object> additionalObjectsForTemplate) throws Exception {
+                          Entity entity, Map<String, Object> additionalObjectsForTemplate) throws Exception {
         Map<String, Object> root = new HashMap<String, Object>();
         root.put("schema", schema);
         root.put("entity", entity);
diff --git a/DaoGenerator/src/de/greenrobot/daogenerator/DaoUtil.java b/DaoGenerator/src/de/greenrobot/daogenerator/DaoUtil.java
index 88a65867..a8a2e965 100644
--- a/DaoGenerator/src/de/greenrobot/daogenerator/DaoUtil.java
+++ b/DaoGenerator/src/de/greenrobot/daogenerator/DaoUtil.java
@@ -1,87 +1,114 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daogenerator;
-
-import java.io.ByteArrayOutputStream;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-
-/** Internal API */
-public class DaoUtil {
-    public static String dbName(String javaName) {
-        StringBuilder builder = new StringBuilder(javaName);
-        for (int i = 1; i < builder.length(); i++) {
-            boolean lastWasUpper = Character.isUpperCase(builder.charAt(i - 1));
-            boolean isUpper = Character.isUpperCase(builder.charAt(i));
-            if (isUpper && !lastWasUpper) {
-                builder.insert(i, '_');
-                i++;
-            }
-        }
-        return builder.toString().toUpperCase();
-    }
-    
-    public static byte[] readAllBytes(InputStream in) throws IOException {
-        ByteArrayOutputStream out = new ByteArrayOutputStream();
-        copyAllBytes(in, out);
-        return out.toByteArray();
-    }
-    
-    public static byte[] readAllBytes(File file) throws IOException {
-        FileInputStream is = new FileInputStream(file);
-        try {
-            return DaoUtil.readAllBytes(is);
-        } finally {
-            is.close();
-        }
-    }
-    
-    public static byte[] readAllBytes(String filename) throws IOException {
-        FileInputStream is = new FileInputStream(filename);
-        try {
-            return DaoUtil.readAllBytes(is);
-        } finally {
-            is.close();
-        }
-    }
-    
-    /**
-     * Copies all available data from in to out without closing any stream.
-     * 
-     * @return number of bytes copied
-     */
-    public static int copyAllBytes(InputStream in, OutputStream out) throws IOException {
-        int byteCount = 0;
-        byte[] buffer = new byte[4096];
-        while (true) {
-            int read = in.read(buffer);
-            if (read == -1) {
-                break;
-            }
-            out.write(buffer, 0, read);
-            byteCount += read;
-        }
-        return byteCount;
-    }
-    
-
-
-}
+/*
+ * Copyright (C) 2011-2015 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daogenerator;
+
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+
+/** Internal API */
+public class DaoUtil {
+    public static String dbName(String javaName) {
+        StringBuilder builder = new StringBuilder(javaName);
+        for (int i = 1; i < builder.length(); i++) {
+            boolean lastWasUpper = Character.isUpperCase(builder.charAt(i - 1));
+            boolean isUpper = Character.isUpperCase(builder.charAt(i));
+            if (isUpper && !lastWasUpper) {
+                builder.insert(i, '_');
+                i++;
+            }
+        }
+        return builder.toString().toUpperCase();
+    }
+
+    public static String getClassnameFromFullyQualified(String clazz) {
+        int index = clazz.lastIndexOf('.');
+        if (index != -1) {
+            return clazz.substring(index + 1);
+        } else {
+            return clazz;
+        }
+    }
+
+    public static String capFirst(String string) {
+        return Character.toUpperCase(string.charAt(0)) + (string.length() > 1 ? string.substring(1) : "");
+    }
+
+    public static String getPackageFromFullyQualified(String clazz) {
+        int index = clazz.lastIndexOf('.');
+        if (index != -1) {
+            return clazz.substring(0, index);
+        } else {
+            return null;
+        }
+    }
+
+    public static byte[] readAllBytes(InputStream in) throws IOException {
+        ByteArrayOutputStream out = new ByteArrayOutputStream();
+        copyAllBytes(in, out);
+        return out.toByteArray();
+    }
+
+    public static byte[] readAllBytes(File file) throws IOException {
+        FileInputStream is = new FileInputStream(file);
+        try {
+            return DaoUtil.readAllBytes(is);
+        } finally {
+            is.close();
+        }
+    }
+
+    public static byte[] readAllBytes(String filename) throws IOException {
+        FileInputStream is = new FileInputStream(filename);
+        try {
+            return DaoUtil.readAllBytes(is);
+        } finally {
+            is.close();
+        }
+    }
+
+    /**
+     * Copies all available data from in to out without closing any stream.
+     *
+     * @return number of bytes copied
+     */
+    public static int copyAllBytes(InputStream in, OutputStream out) throws IOException {
+        int byteCount = 0;
+        byte[] buffer = new byte[4096];
+        while (true) {
+            int read = in.read(buffer);
+            if (read == -1) {
+                break;
+            }
+            out.write(buffer, 0, read);
+            byteCount += read;
+        }
+        return byteCount;
+    }
+
+    public static String checkConvertToJavaDoc(String javaDoc, String indent) {
+        if (javaDoc != null && !javaDoc.trim().startsWith("/**")) {
+            javaDoc = javaDoc.replace("\n", "\n" + indent + " * ");
+            javaDoc = indent + "/**\n" + indent + " * " + javaDoc + "\n" + indent + " */";
+        }
+        return javaDoc;
+    }
+}
diff --git a/DaoGenerator/src/de/greenrobot/daogenerator/Entity.java b/DaoGenerator/src/de/greenrobot/daogenerator/Entity.java
index dc8b1049..da865a42 100644
--- a/DaoGenerator/src/de/greenrobot/daogenerator/Entity.java
+++ b/DaoGenerator/src/de/greenrobot/daogenerator/Entity.java
@@ -1,619 +1,688 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daogenerator;
-
-import de.greenrobot.daogenerator.Property.PropertyBuilder;
-
-import java.util.*;
-
-/**
- * Model class for an entity: a Java data object mapped to a data base table. A new entity is added to a {@link Schema}
- * by the method {@link Schema#addEntity(String)} (there is no public constructor for {@link Entity} itself). <br/>
- * <br/> Use the various addXXX methods to add entity properties, indexes, and relations to other entities (addToOne,
- * addToMany).<br/> <br/> There are further configuration possibilities: <ul> <li>{@link
- * Entity#implementsInterface(String...)} and {@link #implementsSerializable()} to specify interfaces the entity will
- * implement</li> <li>{@link #setSuperclass(String)} to specify a class of which the entity will extend from</li>
- * <li>Various setXXX methods</li> </ul>
- *
- * @see <a href="http://greendao-orm.com/documentation/modelling-entities/">Modelling Entities (Documentation page)</a>
- * @see <a href="http://greendao-orm.com/documentation/relations/">Relations (Documentation page)</a>
- */
-public class Entity {
-    private final Schema schema;
-    private final String className;
-    private final List<Property> properties;
-    private List<Property> propertiesColumns;
-    private final List<Property> propertiesPk;
-    private final List<Property> propertiesNonPk;
-    private final Set<String> propertyNames;
-    private final List<Index> indexes;
-    private final List<ToOne> toOneRelations;
-    private final List<ToMany> toManyRelations;
-    private final List<ToMany> incomingToManyRelations;
-    private final Collection<String> additionalImportsEntity;
-    private final Collection<String> additionalImportsDao;
-    private final List<String> interfacesToImplement;
-    private final List<ContentProvider> contentProviders;
-
-    private String tableName;
-    private String classNameDao;
-    private String classNameTest;
-    private String javaPackage;
-    private String javaPackageDao;
-    private String javaPackageTest;
-    private Property pkProperty;
-    private String pkType;
-    private String superclass;
-
-    private boolean protobuf;
-    private boolean constructors;
-    private boolean skipGeneration;
-    private boolean skipGenerationTest;
-    private boolean skipTableCreation;
-    private Boolean active;
-    private Boolean hasKeepSections;
-
-    Entity(Schema schema, String className) {
-        this.schema = schema;
-        this.className = className;
-        properties = new ArrayList<Property>();
-        propertiesPk = new ArrayList<Property>();
-        propertiesNonPk = new ArrayList<Property>();
-        propertyNames = new HashSet<String>();
-        indexes = new ArrayList<Index>();
-        toOneRelations = new ArrayList<ToOne>();
-        toManyRelations = new ArrayList<ToMany>();
-        incomingToManyRelations = new ArrayList<ToMany>();
-        additionalImportsEntity = new TreeSet<String>();
-        additionalImportsDao = new TreeSet<String>();
-        interfacesToImplement = new ArrayList<String>();
-        contentProviders = new ArrayList<ContentProvider>();
-        constructors = true;
-    }
-
-    public PropertyBuilder addBooleanProperty(String propertyName) {
-        return addProperty(PropertyType.Boolean, propertyName);
-    }
-
-    public PropertyBuilder addByteProperty(String propertyName) {
-        return addProperty(PropertyType.Byte, propertyName);
-    }
-
-    public PropertyBuilder addShortProperty(String propertyName) {
-        return addProperty(PropertyType.Short, propertyName);
-    }
-
-    public PropertyBuilder addIntProperty(String propertyName) {
-        return addProperty(PropertyType.Int, propertyName);
-    }
-
-    public PropertyBuilder addLongProperty(String propertyName) {
-        return addProperty(PropertyType.Long, propertyName);
-    }
-
-    public PropertyBuilder addFloatProperty(String propertyName) {
-        return addProperty(PropertyType.Float, propertyName);
-    }
-
-    public PropertyBuilder addDoubleProperty(String propertyName) {
-        return addProperty(PropertyType.Double, propertyName);
-    }
-
-    public PropertyBuilder addByteArrayProperty(String propertyName) {
-        return addProperty(PropertyType.ByteArray, propertyName);
-    }
-
-    public PropertyBuilder addStringProperty(String propertyName) {
-        return addProperty(PropertyType.String, propertyName);
-    }
-
-    public PropertyBuilder addDateProperty(String propertyName) {
-        return addProperty(PropertyType.Date, propertyName);
-    }
-
-    public PropertyBuilder addProperty(PropertyType propertyType, String propertyName) {
-        if (!propertyNames.add(propertyName)) {
-            throw new RuntimeException("Property already defined: " + propertyName);
-        }
-        PropertyBuilder builder = new Property.PropertyBuilder(schema, this, propertyType, propertyName);
-        properties.add(builder.getProperty());
-        return builder;
-    }
-
-    /** Adds a standard _id column required by standard Android classes, e.g. list adapters. */
-    public PropertyBuilder addIdProperty() {
-        PropertyBuilder builder = addLongProperty("id");
-        builder.columnName("_id").primaryKey();
-        return builder;
-    }
-
-    /** Adds a to-many relationship; the target entity is joined to the PK property of this entity (typically the ID). */
-    public ToMany addToMany(Entity target, Property targetProperty) {
-        Property[] targetProperties = {targetProperty};
-        return addToMany(null, target, targetProperties);
-    }
-
-    /**
-     * Convenience method for {@link Entity#addToMany(Entity, Property)} with a subsequent call to {@link
-     * ToMany#setName(String)}.
-     */
-    public ToMany addToMany(Entity target, Property targetProperty, String name) {
-        ToMany toMany = addToMany(target, targetProperty);
-        toMany.setName(name);
-        return toMany;
-    }
-
-    /**
-     * Add a to-many relationship; the target entity is joined using the given target property (of the target entity)
-     * and given source property (of this entity).
-     */
-    public ToMany addToMany(Property sourceProperty, Entity target, Property targetProperty) {
-        Property[] sourceProperties = {sourceProperty};
-        Property[] targetProperties = {targetProperty};
-        return addToMany(sourceProperties, target, targetProperties);
-    }
-
-    public ToMany addToMany(Property[] sourceProperties, Entity target, Property[] targetProperties) {
-        if (protobuf) {
-            throw new IllegalStateException("Protobuf entities do not support realtions, currently");
-        }
-
-        ToMany toMany = new ToMany(schema, this, sourceProperties, target, targetProperties);
-        toManyRelations.add(toMany);
-        target.incomingToManyRelations.add(toMany);
-        return toMany;
-    }
-
-    /**
-     * Adds a to-one relationship to the given target entity using the given given foreign key property (which belongs
-     * to this entity).
-     */
-    public ToOne addToOne(Entity target, Property fkProperty) {
-        if (protobuf) {
-            throw new IllegalStateException("Protobuf entities do not support realtions, currently");
-        }
-
-        Property[] fkProperties = {fkProperty};
-        ToOne toOne = new ToOne(schema, this, target, fkProperties, true);
-        toOneRelations.add(toOne);
-        return toOne;
-    }
-
-    /** Convenience for {@link #addToOne(Entity, Property)} with a subsequent call to {@link ToOne#setName(String)}. */
-    public ToOne addToOne(Entity target, Property fkProperty, String name) {
-        ToOne toOne = addToOne(target, fkProperty);
-        toOne.setName(name);
-        return toOne;
-    }
-
-    public ToOne addToOneWithoutProperty(String name, Entity target, String fkColumnName) {
-        return addToOneWithoutProperty(name, target, fkColumnName, false, false);
-    }
-
-    public ToOne addToOneWithoutProperty(String name, Entity target, String fkColumnName, boolean notNull,
-                                         boolean unique) {
-        PropertyBuilder propertyBuilder = new PropertyBuilder(schema, this, null, name);
-        if (notNull) {
-            propertyBuilder.notNull();
-        }
-        if (unique) {
-            propertyBuilder.unique();
-        }
-        propertyBuilder.columnName(fkColumnName);
-        Property column = propertyBuilder.getProperty();
-        Property[] fkColumns = {column};
-        ToOne toOne = new ToOne(schema, this, target, fkColumns, false);
-        toOne.setName(name);
-        toOneRelations.add(toOne);
-        return toOne;
-    }
-
-    protected void addIncomingToMany(ToMany toMany) {
-        incomingToManyRelations.add(toMany);
-    }
-
-    public ContentProvider addContentProvider() {
-        List<Entity> entities = new ArrayList<Entity>();
-        ContentProvider contentProvider = new ContentProvider(schema, entities);
-        contentProviders.add(contentProvider);
-        return contentProvider;
-    }
-
-    /** Adds a new index to the entity. */
-    public Entity addIndex(Index index) {
-        indexes.add(index);
-        return this;
-    }
-
-    /** The entity is represented by a protocol buffers object. Requires some special actions like using builders. */
-    Entity useProtobuf() {
-        protobuf = true;
-        return this;
-    }
-
-    public boolean isProtobuf() {
-        return protobuf;
-    }
-
-    public Schema getSchema() {
-        return schema;
-    }
-
-    public String getTableName() {
-        return tableName;
-    }
-
-    public void setTableName(String tableName) {
-        this.tableName = tableName;
-    }
-
-    public String getClassName() {
-        return className;
-    }
-
-    public List<Property> getProperties() {
-        return properties;
-    }
-
-    public List<Property> getPropertiesColumns() {
-        return propertiesColumns;
-    }
-
-    public String getJavaPackage() {
-        return javaPackage;
-    }
-
-    public void setJavaPackage(String javaPackage) {
-        this.javaPackage = javaPackage;
-    }
-
-    public String getJavaPackageDao() {
-        return javaPackageDao;
-    }
-
-    public void setJavaPackageDao(String javaPackageDao) {
-        this.javaPackageDao = javaPackageDao;
-    }
-
-    public String getClassNameDao() {
-        return classNameDao;
-    }
-
-    public void setClassNameDao(String classNameDao) {
-        this.classNameDao = classNameDao;
-    }
-
-    public String getClassNameTest() {
-        return classNameTest;
-    }
-
-    public void setClassNameTest(String classNameTest) {
-        this.classNameTest = classNameTest;
-    }
-
-    public String getJavaPackageTest() {
-        return javaPackageTest;
-    }
-
-    public void setJavaPackageTest(String javaPackageTest) {
-        this.javaPackageTest = javaPackageTest;
-    }
-
-    public List<Property> getPropertiesPk() {
-        return propertiesPk;
-    }
-
-    public List<Property> getPropertiesNonPk() {
-        return propertiesNonPk;
-    }
-
-    public Property getPkProperty() {
-        return pkProperty;
-    }
-
-    public List<Index> getIndexes() {
-        return indexes;
-    }
-
-    public String getPkType() {
-        return pkType;
-    }
-
-    public boolean isConstructors() {
-        return constructors;
-    }
-
-    public void setConstructors(boolean constructors) {
-        this.constructors = constructors;
-    }
-
-    public boolean isSkipGeneration() {
-        return skipGeneration;
-    }
-
-    /**
-     * Flag if the entity's code generation should be skipped. E.g. if you need to change the class after initial
-     * generation.
-     */
-    public void setSkipGeneration(boolean skipGeneration) {
-        this.skipGeneration = skipGeneration;
-    }
-
-    /** Flag if CREATE & DROP TABLE scripts should be skipped in Dao. */
-    public void setSkipTableCreation(boolean skipTableCreation) {
-        this.skipTableCreation = skipTableCreation;
-    }
-
-    public boolean isSkipTableCreation() {
-        return skipTableCreation;
-    }
-
-    public boolean isSkipGenerationTest() {
-        return skipGenerationTest;
-    }
-
-    public void setSkipGenerationTest(boolean skipGenerationTest) {
-        this.skipGenerationTest = skipGenerationTest;
-    }
-
-    public List<ToOne> getToOneRelations() {
-        return toOneRelations;
-    }
-
-    public List<ToMany> getToManyRelations() {
-        return toManyRelations;
-    }
-
-    public List<ToMany> getIncomingToManyRelations() {
-        return incomingToManyRelations;
-    }
-
-    /**
-     * Entities with relations are active, but this method allows to make the entities active even if it does not have
-     * relations.
-     */
-    public void setActive(Boolean active) {
-        this.active = active;
-    }
-
-    public Boolean getActive() {
-        return active;
-    }
-
-    public Boolean getHasKeepSections() {
-        return hasKeepSections;
-    }
-
-    public Collection<String> getAdditionalImportsEntity() {
-        return additionalImportsEntity;
-    }
-
-    public Collection<String> getAdditionalImportsDao() {
-        return additionalImportsDao;
-    }
-
-    public void setHasKeepSections(Boolean hasKeepSections) {
-        this.hasKeepSections = hasKeepSections;
-    }
-
-    public List<String> getInterfacesToImplement() {
-        return interfacesToImplement;
-    }
-
-    public List<ContentProvider> getContentProviders() {
-        return contentProviders;
-    }
-
-    public void implementsInterface(String... interfaces) {
-        for (String interfaceToImplement : interfaces) {
-            interfacesToImplement.add(interfaceToImplement);
-        }
-    }
-
-    public void implementsSerializable() {
-        interfacesToImplement.add("java.io.Serializable");
-    }
-
-    public String getSuperclass() {
-        return superclass;
-    }
-
-    public void setSuperclass(String classToExtend) {
-        this.superclass = classToExtend;
-    }
-
-    void init2ndPass() {
-        init2nPassNamesWithDefaults();
-
-        for (int i = 0; i < properties.size(); i++) {
-            Property property = properties.get(i);
-            property.setOrdinal(i);
-            property.init2ndPass();
-            if (property.isPrimaryKey()) {
-                propertiesPk.add(property);
-            } else {
-                propertiesNonPk.add(property);
-            }
-        }
-
-        if (propertiesPk.size() == 1) {
-            pkProperty = propertiesPk.get(0);
-            pkType = schema.mapToJavaTypeNullable(pkProperty.getPropertyType());
-        } else {
-            pkType = "Void";
-        }
-
-        propertiesColumns = new ArrayList<Property>(properties);
-        for (ToOne toOne : toOneRelations) {
-            toOne.init2ndPass();
-            Property[] fkProperties = toOne.getFkProperties();
-            for (Property fkProperty : fkProperties) {
-                if (!propertiesColumns.contains(fkProperty)) {
-                    propertiesColumns.add(fkProperty);
-                }
-            }
-        }
-
-        for (ToMany toMany : toManyRelations) {
-            toMany.init2ndPass();
-            // Source Properties may not be virtual, so we do not need the following code:
-            // for (Property sourceProperty : toMany.getSourceProperties()) {
-            // if (!propertiesColumns.contains(sourceProperty)) {
-            // propertiesColumns.add(sourceProperty);
-            // }
-            // }
-        }
-
-        if (active == null) {
-            active = schema.isUseActiveEntitiesByDefault();
-        }
-        active |= !toOneRelations.isEmpty() || !toManyRelations.isEmpty();
-
-        if (hasKeepSections == null) {
-            hasKeepSections = schema.isHasKeepSectionsByDefault();
-        }
-
-        init2ndPassIndexNamesWithDefaults();
-
-        for (ContentProvider contentProvider : contentProviders) {
-            contentProvider.init2ndPass();
-        }
-    }
-
-    protected void init2nPassNamesWithDefaults() {
-        if (tableName == null) {
-            tableName = DaoUtil.dbName(className);
-        }
-
-        if (classNameDao == null) {
-            classNameDao = className + "Dao";
-        }
-        if (classNameTest == null) {
-            classNameTest = className + "Test";
-        }
-
-        if (javaPackage == null) {
-            javaPackage = schema.getDefaultJavaPackage();
-        }
-
-        if (javaPackageDao == null) {
-            javaPackageDao = schema.getDefaultJavaPackageDao();
-            if (javaPackageDao == null) {
-                javaPackageDao = javaPackage;
-            }
-        }
-        if (javaPackageTest == null) {
-            javaPackageTest = schema.getDefaultJavaPackageTest();
-            if (javaPackageTest == null) {
-                javaPackageTest = javaPackage;
-            }
-        }
-    }
-
-    protected void init2ndPassIndexNamesWithDefaults() {
-        for (int i = 0; i < indexes.size(); i++) {
-            Index index = indexes.get(i);
-            if (index.getName() == null) {
-                String indexName = "IDX_" + getTableName();
-                List<Property> properties = index.getProperties();
-                for (int j = 0; j < properties.size(); j++) {
-                    Property property = properties.get(j);
-                    indexName += "_" + property.getColumnName();
-                    if ("DESC".equalsIgnoreCase(index.getPropertiesOrder().get(j))) {
-                        indexName += "_DESC";
-                    }
-                }
-                // TODO can this get too long? how to shorten reliably without depending on the order (i)
-                index.setName(indexName);
-            }
-        }
-    }
-
-    void init3ndPass() {
-        for (Property property : properties) {
-            property.init3ndPass();
-        }
-
-        init3rdPassRelations();
-        init3rdPassAdditionalImports();
-    }
-
-    private void init3rdPassRelations() {
-        Set<String> toOneNames = new HashSet<String>();
-        for (ToOne toOne : toOneRelations) {
-            toOne.init3ndPass();
-            if (!toOneNames.add(toOne.getName().toLowerCase())) {
-                throw new RuntimeException("Duplicate name for " + toOne);
-            }
-        }
-
-        Set<String> toManyNames = new HashSet<String>();
-        for (ToMany toMany : toManyRelations) {
-            toMany.init3ndPass();
-            Entity targetEntity = toMany.getTargetEntity();
-            for (Property targetProperty : toMany.getTargetProperties()) {
-                if (!targetEntity.propertiesColumns.contains(targetProperty)) {
-                    targetEntity.propertiesColumns.add(targetProperty);
-                }
-            }
-            if (!toManyNames.add(toMany.getName().toLowerCase())) {
-                throw new RuntimeException("Duplicate name for " + toMany);
-            }
-        }
-    }
-
-    private void init3rdPassAdditionalImports() {
-        if (active && !javaPackage.equals(javaPackageDao)) {
-            additionalImportsEntity.add(javaPackageDao + "." + classNameDao);
-        }
-
-        for (ToOne toOne : toOneRelations) {
-            Entity targetEntity = toOne.getTargetEntity();
-            checkAdditionalImportsEntityTargetEntity(targetEntity);
-            // For deep loading
-            if (!targetEntity.getJavaPackage().equals(javaPackageDao)) {
-                additionalImportsDao.add(targetEntity.getJavaPackage() + "." + targetEntity.getClassName());
-            }
-        }
-
-        for (ToMany toMany : toManyRelations) {
-            Entity targetEntity = toMany.getTargetEntity();
-            checkAdditionalImportsEntityTargetEntity(targetEntity);
-        }
-    }
-
-    private void checkAdditionalImportsEntityTargetEntity(Entity targetEntity) {
-        if (!targetEntity.getJavaPackage().equals(javaPackage)) {
-            additionalImportsEntity.add(targetEntity.getJavaPackage() + "." + targetEntity.getClassName());
-        }
-        if (!targetEntity.getJavaPackageDao().equals(javaPackage)) {
-            additionalImportsEntity.add(targetEntity.getJavaPackageDao() + "." + targetEntity.getClassNameDao());
-        }
-    }
-
-    public void validatePropertyExists(Property property) {
-        if (!properties.contains(property)) {
-            throw new RuntimeException("Property " + property + " does not exist in " + this);
-        }
-    }
-
-    @Override
-    public String toString() {
-        return "Entity " + className + " (package: " + javaPackage + ")";
-    }
-}
+/*
+ * Copyright (C) 2011-2015 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daogenerator;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import java.util.TreeSet;
+
+import de.greenrobot.daogenerator.Property.PropertyBuilder;
+
+/**
+ * Model class for an entity: a Java data object mapped to a data base table. A new entity is added to a {@link Schema}
+ * by the method {@link Schema#addEntity(String)} (there is no public constructor for {@link Entity} itself). <br/>
+ * <br/> Use the various addXXX methods to add entity properties, indexes, and relations to other entities (addToOne,
+ * addToMany).<br/> <br/> There are further configuration possibilities: <ul> <li>{@link
+ * Entity#implementsInterface(String...)} and {@link #implementsSerializable()} to specify interfaces the entity will
+ * implement</li> <li>{@link #setSuperclass(String)} to specify a class of which the entity will extend from</li>
+ * <li>Various setXXX methods</li> </ul>
+ *
+ * @see <a href="http://greendao-orm.com/documentation/modelling-entities/">Modelling Entities (Documentation page)</a>
+ * @see <a href="http://greendao-orm.com/documentation/relations/">Relations (Documentation page)</a>
+ */
+public class Entity {
+    private final Schema schema;
+    private final String className;
+    private final List<Property> properties;
+    private List<Property> propertiesColumns;
+    private final List<Property> propertiesPk;
+    private final List<Property> propertiesNonPk;
+    private final Set<String> propertyNames;
+    private final List<Index> indexes;
+    private final List<ToOne> toOneRelations;
+    private final List<ToManyBase> toManyRelations;
+    private final List<ToManyBase> incomingToManyRelations;
+    private final Collection<String> additionalImportsEntity;
+    private final Collection<String> additionalImportsDao;
+    private final List<String> interfacesToImplement;
+    private final List<ContentProvider> contentProviders;
+
+    private String tableName;
+    private String classNameDao;
+    private String classNameTest;
+    private String javaPackage;
+    private String javaPackageDao;
+    private String javaPackageTest;
+    private Property pkProperty;
+    private String pkType;
+    private String superclass;
+    private String javaDoc;
+    private String codeBeforeClass;
+
+    private boolean protobuf;
+    private boolean constructors;
+    private boolean skipGeneration;
+    private boolean skipGenerationTest;
+    private boolean skipTableCreation;
+    private Boolean active;
+    private Boolean hasKeepSections;
+
+    Entity(Schema schema, String className) {
+        this.schema = schema;
+        this.className = className;
+        properties = new ArrayList<Property>();
+        propertiesPk = new ArrayList<Property>();
+        propertiesNonPk = new ArrayList<Property>();
+        propertyNames = new HashSet<String>();
+        indexes = new ArrayList<Index>();
+        toOneRelations = new ArrayList<ToOne>();
+        toManyRelations = new ArrayList<ToManyBase>();
+        incomingToManyRelations = new ArrayList<ToManyBase>();
+        additionalImportsEntity = new TreeSet<String>();
+        additionalImportsDao = new TreeSet<String>();
+        interfacesToImplement = new ArrayList<String>();
+        contentProviders = new ArrayList<ContentProvider>();
+        constructors = true;
+    }
+
+    public PropertyBuilder addBooleanProperty(String propertyName) {
+        return addProperty(PropertyType.Boolean, propertyName);
+    }
+
+    public PropertyBuilder addByteProperty(String propertyName) {
+        return addProperty(PropertyType.Byte, propertyName);
+    }
+
+    public PropertyBuilder addShortProperty(String propertyName) {
+        return addProperty(PropertyType.Short, propertyName);
+    }
+
+    public PropertyBuilder addIntProperty(String propertyName) {
+        return addProperty(PropertyType.Int, propertyName);
+    }
+
+    public PropertyBuilder addLongProperty(String propertyName) {
+        return addProperty(PropertyType.Long, propertyName);
+    }
+
+    public PropertyBuilder addFloatProperty(String propertyName) {
+        return addProperty(PropertyType.Float, propertyName);
+    }
+
+    public PropertyBuilder addDoubleProperty(String propertyName) {
+        return addProperty(PropertyType.Double, propertyName);
+    }
+
+    public PropertyBuilder addByteArrayProperty(String propertyName) {
+        return addProperty(PropertyType.ByteArray, propertyName);
+    }
+
+    public PropertyBuilder addStringProperty(String propertyName) {
+        return addProperty(PropertyType.String, propertyName);
+    }
+
+    public PropertyBuilder addDateProperty(String propertyName) {
+        return addProperty(PropertyType.Date, propertyName);
+    }
+
+    public PropertyBuilder addProperty(PropertyType propertyType, String propertyName) {
+        if (!propertyNames.add(propertyName)) {
+            throw new RuntimeException("Property already defined: " + propertyName);
+        }
+        PropertyBuilder builder = new Property.PropertyBuilder(schema, this, propertyType, propertyName);
+        properties.add(builder.getProperty());
+        return builder;
+    }
+
+    /** Adds a standard _id column required by standard Android classes, e.g. list adapters. */
+    public PropertyBuilder addIdProperty() {
+        PropertyBuilder builder = addLongProperty("id");
+        builder.columnName("_id").primaryKey();
+        return builder;
+    }
+
+    /** Adds a to-many relationship; the target entity is joined to the PK property of this entity (typically the ID). */
+    public ToMany addToMany(Entity target, Property targetProperty) {
+        Property[] targetProperties = {targetProperty};
+        return addToMany(null, target, targetProperties);
+    }
+
+    /**
+     * Convenience method for {@link Entity#addToMany(Entity, Property)} with a subsequent call to {@link
+     * ToMany#setName(String)}.
+     */
+    public ToMany addToMany(Entity target, Property targetProperty, String name) {
+        ToMany toMany = addToMany(target, targetProperty);
+        toMany.setName(name);
+        return toMany;
+    }
+
+    /**
+     * Add a to-many relationship; the target entity is joined using the given target property (of the target entity)
+     * and given source property (of this entity).
+     */
+    public ToMany addToMany(Property sourceProperty, Entity target, Property targetProperty) {
+        Property[] sourceProperties = {sourceProperty};
+        Property[] targetProperties = {targetProperty};
+        return addToMany(sourceProperties, target, targetProperties);
+    }
+
+    public ToMany addToMany(Property[] sourceProperties, Entity target, Property[] targetProperties) {
+        if (protobuf) {
+            throw new IllegalStateException("Protobuf entities do not support relations, currently");
+        }
+
+        ToMany toMany = new ToMany(schema, this, sourceProperties, target, targetProperties);
+        toManyRelations.add(toMany);
+        target.incomingToManyRelations.add(toMany);
+        return toMany;
+    }
+
+    public ToManyWithJoinEntity addToMany(Entity target, Entity joinEntity, Property id1, Property id2) {
+        ToManyWithJoinEntity toMany = new ToManyWithJoinEntity(schema, this, target, joinEntity, id1, id2);
+        toManyRelations.add(toMany);
+        target.incomingToManyRelations.add(toMany);
+        return toMany;
+    }
+
+
+    /**
+     * Adds a to-one relationship to the given target entity using the given given foreign key property (which belongs
+     * to this entity).
+     */
+    public ToOne addToOne(Entity target, Property fkProperty) {
+        if (protobuf) {
+            throw new IllegalStateException("Protobuf entities do not support realtions, currently");
+        }
+
+        Property[] fkProperties = {fkProperty};
+        ToOne toOne = new ToOne(schema, this, target, fkProperties, true);
+        toOneRelations.add(toOne);
+        return toOne;
+    }
+
+    /** Convenience for {@link #addToOne(Entity, Property)} with a subsequent call to {@link ToOne#setName(String)}. */
+    public ToOne addToOne(Entity target, Property fkProperty, String name) {
+        ToOne toOne = addToOne(target, fkProperty);
+        toOne.setName(name);
+        return toOne;
+    }
+
+    public ToOne addToOneWithoutProperty(String name, Entity target, String fkColumnName) {
+        return addToOneWithoutProperty(name, target, fkColumnName, false, false);
+    }
+
+    public ToOne addToOneWithoutProperty(String name, Entity target, String fkColumnName, boolean notNull,
+                                         boolean unique) {
+        PropertyBuilder propertyBuilder = new PropertyBuilder(schema, this, null, name);
+        if (notNull) {
+            propertyBuilder.notNull();
+        }
+        if (unique) {
+            propertyBuilder.unique();
+        }
+        propertyBuilder.columnName(fkColumnName);
+        Property column = propertyBuilder.getProperty();
+        Property[] fkColumns = {column};
+        ToOne toOne = new ToOne(schema, this, target, fkColumns, false);
+        toOne.setName(name);
+        toOneRelations.add(toOne);
+        return toOne;
+    }
+
+    protected void addIncomingToMany(ToMany toMany) {
+        incomingToManyRelations.add(toMany);
+    }
+
+    public ContentProvider addContentProvider() {
+        List<Entity> entities = new ArrayList<Entity>();
+        entities.add(this);
+        ContentProvider contentProvider = new ContentProvider(schema, entities);
+        contentProviders.add(contentProvider);
+        return contentProvider;
+    }
+
+    /** Adds a new index to the entity. */
+    public Entity addIndex(Index index) {
+        indexes.add(index);
+        return this;
+    }
+
+    public Entity addImport(String additionalImport) {
+        additionalImportsEntity.add(additionalImport);
+        return this;
+    }
+
+    /** The entity is represented by a protocol buffers object. Requires some special actions like using builders. */
+    Entity useProtobuf() {
+        protobuf = true;
+        return this;
+    }
+
+    public boolean isProtobuf() {
+        return protobuf;
+    }
+
+    public Schema getSchema() {
+        return schema;
+    }
+
+    public String getTableName() {
+        return tableName;
+    }
+
+    public void setTableName(String tableName) {
+        this.tableName = tableName;
+    }
+
+    public String getClassName() {
+        return className;
+    }
+
+    public List<Property> getProperties() {
+        return properties;
+    }
+
+    public List<Property> getPropertiesColumns() {
+        return propertiesColumns;
+    }
+
+    public String getJavaPackage() {
+        return javaPackage;
+    }
+
+    public void setJavaPackage(String javaPackage) {
+        this.javaPackage = javaPackage;
+    }
+
+    public String getJavaPackageDao() {
+        return javaPackageDao;
+    }
+
+    public void setJavaPackageDao(String javaPackageDao) {
+        this.javaPackageDao = javaPackageDao;
+    }
+
+    public String getClassNameDao() {
+        return classNameDao;
+    }
+
+    public void setClassNameDao(String classNameDao) {
+        this.classNameDao = classNameDao;
+    }
+
+    public String getClassNameTest() {
+        return classNameTest;
+    }
+
+    public void setClassNameTest(String classNameTest) {
+        this.classNameTest = classNameTest;
+    }
+
+    public String getJavaPackageTest() {
+        return javaPackageTest;
+    }
+
+    public void setJavaPackageTest(String javaPackageTest) {
+        this.javaPackageTest = javaPackageTest;
+    }
+
+    /** Internal property used by templates, don't use during entity definition. */
+    public List<Property> getPropertiesPk() {
+        return propertiesPk;
+    }
+
+    /** Internal property used by templates, don't use during entity definition. */
+    public List<Property> getPropertiesNonPk() {
+        return propertiesNonPk;
+    }
+
+    /** Internal property used by templates, don't use during entity definition. */
+    public Property getPkProperty() {
+        return pkProperty;
+    }
+
+    public List<Index> getIndexes() {
+        return indexes;
+    }
+
+    /** Internal property used by templates, don't use during entity definition. */
+    public String getPkType() {
+        return pkType;
+    }
+
+    public boolean isConstructors() {
+        return constructors;
+    }
+
+    public void setConstructors(boolean constructors) {
+        this.constructors = constructors;
+    }
+
+    public boolean isSkipGeneration() {
+        return skipGeneration;
+    }
+
+    /**
+     * Flag if the entity's code generation should be skipped. E.g. if you need to change the class after initial
+     * generation.
+     */
+    public void setSkipGeneration(boolean skipGeneration) {
+        this.skipGeneration = skipGeneration;
+    }
+
+    /** Flag if CREATE & DROP TABLE scripts should be skipped in Dao. */
+    public void setSkipTableCreation(boolean skipTableCreation) {
+        this.skipTableCreation = skipTableCreation;
+    }
+
+    public boolean isSkipTableCreation() {
+        return skipTableCreation;
+    }
+
+    public boolean isSkipGenerationTest() {
+        return skipGenerationTest;
+    }
+
+    public void setSkipGenerationTest(boolean skipGenerationTest) {
+        this.skipGenerationTest = skipGenerationTest;
+    }
+
+    public List<ToOne> getToOneRelations() {
+        return toOneRelations;
+    }
+
+    public List<ToManyBase> getToManyRelations() {
+        return toManyRelations;
+    }
+
+    public List<ToManyBase> getIncomingToManyRelations() {
+        return incomingToManyRelations;
+    }
+
+    /**
+     * Entities with relations are active, but this method allows to make the entities active even if it does not have
+     * relations.
+     */
+    public void setActive(Boolean active) {
+        this.active = active;
+    }
+
+    public Boolean getActive() {
+        return active;
+    }
+
+    public Boolean getHasKeepSections() {
+        return hasKeepSections;
+    }
+
+    public Collection<String> getAdditionalImportsEntity() {
+        return additionalImportsEntity;
+    }
+
+    public Collection<String> getAdditionalImportsDao() {
+        return additionalImportsDao;
+    }
+
+    public void setHasKeepSections(Boolean hasKeepSections) {
+        this.hasKeepSections = hasKeepSections;
+    }
+
+    public List<String> getInterfacesToImplement() {
+        return interfacesToImplement;
+    }
+
+    public List<ContentProvider> getContentProviders() {
+        return contentProviders;
+    }
+
+    public void implementsInterface(String... interfaces) {
+        for (String interfaceToImplement : interfaces) {
+            if (interfacesToImplement.contains(interfaceToImplement)) {
+                throw new RuntimeException("Interface defined more than once: " + interfaceToImplement);
+            }
+            interfacesToImplement.add(interfaceToImplement);
+        }
+    }
+
+    public void implementsSerializable() {
+        interfacesToImplement.add("java.io.Serializable");
+    }
+
+    public String getSuperclass() {
+        return superclass;
+    }
+
+    public void setSuperclass(String classToExtend) {
+        this.superclass = classToExtend;
+    }
+
+    public String getJavaDoc() {
+        return javaDoc;
+    }
+
+    public void setJavaDoc(String javaDoc) {
+        this.javaDoc = DaoUtil.checkConvertToJavaDoc(javaDoc, "");
+    }
+
+    public String getCodeBeforeClass() {
+        return codeBeforeClass;
+    }
+
+    public void setCodeBeforeClass(String codeBeforeClass) {
+        this.codeBeforeClass = codeBeforeClass;
+    }
+
+    void init2ndPass() {
+        init2ndPassNamesWithDefaults();
+
+        for (int i = 0; i < properties.size(); i++) {
+            Property property = properties.get(i);
+            property.setOrdinal(i);
+            property.init2ndPass();
+            if (property.isPrimaryKey()) {
+                propertiesPk.add(property);
+            } else {
+                propertiesNonPk.add(property);
+            }
+        }
+
+        if (propertiesPk.size() == 1) {
+            pkProperty = propertiesPk.get(0);
+            pkType = schema.mapToJavaTypeNullable(pkProperty.getPropertyType());
+        } else {
+            pkType = "Void";
+        }
+
+        propertiesColumns = new ArrayList<Property>(properties);
+        for (ToOne toOne : toOneRelations) {
+            toOne.init2ndPass();
+            Property[] fkProperties = toOne.getFkProperties();
+            for (Property fkProperty : fkProperties) {
+                if (!propertiesColumns.contains(fkProperty)) {
+                    propertiesColumns.add(fkProperty);
+                }
+            }
+        }
+
+        for (ToManyBase toMany : toManyRelations) {
+            toMany.init2ndPass();
+            // Source Properties may not be virtual, so we do not need the following code:
+            // for (Property sourceProperty : toMany.getSourceProperties()) {
+            // if (!propertiesColumns.contains(sourceProperty)) {
+            // propertiesColumns.add(sourceProperty);
+            // }
+            // }
+        }
+
+        if (active == null) {
+            active = schema.isUseActiveEntitiesByDefault();
+        }
+        active |= !toOneRelations.isEmpty() || !toManyRelations.isEmpty();
+
+        if (hasKeepSections == null) {
+            hasKeepSections = schema.isHasKeepSectionsByDefault();
+        }
+
+        init2ndPassIndexNamesWithDefaults();
+
+        for (ContentProvider contentProvider : contentProviders) {
+            contentProvider.init2ndPass();
+        }
+    }
+
+    protected void init2ndPassNamesWithDefaults() {
+        if (tableName == null) {
+            tableName = DaoUtil.dbName(className);
+        }
+
+        if (classNameDao == null) {
+            classNameDao = className + "Dao";
+        }
+        if (classNameTest == null) {
+            classNameTest = className + "Test";
+        }
+
+        if (javaPackage == null) {
+            javaPackage = schema.getDefaultJavaPackage();
+        }
+
+        if (javaPackageDao == null) {
+            javaPackageDao = schema.getDefaultJavaPackageDao();
+            if (javaPackageDao == null) {
+                javaPackageDao = javaPackage;
+            }
+        }
+        if (javaPackageTest == null) {
+            javaPackageTest = schema.getDefaultJavaPackageTest();
+            if (javaPackageTest == null) {
+                javaPackageTest = javaPackage;
+            }
+        }
+    }
+
+    protected void init2ndPassIndexNamesWithDefaults() {
+        for (int i = 0; i < indexes.size(); i++) {
+            Index index = indexes.get(i);
+            if (index.getName() == null) {
+                String indexName = "IDX_" + getTableName();
+                List<Property> properties = index.getProperties();
+                for (int j = 0; j < properties.size(); j++) {
+                    Property property = properties.get(j);
+                    indexName += "_" + property.getColumnName();
+                    if ("DESC".equalsIgnoreCase(index.getPropertiesOrder().get(j))) {
+                        indexName += "_DESC";
+                    }
+                }
+                // TODO can this get too long? how to shorten reliably without depending on the order (i)
+                index.setName(indexName);
+            }
+        }
+    }
+
+    void init3rdPass() {
+        for (Property property : properties) {
+            property.init3ndPass();
+        }
+
+        init3rdPassRelations();
+        init3rdPassAdditionalImports();
+    }
+
+    private void init3rdPassRelations() {
+        Set<String> toOneNames = new HashSet<String>();
+        for (ToOne toOne : toOneRelations) {
+            toOne.init3ndPass();
+            if (!toOneNames.add(toOne.getName().toLowerCase())) {
+                throw new RuntimeException("Duplicate name for " + toOne);
+            }
+        }
+
+        Set<String> toManyNames = new HashSet<String>();
+        for (ToManyBase toMany : toManyRelations) {
+            toMany.init3rdPass();
+            if (toMany instanceof ToMany) {
+                Entity targetEntity = toMany.getTargetEntity();
+                for (Property targetProperty : ((ToMany) toMany).getTargetProperties()) {
+                    if (!targetEntity.propertiesColumns.contains(targetProperty)) {
+                        targetEntity.propertiesColumns.add(targetProperty);
+                    }
+                }
+            }
+            if (!toManyNames.add(toMany.getName().toLowerCase())) {
+                throw new RuntimeException("Duplicate name for " + toMany);
+            }
+        }
+    }
+
+    private void init3rdPassAdditionalImports() {
+        if (active && !javaPackage.equals(javaPackageDao)) {
+            additionalImportsEntity.add(javaPackageDao + "." + classNameDao);
+        }
+
+        for (ToOne toOne : toOneRelations) {
+            Entity targetEntity = toOne.getTargetEntity();
+            checkAdditionalImportsEntityTargetEntity(targetEntity);
+            // For deep loading
+            if (!targetEntity.getJavaPackage().equals(javaPackageDao)) {
+                additionalImportsDao.add(targetEntity.getJavaPackage() + "." + targetEntity.getClassName());
+            }
+        }
+
+        for (ToManyBase toMany : toManyRelations) {
+            Entity targetEntity = toMany.getTargetEntity();
+            checkAdditionalImportsEntityTargetEntity(targetEntity);
+        }
+
+        for (Property property : properties) {
+            String customType = property.getCustomType();
+            if (customType != null) {
+                String pack = DaoUtil.getPackageFromFullyQualified(customType);
+                if (!pack.equals(javaPackage)) {
+                    additionalImportsEntity.add(customType);
+                }
+                if (!pack.equals(javaPackageDao)) {
+                    additionalImportsDao.add(customType);
+                }
+            }
+
+            String converter = property.getConverter();
+            if (converter != null) {
+                String pack = DaoUtil.getPackageFromFullyQualified(converter);
+                if (!pack.equals(javaPackageDao)) {
+                    additionalImportsDao.add(converter);
+                }
+            }
+
+        }
+    }
+
+    private void checkAdditionalImportsEntityTargetEntity(Entity targetEntity) {
+        if (!targetEntity.getJavaPackage().equals(javaPackage)) {
+            additionalImportsEntity.add(targetEntity.getJavaPackage() + "." + targetEntity.getClassName());
+        }
+        if (!targetEntity.getJavaPackageDao().equals(javaPackage)) {
+            additionalImportsEntity.add(targetEntity.getJavaPackageDao() + "." + targetEntity.getClassNameDao());
+        }
+    }
+
+    public void validatePropertyExists(Property property) {
+        if (!properties.contains(property)) {
+            throw new RuntimeException("Property " + property + " does not exist in " + this);
+        }
+    }
+
+    @Override
+    public String toString() {
+        return "Entity " + className + " (package: " + javaPackage + ")";
+    }
+
+}
diff --git a/DaoGenerator/src/de/greenrobot/daogenerator/Index.java b/DaoGenerator/src/de/greenrobot/daogenerator/Index.java
index ff48dee9..a7d48f5c 100644
--- a/DaoGenerator/src/de/greenrobot/daogenerator/Index.java
+++ b/DaoGenerator/src/de/greenrobot/daogenerator/Index.java
@@ -1,43 +1,43 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daogenerator;
-
-
-public class Index extends PropertyOrderList {
-    private String name;
-    private boolean unique;
-
-    public String getName() {
-        return name;
-    }
-
-    public Index setName(String name) {
-        this.name = name;
-        return this;
-    }
-
-    public Index makeUnique() {
-        unique = true;
-        return this;
-    }
-
-    public boolean isUnique() {
-        return unique;
-    }
-
-}
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daogenerator;
+
+
+public class Index extends PropertyOrderList {
+    private String name;
+    private boolean unique;
+
+    public String getName() {
+        return name;
+    }
+
+    public Index setName(String name) {
+        this.name = name;
+        return this;
+    }
+
+    public Index makeUnique() {
+        unique = true;
+        return this;
+    }
+
+    public boolean isUnique() {
+        return unique;
+    }
+
+}
diff --git a/DaoGenerator/src/de/greenrobot/daogenerator/Property.java b/DaoGenerator/src/de/greenrobot/daogenerator/Property.java
index f54d05e8..14534df5 100644
--- a/DaoGenerator/src/de/greenrobot/daogenerator/Property.java
+++ b/DaoGenerator/src/de/greenrobot/daogenerator/Property.java
@@ -1,248 +1,421 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daogenerator;
-
-/** Model class for an entity's property: a Java property mapped to a data base column. */
-public class Property {
-
-    public static class PropertyBuilder {
-        private final Property property;
-
-        public PropertyBuilder(Schema schema, Entity entity, PropertyType propertyType, String propertyName) {
-            property = new Property(schema, entity, propertyType, propertyName);
-        }
-
-        public PropertyBuilder columnName(String columnName) {
-            property.columnName = columnName;
-            return this;
-        }
-
-        public PropertyBuilder columnType(String columnType) {
-            property.columnType = columnType;
-            return this;
-        }
-
-        public PropertyBuilder primaryKey() {
-            property.primaryKey = true;
-            return this;
-        }
-
-        public PropertyBuilder primaryKeyAsc() {
-            property.primaryKey = true;
-            property.pkAsc = true;
-            return this;
-        }
-
-        public PropertyBuilder primaryKeyDesc() {
-            property.primaryKey = true;
-            property.pkDesc = true;
-            return this;
-        }
-
-        public PropertyBuilder autoincrement() {
-            if (!property.primaryKey || property.propertyType != PropertyType.Long) {
-                throw new RuntimeException(
-                        "AUTOINCREMENT is only available to primary key properties of type long/Long");
-            }
-            property.pkAutoincrement = true;
-            return this;
-        }
-
-        public PropertyBuilder unique() {
-            property.unique = true;
-            return this;
-        }
-
-        public PropertyBuilder notNull() {
-            property.notNull = true;
-            return this;
-        }
-
-        public PropertyBuilder index() {
-            Index index = new Index();
-            index.addProperty(property);
-            property.entity.addIndex(index);
-            return this;
-        }
-
-        public PropertyBuilder indexAsc(String indexNameOrNull, boolean isUnique) {
-            Index index = new Index();
-            index.addPropertyAsc(property);
-            if (isUnique) {
-                index.makeUnique();
-            }
-            index.setName(indexNameOrNull);
-            property.entity.addIndex(index);
-            return this;
-        }
-
-        public PropertyBuilder indexDesc(String indexNameOrNull, boolean isUnique) {
-            Index index = new Index();
-            index.addPropertyDesc(property);
-            if (isUnique) {
-                index.makeUnique();
-            }
-            index.setName(indexNameOrNull);
-            property.entity.addIndex(index);
-            return this;
-        }
-
-        public Property getProperty() {
-            return property;
-        }
-    }
-
-    private final Schema schema;
-    private final Entity entity;
-    private PropertyType propertyType;
-    private final String propertyName;
-
-    private String columnName;
-    private String columnType;
-
-    private boolean primaryKey;
-    private boolean pkAsc;
-    private boolean pkDesc;
-    private boolean pkAutoincrement;
-
-    private boolean unique;
-    private boolean notNull;
-
-    /** Initialized in 2nd pass */
-    private String constraints;
-
-    private int ordinal;
-
-    private String javaType;
-
-    public Property(Schema schema, Entity entity, PropertyType propertyType, String propertyName) {
-        this.schema = schema;
-        this.entity = entity;
-        this.propertyName = propertyName;
-        this.propertyType = propertyType;
-    }
-
-    public String getPropertyName() {
-        return propertyName;
-    }
-
-    public PropertyType getPropertyType() {
-        return propertyType;
-    }
-
-    public void setPropertyType(PropertyType propertyType) {
-        this.propertyType = propertyType;
-    }
-
-    public String getColumnName() {
-        return columnName;
-    }
-
-    public String getColumnType() {
-        return columnType;
-    }
-
-    public boolean isPrimaryKey() {
-        return primaryKey;
-    }
-
-    public boolean isAutoincrement() {
-        return pkAutoincrement;
-    }
-
-    public String getConstraints() {
-        return constraints;
-    }
-
-    public boolean isUnique() {
-        return unique;
-    }
-
-    public boolean isNotNull() {
-        return notNull;
-    }
-
-    public String getJavaType() {
-        return javaType;
-    }
-
-    public int getOrdinal() {
-        return ordinal;
-    }
-
-    public void setOrdinal(int ordinal) {
-        this.ordinal = ordinal;
-    }
-
-    public Entity getEntity() {
-        return entity;
-    }
-
-    void init2ndPass() {
-        initConstraint();
-        if (columnType == null) {
-            columnType = schema.mapToDbType(propertyType);
-        }
-        if (columnName == null) {
-            columnName = DaoUtil.dbName(propertyName);
-        }
-        if (notNull) {
-            javaType = schema.mapToJavaTypeNotNull(propertyType);
-        } else {
-            javaType = schema.mapToJavaTypeNullable(propertyType);
-        }
-    }
-
-    private void initConstraint() {
-        StringBuilder constraintBuilder = new StringBuilder();
-        if (primaryKey) {
-            constraintBuilder.append("PRIMARY KEY");
-            if (pkAsc) {
-                constraintBuilder.append(" ASC");
-            }
-            if (pkDesc) {
-                constraintBuilder.append(" DESC");
-            }
-            if (pkAutoincrement) {
-                constraintBuilder.append(" AUTOINCREMENT");
-            }
-        }
-        // Always have String PKs NOT NULL because SQLite is pretty strange in this respect:
-        // One could insert multiple rows with NULL PKs
-        if (notNull || (primaryKey && propertyType == PropertyType.String)) {
-            constraintBuilder.append(" NOT NULL");
-        }
-        if (unique) {
-            constraintBuilder.append(" UNIQUE");
-        }
-        String newContraints = constraintBuilder.toString().trim();
-        if (constraintBuilder.length() > 0) {
-            constraints = newContraints;
-        }
-    }
-
-    void init3ndPass() {
-        // Nothing to do so far
-    }
-
-    @Override
-    public String toString() {
-        return "Property " + propertyName + " of " + entity.getClassName();
-    }
-
-}
+/*
+ * Copyright (C) 2011-2015 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daogenerator;
+
+/** Model class for an entity's property: a Java property mapped to a data base column. */
+public class Property {
+
+    public static class PropertyBuilder {
+        private final Property property;
+
+        public PropertyBuilder(Schema schema, Entity entity, PropertyType propertyType, String propertyName) {
+            property = new Property(schema, entity, propertyType, propertyName);
+        }
+
+        public PropertyBuilder columnName(String columnName) {
+            property.columnName = columnName;
+            return this;
+        }
+
+        public PropertyBuilder columnType(String columnType) {
+            property.columnType = columnType;
+            return this;
+        }
+
+        public PropertyBuilder primaryKey() {
+            property.primaryKey = true;
+            return this;
+        }
+
+        public PropertyBuilder primaryKeyAsc() {
+            property.primaryKey = true;
+            property.pkAsc = true;
+            return this;
+        }
+
+        public PropertyBuilder primaryKeyDesc() {
+            property.primaryKey = true;
+            property.pkDesc = true;
+            return this;
+        }
+
+        public PropertyBuilder autoincrement() {
+            if (!property.primaryKey || property.propertyType != PropertyType.Long) {
+                throw new RuntimeException(
+                        "AUTOINCREMENT is only available to primary key properties of type long/Long");
+            }
+            property.pkAutoincrement = true;
+            return this;
+        }
+
+        public PropertyBuilder unique() {
+            property.unique = true;
+            return this;
+        }
+
+        public PropertyBuilder notNull() {
+            property.notNull = true;
+            return this;
+        }
+
+        public PropertyBuilder index() {
+            Index index = new Index();
+            index.addProperty(property);
+            property.entity.addIndex(index);
+            return this;
+        }
+
+        public PropertyBuilder indexAsc(String indexNameOrNull, boolean isUnique) {
+            Index index = new Index();
+            index.addPropertyAsc(property);
+            if (isUnique) {
+                index.makeUnique();
+            }
+            index.setName(indexNameOrNull);
+            property.entity.addIndex(index);
+            return this;
+        }
+
+        public PropertyBuilder indexDesc(String indexNameOrNull, boolean isUnique) {
+            Index index = new Index();
+            index.addPropertyDesc(property);
+            if (isUnique) {
+                index.makeUnique();
+            }
+            index.setName(indexNameOrNull);
+            property.entity.addIndex(index);
+            return this;
+        }
+
+        public PropertyBuilder customType(String customType, String converter) {
+            property.customType = customType;
+            property.customTypeClassName = DaoUtil.getClassnameFromFullyQualified(customType);
+            property.converter = converter;
+            property.converterClassName = DaoUtil.getClassnameFromFullyQualified(converter);
+            return this;
+        }
+
+        public PropertyBuilder codeBeforeField(String code) {
+            property.codeBeforeField = code;
+            return this;
+        }
+
+        public PropertyBuilder codeBeforeGetter(String code) {
+            property.codeBeforeGetter = code;
+            return this;
+        }
+
+        public PropertyBuilder codeBeforeSetter(String code) {
+            property.codeBeforeSetter = code;
+            return this;
+        }
+
+        public PropertyBuilder codeBeforeGetterAndSetter(String code) {
+            property.codeBeforeGetter = code;
+            property.codeBeforeSetter = code;
+            return this;
+        }
+
+        public PropertyBuilder javaDocField(String javaDoc) {
+            property.javaDocField = checkConvertToJavaDoc(javaDoc);
+            return this;
+        }
+
+        private String checkConvertToJavaDoc(String javaDoc) {
+            return DaoUtil.checkConvertToJavaDoc(javaDoc, "    ");
+        }
+
+        public PropertyBuilder javaDocGetter(String javaDoc) {
+            property.javaDocGetter = checkConvertToJavaDoc(javaDoc);
+            return this;
+        }
+
+        public PropertyBuilder javaDocSetter(String javaDoc) {
+            property.javaDocSetter = checkConvertToJavaDoc(javaDoc);
+            return this;
+        }
+
+        public PropertyBuilder javaDocGetterAndSetter(String javaDoc) {
+            javaDoc = checkConvertToJavaDoc(javaDoc);
+            property.javaDocGetter = javaDoc;
+            property.javaDocSetter = javaDoc;
+            return this;
+        }
+
+        public Property getProperty() {
+            return property;
+        }
+    }
+
+    private final Schema schema;
+    private final Entity entity;
+    private PropertyType propertyType;
+    private final String propertyName;
+
+    private String columnName;
+    private String columnType;
+
+    private String customType;
+    private String customTypeClassName;
+    private String converter;
+    private String converterClassName;
+
+    private String codeBeforeField;
+    private String codeBeforeGetter;
+    private String codeBeforeSetter;
+
+    private String javaDocField;
+    private String javaDocGetter;
+    private String javaDocSetter;
+
+    private boolean primaryKey;
+    private boolean pkAsc;
+    private boolean pkDesc;
+    private boolean pkAutoincrement;
+
+    private boolean unique;
+    private boolean notNull;
+
+    /** Initialized in 2nd pass */
+    private String constraints;
+
+    private int ordinal;
+
+    private String javaType;
+
+    public Property(Schema schema, Entity entity, PropertyType propertyType, String propertyName) {
+        this.schema = schema;
+        this.entity = entity;
+        this.propertyName = propertyName;
+        this.propertyType = propertyType;
+    }
+
+    public String getPropertyName() {
+        return propertyName;
+    }
+
+    public PropertyType getPropertyType() {
+        return propertyType;
+    }
+
+    public void setPropertyType(PropertyType propertyType) {
+        this.propertyType = propertyType;
+    }
+
+    public String getColumnName() {
+        return columnName;
+    }
+
+    public String getColumnType() {
+        return columnType;
+    }
+
+    public boolean isPrimaryKey() {
+        return primaryKey;
+    }
+
+    public boolean isAutoincrement() {
+        return pkAutoincrement;
+    }
+
+    public String getConstraints() {
+        return constraints;
+    }
+
+    public boolean isUnique() {
+        return unique;
+    }
+
+    public boolean isNotNull() {
+        return notNull;
+    }
+
+    public String getJavaType() {
+        return javaType;
+    }
+
+    public String getJavaTypeInEntity() {
+        if (customTypeClassName != null) {
+            return customTypeClassName;
+        } else {
+            return javaType;
+        }
+    }
+
+    public int getOrdinal() {
+        return ordinal;
+    }
+
+    void setOrdinal(int ordinal) {
+        this.ordinal = ordinal;
+    }
+
+    public String getCustomType() {
+        return customType;
+    }
+
+    public String getCustomTypeClassName() {
+        return customTypeClassName;
+    }
+
+    public String getConverter() {
+        return converter;
+    }
+
+    public String getConverterClassName() {
+        return converterClassName;
+    }
+
+    public String getCodeBeforeField() {
+        return codeBeforeField;
+    }
+
+    public String getCodeBeforeGetter() {
+        return codeBeforeGetter;
+    }
+
+    public String getCodeBeforeSetter() {
+        return codeBeforeSetter;
+    }
+
+    public String getJavaDocField() {
+        return javaDocField;
+    }
+
+    public String getJavaDocGetter() {
+        return javaDocGetter;
+    }
+
+    public String getJavaDocSetter() {
+        return javaDocSetter;
+    }
+
+    public String getDatabaseValueExpression() {
+        return getDatabaseValueExpression(propertyName);
+    }
+
+    public String getDatabaseValueExpressionNotNull() {
+        return getDatabaseValueExpression("entity.get" + DaoUtil.capFirst(propertyName) + "()");
+    }
+
+    // Got too messy in template:
+    // <#if property.customType?has_content>${property.propertyName}Converter.convertToDatabaseValue(</#if><#--
+    // -->entity.get${property.propertyName?cap_first}()<#if property.customType?has_content>)</#if><#if
+    // property.propertyType == "Boolean"> ? 1l: 0l</#if><#if property.propertyType == "Date">.getTime()</#if>
+    public String getDatabaseValueExpression(String entityValue) {
+        StringBuilder builder = new StringBuilder();
+        if (customType != null) {
+            builder.append(propertyName).append("Converter.convertToDatabaseValue(");
+        }
+        builder.append(entityValue);
+        if (customType != null) {
+            builder.append(')');
+        }
+        if (propertyType == PropertyType.Boolean) {
+            builder.append(" ? 1L: 0L");
+        } else if (propertyType == PropertyType.Date) {
+            builder.append(".getTime()");
+        }
+        return builder.toString();
+    }
+
+    // Got too messy in template:
+    // <#if property.propertyType == "Byte">(byte) </#if>
+    // <#if property.propertyType == "Date">new java.util.Date(</#if>
+    // cursor.get${toCursorType[property.propertyType]}(offset + ${property_index})
+    // <#if property.propertyType == "Boolean"> != 0</#if>
+    // <#if property.propertyType == "Date">)</#if>
+    public String getEntityValueExpression(String databaseValue) {
+        StringBuilder builder = new StringBuilder();
+        if (customType != null) {
+            builder.append(propertyName).append("Converter.convertToEntityProperty(");
+        }
+        if (propertyType == PropertyType.Byte) {
+            builder.append("(byte) ");
+        } else if (propertyType == PropertyType.Date) {
+            builder.append("new java.util.Date(");
+        }
+        builder.append(databaseValue);
+        if (propertyType == PropertyType.Boolean) {
+            builder.append(" != 0");
+        } else if (propertyType == PropertyType.Date) {
+            builder.append(")");
+        }
+        if (customType != null) {
+            builder.append(')');
+        }
+        return builder.toString();
+    }
+
+    public Entity getEntity() {
+        return entity;
+    }
+
+    void init2ndPass() {
+        initConstraint();
+        if (columnType == null) {
+            columnType = schema.mapToDbType(propertyType);
+        }
+        if (columnName == null) {
+            columnName = DaoUtil.dbName(propertyName);
+        }
+        if (notNull) {
+            javaType = schema.mapToJavaTypeNotNull(propertyType);
+        } else {
+            javaType = schema.mapToJavaTypeNullable(propertyType);
+        }
+    }
+
+    private void initConstraint() {
+        StringBuilder constraintBuilder = new StringBuilder();
+        if (primaryKey) {
+            constraintBuilder.append("PRIMARY KEY");
+            if (pkAsc) {
+                constraintBuilder.append(" ASC");
+            }
+            if (pkDesc) {
+                constraintBuilder.append(" DESC");
+            }
+            if (pkAutoincrement) {
+                constraintBuilder.append(" AUTOINCREMENT");
+            }
+        }
+        // Always have String PKs NOT NULL because SQLite is pretty strange in this respect:
+        // One could insert multiple rows with NULL PKs
+        if (notNull || (primaryKey && propertyType == PropertyType.String)) {
+            constraintBuilder.append(" NOT NULL");
+        }
+        if (unique) {
+            constraintBuilder.append(" UNIQUE");
+        }
+        String newContraints = constraintBuilder.toString().trim();
+        if (constraintBuilder.length() > 0) {
+            constraints = newContraints;
+        }
+    }
+
+    void init3ndPass() {
+        // Nothing to do so far
+    }
+
+    @Override
+    public String toString() {
+        return "Property " + propertyName + " of " + entity.getClassName();
+    }
+
+}
diff --git a/DaoGenerator/src/de/greenrobot/daogenerator/PropertyOrderList.java b/DaoGenerator/src/de/greenrobot/daogenerator/PropertyOrderList.java
index a228aaf9..312de11e 100644
--- a/DaoGenerator/src/de/greenrobot/daogenerator/PropertyOrderList.java
+++ b/DaoGenerator/src/de/greenrobot/daogenerator/PropertyOrderList.java
@@ -1,83 +1,86 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daogenerator;
-
-import java.util.ArrayList;
-import java.util.List;
-
-public class PropertyOrderList {
-    private List<Property> properties;
-    private List<String> propertiesOrder;
-
-    public PropertyOrderList() {
-        properties = new ArrayList<Property>();
-        propertiesOrder = new ArrayList<String>();
-    }
-
-    public void addProperty(Property property) {
-        properties.add(property);
-        propertiesOrder.add(null);
-    }
-
-    public void addPropertyAsc(Property property) {
-        properties.add(property);
-        propertiesOrder.add("ASC");
-    }
-
-    public void addPropertyDesc(Property property) {
-        properties.add(property);
-        propertiesOrder.add("DESC");
-    }
-
-    public void addOrderRaw(String order) {
-        properties.add(null);
-        propertiesOrder.add(order);
-    }
-
-    public List<Property> getProperties() {
-        return properties;
-    }
-
-    List<String> getPropertiesOrder() {
-        return propertiesOrder;
-    }
-
-    public String getCommaSeparatedString() {
-        StringBuilder builder = new StringBuilder();
-        int size = properties.size();
-        for (int i = 0; i < size; i++) {
-            Property property = properties.get(i);
-            String order = propertiesOrder.get(i);
-            if (property != null) {
-                builder.append(property.getColumnName()).append(' ');
-            }
-            if (order != null) {
-                builder.append(order);
-            }
-            if (i < size - 1) {
-                builder.append(',');
-            }
-        }
-        return builder.toString();
-    }
-
-    public boolean isEmpty() {
-        return properties.isEmpty();
-    }
-
-}
+/*
+ * Copyright (C) 2011-2015 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daogenerator;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class PropertyOrderList {
+    private List<Property> properties;
+    private List<String> propertiesOrder;
+
+    public PropertyOrderList() {
+        properties = new ArrayList<Property>();
+        propertiesOrder = new ArrayList<String>();
+    }
+
+    public void addProperty(Property property) {
+        properties.add(property);
+        propertiesOrder.add(null);
+    }
+
+    public void addPropertyAsc(Property property) {
+        properties.add(property);
+        propertiesOrder.add("ASC");
+    }
+
+    public void addPropertyDesc(Property property) {
+        properties.add(property);
+        propertiesOrder.add("DESC");
+    }
+
+    public void addOrderRaw(String order) {
+        properties.add(null);
+        propertiesOrder.add(order);
+    }
+
+    public List<Property> getProperties() {
+        return properties;
+    }
+
+    List<String> getPropertiesOrder() {
+        return propertiesOrder;
+    }
+
+    public String getCommaSeparatedString(String tablePrefixOrNull) {
+        StringBuilder builder = new StringBuilder();
+        int size = properties.size();
+        for (int i = 0; i < size; i++) {
+            Property property = properties.get(i);
+            String order = propertiesOrder.get(i);
+            if (property != null) {
+                if(tablePrefixOrNull != null) {
+                    builder.append(tablePrefixOrNull).append('.');
+                }
+                builder.append('\'').append(property.getColumnName()).append('\'').append(' ');
+            }
+            if (order != null) {
+                builder.append(order);
+            }
+            if (i < size - 1) {
+                builder.append(',');
+            }
+        }
+        return builder.toString();
+    }
+
+    public boolean isEmpty() {
+        return properties.isEmpty();
+    }
+
+}
diff --git a/DaoGenerator/src/de/greenrobot/daogenerator/PropertyType.java b/DaoGenerator/src/de/greenrobot/daogenerator/PropertyType.java
index 0246239e..db10eaf9 100644
--- a/DaoGenerator/src/de/greenrobot/daogenerator/PropertyType.java
+++ b/DaoGenerator/src/de/greenrobot/daogenerator/PropertyType.java
@@ -1,27 +1,27 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daogenerator;
-
-/**
- * Currently available types for properties.
- * 
- * @author Markus
- */
-public enum PropertyType {
-    Byte, Short, Int, Long, Boolean, Float, Double, String, ByteArray, Date
-}
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daogenerator;
+
+/**
+ * Currently available types for properties.
+ * 
+ * @author Markus
+ */
+public enum PropertyType {
+    Byte, Short, Int, Long, Boolean, Float, Double, String, ByteArray, Date
+}
diff --git a/DaoGenerator/src/de/greenrobot/daogenerator/Query.java b/DaoGenerator/src/de/greenrobot/daogenerator/Query.java
index 528d9569..8929d7fb 100644
--- a/DaoGenerator/src/de/greenrobot/daogenerator/Query.java
+++ b/DaoGenerator/src/de/greenrobot/daogenerator/Query.java
@@ -1,51 +1,51 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daogenerator;
-
-import java.util.ArrayList;
-import java.util.List;
-
-/** NOT IMPLEMENTED YET. Check back later. */
-public class Query {
-    @SuppressWarnings("unused")
-    private String name;
-    private List<QueryParam> parameters;
-    @SuppressWarnings("unused")
-    private boolean distinct;
-
-    public Query(String name) {
-        this.name = name;
-        parameters= new ArrayList<QueryParam>();
-    }
-    
-    public QueryParam addEqualsParam(Property column) {
-        return addParam(column, "=");
-    }
-
-    public QueryParam addParam(Property column, String operator) {
-        QueryParam queryParam = new QueryParam(column, operator);
-        parameters.add(queryParam);
-        return queryParam;
-    }
-    
-    public void distinct() {
-        distinct = true;
-    }
-
-
-}
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daogenerator;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/** NOT IMPLEMENTED YET. Check back later. */
+public class Query {
+    @SuppressWarnings("unused")
+    private String name;
+    private List<QueryParam> parameters;
+    @SuppressWarnings("unused")
+    private boolean distinct;
+
+    public Query(String name) {
+        this.name = name;
+        parameters= new ArrayList<QueryParam>();
+    }
+    
+    public QueryParam addEqualsParam(Property column) {
+        return addParam(column, "=");
+    }
+
+    public QueryParam addParam(Property column, String operator) {
+        QueryParam queryParam = new QueryParam(column, operator);
+        parameters.add(queryParam);
+        return queryParam;
+    }
+    
+    public void distinct() {
+        distinct = true;
+    }
+
+
+}
diff --git a/DaoGenerator/src/de/greenrobot/daogenerator/QueryParam.java b/DaoGenerator/src/de/greenrobot/daogenerator/QueryParam.java
index 7b5d1327..b775dffc 100644
--- a/DaoGenerator/src/de/greenrobot/daogenerator/QueryParam.java
+++ b/DaoGenerator/src/de/greenrobot/daogenerator/QueryParam.java
@@ -1,38 +1,38 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daogenerator;
-
-/** NOT IMPLEMENTED YET. Check back later. */
-public class QueryParam {
-    private Property column;
-    private String operator;
-    
-    public QueryParam(Property column, String operator) {
-        this.column = column;
-        this.operator = operator;
-    }
-
-    public Property getColumn() {
-        return column;
-    }
-
-    public String getOperator() {
-        return operator;
-    }
-    
-}
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daogenerator;
+
+/** NOT IMPLEMENTED YET. Check back later. */
+public class QueryParam {
+    private Property column;
+    private String operator;
+    
+    public QueryParam(Property column, String operator) {
+        this.column = column;
+        this.operator = operator;
+    }
+
+    public Property getColumn() {
+        return column;
+    }
+
+    public String getOperator() {
+        return operator;
+    }
+    
+}
diff --git a/DaoGenerator/src/de/greenrobot/daogenerator/Schema.java b/DaoGenerator/src/de/greenrobot/daogenerator/Schema.java
index e94c58f5..8351ecb5 100644
--- a/DaoGenerator/src/de/greenrobot/daogenerator/Schema.java
+++ b/DaoGenerator/src/de/greenrobot/daogenerator/Schema.java
@@ -1,189 +1,189 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daogenerator;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-/**
- * The "root" model class to which you can add entities to.
- * 
- * @see <a href="http://greendao-orm.com/documentation/modelling-entities/">Modelling Entities (Documentation page)</a>
- */
-public class Schema {
-    private final int version;
-    private final String defaultJavaPackage;
-    private String defaultJavaPackageDao;
-    private String defaultJavaPackageTest;
-    private final List<Entity> entities;
-    private Map<PropertyType, String> propertyToDbType;
-    private Map<PropertyType, String> propertyToJavaTypeNotNull;
-    private Map<PropertyType, String> propertyToJavaTypeNullable;
-    private boolean hasKeepSectionsByDefault;
-    private boolean useActiveEntitiesByDefault;
-
-    public Schema(int version, String defaultJavaPackage) {
-        this.version = version;
-        this.defaultJavaPackage = defaultJavaPackage;
-        this.entities = new ArrayList<Entity>();
-        initTypeMappings();
-    }
-
-    public void enableKeepSectionsByDefault() {
-        hasKeepSectionsByDefault = true;
-    }
-
-    public void enableActiveEntitiesByDefault() {
-        useActiveEntitiesByDefault = true;
-    }
-
-    private void initTypeMappings() {
-        propertyToDbType = new HashMap<PropertyType, String>();
-        propertyToDbType.put(PropertyType.Boolean, "INTEGER");
-        propertyToDbType.put(PropertyType.Byte, "INTEGER");
-        propertyToDbType.put(PropertyType.Short, "INTEGER");
-        propertyToDbType.put(PropertyType.Int, "INTEGER");
-        propertyToDbType.put(PropertyType.Long, "INTEGER");
-        propertyToDbType.put(PropertyType.Float, "REAL");
-        propertyToDbType.put(PropertyType.Double, "REAL");
-        propertyToDbType.put(PropertyType.String, "TEXT");
-        propertyToDbType.put(PropertyType.ByteArray, "BLOB");
-        propertyToDbType.put(PropertyType.Date, "INTEGER");
-
-        propertyToJavaTypeNotNull = new HashMap<PropertyType, String>();
-        propertyToJavaTypeNotNull.put(PropertyType.Boolean, "boolean");
-        propertyToJavaTypeNotNull.put(PropertyType.Byte, "byte");
-        propertyToJavaTypeNotNull.put(PropertyType.Short, "short");
-        propertyToJavaTypeNotNull.put(PropertyType.Int, "int");
-        propertyToJavaTypeNotNull.put(PropertyType.Long, "long");
-        propertyToJavaTypeNotNull.put(PropertyType.Float, "float");
-        propertyToJavaTypeNotNull.put(PropertyType.Double, "double");
-        propertyToJavaTypeNotNull.put(PropertyType.String, "String");
-        propertyToJavaTypeNotNull.put(PropertyType.ByteArray, "byte[]");
-        propertyToJavaTypeNotNull.put(PropertyType.Date, "java.util.Date");
-
-        propertyToJavaTypeNullable = new HashMap<PropertyType, String>();
-        propertyToJavaTypeNullable.put(PropertyType.Boolean, "Boolean");
-        propertyToJavaTypeNullable.put(PropertyType.Byte, "Byte");
-        propertyToJavaTypeNullable.put(PropertyType.Short, "Short");
-        propertyToJavaTypeNullable.put(PropertyType.Int, "Integer");
-        propertyToJavaTypeNullable.put(PropertyType.Long, "Long");
-        propertyToJavaTypeNullable.put(PropertyType.Float, "Float");
-        propertyToJavaTypeNullable.put(PropertyType.Double, "Double");
-        propertyToJavaTypeNullable.put(PropertyType.String, "String");
-        propertyToJavaTypeNullable.put(PropertyType.ByteArray, "byte[]");
-        propertyToJavaTypeNullable.put(PropertyType.Date, "java.util.Date");
-    }
-
-    /**
-     * Adds a new entity to the schema. There can be multiple entities per table, but only one may be the primary entity
-     * per table to create table scripts, etc.
-     */
-    public Entity addEntity(String className) {
-        Entity entity = new Entity(this, className);
-        entities.add(entity);
-        return entity;
-    }
-
-    /**
-     * Adds a new protocol buffers entity to the schema. There can be multiple entities per table, but only one may be
-     * the primary entity per table to create table scripts, etc.
-     */
-    public Entity addProtobufEntity(String className) {
-        Entity entity = addEntity(className);
-        entity.useProtobuf();
-        return entity;
-    }
-
-    public String mapToDbType(PropertyType propertyType) {
-        return mapType(propertyToDbType, propertyType);
-    }
-
-    public String mapToJavaTypeNullable(PropertyType propertyType) {
-        return mapType(propertyToJavaTypeNullable, propertyType);
-    }
-
-    public String mapToJavaTypeNotNull(PropertyType propertyType) {
-        return mapType(propertyToJavaTypeNotNull, propertyType);
-    }
-
-    private String mapType(Map<PropertyType, String> map, PropertyType propertyType) {
-        String dbType = map.get(propertyType);
-        if (dbType == null) {
-            throw new IllegalStateException("No mapping for " + propertyType);
-        }
-        return dbType;
-    }
-
-    public int getVersion() {
-        return version;
-    }
-
-    public String getDefaultJavaPackage() {
-        return defaultJavaPackage;
-    }
-
-    public String getDefaultJavaPackageDao() {
-        return defaultJavaPackageDao;
-    }
-
-    public void setDefaultJavaPackageDao(String defaultJavaPackageDao) {
-        this.defaultJavaPackageDao = defaultJavaPackageDao;
-    }
-
-    public String getDefaultJavaPackageTest() {
-        return defaultJavaPackageTest;
-    }
-
-    public void setDefaultJavaPackageTest(String defaultJavaPackageTest) {
-        this.defaultJavaPackageTest = defaultJavaPackageTest;
-    }
-
-    public List<Entity> getEntities() {
-        return entities;
-    }
-
-    public boolean isHasKeepSectionsByDefault() {
-        return hasKeepSectionsByDefault;
-    }
-
-    public boolean isUseActiveEntitiesByDefault() {
-        return useActiveEntitiesByDefault;
-    }
-
-    void init2ndPass() {
-        if (defaultJavaPackageDao == null) {
-            defaultJavaPackageDao = defaultJavaPackage;
-        }
-        if (defaultJavaPackageTest == null) {
-            defaultJavaPackageTest = defaultJavaPackageDao;
-        }
-        for (Entity entity : entities) {
-            entity.init2ndPass();
-        }
-    }
-
-    void init3ndPass() {
-        for (Entity entity : entities) {
-            entity.init3ndPass();
-        }
-    }
-
-}
+/*
+ * Copyright (C) 2011-2015 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daogenerator;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * The "root" model class to which you can add entities to.
+ * 
+ * @see <a href="http://greendao-orm.com/documentation/modelling-entities/">Modelling Entities (Documentation page)</a>
+ */
+public class Schema {
+    private final int version;
+    private final String defaultJavaPackage;
+    private String defaultJavaPackageDao;
+    private String defaultJavaPackageTest;
+    private final List<Entity> entities;
+    private Map<PropertyType, String> propertyToDbType;
+    private Map<PropertyType, String> propertyToJavaTypeNotNull;
+    private Map<PropertyType, String> propertyToJavaTypeNullable;
+    private boolean hasKeepSectionsByDefault;
+    private boolean useActiveEntitiesByDefault;
+
+    public Schema(int version, String defaultJavaPackage) {
+        this.version = version;
+        this.defaultJavaPackage = defaultJavaPackage;
+        this.entities = new ArrayList<Entity>();
+        initTypeMappings();
+    }
+
+    public void enableKeepSectionsByDefault() {
+        hasKeepSectionsByDefault = true;
+    }
+
+    public void enableActiveEntitiesByDefault() {
+        useActiveEntitiesByDefault = true;
+    }
+
+    private void initTypeMappings() {
+        propertyToDbType = new HashMap<PropertyType, String>();
+        propertyToDbType.put(PropertyType.Boolean, "INTEGER");
+        propertyToDbType.put(PropertyType.Byte, "INTEGER");
+        propertyToDbType.put(PropertyType.Short, "INTEGER");
+        propertyToDbType.put(PropertyType.Int, "INTEGER");
+        propertyToDbType.put(PropertyType.Long, "INTEGER");
+        propertyToDbType.put(PropertyType.Float, "REAL");
+        propertyToDbType.put(PropertyType.Double, "REAL");
+        propertyToDbType.put(PropertyType.String, "TEXT");
+        propertyToDbType.put(PropertyType.ByteArray, "BLOB");
+        propertyToDbType.put(PropertyType.Date, "INTEGER");
+
+        propertyToJavaTypeNotNull = new HashMap<PropertyType, String>();
+        propertyToJavaTypeNotNull.put(PropertyType.Boolean, "boolean");
+        propertyToJavaTypeNotNull.put(PropertyType.Byte, "byte");
+        propertyToJavaTypeNotNull.put(PropertyType.Short, "short");
+        propertyToJavaTypeNotNull.put(PropertyType.Int, "int");
+        propertyToJavaTypeNotNull.put(PropertyType.Long, "long");
+        propertyToJavaTypeNotNull.put(PropertyType.Float, "float");
+        propertyToJavaTypeNotNull.put(PropertyType.Double, "double");
+        propertyToJavaTypeNotNull.put(PropertyType.String, "String");
+        propertyToJavaTypeNotNull.put(PropertyType.ByteArray, "byte[]");
+        propertyToJavaTypeNotNull.put(PropertyType.Date, "java.util.Date");
+
+        propertyToJavaTypeNullable = new HashMap<PropertyType, String>();
+        propertyToJavaTypeNullable.put(PropertyType.Boolean, "Boolean");
+        propertyToJavaTypeNullable.put(PropertyType.Byte, "Byte");
+        propertyToJavaTypeNullable.put(PropertyType.Short, "Short");
+        propertyToJavaTypeNullable.put(PropertyType.Int, "Integer");
+        propertyToJavaTypeNullable.put(PropertyType.Long, "Long");
+        propertyToJavaTypeNullable.put(PropertyType.Float, "Float");
+        propertyToJavaTypeNullable.put(PropertyType.Double, "Double");
+        propertyToJavaTypeNullable.put(PropertyType.String, "String");
+        propertyToJavaTypeNullable.put(PropertyType.ByteArray, "byte[]");
+        propertyToJavaTypeNullable.put(PropertyType.Date, "java.util.Date");
+    }
+
+    /**
+     * Adds a new entity to the schema. There can be multiple entities per table, but only one may be the primary entity
+     * per table to create table scripts, etc.
+     */
+    public Entity addEntity(String className) {
+        Entity entity = new Entity(this, className);
+        entities.add(entity);
+        return entity;
+    }
+
+    /**
+     * Adds a new protocol buffers entity to the schema. There can be multiple entities per table, but only one may be
+     * the primary entity per table to create table scripts, etc.
+     */
+    public Entity addProtobufEntity(String className) {
+        Entity entity = addEntity(className);
+        entity.useProtobuf();
+        return entity;
+    }
+
+    public String mapToDbType(PropertyType propertyType) {
+        return mapType(propertyToDbType, propertyType);
+    }
+
+    public String mapToJavaTypeNullable(PropertyType propertyType) {
+        return mapType(propertyToJavaTypeNullable, propertyType);
+    }
+
+    public String mapToJavaTypeNotNull(PropertyType propertyType) {
+        return mapType(propertyToJavaTypeNotNull, propertyType);
+    }
+
+    private String mapType(Map<PropertyType, String> map, PropertyType propertyType) {
+        String dbType = map.get(propertyType);
+        if (dbType == null) {
+            throw new IllegalStateException("No mapping for " + propertyType);
+        }
+        return dbType;
+    }
+
+    public int getVersion() {
+        return version;
+    }
+
+    public String getDefaultJavaPackage() {
+        return defaultJavaPackage;
+    }
+
+    public String getDefaultJavaPackageDao() {
+        return defaultJavaPackageDao;
+    }
+
+    public void setDefaultJavaPackageDao(String defaultJavaPackageDao) {
+        this.defaultJavaPackageDao = defaultJavaPackageDao;
+    }
+
+    public String getDefaultJavaPackageTest() {
+        return defaultJavaPackageTest;
+    }
+
+    public void setDefaultJavaPackageTest(String defaultJavaPackageTest) {
+        this.defaultJavaPackageTest = defaultJavaPackageTest;
+    }
+
+    public List<Entity> getEntities() {
+        return entities;
+    }
+
+    public boolean isHasKeepSectionsByDefault() {
+        return hasKeepSectionsByDefault;
+    }
+
+    public boolean isUseActiveEntitiesByDefault() {
+        return useActiveEntitiesByDefault;
+    }
+
+    void init2ndPass() {
+        if (defaultJavaPackageDao == null) {
+            defaultJavaPackageDao = defaultJavaPackage;
+        }
+        if (defaultJavaPackageTest == null) {
+            defaultJavaPackageTest = defaultJavaPackageDao;
+        }
+        for (Entity entity : entities) {
+            entity.init2ndPass();
+        }
+    }
+
+    void init3rdPass() {
+        for (Entity entity : entities) {
+            entity.init3rdPass();
+        }
+    }
+
+}
diff --git a/DaoGenerator/src/de/greenrobot/daogenerator/ToMany.java b/DaoGenerator/src/de/greenrobot/daogenerator/ToMany.java
index 67ca76aa..5b8611b2 100644
--- a/DaoGenerator/src/de/greenrobot/daogenerator/ToMany.java
+++ b/DaoGenerator/src/de/greenrobot/daogenerator/ToMany.java
@@ -1,143 +1,81 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daogenerator;
-
-import java.util.List;
-
-/** To-many relationship from a source entity to many target entitites. */
-public class ToMany {
-    @SuppressWarnings("unused")
-    private final Schema schema;
-    private String name;
-    private final Entity sourceEntity;
-    private final Entity targetEntity;
-    private Property[] sourceProperties;
-    private final Property[] targetProperties;
-    private final PropertyOrderList propertyOrderList;
-
-    public ToMany(Schema schema, Entity sourceEntity, Property[] sourceProperties, Entity targetEntity,
-            Property[] targetProperties) {
-        this.schema = schema;
-        this.sourceEntity = sourceEntity;
-        this.targetEntity = targetEntity;
-        this.sourceProperties = sourceProperties;
-        this.targetProperties = targetProperties;
-        propertyOrderList = new PropertyOrderList();
-    }
-
-    public Entity getSourceEntity() {
-        return sourceEntity;
-    }
-
-    public Entity getTargetEntity() {
-        return targetEntity;
-    }
-
-    public Property[] getSourceProperties() {
-        return sourceProperties;
-    }
-
-    public void setSourceProperties(Property[] sourceProperties) {
-        this.sourceProperties = sourceProperties;
-    }
-
-    public Property[] getTargetProperties() {
-        return targetProperties;
-    }
-
-    public String getName() {
-        return name;
-    }
-
-    /**
-     * Sets the name of the relation, which is used as the property name in the entity (the source entity owning the
-     * to-many relationship).
-     */
-    public void setName(String name) {
-        this.name = name;
-    }
-
-    /** Property of target entity used for ascending order. */
-    public void orderAsc(Property... properties) {
-        for (Property property : properties) {
-            targetEntity.validatePropertyExists(property);
-            propertyOrderList.addPropertyAsc(property);
-        }
-    }
-
-    /** Property of target entity used for descending order. */
-    public void orderDesc(Property... properties) {
-        for (Property property : properties) {
-            targetEntity.validatePropertyExists(property);
-            propertyOrderList.addPropertyDesc(property);
-        }
-    }
-
-    public String getOrder() {
-        if (propertyOrderList.isEmpty()) {
-            return null;
-        } else {
-            return propertyOrderList.getCommaSeparatedString();
-        }
-    }
-
-    void init2ndPass() {
-        if (name == null) {
-            char[] nameCharArray = targetEntity.getClassName().toCharArray();
-            nameCharArray[0] = Character.toLowerCase(nameCharArray[0]);
-            name = new String(nameCharArray) + "List";
-        }
-        if (sourceProperties == null) {
-            List<Property> pks = sourceEntity.getPropertiesPk();
-            if (pks.isEmpty()) {
-                throw new RuntimeException("Source entity has no primary key, but we need it for " + this);
-            }
-            sourceProperties = new Property[pks.size()];
-            sourceProperties = pks.toArray(sourceProperties);
-        }
-        int count = sourceProperties.length;
-        if (count != targetProperties.length) {
-            throw new RuntimeException("Source properties do not match target properties: " + this);
-        }
-
-        for (int i = 0; i < count; i++) {
-            Property sourceProperty = sourceProperties[i];
-            Property targetProperty = targetProperties[i];
-
-            PropertyType sourceType = sourceProperty.getPropertyType();
-            PropertyType targetType = targetProperty.getPropertyType();
-            if (sourceType == null || targetType == null) {
-                throw new RuntimeException("Property type uninitialized");
-            }
-            if (sourceType != targetType) {
-                System.err.println("Warning to-one property type does not match target key type: " + this);
-            }
-        }
-    }
-
-    void init3ndPass() {
-    }
-
-    @Override
-    public String toString() {
-        String sourceName = sourceEntity != null ? sourceEntity.getClassName() : null;
-        String targetName = targetEntity != null ? targetEntity.getClassName() : null;
-        return "ToMany '" + name + "' from " + sourceName + " to " + targetName;
-    }
-
-}
+/*
+ * Copyright (C) 2011-2015 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daogenerator;
+
+import java.util.List;
+
+/** To-many relationship from a source entity to many target entities. */
+public class ToMany extends ToManyBase {
+    @SuppressWarnings("unused")
+    private Property[] sourceProperties;
+    private final Property[] targetProperties;
+
+    public ToMany(Schema schema, Entity sourceEntity, Property[] sourceProperties, Entity targetEntity,
+            Property[] targetProperties) {
+        super(schema, sourceEntity, targetEntity);
+        this.sourceProperties = sourceProperties;
+        this.targetProperties = targetProperties;
+    }
+
+    public Property[] getSourceProperties() {
+        return sourceProperties;
+    }
+
+    public void setSourceProperties(Property[] sourceProperties) {
+        this.sourceProperties = sourceProperties;
+    }
+
+    public Property[] getTargetProperties() {
+        return targetProperties;
+    }
+
+    void init2ndPass() {
+        super.init2ndPass();
+        if (sourceProperties == null) {
+            List<Property> pks = sourceEntity.getPropertiesPk();
+            if (pks.isEmpty()) {
+                throw new RuntimeException("Source entity has no primary key, but we need it for " + this);
+            }
+            sourceProperties = new Property[pks.size()];
+            sourceProperties = pks.toArray(sourceProperties);
+        }
+        int count = sourceProperties.length;
+        if (count != targetProperties.length) {
+            throw new RuntimeException("Source properties do not match target properties: " + this);
+        }
+
+        for (int i = 0; i < count; i++) {
+            Property sourceProperty = sourceProperties[i];
+            Property targetProperty = targetProperties[i];
+
+            PropertyType sourceType = sourceProperty.getPropertyType();
+            PropertyType targetType = targetProperty.getPropertyType();
+            if (sourceType == null || targetType == null) {
+                throw new RuntimeException("Property type uninitialized");
+            }
+            if (sourceType != targetType) {
+                System.err.println("Warning to-one property type does not match target key type: " + this);
+            }
+        }
+    }
+
+    void init3rdPass() {
+        super.init3rdPass();
+    }
+
+}
diff --git a/DaoGenerator/src/de/greenrobot/daogenerator/ToManyBase.java b/DaoGenerator/src/de/greenrobot/daogenerator/ToManyBase.java
new file mode 100644
index 00000000..699cac11
--- /dev/null
+++ b/DaoGenerator/src/de/greenrobot/daogenerator/ToManyBase.java
@@ -0,0 +1,99 @@
+/*
+ * Copyright (C) 2011-2015 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daogenerator;
+
+/** Base class for to-many relationship from source entities to target entities. */
+public abstract class ToManyBase {
+    @SuppressWarnings("unused")
+    private final Schema schema;
+    private String name;
+    protected final Entity sourceEntity;
+    protected final Entity targetEntity;
+    private final PropertyOrderList propertyOrderList;
+
+    public ToManyBase(Schema schema, Entity sourceEntity, Entity targetEntity) {
+        this.schema = schema;
+        this.sourceEntity = sourceEntity;
+        this.targetEntity = targetEntity;
+        propertyOrderList = new PropertyOrderList();
+    }
+
+    public Entity getSourceEntity() {
+        return sourceEntity;
+    }
+
+    public Entity getTargetEntity() {
+        return targetEntity;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    /**
+     * Sets the name of the relation, which is used as the property name in the entity (the source entity owning the
+     * to-many relationship).
+     */
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    /** Property of target entity used for ascending order. */
+    public void orderAsc(Property... properties) {
+        for (Property property : properties) {
+            targetEntity.validatePropertyExists(property);
+            propertyOrderList.addPropertyAsc(property);
+        }
+    }
+
+    /** Property of target entity used for descending order. */
+    public void orderDesc(Property... properties) {
+        for (Property property : properties) {
+            targetEntity.validatePropertyExists(property);
+            propertyOrderList.addPropertyDesc(property);
+        }
+    }
+
+    public String getOrder() {
+        if (propertyOrderList.isEmpty()) {
+            return null;
+        } else {
+            // Table prefix must match default of QueryBuilder in DaoCore
+            return propertyOrderList.getCommaSeparatedString("T");
+        }
+    }
+
+    void init2ndPass() {
+        if (name == null) {
+            char[] nameCharArray = targetEntity.getClassName().toCharArray();
+            nameCharArray[0] = Character.toLowerCase(nameCharArray[0]);
+            name = new String(nameCharArray) + "List";
+        }
+    }
+
+    void init3rdPass() {
+    }
+
+    @Override
+    public String toString() {
+        String sourceName = sourceEntity != null ? sourceEntity.getClassName() : null;
+        String targetName = targetEntity != null ? targetEntity.getClassName() : null;
+        return "ToMany '" + name + "' from " + sourceName + " to " + targetName;
+    }
+
+}
diff --git a/DaoGenerator/src/de/greenrobot/daogenerator/ToManyWithJoinEntity.java b/DaoGenerator/src/de/greenrobot/daogenerator/ToManyWithJoinEntity.java
new file mode 100644
index 00000000..0f897f05
--- /dev/null
+++ b/DaoGenerator/src/de/greenrobot/daogenerator/ToManyWithJoinEntity.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2011-2015 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daogenerator;
+
+import java.util.List;
+
+/** To-many relationship to many target entities using a join entity (aka JOIN table). */
+public class ToManyWithJoinEntity extends ToManyBase {
+    private final Entity joinEntity;
+    private final Property sourceProperty;
+    private final Property targetProperty;
+
+    public ToManyWithJoinEntity(Schema schema, Entity sourceEntity, Entity targetEntity, Entity joinEntity,
+                                Property sourceProperty, Property targetProperty) {
+        super(schema, sourceEntity, targetEntity);
+        this.joinEntity = joinEntity;
+        this.sourceProperty = sourceProperty;
+        this.targetProperty = targetProperty;
+    }
+
+    public Entity getJoinEntity() {
+        return joinEntity;
+    }
+
+    public Property getSourceProperty() {
+        return sourceProperty;
+    }
+
+    public Property getTargetProperty() {
+        return targetProperty;
+    }
+
+    void init3rdPass() {
+        super.init3rdPass();
+        List<Property> pks = sourceEntity.getPropertiesPk();
+        if (pks.isEmpty()) {
+            throw new RuntimeException("Source entity has no primary key, but we need it for " + this);
+        }
+        List<Property> pks2 = targetEntity.getPropertiesPk();
+        if (pks2.isEmpty()) {
+            throw new RuntimeException("Target entity has no primary key, but we need it for " + this);
+        }
+    }
+
+}
diff --git a/DaoGenerator/src/de/greenrobot/daogenerator/ToOne.java b/DaoGenerator/src/de/greenrobot/daogenerator/ToOne.java
index 82cb34f6..2a71e5f5 100644
--- a/DaoGenerator/src/de/greenrobot/daogenerator/ToOne.java
+++ b/DaoGenerator/src/de/greenrobot/daogenerator/ToOne.java
@@ -1,134 +1,134 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daogenerator;
-
-/** To-one relationship from a source entity to one (or zero) target entity. */
-public class ToOne {
-    private final Schema schema;
-    private final Entity sourceEntity;
-    private final Entity targetEntity;
-    private final Property[] fkProperties;
-    private final String[] resolvedKeyJavaType;
-    private final boolean[] resolvedKeyUseEquals;
-    private String name;
-    private final boolean useFkProperty;
-
-    public ToOne(Schema schema, Entity sourceEntity, Entity targetEntity, Property[] fkProperties, boolean useFkProperty) {
-        this.schema = schema;
-        this.sourceEntity = sourceEntity;
-        this.targetEntity = targetEntity;
-        this.fkProperties = fkProperties;
-        this.useFkProperty = useFkProperty;
-        resolvedKeyJavaType = new String[fkProperties.length];
-        resolvedKeyUseEquals = new boolean[fkProperties.length];
-    }
-
-    public Entity getSourceEntity() {
-        return sourceEntity;
-    }
-
-    public Entity getTargetEntity() {
-        return targetEntity;
-    }
-
-    public Property[] getFkProperties() {
-        return fkProperties;
-    }
-
-    public String[] getResolvedKeyJavaType() {
-        return resolvedKeyJavaType;
-    }
-
-    public boolean[] getResolvedKeyUseEquals() {
-        return resolvedKeyUseEquals;
-    }
-
-    public String getName() {
-        return name;
-    }
-
-    /**
-     * Sets the name of the relation, which is used as the property name in the entity (the source entity owning the
-     * to-many relationship).
-     */
-    public void setName(String name) {
-        this.name = name;
-    }
-
-    public boolean isUseFkProperty() {
-        return useFkProperty;
-    }
-
-    void init2ndPass() {
-        if (name == null) {
-            char[] nameCharArray = targetEntity.getClassName().toCharArray();
-            nameCharArray[0] = Character.toLowerCase(nameCharArray[0]);
-            name = new String(nameCharArray);
-        }
-
-    }
-
-    /** Constructs fkColumns. Depends on 2nd pass of target key properties. */
-    void init3ndPass() {
-
-        Property targetPkProperty = targetEntity.getPkProperty();
-        if (fkProperties.length != 1 || targetPkProperty == null) {
-            throw new RuntimeException("Currently only single FK columns are supported: " + this);
-        }
-
-        Property property = fkProperties[0];
-        PropertyType propertyType = property.getPropertyType();
-        if (propertyType == null) {
-            propertyType = targetPkProperty.getPropertyType();
-            property.setPropertyType(propertyType);
-            // Property is not a regular property with primitive getters/setters, so let it catch up
-            property.init2ndPass();
-            property.init3ndPass();
-        } else if (propertyType != targetPkProperty.getPropertyType()) {
-            System.err.println("Warning to-one property type does not match target key type: " + this);
-        }
-        resolvedKeyJavaType[0] = schema.mapToJavaTypeNullable(propertyType);
-        resolvedKeyUseEquals[0] = checkUseEquals(propertyType);
-    }
-
-    protected boolean checkUseEquals(PropertyType propertyType) {
-        boolean useEquals;
-        switch (propertyType) {
-        case Byte:
-        case Short:
-        case Int:
-        case Long:
-        case Boolean:
-        case Float:
-            useEquals = true;
-            break;
-        default:
-            useEquals = false;
-            break;
-        }
-        return useEquals;
-    }
-
-    @Override
-    public String toString() {
-        String sourceName = sourceEntity != null ? sourceEntity.getClassName() : null;
-        String targetName = targetEntity != null ? targetEntity.getClassName() : null;
-        return "ToOne '" + name + "' from " + sourceName + " to " + targetName;
-    }
-
-}
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daogenerator;
+
+/** To-one relationship from a source entity to one (or zero) target entity. */
+public class ToOne {
+    private final Schema schema;
+    private final Entity sourceEntity;
+    private final Entity targetEntity;
+    private final Property[] fkProperties;
+    private final String[] resolvedKeyJavaType;
+    private final boolean[] resolvedKeyUseEquals;
+    private String name;
+    private final boolean useFkProperty;
+
+    public ToOne(Schema schema, Entity sourceEntity, Entity targetEntity, Property[] fkProperties, boolean useFkProperty) {
+        this.schema = schema;
+        this.sourceEntity = sourceEntity;
+        this.targetEntity = targetEntity;
+        this.fkProperties = fkProperties;
+        this.useFkProperty = useFkProperty;
+        resolvedKeyJavaType = new String[fkProperties.length];
+        resolvedKeyUseEquals = new boolean[fkProperties.length];
+    }
+
+    public Entity getSourceEntity() {
+        return sourceEntity;
+    }
+
+    public Entity getTargetEntity() {
+        return targetEntity;
+    }
+
+    public Property[] getFkProperties() {
+        return fkProperties;
+    }
+
+    public String[] getResolvedKeyJavaType() {
+        return resolvedKeyJavaType;
+    }
+
+    public boolean[] getResolvedKeyUseEquals() {
+        return resolvedKeyUseEquals;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    /**
+     * Sets the name of the relation, which is used as the property name in the entity (the source entity owning the
+     * to-many relationship).
+     */
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    public boolean isUseFkProperty() {
+        return useFkProperty;
+    }
+
+    void init2ndPass() {
+        if (name == null) {
+            char[] nameCharArray = targetEntity.getClassName().toCharArray();
+            nameCharArray[0] = Character.toLowerCase(nameCharArray[0]);
+            name = new String(nameCharArray);
+        }
+
+    }
+
+    /** Constructs fkColumns. Depends on 2nd pass of target key properties. */
+    void init3ndPass() {
+
+        Property targetPkProperty = targetEntity.getPkProperty();
+        if (fkProperties.length != 1 || targetPkProperty == null) {
+            throw new RuntimeException("Currently only single FK columns are supported: " + this);
+        }
+
+        Property property = fkProperties[0];
+        PropertyType propertyType = property.getPropertyType();
+        if (propertyType == null) {
+            propertyType = targetPkProperty.getPropertyType();
+            property.setPropertyType(propertyType);
+            // Property is not a regular property with primitive getters/setters, so let it catch up
+            property.init2ndPass();
+            property.init3ndPass();
+        } else if (propertyType != targetPkProperty.getPropertyType()) {
+            System.err.println("Warning to-one property type does not match target key type: " + this);
+        }
+        resolvedKeyJavaType[0] = schema.mapToJavaTypeNullable(propertyType);
+        resolvedKeyUseEquals[0] = checkUseEquals(propertyType);
+    }
+
+    protected boolean checkUseEquals(PropertyType propertyType) {
+        boolean useEquals;
+        switch (propertyType) {
+        case Byte:
+        case Short:
+        case Int:
+        case Long:
+        case Boolean:
+        case Float:
+            useEquals = true;
+            break;
+        default:
+            useEquals = false;
+            break;
+        }
+        return useEquals;
+    }
+
+    @Override
+    public String toString() {
+        String sourceName = sourceEntity != null ? sourceEntity.getClassName() : null;
+        String targetName = targetEntity != null ? targetEntity.getClassName() : null;
+        return "ToOne '" + name + "' from " + sourceName + " to " + targetName;
+    }
+
+}
diff --git a/DaoTest/.classpath b/DaoTest/.classpath
deleted file mode 100644
index 80819056..00000000
--- a/DaoTest/.classpath
+++ /dev/null
@@ -1,10 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="src" path="gen"/>
-	<classpathentry kind="src" path="src-gen"/>
-	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
-	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
-	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
-	<classpathentry kind="output" path="bin/classes"/>
-</classpath>
diff --git a/DaoTest/.project b/DaoTest/.project
deleted file mode 100644
index 3bbfbaa0..00000000
--- a/DaoTest/.project
+++ /dev/null
@@ -1,34 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<projectDescription>
-	<name>DaoTest</name>
-	<comment></comment>
-	<projects>
-	</projects>
-	<buildSpec>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>org.eclipse.jdt.core.javabuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-	</buildSpec>
-	<natures>
-		<nature>org.springsource.ide.eclipse.gradle.core.nature</nature>
-		<nature>org.eclipse.jdt.core.javanature</nature>
-		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
-	</natures>
-</projectDescription>
diff --git a/DaoTest/.settings/org.eclipse.core.resources.prefs b/DaoTest/.settings/org.eclipse.core.resources.prefs
deleted file mode 100644
index 3d916f29..00000000
--- a/DaoTest/.settings/org.eclipse.core.resources.prefs
+++ /dev/null
@@ -1,2 +0,0 @@
-eclipse.preferences.version=1
-encoding/<project>=Cp1252
diff --git a/DaoTest/.settings/org.eclipse.jdt.core.prefs b/DaoTest/.settings/org.eclipse.jdt.core.prefs
deleted file mode 100644
index 9128aee6..00000000
--- a/DaoTest/.settings/org.eclipse.jdt.core.prefs
+++ /dev/null
@@ -1,12 +0,0 @@
-#Sat Jan 28 16:28:53 CET 2012
-eclipse.preferences.version=1
-org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
-org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.6
-org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
-org.eclipse.jdt.core.compiler.compliance=1.6
-org.eclipse.jdt.core.compiler.debug.lineNumber=generate
-org.eclipse.jdt.core.compiler.debug.localVariable=generate
-org.eclipse.jdt.core.compiler.debug.sourceFile=generate
-org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
-org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
-org.eclipse.jdt.core.compiler.source=1.6
diff --git a/DaoTest/build.gradle b/DaoTest/build.gradle
index a1f62bca..0947debd 100644
--- a/DaoTest/build.gradle
+++ b/DaoTest/build.gradle
@@ -4,19 +4,22 @@ buildscript {
     }
 
     dependencies {
-        classpath 'com.android.tools.build:gradle:0.10.2'
+        classpath 'com.android.tools.build:gradle:1.3.1'
     }
 }
 
-apply plugin: 'android'
+apply plugin: 'com.android.application'
 
 dependencies {
     androidTestCompile project(':DaoCore')
+
+    testCompile project(':DaoCore')
+    testCompile 'org.robolectric:robolectric:3.0'
 }
 
 android {
-    buildToolsVersion '19.1.0'
-    compileSdkVersion 19
+    buildToolsVersion rootProject.ext.buildToolsVersion
+    compileSdkVersion rootProject.ext.compileSdkVersion
 
     sourceSets {
         main {
@@ -27,12 +30,16 @@ android {
 
         androidTest {
             assets.srcDirs = ['assets']
-            java.srcDirs = ['src','src-gen']
+            java.srcDirs = ['src', 'src-gen']
+        }
+
+        unitTest {
+            java.srcDirs = ['src-unit-test']
         }
     }
 
     defaultConfig {
-        testPackageName "de.greenrobot.daotest"
+        testApplicationId "de.greenrobot.daotest"
         testInstrumentationRunner "android.test.InstrumentationTestRunner"
     }
 }
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/AbcdefEntity.java b/DaoTest/src-gen/de/greenrobot/daotest/AbcdefEntity.java
index e441334f..57bc708a 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/AbcdefEntity.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/AbcdefEntity.java
@@ -2,7 +2,7 @@
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
 /**
- * Entity mapped to table ABCDEF_ENTITY.
+ * Entity mapped to table "ABCDEF_ENTITY".
  */
 public class AbcdefEntity {
 
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/AbcdefEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/AbcdefEntityDao.java
index 63bcfc74..ef47a89d 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/AbcdefEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/AbcdefEntityDao.java
@@ -12,7 +12,7 @@
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
- * DAO for table ABCDEF_ENTITY.
+ * DAO for table "ABCDEF_ENTITY".
 */
 public class AbcdefEntityDao extends AbstractDao<AbcdefEntity, Long> {
 
@@ -49,24 +49,24 @@ public AbcdefEntityDao(DaoConfig config, DaoSession daoSession) {
     /** Creates the underlying database table. */
     public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
-        db.execSQL("CREATE TABLE " + constraint + "'ABCDEF_ENTITY' (" + //
-                "'_id' INTEGER PRIMARY KEY ," + // 0: id
-                "'A' INTEGER," + // 1: a
-                "'B' INTEGER," + // 2: b
-                "'C' INTEGER," + // 3: c
-                "'D' INTEGER," + // 4: d
-                "'E' INTEGER," + // 5: e
-                "'F' INTEGER," + // 6: f
-                "'G' INTEGER," + // 7: g
-                "'H' INTEGER," + // 8: h
-                "'J' INTEGER," + // 9: j
-                "'I' INTEGER," + // 10: i
-                "'K' INTEGER);"); // 11: k
+        db.execSQL("CREATE TABLE " + constraint + "\"ABCDEF_ENTITY\" (" + //
+                "\"_id\" INTEGER PRIMARY KEY ," + // 0: id
+                "\"A\" INTEGER," + // 1: a
+                "\"B\" INTEGER," + // 2: b
+                "\"C\" INTEGER," + // 3: c
+                "\"D\" INTEGER," + // 4: d
+                "\"E\" INTEGER," + // 5: e
+                "\"F\" INTEGER," + // 6: f
+                "\"G\" INTEGER," + // 7: g
+                "\"H\" INTEGER," + // 8: h
+                "\"J\" INTEGER," + // 9: j
+                "\"I\" INTEGER," + // 10: i
+                "\"K\" INTEGER);"); // 11: k
     }
 
     /** Drops the underlying database table. */
     public static void dropTable(SQLiteDatabase db, boolean ifExists) {
-        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'ABCDEF_ENTITY'";
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "\"ABCDEF_ENTITY\"";
         db.execSQL(sql);
     }
 
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/AnActiveEntity.java b/DaoTest/src-gen/de/greenrobot/daotest/AnActiveEntity.java
index bcd27a00..0ce14697 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/AnActiveEntity.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/AnActiveEntity.java
@@ -5,7 +5,7 @@
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
 /**
- * Entity mapped to table AN_ACTIVE_ENTITY.
+ * Entity mapped to table "AN_ACTIVE_ENTITY".
  */
 public class AnActiveEntity {
 
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/AnActiveEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/AnActiveEntityDao.java
index 21837b20..91fe814c 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/AnActiveEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/AnActiveEntityDao.java
@@ -12,7 +12,7 @@
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
- * DAO for table AN_ACTIVE_ENTITY.
+ * DAO for table "AN_ACTIVE_ENTITY".
 */
 public class AnActiveEntityDao extends AbstractDao<AnActiveEntity, Long> {
 
@@ -42,14 +42,14 @@ public AnActiveEntityDao(DaoConfig config, DaoSession daoSession) {
     /** Creates the underlying database table. */
     public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
-        db.execSQL("CREATE TABLE " + constraint + "'AN_ACTIVE_ENTITY' (" + //
-                "'_id' INTEGER PRIMARY KEY ," + // 0: id
-                "'TEXT' TEXT);"); // 1: text
+        db.execSQL("CREATE TABLE " + constraint + "\"AN_ACTIVE_ENTITY\" (" + //
+                "\"_id\" INTEGER PRIMARY KEY ," + // 0: id
+                "\"TEXT\" TEXT);"); // 1: text
     }
 
     /** Drops the underlying database table. */
     public static void dropTable(SQLiteDatabase db, boolean ifExists) {
-        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'AN_ACTIVE_ENTITY'";
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "\"AN_ACTIVE_ENTITY\"";
         db.execSQL(sql);
     }
 
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/AutoincrementEntity.java b/DaoTest/src-gen/de/greenrobot/daotest/AutoincrementEntity.java
index cc81483c..f2706c00 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/AutoincrementEntity.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/AutoincrementEntity.java
@@ -2,7 +2,7 @@
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
 /**
- * Entity mapped to table AUTOINCREMENT_ENTITY.
+ * Entity mapped to table "AUTOINCREMENT_ENTITY".
  */
 public class AutoincrementEntity {
 
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/AutoincrementEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/AutoincrementEntityDao.java
index 344db8df..95fe147e 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/AutoincrementEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/AutoincrementEntityDao.java
@@ -12,7 +12,7 @@
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
- * DAO for table AUTOINCREMENT_ENTITY.
+ * DAO for table "AUTOINCREMENT_ENTITY".
 */
 public class AutoincrementEntityDao extends AbstractDao<AutoincrementEntity, Long> {
 
@@ -38,13 +38,13 @@ public AutoincrementEntityDao(DaoConfig config, DaoSession daoSession) {
     /** Creates the underlying database table. */
     public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
-        db.execSQL("CREATE TABLE " + constraint + "'AUTOINCREMENT_ENTITY' (" + //
-                "'_id' INTEGER PRIMARY KEY AUTOINCREMENT );"); // 0: id
+        db.execSQL("CREATE TABLE " + constraint + "\"AUTOINCREMENT_ENTITY\" (" + //
+                "\"_id\" INTEGER PRIMARY KEY AUTOINCREMENT );"); // 0: id
     }
 
     /** Drops the underlying database table. */
     public static void dropTable(SQLiteDatabase db, boolean ifExists) {
-        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'AUTOINCREMENT_ENTITY'";
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "\"AUTOINCREMENT_ENTITY\"";
         db.execSQL(sql);
     }
 
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/CustomTypeEntity.java b/DaoTest/src-gen/de/greenrobot/daotest/CustomTypeEntity.java
new file mode 100644
index 00000000..0b3e21d0
--- /dev/null
+++ b/DaoTest/src-gen/de/greenrobot/daotest/CustomTypeEntity.java
@@ -0,0 +1,42 @@
+package de.greenrobot.daotest;
+
+import de.greenrobot.daotest.customtype.MyTimestamp;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
+/**
+ * Entity mapped to table "CUSTOM_TYPE_ENTITY".
+ */
+public class CustomTypeEntity {
+
+    private Long id;
+    private MyTimestamp myCustomTimestamp;
+
+    public CustomTypeEntity() {
+    }
+
+    public CustomTypeEntity(Long id) {
+        this.id = id;
+    }
+
+    public CustomTypeEntity(Long id, MyTimestamp myCustomTimestamp) {
+        this.id = id;
+        this.myCustomTimestamp = myCustomTimestamp;
+    }
+
+    public Long getId() {
+        return id;
+    }
+
+    public void setId(Long id) {
+        this.id = id;
+    }
+
+    public MyTimestamp getMyCustomTimestamp() {
+        return myCustomTimestamp;
+    }
+
+    public void setMyCustomTimestamp(MyTimestamp myCustomTimestamp) {
+        this.myCustomTimestamp = myCustomTimestamp;
+    }
+
+}
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/CustomTypeEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/CustomTypeEntityDao.java
new file mode 100644
index 00000000..32cf4e6a
--- /dev/null
+++ b/DaoTest/src-gen/de/greenrobot/daotest/CustomTypeEntityDao.java
@@ -0,0 +1,119 @@
+package de.greenrobot.daotest;
+
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteStatement;
+
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.Property;
+import de.greenrobot.dao.internal.DaoConfig;
+
+import de.greenrobot.daotest.customtype.MyTimestamp;
+import de.greenrobot.daotest.customtype.MyTimestampConverter;
+
+import de.greenrobot.daotest.CustomTypeEntity;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+/** 
+ * DAO for table "CUSTOM_TYPE_ENTITY".
+*/
+public class CustomTypeEntityDao extends AbstractDao<CustomTypeEntity, Long> {
+
+    public static final String TABLENAME = "CUSTOM_TYPE_ENTITY";
+
+    /**
+     * Properties of entity CustomTypeEntity.<br/>
+     * Can be used for QueryBuilder and for referencing column names.
+    */
+    public static class Properties {
+        public final static Property Id = new Property(0, Long.class, "id", true, "_id");
+        public final static Property MyCustomTimestamp = new Property(1, Long.class, "myCustomTimestamp", false, "MY_CUSTOM_TIMESTAMP");
+    };
+
+    private final MyTimestampConverter myCustomTimestampConverter = new MyTimestampConverter();
+
+    public CustomTypeEntityDao(DaoConfig config) {
+        super(config);
+    }
+    
+    public CustomTypeEntityDao(DaoConfig config, DaoSession daoSession) {
+        super(config, daoSession);
+    }
+
+    /** Creates the underlying database table. */
+    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+        String constraint = ifNotExists? "IF NOT EXISTS ": "";
+        db.execSQL("CREATE TABLE " + constraint + "\"CUSTOM_TYPE_ENTITY\" (" + //
+                "\"_id\" INTEGER PRIMARY KEY ," + // 0: id
+                "\"MY_CUSTOM_TIMESTAMP\" INTEGER);"); // 1: myCustomTimestamp
+    }
+
+    /** Drops the underlying database table. */
+    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "\"CUSTOM_TYPE_ENTITY\"";
+        db.execSQL(sql);
+    }
+
+    /** @inheritdoc */
+    @Override
+    protected void bindValues(SQLiteStatement stmt, CustomTypeEntity entity) {
+        stmt.clearBindings();
+ 
+        Long id = entity.getId();
+        if (id != null) {
+            stmt.bindLong(1, id);
+        }
+ 
+        MyTimestamp myCustomTimestamp = entity.getMyCustomTimestamp();
+        if (myCustomTimestamp != null) {
+            stmt.bindLong(2, myCustomTimestampConverter.convertToDatabaseValue(myCustomTimestamp));
+        }
+    }
+
+    /** @inheritdoc */
+    @Override
+    public Long readKey(Cursor cursor, int offset) {
+        return cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0);
+    }    
+
+    /** @inheritdoc */
+    @Override
+    public CustomTypeEntity readEntity(Cursor cursor, int offset) {
+        CustomTypeEntity entity = new CustomTypeEntity( //
+            cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0), // id
+            cursor.isNull(offset + 1) ? null : myCustomTimestampConverter.convertToEntityProperty(cursor.getLong(offset + 1)) // myCustomTimestamp
+        );
+        return entity;
+    }
+     
+    /** @inheritdoc */
+    @Override
+    public void readEntity(Cursor cursor, CustomTypeEntity entity, int offset) {
+        entity.setId(cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0));
+        entity.setMyCustomTimestamp(cursor.isNull(offset + 1) ? null : myCustomTimestampConverter.convertToEntityProperty(cursor.getLong(offset + 1)));
+     }
+    
+    /** @inheritdoc */
+    @Override
+    protected Long updateKeyAfterInsert(CustomTypeEntity entity, long rowId) {
+        entity.setId(rowId);
+        return rowId;
+    }
+    
+    /** @inheritdoc */
+    @Override
+    public Long getKey(CustomTypeEntity entity) {
+        if(entity != null) {
+            return entity.getId();
+        } else {
+            return null;
+        }
+    }
+
+    /** @inheritdoc */
+    @Override    
+    protected boolean isEntityUpdateable() {
+        return true;
+    }
+    
+}
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/DaoMaster.java b/DaoTest/src-gen/de/greenrobot/daotest/DaoMaster.java
index b68069c5..9a9bfdc6 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/DaoMaster.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/DaoMaster.java
@@ -17,12 +17,15 @@
 import de.greenrobot.daotest.AbcdefEntityDao;
 import de.greenrobot.daotest.ToManyTargetEntityDao;
 import de.greenrobot.daotest.ToManyEntityDao;
+import de.greenrobot.daotest.JoinManyToDateEntityDao;
 import de.greenrobot.daotest.TreeEntityDao;
 import de.greenrobot.daotest.AnActiveEntityDao;
 import de.greenrobot.daotest.ExtendsImplementsEntityDao;
 import de.greenrobot.daotest.StringKeyValueEntityDao;
 import de.greenrobot.daotest.AutoincrementEntityDao;
 import de.greenrobot.daotest.SqliteMasterDao;
+import de.greenrobot.daotest.CustomTypeEntityDao;
+import de.greenrobot.daotest.IndexedStringEntityDao;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
@@ -42,11 +45,14 @@ public static void createAllTables(SQLiteDatabase db, boolean ifNotExists) {
         AbcdefEntityDao.createTable(db, ifNotExists);
         ToManyTargetEntityDao.createTable(db, ifNotExists);
         ToManyEntityDao.createTable(db, ifNotExists);
+        JoinManyToDateEntityDao.createTable(db, ifNotExists);
         TreeEntityDao.createTable(db, ifNotExists);
         AnActiveEntityDao.createTable(db, ifNotExists);
         ExtendsImplementsEntityDao.createTable(db, ifNotExists);
         StringKeyValueEntityDao.createTable(db, ifNotExists);
         AutoincrementEntityDao.createTable(db, ifNotExists);
+        CustomTypeEntityDao.createTable(db, ifNotExists);
+        IndexedStringEntityDao.createTable(db, ifNotExists);
     }
     
     /** Drops underlying database table using DAOs. */
@@ -60,11 +66,14 @@ public static void dropAllTables(SQLiteDatabase db, boolean ifExists) {
         AbcdefEntityDao.dropTable(db, ifExists);
         ToManyTargetEntityDao.dropTable(db, ifExists);
         ToManyEntityDao.dropTable(db, ifExists);
+        JoinManyToDateEntityDao.dropTable(db, ifExists);
         TreeEntityDao.dropTable(db, ifExists);
         AnActiveEntityDao.dropTable(db, ifExists);
         ExtendsImplementsEntityDao.dropTable(db, ifExists);
         StringKeyValueEntityDao.dropTable(db, ifExists);
         AutoincrementEntityDao.dropTable(db, ifExists);
+        CustomTypeEntityDao.dropTable(db, ifExists);
+        IndexedStringEntityDao.dropTable(db, ifExists);
     }
     
     public static abstract class OpenHelper extends SQLiteOpenHelper {
@@ -105,12 +114,15 @@ public DaoMaster(SQLiteDatabase db) {
         registerDaoClass(AbcdefEntityDao.class);
         registerDaoClass(ToManyTargetEntityDao.class);
         registerDaoClass(ToManyEntityDao.class);
+        registerDaoClass(JoinManyToDateEntityDao.class);
         registerDaoClass(TreeEntityDao.class);
         registerDaoClass(AnActiveEntityDao.class);
         registerDaoClass(ExtendsImplementsEntityDao.class);
         registerDaoClass(StringKeyValueEntityDao.class);
         registerDaoClass(AutoincrementEntityDao.class);
         registerDaoClass(SqliteMasterDao.class);
+        registerDaoClass(CustomTypeEntityDao.class);
+        registerDaoClass(IndexedStringEntityDao.class);
     }
     
     public DaoSession newSession() {
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/DaoSession.java b/DaoTest/src-gen/de/greenrobot/daotest/DaoSession.java
index 0a9a8e95..0e608cb9 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/DaoSession.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/DaoSession.java
@@ -18,12 +18,15 @@
 import de.greenrobot.daotest.AbcdefEntity;
 import de.greenrobot.daotest.ToManyTargetEntity;
 import de.greenrobot.daotest.ToManyEntity;
+import de.greenrobot.daotest.JoinManyToDateEntity;
 import de.greenrobot.daotest.TreeEntity;
 import de.greenrobot.daotest.AnActiveEntity;
 import de.greenrobot.daotest.ExtendsImplementsEntity;
 import de.greenrobot.daotest.StringKeyValueEntity;
 import de.greenrobot.daotest.AutoincrementEntity;
 import de.greenrobot.daotest.SqliteMaster;
+import de.greenrobot.daotest.CustomTypeEntity;
+import de.greenrobot.daotest.IndexedStringEntity;
 
 import de.greenrobot.daotest.SimpleEntityDao;
 import de.greenrobot.daotest.SimpleEntityNotNullDao;
@@ -34,12 +37,15 @@
 import de.greenrobot.daotest.AbcdefEntityDao;
 import de.greenrobot.daotest.ToManyTargetEntityDao;
 import de.greenrobot.daotest.ToManyEntityDao;
+import de.greenrobot.daotest.JoinManyToDateEntityDao;
 import de.greenrobot.daotest.TreeEntityDao;
 import de.greenrobot.daotest.AnActiveEntityDao;
 import de.greenrobot.daotest.ExtendsImplementsEntityDao;
 import de.greenrobot.daotest.StringKeyValueEntityDao;
 import de.greenrobot.daotest.AutoincrementEntityDao;
 import de.greenrobot.daotest.SqliteMasterDao;
+import de.greenrobot.daotest.CustomTypeEntityDao;
+import de.greenrobot.daotest.IndexedStringEntityDao;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 
@@ -59,12 +65,15 @@
     private final DaoConfig abcdefEntityDaoConfig;
     private final DaoConfig toManyTargetEntityDaoConfig;
     private final DaoConfig toManyEntityDaoConfig;
+    private final DaoConfig joinManyToDateEntityDaoConfig;
     private final DaoConfig treeEntityDaoConfig;
     private final DaoConfig anActiveEntityDaoConfig;
     private final DaoConfig extendsImplementsEntityDaoConfig;
     private final DaoConfig stringKeyValueEntityDaoConfig;
     private final DaoConfig autoincrementEntityDaoConfig;
     private final DaoConfig sqliteMasterDaoConfig;
+    private final DaoConfig customTypeEntityDaoConfig;
+    private final DaoConfig indexedStringEntityDaoConfig;
 
     private final SimpleEntityDao simpleEntityDao;
     private final SimpleEntityNotNullDao simpleEntityNotNullDao;
@@ -75,12 +84,15 @@
     private final AbcdefEntityDao abcdefEntityDao;
     private final ToManyTargetEntityDao toManyTargetEntityDao;
     private final ToManyEntityDao toManyEntityDao;
+    private final JoinManyToDateEntityDao joinManyToDateEntityDao;
     private final TreeEntityDao treeEntityDao;
     private final AnActiveEntityDao anActiveEntityDao;
     private final ExtendsImplementsEntityDao extendsImplementsEntityDao;
     private final StringKeyValueEntityDao stringKeyValueEntityDao;
     private final AutoincrementEntityDao autoincrementEntityDao;
     private final SqliteMasterDao sqliteMasterDao;
+    private final CustomTypeEntityDao customTypeEntityDao;
+    private final IndexedStringEntityDao indexedStringEntityDao;
 
     public DaoSession(SQLiteDatabase db, IdentityScopeType type, Map<Class<? extends AbstractDao<?, ?>>, DaoConfig>
             daoConfigMap) {
@@ -113,6 +125,9 @@ public DaoSession(SQLiteDatabase db, IdentityScopeType type, Map<Class<? extends
         toManyEntityDaoConfig = daoConfigMap.get(ToManyEntityDao.class).clone();
         toManyEntityDaoConfig.initIdentityScope(type);
 
+        joinManyToDateEntityDaoConfig = daoConfigMap.get(JoinManyToDateEntityDao.class).clone();
+        joinManyToDateEntityDaoConfig.initIdentityScope(type);
+
         treeEntityDaoConfig = daoConfigMap.get(TreeEntityDao.class).clone();
         treeEntityDaoConfig.initIdentityScope(type);
 
@@ -131,6 +146,12 @@ public DaoSession(SQLiteDatabase db, IdentityScopeType type, Map<Class<? extends
         sqliteMasterDaoConfig = daoConfigMap.get(SqliteMasterDao.class).clone();
         sqliteMasterDaoConfig.initIdentityScope(type);
 
+        customTypeEntityDaoConfig = daoConfigMap.get(CustomTypeEntityDao.class).clone();
+        customTypeEntityDaoConfig.initIdentityScope(type);
+
+        indexedStringEntityDaoConfig = daoConfigMap.get(IndexedStringEntityDao.class).clone();
+        indexedStringEntityDaoConfig.initIdentityScope(type);
+
         simpleEntityDao = new SimpleEntityDao(simpleEntityDaoConfig, this);
         simpleEntityNotNullDao = new SimpleEntityNotNullDao(simpleEntityNotNullDaoConfig, this);
         testEntityDao = new TestEntityDao(testEntityDaoConfig, this);
@@ -140,12 +161,15 @@ public DaoSession(SQLiteDatabase db, IdentityScopeType type, Map<Class<? extends
         abcdefEntityDao = new AbcdefEntityDao(abcdefEntityDaoConfig, this);
         toManyTargetEntityDao = new ToManyTargetEntityDao(toManyTargetEntityDaoConfig, this);
         toManyEntityDao = new ToManyEntityDao(toManyEntityDaoConfig, this);
+        joinManyToDateEntityDao = new JoinManyToDateEntityDao(joinManyToDateEntityDaoConfig, this);
         treeEntityDao = new TreeEntityDao(treeEntityDaoConfig, this);
         anActiveEntityDao = new AnActiveEntityDao(anActiveEntityDaoConfig, this);
         extendsImplementsEntityDao = new ExtendsImplementsEntityDao(extendsImplementsEntityDaoConfig, this);
         stringKeyValueEntityDao = new StringKeyValueEntityDao(stringKeyValueEntityDaoConfig, this);
         autoincrementEntityDao = new AutoincrementEntityDao(autoincrementEntityDaoConfig, this);
         sqliteMasterDao = new SqliteMasterDao(sqliteMasterDaoConfig, this);
+        customTypeEntityDao = new CustomTypeEntityDao(customTypeEntityDaoConfig, this);
+        indexedStringEntityDao = new IndexedStringEntityDao(indexedStringEntityDaoConfig, this);
 
         registerDao(SimpleEntity.class, simpleEntityDao);
         registerDao(SimpleEntityNotNull.class, simpleEntityNotNullDao);
@@ -156,12 +180,15 @@ public DaoSession(SQLiteDatabase db, IdentityScopeType type, Map<Class<? extends
         registerDao(AbcdefEntity.class, abcdefEntityDao);
         registerDao(ToManyTargetEntity.class, toManyTargetEntityDao);
         registerDao(ToManyEntity.class, toManyEntityDao);
+        registerDao(JoinManyToDateEntity.class, joinManyToDateEntityDao);
         registerDao(TreeEntity.class, treeEntityDao);
         registerDao(AnActiveEntity.class, anActiveEntityDao);
         registerDao(ExtendsImplementsEntity.class, extendsImplementsEntityDao);
         registerDao(StringKeyValueEntity.class, stringKeyValueEntityDao);
         registerDao(AutoincrementEntity.class, autoincrementEntityDao);
         registerDao(SqliteMaster.class, sqliteMasterDao);
+        registerDao(CustomTypeEntity.class, customTypeEntityDao);
+        registerDao(IndexedStringEntity.class, indexedStringEntityDao);
     }
     
     public void clear() {
@@ -174,12 +201,15 @@ public void clear() {
         abcdefEntityDaoConfig.getIdentityScope().clear();
         toManyTargetEntityDaoConfig.getIdentityScope().clear();
         toManyEntityDaoConfig.getIdentityScope().clear();
+        joinManyToDateEntityDaoConfig.getIdentityScope().clear();
         treeEntityDaoConfig.getIdentityScope().clear();
         anActiveEntityDaoConfig.getIdentityScope().clear();
         extendsImplementsEntityDaoConfig.getIdentityScope().clear();
         stringKeyValueEntityDaoConfig.getIdentityScope().clear();
         autoincrementEntityDaoConfig.getIdentityScope().clear();
         sqliteMasterDaoConfig.getIdentityScope().clear();
+        customTypeEntityDaoConfig.getIdentityScope().clear();
+        indexedStringEntityDaoConfig.getIdentityScope().clear();
     }
 
     public SimpleEntityDao getSimpleEntityDao() {
@@ -218,6 +248,10 @@ public ToManyEntityDao getToManyEntityDao() {
         return toManyEntityDao;
     }
 
+    public JoinManyToDateEntityDao getJoinManyToDateEntityDao() {
+        return joinManyToDateEntityDao;
+    }
+
     public TreeEntityDao getTreeEntityDao() {
         return treeEntityDao;
     }
@@ -242,4 +276,12 @@ public SqliteMasterDao getSqliteMasterDao() {
         return sqliteMasterDao;
     }
 
+    public CustomTypeEntityDao getCustomTypeEntityDao() {
+        return customTypeEntityDao;
+    }
+
+    public IndexedStringEntityDao getIndexedStringEntityDao() {
+        return indexedStringEntityDao;
+    }
+
 }
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/DateEntity.java b/DaoTest/src-gen/de/greenrobot/daotest/DateEntity.java
index b01bd724..7b8f305a 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/DateEntity.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/DateEntity.java
@@ -1,12 +1,16 @@
 package de.greenrobot.daotest;
 
+import java.lang.String;
+
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
 /**
- * Entity mapped to table DATE_ENTITY.
+ * Entity mapped to table "DATE_ENTITY".
  */
 public class DateEntity {
 
     private Long id;
+     // Test code for
+    // field
     private java.util.Date date;
     /** Not-null value. */
     private java.util.Date dateNotNull;
@@ -32,10 +36,14 @@ public void setId(Long id) {
         this.id = id;
     }
 
+    // Test code for
+    // getter
     public java.util.Date getDate() {
         return date;
     }
 
+    // Test code for
+    // setter
     public void setDate(java.util.Date date) {
         this.date = date;
     }
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/DateEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/DateEntityDao.java
index b3eb348f..7d5ab029 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/DateEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/DateEntityDao.java
@@ -1,5 +1,6 @@
 package de.greenrobot.daotest;
 
+import java.util.List;
 import android.database.Cursor;
 import android.database.sqlite.SQLiteDatabase;
 import android.database.sqlite.SQLiteStatement;
@@ -7,12 +8,14 @@
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.Property;
 import de.greenrobot.dao.internal.DaoConfig;
+import de.greenrobot.dao.query.Query;
+import de.greenrobot.dao.query.QueryBuilder;
 
 import de.greenrobot.daotest.DateEntity;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
- * DAO for table DATE_ENTITY.
+ * DAO for table "DATE_ENTITY".
 */
 public class DateEntityDao extends AbstractDao<DateEntity, Long> {
 
@@ -28,6 +31,7 @@
         public final static Property DateNotNull = new Property(2, java.util.Date.class, "dateNotNull", false, "DATE_NOT_NULL");
     };
 
+    private Query<DateEntity> toManyEntity_DateEntityListQuery;
 
     public DateEntityDao(DaoConfig config) {
         super(config);
@@ -40,15 +44,15 @@ public DateEntityDao(DaoConfig config, DaoSession daoSession) {
     /** Creates the underlying database table. */
     public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
-        db.execSQL("CREATE TABLE " + constraint + "'DATE_ENTITY' (" + //
-                "'_id' INTEGER PRIMARY KEY ," + // 0: id
-                "'DATE' INTEGER," + // 1: date
-                "'DATE_NOT_NULL' INTEGER NOT NULL );"); // 2: dateNotNull
+        db.execSQL("CREATE TABLE " + constraint + "\"DATE_ENTITY\" (" + //
+                "\"_id\" INTEGER PRIMARY KEY ," + // 0: id
+                "\"DATE\" INTEGER," + // 1: date
+                "\"DATE_NOT_NULL\" INTEGER NOT NULL );"); // 2: dateNotNull
     }
 
     /** Drops the underlying database table. */
     public static void dropTable(SQLiteDatabase db, boolean ifExists) {
-        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'DATE_ENTITY'";
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "\"DATE_ENTITY\"";
         db.execSQL(sql);
     }
 
@@ -117,4 +121,19 @@ protected boolean isEntityUpdateable() {
         return true;
     }
     
+    /** Internal query to resolve the "dateEntityList" to-many relationship of ToManyEntity. */
+    public List<DateEntity> _queryToManyEntity_DateEntityList(Long idToMany) {
+        synchronized (this) {
+            if (toManyEntity_DateEntityListQuery == null) {
+                QueryBuilder<DateEntity> queryBuilder = queryBuilder();
+                queryBuilder.join(JoinManyToDateEntity.class, JoinManyToDateEntityDao.Properties.IdDate)
+                    .where(JoinManyToDateEntityDao.Properties.IdToMany.eq(idToMany));
+                toManyEntity_DateEntityListQuery = queryBuilder.build();
+            }
+        }
+        Query<DateEntity> query = toManyEntity_DateEntityListQuery.forCurrentThread();
+        query.setParameter(0, idToMany);
+        return query.list();
+    }
+
 }
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/ExtendsImplementsEntity.java b/DaoTest/src-gen/de/greenrobot/daotest/ExtendsImplementsEntity.java
index 72c57ee8..92a99f64 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/ExtendsImplementsEntity.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/ExtendsImplementsEntity.java
@@ -2,7 +2,7 @@
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
 /**
- * Entity mapped to table EXTENDS_IMPLEMENTS_ENTITY.
+ * Entity mapped to table "EXTENDS_IMPLEMENTS_ENTITY".
  */
 public class ExtendsImplementsEntity extends TestSuperclass  implements TestInterface, java.io.Serializable {
 
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/ExtendsImplementsEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/ExtendsImplementsEntityDao.java
index 10e62249..243ea2b9 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/ExtendsImplementsEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/ExtendsImplementsEntityDao.java
@@ -12,7 +12,7 @@
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
- * DAO for table EXTENDS_IMPLEMENTS_ENTITY.
+ * DAO for table "EXTENDS_IMPLEMENTS_ENTITY".
 */
 public class ExtendsImplementsEntityDao extends AbstractDao<ExtendsImplementsEntity, Long> {
 
@@ -39,14 +39,14 @@ public ExtendsImplementsEntityDao(DaoConfig config, DaoSession daoSession) {
     /** Creates the underlying database table. */
     public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
-        db.execSQL("CREATE TABLE " + constraint + "'EXTENDS_IMPLEMENTS_ENTITY' (" + //
-                "'_id' INTEGER PRIMARY KEY ," + // 0: id
-                "'TEXT' TEXT);"); // 1: text
+        db.execSQL("CREATE TABLE " + constraint + "\"EXTENDS_IMPLEMENTS_ENTITY\" (" + //
+                "\"_id\" INTEGER PRIMARY KEY ," + // 0: id
+                "\"TEXT\" TEXT);"); // 1: text
     }
 
     /** Drops the underlying database table. */
     public static void dropTable(SQLiteDatabase db, boolean ifExists) {
-        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'EXTENDS_IMPLEMENTS_ENTITY'";
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "\"EXTENDS_IMPLEMENTS_ENTITY\"";
         db.execSQL(sql);
     }
 
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/IndexedStringEntity.java b/DaoTest/src-gen/de/greenrobot/daotest/IndexedStringEntity.java
new file mode 100644
index 00000000..7aeb7cde
--- /dev/null
+++ b/DaoTest/src-gen/de/greenrobot/daotest/IndexedStringEntity.java
@@ -0,0 +1,40 @@
+package de.greenrobot.daotest;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
+/**
+ * Entity mapped to table "INDEXED_STRING_ENTITY".
+ */
+public class IndexedStringEntity {
+
+    private Long id;
+    private String indexedString;
+
+    public IndexedStringEntity() {
+    }
+
+    public IndexedStringEntity(Long id) {
+        this.id = id;
+    }
+
+    public IndexedStringEntity(Long id, String indexedString) {
+        this.id = id;
+        this.indexedString = indexedString;
+    }
+
+    public Long getId() {
+        return id;
+    }
+
+    public void setId(Long id) {
+        this.id = id;
+    }
+
+    public String getIndexedString() {
+        return indexedString;
+    }
+
+    public void setIndexedString(String indexedString) {
+        this.indexedString = indexedString;
+    }
+
+}
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/IndexedStringEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/IndexedStringEntityDao.java
new file mode 100644
index 00000000..3724a9af
--- /dev/null
+++ b/DaoTest/src-gen/de/greenrobot/daotest/IndexedStringEntityDao.java
@@ -0,0 +1,118 @@
+package de.greenrobot.daotest;
+
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteStatement;
+
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.Property;
+import de.greenrobot.dao.internal.DaoConfig;
+
+import de.greenrobot.daotest.IndexedStringEntity;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+/** 
+ * DAO for table "INDEXED_STRING_ENTITY".
+*/
+public class IndexedStringEntityDao extends AbstractDao<IndexedStringEntity, Long> {
+
+    public static final String TABLENAME = "INDEXED_STRING_ENTITY";
+
+    /**
+     * Properties of entity IndexedStringEntity.<br/>
+     * Can be used for QueryBuilder and for referencing column names.
+    */
+    public static class Properties {
+        public final static Property Id = new Property(0, Long.class, "id", true, "_id");
+        public final static Property IndexedString = new Property(1, String.class, "indexedString", false, "INDEXED_STRING");
+    };
+
+
+    public IndexedStringEntityDao(DaoConfig config) {
+        super(config);
+    }
+    
+    public IndexedStringEntityDao(DaoConfig config, DaoSession daoSession) {
+        super(config, daoSession);
+    }
+
+    /** Creates the underlying database table. */
+    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+        String constraint = ifNotExists? "IF NOT EXISTS ": "";
+        db.execSQL("CREATE TABLE " + constraint + "\"INDEXED_STRING_ENTITY\" (" + //
+                "\"_id\" INTEGER PRIMARY KEY ," + // 0: id
+                "\"INDEXED_STRING\" TEXT);"); // 1: indexedString
+        // Add Indexes
+        db.execSQL("CREATE INDEX " + constraint + "IDX_INDEXED_STRING_ENTITY_INDEXED_STRING ON INDEXED_STRING_ENTITY" +
+                " (\"INDEXED_STRING\");");
+    }
+
+    /** Drops the underlying database table. */
+    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "\"INDEXED_STRING_ENTITY\"";
+        db.execSQL(sql);
+    }
+
+    /** @inheritdoc */
+    @Override
+    protected void bindValues(SQLiteStatement stmt, IndexedStringEntity entity) {
+        stmt.clearBindings();
+ 
+        Long id = entity.getId();
+        if (id != null) {
+            stmt.bindLong(1, id);
+        }
+ 
+        String indexedString = entity.getIndexedString();
+        if (indexedString != null) {
+            stmt.bindString(2, indexedString);
+        }
+    }
+
+    /** @inheritdoc */
+    @Override
+    public Long readKey(Cursor cursor, int offset) {
+        return cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0);
+    }    
+
+    /** @inheritdoc */
+    @Override
+    public IndexedStringEntity readEntity(Cursor cursor, int offset) {
+        IndexedStringEntity entity = new IndexedStringEntity( //
+            cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0), // id
+            cursor.isNull(offset + 1) ? null : cursor.getString(offset + 1) // indexedString
+        );
+        return entity;
+    }
+     
+    /** @inheritdoc */
+    @Override
+    public void readEntity(Cursor cursor, IndexedStringEntity entity, int offset) {
+        entity.setId(cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0));
+        entity.setIndexedString(cursor.isNull(offset + 1) ? null : cursor.getString(offset + 1));
+     }
+    
+    /** @inheritdoc */
+    @Override
+    protected Long updateKeyAfterInsert(IndexedStringEntity entity, long rowId) {
+        entity.setId(rowId);
+        return rowId;
+    }
+    
+    /** @inheritdoc */
+    @Override
+    public Long getKey(IndexedStringEntity entity) {
+        if(entity != null) {
+            return entity.getId();
+        } else {
+            return null;
+        }
+    }
+
+    /** @inheritdoc */
+    @Override    
+    protected boolean isEntityUpdateable() {
+        return true;
+    }
+    
+}
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/JoinManyToDateEntity.java b/DaoTest/src-gen/de/greenrobot/daotest/JoinManyToDateEntity.java
new file mode 100644
index 00000000..480cc197
--- /dev/null
+++ b/DaoTest/src-gen/de/greenrobot/daotest/JoinManyToDateEntity.java
@@ -0,0 +1,50 @@
+package de.greenrobot.daotest;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
+/**
+ * Entity mapped to table "JOIN_MANY_TO_DATE_ENTITY".
+ */
+public class JoinManyToDateEntity {
+
+    private Long id;
+    private Long idToMany;
+    private Long idDate;
+
+    public JoinManyToDateEntity() {
+    }
+
+    public JoinManyToDateEntity(Long id) {
+        this.id = id;
+    }
+
+    public JoinManyToDateEntity(Long id, Long idToMany, Long idDate) {
+        this.id = id;
+        this.idToMany = idToMany;
+        this.idDate = idDate;
+    }
+
+    public Long getId() {
+        return id;
+    }
+
+    public void setId(Long id) {
+        this.id = id;
+    }
+
+    public Long getIdToMany() {
+        return idToMany;
+    }
+
+    public void setIdToMany(Long idToMany) {
+        this.idToMany = idToMany;
+    }
+
+    public Long getIdDate() {
+        return idDate;
+    }
+
+    public void setIdDate(Long idDate) {
+        this.idDate = idDate;
+    }
+
+}
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/JoinManyToDateEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/JoinManyToDateEntityDao.java
new file mode 100644
index 00000000..5ba3944c
--- /dev/null
+++ b/DaoTest/src-gen/de/greenrobot/daotest/JoinManyToDateEntityDao.java
@@ -0,0 +1,124 @@
+package de.greenrobot.daotest;
+
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteStatement;
+
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.Property;
+import de.greenrobot.dao.internal.DaoConfig;
+
+import de.greenrobot.daotest.JoinManyToDateEntity;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+/** 
+ * DAO for table "JOIN_MANY_TO_DATE_ENTITY".
+*/
+public class JoinManyToDateEntityDao extends AbstractDao<JoinManyToDateEntity, Long> {
+
+    public static final String TABLENAME = "JOIN_MANY_TO_DATE_ENTITY";
+
+    /**
+     * Properties of entity JoinManyToDateEntity.<br/>
+     * Can be used for QueryBuilder and for referencing column names.
+    */
+    public static class Properties {
+        public final static Property Id = new Property(0, Long.class, "id", true, "_id");
+        public final static Property IdToMany = new Property(1, Long.class, "idToMany", false, "ID_TO_MANY");
+        public final static Property IdDate = new Property(2, Long.class, "idDate", false, "ID_DATE");
+    };
+
+
+    public JoinManyToDateEntityDao(DaoConfig config) {
+        super(config);
+    }
+    
+    public JoinManyToDateEntityDao(DaoConfig config, DaoSession daoSession) {
+        super(config, daoSession);
+    }
+
+    /** Creates the underlying database table. */
+    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+        String constraint = ifNotExists? "IF NOT EXISTS ": "";
+        db.execSQL("CREATE TABLE " + constraint + "\"JOIN_MANY_TO_DATE_ENTITY\" (" + //
+                "\"_id\" INTEGER PRIMARY KEY ," + // 0: id
+                "\"ID_TO_MANY\" INTEGER," + // 1: idToMany
+                "\"ID_DATE\" INTEGER);"); // 2: idDate
+    }
+
+    /** Drops the underlying database table. */
+    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "\"JOIN_MANY_TO_DATE_ENTITY\"";
+        db.execSQL(sql);
+    }
+
+    /** @inheritdoc */
+    @Override
+    protected void bindValues(SQLiteStatement stmt, JoinManyToDateEntity entity) {
+        stmt.clearBindings();
+ 
+        Long id = entity.getId();
+        if (id != null) {
+            stmt.bindLong(1, id);
+        }
+ 
+        Long idToMany = entity.getIdToMany();
+        if (idToMany != null) {
+            stmt.bindLong(2, idToMany);
+        }
+ 
+        Long idDate = entity.getIdDate();
+        if (idDate != null) {
+            stmt.bindLong(3, idDate);
+        }
+    }
+
+    /** @inheritdoc */
+    @Override
+    public Long readKey(Cursor cursor, int offset) {
+        return cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0);
+    }    
+
+    /** @inheritdoc */
+    @Override
+    public JoinManyToDateEntity readEntity(Cursor cursor, int offset) {
+        JoinManyToDateEntity entity = new JoinManyToDateEntity( //
+            cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0), // id
+            cursor.isNull(offset + 1) ? null : cursor.getLong(offset + 1), // idToMany
+            cursor.isNull(offset + 2) ? null : cursor.getLong(offset + 2) // idDate
+        );
+        return entity;
+    }
+     
+    /** @inheritdoc */
+    @Override
+    public void readEntity(Cursor cursor, JoinManyToDateEntity entity, int offset) {
+        entity.setId(cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0));
+        entity.setIdToMany(cursor.isNull(offset + 1) ? null : cursor.getLong(offset + 1));
+        entity.setIdDate(cursor.isNull(offset + 2) ? null : cursor.getLong(offset + 2));
+     }
+    
+    /** @inheritdoc */
+    @Override
+    protected Long updateKeyAfterInsert(JoinManyToDateEntity entity, long rowId) {
+        entity.setId(rowId);
+        return rowId;
+    }
+    
+    /** @inheritdoc */
+    @Override
+    public Long getKey(JoinManyToDateEntity entity) {
+        if(entity != null) {
+            return entity.getId();
+        } else {
+            return null;
+        }
+    }
+
+    /** @inheritdoc */
+    @Override    
+    protected boolean isEntityUpdateable() {
+        return true;
+    }
+    
+}
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/RelationEntity.java b/DaoTest/src-gen/de/greenrobot/daotest/RelationEntity.java
index 7a2d6944..ea93789b 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/RelationEntity.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/RelationEntity.java
@@ -5,7 +5,7 @@
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
 /**
- * Entity mapped to table RELATION_ENTITY.
+ * Entity mapped to table "RELATION_ENTITY".
  */
 public class RelationEntity {
 
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/RelationEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/RelationEntityDao.java
index 4f09837e..f4c5ab06 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/RelationEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/RelationEntityDao.java
@@ -15,7 +15,7 @@
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
- * DAO for table RELATION_ENTITY.
+ * DAO for table "RELATION_ENTITY".
 */
 public class RelationEntityDao extends AbstractDao<RelationEntity, Long> {
 
@@ -49,18 +49,18 @@ public RelationEntityDao(DaoConfig config, DaoSession daoSession) {
     /** Creates the underlying database table. */
     public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
-        db.execSQL("CREATE TABLE " + constraint + "'RELATION_ENTITY' (" + //
-                "'_id' INTEGER PRIMARY KEY ," + // 0: id
-                "'PARENT_ID' INTEGER," + // 1: parentId
-                "'TEST_ID' INTEGER," + // 2: testId
-                "'TEST_ID_NOT_NULL' INTEGER NOT NULL ," + // 3: testIdNotNull
-                "'SIMPLE_STRING' TEXT," + // 4: simpleString
-                "'WITHOUT_PROPERTY_TEST_ID' INTEGER);"); // 5: testWithoutProperty
+        db.execSQL("CREATE TABLE " + constraint + "\"RELATION_ENTITY\" (" + //
+                "\"_id\" INTEGER PRIMARY KEY ," + // 0: id
+                "\"PARENT_ID\" INTEGER," + // 1: parentId
+                "\"TEST_ID\" INTEGER," + // 2: testId
+                "\"TEST_ID_NOT_NULL\" INTEGER NOT NULL ," + // 3: testIdNotNull
+                "\"SIMPLE_STRING\" TEXT," + // 4: simpleString
+                "\"WITHOUT_PROPERTY_TEST_ID\" INTEGER);"); // 5: testWithoutProperty
     }
 
     /** Drops the underlying database table. */
     public static void dropTable(SQLiteDatabase db, boolean ifExists) {
-        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'RELATION_ENTITY'";
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "\"RELATION_ENTITY\"";
         db.execSQL(sql);
     }
 
@@ -164,10 +164,10 @@ protected String getSelectDeep() {
             builder.append(',');
             SqlUtils.appendColumns(builder, "T3", daoSession.getTestEntityDao().getAllColumns());
             builder.append(" FROM RELATION_ENTITY T");
-            builder.append(" LEFT JOIN RELATION_ENTITY T0 ON T.'PARENT_ID'=T0.'_id'");
-            builder.append(" LEFT JOIN TEST_ENTITY T1 ON T.'TEST_ID'=T1.'_id'");
-            builder.append(" LEFT JOIN TEST_ENTITY T2 ON T.'TEST_ID_NOT_NULL'=T2.'_id'");
-            builder.append(" LEFT JOIN TEST_ENTITY T3 ON T.'WITHOUT_PROPERTY_TEST_ID'=T3.'_id'");
+            builder.append(" LEFT JOIN RELATION_ENTITY T0 ON T.\"PARENT_ID\"=T0.\"_id\"");
+            builder.append(" LEFT JOIN TEST_ENTITY T1 ON T.\"TEST_ID\"=T1.\"_id\"");
+            builder.append(" LEFT JOIN TEST_ENTITY T2 ON T.\"TEST_ID_NOT_NULL\"=T2.\"_id\"");
+            builder.append(" LEFT JOIN TEST_ENTITY T3 ON T.\"WITHOUT_PROPERTY_TEST_ID\"=T3.\"_id\"");
             builder.append(' ');
             selectDeep = builder.toString();
         }
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntity.java b/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntity.java
index 9c072e1e..b50f0598 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntity.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntity.java
@@ -2,7 +2,7 @@
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
 /**
- * Entity mapped to table SIMPLE_ENTITY.
+ * Entity mapped to table "SIMPLE_ENTITY".
  */
 public class SimpleEntity {
 
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntityDao.java
index 70a5df92..6afdd7c8 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntityDao.java
@@ -12,7 +12,7 @@
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
- * DAO for table SIMPLE_ENTITY.
+ * DAO for table "SIMPLE_ENTITY".
 */
 public class SimpleEntityDao extends AbstractDao<SimpleEntity, Long> {
 
@@ -47,22 +47,22 @@ public SimpleEntityDao(DaoConfig config, DaoSession daoSession) {
     /** Creates the underlying database table. */
     public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
-        db.execSQL("CREATE TABLE " + constraint + "'SIMPLE_ENTITY' (" + //
-                "'_id' INTEGER PRIMARY KEY ," + // 0: id
-                "'SIMPLE_BOOLEAN' INTEGER," + // 1: simpleBoolean
-                "'SIMPLE_BYTE' INTEGER," + // 2: simpleByte
-                "'SIMPLE_SHORT' INTEGER," + // 3: simpleShort
-                "'SIMPLE_INT' INTEGER," + // 4: simpleInt
-                "'SIMPLE_LONG' INTEGER," + // 5: simpleLong
-                "'SIMPLE_FLOAT' REAL," + // 6: simpleFloat
-                "'SIMPLE_DOUBLE' REAL," + // 7: simpleDouble
-                "'SIMPLE_STRING' TEXT," + // 8: simpleString
-                "'SIMPLE_BYTE_ARRAY' BLOB);"); // 9: simpleByteArray
+        db.execSQL("CREATE TABLE " + constraint + "\"SIMPLE_ENTITY\" (" + //
+                "\"_id\" INTEGER PRIMARY KEY ," + // 0: id
+                "\"SIMPLE_BOOLEAN\" INTEGER," + // 1: simpleBoolean
+                "\"SIMPLE_BYTE\" INTEGER," + // 2: simpleByte
+                "\"SIMPLE_SHORT\" INTEGER," + // 3: simpleShort
+                "\"SIMPLE_INT\" INTEGER," + // 4: simpleInt
+                "\"SIMPLE_LONG\" INTEGER," + // 5: simpleLong
+                "\"SIMPLE_FLOAT\" REAL," + // 6: simpleFloat
+                "\"SIMPLE_DOUBLE\" REAL," + // 7: simpleDouble
+                "\"SIMPLE_STRING\" TEXT," + // 8: simpleString
+                "\"SIMPLE_BYTE_ARRAY\" BLOB);"); // 9: simpleByteArray
     }
 
     /** Drops the underlying database table. */
     public static void dropTable(SQLiteDatabase db, boolean ifExists) {
-        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'SIMPLE_ENTITY'";
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "\"SIMPLE_ENTITY\"";
         db.execSQL(sql);
     }
 
@@ -78,7 +78,7 @@ protected void bindValues(SQLiteStatement stmt, SimpleEntity entity) {
  
         Boolean simpleBoolean = entity.getSimpleBoolean();
         if (simpleBoolean != null) {
-            stmt.bindLong(2, simpleBoolean ? 1l: 0l);
+            stmt.bindLong(2, simpleBoolean ? 1L: 0L);
         }
  
         Byte simpleByte = entity.getSimpleByte();
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntityNotNull.java b/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntityNotNull.java
index 98c6a053..dc5dfaef 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntityNotNull.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntityNotNull.java
@@ -2,7 +2,7 @@
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
 /**
- * Entity mapped to table SIMPLE_ENTITY_NOT_NULL.
+ * Entity mapped to table "SIMPLE_ENTITY_NOT_NULL".
  */
 public class SimpleEntityNotNull {
 
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntityNotNullDao.java b/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntityNotNullDao.java
index 246d9392..a90ccf3b 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntityNotNullDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntityNotNullDao.java
@@ -12,7 +12,7 @@
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
- * DAO for table SIMPLE_ENTITY_NOT_NULL.
+ * DAO for table "SIMPLE_ENTITY_NOT_NULL".
 */
 public class SimpleEntityNotNullDao extends AbstractDao<SimpleEntityNotNull, Long> {
 
@@ -47,22 +47,22 @@ public SimpleEntityNotNullDao(DaoConfig config, DaoSession daoSession) {
     /** Creates the underlying database table. */
     public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
-        db.execSQL("CREATE TABLE " + constraint + "'SIMPLE_ENTITY_NOT_NULL' (" + //
-                "'_id' INTEGER PRIMARY KEY NOT NULL ," + // 0: id
-                "'SIMPLE_BOOLEAN' INTEGER NOT NULL ," + // 1: simpleBoolean
-                "'SIMPLE_BYTE' INTEGER NOT NULL ," + // 2: simpleByte
-                "'SIMPLE_SHORT' INTEGER NOT NULL ," + // 3: simpleShort
-                "'SIMPLE_INT' INTEGER NOT NULL ," + // 4: simpleInt
-                "'SIMPLE_LONG' INTEGER NOT NULL ," + // 5: simpleLong
-                "'SIMPLE_FLOAT' REAL NOT NULL ," + // 6: simpleFloat
-                "'SIMPLE_DOUBLE' REAL NOT NULL ," + // 7: simpleDouble
-                "'SIMPLE_STRING' TEXT NOT NULL ," + // 8: simpleString
-                "'SIMPLE_BYTE_ARRAY' BLOB NOT NULL );"); // 9: simpleByteArray
+        db.execSQL("CREATE TABLE " + constraint + "\"SIMPLE_ENTITY_NOT_NULL\" (" + //
+                "\"_id\" INTEGER PRIMARY KEY NOT NULL ," + // 0: id
+                "\"SIMPLE_BOOLEAN\" INTEGER NOT NULL ," + // 1: simpleBoolean
+                "\"SIMPLE_BYTE\" INTEGER NOT NULL ," + // 2: simpleByte
+                "\"SIMPLE_SHORT\" INTEGER NOT NULL ," + // 3: simpleShort
+                "\"SIMPLE_INT\" INTEGER NOT NULL ," + // 4: simpleInt
+                "\"SIMPLE_LONG\" INTEGER NOT NULL ," + // 5: simpleLong
+                "\"SIMPLE_FLOAT\" REAL NOT NULL ," + // 6: simpleFloat
+                "\"SIMPLE_DOUBLE\" REAL NOT NULL ," + // 7: simpleDouble
+                "\"SIMPLE_STRING\" TEXT NOT NULL ," + // 8: simpleString
+                "\"SIMPLE_BYTE_ARRAY\" BLOB NOT NULL );"); // 9: simpleByteArray
     }
 
     /** Drops the underlying database table. */
     public static void dropTable(SQLiteDatabase db, boolean ifExists) {
-        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'SIMPLE_ENTITY_NOT_NULL'";
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "\"SIMPLE_ENTITY_NOT_NULL\"";
         db.execSQL(sql);
     }
 
@@ -71,7 +71,7 @@ public static void dropTable(SQLiteDatabase db, boolean ifExists) {
     protected void bindValues(SQLiteStatement stmt, SimpleEntityNotNull entity) {
         stmt.clearBindings();
         stmt.bindLong(1, entity.getId());
-        stmt.bindLong(2, entity.getSimpleBoolean() ? 1l: 0l);
+        stmt.bindLong(2, entity.getSimpleBoolean() ? 1L: 0L);
         stmt.bindLong(3, entity.getSimpleByte());
         stmt.bindLong(4, entity.getSimpleShort());
         stmt.bindLong(5, entity.getSimpleInt());
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/SpecialNamesEntity.java b/DaoTest/src-gen/de/greenrobot/daotest/SpecialNamesEntity.java
index 3a907aeb..5b10d0fc 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/SpecialNamesEntity.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/SpecialNamesEntity.java
@@ -2,7 +2,7 @@
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
 /**
- * Entity mapped to table SPECIAL_NAMES_ENTITY.
+ * Entity mapped to table "ORDER TRANSACTION GROUP BY".
  */
 public class SpecialNamesEntity {
 
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/SpecialNamesEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/SpecialNamesEntityDao.java
index 184203a7..7e9c2698 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/SpecialNamesEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/SpecialNamesEntityDao.java
@@ -12,11 +12,11 @@
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
- * DAO for table SPECIAL_NAMES_ENTITY.
+ * DAO for table "ORDER TRANSACTION GROUP BY".
 */
 public class SpecialNamesEntityDao extends AbstractDao<SpecialNamesEntity, Long> {
 
-    public static final String TABLENAME = "SPECIAL_NAMES_ENTITY";
+    public static final String TABLENAME = "ORDER TRANSACTION GROUP BY";
 
     /**
      * Properties of entity SpecialNamesEntity.<br/>
@@ -47,22 +47,22 @@ public SpecialNamesEntityDao(DaoConfig config, DaoSession daoSession) {
     /** Creates the underlying database table. */
     public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
-        db.execSQL("CREATE TABLE " + constraint + "'SPECIAL_NAMES_ENTITY' (" + //
-                "'_id' INTEGER PRIMARY KEY ," + // 0: id
-                "'COUNT' TEXT," + // 1: count
-                "'SELECT' TEXT," + // 2: select
-                "'SUM' TEXT," + // 3: sum
-                "'AVG' TEXT," + // 4: avg
-                "'JOIN' TEXT," + // 5: join
-                "'DISTINCT' TEXT," + // 6: distinct
-                "'ON' TEXT," + // 7: on
-                "'INDEX' TEXT," + // 8: index
-                "'ORDER' INTEGER);"); // 9: order
+        db.execSQL("CREATE TABLE " + constraint + "\"ORDER TRANSACTION GROUP BY\" (" + //
+                "\"_id\" INTEGER PRIMARY KEY ," + // 0: id
+                "\"COUNT\" TEXT," + // 1: count
+                "\"SELECT\" TEXT," + // 2: select
+                "\"SUM\" TEXT," + // 3: sum
+                "\"AVG\" TEXT," + // 4: avg
+                "\"JOIN\" TEXT," + // 5: join
+                "\"DISTINCT\" TEXT," + // 6: distinct
+                "\"ON\" TEXT," + // 7: on
+                "\"INDEX\" TEXT," + // 8: index
+                "\"ORDER\" INTEGER);"); // 9: order
     }
 
     /** Drops the underlying database table. */
     public static void dropTable(SQLiteDatabase db, boolean ifExists) {
-        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'SPECIAL_NAMES_ENTITY'";
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "\"ORDER TRANSACTION GROUP BY\"";
         db.execSQL(sql);
     }
 
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/SqliteMaster.java b/DaoTest/src-gen/de/greenrobot/daotest/SqliteMaster.java
index d67dc10f..7b53491f 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/SqliteMaster.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/SqliteMaster.java
@@ -5,7 +5,7 @@
 // KEEP INCLUDES - put your custom includes here
 // KEEP INCLUDES END
 /**
- * Entity mapped to table SQLITE_MASTER.
+ * Entity mapped to table "SQLITE_MASTER".
  */
 public class SqliteMaster {
 
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/SqliteMasterDao.java b/DaoTest/src-gen/de/greenrobot/daotest/SqliteMasterDao.java
index b83e409c..8302d4d0 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/SqliteMasterDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/SqliteMasterDao.java
@@ -12,7 +12,7 @@
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
- * DAO for table SQLITE_MASTER.
+ * DAO for table "SQLITE_MASTER".
 */
 public class SqliteMasterDao extends AbstractDao<SqliteMaster, Void> {
 
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/StringKeyValueEntity.java b/DaoTest/src-gen/de/greenrobot/daotest/StringKeyValueEntity.java
index b436d049..49a3ebc8 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/StringKeyValueEntity.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/StringKeyValueEntity.java
@@ -2,7 +2,7 @@
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
 /**
- * Entity mapped to table STRING_KEY_VALUE_ENTITY.
+ * Entity mapped to table "STRING_KEY_VALUE_ENTITY".
  */
 public class StringKeyValueEntity {
 
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/StringKeyValueEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/StringKeyValueEntityDao.java
index bdf2cd83..8efdfaef 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/StringKeyValueEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/StringKeyValueEntityDao.java
@@ -12,7 +12,7 @@
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
- * DAO for table STRING_KEY_VALUE_ENTITY.
+ * DAO for table "STRING_KEY_VALUE_ENTITY".
 */
 public class StringKeyValueEntityDao extends AbstractDao<StringKeyValueEntity, String> {
 
@@ -39,14 +39,14 @@ public StringKeyValueEntityDao(DaoConfig config, DaoSession daoSession) {
     /** Creates the underlying database table. */
     public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
-        db.execSQL("CREATE TABLE " + constraint + "'STRING_KEY_VALUE_ENTITY' (" + //
-                "'KEY' TEXT PRIMARY KEY NOT NULL ," + // 0: key
-                "'VALUE' TEXT);"); // 1: value
+        db.execSQL("CREATE TABLE " + constraint + "\"STRING_KEY_VALUE_ENTITY\" (" + //
+                "\"KEY\" TEXT PRIMARY KEY NOT NULL ," + // 0: key
+                "\"VALUE\" TEXT);"); // 1: value
     }
 
     /** Drops the underlying database table. */
     public static void dropTable(SQLiteDatabase db, boolean ifExists) {
-        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'STRING_KEY_VALUE_ENTITY'";
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "\"STRING_KEY_VALUE_ENTITY\"";
         db.execSQL(sql);
     }
 
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/TestEntity.java b/DaoTest/src-gen/de/greenrobot/daotest/TestEntity.java
index 82bde4bd..15863049 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/TestEntity.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/TestEntity.java
@@ -1,11 +1,17 @@
 package de.greenrobot.daotest;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
+
 /**
- * Entity mapped to table TEST_ENTITY.
+ * This entity is used by internal tests of greenDAO.
+ * (This JavaDoc is defined in the generator project.)
  */
+// This is another test comment, you could also apply annotations like this
 public class TestEntity {
 
+    /**
+     * JavaDoc test field
+     */
     private Long id;
     private int simpleInt;
     private Integer simpleInteger;
@@ -16,6 +22,7 @@
     private String indexedStringAscUnique;
     private java.util.Date simpleDate;
     private Boolean simpleBoolean;
+    private byte[] simpleByteArray;
 
     public TestEntity() {
     }
@@ -24,7 +31,7 @@ public TestEntity(Long id) {
         this.id = id;
     }
 
-    public TestEntity(Long id, int simpleInt, Integer simpleInteger, String simpleStringNotNull, String simpleString, String indexedString, String indexedStringAscUnique, java.util.Date simpleDate, Boolean simpleBoolean) {
+    public TestEntity(Long id, int simpleInt, Integer simpleInteger, String simpleStringNotNull, String simpleString, String indexedString, String indexedStringAscUnique, java.util.Date simpleDate, Boolean simpleBoolean, byte[] simpleByteArray) {
         this.id = id;
         this.simpleInt = simpleInt;
         this.simpleInteger = simpleInteger;
@@ -34,6 +41,7 @@ public TestEntity(Long id, int simpleInt, Integer simpleInteger, String simpleSt
         this.indexedStringAscUnique = indexedStringAscUnique;
         this.simpleDate = simpleDate;
         this.simpleBoolean = simpleBoolean;
+        this.simpleByteArray = simpleByteArray;
     }
 
     public Long getId() {
@@ -44,6 +52,9 @@ public void setId(Long id) {
         this.id = id;
     }
 
+    /**
+     * JavaDoc test getter
+     */
     public int getSimpleInt() {
         return simpleInt;
     }
@@ -56,16 +67,25 @@ public Integer getSimpleInteger() {
         return simpleInteger;
     }
 
+    /**
+     * JavaDoc test setter
+     */
     public void setSimpleInteger(Integer simpleInteger) {
         this.simpleInteger = simpleInteger;
     }
 
     /** Not-null value. */
+    /**
+     * JavaDoc test getter and setter
+     */
     public String getSimpleStringNotNull() {
         return simpleStringNotNull;
     }
 
     /** Not-null value; ensure this value is available before it is saved to the database. */
+    /**
+     * JavaDoc test getter and setter
+     */
     public void setSimpleStringNotNull(String simpleStringNotNull) {
         this.simpleStringNotNull = simpleStringNotNull;
     }
@@ -110,4 +130,12 @@ public void setSimpleBoolean(Boolean simpleBoolean) {
         this.simpleBoolean = simpleBoolean;
     }
 
+    public byte[] getSimpleByteArray() {
+        return simpleByteArray;
+    }
+
+    public void setSimpleByteArray(byte[] simpleByteArray) {
+        this.simpleByteArray = simpleByteArray;
+    }
+
 }
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/TestEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/TestEntityDao.java
index b3d584ae..5febaa8b 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/TestEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/TestEntityDao.java
@@ -12,7 +12,7 @@
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
- * DAO for table TEST_ENTITY.
+ * DAO for table "TEST_ENTITY".
 */
 public class TestEntityDao extends AbstractDao<TestEntity, Long> {
 
@@ -32,6 +32,7 @@
         public final static Property IndexedStringAscUnique = new Property(6, String.class, "indexedStringAscUnique", false, "INDEXED_STRING_ASC_UNIQUE");
         public final static Property SimpleDate = new Property(7, java.util.Date.class, "simpleDate", false, "SIMPLE_DATE");
         public final static Property SimpleBoolean = new Property(8, Boolean.class, "simpleBoolean", false, "SIMPLE_BOOLEAN");
+        public final static Property SimpleByteArray = new Property(9, byte[].class, "simpleByteArray", false, "SIMPLE_BYTE_ARRAY");
     };
 
 
@@ -46,26 +47,27 @@ public TestEntityDao(DaoConfig config, DaoSession daoSession) {
     /** Creates the underlying database table. */
     public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
-        db.execSQL("CREATE TABLE " + constraint + "'TEST_ENTITY' (" + //
-                "'_id' INTEGER PRIMARY KEY ," + // 0: id
-                "'SIMPLE_INT' INTEGER NOT NULL ," + // 1: simpleInt
-                "'SIMPLE_INTEGER' INTEGER," + // 2: simpleInteger
-                "'SIMPLE_STRING_NOT_NULL' TEXT NOT NULL ," + // 3: simpleStringNotNull
-                "'SIMPLE_STRING' TEXT," + // 4: simpleString
-                "'INDEXED_STRING' TEXT," + // 5: indexedString
-                "'INDEXED_STRING_ASC_UNIQUE' TEXT," + // 6: indexedStringAscUnique
-                "'SIMPLE_DATE' INTEGER," + // 7: simpleDate
-                "'SIMPLE_BOOLEAN' INTEGER);"); // 8: simpleBoolean
+        db.execSQL("CREATE TABLE " + constraint + "\"TEST_ENTITY\" (" + //
+                "\"_id\" INTEGER PRIMARY KEY ," + // 0: id
+                "\"SIMPLE_INT\" INTEGER NOT NULL ," + // 1: simpleInt
+                "\"SIMPLE_INTEGER\" INTEGER," + // 2: simpleInteger
+                "\"SIMPLE_STRING_NOT_NULL\" TEXT NOT NULL ," + // 3: simpleStringNotNull
+                "\"SIMPLE_STRING\" TEXT," + // 4: simpleString
+                "\"INDEXED_STRING\" TEXT," + // 5: indexedString
+                "\"INDEXED_STRING_ASC_UNIQUE\" TEXT," + // 6: indexedStringAscUnique
+                "\"SIMPLE_DATE\" INTEGER," + // 7: simpleDate
+                "\"SIMPLE_BOOLEAN\" INTEGER," + // 8: simpleBoolean
+                "\"SIMPLE_BYTE_ARRAY\" BLOB);"); // 9: simpleByteArray
         // Add Indexes
         db.execSQL("CREATE INDEX " + constraint + "IDX_TEST_ENTITY_INDEXED_STRING ON TEST_ENTITY" +
-                " (INDEXED_STRING);");
+                " (\"INDEXED_STRING\");");
         db.execSQL("CREATE UNIQUE INDEX " + constraint + "IDX_TEST_ENTITY_INDEXED_STRING_ASC_UNIQUE ON TEST_ENTITY" +
-                " (INDEXED_STRING_ASC_UNIQUE);");
+                " (\"INDEXED_STRING_ASC_UNIQUE\");");
     }
 
     /** Drops the underlying database table. */
     public static void dropTable(SQLiteDatabase db, boolean ifExists) {
-        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'TEST_ENTITY'";
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "\"TEST_ENTITY\"";
         db.execSQL(sql);
     }
 
@@ -108,7 +110,12 @@ protected void bindValues(SQLiteStatement stmt, TestEntity entity) {
  
         Boolean simpleBoolean = entity.getSimpleBoolean();
         if (simpleBoolean != null) {
-            stmt.bindLong(9, simpleBoolean ? 1l: 0l);
+            stmt.bindLong(9, simpleBoolean ? 1L: 0L);
+        }
+ 
+        byte[] simpleByteArray = entity.getSimpleByteArray();
+        if (simpleByteArray != null) {
+            stmt.bindBlob(10, simpleByteArray);
         }
     }
 
@@ -130,7 +137,8 @@ public TestEntity readEntity(Cursor cursor, int offset) {
             cursor.isNull(offset + 5) ? null : cursor.getString(offset + 5), // indexedString
             cursor.isNull(offset + 6) ? null : cursor.getString(offset + 6), // indexedStringAscUnique
             cursor.isNull(offset + 7) ? null : new java.util.Date(cursor.getLong(offset + 7)), // simpleDate
-            cursor.isNull(offset + 8) ? null : cursor.getShort(offset + 8) != 0 // simpleBoolean
+            cursor.isNull(offset + 8) ? null : cursor.getShort(offset + 8) != 0, // simpleBoolean
+            cursor.isNull(offset + 9) ? null : cursor.getBlob(offset + 9) // simpleByteArray
         );
         return entity;
     }
@@ -147,6 +155,7 @@ public void readEntity(Cursor cursor, TestEntity entity, int offset) {
         entity.setIndexedStringAscUnique(cursor.isNull(offset + 6) ? null : cursor.getString(offset + 6));
         entity.setSimpleDate(cursor.isNull(offset + 7) ? null : new java.util.Date(cursor.getLong(offset + 7)));
         entity.setSimpleBoolean(cursor.isNull(offset + 8) ? null : cursor.getShort(offset + 8) != 0);
+        entity.setSimpleByteArray(cursor.isNull(offset + 9) ? null : cursor.getBlob(offset + 9));
      }
     
     /** @inheritdoc */
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/ToManyEntity.java b/DaoTest/src-gen/de/greenrobot/daotest/ToManyEntity.java
index c88b577f..76279426 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/ToManyEntity.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/ToManyEntity.java
@@ -6,7 +6,7 @@
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
 /**
- * Entity mapped to table TO_MANY_ENTITY.
+ * Entity mapped to table "TO_MANY_ENTITY".
  */
 public class ToManyEntity {
 
@@ -23,6 +23,7 @@
     private List<ToManyTargetEntity> toManyDescList;
     private List<ToManyTargetEntity> toManyByJoinProperty;
     private List<ToManyTargetEntity> toManyJoinTwo;
+    private List<DateEntity> dateEntityList;
 
     public ToManyEntity() {
     }
@@ -146,6 +147,28 @@ public synchronized void resetToManyJoinTwo() {
         toManyJoinTwo = null;
     }
 
+    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
+    public List<DateEntity> getDateEntityList() {
+        if (dateEntityList == null) {
+            if (daoSession == null) {
+                throw new DaoException("Entity is detached from DAO context");
+            }
+            DateEntityDao targetDao = daoSession.getDateEntityDao();
+            List<DateEntity> dateEntityListNew = targetDao._queryToManyEntity_DateEntityList(id);
+            synchronized (this) {
+                if(dateEntityList == null) {
+                    dateEntityList = dateEntityListNew;
+                }
+            }
+        }
+        return dateEntityList;
+    }
+
+    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
+    public synchronized void resetDateEntityList() {
+        dateEntityList = null;
+    }
+
     /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
     public void delete() {
         if (myDao == null) {
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/ToManyEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/ToManyEntityDao.java
index 953c2ad0..410c448a 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/ToManyEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/ToManyEntityDao.java
@@ -12,7 +12,7 @@
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
- * DAO for table TO_MANY_ENTITY.
+ * DAO for table "TO_MANY_ENTITY".
 */
 public class ToManyEntityDao extends AbstractDao<ToManyEntity, Long> {
 
@@ -42,14 +42,14 @@ public ToManyEntityDao(DaoConfig config, DaoSession daoSession) {
     /** Creates the underlying database table. */
     public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
-        db.execSQL("CREATE TABLE " + constraint + "'TO_MANY_ENTITY' (" + //
-                "'_id' INTEGER PRIMARY KEY ," + // 0: id
-                "'SOURCE_JOIN_PROPERTY' TEXT);"); // 1: sourceJoinProperty
+        db.execSQL("CREATE TABLE " + constraint + "\"TO_MANY_ENTITY\" (" + //
+                "\"_id\" INTEGER PRIMARY KEY ," + // 0: id
+                "\"SOURCE_JOIN_PROPERTY\" TEXT);"); // 1: sourceJoinProperty
     }
 
     /** Drops the underlying database table. */
     public static void dropTable(SQLiteDatabase db, boolean ifExists) {
-        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'TO_MANY_ENTITY'";
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "\"TO_MANY_ENTITY\"";
         db.execSQL(sql);
     }
 
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/ToManyTargetEntity.java b/DaoTest/src-gen/de/greenrobot/daotest/ToManyTargetEntity.java
index ad585ffb..94df37ea 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/ToManyTargetEntity.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/ToManyTargetEntity.java
@@ -2,7 +2,7 @@
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
 /**
- * Entity mapped to table TO_MANY_TARGET_ENTITY.
+ * Entity mapped to table "TO_MANY_TARGET_ENTITY".
  */
 public class ToManyTargetEntity {
 
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/ToManyTargetEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/ToManyTargetEntityDao.java
index ff44764b..61aafebe 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/ToManyTargetEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/ToManyTargetEntityDao.java
@@ -15,7 +15,7 @@
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
- * DAO for table TO_MANY_TARGET_ENTITY.
+ * DAO for table "TO_MANY_TARGET_ENTITY".
 */
 public class ToManyTargetEntityDao extends AbstractDao<ToManyTargetEntity, Long> {
 
@@ -48,16 +48,16 @@ public ToManyTargetEntityDao(DaoConfig config, DaoSession daoSession) {
     /** Creates the underlying database table. */
     public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
-        db.execSQL("CREATE TABLE " + constraint + "'TO_MANY_TARGET_ENTITY' (" + //
-                "'TO_MANY_ID' INTEGER," + // 0: toManyId
-                "'TO_MANY_ID_DESC' INTEGER," + // 1: toManyIdDesc
-                "'_id' INTEGER PRIMARY KEY ," + // 2: id
-                "'TARGET_JOIN_PROPERTY' TEXT);"); // 3: targetJoinProperty
+        db.execSQL("CREATE TABLE " + constraint + "\"TO_MANY_TARGET_ENTITY\" (" + //
+                "\"TO_MANY_ID\" INTEGER," + // 0: toManyId
+                "\"TO_MANY_ID_DESC\" INTEGER," + // 1: toManyIdDesc
+                "\"_id\" INTEGER PRIMARY KEY ," + // 2: id
+                "\"TARGET_JOIN_PROPERTY\" TEXT);"); // 3: targetJoinProperty
     }
 
     /** Drops the underlying database table. */
     public static void dropTable(SQLiteDatabase db, boolean ifExists) {
-        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'TO_MANY_TARGET_ENTITY'";
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "\"TO_MANY_TARGET_ENTITY\"";
         db.execSQL(sql);
     }
 
@@ -143,7 +143,7 @@ protected boolean isEntityUpdateable() {
             if (toManyEntity_ToManyTargetEntityListQuery == null) {
                 QueryBuilder<ToManyTargetEntity> queryBuilder = queryBuilder();
                 queryBuilder.where(Properties.ToManyId.eq(null));
-                queryBuilder.orderRaw("_id ASC");
+                queryBuilder.orderRaw("T.'_id' ASC");
                 toManyEntity_ToManyTargetEntityListQuery = queryBuilder.build();
             }
         }
@@ -158,7 +158,7 @@ protected boolean isEntityUpdateable() {
             if (toManyEntity_ToManyDescListQuery == null) {
                 QueryBuilder<ToManyTargetEntity> queryBuilder = queryBuilder();
                 queryBuilder.where(Properties.ToManyIdDesc.eq(null));
-                queryBuilder.orderRaw("_id DESC");
+                queryBuilder.orderRaw("T.'_id' DESC");
                 toManyEntity_ToManyDescListQuery = queryBuilder.build();
             }
         }
@@ -173,7 +173,7 @@ protected boolean isEntityUpdateable() {
             if (toManyEntity_ToManyByJoinPropertyQuery == null) {
                 QueryBuilder<ToManyTargetEntity> queryBuilder = queryBuilder();
                 queryBuilder.where(Properties.TargetJoinProperty.eq(null));
-                queryBuilder.orderRaw("_id ASC");
+                queryBuilder.orderRaw("T.'_id' ASC");
                 toManyEntity_ToManyByJoinPropertyQuery = queryBuilder.build();
             }
         }
@@ -189,7 +189,7 @@ protected boolean isEntityUpdateable() {
                 QueryBuilder<ToManyTargetEntity> queryBuilder = queryBuilder();
                 queryBuilder.where(Properties.ToManyId.eq(null));
                 queryBuilder.where(Properties.TargetJoinProperty.eq(null));
-                queryBuilder.orderRaw("TARGET_JOIN_PROPERTY DESC,_id DESC");
+                queryBuilder.orderRaw("T.'TARGET_JOIN_PROPERTY' DESC,T.'_id' DESC");
                 toManyEntity_ToManyJoinTwoQuery = queryBuilder.build();
             }
         }
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/TreeEntity.java b/DaoTest/src-gen/de/greenrobot/daotest/TreeEntity.java
index 8b4d0ca3..cd8bdda9 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/TreeEntity.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/TreeEntity.java
@@ -6,7 +6,7 @@
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
 /**
- * Entity mapped to table TREE_ENTITY.
+ * Entity mapped to table "TREE_ENTITY".
  */
 public class TreeEntity {
 
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/TreeEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/TreeEntityDao.java
index 14d3521a..934b0b3a 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/TreeEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/TreeEntityDao.java
@@ -17,7 +17,7 @@
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
- * DAO for table TREE_ENTITY.
+ * DAO for table "TREE_ENTITY".
 */
 public class TreeEntityDao extends AbstractDao<TreeEntity, Long> {
 
@@ -48,14 +48,14 @@ public TreeEntityDao(DaoConfig config, DaoSession daoSession) {
     /** Creates the underlying database table. */
     public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
-        db.execSQL("CREATE TABLE " + constraint + "'TREE_ENTITY' (" + //
-                "'_id' INTEGER PRIMARY KEY ," + // 0: id
-                "'PARENT_ID' INTEGER);"); // 1: parentId
+        db.execSQL("CREATE TABLE " + constraint + "\"TREE_ENTITY\" (" + //
+                "\"_id\" INTEGER PRIMARY KEY ," + // 0: id
+                "\"PARENT_ID\" INTEGER);"); // 1: parentId
     }
 
     /** Drops the underlying database table. */
     public static void dropTable(SQLiteDatabase db, boolean ifExists) {
-        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'TREE_ENTITY'";
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "\"TREE_ENTITY\"";
         db.execSQL(sql);
     }
 
@@ -150,7 +150,7 @@ protected String getSelectDeep() {
             builder.append(',');
             SqlUtils.appendColumns(builder, "T0", daoSession.getTreeEntityDao().getAllColumns());
             builder.append(" FROM TREE_ENTITY T");
-            builder.append(" LEFT JOIN TREE_ENTITY T0 ON T.'PARENT_ID'=T0.'_id'");
+            builder.append(" LEFT JOIN TREE_ENTITY T0 ON T.\"PARENT_ID\"=T0.\"_id\"");
             builder.append(' ');
             selectDeep = builder.toString();
         }
diff --git a/DaoTest/src-gen/de/greenrobot/daotest2/KeepEntity.java b/DaoTest/src-gen/de/greenrobot/daotest2/KeepEntity.java
index b3b185a8..5d575211 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest2/KeepEntity.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest2/KeepEntity.java
@@ -6,7 +6,7 @@
 import android.os.Build;
 // KEEP INCLUDES END
 /**
- * Entity mapped to table KEEP_ENTITY.
+ * Entity mapped to table "KEEP_ENTITY".
  */
 public class KeepEntity {
 
diff --git a/DaoTest/src-gen/de/greenrobot/daotest2/ToManyTarget2.java b/DaoTest/src-gen/de/greenrobot/daotest2/ToManyTarget2.java
index 3265f8ec..3fa8bcd0 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest2/ToManyTarget2.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest2/ToManyTarget2.java
@@ -5,7 +5,7 @@
 // KEEP INCLUDES - put your custom includes here
 // KEEP INCLUDES END
 /**
- * Entity mapped to table TO_MANY_TARGET2.
+ * Entity mapped to table "TO_MANY_TARGET2".
  */
 public class ToManyTarget2 {
 
diff --git a/DaoTest/src-gen/de/greenrobot/daotest2/dao/KeepEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest2/dao/KeepEntityDao.java
index f8de31aa..c3d748f0 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest2/dao/KeepEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest2/dao/KeepEntityDao.java
@@ -12,7 +12,7 @@
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
- * DAO for table KEEP_ENTITY.
+ * DAO for table "KEEP_ENTITY".
 */
 public class KeepEntityDao extends AbstractDao<KeepEntity, Long> {
 
@@ -38,13 +38,13 @@ public KeepEntityDao(DaoConfig config, DaoSession daoSession) {
     /** Creates the underlying database table. */
     public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
-        db.execSQL("CREATE TABLE " + constraint + "'KEEP_ENTITY' (" + //
-                "'_id' INTEGER PRIMARY KEY );"); // 0: id
+        db.execSQL("CREATE TABLE " + constraint + "\"KEEP_ENTITY\" (" + //
+                "\"_id\" INTEGER PRIMARY KEY );"); // 0: id
     }
 
     /** Drops the underlying database table. */
     public static void dropTable(SQLiteDatabase db, boolean ifExists) {
-        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'KEEP_ENTITY'";
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "\"KEEP_ENTITY\"";
         db.execSQL(sql);
     }
 
diff --git a/DaoTest/src-gen/de/greenrobot/daotest2/dao/ToManyTarget2Dao.java b/DaoTest/src-gen/de/greenrobot/daotest2/dao/ToManyTarget2Dao.java
index a55df346..9370a884 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest2/dao/ToManyTarget2Dao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest2/dao/ToManyTarget2Dao.java
@@ -15,7 +15,7 @@
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
- * DAO for table TO_MANY_TARGET2.
+ * DAO for table "TO_MANY_TARGET2".
 */
 public class ToManyTarget2Dao extends AbstractDao<ToManyTarget2, Long> {
 
@@ -43,14 +43,14 @@ public ToManyTarget2Dao(DaoConfig config, DaoSession daoSession) {
     /** Creates the underlying database table. */
     public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
-        db.execSQL("CREATE TABLE " + constraint + "'TO_MANY_TARGET2' (" + //
-                "'_id' INTEGER PRIMARY KEY ," + // 0: id
-                "'FK_ID' INTEGER);"); // 1: fkId
+        db.execSQL("CREATE TABLE " + constraint + "\"TO_MANY_TARGET2\" (" + //
+                "\"_id\" INTEGER PRIMARY KEY ," + // 0: id
+                "\"FK_ID\" INTEGER);"); // 1: fkId
     }
 
     /** Drops the underlying database table. */
     public static void dropTable(SQLiteDatabase db, boolean ifExists) {
-        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'TO_MANY_TARGET2'";
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "\"TO_MANY_TARGET2\"";
         db.execSQL(sql);
     }
 
diff --git a/DaoTest/src-gen/de/greenrobot/daotest2/specialdao/RelationSource2Dao.java b/DaoTest/src-gen/de/greenrobot/daotest2/specialdao/RelationSource2Dao.java
index 107160bc..ea61e43a 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest2/specialdao/RelationSource2Dao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest2/specialdao/RelationSource2Dao.java
@@ -19,7 +19,7 @@
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
- * DAO for table RELATION_SOURCE2.
+ * DAO for table "RELATION_SOURCE2".
 */
 public class RelationSource2Dao extends AbstractDao<RelationSource2, Long> {
 
@@ -49,14 +49,14 @@ public RelationSource2Dao(DaoConfig config, DaoSession daoSession) {
     /** Creates the underlying database table. */
     public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
-        db.execSQL("CREATE TABLE " + constraint + "'RELATION_SOURCE2' (" + //
-                "'_id' INTEGER PRIMARY KEY ," + // 0: id
-                "'TO_ONE_ID' INTEGER);"); // 1: toOneId
+        db.execSQL("CREATE TABLE " + constraint + "\"RELATION_SOURCE2\" (" + //
+                "\"_id\" INTEGER PRIMARY KEY ," + // 0: id
+                "\"TO_ONE_ID\" INTEGER);"); // 1: toOneId
     }
 
     /** Drops the underlying database table. */
     public static void dropTable(SQLiteDatabase db, boolean ifExists) {
-        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'RELATION_SOURCE2'";
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "\"RELATION_SOURCE2\"";
         db.execSQL(sql);
     }
 
@@ -137,7 +137,7 @@ protected String getSelectDeep() {
             builder.append(',');
             SqlUtils.appendColumns(builder, "T0", daoSession.getToOneTarget2Dao().getAllColumns());
             builder.append(" FROM RELATION_SOURCE2 T");
-            builder.append(" LEFT JOIN TO_ONE_TARGET2 T0 ON T.'TO_ONE_ID'=T0.'_id'");
+            builder.append(" LEFT JOIN TO_ONE_TARGET2 T0 ON T.\"TO_ONE_ID\"=T0.\"_id\"");
             builder.append(' ');
             selectDeep = builder.toString();
         }
diff --git a/DaoTest/src-gen/de/greenrobot/daotest2/specialentity/RelationSource2.java b/DaoTest/src-gen/de/greenrobot/daotest2/specialentity/RelationSource2.java
index ff587223..1eb7e599 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest2/specialentity/RelationSource2.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest2/specialentity/RelationSource2.java
@@ -15,7 +15,7 @@
 // KEEP INCLUDES - put your custom includes here
 // KEEP INCLUDES END
 /**
- * Entity mapped to table RELATION_SOURCE2.
+ * Entity mapped to table "RELATION_SOURCE2".
  */
 public class RelationSource2 {
 
diff --git a/DaoTest/src-gen/de/greenrobot/daotest2/to1_specialdao/ToOneTarget2Dao.java b/DaoTest/src-gen/de/greenrobot/daotest2/to1_specialdao/ToOneTarget2Dao.java
index 3ff139b3..9048acb9 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest2/to1_specialdao/ToOneTarget2Dao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest2/to1_specialdao/ToOneTarget2Dao.java
@@ -14,7 +14,7 @@
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
- * DAO for table TO_ONE_TARGET2.
+ * DAO for table "TO_ONE_TARGET2".
 */
 public class ToOneTarget2Dao extends AbstractDao<ToOneTarget2, Long> {
 
@@ -40,13 +40,13 @@ public ToOneTarget2Dao(DaoConfig config, DaoSession daoSession) {
     /** Creates the underlying database table. */
     public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
-        db.execSQL("CREATE TABLE " + constraint + "'TO_ONE_TARGET2' (" + //
-                "'_id' INTEGER PRIMARY KEY );"); // 0: id
+        db.execSQL("CREATE TABLE " + constraint + "\"TO_ONE_TARGET2\" (" + //
+                "\"_id\" INTEGER PRIMARY KEY );"); // 0: id
     }
 
     /** Drops the underlying database table. */
     public static void dropTable(SQLiteDatabase db, boolean ifExists) {
-        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'TO_ONE_TARGET2'";
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "\"TO_ONE_TARGET2\"";
         db.execSQL(sql);
     }
 
diff --git a/DaoTest/src-gen/de/greenrobot/daotest2/to1_specialentity/ToOneTarget2.java b/DaoTest/src-gen/de/greenrobot/daotest2/to1_specialentity/ToOneTarget2.java
index d5444c79..12fae8d7 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest2/to1_specialentity/ToOneTarget2.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest2/to1_specialentity/ToOneTarget2.java
@@ -5,7 +5,7 @@
 // KEEP INCLUDES - put your custom includes here
 // KEEP INCLUDES END
 /**
- * Entity mapped to table TO_ONE_TARGET2.
+ * Entity mapped to table "TO_ONE_TARGET2".
  */
 public class ToOneTarget2 {
 
diff --git a/DaoTest/src-unit-test/de/greenrobot/dao/unittest/DaoMaster.java b/DaoTest/src-unit-test/de/greenrobot/dao/unittest/DaoMaster.java
new file mode 100644
index 00000000..45473f60
--- /dev/null
+++ b/DaoTest/src-unit-test/de/greenrobot/dao/unittest/DaoMaster.java
@@ -0,0 +1,70 @@
+package de.greenrobot.dao.unittest;
+
+import android.content.Context;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteDatabase.CursorFactory;
+import android.database.sqlite.SQLiteOpenHelper;
+import android.util.Log;
+import de.greenrobot.dao.AbstractDaoMaster;
+import de.greenrobot.dao.identityscope.IdentityScopeType;
+
+import de.greenrobot.dao.unittest.MinimalEntityDao;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+/** 
+ * Master of DAO (schema version 1): knows all DAOs.
+*/
+public class DaoMaster extends AbstractDaoMaster {
+    public static final int SCHEMA_VERSION = 1;
+
+    /** Creates underlying database table using DAOs. */
+    public static void createAllTables(SQLiteDatabase db, boolean ifNotExists) {
+        MinimalEntityDao.createTable(db, ifNotExists);
+    }
+    
+    /** Drops underlying database table using DAOs. */
+    public static void dropAllTables(SQLiteDatabase db, boolean ifExists) {
+        MinimalEntityDao.dropTable(db, ifExists);
+    }
+    
+    public static abstract class OpenHelper extends SQLiteOpenHelper {
+
+        public OpenHelper(Context context, String name, CursorFactory factory) {
+            super(context, name, factory, SCHEMA_VERSION);
+        }
+
+        @Override
+        public void onCreate(SQLiteDatabase db) {
+            Log.i("greenDAO", "Creating tables for schema version " + SCHEMA_VERSION);
+            createAllTables(db, false);
+        }
+    }
+    
+    /** WARNING: Drops all table on Upgrade! Use only during development. */
+    public static class DevOpenHelper extends OpenHelper {
+        public DevOpenHelper(Context context, String name, CursorFactory factory) {
+            super(context, name, factory);
+        }
+
+        @Override
+        public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+            Log.i("greenDAO", "Upgrading schema from version " + oldVersion + " to " + newVersion + " by dropping all tables");
+            dropAllTables(db, true);
+            onCreate(db);
+        }
+    }
+
+    public DaoMaster(SQLiteDatabase db) {
+        super(db, SCHEMA_VERSION);
+        registerDaoClass(MinimalEntityDao.class);
+    }
+    
+    public DaoSession newSession() {
+        return new DaoSession(db, IdentityScopeType.Session, daoConfigMap);
+    }
+    
+    public DaoSession newSession(IdentityScopeType type) {
+        return new DaoSession(db, type, daoConfigMap);
+    }
+    
+}
diff --git a/DaoTest/src-unit-test/de/greenrobot/dao/unittest/DaoSession.java b/DaoTest/src-unit-test/de/greenrobot/dao/unittest/DaoSession.java
new file mode 100644
index 00000000..53dabbcb
--- /dev/null
+++ b/DaoTest/src-unit-test/de/greenrobot/dao/unittest/DaoSession.java
@@ -0,0 +1,49 @@
+package de.greenrobot.dao.unittest;
+
+import android.database.sqlite.SQLiteDatabase;
+
+import java.util.Map;
+
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.AbstractDaoSession;
+import de.greenrobot.dao.identityscope.IdentityScopeType;
+import de.greenrobot.dao.internal.DaoConfig;
+
+import de.greenrobot.dao.unittest.MinimalEntity;
+
+import de.greenrobot.dao.unittest.MinimalEntityDao;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+
+/**
+ * {@inheritDoc}
+ * 
+ * @see de.greenrobot.dao.AbstractDaoSession
+ */
+public class DaoSession extends AbstractDaoSession {
+
+    private final DaoConfig minimalEntityDaoConfig;
+
+    private final MinimalEntityDao minimalEntityDao;
+
+    public DaoSession(SQLiteDatabase db, IdentityScopeType type, Map<Class<? extends AbstractDao<?, ?>>, DaoConfig>
+            daoConfigMap) {
+        super(db);
+
+        minimalEntityDaoConfig = daoConfigMap.get(MinimalEntityDao.class).clone();
+        minimalEntityDaoConfig.initIdentityScope(type);
+
+        minimalEntityDao = new MinimalEntityDao(minimalEntityDaoConfig, this);
+
+        registerDao(MinimalEntity.class, minimalEntityDao);
+    }
+    
+    public void clear() {
+        minimalEntityDaoConfig.getIdentityScope().clear();
+    }
+
+    public MinimalEntityDao getMinimalEntityDao() {
+        return minimalEntityDao;
+    }
+
+}
diff --git a/DaoTest/src-unit-test/de/greenrobot/dao/unittest/MinimalEntity.java b/DaoTest/src-unit-test/de/greenrobot/dao/unittest/MinimalEntity.java
new file mode 100644
index 00000000..7e44d860
--- /dev/null
+++ b/DaoTest/src-unit-test/de/greenrobot/dao/unittest/MinimalEntity.java
@@ -0,0 +1,26 @@
+package de.greenrobot.dao.unittest;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
+/**
+ * Entity mapped to table "MINIMAL_ENTITY".
+ */
+public class MinimalEntity {
+
+    private Long id;
+
+    public MinimalEntity() {
+    }
+
+    public MinimalEntity(Long id) {
+        this.id = id;
+    }
+
+    public Long getId() {
+        return id;
+    }
+
+    public void setId(Long id) {
+        this.id = id;
+    }
+
+}
diff --git a/DaoTest/src-unit-test/de/greenrobot/dao/unittest/MinimalEntityDao.java b/DaoTest/src-unit-test/de/greenrobot/dao/unittest/MinimalEntityDao.java
new file mode 100644
index 00000000..530442c5
--- /dev/null
+++ b/DaoTest/src-unit-test/de/greenrobot/dao/unittest/MinimalEntityDao.java
@@ -0,0 +1,106 @@
+package de.greenrobot.dao.unittest;
+
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteStatement;
+
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.Property;
+import de.greenrobot.dao.internal.DaoConfig;
+
+import de.greenrobot.dao.unittest.MinimalEntity;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+/** 
+ * DAO for table "MINIMAL_ENTITY".
+*/
+public class MinimalEntityDao extends AbstractDao<MinimalEntity, Long> {
+
+    public static final String TABLENAME = "MINIMAL_ENTITY";
+
+    /**
+     * Properties of entity MinimalEntity.<br/>
+     * Can be used for QueryBuilder and for referencing column names.
+    */
+    public static class Properties {
+        public final static Property Id = new Property(0, Long.class, "id", true, "_id");
+    };
+
+
+    public MinimalEntityDao(DaoConfig config) {
+        super(config);
+    }
+    
+    public MinimalEntityDao(DaoConfig config, DaoSession daoSession) {
+        super(config, daoSession);
+    }
+
+    /** Creates the underlying database table. */
+    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+        String constraint = ifNotExists? "IF NOT EXISTS ": "";
+        db.execSQL("CREATE TABLE " + constraint + "\"MINIMAL_ENTITY\" (" + //
+                "\"_id\" INTEGER PRIMARY KEY );"); // 0: id
+    }
+
+    /** Drops the underlying database table. */
+    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "\"MINIMAL_ENTITY\"";
+        db.execSQL(sql);
+    }
+
+    /** @inheritdoc */
+    @Override
+    protected void bindValues(SQLiteStatement stmt, MinimalEntity entity) {
+        stmt.clearBindings();
+ 
+        Long id = entity.getId();
+        if (id != null) {
+            stmt.bindLong(1, id);
+        }
+    }
+
+    /** @inheritdoc */
+    @Override
+    public Long readKey(Cursor cursor, int offset) {
+        return cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0);
+    }    
+
+    /** @inheritdoc */
+    @Override
+    public MinimalEntity readEntity(Cursor cursor, int offset) {
+        MinimalEntity entity = new MinimalEntity( //
+            cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0) // id
+        );
+        return entity;
+    }
+     
+    /** @inheritdoc */
+    @Override
+    public void readEntity(Cursor cursor, MinimalEntity entity, int offset) {
+        entity.setId(cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0));
+     }
+    
+    /** @inheritdoc */
+    @Override
+    protected Long updateKeyAfterInsert(MinimalEntity entity, long rowId) {
+        entity.setId(rowId);
+        return rowId;
+    }
+    
+    /** @inheritdoc */
+    @Override
+    public Long getKey(MinimalEntity entity) {
+        if(entity != null) {
+            return entity.getId();
+        } else {
+            return null;
+        }
+    }
+
+    /** @inheritdoc */
+    @Override    
+    protected boolean isEntityUpdateable() {
+        return true;
+    }
+    
+}
diff --git a/DaoTest/src-unit-test/de/greenrobot/dao/unittest/MinimalEntityTest.java b/DaoTest/src-unit-test/de/greenrobot/dao/unittest/MinimalEntityTest.java
new file mode 100644
index 00000000..702ba039
--- /dev/null
+++ b/DaoTest/src-unit-test/de/greenrobot/dao/unittest/MinimalEntityTest.java
@@ -0,0 +1,71 @@
+package de.greenrobot.dao.unittest;
+
+import android.database.sqlite.SQLiteDatabase;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+import java.util.concurrent.CountDownLatch;
+
+import de.greenrobot.dao.query.Query;
+import de.greenrobot.daotest.dummyapp.BuildConfig;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = BuildConfig.class, sdk = 16)
+public class MinimalEntityTest {
+
+    private DaoSession daoSession;
+    private MinimalEntityDao minimalEntityDao;
+
+    @Before
+    public void setUp() {
+        DaoMaster.DevOpenHelper openHelper = new DaoMaster.DevOpenHelper(RuntimeEnvironment.application, null, null);
+        SQLiteDatabase db = openHelper.getWritableDatabase();
+        daoSession = new DaoMaster(db).newSession();
+        minimalEntityDao = daoSession.getMinimalEntityDao();
+    }
+
+    @Test
+    public void testBasics() {
+        MinimalEntity entity = new MinimalEntity();
+        daoSession.insert(entity);
+        assertNotNull(entity.getId());
+        assertNotNull(minimalEntityDao.load(entity.getId()));
+        assertEquals(1, minimalEntityDao.count());
+        assertEquals(1, daoSession.loadAll(MinimalEntity.class).size());
+
+        daoSession.update(entity);
+        daoSession.delete(entity);
+        assertNull(minimalEntityDao.load(entity.getId()));
+    }
+
+    @Test
+    // Testing the work around for Process.myTid() being always 0 in Robolectric
+    public void testQueryForCurrentThread() throws InterruptedException {
+        final CountDownLatch latch = new CountDownLatch(1);
+        final Query<MinimalEntity>[] queryHolder = new Query[1];
+        new Thread() {
+            @Override
+            public void run() {
+                try {
+                    queryHolder[0] = minimalEntityDao.queryBuilder().build();
+                    queryHolder[0].list();
+                } finally {
+                    latch.countDown();
+                }
+            }
+        }.start();
+        latch.await();
+        Query<MinimalEntity> query = queryHolder[0].forCurrentThread();
+        query.list();
+    }
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/DaoSessionConcurrentTest.java b/DaoTest/src/de/greenrobot/daotest/DaoSessionConcurrentTest.java
index ffa9e718..e243c4c5 100644
--- a/DaoTest/src/de/greenrobot/daotest/DaoSessionConcurrentTest.java
+++ b/DaoTest/src/de/greenrobot/daotest/DaoSessionConcurrentTest.java
@@ -5,6 +5,7 @@
 import android.database.sqlite.SQLiteDatabase;
 import android.database.sqlite.SQLiteStatement;
 import android.os.SystemClock;
+
 import de.greenrobot.dao.DaoLog;
 import de.greenrobot.dao.query.DeleteQuery;
 import de.greenrobot.dao.query.Query;
@@ -209,17 +210,14 @@ public void run() {
         latchThreadsDone.await();
     }
 
-    // No connection for read can be acquired while TX is active; this will deadlock!
-    public void _testConcurrentLockAndQueryDuringTx() throws InterruptedException {
+    public void testConcurrentLockAndQueryDuringTx() throws InterruptedException {
         final TestEntity entity = createEntity(null);
         dao.insert(entity);
         final Query<TestEntity> query = dao.queryBuilder().build();
         Runnable runnable1 = new Runnable() {
             @Override
             public void run() {
-                synchronized (query) {
-                    query.list();
-                }
+                query.forCurrentThread().list();
             }
         };
 
@@ -229,9 +227,7 @@ public void run() {
         doTx(new Runnable() {
             @Override
             public void run() {
-                synchronized (query) {
-                    query.list();
-                }
+                query.list();
             }
         });
         latchThreadsDone.await();
diff --git a/DaoTest/src/de/greenrobot/daotest/DaoSessionTest.java b/DaoTest/src/de/greenrobot/daotest/DaoSessionTest.java
index df70ce52..dc44c2b7 100644
--- a/DaoTest/src/de/greenrobot/daotest/DaoSessionTest.java
+++ b/DaoTest/src/de/greenrobot/daotest/DaoSessionTest.java
@@ -1,61 +1,61 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daotest;
-
-import de.greenrobot.dao.test.AbstractDaoSessionTest;
-
-public class DaoSessionTest extends AbstractDaoSessionTest<DaoMaster, DaoSession> {
-
-    public DaoSessionTest() {
-        super(DaoMaster.class);
-    }
-
-    public void testInsertAndLoad() {
-        SimpleEntity entity = new SimpleEntity();
-        daoSession.insert(entity);
-        Long id = entity.getId();
-        assertNotNull(id);
-        SimpleEntity entity2 = daoSession.load(SimpleEntity.class, id);
-        assertNotNull(entity2);
-    }
-
-    public void testIdentity() {
-        SimpleEntity entity = new SimpleEntity();
-        daoSession.insert(entity);
-        SimpleEntity entity2 = daoSession.load(SimpleEntity.class, entity.getId());
-        SimpleEntity entity3 = daoSession.load(SimpleEntity.class, entity.getId());
-        assertSame(entity, entity2);
-        assertSame(entity, entity3);
-    }
-
-    public void testIdentityPerSession() {
-        SimpleEntity entity = new SimpleEntity();
-        daoSession.insert(entity);
-        DaoSession session2 = daoMaster.newSession();
-        SimpleEntity entity2 = session2.load(SimpleEntity.class, entity.getId());
-        assertNotSame(entity, entity2);
-    }
-
-    public void testSessionReset() {
-        SimpleEntity entity = new SimpleEntity();
-        daoSession.insert(entity);
-        daoSession.clear();
-        SimpleEntity entity2 = daoSession.load(SimpleEntity.class, entity.getId());
-        assertNotSame(entity, entity2);
-    }
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest;
+
+import de.greenrobot.dao.test.AbstractDaoSessionTest;
+
+public class DaoSessionTest extends AbstractDaoSessionTest<DaoMaster, DaoSession> {
+
+    public DaoSessionTest() {
+        super(DaoMaster.class);
+    }
+
+    public void testInsertAndLoad() {
+        SimpleEntity entity = new SimpleEntity();
+        daoSession.insert(entity);
+        Long id = entity.getId();
+        assertNotNull(id);
+        SimpleEntity entity2 = daoSession.load(SimpleEntity.class, id);
+        assertNotNull(entity2);
+    }
+
+    public void testIdentity() {
+        SimpleEntity entity = new SimpleEntity();
+        daoSession.insert(entity);
+        SimpleEntity entity2 = daoSession.load(SimpleEntity.class, entity.getId());
+        SimpleEntity entity3 = daoSession.load(SimpleEntity.class, entity.getId());
+        assertSame(entity, entity2);
+        assertSame(entity, entity3);
+    }
+
+    public void testIdentityPerSession() {
+        SimpleEntity entity = new SimpleEntity();
+        daoSession.insert(entity);
+        DaoSession session2 = daoMaster.newSession();
+        SimpleEntity entity2 = session2.load(SimpleEntity.class, entity.getId());
+        assertNotSame(entity, entity2);
+    }
+
+    public void testSessionReset() {
+        SimpleEntity entity = new SimpleEntity();
+        daoSession.insert(entity);
+        daoSession.clear();
+        SimpleEntity entity2 = daoSession.load(SimpleEntity.class, entity.getId());
+        assertNotSame(entity, entity2);
+    }
 }
\ No newline at end of file
diff --git a/DaoTest/src/de/greenrobot/daotest/DbUtilsTest.java b/DaoTest/src/de/greenrobot/daotest/DbUtilsTest.java
index 47e5c89a..4ff7957d 100644
--- a/DaoTest/src/de/greenrobot/daotest/DbUtilsTest.java
+++ b/DaoTest/src/de/greenrobot/daotest/DbUtilsTest.java
@@ -1,38 +1,38 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daotest;
-
-import java.io.IOException;
-
-import android.database.Cursor;
-import de.greenrobot.dao.DbUtils;
-import de.greenrobot.dao.test.DbTest;
-
-public class DbUtilsTest extends DbTest {
-    public void testExecuteSqlScript() throws IOException {
-        DbUtils.executeSqlScript(getContext(), db, "minimal-entity.sql");
-        Cursor cursor = db.rawQuery("SELECT count(*) from MINIMAL_ENTITY", null);
-        try {
-            cursor.moveToFirst();
-            assertEquals(5, cursor.getInt(0));
-        } finally {
-            cursor.close();
-        }
-    }
-
-}
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest;
+
+import java.io.IOException;
+
+import android.database.Cursor;
+import de.greenrobot.dao.DbUtils;
+import de.greenrobot.dao.test.DbTest;
+
+public class DbUtilsTest extends DbTest {
+    public void testExecuteSqlScript() throws IOException {
+        DbUtils.executeSqlScript(getContext(), db, "minimal-entity.sql");
+        Cursor cursor = db.rawQuery("SELECT count(*) from MINIMAL_ENTITY", null);
+        try {
+            cursor.moveToFirst();
+            assertEquals(5, cursor.getInt(0));
+        } finally {
+            cursor.close();
+        }
+    }
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/DeadlockPreventionTest.java b/DaoTest/src/de/greenrobot/daotest/DeadlockPreventionTest.java
new file mode 100644
index 00000000..ae015fb2
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/DeadlockPreventionTest.java
@@ -0,0 +1,153 @@
+/*
+ * Copyright (C) 2011-2015 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+import de.greenrobot.dao.test.AbstractDaoSessionTest;
+
+/**
+ * Test to reproduce https://github.com/greenrobot/greenDAO/issues/223 (works at least on a Android 2.3 emulator).
+ */
+public class DeadlockPreventionTest extends AbstractDaoSessionTest<DaoMaster, DaoSession> {
+
+    CountDownLatch done = new CountDownLatch(1);
+    private TestEntityDao dao;
+
+    public DeadlockPreventionTest() {
+        super(DaoMaster.class);
+    }
+
+    // Runs pretty long, only run manually
+    public void _testLoadAll() throws InterruptedException {
+        dao = daoSession.getTestEntityDao();
+        List<TestEntity> entities = new ArrayList<>();
+        for (int i = 0; i < 10000; i++) {
+            TestEntity entity = new TestEntity();
+            entity.setSimpleStringNotNull("Text" + i);
+            entities.add(entity);
+        }
+        dao.insertInTx(entities);
+        System.out.println("Entities inserted");
+
+        LoadThread loadThread = new LoadThread();
+        InsertThread insertThread = new InsertThread();
+        InsertBatchThread insertBatchThread = new InsertBatchThread();
+        loadThread.start();
+        insertThread.start();
+        insertBatchThread.start();
+
+        int lastCounterInsert = insertThread.counter;
+        int lastCounterInsertBatch = insertBatchThread.counter;
+        int noProgressCount = 0;
+        while (!done.await(10, TimeUnit.SECONDS)) {
+            if (lastCounterInsert == insertThread.counter && lastCounterInsertBatch == insertBatchThread.counter) {
+                noProgressCount++;
+                System.err.println("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
+                System.err.println("No progress #" + noProgressCount + ", dumping threads");
+                System.err.println("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
+                dumpStacktrace("LOAD", loadThread);
+                dumpStacktrace("INSERT", insertThread);
+                dumpStacktrace("INSERT BATCH", insertBatchThread);
+
+                if (noProgressCount >= 3) {
+                    // Test seems to be stuck, kill everything!
+                    System.exit(1);
+                }
+            } else {
+                lastCounterInsert = insertThread.counter;
+                lastCounterInsertBatch = insertBatchThread.counter;
+                noProgressCount = 0;
+            }
+        }
+
+        loadThread.join();
+        insertThread.join();
+        insertBatchThread.join();
+    }
+
+    private void dumpStacktrace(String name, Thread thread) {
+        System.err.println("--- Thread dump of " + name + " ------------------------");
+        for (StackTraceElement element : thread.getStackTrace()) {
+            System.err.println(element);
+        }
+    }
+
+    private class LoadThread extends Thread {
+        @Override
+        public void run() {
+            for (int i = 0; i < 10; i++) {
+                System.out.println("Starting loadAll #" + i);
+                dao.loadAll();
+            }
+            done.countDown();
+        }
+    }
+
+
+    private class InsertThread extends Thread {
+        volatile int counter = 0;
+
+        @Override
+        public void run() {
+            List<TestEntity> toDelete = new ArrayList<>();
+            while (done.getCount() > 0) {
+                TestEntity entity = new TestEntity();
+                entity.setSimpleStringNotNull("TextThread" + counter);
+                dao.insert(entity);
+                toDelete.add(entity);
+                counter++;
+                if (counter % 10 == 0) {
+                    System.out.println("Thread inserted " + counter+ ", now deleting");
+                    dao.deleteInTx(toDelete);
+                    toDelete.clear();
+                }
+            }
+        }
+    }
+
+    private class InsertBatchThread extends Thread {
+        volatile int counter = 0;
+
+        @Override
+        public void run() {
+            List<TestEntity> batch = new ArrayList<>();
+            List<TestEntity> toDelete = new ArrayList<>();
+            while (done.getCount() > 0) {
+                TestEntity entity = new TestEntity();
+                entity.setSimpleStringNotNull("TextThreadBatch" + counter);
+                batch.add(entity);
+                counter++;
+                if (counter % 10 == 0) {
+                    dao.insertInTx(batch);
+                    System.out.println("Batch Thread inserted " + counter);
+                    toDelete.addAll(batch);
+                    batch.clear();
+                }
+                if (counter % 1000 == 0) {
+                    dao.deleteInTx(toDelete);
+                    toDelete.clear();
+                    System.out.println("Batch Thread deleted " + counter);
+                }
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/DaoTest/src/de/greenrobot/daotest/IndexTest.java b/DaoTest/src/de/greenrobot/daotest/IndexTest.java
index b5f15d46..402b367c 100644
--- a/DaoTest/src/de/greenrobot/daotest/IndexTest.java
+++ b/DaoTest/src/de/greenrobot/daotest/IndexTest.java
@@ -1,49 +1,49 @@
-package de.greenrobot.daotest;
-
-import java.util.List;
-
-import junit.framework.Assert;
-import de.greenrobot.dao.DaoLog;
-import de.greenrobot.dao.test.AbstractDaoTest;
-import de.greenrobot.daotest.SqliteMasterDao.Properties;
-
-public class IndexTest extends AbstractDaoTest<SqliteMasterDao, SqliteMaster, Void> {
-
-    public IndexTest() {
-        super(SqliteMasterDao.class);
-    }
-
-    public void testIndexesCreated() {
-        Assert.assertEquals(0, getIndexes().size());
-
-        TestEntityDao.createTable(db, false);
-        List<SqliteMaster> indexes = getIndexes();
-        Assert.assertEquals(2, indexes.size());
-
-        SqliteMaster index1 = indexes.get(0);
-        SqliteMaster index2 = indexes.get(1);
-        Assert.assertEquals(TestEntityDao.TABLENAME, index1.getTableName());
-        Assert.assertEquals(TestEntityDao.TABLENAME, index2.getTableName());
-        Assert.assertEquals("IDX_TEST_ENTITY_INDEXED_STRING", index1.getName());
-        Assert.assertEquals("IDX_TEST_ENTITY_INDEXED_STRING_ASC_UNIQUE", index2.getName());
-
-        for (SqliteMaster index : indexes) {
-            DaoLog.v(index.toString());
-        }
-    }
-    
-    public void testIndexCreateIfNotExists() {
-        Assert.assertEquals(0, getIndexes().size());
-        TestEntityDao.createTable(db, false);
-        Assert.assertEquals(2, getIndexes().size());
-        TestEntityDao.createTable(db, true);
-        Assert.assertEquals(2, getIndexes().size());
-    }
-
-    private List<SqliteMaster> getIndexes() {
-        String where = "WHERE " + Properties.Type.columnName + "=? ORDER BY " + Properties.Name.columnName;
-        List<SqliteMaster> indexes = dao.queryRaw(where, "index");
-        return indexes;
-    }
-
-}
+package de.greenrobot.daotest;
+
+import java.util.List;
+
+import junit.framework.Assert;
+import de.greenrobot.dao.DaoLog;
+import de.greenrobot.dao.test.AbstractDaoTest;
+import de.greenrobot.daotest.SqliteMasterDao.Properties;
+
+public class IndexTest extends AbstractDaoTest<SqliteMasterDao, SqliteMaster, Void> {
+
+    public IndexTest() {
+        super(SqliteMasterDao.class);
+    }
+
+    public void testIndexesCreated() {
+        Assert.assertEquals(0, getIndexes().size());
+
+        TestEntityDao.createTable(db, false);
+        List<SqliteMaster> indexes = getIndexes();
+        Assert.assertEquals(2, indexes.size());
+
+        SqliteMaster index1 = indexes.get(0);
+        SqliteMaster index2 = indexes.get(1);
+        Assert.assertEquals(TestEntityDao.TABLENAME, index1.getTableName());
+        Assert.assertEquals(TestEntityDao.TABLENAME, index2.getTableName());
+        Assert.assertEquals("IDX_TEST_ENTITY_INDEXED_STRING", index1.getName());
+        Assert.assertEquals("IDX_TEST_ENTITY_INDEXED_STRING_ASC_UNIQUE", index2.getName());
+
+        for (SqliteMaster index : indexes) {
+            DaoLog.v(index.toString());
+        }
+    }
+    
+    public void testIndexCreateIfNotExists() {
+        Assert.assertEquals(0, getIndexes().size());
+        TestEntityDao.createTable(db, false);
+        Assert.assertEquals(2, getIndexes().size());
+        TestEntityDao.createTable(db, true);
+        Assert.assertEquals(2, getIndexes().size());
+    }
+
+    private List<SqliteMaster> getIndexes() {
+        String where = "WHERE " + Properties.Type.columnName + "=? ORDER BY " + Properties.Name.columnName;
+        List<SqliteMaster> indexes = dao.queryRaw(where, "index");
+        return indexes;
+    }
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/TestInterface.java b/DaoTest/src/de/greenrobot/daotest/TestInterface.java
index 7c38baab..035d4ab2 100644
--- a/DaoTest/src/de/greenrobot/daotest/TestInterface.java
+++ b/DaoTest/src/de/greenrobot/daotest/TestInterface.java
@@ -1,5 +1,5 @@
-package de.greenrobot.daotest;
-
-public interface TestInterface {
-
-}
+package de.greenrobot.daotest;
+
+public interface TestInterface {
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/TestSuperclass.java b/DaoTest/src/de/greenrobot/daotest/TestSuperclass.java
index 8687b520..f360e3d0 100644
--- a/DaoTest/src/de/greenrobot/daotest/TestSuperclass.java
+++ b/DaoTest/src/de/greenrobot/daotest/TestSuperclass.java
@@ -1,5 +1,5 @@
-package de.greenrobot.daotest;
-
-public class TestSuperclass {
-
-}
+package de.greenrobot.daotest;
+
+public class TestSuperclass {
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/async/AbstractAsyncTest.java b/DaoTest/src/de/greenrobot/daotest/async/AbstractAsyncTest.java
index 423733c0..c363aa5e 100644
--- a/DaoTest/src/de/greenrobot/daotest/async/AbstractAsyncTest.java
+++ b/DaoTest/src/de/greenrobot/daotest/async/AbstractAsyncTest.java
@@ -1,47 +1,47 @@
-package de.greenrobot.daotest.async;
-
-import java.util.List;
-import java.util.concurrent.CopyOnWriteArrayList;
-
-import de.greenrobot.dao.async.AsyncOperation;
-import de.greenrobot.dao.async.AsyncOperationListener;
-import de.greenrobot.dao.async.AsyncSession;
-import de.greenrobot.dao.test.AbstractDaoSessionTest;
-import de.greenrobot.daotest.DaoMaster;
-import de.greenrobot.daotest.DaoSession;
-
-public abstract class AbstractAsyncTest extends AbstractDaoSessionTest<DaoMaster, DaoSession> implements
-        AsyncOperationListener {
-
-    protected AsyncSession asyncSession;
-    protected List<AsyncOperation> completedOperations;
-
-    public AbstractAsyncTest() {
-        super(DaoMaster.class);
-    }
-
-    @Override
-    protected void setUp() throws Exception {
-        super.setUp();
-        asyncSession = daoSession.startAsyncSession();
-        asyncSession.setListener(this);
-        completedOperations = new CopyOnWriteArrayList<AsyncOperation>();
-    }
-
-    public void assertWaitForCompletion1Sec() {
-        assertTrue(asyncSession.waitForCompletion(1000));
-        assertTrue(asyncSession.isCompleted());
-    }
-
-    @Override
-    public void onAsyncOperationCompleted(AsyncOperation operation) {
-        completedOperations.add(operation);
-    }
-
-    protected void assertSingleOperationCompleted(AsyncOperation operation) {
-        assertSame(operation, completedOperations.get(0));
-        assertEquals(1, completedOperations.size());
-        assertTrue(operation.isCompleted());
-    }
-
-}
+package de.greenrobot.daotest.async;
+
+import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
+
+import de.greenrobot.dao.async.AsyncOperation;
+import de.greenrobot.dao.async.AsyncOperationListener;
+import de.greenrobot.dao.async.AsyncSession;
+import de.greenrobot.dao.test.AbstractDaoSessionTest;
+import de.greenrobot.daotest.DaoMaster;
+import de.greenrobot.daotest.DaoSession;
+
+public abstract class AbstractAsyncTest extends AbstractDaoSessionTest<DaoMaster, DaoSession> implements
+        AsyncOperationListener {
+
+    protected AsyncSession asyncSession;
+    protected List<AsyncOperation> completedOperations;
+
+    public AbstractAsyncTest() {
+        super(DaoMaster.class);
+    }
+
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        asyncSession = daoSession.startAsyncSession();
+        asyncSession.setListener(this);
+        completedOperations = new CopyOnWriteArrayList<AsyncOperation>();
+    }
+
+    public void assertWaitForCompletion1Sec() {
+        assertTrue(asyncSession.waitForCompletion(1000));
+        assertTrue(asyncSession.isCompleted());
+    }
+
+    @Override
+    public void onAsyncOperationCompleted(AsyncOperation operation) {
+        completedOperations.add(operation);
+    }
+
+    protected void assertSingleOperationCompleted(AsyncOperation operation) {
+        assertSame(operation, completedOperations.get(0));
+        assertEquals(1, completedOperations.size());
+        assertTrue(operation.isCompleted());
+    }
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/async/BasicAsyncTest.java b/DaoTest/src/de/greenrobot/daotest/async/BasicAsyncTest.java
index 5a181ee8..c2d2a516 100644
--- a/DaoTest/src/de/greenrobot/daotest/async/BasicAsyncTest.java
+++ b/DaoTest/src/de/greenrobot/daotest/async/BasicAsyncTest.java
@@ -1,156 +1,181 @@
-package de.greenrobot.daotest.async;
-
-import java.util.concurrent.Callable;
-
-import android.os.Looper;
-import de.greenrobot.dao.async.AsyncDaoException;
-import de.greenrobot.dao.async.AsyncOperation;
-import de.greenrobot.dao.async.AsyncOperationListener;
-import de.greenrobot.daotest.SimpleEntity;
-
-public class BasicAsyncTest extends AbstractAsyncTest {
-
-    Thread txThread;
-    boolean testListenerMainThread_done;
-
-    public void testSequenceNumber() {
-        AsyncOperation op1 = asyncSession.count(SimpleEntity.class);
-        assertEquals(1, op1.getSequenceNumber());
-        AsyncOperation op2 = asyncSession.count(SimpleEntity.class);
-        assertEquals(2, op2.getSequenceNumber());
-    }
-
-    public void testWaitForCompletionNoOps() {
-        assertTrue(asyncSession.isCompleted());
-        assertTrue(asyncSession.waitForCompletion(1));
-        asyncSession.waitForCompletion();
-    }
-
-    public void testAsyncInsert() {
-        SimpleEntity entity = new SimpleEntity();
-        entity.setSimpleString("heho");
-        AsyncOperation operation = asyncSession.insert(entity);
-        assertWaitForCompletion1Sec();
-        SimpleEntity entity2 = daoSession.load(SimpleEntity.class, entity.getId());
-        assertNotNull(entity2);
-        assertEquals("heho", entity2.getSimpleString());
-        assertFalse(operation.isFailed());
-        assertSingleOperationCompleted(operation);
-    }
-
-    public void testAsyncUpdate() {
-        SimpleEntity entity = new SimpleEntity();
-        entity.setSimpleString("heho");
-        daoSession.insert(entity);
-        entity.setSimpleString("updated");
-        AsyncOperation operation = asyncSession.update(entity);
-        assertWaitForCompletion1Sec();
-        daoSession.clear();
-        SimpleEntity entity2 = daoSession.load(SimpleEntity.class, entity.getId());
-        assertNotNull(entity2);
-        assertEquals("updated", entity2.getSimpleString());
-        assertFalse(operation.isFailed());
-        assertSingleOperationCompleted(operation);
-    }
-
-    public void testOperationGetResult() {
-        SimpleEntity entity = new SimpleEntity();
-        entity.setSimpleString("heho");
-        daoSession.insert(entity);
-        daoSession.clear();
-
-        AsyncOperation operation = asyncSession.load(SimpleEntity.class, entity.getId());
-        SimpleEntity result = (SimpleEntity) operation.getResult();
-        assertTrue(operation.isCompleted());
-        assertTrue(operation.isCompletedSucessfully());
-        assertNotNull(result);
-        assertNotSame(entity, result);
-        assertEquals(entity.getId(), result.getId());
-        assertEquals(entity.getSimpleString(), result.getSimpleString());
-    }
-
-    public void testOperationGetResultException() {
-        SimpleEntity entity = new SimpleEntity();
-        daoSession.insert(entity);
-        AsyncOperation operation = asyncSession.insert(entity);
-        try {
-            operation.getResult();
-            fail("getResult should have thrown");
-        } catch (AsyncDaoException expected) {
-            // OK
-        }
-        assertTrue(operation.isCompleted());
-        assertFalse(operation.isCompletedSucessfully());
-        assertTrue(operation.isFailed());
-    }
-
-    public void testAsyncException() {
-        SimpleEntity entity = new SimpleEntity();
-        daoSession.insert(entity);
-        AsyncOperation operation = asyncSession.insert(entity);
-        assertWaitForCompletion1Sec();
-        assertSingleOperationCompleted(operation);
-
-        assertTrue(operation.isFailed());
-        assertNotNull(operation.getThrowable());
-    }
-
-    public void testAsyncOperationWaitMillis() {
-        AsyncOperation operation = asyncSession.insert(new SimpleEntity());
-        assertTrue(asyncSession.waitForCompletion(1000));
-        assertSingleOperationCompleted(operation);
-    }
-
-    public void testAsyncOperationWait() {
-        AsyncOperation operation = asyncSession.insert(new SimpleEntity());
-        asyncSession.waitForCompletion();
-        assertSingleOperationCompleted(operation);
-    }
-
-    public void testAsyncRunInTx() {
-        AsyncOperation operation = asyncSession.runInTx(new Runnable() {
-
-            @Override
-            public void run() {
-                txThread = Thread.currentThread();
-            }
-        });
-        assertWaitForCompletion1Sec();
-        assertSingleOperationCompleted(operation);
-        assertNotNull(txThread);
-        assertFalse(Thread.currentThread().equals(txThread));
-    }
-
-    public void testAsynCallInTx() {
-        AsyncOperation operation = asyncSession.callInTx(new Callable<String>() {
-
-            @Override
-            public String call() throws Exception {
-                txThread = Thread.currentThread();
-                return "OK";
-            }
-        });
-        assertEquals("OK", operation.waitForCompletion());
-        assertNotNull(txThread);
-        assertFalse(Thread.currentThread().equals(txThread));
-    }
-
-    public void testListenerMainThread() throws InterruptedException {
-        AsyncOperationListener listener = new AsyncOperationListener() {
-            @Override
-            public synchronized void onAsyncOperationCompleted(AsyncOperation operation) {
-                assertEquals(Looper.getMainLooper(), Looper.myLooper());
-                testListenerMainThread_done = true;
-                notifyAll();
-            }
-        };
-        asyncSession.setListenerMainThread(listener);
-        asyncSession.insert(new SimpleEntity());
-        assertWaitForCompletion1Sec();
-        while (!testListenerMainThread_done) {
-            synchronized (listener) {
-                listener.wait();
-            }
-        }
-    }
-}
+package de.greenrobot.daotest.async;
+
+import java.util.concurrent.Callable;
+
+import android.os.Looper;
+import de.greenrobot.dao.async.AsyncDaoException;
+import de.greenrobot.dao.async.AsyncOperation;
+import de.greenrobot.dao.async.AsyncOperationListener;
+import de.greenrobot.daotest.SimpleEntity;
+
+public class BasicAsyncTest extends AbstractAsyncTest {
+
+    Thread txThread;
+    boolean testListenerMainThread_done;
+
+    public void testSequenceNumber() {
+        AsyncOperation op1 = asyncSession.count(SimpleEntity.class);
+        assertEquals(1, op1.getSequenceNumber());
+        AsyncOperation op2 = asyncSession.count(SimpleEntity.class);
+        assertEquals(2, op2.getSequenceNumber());
+    }
+
+    public void testWaitForCompletionNoOps() {
+        assertTrue(asyncSession.isCompleted());
+        assertTrue(asyncSession.waitForCompletion(1));
+        asyncSession.waitForCompletion();
+    }
+
+    public void testAsyncInsert() {
+        SimpleEntity entity = new SimpleEntity();
+        entity.setSimpleString("heho");
+        AsyncOperation operation = asyncSession.insert(entity);
+        assertWaitForCompletion1Sec();
+        SimpleEntity entity2 = daoSession.load(SimpleEntity.class, entity.getId());
+        assertNotNull(entity2);
+        assertEquals("heho", entity2.getSimpleString());
+        assertFalse(operation.isFailed());
+        assertSingleOperationCompleted(operation);
+    }
+
+    public void testAsyncUpdate() {
+        SimpleEntity entity = new SimpleEntity();
+        entity.setSimpleString("heho");
+        daoSession.insert(entity);
+        entity.setSimpleString("updated");
+        AsyncOperation operation = asyncSession.update(entity);
+        assertWaitForCompletion1Sec();
+        daoSession.clear();
+        SimpleEntity entity2 = daoSession.load(SimpleEntity.class, entity.getId());
+        assertNotNull(entity2);
+        assertEquals("updated", entity2.getSimpleString());
+        assertFalse(operation.isFailed());
+        assertSingleOperationCompleted(operation);
+    }
+
+    public void testOperationGetResult() {
+        SimpleEntity entity = new SimpleEntity();
+        entity.setSimpleString("heho");
+        daoSession.insert(entity);
+        daoSession.clear();
+
+        AsyncOperation operation = asyncSession.load(SimpleEntity.class, entity.getId());
+        SimpleEntity result = (SimpleEntity) operation.getResult();
+        assertTrue(operation.isCompleted());
+        assertTrue(operation.isCompletedSucessfully());
+        assertNotNull(result);
+        assertNotSame(entity, result);
+        assertEquals(entity.getId(), result.getId());
+        assertEquals(entity.getSimpleString(), result.getSimpleString());
+    }
+
+    public void testOperationGetResultException() {
+        SimpleEntity entity = new SimpleEntity();
+        daoSession.insert(entity);
+        AsyncOperation operation = asyncSession.insert(entity);
+        try {
+            operation.getResult();
+            fail("getResult should have thrown");
+        } catch (AsyncDaoException expected) {
+            // OK
+        }
+        assertTrue(operation.isCompleted());
+        assertFalse(operation.isCompletedSucessfully());
+        assertTrue(operation.isFailed());
+    }
+
+    public void testAsyncException() {
+        SimpleEntity entity = new SimpleEntity();
+        daoSession.insert(entity);
+        AsyncOperation operation = asyncSession.insert(entity);
+        assertWaitForCompletion1Sec();
+        assertSingleOperationCompleted(operation);
+
+        assertTrue(operation.isFailed());
+        assertNotNull(operation.getThrowable());
+    }
+
+    public void testAsyncExceptionCreator() {
+        SimpleEntity entity = new SimpleEntity();
+        daoSession.insert(entity);
+        AsyncOperation operation = asyncSession.insert(entity);
+        assertWaitForCompletion1Sec();
+        assertNull(operation.getCreatorStacktrace());
+
+        operation = asyncSession.insert(entity, AsyncOperation.FLAG_TRACK_CREATOR_STACKTRACE);
+        assertWaitForCompletion1Sec();
+        assertNotNull(operation.getCreatorStacktrace());
+
+        asyncSession.setSessionFlags(AsyncOperation.FLAG_TRACK_CREATOR_STACKTRACE);
+        operation = asyncSession.insert(entity);
+        assertWaitForCompletion1Sec();
+        assertNotNull(operation.getCreatorStacktrace());
+        StackTraceElement[] stack = operation.getCreatorStacktrace().getStackTrace();
+        boolean found = false;
+        for (StackTraceElement stackTraceElement : stack) {
+            found |= stackTraceElement.getClassName().equals(getClass().getName());
+        }
+        assertTrue(found);
+    }
+
+    public void testAsyncOperationWaitMillis() {
+        AsyncOperation operation = asyncSession.insert(new SimpleEntity());
+        assertTrue(asyncSession.waitForCompletion(1000));
+        assertSingleOperationCompleted(operation);
+    }
+
+    public void testAsyncOperationWait() {
+        AsyncOperation operation = asyncSession.insert(new SimpleEntity());
+        asyncSession.waitForCompletion();
+        assertSingleOperationCompleted(operation);
+    }
+
+    public void testAsyncRunInTx() {
+        AsyncOperation operation = asyncSession.runInTx(new Runnable() {
+
+            @Override
+            public void run() {
+                txThread = Thread.currentThread();
+            }
+        });
+        assertWaitForCompletion1Sec();
+        assertSingleOperationCompleted(operation);
+        assertNotNull(txThread);
+        assertFalse(Thread.currentThread().equals(txThread));
+    }
+
+    public void testAsynCallInTx() {
+        AsyncOperation operation = asyncSession.callInTx(new Callable<String>() {
+
+            @Override
+            public String call() throws Exception {
+                txThread = Thread.currentThread();
+                return "OK";
+            }
+        });
+        assertEquals("OK", operation.waitForCompletion());
+        assertNotNull(txThread);
+        assertFalse(Thread.currentThread().equals(txThread));
+    }
+
+    public void testListenerMainThread() throws InterruptedException {
+        AsyncOperationListener listener = new AsyncOperationListener() {
+            @Override
+            public synchronized void onAsyncOperationCompleted(AsyncOperation operation) {
+                assertEquals(Looper.getMainLooper(), Looper.myLooper());
+                testListenerMainThread_done = true;
+                notifyAll();
+            }
+        };
+        asyncSession.setListenerMainThread(listener);
+        asyncSession.insert(new SimpleEntity());
+        assertWaitForCompletion1Sec();
+        while (!testListenerMainThread_done) {
+            synchronized (listener) {
+                listener.wait();
+            }
+        }
+    }
+
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/async/MergeTxAsyncTest.java b/DaoTest/src/de/greenrobot/daotest/async/MergeTxAsyncTest.java
index c307e914..b22958a9 100644
--- a/DaoTest/src/de/greenrobot/daotest/async/MergeTxAsyncTest.java
+++ b/DaoTest/src/de/greenrobot/daotest/async/MergeTxAsyncTest.java
@@ -1,30 +1,30 @@
-package de.greenrobot.daotest.async;
-
-import de.greenrobot.dao.async.AsyncOperation;
-import de.greenrobot.daotest.SimpleEntity;
-
-public class MergeTxAsyncTest extends AbstractAsyncTest {
-
-    public void testMergeInsertAndUpdate() {
-        SimpleEntity entity = new SimpleEntity();
-        entity.setId(42l);
-        entity.setSimpleString("heho");
-        
-        SimpleEntity entity2 = new SimpleEntity();
-        entity2.setId(42l);
-        entity2.setSimpleString("updated");
-        
-        AsyncOperation op1 = asyncSession.insert(entity, AsyncOperation.FLAG_MERGE_TX);
-        AsyncOperation op2 = asyncSession.update(entity2, AsyncOperation.FLAG_MERGE_TX);
-        
-        assertWaitForCompletion1Sec();
-        daoSession.clear();
-        SimpleEntity entity3 = daoSession.load(SimpleEntity.class, 42l);
-        assertNotNull(entity3);
-        assertEquals(entity2.getSimpleString(), entity3.getSimpleString());
-        
-        assertEquals(2, op1.getMergedOperationsCount());
-        assertEquals(2, op2.getMergedOperationsCount());
-    }
-
-}
+package de.greenrobot.daotest.async;
+
+import de.greenrobot.dao.async.AsyncOperation;
+import de.greenrobot.daotest.SimpleEntity;
+
+public class MergeTxAsyncTest extends AbstractAsyncTest {
+
+    public void testMergeInsertAndUpdate() {
+        SimpleEntity entity = new SimpleEntity();
+        entity.setId(42l);
+        entity.setSimpleString("heho");
+        
+        SimpleEntity entity2 = new SimpleEntity();
+        entity2.setId(42l);
+        entity2.setSimpleString("updated");
+        
+        AsyncOperation op1 = asyncSession.insert(entity, AsyncOperation.FLAG_MERGE_TX);
+        AsyncOperation op2 = asyncSession.update(entity2, AsyncOperation.FLAG_MERGE_TX);
+        
+        assertWaitForCompletion1Sec();
+        daoSession.clear();
+        SimpleEntity entity3 = daoSession.load(SimpleEntity.class, 42l);
+        assertNotNull(entity3);
+        assertEquals(entity2.getSimpleString(), entity3.getSimpleString());
+        
+        assertEquals(2, op1.getMergedOperationsCount());
+        assertEquals(2, op2.getMergedOperationsCount());
+    }
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/contentprovider/SimpleEntityContentProviderTest.java b/DaoTest/src/de/greenrobot/daotest/contentprovider/SimpleEntityContentProviderTest.java
index 1cd76794..d66bfa5a 100644
--- a/DaoTest/src/de/greenrobot/daotest/contentprovider/SimpleEntityContentProviderTest.java
+++ b/DaoTest/src/de/greenrobot/daotest/contentprovider/SimpleEntityContentProviderTest.java
@@ -1,69 +1,69 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daotest.contentprovider;
-
-import android.database.Cursor;
-import android.test.suitebuilder.annotation.Suppress;
-
-import de.greenrobot.dao.test.AbstractDaoSessionTest;
-import de.greenrobot.daotest.DaoMaster;
-import de.greenrobot.daotest.DaoSession;
-import de.greenrobot.daotest.SimpleEntity;
-import de.greenrobot.daotest.SimpleEntityContentProvider;
-import de.greenrobot.daotest.SimpleEntityDao;
-
-@Suppress
-// TODO Activate once the gradle build is fixed (AndroidManifest.xml is not used for instrumentTest)
-public class SimpleEntityContentProviderTest extends AbstractDaoSessionTest<DaoMaster, DaoSession> {
-
-    public SimpleEntityContentProviderTest() {
-        super(DaoMaster.class);
-    }
-
-    @Override
-    protected void setUp() throws Exception {
-        super.setUp();
-        SimpleEntityContentProvider.daoSession = daoSession;
-    }
-
-    public void testQuery() {
-        SimpleEntity entity = new SimpleEntity();
-        entity.setSimpleString("hello");
-        daoSession.insert(entity);
-        long id = entity.getId();
-
-        SimpleEntity entity2 = new SimpleEntity();
-        entity2.setSimpleString("content");
-        daoSession.insert(entity2);
-        long id2 = entity2.getId();
-        Cursor cursor = getContext().getContentResolver().query(SimpleEntityContentProvider.CONTENT_URI, null,
-                null, null, "_id");
-        assertEquals(2, cursor.getCount());
-        int idxId = cursor.getColumnIndexOrThrow(SimpleEntityDao.Properties.Id.columnName);
-        int idxString = cursor.getColumnIndexOrThrow(SimpleEntityDao.Properties.SimpleString.columnName);
-
-        assertTrue(cursor.moveToFirst());
-        assertEquals("hello", cursor.getString(idxString));
-        assertEquals(id, cursor.getLong(idxId));
-
-        assertTrue(cursor.moveToNext());
-        assertEquals("content", cursor.getString(idxString));
-        assertEquals(id2, cursor.getLong(idxId));
-    }
-
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.contentprovider;
+
+import android.database.Cursor;
+import android.test.suitebuilder.annotation.Suppress;
+
+import de.greenrobot.dao.test.AbstractDaoSessionTest;
+import de.greenrobot.daotest.DaoMaster;
+import de.greenrobot.daotest.DaoSession;
+import de.greenrobot.daotest.SimpleEntity;
+import de.greenrobot.daotest.SimpleEntityContentProvider;
+import de.greenrobot.daotest.SimpleEntityDao;
+
+@Suppress
+// TODO Activate once the gradle build is fixed (AndroidManifest.xml is not used for instrumentTest)
+public class SimpleEntityContentProviderTest extends AbstractDaoSessionTest<DaoMaster, DaoSession> {
+
+    public SimpleEntityContentProviderTest() {
+        super(DaoMaster.class);
+    }
+
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        SimpleEntityContentProvider.daoSession = daoSession;
+    }
+
+    public void testQuery() {
+        SimpleEntity entity = new SimpleEntity();
+        entity.setSimpleString("hello");
+        daoSession.insert(entity);
+        long id = entity.getId();
+
+        SimpleEntity entity2 = new SimpleEntity();
+        entity2.setSimpleString("content");
+        daoSession.insert(entity2);
+        long id2 = entity2.getId();
+        Cursor cursor = getContext().getContentResolver().query(SimpleEntityContentProvider.CONTENT_URI, null,
+                null, null, "_id");
+        assertEquals(2, cursor.getCount());
+        int idxId = cursor.getColumnIndexOrThrow(SimpleEntityDao.Properties.Id.columnName);
+        int idxString = cursor.getColumnIndexOrThrow(SimpleEntityDao.Properties.SimpleString.columnName);
+
+        assertTrue(cursor.moveToFirst());
+        assertEquals("hello", cursor.getString(idxString));
+        assertEquals(id, cursor.getLong(idxId));
+
+        assertTrue(cursor.moveToNext());
+        assertEquals("content", cursor.getString(idxString));
+        assertEquals(id2, cursor.getLong(idxId));
+    }
+
 }
\ No newline at end of file
diff --git a/DaoTest/src/de/greenrobot/daotest/customtype/IntegerListConverter.java b/DaoTest/src/de/greenrobot/daotest/customtype/IntegerListConverter.java
new file mode 100644
index 00000000..98a72442
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/customtype/IntegerListConverter.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2011-2015 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.daotest.customtype;
+
+import de.greenrobot.dao.converter.PropertyConverter;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Just a sketch how an embedded List could be done using PropertyConverter. Usually, doing a separate table is
+ * preferred because the values can be indexed and queried for.
+ */
+public class IntegerListConverter implements PropertyConverter<List<Integer>, byte[]> {
+    @Override
+    public List<Integer> convertToEntityProperty(byte[] databaseValue) {
+        if (databaseValue == null) {
+            return null;
+        }
+        if (databaseValue.length % 4 != 0) {
+            throw new RuntimeException("Length must be dividable by 4, but is " + databaseValue.length);
+        }
+        ArrayList<Integer> list = new ArrayList<Integer>(databaseValue.length / 4);
+        for (int i = 0; i < databaseValue.length; i += 4) {
+            int intValue = getIntBE(databaseValue, i);
+            list.add(intValue);
+        }
+
+        return list;
+    }
+
+    @Override
+    public byte[] convertToDatabaseValue(List<Integer> entityProperty) {
+        if (entityProperty == null) {
+            return null;
+        }
+        byte[] bytes = new byte[entityProperty.size() * 4];
+        for (Integer integer : entityProperty) {
+            // TODO
+        }
+        return bytes;
+
+    }
+
+    public int getIntBE(byte[] bytes, int index) {
+        return (bytes[index + 3] & 0xff) | ((bytes[index + 2] & 0xff) << 8) |
+                ((bytes[index + 1] & 0xff) << 16) | (bytes[index] << 24);
+    }
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/customtype/MyTimestamp.java b/DaoTest/src/de/greenrobot/daotest/customtype/MyTimestamp.java
new file mode 100644
index 00000000..470185c5
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/customtype/MyTimestamp.java
@@ -0,0 +1,5 @@
+package de.greenrobot.daotest.customtype;
+
+public class MyTimestamp {
+    public long timestamp;
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/customtype/MyTimestampConverter.java b/DaoTest/src/de/greenrobot/daotest/customtype/MyTimestampConverter.java
new file mode 100644
index 00000000..c96d1cf4
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/customtype/MyTimestampConverter.java
@@ -0,0 +1,17 @@
+package de.greenrobot.daotest.customtype;
+
+import de.greenrobot.dao.converter.PropertyConverter;
+
+public class MyTimestampConverter implements PropertyConverter<MyTimestamp, Long> {
+    @Override
+    public MyTimestamp convertToEntityProperty(Long databaseValue) {
+        MyTimestamp myTimestamp = new MyTimestamp();
+        myTimestamp.timestamp=databaseValue;
+        return myTimestamp;
+    }
+
+    @Override
+    public Long convertToDatabaseValue(MyTimestamp entityProperty) {
+        return entityProperty.timestamp;
+    }
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/AbcdefEntityTest.java b/DaoTest/src/de/greenrobot/daotest/entity/AbcdefEntityTest.java
index d68dcef5..e2797471 100644
--- a/DaoTest/src/de/greenrobot/daotest/entity/AbcdefEntityTest.java
+++ b/DaoTest/src/de/greenrobot/daotest/entity/AbcdefEntityTest.java
@@ -1,37 +1,37 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daotest.entity;
-
-import de.greenrobot.dao.test.AbstractDaoTestLongPk;
-import de.greenrobot.daotest.AbcdefEntity;
-import de.greenrobot.daotest.AbcdefEntityDao;
-
-public class AbcdefEntityTest extends AbstractDaoTestLongPk<AbcdefEntityDao, AbcdefEntity> {
-
-    public AbcdefEntityTest() {
-        super(AbcdefEntityDao.class);
-    }
-
-    @Override
-    protected AbcdefEntity createEntity(Long key) {
-        AbcdefEntity entity = new AbcdefEntity();
-        entity.setId(key);
-        return entity;
-    }
-
-}
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.entity;
+
+import de.greenrobot.dao.test.AbstractDaoTestLongPk;
+import de.greenrobot.daotest.AbcdefEntity;
+import de.greenrobot.daotest.AbcdefEntityDao;
+
+public class AbcdefEntityTest extends AbstractDaoTestLongPk<AbcdefEntityDao, AbcdefEntity> {
+
+    public AbcdefEntityTest() {
+        super(AbcdefEntityDao.class);
+    }
+
+    @Override
+    protected AbcdefEntity createEntity(Long key) {
+        AbcdefEntity entity = new AbcdefEntity();
+        entity.setId(key);
+        return entity;
+    }
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/AnActiveEntityTest.java b/DaoTest/src/de/greenrobot/daotest/entity/AnActiveEntityTest.java
index c8112b8c..ddb9398f 100644
--- a/DaoTest/src/de/greenrobot/daotest/entity/AnActiveEntityTest.java
+++ b/DaoTest/src/de/greenrobot/daotest/entity/AnActiveEntityTest.java
@@ -1,96 +1,96 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daotest.entity;
-
-import de.greenrobot.dao.DaoException;
-import de.greenrobot.dao.test.AbstractDaoSessionTest;
-import de.greenrobot.daotest.AnActiveEntity;
-import de.greenrobot.daotest.AnActiveEntityDao;
-import de.greenrobot.daotest.DaoMaster;
-import de.greenrobot.daotest.DaoSession;
-
-public class AnActiveEntityTest extends AbstractDaoSessionTest<DaoMaster, DaoSession> {
-
-    private AnActiveEntityDao dao;
-
-    public AnActiveEntityTest() {
-        super(DaoMaster.class);
-    }
-
-    @Override
-    protected void setUp() throws Exception {
-        super.setUp();
-        dao = daoSession.getAnActiveEntityDao();
-    }
-
-    public void testThrowWhenDetached() {
-        AnActiveEntity entity = new AnActiveEntity();
-        try {
-            entity.delete();
-            fail("Should fail for detached entity");
-        } catch (DaoException e) {
-            // OK, expected
-        }
-        try {
-            entity.refresh();
-            fail("Should fail for detached entity");
-        } catch (DaoException e) {
-            // OK, expected
-        }
-        try {
-            entity.update();
-            fail("Should fail for detached entity");
-        } catch (DaoException e) {
-            // OK, expected
-        }
-    }
-
-    public void testActiveUpdate() {
-        AnActiveEntity entity = new AnActiveEntity(1l);
-        long rowId = dao.insert(entity);
-
-        entity.setText("NEW");
-        entity.update();
-
-        daoSession.clear();
-        AnActiveEntity entity2 = dao.load(rowId);
-        assertNotSame(entity, entity2);
-        assertEquals("NEW", entity2.getText());
-    }
-
-    public void testActiveRefresh() {
-        AnActiveEntity entity = new AnActiveEntity(1l);
-        dao.insert(entity);
-
-        AnActiveEntity entity2 = new AnActiveEntity(1l);
-        entity2.setText("NEW");
-        dao.update(entity2);
-
-        entity.refresh();
-        assertEquals("NEW", entity.getText());
-    }
-
-    public void testActiveDelete() {
-        AnActiveEntity entity = new AnActiveEntity(1l);
-        dao.insert(entity);
-
-        entity.delete();
-        assertNull(dao.load(1l));
-    }
-
-}
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.entity;
+
+import de.greenrobot.dao.DaoException;
+import de.greenrobot.dao.test.AbstractDaoSessionTest;
+import de.greenrobot.daotest.AnActiveEntity;
+import de.greenrobot.daotest.AnActiveEntityDao;
+import de.greenrobot.daotest.DaoMaster;
+import de.greenrobot.daotest.DaoSession;
+
+public class AnActiveEntityTest extends AbstractDaoSessionTest<DaoMaster, DaoSession> {
+
+    private AnActiveEntityDao dao;
+
+    public AnActiveEntityTest() {
+        super(DaoMaster.class);
+    }
+
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        dao = daoSession.getAnActiveEntityDao();
+    }
+
+    public void testThrowWhenDetached() {
+        AnActiveEntity entity = new AnActiveEntity();
+        try {
+            entity.delete();
+            fail("Should fail for detached entity");
+        } catch (DaoException e) {
+            // OK, expected
+        }
+        try {
+            entity.refresh();
+            fail("Should fail for detached entity");
+        } catch (DaoException e) {
+            // OK, expected
+        }
+        try {
+            entity.update();
+            fail("Should fail for detached entity");
+        } catch (DaoException e) {
+            // OK, expected
+        }
+    }
+
+    public void testActiveUpdate() {
+        AnActiveEntity entity = new AnActiveEntity(1l);
+        long rowId = dao.insert(entity);
+
+        entity.setText("NEW");
+        entity.update();
+
+        daoSession.clear();
+        AnActiveEntity entity2 = dao.load(rowId);
+        assertNotSame(entity, entity2);
+        assertEquals("NEW", entity2.getText());
+    }
+
+    public void testActiveRefresh() {
+        AnActiveEntity entity = new AnActiveEntity(1l);
+        dao.insert(entity);
+
+        AnActiveEntity entity2 = new AnActiveEntity(1l);
+        entity2.setText("NEW");
+        dao.update(entity2);
+
+        entity.refresh();
+        assertEquals("NEW", entity.getText());
+    }
+
+    public void testActiveDelete() {
+        AnActiveEntity entity = new AnActiveEntity(1l);
+        dao.insert(entity);
+
+        entity.delete();
+        assertNull(dao.load(1l));
+    }
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/AutoincrementEntityTest.java b/DaoTest/src/de/greenrobot/daotest/entity/AutoincrementEntityTest.java
index fbff5349..2be68193 100644
--- a/DaoTest/src/de/greenrobot/daotest/entity/AutoincrementEntityTest.java
+++ b/DaoTest/src/de/greenrobot/daotest/entity/AutoincrementEntityTest.java
@@ -1,39 +1,39 @@
-package de.greenrobot.daotest.entity;
-
-import de.greenrobot.dao.test.AbstractDaoSessionTest;
-import de.greenrobot.daotest.AutoincrementEntity;
-import de.greenrobot.daotest.DaoMaster;
-import de.greenrobot.daotest.DaoSession;
-import de.greenrobot.daotest.SimpleEntity;
-
-public class AutoincrementEntityTest extends AbstractDaoSessionTest<DaoMaster, DaoSession> {
-
-    public AutoincrementEntityTest() {
-        super(DaoMaster.class);
-    }
-
-    public void testAutoincrement() {
-        AutoincrementEntity entity = new AutoincrementEntity();
-        daoSession.insert(entity);
-        Long id1 = entity.getId();
-        assertNotNull(id1);
-        daoSession.delete(entity);
-
-        AutoincrementEntity entity2 = new AutoincrementEntity();
-        daoSession.insert(entity2);
-        assertEquals(id1 + 1, (long) entity2.getId());
-    }
-
-    public void testNoAutoincrement() {
-        SimpleEntity entity = new SimpleEntity();
-        daoSession.insert(entity);
-        Long id1 = entity.getId();
-        assertNotNull(id1);
-        daoSession.delete(entity);
-
-        SimpleEntity entity2 = new SimpleEntity();
-        daoSession.insert(entity2);
-        assertEquals(id1, entity2.getId());
-    }
-
-}
+package de.greenrobot.daotest.entity;
+
+import de.greenrobot.dao.test.AbstractDaoSessionTest;
+import de.greenrobot.daotest.AutoincrementEntity;
+import de.greenrobot.daotest.DaoMaster;
+import de.greenrobot.daotest.DaoSession;
+import de.greenrobot.daotest.SimpleEntity;
+
+public class AutoincrementEntityTest extends AbstractDaoSessionTest<DaoMaster, DaoSession> {
+
+    public AutoincrementEntityTest() {
+        super(DaoMaster.class);
+    }
+
+    public void testAutoincrement() {
+        AutoincrementEntity entity = new AutoincrementEntity();
+        daoSession.insert(entity);
+        Long id1 = entity.getId();
+        assertNotNull(id1);
+        daoSession.delete(entity);
+
+        AutoincrementEntity entity2 = new AutoincrementEntity();
+        daoSession.insert(entity2);
+        assertEquals(id1 + 1, (long) entity2.getId());
+    }
+
+    public void testNoAutoincrement() {
+        SimpleEntity entity = new SimpleEntity();
+        daoSession.insert(entity);
+        Long id1 = entity.getId();
+        assertNotNull(id1);
+        daoSession.delete(entity);
+
+        SimpleEntity entity2 = new SimpleEntity();
+        daoSession.insert(entity2);
+        assertEquals(id1, entity2.getId());
+    }
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/CustomTypeEntityTest.java b/DaoTest/src/de/greenrobot/daotest/entity/CustomTypeEntityTest.java
new file mode 100644
index 00000000..933035fc
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/entity/CustomTypeEntityTest.java
@@ -0,0 +1,46 @@
+package de.greenrobot.daotest.entity;
+
+import de.greenrobot.dao.test.AbstractDaoTestLongPk;
+import de.greenrobot.daotest.CustomTypeEntity;
+import de.greenrobot.daotest.CustomTypeEntityDao;
+import de.greenrobot.daotest.customtype.MyTimestamp;
+
+import java.util.List;
+
+public class CustomTypeEntityTest extends AbstractDaoTestLongPk<CustomTypeEntityDao, CustomTypeEntity> {
+
+    public CustomTypeEntityTest() {
+        super(CustomTypeEntityDao.class);
+    }
+
+    @Override
+    protected CustomTypeEntity createEntity(Long key) {
+        CustomTypeEntity entity = new CustomTypeEntity();
+        entity.setId(key);
+        MyTimestamp myCustomTimestamp = new MyTimestamp();
+        myCustomTimestamp.timestamp = System.currentTimeMillis();
+        entity.setMyCustomTimestamp(myCustomTimestamp);
+        return entity;
+    }
+
+    public void testCustomTypeValue() {
+        CustomTypeEntity entity = createEntityWithRandomPk();
+        long timestamp = entity.getMyCustomTimestamp().timestamp;
+        dao.insert(entity);
+
+        List<CustomTypeEntity> all = dao.loadAll();
+        assertEquals(1, all.size());
+        assertEquals(timestamp, all.get(0).getMyCustomTimestamp().timestamp);
+    }
+
+    public void testCustomTypeValueNull() {
+        CustomTypeEntity entity = createEntityWithRandomPk();
+        entity.setMyCustomTimestamp(null);
+        dao.insert(entity);
+
+        List<CustomTypeEntity> all = dao.loadAll();
+        assertEquals(1, all.size());
+        assertNull(all.get(0).getMyCustomTimestamp());
+    }
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/DateEntityTest.java b/DaoTest/src/de/greenrobot/daotest/entity/DateEntityTest.java
index 78ef137c..d3a8b21b 100644
--- a/DaoTest/src/de/greenrobot/daotest/entity/DateEntityTest.java
+++ b/DaoTest/src/de/greenrobot/daotest/entity/DateEntityTest.java
@@ -1,65 +1,65 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daotest.entity;
-
-import java.util.Date;
-
-import de.greenrobot.dao.test.AbstractDaoTestLongPk;
-import de.greenrobot.daotest.DateEntity;
-import de.greenrobot.daotest.DateEntityDao;
-
-public class DateEntityTest extends AbstractDaoTestLongPk<DateEntityDao, DateEntity> {
-
-    public DateEntityTest() {
-        super(DateEntityDao.class);
-    }
-
-    @Override
-    protected DateEntity createEntity(Long key) {
-        DateEntity entity = new DateEntity();
-        entity.setId(key);
-        entity.setDateNotNull(new Date());
-        return entity;
-    }
-    
-    public void testValues() {
-        DateEntity entity = createEntity(1l);
-        dao.insert(entity);
-        
-        DateEntity reloaded = dao.load(entity.getId());
-        assertNull(reloaded.getDate());
-        assertNotNull(reloaded.getDateNotNull());
-        assertEquals(entity.getDateNotNull(), reloaded.getDateNotNull());
-    }
-
-    public void testValues2() {
-        DateEntity entity = createEntity(1l);
-        long t1=32479875;
-        long t2=976345942443435235l;
-        entity.setDate(new Date(t1));
-        entity.setDateNotNull(new Date(t2));
-        dao.insert(entity);
-        
-        DateEntity reloaded = dao.load(entity.getId());
-        assertNotNull(reloaded.getDate());
-        assertNotNull(reloaded.getDateNotNull());
-        assertEquals(t1, reloaded.getDate().getTime());
-        assertEquals(t2, reloaded.getDateNotNull().getTime());
-    }
-
-}
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.entity;
+
+import java.util.Date;
+
+import de.greenrobot.dao.test.AbstractDaoTestLongPk;
+import de.greenrobot.daotest.DateEntity;
+import de.greenrobot.daotest.DateEntityDao;
+
+public class DateEntityTest extends AbstractDaoTestLongPk<DateEntityDao, DateEntity> {
+
+    public DateEntityTest() {
+        super(DateEntityDao.class);
+    }
+
+    @Override
+    protected DateEntity createEntity(Long key) {
+        DateEntity entity = new DateEntity();
+        entity.setId(key);
+        entity.setDateNotNull(new Date());
+        return entity;
+    }
+    
+    public void testValues() {
+        DateEntity entity = createEntity(1l);
+        dao.insert(entity);
+        
+        DateEntity reloaded = dao.load(entity.getId());
+        assertNull(reloaded.getDate());
+        assertNotNull(reloaded.getDateNotNull());
+        assertEquals(entity.getDateNotNull(), reloaded.getDateNotNull());
+    }
+
+    public void testValues2() {
+        DateEntity entity = createEntity(1l);
+        long t1=32479875;
+        long t2=976345942443435235l;
+        entity.setDate(new Date(t1));
+        entity.setDateNotNull(new Date(t2));
+        dao.insert(entity);
+        
+        DateEntity reloaded = dao.load(entity.getId());
+        assertNotNull(reloaded.getDate());
+        assertNotNull(reloaded.getDateNotNull());
+        assertEquals(t1, reloaded.getDate().getTime());
+        assertEquals(t2, reloaded.getDateNotNull().getTime());
+    }
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/ExtendsImplementsEntityTest.java b/DaoTest/src/de/greenrobot/daotest/entity/ExtendsImplementsEntityTest.java
index 757bb3eb..3096e7c4 100644
--- a/DaoTest/src/de/greenrobot/daotest/entity/ExtendsImplementsEntityTest.java
+++ b/DaoTest/src/de/greenrobot/daotest/entity/ExtendsImplementsEntityTest.java
@@ -1,32 +1,32 @@
-package de.greenrobot.daotest.entity;
-
-import java.io.Serializable;
-
-import de.greenrobot.dao.test.AbstractDaoTestLongPk;
-import de.greenrobot.daotest.ExtendsImplementsEntity;
-import de.greenrobot.daotest.ExtendsImplementsEntityDao;
-import de.greenrobot.daotest.TestInterface;
-import de.greenrobot.daotest.TestSuperclass;
-
-public class ExtendsImplementsEntityTest extends
-        AbstractDaoTestLongPk<ExtendsImplementsEntityDao, ExtendsImplementsEntity> {
-
-    public ExtendsImplementsEntityTest() {
-        super(ExtendsImplementsEntityDao.class);
-    }
-
-    @Override
-    protected ExtendsImplementsEntity createEntity(Long key) {
-        ExtendsImplementsEntity entity = new ExtendsImplementsEntity();
-        entity.setId(key);
-        return entity;
-    }
-
-    public void testInheritance() {
-        ExtendsImplementsEntity entity = createEntityWithRandomPk();
-        assertTrue(entity instanceof TestSuperclass);
-        assertTrue(entity instanceof TestInterface);
-        assertTrue(entity instanceof Serializable);
-    }
-
-}
+package de.greenrobot.daotest.entity;
+
+import java.io.Serializable;
+
+import de.greenrobot.dao.test.AbstractDaoTestLongPk;
+import de.greenrobot.daotest.ExtendsImplementsEntity;
+import de.greenrobot.daotest.ExtendsImplementsEntityDao;
+import de.greenrobot.daotest.TestInterface;
+import de.greenrobot.daotest.TestSuperclass;
+
+public class ExtendsImplementsEntityTest extends
+        AbstractDaoTestLongPk<ExtendsImplementsEntityDao, ExtendsImplementsEntity> {
+
+    public ExtendsImplementsEntityTest() {
+        super(ExtendsImplementsEntityDao.class);
+    }
+
+    @Override
+    protected ExtendsImplementsEntity createEntity(Long key) {
+        ExtendsImplementsEntity entity = new ExtendsImplementsEntity();
+        entity.setId(key);
+        return entity;
+    }
+
+    public void testInheritance() {
+        ExtendsImplementsEntity entity = createEntityWithRandomPk();
+        assertTrue(entity instanceof TestSuperclass);
+        assertTrue(entity instanceof TestInterface);
+        assertTrue(entity instanceof Serializable);
+    }
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/IndexedStringEntityTest.java b/DaoTest/src/de/greenrobot/daotest/entity/IndexedStringEntityTest.java
new file mode 100644
index 00000000..437de999
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/entity/IndexedStringEntityTest.java
@@ -0,0 +1,21 @@
+package de.greenrobot.daotest.entity;
+
+import de.greenrobot.dao.test.AbstractDaoTestLongPk;
+
+import de.greenrobot.daotest.IndexedStringEntity;
+import de.greenrobot.daotest.IndexedStringEntityDao;
+
+public class IndexedStringEntityTest extends AbstractDaoTestLongPk<IndexedStringEntityDao, IndexedStringEntity> {
+
+    public IndexedStringEntityTest() {
+        super(IndexedStringEntityDao.class);
+    }
+
+    @Override
+    protected IndexedStringEntity createEntity(Long key) {
+        IndexedStringEntity entity = new IndexedStringEntity();
+        entity.setId(key);
+        return entity;
+    }
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/JoinManyToDateEntityTest.java b/DaoTest/src/de/greenrobot/daotest/entity/JoinManyToDateEntityTest.java
new file mode 100644
index 00000000..7ed4e6de
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/entity/JoinManyToDateEntityTest.java
@@ -0,0 +1,21 @@
+package de.greenrobot.daotest.entity;
+
+import de.greenrobot.dao.test.AbstractDaoTestLongPk;
+
+import de.greenrobot.daotest.JoinManyToDateEntity;
+import de.greenrobot.daotest.JoinManyToDateEntityDao;
+
+public class JoinManyToDateEntityTest extends AbstractDaoTestLongPk<JoinManyToDateEntityDao, JoinManyToDateEntity> {
+
+    public JoinManyToDateEntityTest() {
+        super(JoinManyToDateEntityDao.class);
+    }
+
+    @Override
+    protected JoinManyToDateEntity createEntity(Long key) {
+        JoinManyToDateEntity entity = new JoinManyToDateEntity();
+        entity.setId(key);
+        return entity;
+    }
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/SimpleEntityNotNullHelper.java b/DaoTest/src/de/greenrobot/daotest/entity/SimpleEntityNotNullHelper.java
index 9a174bc6..54f2b3c6 100644
--- a/DaoTest/src/de/greenrobot/daotest/entity/SimpleEntityNotNullHelper.java
+++ b/DaoTest/src/de/greenrobot/daotest/entity/SimpleEntityNotNullHelper.java
@@ -1,42 +1,42 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daotest.entity;
-
-import de.greenrobot.daotest.SimpleEntityNotNull;
-
-
-public class SimpleEntityNotNullHelper {
-    public static SimpleEntityNotNull createEntity(Long key) {
-        if (key == null) {
-            return null;
-        }
-        SimpleEntityNotNull entity = new SimpleEntityNotNull();
-        entity.setId(key);
-        entity.setSimpleBoolean(true);
-        entity.setSimpleByte(Byte.MAX_VALUE);
-        entity.setSimpleShort(Short.MAX_VALUE);
-        entity.setSimpleInt(Integer.MAX_VALUE);
-        entity.setSimpleLong(Long.MAX_VALUE);
-        entity.setSimpleFloat(Float.MAX_VALUE);
-        entity.setSimpleDouble(Double.MAX_VALUE);
-        entity.setSimpleString("greenrobot greenDAO");
-        byte[] bytes = { 42, -17, 23, 0, 127, -128 };
-        entity.setSimpleByteArray(bytes);
-        return entity;
-    }
-}
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.entity;
+
+import de.greenrobot.daotest.SimpleEntityNotNull;
+
+
+public class SimpleEntityNotNullHelper {
+    public static SimpleEntityNotNull createEntity(Long key) {
+        if (key == null) {
+            return null;
+        }
+        SimpleEntityNotNull entity = new SimpleEntityNotNull();
+        entity.setId(key);
+        entity.setSimpleBoolean(true);
+        entity.setSimpleByte(Byte.MAX_VALUE);
+        entity.setSimpleShort(Short.MAX_VALUE);
+        entity.setSimpleInt(Integer.MAX_VALUE);
+        entity.setSimpleLong(Long.MAX_VALUE);
+        entity.setSimpleFloat(Float.MAX_VALUE);
+        entity.setSimpleDouble(Double.MAX_VALUE);
+        entity.setSimpleString("greenrobot greenDAO");
+        byte[] bytes = { 42, -17, 23, 0, 127, -128 };
+        entity.setSimpleByteArray(bytes);
+        return entity;
+    }
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/SimpleEntityNotNullTest.java b/DaoTest/src/de/greenrobot/daotest/entity/SimpleEntityNotNullTest.java
index 94299a18..15111b52 100644
--- a/DaoTest/src/de/greenrobot/daotest/entity/SimpleEntityNotNullTest.java
+++ b/DaoTest/src/de/greenrobot/daotest/entity/SimpleEntityNotNullTest.java
@@ -1,81 +1,81 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daotest.entity;
-
-import java.util.Arrays;
-
-import de.greenrobot.dao.test.AbstractDaoTestLongPk;
-import de.greenrobot.daotest.SimpleEntityNotNull;
-import de.greenrobot.daotest.SimpleEntityNotNullDao;
-
-public class SimpleEntityNotNullTest extends AbstractDaoTestLongPk<SimpleEntityNotNullDao, SimpleEntityNotNull> {
-
-    public SimpleEntityNotNullTest() {
-        super(SimpleEntityNotNullDao.class);
-    }
-
-    @Override
-    protected SimpleEntityNotNull createEntity(Long key) {
-        return SimpleEntityNotNullHelper.createEntity(key);
-    }
-
-    public void testValues() {
-        SimpleEntityNotNull entity = createEntity(1l);
-        dao.insert(entity);
-        SimpleEntityNotNull reloaded = dao.load(1l);
-        assertEqualProperties(entity, reloaded);
-    }
-
-    protected static void assertEqualProperties(SimpleEntityNotNull entity, SimpleEntityNotNull reloaded) {
-        assertNotSame(entity, reloaded);
-
-        assertEquals(entity.getId(), reloaded.getId());
-        assertEquals(entity.getSimpleBoolean(), reloaded.getSimpleBoolean());
-        assertEquals(entity.getSimpleDouble(), reloaded.getSimpleDouble());
-        assertEquals(entity.getSimpleFloat(), reloaded.getSimpleFloat());
-        assertEquals(entity.getSimpleLong(), reloaded.getSimpleLong());
-        assertEquals(entity.getSimpleByte(), reloaded.getSimpleByte());
-        assertEquals(entity.getSimpleInt(), reloaded.getSimpleInt());
-        assertEquals(entity.getSimpleShort(), reloaded.getSimpleShort());
-        assertEquals(entity.getSimpleBoolean(), reloaded.getSimpleBoolean());
-        assertEquals(entity.getSimpleString(), reloaded.getSimpleString());
-        assertTrue(Arrays.equals(entity.getSimpleByteArray(), reloaded.getSimpleByteArray()));
-    }
-
-    public void testUpdateValues() {
-        SimpleEntityNotNull entity = createEntity(1l);
-        dao.insert(entity);
-        entity = dao.load(1l);
-
-        entity.setSimpleBoolean(false);
-        entity.setSimpleByte(Byte.MIN_VALUE);
-        entity.setSimpleShort(Short.MIN_VALUE);
-        entity.setSimpleInt(Integer.MIN_VALUE);
-        entity.setSimpleLong(Long.MIN_VALUE);
-        entity.setSimpleFloat(Float.MIN_VALUE);
-        entity.setSimpleDouble(Double.MIN_VALUE);
-        entity.setSimpleString("greenDAO");
-        byte[] bytes = { -1, 0, 1 };
-        entity.setSimpleByteArray(bytes);
-        dao.update(entity);
-
-        SimpleEntityNotNull reloaded = dao.load(1l);
-        assertEqualProperties(entity, reloaded);
-    }
-
-}
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.entity;
+
+import java.util.Arrays;
+
+import de.greenrobot.dao.test.AbstractDaoTestLongPk;
+import de.greenrobot.daotest.SimpleEntityNotNull;
+import de.greenrobot.daotest.SimpleEntityNotNullDao;
+
+public class SimpleEntityNotNullTest extends AbstractDaoTestLongPk<SimpleEntityNotNullDao, SimpleEntityNotNull> {
+
+    public SimpleEntityNotNullTest() {
+        super(SimpleEntityNotNullDao.class);
+    }
+
+    @Override
+    protected SimpleEntityNotNull createEntity(Long key) {
+        return SimpleEntityNotNullHelper.createEntity(key);
+    }
+
+    public void testValues() {
+        SimpleEntityNotNull entity = createEntity(1l);
+        dao.insert(entity);
+        SimpleEntityNotNull reloaded = dao.load(1l);
+        assertEqualProperties(entity, reloaded);
+    }
+
+    protected static void assertEqualProperties(SimpleEntityNotNull entity, SimpleEntityNotNull reloaded) {
+        assertNotSame(entity, reloaded);
+
+        assertEquals(entity.getId(), reloaded.getId());
+        assertEquals(entity.getSimpleBoolean(), reloaded.getSimpleBoolean());
+        assertEquals(entity.getSimpleDouble(), reloaded.getSimpleDouble());
+        assertEquals(entity.getSimpleFloat(), reloaded.getSimpleFloat());
+        assertEquals(entity.getSimpleLong(), reloaded.getSimpleLong());
+        assertEquals(entity.getSimpleByte(), reloaded.getSimpleByte());
+        assertEquals(entity.getSimpleInt(), reloaded.getSimpleInt());
+        assertEquals(entity.getSimpleShort(), reloaded.getSimpleShort());
+        assertEquals(entity.getSimpleBoolean(), reloaded.getSimpleBoolean());
+        assertEquals(entity.getSimpleString(), reloaded.getSimpleString());
+        assertTrue(Arrays.equals(entity.getSimpleByteArray(), reloaded.getSimpleByteArray()));
+    }
+
+    public void testUpdateValues() {
+        SimpleEntityNotNull entity = createEntity(1l);
+        dao.insert(entity);
+        entity = dao.load(1l);
+
+        entity.setSimpleBoolean(false);
+        entity.setSimpleByte(Byte.MIN_VALUE);
+        entity.setSimpleShort(Short.MIN_VALUE);
+        entity.setSimpleInt(Integer.MIN_VALUE);
+        entity.setSimpleLong(Long.MIN_VALUE);
+        entity.setSimpleFloat(Float.MIN_VALUE);
+        entity.setSimpleDouble(Double.MIN_VALUE);
+        entity.setSimpleString("greenDAO");
+        byte[] bytes = { -1, 0, 1 };
+        entity.setSimpleByteArray(bytes);
+        dao.update(entity);
+
+        SimpleEntityNotNull reloaded = dao.load(1l);
+        assertEqualProperties(entity, reloaded);
+    }
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/SimpleEntityTest.java b/DaoTest/src/de/greenrobot/daotest/entity/SimpleEntityTest.java
index 87cc2901..0bb5899a 100644
--- a/DaoTest/src/de/greenrobot/daotest/entity/SimpleEntityTest.java
+++ b/DaoTest/src/de/greenrobot/daotest/entity/SimpleEntityTest.java
@@ -1,134 +1,134 @@
-package de.greenrobot.daotest.entity;
-
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-import java.util.Arrays;
-
-import de.greenrobot.dao.test.AbstractDaoTestLongPk;
-import de.greenrobot.daotest.SimpleEntity;
-import de.greenrobot.daotest.SimpleEntityDao;
-
-public class SimpleEntityTest extends AbstractDaoTestLongPk<SimpleEntityDao, SimpleEntity> {
-
-    public SimpleEntityTest() {
-        super(SimpleEntityDao.class);
-    }
-
-    @Override
-    protected SimpleEntity createEntity(Long key) {
-        SimpleEntity entity = new SimpleEntity();
-        entity.setId(key);
-        return entity;
-    }
-
-    public void testValuesNull() {
-        SimpleEntity entity = createEntity(1l);
-        dao.insert(entity);
-        SimpleEntity reloaded = dao.load(1l);
-        assertNotSame(entity, reloaded);
-
-        assertEquals(entity.getId(), reloaded.getId());
-        assertValuesNull(reloaded);
-    }
-
-    public void testValues() {
-        SimpleEntity entity = createEntity(1l);
-        setValues(entity);
-        dao.insert(entity);
-        SimpleEntity reloaded = dao.load(1l);
-        assertNotSame(entity, reloaded);
-        assertValues(reloaded);
-    }
-
-    public void testUpdateValues() {
-        SimpleEntity entity = createEntity(1l);
-        dao.insert(entity);
-        entity = dao.load(1l);
-        setValues(entity);
-        dao.update(entity);
-        SimpleEntity reloaded = dao.load(1l);
-        assertNotSame(entity, reloaded);
-        assertValues(reloaded);
-    }
-
-    public void testUpdateValuesToNull() {
-        SimpleEntity entity = createEntity(1l);
-        setValues(entity);
-        dao.insert(entity);
-        entity = dao.load(1l);
-        assertValues(entity);
-        setValuesToNull(entity);
-        dao.update(entity);
-        SimpleEntity reloaded = dao.load(1l);
-        assertNotSame(entity, reloaded);
-        assertValuesNull(reloaded);
-    }
-
-    protected void assertValues(SimpleEntity reloaded) {
-        assertEquals(1l, (long) reloaded.getId());
-        assertEquals(true, (boolean) reloaded.getSimpleBoolean());
-        assertEquals(Double.MAX_VALUE, reloaded.getSimpleDouble());
-        assertEquals(Float.MAX_VALUE, reloaded.getSimpleFloat());
-        assertEquals(Long.MAX_VALUE, (long) reloaded.getSimpleLong());
-        assertEquals(Byte.MAX_VALUE, (byte) reloaded.getSimpleByte());
-        assertEquals(Integer.MAX_VALUE, (int) reloaded.getSimpleInt());
-        assertEquals(Short.MAX_VALUE, (short) reloaded.getSimpleShort());
-        assertEquals("greenrobot greenDAO", reloaded.getSimpleString());
-        byte[] bytes = { 42, -17, 23, 0, 127, -128 };
-        assertTrue(Arrays.equals(bytes, reloaded.getSimpleByteArray()));
-    }
-
-    protected void setValues(SimpleEntity entity) {
-        entity.setSimpleBoolean(true);
-        entity.setSimpleByte(Byte.MAX_VALUE);
-        entity.setSimpleShort(Short.MAX_VALUE);
-        entity.setSimpleInt(Integer.MAX_VALUE);
-        entity.setSimpleLong(Long.MAX_VALUE);
-        entity.setSimpleFloat(Float.MAX_VALUE);
-        entity.setSimpleDouble(Double.MAX_VALUE);
-        entity.setSimpleString("greenrobot greenDAO");
-        byte[] bytes = { 42, -17, 23, 0, 127, -128 };
-        entity.setSimpleByteArray(bytes);
-    }
-
-    protected void setValuesToNull(SimpleEntity entity) {
-        entity.setSimpleBoolean(null);
-        entity.setSimpleByte(null);
-        entity.setSimpleShort(null);
-        entity.setSimpleInt(null);
-        entity.setSimpleLong(null);
-        entity.setSimpleFloat(null);
-        entity.setSimpleDouble(null);
-        entity.setSimpleString(null);
-        entity.setSimpleByteArray(null);
-    }
-
-    protected void assertValuesNull(SimpleEntity reloaded) {
-        assertNull(reloaded.getSimpleBoolean());
-        assertNull(reloaded.getSimpleDouble());
-        assertNull(reloaded.getSimpleFloat());
-        assertNull(reloaded.getSimpleLong());
-        assertNull(reloaded.getSimpleByte());
-        assertNull(reloaded.getSimpleInt());
-        assertNull(reloaded.getSimpleShort());
-        assertNull(reloaded.getSimpleBoolean());
-        assertNull(reloaded.getSimpleString());
-        assertNull(reloaded.getSimpleByteArray());
-    }
-
-}
+package de.greenrobot.daotest.entity;
+
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+import java.util.Arrays;
+
+import de.greenrobot.dao.test.AbstractDaoTestLongPk;
+import de.greenrobot.daotest.SimpleEntity;
+import de.greenrobot.daotest.SimpleEntityDao;
+
+public class SimpleEntityTest extends AbstractDaoTestLongPk<SimpleEntityDao, SimpleEntity> {
+
+    public SimpleEntityTest() {
+        super(SimpleEntityDao.class);
+    }
+
+    @Override
+    protected SimpleEntity createEntity(Long key) {
+        SimpleEntity entity = new SimpleEntity();
+        entity.setId(key);
+        return entity;
+    }
+
+    public void testValuesNull() {
+        SimpleEntity entity = createEntity(1l);
+        dao.insert(entity);
+        SimpleEntity reloaded = dao.load(1l);
+        assertNotSame(entity, reloaded);
+
+        assertEquals(entity.getId(), reloaded.getId());
+        assertValuesNull(reloaded);
+    }
+
+    public void testValues() {
+        SimpleEntity entity = createEntity(1l);
+        setValues(entity);
+        dao.insert(entity);
+        SimpleEntity reloaded = dao.load(1l);
+        assertNotSame(entity, reloaded);
+        assertValues(reloaded);
+    }
+
+    public void testUpdateValues() {
+        SimpleEntity entity = createEntity(1l);
+        dao.insert(entity);
+        entity = dao.load(1l);
+        setValues(entity);
+        dao.update(entity);
+        SimpleEntity reloaded = dao.load(1l);
+        assertNotSame(entity, reloaded);
+        assertValues(reloaded);
+    }
+
+    public void testUpdateValuesToNull() {
+        SimpleEntity entity = createEntity(1l);
+        setValues(entity);
+        dao.insert(entity);
+        entity = dao.load(1l);
+        assertValues(entity);
+        setValuesToNull(entity);
+        dao.update(entity);
+        SimpleEntity reloaded = dao.load(1l);
+        assertNotSame(entity, reloaded);
+        assertValuesNull(reloaded);
+    }
+
+    protected void assertValues(SimpleEntity reloaded) {
+        assertEquals(1l, (long) reloaded.getId());
+        assertEquals(true, (boolean) reloaded.getSimpleBoolean());
+        assertEquals(Double.MAX_VALUE, reloaded.getSimpleDouble());
+        assertEquals(Float.MAX_VALUE, reloaded.getSimpleFloat());
+        assertEquals(Long.MAX_VALUE, (long) reloaded.getSimpleLong());
+        assertEquals(Byte.MAX_VALUE, (byte) reloaded.getSimpleByte());
+        assertEquals(Integer.MAX_VALUE, (int) reloaded.getSimpleInt());
+        assertEquals(Short.MAX_VALUE, (short) reloaded.getSimpleShort());
+        assertEquals("greenrobot greenDAO", reloaded.getSimpleString());
+        byte[] bytes = { 42, -17, 23, 0, 127, -128 };
+        assertTrue(Arrays.equals(bytes, reloaded.getSimpleByteArray()));
+    }
+
+    protected void setValues(SimpleEntity entity) {
+        entity.setSimpleBoolean(true);
+        entity.setSimpleByte(Byte.MAX_VALUE);
+        entity.setSimpleShort(Short.MAX_VALUE);
+        entity.setSimpleInt(Integer.MAX_VALUE);
+        entity.setSimpleLong(Long.MAX_VALUE);
+        entity.setSimpleFloat(Float.MAX_VALUE);
+        entity.setSimpleDouble(Double.MAX_VALUE);
+        entity.setSimpleString("greenrobot greenDAO");
+        byte[] bytes = { 42, -17, 23, 0, 127, -128 };
+        entity.setSimpleByteArray(bytes);
+    }
+
+    protected void setValuesToNull(SimpleEntity entity) {
+        entity.setSimpleBoolean(null);
+        entity.setSimpleByte(null);
+        entity.setSimpleShort(null);
+        entity.setSimpleInt(null);
+        entity.setSimpleLong(null);
+        entity.setSimpleFloat(null);
+        entity.setSimpleDouble(null);
+        entity.setSimpleString(null);
+        entity.setSimpleByteArray(null);
+    }
+
+    protected void assertValuesNull(SimpleEntity reloaded) {
+        assertNull(reloaded.getSimpleBoolean());
+        assertNull(reloaded.getSimpleDouble());
+        assertNull(reloaded.getSimpleFloat());
+        assertNull(reloaded.getSimpleLong());
+        assertNull(reloaded.getSimpleByte());
+        assertNull(reloaded.getSimpleInt());
+        assertNull(reloaded.getSimpleShort());
+        assertNull(reloaded.getSimpleBoolean());
+        assertNull(reloaded.getSimpleString());
+        assertNull(reloaded.getSimpleByteArray());
+    }
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/SpecialNamesEntityTest.java b/DaoTest/src/de/greenrobot/daotest/entity/SpecialNamesEntityTest.java
index 4cc7d4f7..35806fef 100644
--- a/DaoTest/src/de/greenrobot/daotest/entity/SpecialNamesEntityTest.java
+++ b/DaoTest/src/de/greenrobot/daotest/entity/SpecialNamesEntityTest.java
@@ -1,37 +1,37 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daotest.entity;
-
-import de.greenrobot.dao.test.AbstractDaoTestLongPk;
-import de.greenrobot.daotest.SpecialNamesEntity;
-import de.greenrobot.daotest.SpecialNamesEntityDao;
-
-public class SpecialNamesEntityTest extends AbstractDaoTestLongPk<SpecialNamesEntityDao, SpecialNamesEntity> {
-
-    public SpecialNamesEntityTest() {
-        super(SpecialNamesEntityDao.class);
-    }
-
-    @Override
-    protected SpecialNamesEntity createEntity(Long key) {
-        SpecialNamesEntity entity = new SpecialNamesEntity();
-        entity.setId(key);
-        return entity;
-    }
-
-}
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.entity;
+
+import de.greenrobot.dao.test.AbstractDaoTestLongPk;
+import de.greenrobot.daotest.SpecialNamesEntity;
+import de.greenrobot.daotest.SpecialNamesEntityDao;
+
+public class SpecialNamesEntityTest extends AbstractDaoTestLongPk<SpecialNamesEntityDao, SpecialNamesEntity> {
+
+    public SpecialNamesEntityTest() {
+        super(SpecialNamesEntityDao.class);
+    }
+
+    @Override
+    protected SpecialNamesEntity createEntity(Long key) {
+        SpecialNamesEntity entity = new SpecialNamesEntity();
+        entity.setId(key);
+        return entity;
+    }
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/SqliteMasterTest.java b/DaoTest/src/de/greenrobot/daotest/entity/SqliteMasterTest.java
index 8cb26bf5..913b6a33 100644
--- a/DaoTest/src/de/greenrobot/daotest/entity/SqliteMasterTest.java
+++ b/DaoTest/src/de/greenrobot/daotest/entity/SqliteMasterTest.java
@@ -1,31 +1,31 @@
-package de.greenrobot.daotest.entity;
-
-import java.util.List;
-
-import de.greenrobot.dao.DaoLog;
-import de.greenrobot.dao.test.AbstractDaoTest;
-import de.greenrobot.daotest.SqliteMaster;
-import de.greenrobot.daotest.SqliteMasterDao;
-import de.greenrobot.daotest.SqliteMasterDao.Properties;
-
-public class SqliteMasterTest extends AbstractDaoTest<SqliteMasterDao, SqliteMaster, Void> {
-
-    public SqliteMasterTest() {
-        super(SqliteMasterDao.class);
-    }
-
-    public void testLoadAll() {
-        List<SqliteMaster> all = dao.loadAll();
-        for (SqliteMaster meta : all) {
-            DaoLog.v(meta.toString());
-        }
-    }
-
-    public void testQueryRaw() {
-        List<SqliteMaster> tables = dao.queryRaw("WHERE " + Properties.Type.columnName + "=?", "table");
-        for (SqliteMaster table : tables) {
-            DaoLog.v(table.toString());
-        }
-    }
-
-}
+package de.greenrobot.daotest.entity;
+
+import java.util.List;
+
+import de.greenrobot.dao.DaoLog;
+import de.greenrobot.dao.test.AbstractDaoTest;
+import de.greenrobot.daotest.SqliteMaster;
+import de.greenrobot.daotest.SqliteMasterDao;
+import de.greenrobot.daotest.SqliteMasterDao.Properties;
+
+public class SqliteMasterTest extends AbstractDaoTest<SqliteMasterDao, SqliteMaster, Void> {
+
+    public SqliteMasterTest() {
+        super(SqliteMasterDao.class);
+    }
+
+    public void testLoadAll() {
+        List<SqliteMaster> all = dao.loadAll();
+        for (SqliteMaster meta : all) {
+            DaoLog.v(meta.toString());
+        }
+    }
+
+    public void testQueryRaw() {
+        List<SqliteMaster> tables = dao.queryRaw("WHERE " + Properties.Type.columnName + "=?", "table");
+        for (SqliteMaster table : tables) {
+            DaoLog.v(table.toString());
+        }
+    }
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/StringKeyValueEntityTest.java b/DaoTest/src/de/greenrobot/daotest/entity/StringKeyValueEntityTest.java
index 30792652..80876125 100644
--- a/DaoTest/src/de/greenrobot/daotest/entity/StringKeyValueEntityTest.java
+++ b/DaoTest/src/de/greenrobot/daotest/entity/StringKeyValueEntityTest.java
@@ -1,31 +1,31 @@
-package de.greenrobot.daotest.entity;
-
-import junit.framework.Assert;
-import de.greenrobot.dao.test.AbstractDaoTestStringPk;
-import de.greenrobot.daotest.StringKeyValueEntity;
-import de.greenrobot.daotest.StringKeyValueEntityDao;
-
-public class StringKeyValueEntityTest extends AbstractDaoTestStringPk<StringKeyValueEntityDao, StringKeyValueEntity> {
-
-    public StringKeyValueEntityTest() {
-        super(StringKeyValueEntityDao.class);
-    }
-
-    @Override
-    protected StringKeyValueEntity createEntity(String key) {
-        StringKeyValueEntity entity = new StringKeyValueEntity();
-        entity.setKey(key);
-        return entity;
-    }
-
-    public void testInsertWithoutPK() {
-        StringKeyValueEntity entity = createEntity(null);
-        try {
-            dao.insert(entity);
-            Assert.fail("Insert without pre-set PK succeeded");
-        } catch (Exception e) {
-            // Expected
-        }
-    }
-
-}
+package de.greenrobot.daotest.entity;
+
+import junit.framework.Assert;
+import de.greenrobot.dao.test.AbstractDaoTestStringPk;
+import de.greenrobot.daotest.StringKeyValueEntity;
+import de.greenrobot.daotest.StringKeyValueEntityDao;
+
+public class StringKeyValueEntityTest extends AbstractDaoTestStringPk<StringKeyValueEntityDao, StringKeyValueEntity> {
+
+    public StringKeyValueEntityTest() {
+        super(StringKeyValueEntityDao.class);
+    }
+
+    @Override
+    protected StringKeyValueEntity createEntity(String key) {
+        StringKeyValueEntity entity = new StringKeyValueEntity();
+        entity.setKey(key);
+        return entity;
+    }
+
+    public void testInsertWithoutPK() {
+        StringKeyValueEntity entity = createEntity(null);
+        try {
+            dao.insert(entity);
+            Assert.fail("Insert without pre-set PK succeeded");
+        } catch (Exception e) {
+            // Expected
+        }
+    }
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/TestEntityIdentityScopeTest.java b/DaoTest/src/de/greenrobot/daotest/entity/TestEntityIdentityScopeTest.java
index 755156cb..10de895c 100644
--- a/DaoTest/src/de/greenrobot/daotest/entity/TestEntityIdentityScopeTest.java
+++ b/DaoTest/src/de/greenrobot/daotest/entity/TestEntityIdentityScopeTest.java
@@ -50,6 +50,17 @@ public void testDetach() {
         assertNotSame(entity, entity3);
     }
 
+    public void testDetachAll() {
+        TestEntity entity1 = createEntity(null);
+        TestEntity entity2 = createEntity(null);
+        dao.insertInTx(entity1, entity2);
+        dao.detachAll();
+        TestEntity entity1a = dao.load(entity1.getId());
+        TestEntity entity2a = dao.load(entity2.getId());
+        assertNotSame(entity1, entity1a);
+        assertNotSame(entity2, entity2a);
+    }
+
     public void testDetachOther() {
         TestEntity entity = createEntity(null);
         dao.insert(entity);
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/TestEntityTest.java b/DaoTest/src/de/greenrobot/daotest/entity/TestEntityTest.java
index 237b9814..2ad04693 100644
--- a/DaoTest/src/de/greenrobot/daotest/entity/TestEntityTest.java
+++ b/DaoTest/src/de/greenrobot/daotest/entity/TestEntityTest.java
@@ -1,67 +1,67 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daotest.entity;
-
-import de.greenrobot.dao.DaoException;
-import de.greenrobot.dao.test.AbstractDaoTestLongPk;
-import de.greenrobot.daotest.TestEntity;
-import de.greenrobot.daotest.TestEntityDao;
-
-public class TestEntityTest extends AbstractDaoTestLongPk<TestEntityDao, TestEntity> {
-
-    public TestEntityTest() {
-        super(TestEntityDao.class);
-    }
-
-    @Override
-    protected TestEntity createEntity(Long key) {
-        TestEntity entity = new TestEntity();
-        entity.setId(key);
-        entity.setSimpleStringNotNull("green");
-        return entity;
-    }
-
-    public void testRefresh() {
-        TestEntity entity = createEntity(1l);
-        entity.setSimpleInteger(42);
-        entity.setSimpleString(null);
-        dao.insert(entity);
-        entity.setSimpleInteger(null);
-        entity.setSimpleString("temp");
-        dao.refresh(entity);
-        assertEquals(42, (int) entity.getSimpleInteger());
-        assertNull(entity.getSimpleString());
-    }
-
-    public void testRefreshIllegal() {
-        TestEntity entity = createEntity(1l);
-        try {
-            dao.refresh(entity);
-            fail("Exception expected");
-        } catch (DaoException expected) {
-        }
-        dao.insert(entity);
-        dao.delete(entity);
-        try {
-            dao.refresh(entity);
-            fail("Exception expected");
-        } catch (DaoException expected) {
-        }
-    }
-
-}
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.entity;
+
+import de.greenrobot.dao.DaoException;
+import de.greenrobot.dao.test.AbstractDaoTestLongPk;
+import de.greenrobot.daotest.TestEntity;
+import de.greenrobot.daotest.TestEntityDao;
+
+public class TestEntityTest extends AbstractDaoTestLongPk<TestEntityDao, TestEntity> {
+
+    public TestEntityTest() {
+        super(TestEntityDao.class);
+    }
+
+    @Override
+    protected TestEntity createEntity(Long key) {
+        TestEntity entity = new TestEntity();
+        entity.setId(key);
+        entity.setSimpleStringNotNull("green");
+        return entity;
+    }
+
+    public void testRefresh() {
+        TestEntity entity = createEntity(1l);
+        entity.setSimpleInteger(42);
+        entity.setSimpleString(null);
+        dao.insert(entity);
+        entity.setSimpleInteger(null);
+        entity.setSimpleString("temp");
+        dao.refresh(entity);
+        assertEquals(42, (int) entity.getSimpleInteger());
+        assertNull(entity.getSimpleString());
+    }
+
+    public void testRefreshIllegal() {
+        TestEntity entity = createEntity(1l);
+        try {
+            dao.refresh(entity);
+            fail("Exception expected");
+        } catch (DaoException expected) {
+        }
+        dao.insert(entity);
+        dao.delete(entity);
+        try {
+            dao.refresh(entity);
+            fail("Exception expected");
+        } catch (DaoException expected) {
+        }
+    }
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/TestEntityTestBase.java b/DaoTest/src/de/greenrobot/daotest/entity/TestEntityTestBase.java
index a6b75a9d..a026ecc8 100644
--- a/DaoTest/src/de/greenrobot/daotest/entity/TestEntityTestBase.java
+++ b/DaoTest/src/de/greenrobot/daotest/entity/TestEntityTestBase.java
@@ -1,72 +1,72 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daotest.entity;
-
-import java.util.ArrayList;
-
-import de.greenrobot.dao.query.LazyList;
-import de.greenrobot.dao.test.AbstractDaoTest;
-import de.greenrobot.daotest.TestEntity;
-import de.greenrobot.daotest.TestEntityDao;
-
-public abstract class TestEntityTestBase extends AbstractDaoTest<TestEntityDao, TestEntity, Long> {
-
-    public TestEntityTestBase() {
-        super(TestEntityDao.class);
-    }
-
-    protected TestEntity createEntity(int simpleInteger, String simpleString) {
-        TestEntity entity = new TestEntity();
-        entity.setId(null);
-        entity.setSimpleStringNotNull("green");
-        entity.setSimpleInteger(simpleInteger);
-        entity.setSimpleString(simpleString);
-        return entity;
-    }
-
-    protected ArrayList<TestEntity> insert(int count) {
-        ArrayList<TestEntity> list = new ArrayList<TestEntity>();
-        for (int i = 0; i < count; i++) {
-            TestEntity entity = createEntity(getSimpleInteger(i), getSimpleString(i));
-            list.add(entity);
-        }
-        dao.insertInTx(list);
-        return list;
-    }
-
-    protected String getSimpleString(int i) {
-        return "String" + (i + 100);
-    }
-
-    protected int getSimpleInteger(int i) {
-        return 100 + i;
-    }
-
-    protected void assertIds(ArrayList<TestEntity> list, LazyList<TestEntity> list2) {
-        for (int i = 0; i < list.size(); i++) {
-            TestEntity entity = list.get(i);
-            TestEntity lazyEntity = list2.get(i);
-            assertIds(entity, lazyEntity);
-        }
-    }
-
-    protected void assertIds(TestEntity entity, TestEntity entity2) {
-        assertEquals(entity.getId(), entity2.getId());
-    }
-
-}
+/*
+ * Copyright (C) 2011-2015 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.entity;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import de.greenrobot.dao.test.AbstractDaoTest;
+import de.greenrobot.daotest.TestEntity;
+import de.greenrobot.daotest.TestEntityDao;
+
+public abstract class TestEntityTestBase extends AbstractDaoTest<TestEntityDao, TestEntity, Long> {
+
+    public TestEntityTestBase() {
+        super(TestEntityDao.class);
+    }
+
+    protected TestEntity createEntity(int simpleInteger, String simpleString) {
+        TestEntity entity = new TestEntity();
+        entity.setId(null);
+        entity.setSimpleStringNotNull("green");
+        entity.setSimpleInteger(simpleInteger);
+        entity.setSimpleString(simpleString);
+        return entity;
+    }
+
+    protected ArrayList<TestEntity> insert(int count) {
+        ArrayList<TestEntity> list = new ArrayList<TestEntity>();
+        for (int i = 0; i < count; i++) {
+            TestEntity entity = createEntity(getSimpleInteger(i), getSimpleString(i));
+            list.add(entity);
+        }
+        dao.insertInTx(list);
+        return list;
+    }
+
+    protected String getSimpleString(int i) {
+        return "String" + (i + 100);
+    }
+
+    protected int getSimpleInteger(int i) {
+        return 100 + i;
+    }
+
+    protected void assertIds(List<TestEntity> list, List<TestEntity> list2) {
+        for (int i = 0; i < list.size(); i++) {
+            TestEntity entity = list.get(i);
+            TestEntity lazyEntity = list2.get(i);
+            assertIds(entity, lazyEntity);
+        }
+    }
+
+    protected void assertIds(TestEntity entity, TestEntity entity2) {
+        assertEquals(entity.getId(), entity2.getId());
+    }
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/ToManyEntityTest.java b/DaoTest/src/de/greenrobot/daotest/entity/ToManyEntityTest.java
index 55fd37bd..592bdddf 100644
--- a/DaoTest/src/de/greenrobot/daotest/entity/ToManyEntityTest.java
+++ b/DaoTest/src/de/greenrobot/daotest/entity/ToManyEntityTest.java
@@ -17,6 +17,7 @@
  */
 package de.greenrobot.daotest.entity;
 
+import java.util.Date;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
@@ -24,6 +25,9 @@
 import de.greenrobot.dao.test.AbstractDaoSessionTest;
 import de.greenrobot.daotest.DaoMaster;
 import de.greenrobot.daotest.DaoSession;
+import de.greenrobot.daotest.DateEntity;
+import de.greenrobot.daotest.DateEntityDao;
+import de.greenrobot.daotest.JoinManyToDateEntity;
 import de.greenrobot.daotest.ToManyEntity;
 import de.greenrobot.daotest.ToManyEntityDao;
 import de.greenrobot.daotest.ToManyTargetEntity;
@@ -62,40 +66,6 @@ public void runTestToManyBasics(long id, int count) {
         assertSameEntities(targetEntities, resolvedToMany);
     }
 
-    private void assertSameEntities(ToManyTargetEntity[] targetEntities, List<ToManyTargetEntity> resolvedToMany) {
-        int count = targetEntities.length;
-        assertEquals(count, resolvedToMany.size());
-
-        Map<Long, ToManyTargetEntity> resolvedMap = new HashMap<Long, ToManyTargetEntity>();
-        for (ToManyTargetEntity resolvedEntity : resolvedToMany) {
-            resolvedMap.put(resolvedEntity.getId(), resolvedEntity);
-        }
-        for (int i = 0; i < count; i++) {
-            long entityId = (long) targetEntities[i].getId();
-            assertTrue("ID=" + entityId, resolvedMap.containsKey(entityId));
-            assertSame(targetEntities[i], resolvedMap.get(entityId));
-        }
-    }
-
-    private ToManyTargetEntity[] prepareToMany(long id, int count) {
-        ToManyEntity entity = new ToManyEntity(id);
-        daoSession.insert(entity);
-        return insertTargetEntitites(id, count, null);
-    }
-
-    private ToManyTargetEntity[] insertTargetEntitites(Long toManyId, int count, String joinProperty) {
-        ToManyTargetEntity[] targetEntities = new ToManyTargetEntity[count];
-        for (int i = 0; i < count; i++) {
-            ToManyTargetEntity target = new ToManyTargetEntity();
-            target.setToManyId(toManyId);
-            target.setToManyIdDesc(toManyId);
-            target.setTargetJoinProperty(joinProperty);
-            targetEntities[i] = target;
-        }
-        toManyTargetEntityDao.insertInTx(targetEntities);
-        return targetEntities;
-    }
-
     public void testGetToManyTwice() {
         prepareToMany(1, 3);
 
@@ -154,7 +124,7 @@ public void testJoinProperty() {
         ToManyEntity entity = new ToManyEntity(1l);
         entity.setSourceJoinProperty("JOIN ME");
         daoSession.insert(entity);
-        insertTargetEntitites(null, 3, "JOIN ME");
+        insertTargetEntities(null, 3, "JOIN ME");
 
         ToManyEntity testEntity = toManyEntityDao.load(1l);
         List<ToManyTargetEntity> targetEntities = testEntity.getToManyByJoinProperty();
@@ -176,7 +146,7 @@ public void testTwoJoinProperty() {
         ToManyEntity entity = new ToManyEntity(1l);
         entity.setSourceJoinProperty("JOIN ME");
         daoSession.insert(entity);
-        insertTargetEntitites(1l, 3, "JOIN ME");
+        insertTargetEntities(1l, 3, "JOIN ME");
 
         ToManyEntity testEntity = toManyEntityDao.load(1l);
         List<ToManyTargetEntity> targetEntities = testEntity.getToManyJoinTwo();
@@ -194,4 +164,66 @@ public void testTwoJoinProperty() {
         assertFalse(middleEntity.getId() == targetEntities.get(1).getId());
     }
 
+    public void testToManyWithJoin() {
+        ToManyEntity entity = new ToManyEntity(1l);
+        daoSession.insert(entity);
+        List<DateEntity> dateEntities = entity.getDateEntityList();
+        assertEquals(0, dateEntities.size());
+
+        DateEntityDao dateDao = daoSession.getDateEntityDao();
+        Date now = new Date();
+        DateEntity date1 = new DateEntity(1L, null, now);
+        DateEntity date2 = new DateEntity(2L, null, now);
+        DateEntity date3 = new DateEntity(3L, null, now);
+        DateEntity date4 = new DateEntity(4L, null, now);
+        dateDao.insertInTx(date1, date2, date3, date4);
+
+        daoSession.insert(new JoinManyToDateEntity(1L,2L,1L));
+        daoSession.insert(new JoinManyToDateEntity(2L,1L,3L));
+        entity.resetDateEntityList();
+        dateEntities = entity.getDateEntityList();
+        assertEquals(1, dateEntities.size());
+        assertEquals(3L, (long) dateEntities.get(0).getId());
+
+        daoSession.insert(new JoinManyToDateEntity(3L, 1L, 4L));
+        entity.resetDateEntityList();
+        dateEntities = entity.getDateEntityList();
+        assertEquals(2, dateEntities.size());
+    }
+
+    private void assertSameEntities(ToManyTargetEntity[] targetEntities, List<ToManyTargetEntity> resolvedToMany) {
+        int count = targetEntities.length;
+        assertEquals(count, resolvedToMany.size());
+
+        Map<Long, ToManyTargetEntity> resolvedMap = new HashMap<Long, ToManyTargetEntity>();
+        for (ToManyTargetEntity resolvedEntity : resolvedToMany) {
+            resolvedMap.put(resolvedEntity.getId(), resolvedEntity);
+        }
+        for (int i = 0; i < count; i++) {
+            long entityId = (long) targetEntities[i].getId();
+            assertTrue("ID=" + entityId, resolvedMap.containsKey(entityId));
+            assertSame(targetEntities[i], resolvedMap.get(entityId));
+        }
+    }
+
+    private ToManyTargetEntity[] prepareToMany(long id, int count) {
+        ToManyEntity entity = new ToManyEntity(id);
+        daoSession.insert(entity);
+        return insertTargetEntities(id, count, null);
+    }
+
+    private ToManyTargetEntity[] insertTargetEntities(Long toManyId, int count, String joinProperty) {
+        ToManyTargetEntity[] targetEntities = new ToManyTargetEntity[count];
+        for (int i = 0; i < count; i++) {
+            ToManyTargetEntity target = new ToManyTargetEntity();
+            target.setToManyId(toManyId);
+            target.setToManyIdDesc(toManyId);
+            target.setTargetJoinProperty(joinProperty);
+            targetEntities[i] = target;
+        }
+        toManyTargetEntityDao.insertInTx(targetEntities);
+        return targetEntities;
+    }
+
+
 }
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/ToManyTargetEntityTest.java b/DaoTest/src/de/greenrobot/daotest/entity/ToManyTargetEntityTest.java
index 7170c14d..b6b806d6 100644
--- a/DaoTest/src/de/greenrobot/daotest/entity/ToManyTargetEntityTest.java
+++ b/DaoTest/src/de/greenrobot/daotest/entity/ToManyTargetEntityTest.java
@@ -1,37 +1,37 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daotest.entity;
-
-import de.greenrobot.dao.test.AbstractDaoTestLongPk;
-import de.greenrobot.daotest.ToManyTargetEntity;
-import de.greenrobot.daotest.ToManyTargetEntityDao;
-
-public class ToManyTargetEntityTest extends AbstractDaoTestLongPk<ToManyTargetEntityDao, ToManyTargetEntity> {
-
-    public ToManyTargetEntityTest() {
-        super(ToManyTargetEntityDao.class);
-    }
-
-    @Override
-    protected ToManyTargetEntity createEntity(Long key) {
-        ToManyTargetEntity entity = new ToManyTargetEntity();
-        entity.setId(key);
-        return entity;
-    }
-
-}
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.entity;
+
+import de.greenrobot.dao.test.AbstractDaoTestLongPk;
+import de.greenrobot.daotest.ToManyTargetEntity;
+import de.greenrobot.daotest.ToManyTargetEntityDao;
+
+public class ToManyTargetEntityTest extends AbstractDaoTestLongPk<ToManyTargetEntityDao, ToManyTargetEntity> {
+
+    public ToManyTargetEntityTest() {
+        super(ToManyTargetEntityDao.class);
+    }
+
+    @Override
+    protected ToManyTargetEntity createEntity(Long key) {
+        ToManyTargetEntity entity = new ToManyTargetEntity();
+        entity.setId(key);
+        return entity;
+    }
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/TreeEntityTest.java b/DaoTest/src/de/greenrobot/daotest/entity/TreeEntityTest.java
index 7f0d43ee..dc09eb9b 100644
--- a/DaoTest/src/de/greenrobot/daotest/entity/TreeEntityTest.java
+++ b/DaoTest/src/de/greenrobot/daotest/entity/TreeEntityTest.java
@@ -1,93 +1,93 @@
-package de.greenrobot.daotest.entity;
-
-import de.greenrobot.dao.test.AbstractDaoSessionTest;
-import de.greenrobot.daotest.DaoMaster;
-import de.greenrobot.daotest.DaoSession;
-import de.greenrobot.daotest.TreeEntity;
-import de.greenrobot.daotest.TreeEntityDao;
-
-public class TreeEntityTest extends AbstractDaoSessionTest<DaoMaster, DaoSession> {
-
-    private TreeEntityDao treeEntityDao;
-
-    public TreeEntityTest() {
-        super(DaoMaster.class);
-    }
-
-    @Override
-    protected void setUp() throws Exception {
-        super.setUp();
-        treeEntityDao = daoSession.getTreeEntityDao();
-    }
-
-    public void testNavigateTreeFromLeaf() {
-        createTree();
-        daoSession.clear();
-
-        TreeEntity child1Child = treeEntityDao.load(101l);
-        assertEquals(0, child1Child.getChildren().size());
-
-        TreeEntity child1 = child1Child.getParent();
-        assertEquals(11l, child1.getId().longValue());
-        assertEquals(1, child1.getChildren().size());
-        assertSame(child1Child, child1.getChildren().get(0));
-
-        TreeEntity root = child1.getParent();
-        assertEquals(1l, root.getId().longValue());
-        assertEquals(2, root.getChildren().size());
-        assertNull(root.getParent());
-    }
-
-    public void testNavigateTreeFromMiddle() {
-        createTree();
-        daoSession.clear();
-
-        TreeEntity child1 = treeEntityDao.load(11l);
-        assertEquals(1, child1.getChildren().size());
-        TreeEntity child1Child = child1.getChildren().get(0);
-        assertEquals(101, child1Child.getId().longValue());
-        assertEquals(0, child1Child.getChildren().size());
-
-        TreeEntity root = child1.getParent();
-        assertEquals(1l, root.getId().longValue());
-        assertEquals(2, root.getChildren().size());
-        assertNull(root.getParent());
-    }
-
-    public void testNavigateTreeFromRoot() {
-        createTree();
-        daoSession.clear();
-
-        TreeEntity root = treeEntityDao.load(1l);
-        assertEquals(2, root.getChildren().size());
-        assertNull(root.getParent());
-
-        TreeEntity child1 = root.getChildren().get(0);
-        TreeEntity child2 = root.getChildren().get(1);
-        if (child1.getId() != 11l) {
-            child1 = child2;
-            child2 = root.getChildren().get(0);
-        }
-
-        assertSame(root, child1.getParent());
-        assertEquals(1, child1.getChildren().size());
-        TreeEntity child1Child = child1.getChildren().get(0);
-        assertEquals(101, child1Child.getId().longValue());
-        assertEquals(0, child1Child.getChildren().size());
-        
-        assertSame(root, child2.getParent());
-        assertEquals(0, child2.getChildren().size());
-    }
-
-    private void createTree() {
-        TreeEntity root = new TreeEntity(1l);
-        TreeEntity child1 = new TreeEntity(11l);
-        child1.setParent(root);
-        TreeEntity child2 = new TreeEntity(12l);
-        child2.setParent(root);
-        TreeEntity child1Child = new TreeEntity(101l);
-        child1Child.setParent(child1);
-        treeEntityDao.insertInTx(root, child1, child2, child1Child);
-    }
-
-}
+package de.greenrobot.daotest.entity;
+
+import de.greenrobot.dao.test.AbstractDaoSessionTest;
+import de.greenrobot.daotest.DaoMaster;
+import de.greenrobot.daotest.DaoSession;
+import de.greenrobot.daotest.TreeEntity;
+import de.greenrobot.daotest.TreeEntityDao;
+
+public class TreeEntityTest extends AbstractDaoSessionTest<DaoMaster, DaoSession> {
+
+    private TreeEntityDao treeEntityDao;
+
+    public TreeEntityTest() {
+        super(DaoMaster.class);
+    }
+
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        treeEntityDao = daoSession.getTreeEntityDao();
+    }
+
+    public void testNavigateTreeFromLeaf() {
+        createTree();
+        daoSession.clear();
+
+        TreeEntity child1Child = treeEntityDao.load(101l);
+        assertEquals(0, child1Child.getChildren().size());
+
+        TreeEntity child1 = child1Child.getParent();
+        assertEquals(11l, child1.getId().longValue());
+        assertEquals(1, child1.getChildren().size());
+        assertSame(child1Child, child1.getChildren().get(0));
+
+        TreeEntity root = child1.getParent();
+        assertEquals(1l, root.getId().longValue());
+        assertEquals(2, root.getChildren().size());
+        assertNull(root.getParent());
+    }
+
+    public void testNavigateTreeFromMiddle() {
+        createTree();
+        daoSession.clear();
+
+        TreeEntity child1 = treeEntityDao.load(11l);
+        assertEquals(1, child1.getChildren().size());
+        TreeEntity child1Child = child1.getChildren().get(0);
+        assertEquals(101, child1Child.getId().longValue());
+        assertEquals(0, child1Child.getChildren().size());
+
+        TreeEntity root = child1.getParent();
+        assertEquals(1l, root.getId().longValue());
+        assertEquals(2, root.getChildren().size());
+        assertNull(root.getParent());
+    }
+
+    public void testNavigateTreeFromRoot() {
+        createTree();
+        daoSession.clear();
+
+        TreeEntity root = treeEntityDao.load(1l);
+        assertEquals(2, root.getChildren().size());
+        assertNull(root.getParent());
+
+        TreeEntity child1 = root.getChildren().get(0);
+        TreeEntity child2 = root.getChildren().get(1);
+        if (child1.getId() != 11l) {
+            child1 = child2;
+            child2 = root.getChildren().get(0);
+        }
+
+        assertSame(root, child1.getParent());
+        assertEquals(1, child1.getChildren().size());
+        TreeEntity child1Child = child1.getChildren().get(0);
+        assertEquals(101, child1Child.getId().longValue());
+        assertEquals(0, child1Child.getChildren().size());
+        
+        assertSame(root, child2.getParent());
+        assertEquals(0, child2.getChildren().size());
+    }
+
+    private void createTree() {
+        TreeEntity root = new TreeEntity(1l);
+        TreeEntity child1 = new TreeEntity(11l);
+        child1.setParent(root);
+        TreeEntity child2 = new TreeEntity(12l);
+        child2.setParent(root);
+        TreeEntity child1Child = new TreeEntity(101l);
+        child1Child.setParent(child1);
+        treeEntityDao.insertInTx(root, child1, child2, child1Child);
+    }
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/performance/IndexedStringPerformanceTest.java b/DaoTest/src/de/greenrobot/daotest/performance/IndexedStringPerformanceTest.java
new file mode 100644
index 00000000..dfb30b63
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/performance/IndexedStringPerformanceTest.java
@@ -0,0 +1,73 @@
+package de.greenrobot.daotest.performance;
+
+import de.greenrobot.dao.DaoLog;
+import de.greenrobot.dao.test.AbstractDaoTest;
+import de.greenrobot.daotest.IndexedStringEntity;
+import de.greenrobot.daotest.IndexedStringEntityDao;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Stores entities with an indexed string property and measures the duration to query them by this
+ * string. The generated strings are in a fixed random sequence. The strings to query for are also
+ * in a fixed random sequence.
+ */
+public class IndexedStringPerformanceTest
+        extends AbstractDaoTest<IndexedStringEntityDao, IndexedStringEntity, Long> {
+
+    private static final int BATCH_SIZE = 10000;
+    private static final int QUERY_COUNT = 1000;
+    private static final int RUNS = 8;
+
+    public IndexedStringPerformanceTest() {
+        super(IndexedStringEntityDao.class, false);
+    }
+
+    public void testIndexedStringEntityQuery() {
+        // disabled for regular builds
+//        DaoLog.d("--------Indexed Queries: Start");
+//        for (int i = 0; i < RUNS; i++) {
+//            DaoLog.d("----Run " + (i + 1) + " of " + RUNS);
+//            doIndexedStringEntityQuery();
+//        }
+//        DaoLog.d("--------Indexed Queries: End");
+    }
+
+    private void doIndexedStringEntityQuery() {
+        // create entities
+        List<IndexedStringEntity> entities = new ArrayList<>(BATCH_SIZE);
+        String[] fixedRandomStrings = StringGenerator.createFixedRandomStrings(BATCH_SIZE);
+        for (int i = 0; i < BATCH_SIZE; i++) {
+            IndexedStringEntity entity = new IndexedStringEntity();
+            entity.setId((long) i);
+            entity.setIndexedString(fixedRandomStrings[i]);
+            entities.add(entity);
+        }
+        DaoLog.d("Built entities.");
+
+        // insert entities
+        dao.insertInTx(entities);
+        DaoLog.d("Inserted entities.");
+
+        // query for entities by indexed string at random
+        int[] randomIndices = StringGenerator.getFixedRandomIndices(QUERY_COUNT, BATCH_SIZE - 1);
+
+        long start = System.currentTimeMillis();
+        for (int i = 0; i < QUERY_COUNT; i++) {
+            int nextIndex = randomIndices[i];
+            //noinspection unused
+            List<IndexedStringEntity> query = dao.queryBuilder()
+                    .where(IndexedStringEntityDao.Properties.IndexedString.eq(
+                            fixedRandomStrings[nextIndex]))
+                    .list();
+        }
+        long time = System.currentTimeMillis() - start;
+        DaoLog.d("Queried for " + QUERY_COUNT + " of " + BATCH_SIZE + " indexed entities in " + time
+                + " ms.");
+
+        // delete all entities
+        dao.deleteAll();
+        DaoLog.d("Deleted all entities.");
+    }
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/performance/PerformanceTest.java b/DaoTest/src/de/greenrobot/daotest/performance/PerformanceTest.java
index 60f1321f..e6dcbcf3 100644
--- a/DaoTest/src/de/greenrobot/daotest/performance/PerformanceTest.java
+++ b/DaoTest/src/de/greenrobot/daotest/performance/PerformanceTest.java
@@ -1,169 +1,179 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daotest.performance;
-
-import java.util.ArrayList;
-import java.util.Date;
-import java.util.List;
-
-import android.os.Debug;
-import de.greenrobot.dao.AbstractDao;
-import de.greenrobot.dao.DaoLog;
-import de.greenrobot.dao.test.AbstractDaoTest;
-
-public abstract class PerformanceTest<D extends AbstractDao<T, K>, T, K> extends AbstractDaoTest<D, T, K> {
-    long start;
-    private String traceName;
-    boolean useTraceView = false;
-
-    public PerformanceTest(Class<D> daoClass) {
-        super(daoClass, false);
-    }
-
-    public void testPerformance() throws Exception {
-        // runTests(1000);
-        // runTests(1000);
-        // runTests(1000);
-        // runTests(1000);
-        // runTests(1000);
-        // runTests(1000);
-    }
-
-    protected void runTests(int entityCount) {
-        DaoLog.d("####################");
-        DaoLog.d(getClass().getSimpleName() + ": " + entityCount + " entities on " + new Date());
-        DaoLog.d("####################");
-        clearIdentityScopeIfAny();
-
-        List<T> list = new ArrayList<T>(entityCount);
-        for (int i = 0; i < entityCount; i++) {
-            list.add(createEntity());
-        }
-        System.gc();
-
-        dao.deleteAll();
-        // runOneByOneTests(list, entityCount, entityCount / 10);
-        dao.deleteAll();
-        DaoLog.d("------------------------");
-        System.gc();
-
-        // runBatchTests(list);
-
-        startClock("delete-all");
-        dao.deleteAll();
-        stopClock();
-        System.gc();
-    }
-
-    protected void runOneByOneTests(List<T> list, int loadCount, int modifyCount) {
-        dao.insertInTx(list);
-        List<K> keys = new ArrayList<K>(loadCount);
-        for (int i = 0; i < loadCount; i++) {
-            keys.add(daoAccess.getKey(list.get(i)));
-        }
-        clearIdentityScopeIfAny();
-        System.gc();
-
-        list = runLoadOneByOne(keys, "load-one-by-one-1");
-        list = runLoadOneByOne(keys, "load-one-by-one-2");
-        Debug.stopMethodTracing();
-
-        dao.deleteAll();
-        System.gc();
-
-        startClock("insert-one-by-one");
-        for (int i = 0; i < modifyCount; i++) {
-            dao.insert(list.get(i));
-        }
-        stopClock(modifyCount + " entities");
-        System.gc();
-
-        startClock("update-one-by-one");
-        for (int i = 0; i < modifyCount; i++) {
-            dao.update(list.get(i));
-        }
-        stopClock(modifyCount + " entities");
-        System.gc();
-
-        startClock("delete-one-by-one");
-        for (int i = 0; i < modifyCount; i++) {
-            dao.delete(list.get(i));
-        }
-        stopClock(modifyCount + " entities");
-        System.gc();
-    }
-
-    protected List<T> runLoadOneByOne(List<K> keys, String traceName) {
-        List<T> list = new ArrayList<T>(keys.size());
-        startClock(traceName);
-        for (K key : keys) {
-            list.add(dao.load(key));
-        }
-        stopClock(keys.size() + " entities");
-        return list;
-    }
-
-    protected void runBatchTests(List<T> list) {
-        startClock("insert");
-        dao.insertInTx(list);
-        stopClock(list.size() + " entities");
-
-        list = null;
-        System.gc();
-
-        clearIdentityScopeIfAny();
-        list = runLoadAll("load-all-1");
-        list = runLoadAll("load-all-2");
-
-        startClock("update");
-        dao.updateInTx(list);
-        stopClock(list.size() + " entities");
-    }
-
-    protected List<T> runLoadAll(String traceName) {
-        startClock(traceName);
-        List<T> list = dao.loadAll();
-        stopClock(list.size() + " entities");
-        return list;
-    }
-
-    protected void startClock(String traceName) {
-        System.gc();
-        this.traceName = traceName;
-        if (useTraceView) {
-            Debug.startMethodTracing(traceName);
-        }
-        start = System.currentTimeMillis();
-    }
-
-    protected void stopClock() {
-        stopClock(null);
-    }
-
-    protected void stopClock(String extraInfoOrNull) {
-        long time = System.currentTimeMillis() - start;
-        String extraLog = extraInfoOrNull != null ? " (" + extraInfoOrNull + ")" : "";
-        DaoLog.d(traceName + " completed in " + time + "ms" + extraLog);
-        if (useTraceView) {
-            Debug.stopMethodTracing();
-        }
-        System.gc();
-    }
-
-    protected abstract T createEntity();
-}
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.performance;
+
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.List;
+
+import android.os.Debug;
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.DaoLog;
+import de.greenrobot.dao.test.AbstractDaoTest;
+
+public abstract class PerformanceTest<D extends AbstractDao<T, K>, T, K>
+        extends AbstractDaoTest<D, T, K> {
+    private static final int BATCH_SIZE = 10000;
+    private static final int RUNS = 8;
+
+    long start;
+    private String traceName;
+    boolean useTraceView = false;
+
+    public PerformanceTest(Class<D> daoClass) {
+        super(daoClass, false);
+    }
+
+    public void testPerformance() throws Exception {
+        // disabled for regular builds
+//        for (int i = 0; i < RUNS; i++) {
+//            runTests(BATCH_SIZE);
+//        }
+    }
+
+    protected void runTests(int entityCount) {
+        DaoLog.d("####################");
+        DaoLog.d(getClass().getSimpleName() + ": " + entityCount + " entities on " + new Date());
+        DaoLog.d("####################");
+        clearIdentityScopeIfAny();
+
+        List<T> list = new ArrayList<T>(entityCount);
+        for (int i = 0; i < entityCount; i++) {
+            list.add(createEntity());
+        }
+        System.gc();
+
+        dao.deleteAll();
+        // runOneByOneTests(list, entityCount, entityCount / 10);
+        dao.deleteAll();
+        DaoLog.d("------------------------");
+        System.gc();
+
+        // runBatchTests(list);
+
+        startClock("delete-all");
+        dao.deleteAll();
+        stopClock();
+        System.gc();
+    }
+
+    protected void runOneByOneTests(List<T> list, int loadCount, int modifyCount) {
+        dao.insertInTx(list);
+        List<K> keys = new ArrayList<K>(loadCount);
+        for (int i = 0; i < loadCount; i++) {
+            keys.add(daoAccess.getKey(list.get(i)));
+        }
+        clearIdentityScopeIfAny();
+        System.gc();
+
+        list = runLoadOneByOne(keys, "load-one-by-one-1");
+        list = runLoadOneByOne(keys, "load-one-by-one-2");
+        Debug.stopMethodTracing();
+
+        dao.deleteAll();
+        System.gc();
+
+        startClock("insert-one-by-one");
+        for (int i = 0; i < modifyCount; i++) {
+            dao.insert(list.get(i));
+        }
+        stopClock(modifyCount + " entities");
+        System.gc();
+
+        startClock("update-one-by-one");
+        for (int i = 0; i < modifyCount; i++) {
+            dao.update(list.get(i));
+        }
+        stopClock(modifyCount + " entities");
+        System.gc();
+
+        startClock("delete-one-by-one");
+        for (int i = 0; i < modifyCount; i++) {
+            dao.delete(list.get(i));
+        }
+        stopClock(modifyCount + " entities");
+        System.gc();
+    }
+
+    protected List<T> runLoadOneByOne(List<K> keys, String traceName) {
+        List<T> list = new ArrayList<T>(keys.size());
+        startClock(traceName);
+        for (K key : keys) {
+            list.add(dao.load(key));
+        }
+        stopClock(keys.size() + " entities");
+        return list;
+    }
+
+    protected void runBatchTests(List<T> list) {
+        startClock("insert");
+        dao.insertInTx(list);
+        stopClock(list.size() + " entities");
+
+        list = null;
+        System.gc();
+
+        clearIdentityScopeIfAny();
+        list = runLoadAll("load-all-1");
+        accessAll(list, "access-all-1");
+        list = runLoadAll("load-all-2");
+        accessAll(list, "access-all-2");
+
+        startClock("update");
+        dao.updateInTx(list);
+        stopClock(list.size() + " entities");
+    }
+
+    protected List<T> runLoadAll(String traceName) {
+        startClock(traceName);
+        List<T> list = dao.loadAll();
+        stopClock(list.size() + " entities");
+        return list;
+    }
+
+    protected void startClock(String traceName) {
+        System.gc();
+        this.traceName = traceName;
+        if (useTraceView) {
+            Debug.startMethodTracing(traceName);
+        }
+        start = System.currentTimeMillis();
+    }
+
+    protected void stopClock() {
+        stopClock(null);
+    }
+
+    protected void stopClock(String extraInfoOrNull) {
+        long time = System.currentTimeMillis() - start;
+        String extraLog = extraInfoOrNull != null ? " (" + extraInfoOrNull + ")" : "";
+        DaoLog.d(traceName + " completed in " + time + " ms" + extraLog);
+        if (useTraceView) {
+            Debug.stopMethodTracing();
+        }
+        System.gc();
+    }
+
+    protected abstract T createEntity();
+
+    /**
+     * Access every property of the entity under test and record execution time with {@link
+     * #startClock(String)} and {@link #stopClock()}.
+     */
+    protected abstract void accessAll(List<T> list, String traceName);
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/performance/PerformanceTestNotNull.java b/DaoTest/src/de/greenrobot/daotest/performance/PerformanceTestNotNull.java
index 7b6be735..57986b0f 100644
--- a/DaoTest/src/de/greenrobot/daotest/performance/PerformanceTestNotNull.java
+++ b/DaoTest/src/de/greenrobot/daotest/performance/PerformanceTestNotNull.java
@@ -1,37 +1,57 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daotest.performance;
-
-import de.greenrobot.daotest.SimpleEntityNotNull;
-import de.greenrobot.daotest.SimpleEntityNotNullDao;
-import de.greenrobot.daotest.entity.SimpleEntityNotNullHelper;
-
-public class PerformanceTestNotNull extends PerformanceTest<SimpleEntityNotNullDao, SimpleEntityNotNull, Long> {
-
-    static long sequence;
-
-    public PerformanceTestNotNull() {
-        super(SimpleEntityNotNullDao.class);
-    }
-
-    @Override
-    protected SimpleEntityNotNull createEntity() {
-        return SimpleEntityNotNullHelper.createEntity(sequence++);
-    }
-
-}
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.performance;
+
+import de.greenrobot.daotest.SimpleEntityNotNull;
+import de.greenrobot.daotest.SimpleEntityNotNullDao;
+import de.greenrobot.daotest.entity.SimpleEntityNotNullHelper;
+import java.util.List;
+
+public class PerformanceTestNotNull extends PerformanceTest<SimpleEntityNotNullDao, SimpleEntityNotNull, Long> {
+
+    static long sequence;
+
+    public PerformanceTestNotNull() {
+        super(SimpleEntityNotNullDao.class);
+    }
+
+    @Override
+    protected SimpleEntityNotNull createEntity() {
+        return SimpleEntityNotNullHelper.createEntity(sequence++);
+    }
+
+    @Override
+    protected void accessAll(List<SimpleEntityNotNull> list, String traceName) {
+        startClock(traceName);
+        for (int i = 0; i < list.size(); i++) {
+            SimpleEntityNotNull entity = list.get(i);
+            entity.getId();
+            entity.getSimpleBoolean();
+            entity.getSimpleByte();
+            entity.getSimpleShort();
+            entity.getSimpleInt();
+            entity.getSimpleLong();
+            entity.getSimpleFloat();
+            entity.getSimpleDouble();
+            entity.getSimpleString();
+            entity.getSimpleByteArray();
+        }
+        stopClock(list.size() + " entities");
+    }
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/performance/ReflectionPerformanceTest.java b/DaoTest/src/de/greenrobot/daotest/performance/ReflectionPerformanceTest.java
index e71f1ab8..6abddab2 100644
--- a/DaoTest/src/de/greenrobot/daotest/performance/ReflectionPerformanceTest.java
+++ b/DaoTest/src/de/greenrobot/daotest/performance/ReflectionPerformanceTest.java
@@ -1,128 +1,128 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daotest.performance;
-
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-
-import de.greenrobot.dao.DaoLog;
-
-public class ReflectionPerformanceTest // extends TestCase
-{
-
-    int intValue;
-    String stringValue;
-
-    public int getIntValue() {
-        return intValue;
-    }
-
-    public void setIntValue(int inValue) {
-        this.intValue = inValue;
-    }
-
-    public String getStringValue() {
-        return stringValue;
-    }
-
-    public void setStringValue(String stringValue) {
-        this.stringValue = stringValue;
-    }
-
-    public void testSetIntPerf() throws SecurityException, NoSuchMethodException, IllegalArgumentException,
-            IllegalAccessException, InvocationTargetException {
-        int count = 100000;
-
-        long start = System.currentTimeMillis();
-        for (int i = 0; i < count; i++) {
-            setIntValue(i);
-        }
-        long time = System.currentTimeMillis() - start;
-
-        Method method = getClass().getMethod("setIntValue", int.class);
-        long start2 = System.currentTimeMillis();
-        for (int i = 0; i < count; i++) {
-            method.invoke(this, i);
-        }
-        long time2 = System.currentTimeMillis() - start2;
-        DaoLog.d("set int: normal=" + time + "ms, reflected=" + time2 + "ms, " + 1000 * count / time2
-                + " refelected ops/s, slower=" + ((float) time2) / time);
-
-    }
-
-    public void testGetIntPerf() throws SecurityException, NoSuchMethodException, IllegalArgumentException,
-            IllegalAccessException, InvocationTargetException {
-        int count = 100000;
-
-        long start = System.currentTimeMillis();
-        for (int i = 0; i < count; i++) {
-            int x = getIntValue();
-        }
-        long time = System.currentTimeMillis() - start;
-
-        Method method = getClass().getMethod("getIntValue");
-        long start2 = System.currentTimeMillis();
-        for (int i = 0; i < count; i++) {
-            int x = (Integer) method.invoke(this);
-        }
-        long time2 = System.currentTimeMillis() - start2;
-        DaoLog.d("get int: normal=" + time + "ms, reflected=" + time2 + "ms, " + 1000 * count / time2
-                + " refelected ops/s, slower=" + ((float) time2) / time);
-    }
-
-    public void testSetStringPerf() throws SecurityException, NoSuchMethodException, IllegalArgumentException,
-            IllegalAccessException, InvocationTargetException {
-        int count = 100000;
-
-        long start = System.currentTimeMillis();
-        for (int i = 0; i < count; i++) {
-            setStringValue("the quick brown fox");
-        }
-        long time = System.currentTimeMillis() - start;
-
-        Method method = getClass().getMethod("setStringValue", String.class);
-        long start2 = System.currentTimeMillis();
-        for (int i = 0; i < count; i++) {
-            method.invoke(this, "the quick brown fox");
-        }
-        long time2 = System.currentTimeMillis() - start2;
-        DaoLog.d("set String: normal=" + time + "ms, reflected=" + time2 + "ms, " + 1000 * count / time2
-                + " refelected ops/s, slower=" + ((float) time2) / time);
-
-    }
-
-    public void testGetStringPerf() throws SecurityException, NoSuchMethodException, IllegalArgumentException,
-            IllegalAccessException, InvocationTargetException {
-        int count = 100000;
-
-        long start = System.currentTimeMillis();
-        for (int i = 0; i < count; i++) {
-            String x = getStringValue();
-        }
-        long time = System.currentTimeMillis() - start;
-
-        Method method = getClass().getMethod("getStringValue");
-        long start2 = System.currentTimeMillis();
-        for (int i = 0; i < count; i++) {
-            String x = (String) method.invoke(this);
-        }
-        long time2 = System.currentTimeMillis() - start2;
-        DaoLog.d("get String: normal=" + time + "ms, reflected=" + time2 + "ms, " + 1000 * count / time2
-                + " refelected ops/s, slower=" + ((float) time2) / time);
-    }
-}
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.performance;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
+import de.greenrobot.dao.DaoLog;
+
+public class ReflectionPerformanceTest // extends TestCase
+{
+
+    int intValue;
+    String stringValue;
+
+    public int getIntValue() {
+        return intValue;
+    }
+
+    public void setIntValue(int inValue) {
+        this.intValue = inValue;
+    }
+
+    public String getStringValue() {
+        return stringValue;
+    }
+
+    public void setStringValue(String stringValue) {
+        this.stringValue = stringValue;
+    }
+
+    public void testSetIntPerf() throws SecurityException, NoSuchMethodException, IllegalArgumentException,
+            IllegalAccessException, InvocationTargetException {
+        int count = 100000;
+
+        long start = System.currentTimeMillis();
+        for (int i = 0; i < count; i++) {
+            setIntValue(i);
+        }
+        long time = System.currentTimeMillis() - start;
+
+        Method method = getClass().getMethod("setIntValue", int.class);
+        long start2 = System.currentTimeMillis();
+        for (int i = 0; i < count; i++) {
+            method.invoke(this, i);
+        }
+        long time2 = System.currentTimeMillis() - start2;
+        DaoLog.d("set int: normal=" + time + "ms, reflected=" + time2 + "ms, " + 1000 * count / time2
+                + " refelected ops/s, slower=" + ((float) time2) / time);
+
+    }
+
+    public void testGetIntPerf() throws SecurityException, NoSuchMethodException, IllegalArgumentException,
+            IllegalAccessException, InvocationTargetException {
+        int count = 100000;
+
+        long start = System.currentTimeMillis();
+        for (int i = 0; i < count; i++) {
+            int x = getIntValue();
+        }
+        long time = System.currentTimeMillis() - start;
+
+        Method method = getClass().getMethod("getIntValue");
+        long start2 = System.currentTimeMillis();
+        for (int i = 0; i < count; i++) {
+            int x = (Integer) method.invoke(this);
+        }
+        long time2 = System.currentTimeMillis() - start2;
+        DaoLog.d("get int: normal=" + time + "ms, reflected=" + time2 + "ms, " + 1000 * count / time2
+                + " refelected ops/s, slower=" + ((float) time2) / time);
+    }
+
+    public void testSetStringPerf() throws SecurityException, NoSuchMethodException, IllegalArgumentException,
+            IllegalAccessException, InvocationTargetException {
+        int count = 100000;
+
+        long start = System.currentTimeMillis();
+        for (int i = 0; i < count; i++) {
+            setStringValue("the quick brown fox");
+        }
+        long time = System.currentTimeMillis() - start;
+
+        Method method = getClass().getMethod("setStringValue", String.class);
+        long start2 = System.currentTimeMillis();
+        for (int i = 0; i < count; i++) {
+            method.invoke(this, "the quick brown fox");
+        }
+        long time2 = System.currentTimeMillis() - start2;
+        DaoLog.d("set String: normal=" + time + "ms, reflected=" + time2 + "ms, " + 1000 * count / time2
+                + " refelected ops/s, slower=" + ((float) time2) / time);
+
+    }
+
+    public void testGetStringPerf() throws SecurityException, NoSuchMethodException, IllegalArgumentException,
+            IllegalAccessException, InvocationTargetException {
+        int count = 100000;
+
+        long start = System.currentTimeMillis();
+        for (int i = 0; i < count; i++) {
+            String x = getStringValue();
+        }
+        long time = System.currentTimeMillis() - start;
+
+        Method method = getClass().getMethod("getStringValue");
+        long start2 = System.currentTimeMillis();
+        for (int i = 0; i < count; i++) {
+            String x = (String) method.invoke(this);
+        }
+        long time2 = System.currentTimeMillis() - start2;
+        DaoLog.d("get String: normal=" + time + "ms, reflected=" + time2 + "ms, " + 1000 * count / time2
+                + " refelected ops/s, slower=" + ((float) time2) / time);
+    }
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/performance/StringGenerator.java b/DaoTest/src/de/greenrobot/daotest/performance/StringGenerator.java
new file mode 100644
index 00000000..3fd87902
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/performance/StringGenerator.java
@@ -0,0 +1,58 @@
+package de.greenrobot.daotest.performance;
+
+import java.util.Random;
+
+/**
+ * Helper class to generate a pre-determined set of random strings.
+ */
+public class StringGenerator {
+
+    // Fixed seed so we generate the same set of strings every time.
+    public static final long SEED = -2662502316022774L;
+    private static final int MIN_LENGTH = 5;
+    private static final int MAX_LENGTH = 500;
+    // limit to a fixed set of chars
+    private static final char[] CHARS = new char[]{'0', '1', '2', '3', '4', '5', '6', '7', '8',
+            '9', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p',
+            'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'};
+
+    /**
+     * Creates the same random sequence of strings.
+     */
+    public static String[] createFixedRandomStrings(int count) {
+        String[] strings = new String[count];
+
+        Random lengthRandom = new Random();
+        lengthRandom.setSeed(SEED);
+
+        Random stringRandom = new Random();
+        stringRandom.setSeed(SEED);
+
+        for (int i = 0; i < count; i++) {
+            int nextLength = MIN_LENGTH + lengthRandom.nextInt(MAX_LENGTH - MIN_LENGTH - 1);
+            char[] chars = new char[nextLength];
+            for (int j = 0; j < nextLength; j++) {
+                chars[j] = CHARS[stringRandom.nextInt(CHARS.length)];
+            }
+            strings[i] = new String(chars);
+        }
+        return strings;
+    }
+
+    /**
+     * Creates the same random sequence of indexes. To be used to select strings by {@link
+     * #createFixedRandomStrings(int)}.
+     */
+    public static int[] getFixedRandomIndices(int count, int maxIndex) {
+        int[] indices = new int[count];
+
+        Random random = new Random();
+        random.setSeed(StringGenerator.SEED);
+
+        for (int i = 0; i < count; i++) {
+            indices[i] = random.nextInt(maxIndex + 1);
+        }
+
+        return indices;
+    }
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/performance/target/LongHashMapAmarena2DZechner.java b/DaoTest/src/de/greenrobot/daotest/performance/target/LongHashMapAmarena2DZechner.java
index a28e836b..2979e9f9 100644
--- a/DaoTest/src/de/greenrobot/daotest/performance/target/LongHashMapAmarena2DZechner.java
+++ b/DaoTest/src/de/greenrobot/daotest/performance/target/LongHashMapAmarena2DZechner.java
@@ -1,249 +1,249 @@
-/*******************************************************************************
- * Copyright 2010 Mario Zechner (contact@badlogicgames.com)
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
- * License. You may obtain a copy of the License at
- * 
- * http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS"
- * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language
- * governing permissions and limitations under the License.
- ******************************************************************************/
-
-package de.greenrobot.daotest.performance.target;
-
-import java.util.Iterator;
-
-import de.greenrobot.dao.DaoLog;
-
-/**
- * An long to object hashmap, taken from Amarena2D (thanks Christoph :p).
- * 
- * @author christop widulle
- * 
- * @param <T>
- */
-public class LongHashMapAmarena2DZechner<T> {
-
-    private Entry[] table;
-    private float loadFactor;
-    private int size, mask, capacity, threshold;
-
-    public LongHashMapAmarena2DZechner() {
-        this(16, 0.75f);
-    }
-
-    public LongHashMapAmarena2DZechner(int initialCapacity) {
-        this(initialCapacity, 0.75f);
-    }
-
-    public LongHashMapAmarena2DZechner(int initialCapacity, float loadFactor) {
-        if (initialCapacity > 1 << 30)
-            throw new IllegalArgumentException("initialCapacity is too large.");
-        if (initialCapacity < 0)
-            throw new IllegalArgumentException("initialCapacity must be greater than zero.");
-        if (loadFactor <= 0)
-            throw new IllegalArgumentException("initialCapacity must be greater than zero.");
-        capacity = 1;
-        while (capacity < initialCapacity) {
-            capacity <<= 1;
-        }
-        this.loadFactor = loadFactor;
-        this.threshold = (int) (capacity * loadFactor);
-        this.table = new Entry[capacity];
-        this.mask = capacity - 1;
-    }
-
-    public boolean containsValue(Object value) {
-        Entry[] table = this.table;
-        for (int i = table.length; i-- > 0;)
-            for (Entry e = table[i]; e != null; e = e.next)
-                if (e.value.equals(value))
-                    return true;
-        return false;
-    }
-
-    public boolean containsKey(long key) {
-        int index = ((int) key) & mask;
-        for (Entry e = table[index]; e != null; e = e.next)
-            if (e.key == key)
-                return true;
-        return false;
-    }
-
-    @SuppressWarnings("unchecked")
-    public T get(long key) {
-        int index = (int) (key & mask);
-        for (Entry e = table[index]; e != null; e = e.next)
-            if (e.key == key)
-                return (T) e.value;
-        return null;
-    }
-
-    @SuppressWarnings("unchecked")
-    public T put(long key, T value) {
-        int index = (int) (key & mask);
-        // Check if key already exists.
-        for (Entry e = table[index]; e != null; e = e.next) {
-            if (e.key != key)
-                continue;
-            Object oldValue = e.value;
-            e.value = value;
-            return (T) oldValue;
-        }
-        table[index] = new Entry(key, value, table[index]);
-        if (size++ >= threshold) {
-            // Rehash.
-            int newCapacity = 2 * capacity;
-            Entry[] newTable = new Entry[newCapacity];
-            Entry[] src = table;
-            int bucketmask = newCapacity - 1;
-            for (int j = 0; j < src.length; j++) {
-                Entry e = src[j];
-                if (e != null) {
-                    src[j] = null;
-                    do {
-                        Entry next = e.next;
-                        index = (int) (e.key & bucketmask);
-                        e.next = newTable[index];
-                        newTable[index] = e;
-                        e = next;
-                    } while (e != null);
-                }
-            }
-            table = newTable;
-            capacity = newCapacity;
-            threshold = (int) (newCapacity * loadFactor);
-            mask = capacity - 1;
-        }
-        return null;
-    }
-
-    @SuppressWarnings("unchecked")
-    public T remove(long key) {
-        int index = (int) (key & mask);
-        Entry prev = table[index];
-        Entry e = prev;
-        while (e != null) {
-            Entry next = e.next;
-            if (e.key == key) {
-                size--;
-                if (prev == e) {
-                    table[index] = next;
-                } else {
-                    prev.next = next;
-                }
-                return (T) e.value;
-            }
-            prev = e;
-            e = next;
-        }
-        return null;
-    }
-
-    public int size() {
-        return size;
-    }
-
-    public void clear() {
-        Entry[] table = this.table;
-        for (int index = table.length; --index >= 0;)
-            table[index] = null;
-        size = 0;
-    }
-
-    static class Entry {
-        final long key;
-        Object value;
-        Entry next;
-
-        Entry(long k, Object v, Entry n) {
-            key = k;
-            value = v;
-            next = n;
-        }
-    }
-
-    EntryIterable iterable = new EntryIterable();
-
-    public Iterable<T> values() {
-        iterable.reset();
-        return iterable;
-    }
-
-    class EntryIterable implements Iterable<T> {
-        int currIndex = -1;
-        Entry currEntry = null;
-
-        Iterator<T> iter = new Iterator<T>() {
-            @Override
-            public boolean hasNext() {
-                if (currEntry == null) {
-                    if (!loadNextEntry())
-                        return false;
-                } else {
-                    if (currEntry.next == null) {
-                        if (loadNextEntry() == false)
-                            return false;
-                    } else
-                        currEntry = currEntry.next;
-                }
-
-                return true;
-            }
-
-            @SuppressWarnings("synthetic-access")
-            private boolean loadNextEntry() {
-                while (true) {
-                    currIndex++;
-                    if (currIndex >= table.length)
-                        return false;
-
-                    if (table[currIndex] == null)
-                        continue;
-                    else {
-                        currEntry = table[currIndex];
-                        return true;
-                    }
-                }
-            }
-
-            @SuppressWarnings("unchecked")
-            @Override
-            public T next() {
-                return (T) currEntry.value;
-            }
-
-            @Override
-            public void remove() {
-                throw new UnsupportedOperationException("not implemented");
-            }
-
-        };
-
-        public void reset() {
-            currIndex = -1;
-            currEntry = null;
-        }
-
-        @Override
-        public Iterator<T> iterator() {
-            return iter;
-        }
-
-    }
-
-    public void logStats() {
-        int collisions = 0;
-        for (Entry entry : table) {
-            while (entry != null && entry.next != null) {
-                collisions++;
-                entry = entry.next;
-            }
-        }
-        DaoLog.d("load: " + ((float) size) / capacity + ", size: " + size + ", capa: " + capacity + ", collisions: "
-                + collisions + ", collision ratio: " + ((float) collisions) / size);
-    }
-
-}
+/*******************************************************************************
+ * Copyright 2010 Mario Zechner (contact@badlogicgames.com)
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS"
+ * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ ******************************************************************************/
+
+package de.greenrobot.daotest.performance.target;
+
+import java.util.Iterator;
+
+import de.greenrobot.dao.DaoLog;
+
+/**
+ * An long to object hashmap, taken from Amarena2D (thanks Christoph :p).
+ * 
+ * @author christop widulle
+ * 
+ * @param <T>
+ */
+public class LongHashMapAmarena2DZechner<T> {
+
+    private Entry[] table;
+    private float loadFactor;
+    private int size, mask, capacity, threshold;
+
+    public LongHashMapAmarena2DZechner() {
+        this(16, 0.75f);
+    }
+
+    public LongHashMapAmarena2DZechner(int initialCapacity) {
+        this(initialCapacity, 0.75f);
+    }
+
+    public LongHashMapAmarena2DZechner(int initialCapacity, float loadFactor) {
+        if (initialCapacity > 1 << 30)
+            throw new IllegalArgumentException("initialCapacity is too large.");
+        if (initialCapacity < 0)
+            throw new IllegalArgumentException("initialCapacity must be greater than zero.");
+        if (loadFactor <= 0)
+            throw new IllegalArgumentException("initialCapacity must be greater than zero.");
+        capacity = 1;
+        while (capacity < initialCapacity) {
+            capacity <<= 1;
+        }
+        this.loadFactor = loadFactor;
+        this.threshold = (int) (capacity * loadFactor);
+        this.table = new Entry[capacity];
+        this.mask = capacity - 1;
+    }
+
+    public boolean containsValue(Object value) {
+        Entry[] table = this.table;
+        for (int i = table.length; i-- > 0;)
+            for (Entry e = table[i]; e != null; e = e.next)
+                if (e.value.equals(value))
+                    return true;
+        return false;
+    }
+
+    public boolean containsKey(long key) {
+        int index = ((int) key) & mask;
+        for (Entry e = table[index]; e != null; e = e.next)
+            if (e.key == key)
+                return true;
+        return false;
+    }
+
+    @SuppressWarnings("unchecked")
+    public T get(long key) {
+        int index = (int) (key & mask);
+        for (Entry e = table[index]; e != null; e = e.next)
+            if (e.key == key)
+                return (T) e.value;
+        return null;
+    }
+
+    @SuppressWarnings("unchecked")
+    public T put(long key, T value) {
+        int index = (int) (key & mask);
+        // Check if key already exists.
+        for (Entry e = table[index]; e != null; e = e.next) {
+            if (e.key != key)
+                continue;
+            Object oldValue = e.value;
+            e.value = value;
+            return (T) oldValue;
+        }
+        table[index] = new Entry(key, value, table[index]);
+        if (size++ >= threshold) {
+            // Rehash.
+            int newCapacity = 2 * capacity;
+            Entry[] newTable = new Entry[newCapacity];
+            Entry[] src = table;
+            int bucketmask = newCapacity - 1;
+            for (int j = 0; j < src.length; j++) {
+                Entry e = src[j];
+                if (e != null) {
+                    src[j] = null;
+                    do {
+                        Entry next = e.next;
+                        index = (int) (e.key & bucketmask);
+                        e.next = newTable[index];
+                        newTable[index] = e;
+                        e = next;
+                    } while (e != null);
+                }
+            }
+            table = newTable;
+            capacity = newCapacity;
+            threshold = (int) (newCapacity * loadFactor);
+            mask = capacity - 1;
+        }
+        return null;
+    }
+
+    @SuppressWarnings("unchecked")
+    public T remove(long key) {
+        int index = (int) (key & mask);
+        Entry prev = table[index];
+        Entry e = prev;
+        while (e != null) {
+            Entry next = e.next;
+            if (e.key == key) {
+                size--;
+                if (prev == e) {
+                    table[index] = next;
+                } else {
+                    prev.next = next;
+                }
+                return (T) e.value;
+            }
+            prev = e;
+            e = next;
+        }
+        return null;
+    }
+
+    public int size() {
+        return size;
+    }
+
+    public void clear() {
+        Entry[] table = this.table;
+        for (int index = table.length; --index >= 0;)
+            table[index] = null;
+        size = 0;
+    }
+
+    static class Entry {
+        final long key;
+        Object value;
+        Entry next;
+
+        Entry(long k, Object v, Entry n) {
+            key = k;
+            value = v;
+            next = n;
+        }
+    }
+
+    EntryIterable iterable = new EntryIterable();
+
+    public Iterable<T> values() {
+        iterable.reset();
+        return iterable;
+    }
+
+    class EntryIterable implements Iterable<T> {
+        int currIndex = -1;
+        Entry currEntry = null;
+
+        Iterator<T> iter = new Iterator<T>() {
+            @Override
+            public boolean hasNext() {
+                if (currEntry == null) {
+                    if (!loadNextEntry())
+                        return false;
+                } else {
+                    if (currEntry.next == null) {
+                        if (loadNextEntry() == false)
+                            return false;
+                    } else
+                        currEntry = currEntry.next;
+                }
+
+                return true;
+            }
+
+            @SuppressWarnings("synthetic-access")
+            private boolean loadNextEntry() {
+                while (true) {
+                    currIndex++;
+                    if (currIndex >= table.length)
+                        return false;
+
+                    if (table[currIndex] == null)
+                        continue;
+                    else {
+                        currEntry = table[currIndex];
+                        return true;
+                    }
+                }
+            }
+
+            @SuppressWarnings("unchecked")
+            @Override
+            public T next() {
+                return (T) currEntry.value;
+            }
+
+            @Override
+            public void remove() {
+                throw new UnsupportedOperationException("not implemented");
+            }
+
+        };
+
+        public void reset() {
+            currIndex = -1;
+            currEntry = null;
+        }
+
+        @Override
+        public Iterator<T> iterator() {
+            return iter;
+        }
+
+    }
+
+    public void logStats() {
+        int collisions = 0;
+        for (Entry entry : table) {
+            while (entry != null && entry.next != null) {
+                collisions++;
+                entry = entry.next;
+            }
+        }
+        DaoLog.d("load: " + ((float) size) / capacity + ", size: " + size + ", capa: " + capacity + ", collisions: "
+                + collisions + ", collision ratio: " + ((float) collisions) / size);
+    }
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/query/CursorQueryTest.java b/DaoTest/src/de/greenrobot/daotest/query/CursorQueryTest.java
new file mode 100644
index 00000000..be86693b
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/query/CursorQueryTest.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2011-2015 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.query;
+
+import android.database.Cursor;
+import de.greenrobot.dao.query.CursorQuery;
+import de.greenrobot.dao.query.QueryBuilder;
+import de.greenrobot.daotest.TestEntityDao.Properties;
+import de.greenrobot.daotest.entity.TestEntityTestBase;
+
+// TODO more tests
+public class CursorQueryTest extends TestEntityTestBase {
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        QueryBuilder.LOG_SQL = true;
+        QueryBuilder.LOG_VALUES = true;
+    }
+
+    public void testCursorQuerySimple() {
+        insert(3);
+        CursorQuery query = dao.queryBuilder().orderAsc(Properties.SimpleInteger).buildCursor();
+        Cursor cursor = query.query();
+        try {
+            assertEquals(3, cursor.getCount());
+            assertTrue(cursor.moveToNext());
+            int columnIndex = cursor.getColumnIndexOrThrow(Properties.SimpleInteger.columnName);
+            assertEquals(getSimpleInteger(0), cursor.getInt(columnIndex));
+            assertTrue(cursor.moveToNext());
+            assertEquals(getSimpleInteger(1), cursor.getInt(columnIndex));
+            assertTrue(cursor.moveToNext());
+            assertEquals(getSimpleInteger(2), cursor.getInt(columnIndex));
+            assertFalse(cursor.moveToNext());
+        } finally {
+            cursor.close();
+        }
+    }
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/query/JoinTest.java b/DaoTest/src/de/greenrobot/daotest/query/JoinTest.java
new file mode 100644
index 00000000..ff06aff5
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/query/JoinTest.java
@@ -0,0 +1,166 @@
+/*
+ * Copyright (C) 2011-2015 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.daotest.query;
+
+import de.greenrobot.dao.DaoException;
+import de.greenrobot.dao.query.Join;
+import de.greenrobot.dao.query.Query;
+import de.greenrobot.dao.query.QueryBuilder;
+import de.greenrobot.dao.test.AbstractDaoSessionTest;
+import de.greenrobot.daotest.DaoMaster;
+import de.greenrobot.daotest.DaoSession;
+import de.greenrobot.daotest.RelationEntity;
+import de.greenrobot.daotest.RelationEntityDao;
+import de.greenrobot.daotest.TestEntity;
+import de.greenrobot.daotest.TestEntityDao;
+import de.greenrobot.daotest.TestEntityDao.Properties;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class JoinTest extends AbstractDaoSessionTest<DaoMaster, DaoSession> {
+
+    private TestEntityDao testEntityDao;
+    private RelationEntityDao relationEntityDao;
+
+    public JoinTest() {
+        super(DaoMaster.class);
+    }
+
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        QueryBuilder.LOG_SQL = true;
+        QueryBuilder.LOG_VALUES = true;
+        testEntityDao = daoSession.getTestEntityDao();
+        relationEntityDao = daoSession.getRelationEntityDao();
+    }
+
+    public void testJoinSimple() {
+        prepareData();
+        QueryBuilder<RelationEntity> queryBuilder = createQueryBuilder(5);
+        RelationEntity unique = queryBuilder.uniqueOrThrow();
+        assertEquals("entity-5", unique.getSimpleString());
+    }
+
+    public void testJoinSimpleParameterValue() {
+        prepareData();
+        QueryBuilder<RelationEntity> queryBuilder = createQueryBuilder(-1);
+        Query<RelationEntity> query = queryBuilder.build();
+        for (int i = 0; i < 10; i++) {
+            query.setParameter(0, i + 1);
+            RelationEntity unique = query.uniqueOrThrow();
+            assertEquals("entity-" + (i + 1), unique.getSimpleString());
+        }
+    }
+
+    public void testJoinMixedParameterValues() {
+        prepareData();
+        QueryBuilder<RelationEntity> queryBuilder = relationEntityDao.queryBuilder();
+        queryBuilder.where(RelationEntityDao.Properties.SimpleString.like(""), RelationEntityDao.Properties.SimpleString.ge(""));
+        Join<RelationEntity, TestEntity> join = queryBuilder.join(RelationEntityDao.Properties.TestIdNotNull,
+                TestEntity.class);
+        join.where(Properties.SimpleInt.le(0));
+        queryBuilder.offset(0).limit(0);
+        Query<RelationEntity> query = queryBuilder.build();
+        query.setParameter(0, "entity-%");
+        query.setParameter(1, "entity-4");
+        query.setParameter(2, 6);
+        query.setOffset(1);
+        query.setLimit(99);
+        List<RelationEntity> entities = query.list();
+        assertEquals(2, entities.size());
+        assertEquals("entity-5", entities.get(0).getSimpleString());
+        assertEquals("entity-6", entities.get(1).getSimpleString());
+    }
+
+    public void testJoinOfJoin() {
+        prepareData();
+        List<RelationEntity> relationEntities = relationEntityDao.loadAll();
+        relationEntities.get(2).setParent(relationEntities.get(4));
+        relationEntities.get(3).setParent(relationEntities.get(5));
+        relationEntities.get(7).setParent(relationEntities.get(5));
+        relationEntityDao.updateInTx(relationEntities);
+
+        QueryBuilder<RelationEntity> queryBuilder = relationEntityDao.queryBuilder();
+        Join<RelationEntity, RelationEntity> join1 =
+                queryBuilder.join(RelationEntityDao.Properties.ParentId, RelationEntity.class);
+        queryBuilder.join(join1, RelationEntityDao.Properties.TestIdNotNull, TestEntity.class, Properties.Id)
+                .where(Properties.SimpleInt.lt(6));
+
+        Query<RelationEntity> query = queryBuilder.build();
+        RelationEntity entity = query.uniqueOrThrow();
+        assertEquals(relationEntities.get(2).getSimpleString(), entity.getSimpleString());
+
+        query.setParameter(0, 99);
+        assertEquals(3, query.list().size());
+    }
+
+    public void testJoinDelete() {
+        prepareData();
+        QueryBuilder<RelationEntity> queryBuilder = createQueryBuilder(5);
+        try {
+            queryBuilder.buildDelete().executeDeleteWithoutDetachingEntities();
+        } catch (DaoException e) {
+            assertEquals("JOINs are not supported for DELETE queries", e.getMessage());
+            return;
+        }
+        // Never executed, unsupported by SQLite
+        assertEquals(9, relationEntityDao.count());
+        assertEquals(10, testEntityDao.count());
+        assertNull(relationEntityDao.queryBuilder().where(Properties.SimpleString.eq("entity-5")).unique());
+    }
+
+    public void testJoinCount() {
+        prepareData();
+        QueryBuilder<RelationEntity> queryBuilder = relationEntityDao.queryBuilder();
+        Join<RelationEntity, TestEntity> join = queryBuilder.join(RelationEntityDao.Properties.TestIdNotNull,
+                TestEntity.class);
+        join.where(Properties.SimpleInt.gt(6));
+        queryBuilder.count();
+        assertEquals(4, queryBuilder.count());
+    }
+
+    private void prepareData() {
+        List<TestEntity> targetEntities = new ArrayList<TestEntity>();
+        for (int i = 0; i < 10; i++) {
+            TestEntity testEntity = new TestEntity();
+            testEntity.setSimpleInt(i + 1);
+            testEntity.setSimpleStringNotNull("string-" + (i + 1));
+            targetEntities.add(testEntity);
+        }
+        testEntityDao.insertInTx(targetEntities);
+
+        List<RelationEntity> entities = new ArrayList<RelationEntity>();
+        for (int i = 0; i < 10; i++) {
+            RelationEntity entity = new RelationEntity();
+            entity.setSimpleString("entity-" + (i + 1));
+            entity.setTestNotNull(targetEntities.get(i));
+            entities.add(entity);
+        }
+        relationEntityDao.insertInTx(entities);
+    }
+
+    private QueryBuilder<RelationEntity> createQueryBuilder(int simpleIntWhereValue) {
+        QueryBuilder<RelationEntity> queryBuilder = relationEntityDao.queryBuilder();
+        Join<RelationEntity, TestEntity> join = queryBuilder.join(RelationEntityDao.Properties.TestIdNotNull,
+                TestEntity.class);
+        join.where(Properties.SimpleInt.eq(simpleIntWhereValue));
+        return queryBuilder;
+    }
+
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/query/LazyListTest.java b/DaoTest/src/de/greenrobot/daotest/query/LazyListTest.java
index 20af0472..7cbb071c 100644
--- a/DaoTest/src/de/greenrobot/daotest/query/LazyListTest.java
+++ b/DaoTest/src/de/greenrobot/daotest/query/LazyListTest.java
@@ -1,187 +1,204 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daotest.query;
-
-import java.util.ArrayList;
-import java.util.ListIterator;
-import java.util.NoSuchElementException;
-
-import de.greenrobot.dao.DaoException;
-import de.greenrobot.dao.query.CloseableListIterator;
-import de.greenrobot.dao.query.LazyList;
-import de.greenrobot.daotest.TestEntity;
-import de.greenrobot.daotest.TestEntityDao.Properties;
-import de.greenrobot.daotest.entity.TestEntityTestBase;
-
-public class LazyListTest extends TestEntityTestBase {
-
-    public void testSizeAndGetAndPeak() {
-        ArrayList<TestEntity> list = insert(2);
-
-        LazyList<TestEntity> listLazy = dao.queryBuilder().build().listLazy();
-        assertEquals(list.size(), listLazy.size());
-        assertNull(listLazy.peak(0));
-        assertNull(listLazy.peak(1));
-
-        assertNotNull(listLazy.get(1));
-        assertNull(listLazy.peak(0));
-        assertNotNull(listLazy.peak(1));
-
-        assertNotNull(listLazy.get(0));
-        assertNotNull(listLazy.peak(0));
-        assertNotNull(listLazy.peak(1));
-    }
-
-    public void testGetAll100() {
-        ArrayList<TestEntity> list = insert(100);
-        LazyList<TestEntity> listLazy = dao.queryBuilder().orderAsc(Properties.SimpleInteger).build().listLazy();
-        assertIds(list, listLazy);
-        assertTrue(listLazy.isClosed());
-    }
-
-    public void testGetAll100Uncached() {
-        ArrayList<TestEntity> list = insert(100);
-        LazyList<TestEntity> listLazy = dao.queryBuilder().orderAsc(Properties.SimpleInteger).build()
-                .listLazyUncached();
-        assertIds(list, listLazy);
-        assertFalse(listLazy.isClosed());
-        listLazy.close();
-    }
-
-    public void testIterator() {
-        ArrayList<TestEntity> list = insert(100);
-        LazyList<TestEntity> listLazy = dao.queryBuilder().orderAsc(Properties.SimpleInteger).build().listLazy();
-        testIerator(list, listLazy, false);
-        assertTrue(listLazy.isClosed());
-    }
-
-    public void testIteratorUncached() {
-        ArrayList<TestEntity> list = insert(100);
-        LazyList<TestEntity> listLazy = dao.queryBuilder().orderAsc(Properties.SimpleInteger).build()
-                .listLazyUncached();
-        testIerator(list, listLazy, true);
-        assertFalse(listLazy.isClosed());
-        listLazy.close();
-    }
-
-    protected void testIerator(ArrayList<TestEntity> list, LazyList<TestEntity> listLazy, boolean uncached) {
-        ListIterator<TestEntity> iterator = listLazy.listIterator();
-        try {
-            iterator.previous();
-            fail("previous should throw here");
-        } catch (NoSuchElementException expected) {
-            // OK
-        }
-        int size = list.size();
-        for (int i = 0; i < size; i++) {
-            assertTrue(iterator.hasNext());
-            assertEquals(i > 0, iterator.hasPrevious());
-            assertEquals(i, iterator.nextIndex());
-            assertEquals(i - 1, iterator.previousIndex());
-
-            if (i > 0) {
-                TestEntity entityPrevious = list.get(i - 1);
-                assertEquals(entityPrevious.getId(), iterator.previous().getId());
-                iterator.next();
-            }
-
-            TestEntity entity = list.get(i);
-            assertNull(listLazy.peak(i));
-            TestEntity lazyEntity = iterator.next();
-            if (uncached) {
-                assertNull(listLazy.peak(i));
-            } else {
-                assertNotNull(listLazy.peak(i));
-            }
-            assertEquals(entity.getId(), lazyEntity.getId());
-        }
-        assertFalse(iterator.hasNext());
-        try {
-            iterator.next();
-            fail("next should throw here");
-        } catch (NoSuchElementException expected) {
-            // OK
-        }
-    }
-
-    public void testEmpty() {
-        insert(1);
-
-        LazyList<TestEntity> listLazy = dao.queryBuilder().where(Properties.SimpleInteger.eq(-1)).build().listLazy();
-        assertTrue(listLazy.isEmpty());
-        assertTrue(listLazy.isClosed());
-        try {
-            listLazy.get(0);
-            fail("Not empty");
-        } catch (RuntimeException e) {
-            // Expected, OK
-        }
-
-    }
-
-    public void testUncached() {
-        insert(1);
-
-        LazyList<TestEntity> listLazy = dao.queryBuilder().build().listLazyUncached();
-        assertFalse(listLazy.isEmpty());
-        assertFalse(listLazy.isClosed());
-        TestEntity entity1 = listLazy.get(0);
-        TestEntity entity2 = listLazy.get(0);
-        assertEquals(entity1.getId(), entity2.getId());
-        if (identityScopeForDao == null) {
-            assertNotSame(entity1, entity2);
-        } else {
-            assertSame(entity1, entity2);
-        }
-        assertFalse(listLazy.isClosed());
-        try {
-            listLazy.loadRemaining();
-            fail("Not empty");
-        } catch (DaoException expected) {
-            // Expected, OK
-        }
-        listLazy.close();
-        assertTrue(listLazy.isClosed());
-    }
-
-    public void testClose() {
-        insert(1);
-
-        LazyList<TestEntity> listLazy = dao.queryBuilder().build().listLazy();
-        assertFalse(listLazy.isEmpty());
-        assertFalse(listLazy.isClosed());
-        listLazy.get(0);
-        assertTrue(listLazy.isClosed());
-
-        // Closing again should not harm
-        listLazy.close();
-        listLazy.close();
-    }
-
-    public void testAutoClose() {
-        insert(10);
-        LazyList<TestEntity> lazyList = dao.queryBuilder().build().listLazyUncached();
-        CloseableListIterator<TestEntity> iterator = lazyList.listIteratorAutoClose();
-        while (iterator.hasNext()) {
-            assertFalse(lazyList.isClosed());
-            iterator.next();
-        }
-        assertTrue(lazyList.isClosed());
-    }
-    
-}
+/*
+ * Copyright (C) 2011-2015 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.query;
+
+import java.util.ArrayList;
+import java.util.ListIterator;
+import java.util.NoSuchElementException;
+
+import de.greenrobot.dao.DaoException;
+import de.greenrobot.dao.query.CloseableListIterator;
+import de.greenrobot.dao.query.LazyList;
+import de.greenrobot.daotest.TestEntity;
+import de.greenrobot.daotest.TestEntityDao.Properties;
+import de.greenrobot.daotest.entity.TestEntityTestBase;
+
+public class LazyListTest extends TestEntityTestBase {
+
+    public void testSizeAndGetAndPeak() {
+        ArrayList<TestEntity> list = insert(2);
+
+        LazyList<TestEntity> listLazy = dao.queryBuilder().build().listLazy();
+        assertEquals(list.size(), listLazy.size());
+        assertNull(listLazy.peak(0));
+        assertNull(listLazy.peak(1));
+
+        assertNotNull(listLazy.get(1));
+        assertNull(listLazy.peak(0));
+        assertNotNull(listLazy.peak(1));
+
+        assertNotNull(listLazy.get(0));
+        assertNotNull(listLazy.peak(0));
+        assertNotNull(listLazy.peak(1));
+    }
+
+    public void testGetAll100() {
+        ArrayList<TestEntity> list = insert(100);
+        LazyList<TestEntity> listLazy = dao.queryBuilder().orderAsc(Properties.SimpleInteger).build().listLazy();
+        assertIds(list, listLazy);
+        assertTrue(listLazy.isClosed());
+    }
+
+    public void testGetAll100Uncached() {
+        ArrayList<TestEntity> list = insert(100);
+        LazyList<TestEntity> listLazy = dao.queryBuilder().orderAsc(Properties.SimpleInteger).build()
+                .listLazyUncached();
+        assertIds(list, listLazy);
+        assertFalse(listLazy.isClosed());
+        listLazy.close();
+    }
+
+    public void testSublist() {
+        ArrayList<TestEntity> list = insert(10);
+        LazyList<TestEntity> listLazy = dao.queryBuilder().orderAsc(Properties.SimpleInteger).build().listLazy();
+        assertIds(list.subList(2, 7), listLazy.subList(2, 7));
+    }
+
+    public void testSublistUncached() {
+        ArrayList<TestEntity> list = insert(10);
+        LazyList<TestEntity> listLazy = dao.queryBuilder().orderAsc(Properties.SimpleInteger).build().listLazyUncached();
+        try {
+            assertIds(list.subList(2,7), listLazy.subList(2,7));
+        } catch (DaoException e) {
+            assertEquals("This operation only works with cached lazy lists", e.getMessage());
+        }
+
+    }
+
+    public void testIterator() {
+        ArrayList<TestEntity> list = insert(100);
+        LazyList<TestEntity> listLazy = dao.queryBuilder().orderAsc(Properties.SimpleInteger).build().listLazy();
+        testIerator(list, listLazy, false);
+        assertTrue(listLazy.isClosed());
+    }
+
+    public void testIteratorUncached() {
+        ArrayList<TestEntity> list = insert(100);
+        LazyList<TestEntity> listLazy = dao.queryBuilder().orderAsc(Properties.SimpleInteger).build()
+                .listLazyUncached();
+        testIerator(list, listLazy, true);
+        assertFalse(listLazy.isClosed());
+        listLazy.close();
+    }
+
+    protected void testIerator(ArrayList<TestEntity> list, LazyList<TestEntity> listLazy, boolean uncached) {
+        ListIterator<TestEntity> iterator = listLazy.listIterator();
+        try {
+            iterator.previous();
+            fail("previous should throw here");
+        } catch (NoSuchElementException expected) {
+            // OK
+        }
+        int size = list.size();
+        for (int i = 0; i < size; i++) {
+            assertTrue(iterator.hasNext());
+            assertEquals(i > 0, iterator.hasPrevious());
+            assertEquals(i, iterator.nextIndex());
+            assertEquals(i - 1, iterator.previousIndex());
+
+            if (i > 0) {
+                TestEntity entityPrevious = list.get(i - 1);
+                assertEquals(entityPrevious.getId(), iterator.previous().getId());
+                iterator.next();
+            }
+
+            TestEntity entity = list.get(i);
+            assertNull(listLazy.peak(i));
+            TestEntity lazyEntity = iterator.next();
+            if (uncached) {
+                assertNull(listLazy.peak(i));
+            } else {
+                assertNotNull(listLazy.peak(i));
+            }
+            assertEquals(entity.getId(), lazyEntity.getId());
+        }
+        assertFalse(iterator.hasNext());
+        try {
+            iterator.next();
+            fail("next should throw here");
+        } catch (NoSuchElementException expected) {
+            // OK
+        }
+    }
+
+    public void testEmpty() {
+        insert(1);
+
+        LazyList<TestEntity> listLazy = dao.queryBuilder().where(Properties.SimpleInteger.eq(-1)).build().listLazy();
+        assertTrue(listLazy.isEmpty());
+        assertTrue(listLazy.isClosed());
+        try {
+            listLazy.get(0);
+            fail("Not empty");
+        } catch (RuntimeException e) {
+            // Expected, OK
+        }
+
+    }
+
+    public void testUncached() {
+        insert(1);
+
+        LazyList<TestEntity> listLazy = dao.queryBuilder().build().listLazyUncached();
+        assertFalse(listLazy.isEmpty());
+        assertFalse(listLazy.isClosed());
+        TestEntity entity1 = listLazy.get(0);
+        TestEntity entity2 = listLazy.get(0);
+        assertEquals(entity1.getId(), entity2.getId());
+        if (identityScopeForDao == null) {
+            assertNotSame(entity1, entity2);
+        } else {
+            assertSame(entity1, entity2);
+        }
+        assertFalse(listLazy.isClosed());
+        try {
+            listLazy.loadRemaining();
+            fail("Not empty");
+        } catch (DaoException expected) {
+            // Expected, OK
+        }
+        listLazy.close();
+        assertTrue(listLazy.isClosed());
+    }
+
+    public void testClose() {
+        insert(1);
+
+        LazyList<TestEntity> listLazy = dao.queryBuilder().build().listLazy();
+        assertFalse(listLazy.isEmpty());
+        assertFalse(listLazy.isClosed());
+        listLazy.get(0);
+        assertTrue(listLazy.isClosed());
+
+        // Closing again should not harm
+        listLazy.close();
+        listLazy.close();
+    }
+
+    public void testAutoClose() {
+        insert(10);
+        LazyList<TestEntity> lazyList = dao.queryBuilder().build().listLazyUncached();
+        CloseableListIterator<TestEntity> iterator = lazyList.listIteratorAutoClose();
+        while (iterator.hasNext()) {
+            assertFalse(lazyList.isClosed());
+            iterator.next();
+        }
+        assertTrue(lazyList.isClosed());
+    }
+    
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/query/QueryBuilderOrderTest.java b/DaoTest/src/de/greenrobot/daotest/query/QueryBuilderOrderTest.java
index f9a43e6b..24638626 100644
--- a/DaoTest/src/de/greenrobot/daotest/query/QueryBuilderOrderTest.java
+++ b/DaoTest/src/de/greenrobot/daotest/query/QueryBuilderOrderTest.java
@@ -109,10 +109,13 @@ public void testOrderCustom() {
 
     public void testOrderRaw() {
         ArrayList<TestEntity> inserted = insert(2);
-        TestEntity entity = inserted.get(0);
         List<TestEntity> result = dao.queryBuilder().orderRaw(Properties.SimpleInteger.columnName + " ASC").list();
         assertEquals(2, result.size());
-        assertEquals(entity.getId(), result.get(0).getId());
+        assertEquals(inserted.get(0).getId(), result.get(0).getId());
+
+        result = dao.queryBuilder().orderRaw(Properties.SimpleInteger.columnName + " DESC").list();
+        assertEquals(2, result.size());
+        assertEquals(inserted.get(1).getId(), result.get(0).getId());
     }
 
     private TestEntity addEntity(List<TestEntity> list, String simpleString) {
diff --git a/DaoTest/src/de/greenrobot/daotest/query/QueryBuilderSimpleTest.java b/DaoTest/src/de/greenrobot/daotest/query/QueryBuilderSimpleTest.java
index 3f9f7276..221a80bd 100644
--- a/DaoTest/src/de/greenrobot/daotest/query/QueryBuilderSimpleTest.java
+++ b/DaoTest/src/de/greenrobot/daotest/query/QueryBuilderSimpleTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ * Copyright (C) 2011-2015 Markus Junginger, greenrobot (http://greenrobot.de)
  *
  * This file is part of greenDAO Generator.
  * 
@@ -21,8 +21,10 @@
 import java.util.Date;
 import java.util.List;
 
+import de.greenrobot.dao.internal.SqlUtils;
 import de.greenrobot.dao.query.Query;
 import de.greenrobot.dao.query.QueryBuilder;
+import de.greenrobot.dao.query.WhereCondition;
 import de.greenrobot.daotest.TestEntity;
 import de.greenrobot.daotest.TestEntityDao.Properties;
 import de.greenrobot.daotest.entity.TestEntityTestBase;
@@ -135,7 +137,11 @@ public void testEqDate() {
         testEntity.setSimpleDate(date);
         dao.update(testEntity);
 
-        TestEntity testEntity2 = dao.queryBuilder().where(Properties.SimpleDate.eq(date)).uniqueOrThrow();
+        Query<TestEntity> queryDate = dao.queryBuilder().where(Properties.SimpleDate.eq(date)).build();
+        TestEntity testEntity2 = queryDate.uniqueOrThrow();
+        assertEquals(testEntity.getId(), testEntity2.getId());
+        queryDate.setParameter(0, date);
+        testEntity2 = queryDate.uniqueOrThrow();
         assertEquals(testEntity.getId(), testEntity2.getId());
 
         testEntity2 = dao.queryBuilder().where(Properties.SimpleDate.eq(date.getTime())).uniqueOrThrow();
@@ -149,7 +155,11 @@ public void testEqBoolean() {
         testEntity.setSimpleBoolean(true);
         dao.update(testEntity);
 
-        TestEntity testEntity2 = dao.queryBuilder().where(Properties.SimpleBoolean.eq(true)).uniqueOrThrow();
+        Query<TestEntity> queryBoolean = dao.queryBuilder().where(Properties.SimpleBoolean.eq(true)).build();
+        TestEntity testEntity2 = queryBoolean.uniqueOrThrow();
+        assertEquals(testEntity.getId(), testEntity2.getId());
+        queryBoolean.setParameter(0, true);
+        testEntity2 = queryBoolean.uniqueOrThrow();
         assertEquals(testEntity.getId(), testEntity2.getId());
 
         testEntity2 = dao.queryBuilder().where(Properties.SimpleBoolean.eq(Boolean.TRUE)).uniqueOrThrow();
@@ -162,6 +172,31 @@ public void testEqBoolean() {
         assertEquals(testEntity.getId(), testEntity2.getId());
     }
 
+    // TODO fix byte arrays? Android is doing String args everywhere
+    public void testEqByteArray() {
+        ArrayList<TestEntity> inserted = insert(3);
+        TestEntity testEntity = inserted.get(1);
+
+        byte[] byteArray = {96, 77, 37, -21};
+        testEntity.setSimpleByteArray(byteArray);
+        dao.update(testEntity);
+
+        // Unsupported: Query<TestEntity> query = dao.queryBuilder().where(Properties.SimpleByteArray.eq(byteArray)).build();
+
+        // Works, but probably voids any index on BLOBs (Note: there's no hex2blob function and X'?' is bad syntax):
+        // String conditionString = "HEX(" + Properties.SimpleByteArray.columnName + ")=?";
+        // WhereCondition condition = new WhereCondition.StringCondition(conditionString, SqlUtils.toHex(byteArray));
+
+        String conditionString = Properties.SimpleByteArray.columnName + '=' + SqlUtils.escapeBlobArgument(byteArray);
+        WhereCondition condition = new WhereCondition.StringCondition(conditionString);
+        Query<TestEntity> query = dao.queryBuilder().where(condition).build();
+        TestEntity testEntity2 = query.uniqueOrThrow();
+        assertEquals(testEntity.getId(), testEntity2.getId());
+
+        // Unsupported: query.setParameter(0, new byte[]{96, 77, 37, -21, 99});
+        // Unsupported: assertNull(query.unique());
+    }
+
     public void testIsNullIsNotNull() {
         ArrayList<TestEntity> inserted = insert(2);
         TestEntity testEntityNull = inserted.get(0);
@@ -201,18 +236,28 @@ public void testLike() {
         Query<TestEntity> query = dao.queryBuilder().where(Properties.SimpleString.like("%robot")).build();
         TestEntity entity2 = query.uniqueOrThrow();
         assertEquals(entity.getId(), entity2.getId());
-        
+
         query.setParameter(0, "green%");
         entity2 = query.uniqueOrThrow();
         assertEquals(entity.getId(), entity2.getId());
-        
+
         query.setParameter(0, "%enrob%");
         entity2 = query.uniqueOrThrow();
         assertEquals(entity.getId(), entity2.getId());
-        
+
         query.setParameter(0, "%nothere%");
         entity2 = query.unique();
         assertNull(entity2);
     }
 
+    public void testDistinct() {
+        TestEntity entity = insert(3).get(1);
+
+        Query<TestEntity> query = dao.queryBuilder().distinct()
+                .where(Properties.SimpleString.eq(entity.getSimpleString())).build();
+        TestEntity entity2 = query.uniqueOrThrow();
+        assertEquals(entity.getId(), entity2.getId());
+        // TODO improve test to check functionality
+    }
+
 }
diff --git a/DaoTest/src/de/greenrobot/daotest/query/QueryLimitOffsetTest.java b/DaoTest/src/de/greenrobot/daotest/query/QueryLimitOffsetTest.java
index 6d0d4865..96593fab 100644
--- a/DaoTest/src/de/greenrobot/daotest/query/QueryLimitOffsetTest.java
+++ b/DaoTest/src/de/greenrobot/daotest/query/QueryLimitOffsetTest.java
@@ -1,124 +1,124 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daotest.query;
-
-import java.util.List;
-
-import de.greenrobot.dao.query.Query;
-import de.greenrobot.dao.query.QueryBuilder;
-import de.greenrobot.daotest.TestEntity;
-import de.greenrobot.daotest.TestEntityDao.Properties;
-import de.greenrobot.daotest.entity.TestEntityTestBase;
-
-public class QueryLimitOffsetTest extends TestEntityTestBase {
-    
-    @Override
-    protected void setUp() throws Exception {
-        super.setUp();
-        QueryBuilder.LOG_SQL = true;
-        QueryBuilder.LOG_VALUES = true;
-    }
-
-    public void testQueryBuilderLimit() {
-        insert(10);
-        List<TestEntity> result = dao.queryBuilder().limit(3).orderAsc(Properties.SimpleInt).list();
-        assertEquals(3, result.size());
-
-        assertEquals(getSimpleInteger(0), result.get(0).getSimpleInteger().intValue());
-        assertEquals(getSimpleInteger(1), result.get(1).getSimpleInteger().intValue());
-        assertEquals(getSimpleInteger(2), result.get(2).getSimpleInteger().intValue());
-    }
-
-    public void testQueryBuilderOffsetAndLimit() {
-        insert(10);
-        List<TestEntity> result = dao.queryBuilder().offset(3).limit(3).orderAsc(Properties.SimpleInt).list();
-        assertEquals(3, result.size());
-
-        assertEquals(getSimpleInteger(3), result.get(0).getSimpleInteger().intValue());
-        assertEquals(getSimpleInteger(4), result.get(1).getSimpleInteger().intValue());
-        assertEquals(getSimpleInteger(5), result.get(2).getSimpleInteger().intValue());
-    }
-
-    public void testQueryBuilderOffsetAndLimitWithWhere() {
-        insert(10);
-        List<TestEntity> result = dao.queryBuilder().where(Properties.SimpleInteger.gt(getSimpleInteger(1))).offset(2)
-                .limit(3).orderAsc(Properties.SimpleInt).list();
-        assertEquals(3, result.size());
-
-        assertEquals(getSimpleInteger(4), result.get(0).getSimpleInteger().intValue());
-        assertEquals(getSimpleInteger(5), result.get(1).getSimpleInteger().intValue());
-        assertEquals(getSimpleInteger(6), result.get(2).getSimpleInteger().intValue());
-    }
-
-    public void testQueryOffsetAndLimit() {
-        insert(10);
-        Query<TestEntity> query = dao.queryBuilder().where(Properties.SimpleInteger.gt(getSimpleInteger(-1))).offset(-1)
-                .limit(-1).orderAsc(Properties.SimpleInt).build(); 
-        query.setParameter(0, getSimpleInteger(1));
-        query.setLimit(3);
-        query.setOffset(2);
-        List<TestEntity> result = query.list();
-        assertEquals(3, result.size());
-
-        assertEquals(getSimpleInteger(4), result.get(0).getSimpleInteger().intValue());
-        assertEquals(getSimpleInteger(5), result.get(1).getSimpleInteger().intValue());
-        assertEquals(getSimpleInteger(6), result.get(2).getSimpleInteger().intValue());
-    }
-    
-    public void testQueryBuilderOffsetWithoutLimit() {
-        try{
-            dao.queryBuilder().offset(7).orderAsc(Properties.SimpleInt).build();
-            fail("Offset may not be set alone");
-        } catch(RuntimeException expected) {
-            //OK
-        }
-    }
-    
-    public void testQueryLimitAndSetParameter() {
-        Query<TestEntity> query = dao.queryBuilder().limit(5).offset(1).build();
-        try{
-            query.setParameter(0, null);
-            fail("Offset/limit parameters must not interfere with user parameters");
-        } catch(RuntimeException expected) {
-            //OK
-        }
-    }
-    
-    public void testQueryUnsetLimit() {
-        Query<TestEntity> query = dao.queryBuilder().build();
-        try{
-            query.setLimit(1);
-            fail("Limit must be defined in builder first");
-        } catch(RuntimeException expected) {
-            //OK
-        }
-    } 
-
-    public void testQueryUnsetOffset() {
-        Query<TestEntity> query = dao.queryBuilder().limit(1).build();
-        try{
-            query.setOffset(1);
-            fail("Offset must be defined in builder first");
-        } catch(RuntimeException expected) {
-            //OK
-        }
-    } 
-
-
-
-}
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.query;
+
+import java.util.List;
+
+import de.greenrobot.dao.query.Query;
+import de.greenrobot.dao.query.QueryBuilder;
+import de.greenrobot.daotest.TestEntity;
+import de.greenrobot.daotest.TestEntityDao.Properties;
+import de.greenrobot.daotest.entity.TestEntityTestBase;
+
+public class QueryLimitOffsetTest extends TestEntityTestBase {
+    
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        QueryBuilder.LOG_SQL = true;
+        QueryBuilder.LOG_VALUES = true;
+    }
+
+    public void testQueryBuilderLimit() {
+        insert(10);
+        List<TestEntity> result = dao.queryBuilder().limit(3).orderAsc(Properties.SimpleInt).list();
+        assertEquals(3, result.size());
+
+        assertEquals(getSimpleInteger(0), result.get(0).getSimpleInteger().intValue());
+        assertEquals(getSimpleInteger(1), result.get(1).getSimpleInteger().intValue());
+        assertEquals(getSimpleInteger(2), result.get(2).getSimpleInteger().intValue());
+    }
+
+    public void testQueryBuilderOffsetAndLimit() {
+        insert(10);
+        List<TestEntity> result = dao.queryBuilder().offset(3).limit(3).orderAsc(Properties.SimpleInt).list();
+        assertEquals(3, result.size());
+
+        assertEquals(getSimpleInteger(3), result.get(0).getSimpleInteger().intValue());
+        assertEquals(getSimpleInteger(4), result.get(1).getSimpleInteger().intValue());
+        assertEquals(getSimpleInteger(5), result.get(2).getSimpleInteger().intValue());
+    }
+
+    public void testQueryBuilderOffsetAndLimitWithWhere() {
+        insert(10);
+        List<TestEntity> result = dao.queryBuilder().where(Properties.SimpleInteger.gt(getSimpleInteger(1))).offset(2)
+                .limit(3).orderAsc(Properties.SimpleInt).list();
+        assertEquals(3, result.size());
+
+        assertEquals(getSimpleInteger(4), result.get(0).getSimpleInteger().intValue());
+        assertEquals(getSimpleInteger(5), result.get(1).getSimpleInteger().intValue());
+        assertEquals(getSimpleInteger(6), result.get(2).getSimpleInteger().intValue());
+    }
+
+    public void testQueryOffsetAndLimit() {
+        insert(10);
+        Query<TestEntity> query = dao.queryBuilder().where(Properties.SimpleInteger.gt(getSimpleInteger(-1))).offset(-1)
+                .limit(-1).orderAsc(Properties.SimpleInt).build(); 
+        query.setParameter(0, getSimpleInteger(1));
+        query.setLimit(3);
+        query.setOffset(2);
+        List<TestEntity> result = query.list();
+        assertEquals(3, result.size());
+
+        assertEquals(getSimpleInteger(4), result.get(0).getSimpleInteger().intValue());
+        assertEquals(getSimpleInteger(5), result.get(1).getSimpleInteger().intValue());
+        assertEquals(getSimpleInteger(6), result.get(2).getSimpleInteger().intValue());
+    }
+    
+    public void testQueryBuilderOffsetWithoutLimit() {
+        try{
+            dao.queryBuilder().offset(7).orderAsc(Properties.SimpleInt).build();
+            fail("Offset may not be set alone");
+        } catch(RuntimeException expected) {
+            //OK
+        }
+    }
+    
+    public void testQueryLimitAndSetParameter() {
+        Query<TestEntity> query = dao.queryBuilder().limit(5).offset(1).build();
+        try{
+            query.setParameter(0, (Object) null);
+            fail("Offset/limit parameters must not interfere with user parameters");
+        } catch(RuntimeException expected) {
+            //OK
+        }
+    }
+    
+    public void testQueryUnsetLimit() {
+        Query<TestEntity> query = dao.queryBuilder().build();
+        try{
+            query.setLimit(1);
+            fail("Limit must be defined in builder first");
+        } catch(RuntimeException expected) {
+            //OK
+        }
+    } 
+
+    public void testQueryUnsetOffset() {
+        Query<TestEntity> query = dao.queryBuilder().limit(1).build();
+        try{
+            query.setOffset(1);
+            fail("Offset must be defined in builder first");
+        } catch(RuntimeException expected) {
+            //OK
+        }
+    } 
+
+
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/query/RawQueryTest.java b/DaoTest/src/de/greenrobot/daotest/query/RawQueryTest.java
index b44fa077..1a9126cc 100644
--- a/DaoTest/src/de/greenrobot/daotest/query/RawQueryTest.java
+++ b/DaoTest/src/de/greenrobot/daotest/query/RawQueryTest.java
@@ -1,90 +1,90 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daotest.query;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import de.greenrobot.dao.query.LazyList;
-import de.greenrobot.dao.query.Query;
-import de.greenrobot.dao.query.QueryBuilder;
-import de.greenrobot.daotest.TestEntity;
-import de.greenrobot.daotest.TestEntityDao.Properties;
-import de.greenrobot.daotest.entity.TestEntityTestBase;
-
-public class RawQueryTest extends TestEntityTestBase {
-    @Override
-    protected void setUp() throws Exception {
-        super.setUp();
-        QueryBuilder.LOG_SQL = true;
-        QueryBuilder.LOG_VALUES = true;
-    }
-
-    public void testRawQueryEmptySql() {
-        insert(3);
-        Query<TestEntity> query = dao.queryRawCreate("");
-        List<TestEntity> result = query.list();
-        assertEquals(3, result.size());
-    }
-
-    public void testRawQueryEqualsString() {
-        ArrayList<TestEntity> inserted = insert(3);
-        String value = getSimpleString(1);
-
-        String sql = "WHERE " + Properties.SimpleString.columnName + "=?";
-        List<TestEntity> result = dao.queryRawCreate(sql, value).list();
-        assertEquals(1, result.size());
-
-        TestEntity resultEntity = result.get(0);
-        assertEquals(value, resultEntity.getSimpleString());
-        assertEquals(inserted.get(1).getId(), resultEntity.getId());
-    }
-
-    public void testRawQueryCreate_setParameterInQuery() {
-        insert(3);
-        String value = getSimpleString(2);
-
-        String sql = "WHERE " + Properties.SimpleString.columnName + "=?";
-        Query<TestEntity> query = dao.queryRawCreate(sql, getSimpleString(1));
-        query.list();
-
-        query.setParameter(0, value);
-        List<TestEntity> result = query.list();
-
-        assertEquals(1, result.size());
-        assertEquals(value, result.get(0).getSimpleString());
-    }
-    
-    public void testRawQueryLazyList() {
-        ArrayList<TestEntity> list = insert(2);
-
-        LazyList<TestEntity> listLazy = dao.queryRawCreate("").listLazy();
-        assertEquals(list.size(), listLazy.size());
-        assertNull(listLazy.peak(0));
-        assertNull(listLazy.peak(1));
-
-        assertNotNull(listLazy.get(1));
-        assertNull(listLazy.peak(0));
-        assertNotNull(listLazy.peak(1));
-
-        assertNotNull(listLazy.get(0));
-        assertNotNull(listLazy.peak(0));
-        assertNotNull(listLazy.peak(1));
-    }
-
-}
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.query;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import de.greenrobot.dao.query.LazyList;
+import de.greenrobot.dao.query.Query;
+import de.greenrobot.dao.query.QueryBuilder;
+import de.greenrobot.daotest.TestEntity;
+import de.greenrobot.daotest.TestEntityDao.Properties;
+import de.greenrobot.daotest.entity.TestEntityTestBase;
+
+public class RawQueryTest extends TestEntityTestBase {
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        QueryBuilder.LOG_SQL = true;
+        QueryBuilder.LOG_VALUES = true;
+    }
+
+    public void testRawQueryEmptySql() {
+        insert(3);
+        Query<TestEntity> query = dao.queryRawCreate("");
+        List<TestEntity> result = query.list();
+        assertEquals(3, result.size());
+    }
+
+    public void testRawQueryEqualsString() {
+        ArrayList<TestEntity> inserted = insert(3);
+        String value = getSimpleString(1);
+
+        String sql = "WHERE " + Properties.SimpleString.columnName + "=?";
+        List<TestEntity> result = dao.queryRawCreate(sql, value).list();
+        assertEquals(1, result.size());
+
+        TestEntity resultEntity = result.get(0);
+        assertEquals(value, resultEntity.getSimpleString());
+        assertEquals(inserted.get(1).getId(), resultEntity.getId());
+    }
+
+    public void testRawQueryCreate_setParameterInQuery() {
+        insert(3);
+        String value = getSimpleString(2);
+
+        String sql = "WHERE " + Properties.SimpleString.columnName + "=?";
+        Query<TestEntity> query = dao.queryRawCreate(sql, getSimpleString(1));
+        query.list();
+
+        query.setParameter(0, value);
+        List<TestEntity> result = query.list();
+
+        assertEquals(1, result.size());
+        assertEquals(value, result.get(0).getSimpleString());
+    }
+    
+    public void testRawQueryLazyList() {
+        ArrayList<TestEntity> list = insert(2);
+
+        LazyList<TestEntity> listLazy = dao.queryRawCreate("").listLazy();
+        assertEquals(list.size(), listLazy.size());
+        assertNull(listLazy.peak(0));
+        assertNull(listLazy.peak(1));
+
+        assertNotNull(listLazy.get(1));
+        assertNull(listLazy.peak(0));
+        assertNotNull(listLazy.peak(1));
+
+        assertNotNull(listLazy.get(0));
+        assertNotNull(listLazy.peak(0));
+        assertNotNull(listLazy.peak(1));
+    }
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest2/entity/KeepEntityTest.java b/DaoTest/src/de/greenrobot/daotest2/entity/KeepEntityTest.java
index de181c1b..2e45b7af 100644
--- a/DaoTest/src/de/greenrobot/daotest2/entity/KeepEntityTest.java
+++ b/DaoTest/src/de/greenrobot/daotest2/entity/KeepEntityTest.java
@@ -1,43 +1,43 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daotest2.entity;
-
-import android.os.Build;
-import de.greenrobot.dao.test.AbstractDaoTestLongPk;
-import de.greenrobot.daotest2.KeepEntity;
-import de.greenrobot.daotest2.dao.KeepEntityDao;
-
-public class KeepEntityTest extends AbstractDaoTestLongPk<KeepEntityDao, KeepEntity> {
-
-    public KeepEntityTest() {
-        super(KeepEntityDao.class);
-    }
-
-    @Override
-    protected KeepEntity createEntity(Long key) {
-        KeepEntity entity = new KeepEntity();
-        entity.setId(key);
-        return entity;
-    }
-
-    public void testKeepSectionAvailable() {
-        KeepEntity keepEntity = new KeepEntity(42l);
-        assertEquals("KeepEntity ID=42 (extra="+Build.VERSION.SDK+")", keepEntity.toString());
-    }
-
-}
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest2.entity;
+
+import android.os.Build;
+import de.greenrobot.dao.test.AbstractDaoTestLongPk;
+import de.greenrobot.daotest2.KeepEntity;
+import de.greenrobot.daotest2.dao.KeepEntityDao;
+
+public class KeepEntityTest extends AbstractDaoTestLongPk<KeepEntityDao, KeepEntity> {
+
+    public KeepEntityTest() {
+        super(KeepEntityDao.class);
+    }
+
+    @Override
+    protected KeepEntity createEntity(Long key) {
+        KeepEntity entity = new KeepEntity();
+        entity.setId(key);
+        return entity;
+    }
+
+    public void testKeepSectionAvailable() {
+        KeepEntity keepEntity = new KeepEntity(42l);
+        assertEquals("KeepEntity ID=42 (extra="+Build.VERSION.SDK+")", keepEntity.toString());
+    }
+
+}
diff --git a/DaoTestGenerator/build.gradle b/DaoTestGenerator/build.gradle
new file mode 100644
index 00000000..fad5dbbd
--- /dev/null
+++ b/DaoTestGenerator/build.gradle
@@ -0,0 +1,13 @@
+apply plugin: 'java'
+
+sourceSets {
+    main {
+        java {
+            srcDir 'src'
+        }
+    }
+}
+
+dependencies {
+    compile project(':DaoGenerator')
+}
diff --git a/DaoGenerator/src-generator-testentities/de/greenrobot/daogenerator/gentest/TestDaoGenerator.java b/DaoTestGenerator/src/de/greenrobot/daogenerator/gentest/TestDaoGenerator.java
similarity index 77%
rename from DaoGenerator/src-generator-testentities/de/greenrobot/daogenerator/gentest/TestDaoGenerator.java
rename to DaoTestGenerator/src/de/greenrobot/daogenerator/gentest/TestDaoGenerator.java
index 47bba961..f42d1d36 100644
--- a/DaoGenerator/src-generator-testentities/de/greenrobot/daogenerator/gentest/TestDaoGenerator.java
+++ b/DaoTestGenerator/src/de/greenrobot/daogenerator/gentest/TestDaoGenerator.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ * Copyright (C) 2011-2015 Markus Junginger, greenrobot (http://greenrobot.de)
  *
  * This file is part of greenDAO Generator.
  * 
@@ -25,7 +25,7 @@
 
 /**
  * Generates test entities for test project DaoTest.
- * 
+ *
  * @author Markus
  */
 public class TestDaoGenerator {
@@ -35,9 +35,11 @@ public static void main(String[] args) throws Exception {
         testDaoGenerator.generate();
     }
 
-    private Schema schema;
-    private Entity testEntity;
-    private Schema schema2;
+    private final Schema schema;
+    private final Entity testEntity;
+    private final Entity dateEntity;
+    private final Schema schema2;
+    private final Schema schemaUnitTest;
 
     public TestDaoGenerator() {
         schema = new Schema(1, "de.greenrobot.daotest");
@@ -47,7 +49,7 @@ public TestDaoGenerator() {
         createSimpleNotNull();
         testEntity = createTest();
         createRelation();
-        createDate();
+        dateEntity = createDate();
         createSpecialNames();
         createAbcdef();
         createToMany();
@@ -57,14 +59,18 @@ public TestDaoGenerator() {
         createStringKeyValue();
         createAutoincrement();
         createSqliteMaster();
+        createCustomType();
+        createIndexedString();
 
-        createSchema2();
+        schema2 = createSchema2();
+        schemaUnitTest = createSchemaUnitTest();
     }
 
     public void generate() throws Exception {
         DaoGenerator daoGenerator = new DaoGenerator();
-        daoGenerator.generateAll(schema, "../DaoTest/src-gen", "../DaoTest/src");
-        daoGenerator.generateAll(schema2, "../DaoTest/src-gen", "../DaoTest/src");
+        daoGenerator.generateAll(schema, "../DaoTest/src-gen", null, "../DaoTest/src");
+        daoGenerator.generateAll(schema2, "../DaoTest/src-gen", null, "../DaoTest/src");
+        daoGenerator.generateAll(schemaUnitTest, "../DaoTest/src-unit-test", null, "../DaoTest/src-unit-test");
     }
 
     protected void createSimple() {
@@ -79,7 +85,7 @@ protected void createSimple() {
         simple.addDoubleProperty("simpleDouble");
         simple.addStringProperty("simpleString");
         simple.addByteArrayProperty("simpleByteArray");
-        
+
         simple.addContentProvider().readOnly();
     }
 
@@ -99,15 +105,19 @@ protected void createSimpleNotNull() {
 
     protected Entity createTest() {
         Entity testEntity = schema.addEntity("TestEntity");
-        testEntity.addIdProperty();
-        testEntity.addIntProperty("simpleInt").notNull();
-        testEntity.addIntProperty("simpleInteger");
-        testEntity.addStringProperty("simpleStringNotNull").notNull();
+        testEntity.setJavaDoc("This entity is used by internal tests of greenDAO.\n" +
+                "(This JavaDoc is defined in the generator project.)");
+        testEntity.setCodeBeforeClass("// This is another test comment, you could also apply annotations like this");
+        testEntity.addIdProperty().javaDocField("JavaDoc test field");
+        testEntity.addIntProperty("simpleInt").notNull().javaDocGetter("JavaDoc test getter");
+        testEntity.addIntProperty("simpleInteger").javaDocSetter("JavaDoc test setter");
+        testEntity.addStringProperty("simpleStringNotNull").notNull().javaDocGetterAndSetter("JavaDoc test getter and setter");
         testEntity.addStringProperty("simpleString");
         testEntity.addStringProperty("indexedString").index();
         testEntity.addStringProperty("indexedStringAscUnique").indexAsc(null, true);
         testEntity.addDateProperty("simpleDate");
         testEntity.addBooleanProperty("simpleBoolean");
+        testEntity.addByteArrayProperty("simpleByteArray");
         return testEntity;
     }
 
@@ -147,12 +157,19 @@ protected void createToMany() {
         toManyByJoinProperty.setName("toManyByJoinProperty");
         toManyByJoinProperty.orderAsc(targetIdProperty);
 
-        Property[] sourceProperties = { sourceIdProperty, sourceJoinProperty };
-        Property[] targetProperties = { toManyIdProperty, targetJoinProperty };
+        Property[] sourceProperties = {sourceIdProperty, sourceJoinProperty};
+        Property[] targetProperties = {toManyIdProperty, targetJoinProperty};
         ToMany toManyJoinTwo = toManyEntity.addToMany(sourceProperties, toManyTargetEntity, targetProperties);
         toManyJoinTwo.setName("toManyJoinTwo");
         toManyJoinTwo.orderDesc(targetJoinProperty);
         toManyJoinTwo.orderDesc(targetIdProperty);
+
+        Entity toManyJoinEntity = schema.addEntity("JoinManyToDateEntity");
+        toManyJoinEntity.addIdProperty();
+        Property id1 = toManyJoinEntity.addLongProperty("idToMany").getProperty();
+        Property id2 = toManyJoinEntity.addLongProperty("idDate").getProperty();
+
+        toManyEntity.addToMany(dateEntity, toManyJoinEntity, id1, id2);
     }
 
     protected void createTreeEntity() {
@@ -163,15 +180,19 @@ protected void createTreeEntity() {
         treeEntity.addToMany(treeEntity, parentIdProperty).setName("children");
     }
 
-    protected void createDate() {
+    protected Entity createDate() {
         Entity dateEntity = schema.addEntity("DateEntity");
         dateEntity.addIdProperty();
-        dateEntity.addDateProperty("date");
+        dateEntity.addDateProperty("date").codeBeforeField("// Test code for\n    // field")
+        .codeBeforeGetter("// Test code for\n    // getter").codeBeforeSetter("// Test code for\n    // setter");
+        dateEntity.addImport("java.lang.String");
         dateEntity.addDateProperty("dateNotNull").notNull();
+        return dateEntity;
     }
 
     protected void createSpecialNames() {
         Entity specialNamesEntity = schema.addEntity("SpecialNamesEntity");
+        specialNamesEntity.setTableName("ORDER TRANSACTION GROUP BY");
         specialNamesEntity.addIdProperty();
         specialNamesEntity.addStringProperty("count");
         specialNamesEntity.addStringProperty("select");
@@ -216,8 +237,43 @@ protected void createExtendsImplements() {
         entity.implementsSerializable();
     }
 
-    private void createSchema2() {
-        schema2 = new Schema(1, "de.greenrobot.daotest2");
+    protected void createStringKeyValue() {
+        Entity entity = schema.addEntity("StringKeyValueEntity");
+        entity.addStringProperty("key").primaryKey();
+        entity.addStringProperty("value");
+    }
+
+    protected void createAutoincrement() {
+        Entity entity = schema.addEntity("AutoincrementEntity");
+        entity.addIdProperty().autoincrement();
+    }
+
+    protected void createSqliteMaster() {
+        Entity entity = schema.addEntity("SqliteMaster");
+        entity.setSkipTableCreation(true);
+        entity.setHasKeepSections(true);
+        entity.addStringProperty("type");
+        entity.addStringProperty("name");
+        entity.addStringProperty("tableName").columnName("tbl_name");
+        entity.addLongProperty("rootpage");
+        entity.addStringProperty("sql");
+    }
+
+    protected void createCustomType() {
+        Entity entity = schema.addEntity("CustomTypeEntity");
+        entity.addIdProperty();
+        entity.addLongProperty("myCustomTimestamp").customType("de.greenrobot.daotest.customtype.MyTimestamp",
+                "de.greenrobot.daotest.customtype.MyTimestampConverter");
+    }
+
+    protected void createIndexedString() {
+        Entity entity = schema.addEntity("IndexedStringEntity");
+        entity.addIdProperty();
+        entity.addStringProperty("indexedString").index();
+    }
+
+    private Schema createSchema2() {
+        Schema schema2 = new Schema(1, "de.greenrobot.daotest2");
         schema2.setDefaultJavaPackageTest("de.greenrobot.daotest2.entity");
         schema2.setDefaultJavaPackageDao("de.greenrobot.daotest2.dao");
         schema2.enableKeepSectionsByDefault();
@@ -246,28 +302,15 @@ private void createSchema2() {
         relationSource2.setJavaPackageDao("de.greenrobot.daotest2.specialdao");
         relationSource2.setJavaPackageTest("de.greenrobot.daotest2.specialtest");
         relationSource2.setSkipGenerationTest(true);
+        return schema2;
     }
 
-    protected void createStringKeyValue() {
-        Entity entity = schema.addEntity("StringKeyValueEntity");
-        entity.addStringProperty("key").primaryKey();
-        entity.addStringProperty("value");
-    }
-
-    protected void createAutoincrement() {
-        Entity entity = schema.addEntity("AutoincrementEntity");
-        entity.addIdProperty().autoincrement();
-    }
+    private Schema createSchemaUnitTest() {
+        Schema schema = new Schema(1, "de.greenrobot.dao.unittest");
 
-    protected void createSqliteMaster() {
-        Entity entity = schema.addEntity("SqliteMaster");
-        entity.setSkipTableCreation(true);
-        entity.setHasKeepSections(true);
-        entity.addStringProperty("type");
-        entity.addStringProperty("name");
-        entity.addStringProperty("tableName").columnName("tbl_name");
-        entity.addLongProperty("rootpage");
-        entity.addStringProperty("sql");
+        Entity entity = schema.addEntity("MinimalEntity");
+        entity.addIdProperty();
+        return schema;
     }
 
 }
diff --git a/PerformanceTestOrmLite/.classpath b/PerformanceTestOrmLite/.classpath
deleted file mode 100644
index 2a829e2f..00000000
--- a/PerformanceTestOrmLite/.classpath
+++ /dev/null
@@ -1,11 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="src" path="gen"/>
-	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
-	<classpathentry kind="lib" path="lib/ormlite-android-4.34-SNAPSHOT.jar"/>
-	<classpathentry kind="lib" path="lib/ormlite-core-4.34-SNAPSHOT.jar"/>
-	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
-	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
-	<classpathentry kind="output" path="bin/classes"/>
-</classpath>
diff --git a/PerformanceTestOrmLite/.gitignore b/PerformanceTestOrmLite/.gitignore
deleted file mode 100644
index a02fbbe0..00000000
--- a/PerformanceTestOrmLite/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-/gen
-/bin
diff --git a/PerformanceTestOrmLite/.project b/PerformanceTestOrmLite/.project
deleted file mode 100644
index 2d8adef0..00000000
--- a/PerformanceTestOrmLite/.project
+++ /dev/null
@@ -1,33 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<projectDescription>
-	<name>PerformanceTestOrmLite</name>
-	<comment></comment>
-	<projects>
-	</projects>
-	<buildSpec>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>org.eclipse.jdt.core.javabuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-	</buildSpec>
-	<natures>
-		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
-		<nature>org.eclipse.jdt.core.javanature</nature>
-	</natures>
-</projectDescription>
diff --git a/PerformanceTestOrmLite/.settings/org.eclipse.core.resources.prefs b/PerformanceTestOrmLite/.settings/org.eclipse.core.resources.prefs
deleted file mode 100644
index 3d916f29..00000000
--- a/PerformanceTestOrmLite/.settings/org.eclipse.core.resources.prefs
+++ /dev/null
@@ -1,2 +0,0 @@
-eclipse.preferences.version=1
-encoding/<project>=Cp1252
diff --git a/PerformanceTestOrmLite/AndroidManifest.xml b/PerformanceTestOrmLite/AndroidManifest.xml
deleted file mode 100644
index 47a10c35..00000000
--- a/PerformanceTestOrmLite/AndroidManifest.xml
+++ /dev/null
@@ -1,14 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<manifest
-	xmlns:android="http://schemas.android.com/apk/res/android"
-	package="de.greenrobot.performance.ormlite"
-	android:versionCode="1"
-	android:versionName="1.0">
-	<uses-sdk android:minSdkVersion="4" />
-	<instrumentation
-		android:targetPackage="de.greenrobot.performance.ormlite"
-		android:name="android.test.InstrumentationTestRunner" />
-	<application>
-		<uses-library android:name="android.test.runner" />
-	</application>
-</manifest>
\ No newline at end of file
diff --git a/PerformanceTestOrmLite/lib/ormlite-android-4.34-SNAPSHOT.jar b/PerformanceTestOrmLite/lib/ormlite-android-4.34-SNAPSHOT.jar
deleted file mode 100644
index 7c41c0b9..00000000
Binary files a/PerformanceTestOrmLite/lib/ormlite-android-4.34-SNAPSHOT.jar and /dev/null differ
diff --git a/PerformanceTestOrmLite/lib/ormlite-core-4.34-SNAPSHOT.jar b/PerformanceTestOrmLite/lib/ormlite-core-4.34-SNAPSHOT.jar
deleted file mode 100644
index 24299339..00000000
Binary files a/PerformanceTestOrmLite/lib/ormlite-core-4.34-SNAPSHOT.jar and /dev/null differ
diff --git a/PerformanceTestOrmLite/proguard.cfg b/PerformanceTestOrmLite/proguard.cfg
deleted file mode 100644
index b1cdf17b..00000000
--- a/PerformanceTestOrmLite/proguard.cfg
+++ /dev/null
@@ -1,40 +0,0 @@
--optimizationpasses 5
--dontusemixedcaseclassnames
--dontskipnonpubliclibraryclasses
--dontpreverify
--verbose
--optimizations !code/simplification/arithmetic,!field/*,!class/merging/*
-
--keep public class * extends android.app.Activity
--keep public class * extends android.app.Application
--keep public class * extends android.app.Service
--keep public class * extends android.content.BroadcastReceiver
--keep public class * extends android.content.ContentProvider
--keep public class * extends android.app.backup.BackupAgentHelper
--keep public class * extends android.preference.Preference
--keep public class com.android.vending.licensing.ILicensingService
-
--keepclasseswithmembernames class * {
-    native <methods>;
-}
-
--keepclasseswithmembers class * {
-    public <init>(android.content.Context, android.util.AttributeSet);
-}
-
--keepclasseswithmembers class * {
-    public <init>(android.content.Context, android.util.AttributeSet, int);
-}
-
--keepclassmembers class * extends android.app.Activity {
-   public void *(android.view.View);
-}
-
--keepclassmembers enum * {
-    public static **[] values();
-    public static ** valueOf(java.lang.String);
-}
-
--keep class * implements android.os.Parcelable {
-  public static final android.os.Parcelable$Creator *;
-}
diff --git a/PerformanceTestOrmLite/project.properties b/PerformanceTestOrmLite/project.properties
deleted file mode 100644
index c957743c..00000000
--- a/PerformanceTestOrmLite/project.properties
+++ /dev/null
@@ -1,11 +0,0 @@
-# This file is automatically generated by Android Tools.
-# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
-#
-# This file must be checked in Version Control Systems.
-#
-# To customize properties used by the Ant build system use,
-# "ant.properties", and override values to adapt the script to your
-# project structure.
-
-# Project target.
-target=android-4
diff --git a/PerformanceTestOrmLite/res/values/dummy.xml b/PerformanceTestOrmLite/res/values/dummy.xml
deleted file mode 100644
index 57c3367b..00000000
--- a/PerformanceTestOrmLite/res/values/dummy.xml
+++ /dev/null
@@ -1,4 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<resources>
-    
-</resources>
\ No newline at end of file
diff --git a/PerformanceTestOrmLite/src/de/greenrobot/performance/ormlite/DbHelper.java b/PerformanceTestOrmLite/src/de/greenrobot/performance/ormlite/DbHelper.java
deleted file mode 100644
index 18d0d83d..00000000
--- a/PerformanceTestOrmLite/src/de/greenrobot/performance/ormlite/DbHelper.java
+++ /dev/null
@@ -1,39 +0,0 @@
-package de.greenrobot.performance.ormlite;
-
-import android.content.Context;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteOpenHelper;
-
-public class DbHelper extends SQLiteOpenHelper {
-
-    public DbHelper(Context context, String name) {
-        super(context, name, null, 1);
-    }
-
-    @Override
-    public void onCreate(SQLiteDatabase db) {
-        String sql = "CREATE TABLE SIMPLE_ENTITY_NOT_NULL (" + //
-                "_id INTEGER PRIMARY KEY NOT NULL ," + // 0
-                "SIMPLE_BOOLEAN INTEGER NOT NULL ," + // 1
-                "SIMPLE_BYTE INTEGER NOT NULL ," + // 2
-                "SIMPLE_SHORT INTEGER NOT NULL ," + // 3
-                "SIMPLE_INT INTEGER NOT NULL ," + // 4
-                "SIMPLE_LONG INTEGER NOT NULL ," + // 5
-                "SIMPLE_FLOAT REAL NOT NULL ," + // 6
-                "SIMPLE_DOUBLE REAL NOT NULL ," + // 7
-                "SIMPLE_STRING TEXT NOT NULL ," + // 8
-                "SIMPLE_BYTE_ARRAY BLOB NOT NULL )"; // 9
-        db.execSQL(sql);
-        
-        String sql2 = "CREATE TABLE MINIMAL_ENTITY (_id INTEGER PRIMARY KEY)";
-        db.execSQL(sql2);
-    }
-
-    @Override
-    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
-        db.execSQL("DROP TABLE IF EXISTS SIMPLE_ENTITY_NOT_NULL");
-        db.execSQL("DROP TABLE IF EXISTS MINIMAL_ENTITY");
-        onCreate(db);
-    }
-
-}
diff --git a/PerformanceTestOrmLite/src/de/greenrobot/performance/ormlite/MinimalEntity.java b/PerformanceTestOrmLite/src/de/greenrobot/performance/ormlite/MinimalEntity.java
deleted file mode 100644
index 60fe3ef2..00000000
--- a/PerformanceTestOrmLite/src/de/greenrobot/performance/ormlite/MinimalEntity.java
+++ /dev/null
@@ -1,20 +0,0 @@
-package de.greenrobot.performance.ormlite;
-
-import com.j256.ormlite.field.DatabaseField;
-import com.j256.ormlite.table.DatabaseTable;
-
-@DatabaseTable(tableName = "MINIMAL_ENTITY")
-public class MinimalEntity {
-
-    @DatabaseField(id = true, columnName="_id")
-    private Long id;
-
-    public Long getId() {
-        return id;
-    }
-
-    public void setId(Long id) {
-        this.id = id;
-    }
-    
-}
diff --git a/PerformanceTestOrmLite/src/de/greenrobot/performance/ormlite/PerformanceTestOrmLite.java b/PerformanceTestOrmLite/src/de/greenrobot/performance/ormlite/PerformanceTestOrmLite.java
deleted file mode 100644
index ce65044f..00000000
--- a/PerformanceTestOrmLite/src/de/greenrobot/performance/ormlite/PerformanceTestOrmLite.java
+++ /dev/null
@@ -1,163 +0,0 @@
-package de.greenrobot.performance.ormlite;
-
-import java.sql.SQLException;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.concurrent.Callable;
-
-import android.app.Application;
-import android.test.ApplicationTestCase;
-import android.util.Log;
-
-import com.j256.ormlite.android.AndroidConnectionSource;
-import com.j256.ormlite.dao.Dao;
-import com.j256.ormlite.dao.DaoManager;
-
-public class PerformanceTestOrmLite extends ApplicationTestCase<Application> {
-
-    private Dao<SimpleEntityNotNull, Long> dao;
-    private boolean inMemory;
-    private DbHelper dbHelper;
-    private AndroidConnectionSource connectionSource;
-
-    public PerformanceTestOrmLite() {
-        super(Application.class);
-        inMemory = false;
-    }
-
-    @Override
-    protected void setUp() {
-        createApplication();
-        prepareDb();
-    }
-
-    protected void prepareDb() {
-        String name;
-        if (inMemory) {
-            name = null;
-        } else {
-            name = "test-db";
-            getApplication().deleteDatabase(name);
-        }
-        dbHelper = new DbHelper(getApplication(), name);
-        connectionSource = new AndroidConnectionSource(dbHelper);
-        try {
-            dao = DaoManager.createDao(connectionSource, SimpleEntityNotNull.class);
-        } catch (SQLException e) {
-            throw new RuntimeException(e);
-        }
-    }
-
-    @Override
-    protected void tearDown() throws Exception {
-        if (!inMemory) {
-            getApplication().deleteDatabase("test-db");
-        }
-    }
-
-    public void testPerformance() throws Exception {
-        runTests(100); // Warmup
-        deleteAll();
-        runTests(1000);
-        deleteAll();
-        runTests(1000);
-        deleteAll();
-        runTests(1000);
-        deleteAll();
-        runTests(1000);
-        deleteAll();
-        runTests(1000);
-        Log.d("DAO", "---------------End");
-    }
-
-    protected void deleteAll() {
-        dbHelper.getWritableDatabase().execSQL("DELETE FROM SIMPLE_ENTITY_NOT_NULL");
-    }
-
-    protected void runTests(int entityCount) throws Exception {
-        Log.d("DAO", "---------------Start: " + entityCount);
-
-        long start, time;
-
-        final List<SimpleEntityNotNull> list = new ArrayList<SimpleEntityNotNull>();
-        for (int i = 0; i < entityCount; i++) {
-            list.add(SimpleEntityNotNullHelper.createEntity((long) i));
-        }
-        System.gc();
-
-        runOneByOne(list, entityCount / 10);
-
-        System.gc();
-        deleteAll();
-
-        start = System.currentTimeMillis();
-        dao.callBatchTasks(new Callable<Void>() {
-
-            @Override
-            public Void call() throws Exception {
-                for (SimpleEntityNotNull entity : list) {
-                    dao.create(entity);
-                }
-                return null;
-            }
-        });
-        time = System.currentTimeMillis() - start;
-        Log.d("DAO", "ORMLite: Created (batch) " + list.size() + " entities in " + time + "ms");
-
-        start = System.currentTimeMillis();
-        dao.callBatchTasks(new Callable<Void>() {
-
-            @Override
-            public Void call() throws Exception {
-                for (SimpleEntityNotNull entity : list) {
-                    dao.update(entity);
-                }
-                return null;
-            }
-        });
-        time = System.currentTimeMillis() - start;
-        Log.d("DAO", "ORMLite: Updated (batch) " + list.size() + " entities in " + time + "ms");
-
-        start = System.currentTimeMillis();
-        List<SimpleEntityNotNull> reloaded = dao.queryForAll();
-        time = System.currentTimeMillis() - start;
-        Log.d("DAO", "ORMLite: Loaded " + reloaded.size() + " entities in " + time + "ms");
-
-        System.gc();
-        Log.d("DAO", "---------------End: " + entityCount);
-    }
-
-    protected void runOneByOne(List<SimpleEntityNotNull> list, int count) throws SQLException {
-        long start;
-        long time;
-        start = System.currentTimeMillis();
-        for (int i = 0; i < count; i++) {
-            dao.create(list.get(i));
-        }
-        time = System.currentTimeMillis() - start;
-        Log.d("DAO", "ORMLite: Inserted (one-by-one) " + count + " entities in " + time + "ms");
-
-        start = System.currentTimeMillis();
-        for (int i = 0; i < count; i++) {
-            dao.update(list.get(i));
-        }
-        time = System.currentTimeMillis() - start;
-        Log.d("DAO", "ORMLite: Updated (one-by-one) " + count + " entities in " + time + "ms");
-    }
-
-    public void testSemantics() {
-        try {
-            Dao<MinimalEntity, Long> minimalDao = DaoManager.createDao(connectionSource, MinimalEntity.class);
-            MinimalEntity data = new MinimalEntity();
-            minimalDao.create(data);
-            assertNull(data.getId()); // ORMLite does not update PK after insert
-            MinimalEntity data2 = minimalDao.queryForAll().get(0);
-            MinimalEntity data3 = minimalDao.queryForId(data2.getId());
-            assertNotSame(data, data2);
-            assertNotSame(data2, data3); // ORMLite does not provide object equality
-            assertEquals(data2.getId(), data3.getId());
-        } catch (SQLException e) {
-            throw new RuntimeException(e);
-        }
-    }
-}
diff --git a/PerformanceTestOrmLite/src/de/greenrobot/performance/ormlite/SimpleEntityNotNull.java b/PerformanceTestOrmLite/src/de/greenrobot/performance/ormlite/SimpleEntityNotNull.java
deleted file mode 100644
index cd404d82..00000000
--- a/PerformanceTestOrmLite/src/de/greenrobot/performance/ormlite/SimpleEntityNotNull.java
+++ /dev/null
@@ -1,116 +0,0 @@
-package de.greenrobot.performance.ormlite;
-
-import com.j256.ormlite.field.DataType;
-import com.j256.ormlite.field.DatabaseField;
-import com.j256.ormlite.table.DatabaseTable;
-
-
-/** 
- * Entity mapped to table SIMPLE_ENTITY_NOT_NULL (schema version 1).
-*/
-@DatabaseTable(tableName = "SIMPLE_ENTITY_NOT_NULL")
-public class SimpleEntityNotNull {
-
-    @DatabaseField(id = true, columnName="_id")
-    private long id;
-    
-    @DatabaseField(columnName="SIMPLE_BOOLEAN")
-    private boolean simpleBoolean;
-    @DatabaseField(columnName="SIMPLE_BYTE")
-    private byte simpleByte;
-    @DatabaseField(columnName="SIMPLE_SHORT")
-    private short simpleShort;
-    @DatabaseField(columnName="SIMPLE_INT")
-    private int simpleInt;
-    @DatabaseField(columnName="SIMPLE_LONG")
-    private long simpleLong;
-    @DatabaseField(columnName="SIMPLE_FLOAT")
-    private float simpleFloat;
-    @DatabaseField(columnName="SIMPLE_DOUBLE")
-    private double simpleDouble;
-    @DatabaseField(columnName="SIMPLE_STRING")
-    private String simpleString;
-    @DatabaseField(dataType=DataType.BYTE_ARRAY,columnName="SIMPLE_BYTE_ARRAY")
-    private byte[] simpleByteArray; 
-    
-    public long getId() {
-        return id;
-    } 
-
-    public void setId(long id) {
-        this.id = id;
-    } 
-
-    public boolean getSimpleBoolean() {
-        return simpleBoolean;
-    } 
-
-    public void setSimpleBoolean(boolean simpleBoolean) {
-        this.simpleBoolean = simpleBoolean;
-    } 
-
-    public byte getSimpleByte() {
-        return simpleByte;
-    } 
-
-    public void setSimpleByte(byte simpleByte) {
-        this.simpleByte = simpleByte;
-    } 
-
-    public short getSimpleShort() {
-        return simpleShort;
-    } 
-
-    public void setSimpleShort(short simpleShort) {
-        this.simpleShort = simpleShort;
-    } 
-
-    public int getSimpleInt() {
-        return simpleInt;
-    } 
-
-    public void setSimpleInt(int simpleInt) {
-        this.simpleInt = simpleInt;
-    } 
-
-    public long getSimpleLong() {
-        return simpleLong;
-    } 
-
-    public void setSimpleLong(long simpleLong) {
-        this.simpleLong = simpleLong;
-    } 
-
-    public float getSimpleFloat() {
-        return simpleFloat;
-    } 
-
-    public void setSimpleFloat(float simpleFloat) {
-        this.simpleFloat = simpleFloat;
-    } 
-
-    public double getSimpleDouble() {
-        return simpleDouble;
-    } 
-
-    public void setSimpleDouble(double simpleDouble) {
-        this.simpleDouble = simpleDouble;
-    } 
-
-    public String getSimpleString() {
-        return simpleString;
-    } 
-
-    public void setSimpleString(String simpleString) {
-        this.simpleString = simpleString;
-    } 
-
-    public byte[] getSimpleByteArray() {
-        return simpleByteArray;
-    } 
-
-    public void setSimpleByteArray(byte[] simpleByteArray) {
-        this.simpleByteArray = simpleByteArray;
-    } 
-
-}
diff --git a/PerformanceTestOrmLite/src/de/greenrobot/performance/ormlite/SimpleEntityNotNullHelper.java b/PerformanceTestOrmLite/src/de/greenrobot/performance/ormlite/SimpleEntityNotNullHelper.java
deleted file mode 100644
index a23f7497..00000000
--- a/PerformanceTestOrmLite/src/de/greenrobot/performance/ormlite/SimpleEntityNotNullHelper.java
+++ /dev/null
@@ -1,22 +0,0 @@
-package de.greenrobot.performance.ormlite;
-
-public class SimpleEntityNotNullHelper {
-    protected static SimpleEntityNotNull createEntity(Long key) {
-        if (key == null) {
-            return null;
-        }
-        SimpleEntityNotNull entity = new SimpleEntityNotNull();
-        entity.setId(key);
-        entity.setSimpleBoolean(true);
-        entity.setSimpleByte(Byte.MAX_VALUE);
-        entity.setSimpleShort(Short.MAX_VALUE);
-        entity.setSimpleInt(Integer.MAX_VALUE);
-        entity.setSimpleLong(Long.MAX_VALUE);
-        entity.setSimpleFloat(Float.MAX_VALUE);
-        entity.setSimpleDouble(Double.MAX_VALUE);
-        entity.setSimpleString("greenrobot greenDAO");
-        byte[] bytes = { 42, -17, 23, 0, 127, -128 };
-        entity.setSimpleByteArray(bytes);
-        return entity;
-    }
-}
diff --git a/README.md b/README.md
index 48fee8b3..31752516 100644
--- a/README.md
+++ b/README.md
@@ -2,113 +2,54 @@ greenDAO
 ========
 greenDAO is a light & fast ORM solution for Android that maps objects to SQLite databases. Being highly optimized for Android, greenDAO offers great performance and consumes minimal memory.
 
-Home page, documentation, and support links: http://greendao-orm.com/
+**<font size="+1">Home page, documentation, and support links: http://greenrobot.org/greendao/</font>**
 
 [![Build Status](https://travis-ci.org/greenrobot/greenDAO.svg?branch=master)](https://travis-ci.org/greenrobot/greenDAO)
 
-Upcoming features
------------------
-New features ahead for the brave: documentation and test coverage may be lacking. Give it a shot if you dare. API may change in the future. 
-### Asynchronous API
-* New AsyncSession (acquired from DaoSession.startAsyncSession()) provides most operations for DAOs, Queries, and transactions in a asynchronously variant
-* AsyncOperations are processed in order by a background thread
-* waitForCompletion methods for AsyncSession and AsyncOperations
-* AsyncOperationListener for asynchronous callback when operations complete
-* Asynchronous operations can be merged in single transactions (details follow)
-* Added raw SQL queries returning a Query object (LazyList support etc.)
-
-Release History
----------------
-### Generator V1.3.1 (2015-05-24): Bugfix
-* Fix schema version >= 1000
-
-### V1.3.7 (2013-11-27): Bugfix
-* Fixed building defect DeleteQuery for tables ending with character 'T' (bug introduced in 1.3.3)
-* Prepared Fast Cursor for API level 19
-
-### V1.3.6 (2013-11-15): Bugfix
-* Fixed leaked statement in DeleteQuery
-
-### V1.3.5 (2013-11-14): Bugfix
-* Because of an issue with ApplicationTestCase, the base test class DbTest does not extend this class anymore.
-Note: This refactoring may require you to adjust some test classes if your tests depend on DbTest or its subclasses.
+Features
+--------
+greenDAO has a unique set of features:
 
-### V1.3.4 (2013-10-28): Bugfix
-* Redeployment of 1.3.3 artifacts without some old class leftovers
+* Rock solid: greenDAO has been around since 2011 and is used by countless famous apps
+* Super simple: concise and straight-forward API
+* Small: The library is <100K and it's just plain Java jar (no CPU dependent native parts)
+* Fast: Probably the fastest ORM for Android, driven by intelligent code generation
+* Safe and expressive query API: QueryBuilder uses property constants to avoid typos
+* V2.0.0 Powerful joins: query across entities and even chain joins for complex relations
+* V2.0.0 Flexible property types: use custom classes or enums to represent data in your entity
 
-### V1.3.3 (2013-10-18): Bugfix
-* Fixed a memory leak affecting Query class that was introduced in 1.3.0 (#93)
-* Fixed a rare race condition that can lead to "Entity is detached from DAO context" DaoException (#101)
 
-### V1.3.2 (2013-08-28): Bugfix
-* Fixed building CountQueries with combined AND/OR conditions
-* Some secret inoffical work in progress
+Add greenDAO to your project
+----------------------------
+greenDAO is available on Maven Central. Please ensure that you are using the latest versions by [checking here](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22de.greenrobot%22%20AND%20a%3A%22greendao%22) [and here](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22de.greenrobot%22%20AND%20a%3A%22greendao-generator%22)
 
-### V1.3.1 (2013-03-02): Fixed Gradle dependencies
-* Don't use Gradle's "compile" dependency scope
+Gradle dependency for your Android app:
+```
+    compile 'de.greenrobot:greendao:2.0.0'
+```
 
-### V1.3.0 (2013-02-24): Multithreading robustness and refactoring (breaking changes!)
-* Reworked internal locking of insert/update/delete methods
-* Fixed potential deadlocks when transactions are executed concurrently to one of the various insert/update/delete calls
-* Reworked queries to be used without locking, query instances are now bound to their owner thread (breaking change!)
-* Relations use the new lock-free query API
-* Query classes were moved into the new query subpackage (breaking change!)
-* Introduced Gradle build scripts for DaoCore and DaoGenerator projects
-* Maven artifacts are pushed to Maven Central starting with this version
-* Added two packages for classes used internally (identityscope and internal)
-* Added new deleteByKeyInTx DAO method to efficiently delete multiple entities using their keys
-* Added some checks to throw exceptions with nicer messages telling what's wrong
-* Added Travis CI
+Gradle dependency for your Java generator project:
+```
+    compile 'de.greenrobot:greendao-generator:2.0.0'
+```
 
-### V1.2.0 (2012-06-08): Feature release
-* Limited support of String PKs (no relations using String FKs yet)
-* Fixed index creation (please update your schema)
-* Added CountQuery for creating SELECT COUNT (*) queries with QueryBuilder
-* Added getDatabase in DaoMaster, DaoSession, and Dao
-* Added insertOrReplaceInTx in Dao
-* Added deleteInTx in Dao
-* Added autoincrement() creating AUTOINCREMENT PKs
-* Made DAOs and DaoSessions in active entities transient (allows serialization of entities)
-* Minor fixes
 
-### V1.1.2 (2012-03-26): ADT 17 support for demo project
-* Demo projects works with ADT 17 (moved greendao.jar into libs)
-* CREATE/DROP TABLE may be skipped for entity types: This allows having multiple entity types operate on the same table
-* Minor improvements
-
-### V1.1.1 (2012-02-14): Mini bugfix&feature release
-* Added NOT IN condition for QueryBuilder
-* Fix for Roboelectric (Issue #22)
-* Minor fix (Issue #5)
-
-### V1.1.0 (2012-02-13): Feature release
-* DeleteQuery for bulk deletes
-* Entities may implement Java interfaces
-* Entities may extend a Java class
-* Added LIMIT and OFFSET support for QueryBuilder and Query
-* Convenience methods to add named relationships
-* SQL scripts are executed in a transaction by default
-* Fixed queries with special column names (SQL keywords)
-* Changed default names for to-many relations to end with "List"
-* ORDER BY uses LOCALIZED collation for strings by default
-
-### V1.0.1 (2011-10-30): Bugfix release
-* Fixed generation of to-many relations
-* Fixed generated import statements when entities/DAO are not in the same package
+Features in Beta
+----------------
+Those features are already here for you to try out. Note: Documentation and test coverage may be lacking, and the API may change in the future.
+### Asynchronous API
+* New AsyncSession (acquired from DaoSession.startAsyncSession()) provides most operations for DAOs, Queries, and transactions in a asynchronously variant
+* AsyncOperations are processed in order by a background thread
+* waitForCompletion methods for AsyncSession and AsyncOperations
+* AsyncOperationListener for asynchronous callback when operations complete
+* Asynchronous operations can be merged in single transactions (details follow)
+* Added raw SQL queries returning a Query object (LazyList support etc.)
 
-### V1.0.0 (2011-10-24): First open source release
-* To-many relations (lazily loaded on the entities)
-* To-many relations with custom join properties
-* Active entities can be updated, refreshed, and deleted directly
-* Significant performance improvements (faster identity scope, faster database result parser)
-* "Keep sections" for custom code in entities were added that won't be overwritten during code generation
-* Other minor improvements
+More Open Source by greenrobot
+==============================
+[__EventBus__](https://github.com/greenrobot/EventBus) is a central publish/subscribe bus for Android with optional delivery threads, priorities, and sticky events. A great tool to decouple components (e.g. Activities, Fragments, logic components) from each other.
 
-### Third preview (2011-08-19) 
-http://greendao-orm.com/2011/08/19/query-builder-and-lazy-loading-lists/
+[__greenrobot-common__](https://github.com/greenrobot/greenrobot-common) is a set of utility classes and hash functions for Android & Java projects.
 
-### Second preview (2011-08-12) 
-http://greendao-orm.com/2011/08/12/greendao-2nd-preview/
+[Follow us on Google+](https://plus.google.com/b/114381455741141514652/+GreenrobotDe/posts) to stay up to date.
 
-### First public release (2011-08-04) 
-http://greendao-orm.com/2011/08/04/greendao-public-release/
\ No newline at end of file
diff --git a/build.gradle b/build.gradle
index b62fff62..6a01e479 100644
--- a/build.gradle
+++ b/build.gradle
@@ -1,3 +1,18 @@
+subprojects {
+    repositories {
+        mavenCentral()
+        jcenter()
+    }
+}
+
 task wrapper(type: Wrapper) {
-    gradleVersion = '1.12'
+    gradleVersion = '2.4'
+}
+
+ext {
+    buildToolsVersion = '23.0.1'
+    compileSdkVersion = 23
+
+    minSdkVersion = 4
+    targetSdkVersion = 19
 }
\ No newline at end of file
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
index 3c7abdf1..b5166dad 100644
Binary files a/gradle/wrapper/gradle-wrapper.jar and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index aacac335..a198531e 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Sat May 24 08:38:11 CEST 2014
+#Mon Jun 22 22:22:22 CEST 2015
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=http\://services.gradle.org/distributions/gradle-1.12-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.4-all.zip
diff --git a/gradlew b/gradlew
old mode 100644
new mode 100755
diff --git a/settings.gradle b/settings.gradle
index a26cf78b..ef5f41d2 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -1,2 +1,5 @@
 include 'DaoCore', 'DaoGenerator', 'DaoExampleGenerator'
-include 'DaoTest' // Travis needs some Android setup for this
\ No newline at end of file
+include 'DaoTest' // Travis needs some Android setup for this
+include 'DaoTestGenerator'
+include ':DaoExample'
+
