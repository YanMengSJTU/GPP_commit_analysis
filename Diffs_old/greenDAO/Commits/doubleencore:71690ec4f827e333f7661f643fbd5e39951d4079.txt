diff --git a/.gitignore b/.gitignore
index 20374e4a..da51cda0 100644
--- a/.gitignore
+++ b/.gitignore
@@ -4,3 +4,4 @@
 out/
 build/
 local.properties
+gradle.properties
diff --git a/.travis.yml b/.travis.yml
index 9dc47e89..6483132d 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,12 +1,19 @@
 language: android
+# Use the Travis Container-Based Infrastructure
+sudo: false
 jdk:
   - oraclejdk7
 env:
+  global:
+    # increase adb timeout (2 minutes by default)
+    - ADB_INSTALL_TIMEOUT=8
   matrix:
-    - ANDROID_SDKS=android-19,sysimg-19  ANDROID_TARGET=android-19  ANDROID_ABI=armeabi-v7a
+    - ANDROID_SDKS=android-23,sysimg-23  ANDROID_TARGET=android-19  ANDROID_ABI=armeabi-v7a
 android:
   components:
-    - build-tools-22.0.1
+    - build-tools-23.0.1
+    - android-23
+    - extra-android-m2repository
 before_install:
   - echo no | android create avd --force -n test -t $ANDROID_TARGET --abi $ANDROID_ABI
   - emulator -avd test -no-skin -no-audio -no-window &
@@ -16,4 +23,4 @@ before_script:
   - ./ci/wait_for_emulator
   - adb shell input keyevent 82 &
 script:
-    - TERM=dumb ./gradlew connectedCheck
\ No newline at end of file
+    - TERM=dumb ./gradlew connectedCheck
diff --git a/CHANGELOG.md b/CHANGELOG.md
deleted file mode 100644
index f7b4e232..00000000
--- a/CHANGELOG.md
+++ /dev/null
@@ -1,105 +0,0 @@
-Release History
----------------
-### V2.0.0 Major feature release (2015-07-30, both core and generator)
-* Join for queries: relate a query to other entities (or joins)
-* To-Many relations using a join entity (useful for M:N relationships)
-* Custom types for properties: by implementing PropertyConverter, entities can have properties of any type, e.g. enums, BigInteger, alternative time/date classes, JSON objects, serialized objects, ...
-* Add custom code to fields, getters, and setters of entity properties to add custom annotations or JavaDoc
-* Add additional imports to entities without keep sections
-* Fixes for table names matching a SQL keyword (e.g. "order", "transaction")
-* Several bug fixes
-* Added Flag for AsyncOperation to track the caller's stacktrace (useful for debugging)
-
-### Generator V1.3.1 (2014-05-24): Bugfix
-* Fix schema version >= 1000
-
-### V1.3.7 (2013-11-27): Bugfix
-* Fixed building defect DeleteQuery for tables ending with character 'T' (bug introduced in 1.3.3)
-* Prepared Fast Cursor for API level 19
-
-### V1.3.6 (2013-11-15): Bugfix
-* Fixed leaked statement in DeleteQuery
-
-### V1.3.5 (2013-11-14): Bugfix
-* Because of an issue with ApplicationTestCase, the base test class DbTest does not extend this class anymore.
-Note: This refactoring may require you to adjust some test classes if your tests depend on DbTest or its subclasses.
-
-### V1.3.4 (2013-10-28): Bugfix
-* Redeployment of 1.3.3 artifacts without some old class leftovers
-
-### V1.3.3 (2013-10-18): Bugfix
-* Fixed a memory leak affecting Query class that was introduced in 1.3.0 (#93)
-* Fixed a rare race condition that can lead to "Entity is detached from DAO context" DaoException (#101)
-
-### V1.3.2 (2013-08-28): Bugfix
-* Fixed building CountQueries with combined AND/OR conditions
-* Some secret inoffical work in progress
-
-### V1.3.1 (2013-03-02): Fixed Gradle dependencies
-* Don't use Gradle's "compile" dependency scope
-
-### V1.3.0 (2013-02-24): Multithreading robustness and refactoring (breaking changes!)
-* Reworked internal locking of insert/update/delete methods
-* Fixed potential deadlocks when transactions are executed concurrently to one of the various insert/update/delete calls
-* Reworked queries to be used without locking, query instances are now bound to their owner thread (breaking change!)
-* Relations use the new lock-free query API
-* Query classes were moved into the new query subpackage (breaking change!)
-* Introduced Gradle build scripts for DaoCore and DaoGenerator projects
-* Maven artifacts are pushed to Maven Central starting with this version
-* Added two packages for classes used internally (identityscope and internal)
-* Added new deleteByKeyInTx DAO method to efficiently delete multiple entities using their keys
-* Added some checks to throw exceptions with nicer messages telling what's wrong
-* Added Travis CI
-
-### V1.2.0 (2012-06-08): Feature release
-* Limited support of String PKs (no relations using String FKs yet)
-* Fixed index creation (please update your schema)
-* Added CountQuery for creating SELECT COUNT (*) queries with QueryBuilder
-* Added getDatabase in DaoMaster, DaoSession, and Dao
-* Added insertOrReplaceInTx in Dao
-* Added deleteInTx in Dao
-* Added autoincrement() creating AUTOINCREMENT PKs
-* Made DAOs and DaoSessions in active entities transient (allows serialization of entities)
-* Minor fixes
-
-### V1.1.2 (2012-03-26): ADT 17 support for demo project
-* Demo projects works with ADT 17 (moved greendao.jar into libs)
-* CREATE/DROP TABLE may be skipped for entity types: This allows having multiple entity types operate on the same table
-* Minor improvements
-
-### V1.1.1 (2012-02-14): Mini bugfix&feature release
-* Added NOT IN condition for QueryBuilder
-* Fix for Roboelectric (Issue #22)
-* Minor fix (Issue #5)
-
-### V1.1.0 (2012-02-13): Feature release
-* DeleteQuery for bulk deletes
-* Entities may implement Java interfaces
-* Entities may extend a Java class
-* Added LIMIT and OFFSET support for QueryBuilder and Query
-* Convenience methods to add named relationships
-* SQL scripts are executed in a transaction by default
-* Fixed queries with special column names (SQL keywords)
-* Changed default names for to-many relations to end with "List"
-* ORDER BY uses LOCALIZED collation for strings by default
-
-### V1.0.1 (2011-10-30): Bugfix release
-* Fixed generation of to-many relations
-* Fixed generated import statements when entities/DAO are not in the same package
-
-### V1.0.0 (2011-10-24): First open source release
-* To-many relations (lazily loaded on the entities)
-* To-many relations with custom join properties
-* Active entities can be updated, refreshed, and deleted directly
-* Significant performance improvements (faster identity scope, faster database result parser)
-* "Keep sections" for custom code in entities were added that won't be overwritten during code generation
-* Other minor improvements
-
-### Third preview (2011-08-19)
-http://greendao-orm.com/2011/08/19/query-builder-and-lazy-loading-lists/
-
-### Second preview (2011-08-12)
-http://greendao-orm.com/2011/08/12/greendao-2nd-preview/
-
-### First public release (2011-08-04)
-http://greendao-orm.com/2011/08/04/greendao-public-release/
\ No newline at end of file
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
new file mode 100644
index 00000000..1be8916f
--- /dev/null
+++ b/CONTRIBUTING.md
@@ -0,0 +1,45 @@
+Before you create an Issue...
+=============================
+
+There are better Places for Support
+-----------------------------------
+We want your question to be answered, so it is important that you ask at the right place. Be aware that an issue tracker is not the best place to ask for support. An issue tracker is used to track issues (bugs or feature requests).
+Instead, please use [stackoverflow.com](http://stackoverflow.com/questions/tagged/greendao?sort=frequent) and use the tag [greendao](http://stackoverflow.com/tags/greendao/info) for your question.
+
+If you want professional support, check http://greenrobot.org/contact-support/.
+
+Examples for support questions that are more likely to be answered on StackOverflow:
+
+* Asking how something works
+* Asking how to use greenDAO in a specific scenario
+* Your app crashes/misbehaves and you are not sure why
+
+The perfect Issue Report
+------------------------
+A couple of simple steps can save time for everyone.
+
+Check before reporting:
+
+* It's not a support inquiry
+* You have read the docs
+* You searched the web and stackoverflow
+* You searched existing issues to avoid duplicates
+
+Reporting bugs:
+
+ * Please investigate if is the bug is really caused by the library. Isolate the issue: what's the minimal code to reproduce the bug?
+ * Bonus steps to gain extra karma points: once you isolated and identified the issue, you can prepare an push request. Submit an unit test causing the bug, and ideally a fix for the bug.
+
+Requesting features:
+
+ * Ask yourself: is the feature useful for a majority users? One of our major goals is to keep the API simple and concise. We do not want to cover all possible use cases, but those that make 80% of users happy.
+
+A Note on Pull Requests
+=======================
+Pull requests (and issues) may queue up up a bit. Usually, pull requests and issues are checked when new releases are planned.
+
+For bigger pull requests, it's a good idea to check with the maintainer upfront about the idea and the implementation outline.
+
+Thanks for reading!
+===================
+It's your contributions and feedback that makes maintaining this library fun.
diff --git a/DaoCore/.gitignore b/DaoCore/.gitignore
index 5200a9fa..6a0dc5ea 100644
--- a/DaoCore/.gitignore
+++ b/DaoCore/.gitignore
@@ -1,5 +1 @@
-/gen
-/bin
-/release
-/build
 /gradle.properties
diff --git a/DaoCore/build.gradle b/DaoCore/build.gradle
index 808142e3..47b78307 100644
--- a/DaoCore/build.gradle
+++ b/DaoCore/build.gradle
@@ -2,8 +2,9 @@ apply plugin: 'java'
 apply plugin: 'maven'
 apply plugin: 'signing'
 
-group = 'de.greenrobot'
-version = '2.0.0'
+group = 'org.greenrobot'
+archivesBaseName = 'greendao'
+version = '2.2.1'
 sourceCompatibility = 1.6
 
 def isSnapshot = version.endsWith('-SNAPSHOT')
@@ -18,35 +19,23 @@ repositories {
     mavenCentral()
 }
 
-// provided is not supported in Gradle 1.4, see http://issues.gradle.org/browse/GRADLE-784
-// Like this, it won't appear at all in the POM
 configurations {
-    provided
     deployerJars
 }
 
 dependencies {
-    provided 'com.google.android:android:4.1.1.4'
-    provided 'com.google.android:android-test:4.1.1.4'
-    provided 'com.google.android:annotations:4.1.1.4'
-    provided 'com.google.android:support-v4:r7'
+    compileOnly 'com.google.android:android:4.1.1.4'
+    compileOnly 'com.google.android:android-test:4.1.1.4'
+    compileOnly 'com.google.android:annotations:4.1.1.4'
+    compileOnly 'com.google.android:support-v4:r7'
     // deployerJars 'org.apache.maven.wagon:wagon-webdav-jackrabbit:2.4'
     deployerJars 'org.apache.maven.wagon:wagon-webdav:1.0-beta-2'
 }
 
-sourceSets {
-    main {
-        compileClasspath += configurations.provided
-        java {
-            srcDir 'src'
-        }
-    }
-}
-
 javadoc {
-    classpath += configurations.provided
+    failOnError = false
     title = " greenDAO ${version} API"
-	options.bottom = 'Available under the Apache License, Version 2.0 - <i>Copyright &#169; 2011-2013 <a href="http://greenrobot.de/">greenrobot.de</a>. All Rights Reserved.</i>'
+	options.bottom = 'Available under the Apache License, Version 2.0 - <i>Copyright &#169; 2011-2016 <a href="http://greenrobot.org/">greenrobot.org</a>. All Rights Reserved.</i>'
 	excludes = ['de/greenrobot/dao/internal','de/greenrobot/dao/Internal*']
 }
 
@@ -97,7 +86,7 @@ uploadArchives {
                name 'greenDAO'
                packaging 'jar'
                description 'greenDAO is a light and fast ORM for Android'
-               url 'http://greendao-orm.com'
+               url 'http://greenrobot.org/greendao'
 
                scm {
                    url 'https://github.com/greenrobot/greenDAO'
@@ -127,7 +116,7 @@ uploadArchives {
                
                organization {
                    name 'greenrobot'
-                   url 'http://greenrobot.de'
+                   url 'http://greenrobot.org'
                }
            }
         }
diff --git a/DaoCore/project.properties b/DaoCore/project.properties
deleted file mode 100644
index 96db7421..00000000
--- a/DaoCore/project.properties
+++ /dev/null
@@ -1,12 +0,0 @@
-# This file is automatically generated by Android Tools.
-# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
-#
-# This file must be checked in Version Control Systems.
-#
-# To customize properties used by the Ant build system use,
-# "ant.properties", and override values to adapt the script to your
-# project structure.
-
-android.library=true
-# Project target.
-target=android-4
diff --git a/DaoCore/settings.gradle b/DaoCore/settings.gradle
deleted file mode 100644
index 48427d6a..00000000
--- a/DaoCore/settings.gradle
+++ /dev/null
@@ -1 +0,0 @@
-rootProject.name = 'greendao'
\ No newline at end of file
diff --git a/DaoCore/src/de/greenrobot/dao/AbstractDao.java b/DaoCore/src/main/java/de/greenrobot/dao/AbstractDao.java
similarity index 86%
rename from DaoCore/src/de/greenrobot/dao/AbstractDao.java
rename to DaoCore/src/main/java/de/greenrobot/dao/AbstractDao.java
index 51349dfb..002b04ba 100644
--- a/DaoCore/src/de/greenrobot/dao/AbstractDao.java
+++ b/DaoCore/src/main/java/de/greenrobot/dao/AbstractDao.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2013 Markus Junginger, greenrobot (http://greenrobot.de)
+ * Copyright (C) 2011-2016 Markus Junginger, greenrobot (http://greenrobot.de)
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,17 +16,18 @@
 
 package de.greenrobot.dao;
 
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.List;
-
 import android.database.CrossProcessCursor;
 import android.database.Cursor;
 import android.database.CursorWindow;
 import android.database.DatabaseUtils;
 import android.database.sqlite.SQLiteDatabase;
 import android.database.sqlite.SQLiteStatement;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.List;
+
 import de.greenrobot.dao.identityscope.IdentityScope;
 import de.greenrobot.dao.identityscope.IdentityScopeLong;
 import de.greenrobot.dao.internal.DaoConfig;
@@ -37,15 +38,12 @@
 
 /**
  * Base class for all DAOs: Implements entity operations like insert, load, delete, and query.
- *
+ * <p/>
  * This class is thread-safe.
  *
+ * @param <T> Entity type
+ * @param <K> Primary key (PK) type; use Void if entity does not have exactly one PK
  * @author Markus
- *
- * @param <T>
- *            Entity type
- * @param <K>
- *            Primary key (PK) type; use Void if entity does not have exactly one PK
  */
 /*
  * When operating on TX, statements, or identity scope the following locking order must be met to avoid deadlocks:
@@ -116,10 +114,9 @@ public Property getPkProperty() {
     }
 
     /**
-     * Loads and entity for the given PK.
+     * Loads the entity for the given PK.
      *
-     * @param key
-     *            a PK value or null
+     * @param key a PK value or null
      * @return The entity or null, if no entity matched the PK value
      */
     public T load(K key) {
@@ -134,13 +131,13 @@ public T load(K key) {
             }
         }
         String sql = statements.getSelectByKey();
-        String[] keyArray = new String[] { key.toString() };
+        String[] keyArray = new String[]{key.toString()};
         Cursor cursor = db.rawQuery(sql, keyArray);
         return loadUniqueAndCloseCursor(cursor);
     }
 
     public T loadByRowId(long rowId) {
-        String[] idArray = new String[] { Long.toString(rowId) };
+        String[] idArray = new String[]{Long.toString(rowId)};
         Cursor cursor = db.rawQuery(statements.getSelectByRowId(), idArray);
         return loadUniqueAndCloseCursor(cursor);
     }
@@ -179,6 +176,16 @@ public boolean detach(T entity) {
         }
     }
 
+    /**
+     * Detaches all entities (of type T) from the identity scope (session). Subsequent query results won't return any
+     * previously loaded objects.
+     */
+    public void detachAll() {
+        if (identityScope != null) {
+            identityScope.clear();
+        }
+    }
+
     protected List<T> loadAllAndCloseCursor(Cursor cursor) {
         try {
             return loadAllFromCursor(cursor);
@@ -190,8 +197,7 @@ public boolean detach(T entity) {
     /**
      * Inserts the given entities in the database using a transaction.
      *
-     * @param entities
-     *            The entities to insert.
+     * @param entities The entities to insert.
      */
     public void insertInTx(Iterable<T> entities) {
         insertInTx(entities, isEntityUpdateable());
@@ -200,8 +206,7 @@ public void insertInTx(Iterable<T> entities) {
     /**
      * Inserts the given entities in the database using a transaction.
      *
-     * @param entities
-     *            The entities to insert.
+     * @param entities The entities to insert.
      */
     public void insertInTx(T... entities) {
         insertInTx(Arrays.asList(entities), isEntityUpdateable());
@@ -211,10 +216,9 @@ public void insertInTx(T... entities) {
      * Inserts the given entities in the database using a transaction. The given entities will become tracked if the PK
      * is set.
      *
-     * @param entities
-     *            The entities to insert.
-     * @param setPrimaryKey
-     *            if true, the PKs of the given will be set after the insert; pass false to improve performance.
+     * @param entities      The entities to insert.
+     * @param setPrimaryKey if true, the PKs of the given will be set after the insert; pass false to improve
+     *                      performance.
      */
     public void insertInTx(Iterable<T> entities, boolean setPrimaryKey) {
         SQLiteStatement stmt = statements.getInsertStatement();
@@ -225,10 +229,9 @@ public void insertInTx(Iterable<T> entities, boolean setPrimaryKey) {
      * Inserts or replaces the given entities in the database using a transaction. The given entities will become
      * tracked if the PK is set.
      *
-     * @param entities
-     *            The entities to insert.
-     * @param setPrimaryKey
-     *            if true, the PKs of the given will be set after the insert; pass false to improve performance.
+     * @param entities      The entities to insert.
+     * @param setPrimaryKey if true, the PKs of the given will be set after the insert; pass false to improve
+     *                      performance.
      */
     public void insertOrReplaceInTx(Iterable<T> entities, boolean setPrimaryKey) {
         SQLiteStatement stmt = statements.getInsertOrReplaceStatement();
@@ -238,8 +241,7 @@ public void insertOrReplaceInTx(Iterable<T> entities, boolean setPrimaryKey) {
     /**
      * Inserts or replaces the given entities in the database using a transaction.
      *
-     * @param entities
-     *            The entities to insert.
+     * @param entities The entities to insert.
      */
     public void insertOrReplaceInTx(Iterable<T> entities) {
         insertOrReplaceInTx(entities, isEntityUpdateable());
@@ -248,8 +250,7 @@ public void insertOrReplaceInTx(Iterable<T> entities) {
     /**
      * Inserts or replaces the given entities in the database using a transaction.
      *
-     * @param entities
-     *            The entities to insert.
+     * @param entities The entities to insert.
      */
     public void insertOrReplaceInTx(T... entities) {
         insertOrReplaceInTx(Arrays.asList(entities), isEntityUpdateable());
@@ -294,8 +295,10 @@ public long insert(T entity) {
     }
 
     /**
-     * Insert an entity into the table associated with a concrete DAO <b>without</b> setting key property. Warning: This
-     * may be faster, but the entity should not be used anymore. The entity also won't be attached to identy scope.
+     * Insert an entity into the table associated with a concrete DAO <b>without</b> setting key property.
+     *
+     * Warning: This may be faster, but the entity should not be used anymore. The entity also won't be attached to
+     * identity scope.
      *
      * @return row ID of newly inserted entity
      */
@@ -369,12 +372,18 @@ protected void updateKeyAfterInsertAndAttach(T entity, long rowId, boolean lock)
     /** Reads all available rows from the given cursor and returns a list of entities. */
     protected List<T> loadAllFromCursor(Cursor cursor) {
         int count = cursor.getCount();
+        if (count == 0) {
+            return new ArrayList<T>();
+        }
         List<T> list = new ArrayList<T>(count);
+        CursorWindow window = null;
+        boolean useFastCursor = false;
         if (cursor instanceof CrossProcessCursor) {
-            CursorWindow window = ((CrossProcessCursor) cursor).getWindow();
-            if (window != null) { // E.g. Roboelectric has no Window at this point
+            window = ((CrossProcessCursor) cursor).getWindow();
+            if (window != null) { // E.g. Robolectric has no Window at this point
                 if (window.getNumRows() == count) {
                     cursor = new FastCursor(window);
+                    useFastCursor = true;
                 } else {
                     DaoLog.d("Window vs. result size: " + window.getNumRows() + "/" + count);
                 }
@@ -386,10 +395,15 @@ protected void updateKeyAfterInsertAndAttach(T entity, long rowId, boolean lock)
                 identityScope.lock();
                 identityScope.reserveRoom(count);
             }
+
             try {
-                do {
-                    list.add(loadCurrent(cursor, 0, false));
-                } while (cursor.moveToNext());
+                if (!useFastCursor && window != null && identityScope != null) {
+                    loadAllUnlockOnWindowBounds(cursor, window, list);
+                } else {
+                    do {
+                        list.add(loadCurrent(cursor, 0, false));
+                    } while (cursor.moveToNext());
+                }
             } finally {
                 if (identityScope != null) {
                     identityScope.unlock();
@@ -399,6 +413,42 @@ protected void updateKeyAfterInsertAndAttach(T entity, long rowId, boolean lock)
         return list;
     }
 
+    private void loadAllUnlockOnWindowBounds(Cursor cursor, CursorWindow window, List<T> list) {
+        int windowEnd = window.getStartPosition() + window.getNumRows();
+        for (int row = 0; ; row++) {
+            list.add(loadCurrent(cursor, 0, false));
+            row++;
+            if (row >= windowEnd) {
+                window = moveToNextUnlocked(cursor);
+                if (window == null) {
+                    break;
+                }
+                windowEnd = window.getStartPosition() + window.getNumRows();
+            } else {
+                if (!cursor.moveToNext()) {
+                    break;
+                }
+            }
+        }
+    }
+
+    /**
+     * Unlock identityScope during cursor.moveToNext() when it is about to fill the window (needs a db connection):
+     * We should not hold the lock while trying to acquire a db connection to avoid deadlocks.
+     */
+    private CursorWindow moveToNextUnlocked(Cursor cursor) {
+        identityScope.unlock();
+        try {
+            if (cursor.moveToNext()) {
+                return ((CrossProcessCursor) cursor).getWindow();
+            } else {
+                return null;
+            }
+        } finally {
+            identityScope.lock();
+        }
+    }
+
     /** Internal use only. Considers identity scope. */
     final protected T loadCurrent(Cursor cursor, int offset, boolean lock) {
         if (identityScopeLong != null) {
@@ -580,8 +630,7 @@ private void deleteInTxInternal(Iterable<T> entities, Iterable<K> keys) {
     /**
      * Deletes the given entities in the database using a transaction.
      *
-     * @param entities
-     *            The entities to delete.
+     * @param entities The entities to delete.
      */
     public void deleteInTx(Iterable<T> entities) {
         deleteInTxInternal(entities, null);
@@ -590,8 +639,7 @@ public void deleteInTx(Iterable<T> entities) {
     /**
      * Deletes the given entities in the database using a transaction.
      *
-     * @param entities
-     *            The entities to delete.
+     * @param entities The entities to delete.
      */
     public void deleteInTx(T... entities) {
         deleteInTxInternal(Arrays.asList(entities), null);
@@ -600,8 +648,7 @@ public void deleteInTx(T... entities) {
     /**
      * Deletes all entities with the given keys in the database using a transaction.
      *
-     * @param keys
-     *            Keys of the entities to delete.
+     * @param keys Keys of the entities to delete.
      */
     public void deleteByKeyInTx(Iterable<K> keys) {
         deleteInTxInternal(null, keys);
@@ -610,8 +657,7 @@ public void deleteByKeyInTx(Iterable<K> keys) {
     /**
      * Deletes all entities with the given keys in the database using a transaction.
      *
-     * @param keys
-     *            Keys of the entities to delete.
+     * @param keys Keys of the entities to delete.
      */
     public void deleteByKeyInTx(K... keys) {
         deleteInTxInternal(null, Arrays.asList(keys));
@@ -622,7 +668,7 @@ public void refresh(T entity) {
         assertSinglePk();
         K key = getKeyVerified(entity);
         String sql = statements.getSelectByKey();
-        String[] keyArray = new String[] { key.toString() };
+        String[] keyArray = new String[]{key.toString()};
         Cursor cursor = db.rawQuery(sql, keyArray);
         try {
             boolean available = cursor.moveToFirst();
@@ -683,11 +729,9 @@ protected void updateInsideSynchronized(T entity, SQLiteStatement stmt, boolean
     /**
      * Attaches the entity to the identity scope. Calls attachEntity(T entity).
      *
-     * @param key
-     *            Needed only for identity scope, pass null if there's none.
-     * @param entity
-     *            The entitiy to attach
-     * */
+     * @param key    Needed only for identity scope, pass null if there's none.
+     * @param entity The entitiy to attach
+     */
     protected final void attachEntity(K key, T entity, boolean lock) {
         attachEntity(entity);
         if (identityScope != null && key != null) {
@@ -703,17 +747,15 @@ protected final void attachEntity(K key, T entity, boolean lock) {
      * Sub classes with relations additionally set the DaoMaster here. Must be called before the entity is attached to
      * the identity scope.
      *
-     * @param entity
-     *            The entitiy to attach
-     * */
+     * @param entity The entitiy to attach
+     */
     protected void attachEntity(T entity) {
     }
 
     /**
      * Updates the given entities in the database using a transaction.
      *
-     * @param entities
-     *            The entities to insert.
+     * @param entities The entities to insert.
      */
     public void updateInTx(Iterable<T> entities) {
         SQLiteStatement stmt = statements.getUpdateStatement();
@@ -754,8 +796,7 @@ public void updateInTx(Iterable<T> entities) {
     /**
      * Updates the given entities in the database using a transaction.
      *
-     * @param entities
-     *            The entities to update.
+     * @param entities The entities to update.
      */
     public void updateInTx(T... entities) {
         updateInTx(Arrays.asList(entities));
diff --git a/DaoCore/src/de/greenrobot/dao/AbstractDaoMaster.java b/DaoCore/src/main/java/de/greenrobot/dao/AbstractDaoMaster.java
similarity index 100%
rename from DaoCore/src/de/greenrobot/dao/AbstractDaoMaster.java
rename to DaoCore/src/main/java/de/greenrobot/dao/AbstractDaoMaster.java
diff --git a/DaoCore/src/de/greenrobot/dao/AbstractDaoSession.java b/DaoCore/src/main/java/de/greenrobot/dao/AbstractDaoSession.java
similarity index 94%
rename from DaoCore/src/de/greenrobot/dao/AbstractDaoSession.java
rename to DaoCore/src/main/java/de/greenrobot/dao/AbstractDaoSession.java
index 6a37ef2a..c3a3d5ce 100644
--- a/DaoCore/src/de/greenrobot/dao/AbstractDaoSession.java
+++ b/DaoCore/src/main/java/de/greenrobot/dao/AbstractDaoSession.java
@@ -15,6 +15,8 @@
  */
 package de.greenrobot.dao;
 
+import java.util.Collection;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
@@ -25,14 +27,14 @@
 import de.greenrobot.dao.query.QueryBuilder;
 
 /**
- * DaoSession gives you access to your DAOs, offers convenient persistence methods, and also serves as a session cache.<br/>
- * <br/>
- * To access the DAOs, call the get{entity}Dao methods by the generated DaoSession sub class.<br/>
- * <br/>
+ * DaoSession gives you access to your DAOs, offers convenient persistence methods, and also serves as a session cache.<br>
+ * <br>
+ * To access the DAOs, call the get{entity}Dao methods by the generated DaoSession sub class.<br>
+ * <br>
  * DaoSession offers many of the available persistence operations on entities as a convenience. Consider using DAOs
  * directly to access all available operations, especially if you call a lot of operations on a single entity type to
- * avoid the overhead imposed by DaoSession (the overhead is small, but it may add up).<br/>
- * <br/>
+ * avoid the overhead imposed by DaoSession (the overhead is small, but it may add up).<br>
+ * <br>
  * By default, the DaoSession has a session cache (IdentityScopeType.Session). The session cache is not just a plain
  * data cache to improve performance, but also manages object identities. For example, if you load the same entity twice
  * in a query, you will get a single Java object instead of two when using a session cache. This is particular useful
@@ -187,6 +189,11 @@ public SQLiteDatabase getDatabase() {
         return db;
     }
 
+    /** Allows to inspect the meta model using DAOs (e.g. querying table names or properties). */
+    public Collection<AbstractDao<?, ?>> getAllDaos() {
+        return Collections.unmodifiableCollection(entityToDao.values());
+    }
+
     /**
      * Creates a new {@link AsyncSession} to issue asynchronous entity operations. See {@link AsyncSession} for details.
      */
diff --git a/DaoCore/src/de/greenrobot/dao/DaoException.java b/DaoCore/src/main/java/de/greenrobot/dao/DaoException.java
similarity index 100%
rename from DaoCore/src/de/greenrobot/dao/DaoException.java
rename to DaoCore/src/main/java/de/greenrobot/dao/DaoException.java
diff --git a/DaoCore/src/de/greenrobot/dao/DaoLog.java b/DaoCore/src/main/java/de/greenrobot/dao/DaoLog.java
similarity index 100%
rename from DaoCore/src/de/greenrobot/dao/DaoLog.java
rename to DaoCore/src/main/java/de/greenrobot/dao/DaoLog.java
diff --git a/DaoCore/src/de/greenrobot/dao/DbUtils.java b/DaoCore/src/main/java/de/greenrobot/dao/DbUtils.java
similarity index 100%
rename from DaoCore/src/de/greenrobot/dao/DbUtils.java
rename to DaoCore/src/main/java/de/greenrobot/dao/DbUtils.java
diff --git a/DaoCore/src/de/greenrobot/dao/InternalQueryDaoAccess.java b/DaoCore/src/main/java/de/greenrobot/dao/InternalQueryDaoAccess.java
similarity index 100%
rename from DaoCore/src/de/greenrobot/dao/InternalQueryDaoAccess.java
rename to DaoCore/src/main/java/de/greenrobot/dao/InternalQueryDaoAccess.java
diff --git a/DaoCore/src/de/greenrobot/dao/InternalUnitTestDaoAccess.java b/DaoCore/src/main/java/de/greenrobot/dao/InternalUnitTestDaoAccess.java
similarity index 100%
rename from DaoCore/src/de/greenrobot/dao/InternalUnitTestDaoAccess.java
rename to DaoCore/src/main/java/de/greenrobot/dao/InternalUnitTestDaoAccess.java
diff --git a/DaoCore/src/de/greenrobot/dao/Property.java b/DaoCore/src/main/java/de/greenrobot/dao/Property.java
similarity index 100%
rename from DaoCore/src/de/greenrobot/dao/Property.java
rename to DaoCore/src/main/java/de/greenrobot/dao/Property.java
diff --git a/DaoCore/src/de/greenrobot/dao/async/AsyncDaoException.java b/DaoCore/src/main/java/de/greenrobot/dao/async/AsyncDaoException.java
similarity index 100%
rename from DaoCore/src/de/greenrobot/dao/async/AsyncDaoException.java
rename to DaoCore/src/main/java/de/greenrobot/dao/async/AsyncDaoException.java
diff --git a/DaoCore/src/de/greenrobot/dao/async/AsyncOperation.java b/DaoCore/src/main/java/de/greenrobot/dao/async/AsyncOperation.java
similarity index 100%
rename from DaoCore/src/de/greenrobot/dao/async/AsyncOperation.java
rename to DaoCore/src/main/java/de/greenrobot/dao/async/AsyncOperation.java
diff --git a/DaoCore/src/de/greenrobot/dao/async/AsyncOperationExecutor.java b/DaoCore/src/main/java/de/greenrobot/dao/async/AsyncOperationExecutor.java
similarity index 99%
rename from DaoCore/src/de/greenrobot/dao/async/AsyncOperationExecutor.java
rename to DaoCore/src/main/java/de/greenrobot/dao/async/AsyncOperationExecutor.java
index d57c1f74..6e3b277a 100644
--- a/DaoCore/src/de/greenrobot/dao/async/AsyncOperationExecutor.java
+++ b/DaoCore/src/main/java/de/greenrobot/dao/async/AsyncOperationExecutor.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
+ * Copyright (C) 2011-2015 Markus Junginger, greenrobot (http://greenrobot.de)
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -308,10 +308,10 @@ private void executeOperation(AsyncOperation operation) {
                     executeTransactionCallable(operation);
                     break;
                 case QueryList:
-                    operation.result = ((Query) operation.parameter).list();
+                    operation.result = ((Query) operation.parameter).forCurrentThread().list();
                     break;
                 case QueryUnique:
-                    operation.result = ((Query) operation.parameter).unique();
+                    operation.result = ((Query) operation.parameter).forCurrentThread().unique();
                     break;
                 case DeleteByKey:
                     operation.dao.deleteByKey(operation.parameter);
diff --git a/DaoCore/src/de/greenrobot/dao/async/AsyncOperationListener.java b/DaoCore/src/main/java/de/greenrobot/dao/async/AsyncOperationListener.java
similarity index 100%
rename from DaoCore/src/de/greenrobot/dao/async/AsyncOperationListener.java
rename to DaoCore/src/main/java/de/greenrobot/dao/async/AsyncOperationListener.java
diff --git a/DaoCore/src/de/greenrobot/dao/async/AsyncSession.java b/DaoCore/src/main/java/de/greenrobot/dao/async/AsyncSession.java
similarity index 100%
rename from DaoCore/src/de/greenrobot/dao/async/AsyncSession.java
rename to DaoCore/src/main/java/de/greenrobot/dao/async/AsyncSession.java
diff --git a/DaoCore/src/de/greenrobot/dao/converter/PropertyConverter.java b/DaoCore/src/main/java/de/greenrobot/dao/converter/PropertyConverter.java
similarity index 100%
rename from DaoCore/src/de/greenrobot/dao/converter/PropertyConverter.java
rename to DaoCore/src/main/java/de/greenrobot/dao/converter/PropertyConverter.java
diff --git a/DaoCore/src/de/greenrobot/dao/identityscope/IdentityScope.java b/DaoCore/src/main/java/de/greenrobot/dao/identityscope/IdentityScope.java
similarity index 100%
rename from DaoCore/src/de/greenrobot/dao/identityscope/IdentityScope.java
rename to DaoCore/src/main/java/de/greenrobot/dao/identityscope/IdentityScope.java
diff --git a/DaoCore/src/de/greenrobot/dao/identityscope/IdentityScopeLong.java b/DaoCore/src/main/java/de/greenrobot/dao/identityscope/IdentityScopeLong.java
similarity index 100%
rename from DaoCore/src/de/greenrobot/dao/identityscope/IdentityScopeLong.java
rename to DaoCore/src/main/java/de/greenrobot/dao/identityscope/IdentityScopeLong.java
diff --git a/DaoCore/src/de/greenrobot/dao/identityscope/IdentityScopeObject.java b/DaoCore/src/main/java/de/greenrobot/dao/identityscope/IdentityScopeObject.java
similarity index 100%
rename from DaoCore/src/de/greenrobot/dao/identityscope/IdentityScopeObject.java
rename to DaoCore/src/main/java/de/greenrobot/dao/identityscope/IdentityScopeObject.java
diff --git a/DaoCore/src/de/greenrobot/dao/identityscope/IdentityScopeType.java b/DaoCore/src/main/java/de/greenrobot/dao/identityscope/IdentityScopeType.java
similarity index 100%
rename from DaoCore/src/de/greenrobot/dao/identityscope/IdentityScopeType.java
rename to DaoCore/src/main/java/de/greenrobot/dao/identityscope/IdentityScopeType.java
diff --git a/DaoCore/src/de/greenrobot/dao/internal/DaoConfig.java b/DaoCore/src/main/java/de/greenrobot/dao/internal/DaoConfig.java
similarity index 100%
rename from DaoCore/src/de/greenrobot/dao/internal/DaoConfig.java
rename to DaoCore/src/main/java/de/greenrobot/dao/internal/DaoConfig.java
diff --git a/DaoCore/src/de/greenrobot/dao/internal/FastCursor.java b/DaoCore/src/main/java/de/greenrobot/dao/internal/FastCursor.java
similarity index 100%
rename from DaoCore/src/de/greenrobot/dao/internal/FastCursor.java
rename to DaoCore/src/main/java/de/greenrobot/dao/internal/FastCursor.java
diff --git a/DaoCore/src/de/greenrobot/dao/internal/LongHashMap.java b/DaoCore/src/main/java/de/greenrobot/dao/internal/LongHashMap.java
similarity index 100%
rename from DaoCore/src/de/greenrobot/dao/internal/LongHashMap.java
rename to DaoCore/src/main/java/de/greenrobot/dao/internal/LongHashMap.java
diff --git a/DaoCore/src/de/greenrobot/dao/internal/SqlUtils.java b/DaoCore/src/main/java/de/greenrobot/dao/internal/SqlUtils.java
similarity index 89%
rename from DaoCore/src/de/greenrobot/dao/internal/SqlUtils.java
rename to DaoCore/src/main/java/de/greenrobot/dao/internal/SqlUtils.java
index 23d68949..3e328bc9 100644
--- a/DaoCore/src/de/greenrobot/dao/internal/SqlUtils.java
+++ b/DaoCore/src/main/java/de/greenrobot/dao/internal/SqlUtils.java
@@ -20,6 +20,7 @@
 
 /** Helper class to create SQL statements as used by greenDAO internally. */
 public class SqlUtils {
+    private final static char[] HEX_ARRAY = "0123456789ABCDEF".toCharArray();
 
     public static StringBuilder appendProperty(StringBuilder builder, String tablePrefix, Property property) {
         if (tablePrefix != null) {
@@ -103,12 +104,12 @@ public static String createSqlInsert(String insertInto, String tablename, String
     }
 
     /** Creates an select for given columns with a trailing space */
-    public static String createSqlSelect(String tablename, String tableAlias, String[] columns) {
+    public static String createSqlSelect(String tablename, String tableAlias, String[] columns, boolean distinct) {
         if (tableAlias == null || tableAlias.length() < 0) {
             throw new DaoException("Table alias required");
         }
 
-        StringBuilder builder = new StringBuilder("SELECT ");
+        StringBuilder builder = new StringBuilder(distinct ? "SELECT DISTINCT " : "SELECT ");
         SqlUtils.appendColumns(builder, tableAlias, columns).append(" FROM ");
         builder.append('"').append(tablename).append('"').append(' ').append(tableAlias).append(' ');
         return builder.toString();
@@ -146,4 +147,17 @@ public static String createSqlUpdate(String tablename, String[] updateColumns, S
         return builder.toString();
     }
 
+    public static String escapeBlobArgument(byte[] bytes) {
+        return "X'" + toHex(bytes) + '\'';
+    }
+
+    public static String toHex(byte[] bytes) {
+        char[] hexChars = new char[bytes.length * 2];
+        for (int i = 0; i < bytes.length; i++) {
+            int byteValue = bytes[i] & 0xFF;
+            hexChars[i * 2] = HEX_ARRAY[byteValue >>> 4];
+            hexChars[i * 2 + 1] = HEX_ARRAY[byteValue & 0x0F];
+        }
+        return new String(hexChars);
+    }
 }
diff --git a/DaoCore/src/de/greenrobot/dao/internal/TableStatements.java b/DaoCore/src/main/java/de/greenrobot/dao/internal/TableStatements.java
similarity index 62%
rename from DaoCore/src/de/greenrobot/dao/internal/TableStatements.java
rename to DaoCore/src/main/java/de/greenrobot/dao/internal/TableStatements.java
index 9414f1f7..313fbdb1 100644
--- a/DaoCore/src/de/greenrobot/dao/internal/TableStatements.java
+++ b/DaoCore/src/main/java/de/greenrobot/dao/internal/TableStatements.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ * Copyright (C) 2011-2016 Markus Junginger, greenrobot (http://greenrobot.org)
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -19,16 +19,18 @@
 import android.database.sqlite.SQLiteStatement;
 
 /** Helper class to create SQL statements for specific tables (used by greenDAO internally). */
+// Note: avoid locking while compiling any statement (accessing the db) to avoid deadlocks on lock-savvy DBs like
+// SQLCipher.
 public class TableStatements {
     private final SQLiteDatabase db;
     private final String tablename;
     private final String[] allColumns;
     private final String[] pkColumns;
 
-    private SQLiteStatement insertStatement;
-    private SQLiteStatement insertOrReplaceStatement;
-    private SQLiteStatement updateStatement;
-    private SQLiteStatement deleteStatement;
+    private volatile SQLiteStatement insertStatement;
+    private volatile SQLiteStatement insertOrReplaceStatement;
+    private volatile SQLiteStatement updateStatement;
+    private volatile SQLiteStatement deleteStatement;
 
     private volatile String selectAll;
     private volatile String selectByKey;
@@ -45,7 +47,15 @@ public TableStatements(SQLiteDatabase db, String tablename, String[] allColumns,
     public SQLiteStatement getInsertStatement() {
         if (insertStatement == null) {
             String sql = SqlUtils.createSqlInsert("INSERT INTO ", tablename, allColumns);
-            insertStatement = db.compileStatement(sql);
+            SQLiteStatement newInsertStatement = db.compileStatement(sql);
+            synchronized (this) {
+                if (insertStatement == null) {
+                    insertStatement = newInsertStatement;
+                }
+            }
+            if (insertStatement != newInsertStatement) {
+                newInsertStatement.close();
+            }
         }
         return insertStatement;
     }
@@ -53,7 +63,15 @@ public SQLiteStatement getInsertStatement() {
     public SQLiteStatement getInsertOrReplaceStatement() {
         if (insertOrReplaceStatement == null) {
             String sql = SqlUtils.createSqlInsert("INSERT OR REPLACE INTO ", tablename, allColumns);
-            insertOrReplaceStatement = db.compileStatement(sql);
+            SQLiteStatement newInsertOrReplaceStatement = db.compileStatement(sql);
+            synchronized (this) {
+                if (insertOrReplaceStatement == null) {
+                    insertOrReplaceStatement = newInsertOrReplaceStatement;
+                }
+            }
+            if (insertOrReplaceStatement != newInsertOrReplaceStatement) {
+                newInsertOrReplaceStatement.close();
+            }
         }
         return insertOrReplaceStatement;
     }
@@ -61,7 +79,15 @@ public SQLiteStatement getInsertOrReplaceStatement() {
     public SQLiteStatement getDeleteStatement() {
         if (deleteStatement == null) {
             String sql = SqlUtils.createSqlDelete(tablename, pkColumns);
-            deleteStatement = db.compileStatement(sql);
+            SQLiteStatement newDeleteStatement = db.compileStatement(sql);
+            synchronized (this) {
+                if (deleteStatement == null) {
+                    deleteStatement = newDeleteStatement;
+                }
+            }
+            if (deleteStatement != newDeleteStatement) {
+                newDeleteStatement.close();
+            }
         }
         return deleteStatement;
     }
@@ -69,7 +95,15 @@ public SQLiteStatement getDeleteStatement() {
     public SQLiteStatement getUpdateStatement() {
         if (updateStatement == null) {
             String sql = SqlUtils.createSqlUpdate(tablename, allColumns, pkColumns);
-            updateStatement = db.compileStatement(sql);
+            SQLiteStatement newUpdateStatement = db.compileStatement(sql);
+            synchronized (this) {
+                if (updateStatement == null) {
+                    updateStatement = newUpdateStatement;
+                }
+            }
+            if (updateStatement != newUpdateStatement) {
+                newUpdateStatement.close();
+            }
         }
         return updateStatement;
     }
@@ -77,7 +111,7 @@ public SQLiteStatement getUpdateStatement() {
     /** ends with an space to simplify appending to this string. */
     public String getSelectAll() {
         if (selectAll == null) {
-            selectAll = SqlUtils.createSqlSelect(tablename, "T", allColumns);
+            selectAll = SqlUtils.createSqlSelect(tablename, "T", allColumns, false);
         }
         return selectAll;
     }
@@ -85,7 +119,7 @@ public String getSelectAll() {
     /** ends with an space to simplify appending to this string. */
     public String getSelectKeys() {
         if (selectKeys == null) {
-            selectKeys = SqlUtils.createSqlSelect(tablename, "T", pkColumns);
+            selectKeys = SqlUtils.createSqlSelect(tablename, "T", pkColumns, false);
         }
         return selectKeys;
     }
diff --git a/DaoCore/src/de/greenrobot/dao/query/AbstractQuery.java b/DaoCore/src/main/java/de/greenrobot/dao/query/AbstractQuery.java
similarity index 90%
rename from DaoCore/src/de/greenrobot/dao/query/AbstractQuery.java
rename to DaoCore/src/main/java/de/greenrobot/dao/query/AbstractQuery.java
index c2e5bf9c..3d5c27e8 100644
--- a/DaoCore/src/de/greenrobot/dao/query/AbstractQuery.java
+++ b/DaoCore/src/main/java/de/greenrobot/dao/query/AbstractQuery.java
@@ -27,7 +27,9 @@
  * @param <T>
  *            The entity class the query will return results for.
  */
-// TODO support long, double, blob types directly
+// TODO support long, double and other types, not just Strings, for parameters
+// TODO Make parameters setable by Property (if unique in parameters)
+// TODO Make query compilable
 abstract class AbstractQuery<T> {
     protected final AbstractDao<T, ?> dao;
     protected final InternalQueryDaoAccess<T> daoAccess;
@@ -64,13 +66,14 @@ protected AbstractQuery(AbstractDao<T, ?> dao, String sql, String[] parameters)
     /**
      * Sets the parameter (0 based) using the position in which it was added during building the query.
      */
-    public void setParameter(int index, Object parameter) {
+    public AbstractQuery<T> setParameter(int index, Object parameter) {
         checkThread();
         if (parameter != null) {
             parameters[index] = parameter.toString();
         } else {
             parameters[index] = null;
         }
+        return this;
     }
 
     protected void checkThread() {
diff --git a/DaoCore/src/de/greenrobot/dao/query/AbstractQueryData.java b/DaoCore/src/main/java/de/greenrobot/dao/query/AbstractQueryData.java
similarity index 85%
rename from DaoCore/src/de/greenrobot/dao/query/AbstractQueryData.java
rename to DaoCore/src/main/java/de/greenrobot/dao/query/AbstractQueryData.java
index 7a4736ec..460bc857 100644
--- a/DaoCore/src/de/greenrobot/dao/query/AbstractQueryData.java
+++ b/DaoCore/src/main/java/de/greenrobot/dao/query/AbstractQueryData.java
@@ -31,6 +31,14 @@ Q forCurrentThread(Q query) {
 
     Q forCurrentThread() {
         int threadId = Process.myTid();
+        if (threadId == 0) {
+            // Workaround for Robolectric, always returns 0
+            long id = Thread.currentThread().getId();
+            if (id < 0 || id > Integer.MAX_VALUE) {
+                throw new RuntimeException("Cannot handle thread ID: " + id);
+            }
+            threadId = (int) id;
+        }
         synchronized (queriesForThreads) {
             WeakReference<Q> queryRef = queriesForThreads.get(threadId);
             Q query = queryRef != null ? queryRef.get() : null;
diff --git a/DaoCore/src/main/java/de/greenrobot/dao/query/AbstractQueryWithLimit.java b/DaoCore/src/main/java/de/greenrobot/dao/query/AbstractQueryWithLimit.java
new file mode 100644
index 00000000..c1816812
--- /dev/null
+++ b/DaoCore/src/main/java/de/greenrobot/dao/query/AbstractQueryWithLimit.java
@@ -0,0 +1,87 @@
+/*
+ * Copyright (C) 2011-2015 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.dao.query;
+
+import de.greenrobot.dao.AbstractDao;
+
+import java.util.Date;
+
+/**
+ * Base class for queries returning data (entities or cursor).
+ *
+ * @param <T> The entity class the query will return results for.
+ * @author Markus
+ */
+// TODO Query for PKs/ROW IDs
+abstract class AbstractQueryWithLimit<T> extends AbstractQuery<T> {
+    protected final int limitPosition;
+    protected final int offsetPosition;
+
+    protected AbstractQueryWithLimit(AbstractDao<T, ?> dao, String sql, String[] initialValues, int limitPosition,
+                                     int offsetPosition) {
+        super(dao, sql, initialValues);
+        this.limitPosition = limitPosition;
+        this.offsetPosition = offsetPosition;
+    }
+
+    /**
+     * Sets the parameter (0 based) using the position in which it was added during building the query. Note: all
+     * standard WHERE parameters come first. After that come the WHERE parameters of joins (if any).
+     */
+    public AbstractQueryWithLimit<T> setParameter(int index, Object parameter) {
+        if (index >= 0 && (index == limitPosition || index == offsetPosition)) {
+            throw new IllegalArgumentException("Illegal parameter index: " + index);
+        }
+        return (AbstractQueryWithLimit<T>) super.setParameter(index, parameter);
+    }
+
+    public AbstractQueryWithLimit<T> setParameter(int index, Date parameter) {
+        Long converted = parameter != null ? parameter.getTime() : null;
+        return setParameter(index, converted);
+    }
+
+    public AbstractQueryWithLimit<T> setParameter(int index, Boolean parameter) {
+        Integer converted = parameter != null ? (parameter ? 1 : 0) : null;
+        return setParameter(index, converted);
+    }
+
+    /**
+     * Sets the limit of the maximum number of results returned by this Query. {@link
+     * de.greenrobot.dao.query.QueryBuilder#limit(int)} must
+     * have been called on the QueryBuilder that created this Query object.
+     */
+    public void setLimit(int limit) {
+        checkThread();
+        if (limitPosition == -1) {
+            throw new IllegalStateException("Limit must be set with QueryBuilder before it can be used here");
+        }
+        parameters[limitPosition] = Integer.toString(limit);
+    }
+
+    /**
+     * Sets the offset for results returned by this Query. {@link de.greenrobot.dao.query.QueryBuilder#offset(int)} must
+     * have been called on
+     * the QueryBuilder that created this Query object.
+     */
+    public void setOffset(int offset) {
+        checkThread();
+        if (offsetPosition == -1) {
+            throw new IllegalStateException("Offset must be set with QueryBuilder before it can be used here");
+        }
+        parameters[offsetPosition] = Integer.toString(offset);
+    }
+
+}
diff --git a/DaoCore/src/de/greenrobot/dao/query/CloseableListIterator.java b/DaoCore/src/main/java/de/greenrobot/dao/query/CloseableListIterator.java
similarity index 100%
rename from DaoCore/src/de/greenrobot/dao/query/CloseableListIterator.java
rename to DaoCore/src/main/java/de/greenrobot/dao/query/CloseableListIterator.java
diff --git a/DaoCore/src/de/greenrobot/dao/query/CountQuery.java b/DaoCore/src/main/java/de/greenrobot/dao/query/CountQuery.java
similarity index 100%
rename from DaoCore/src/de/greenrobot/dao/query/CountQuery.java
rename to DaoCore/src/main/java/de/greenrobot/dao/query/CountQuery.java
diff --git a/DaoCore/src/main/java/de/greenrobot/dao/query/CursorQuery.java b/DaoCore/src/main/java/de/greenrobot/dao/query/CursorQuery.java
new file mode 100644
index 00000000..9ca90917
--- /dev/null
+++ b/DaoCore/src/main/java/de/greenrobot/dao/query/CursorQuery.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2011-2015 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.dao.query;
+
+import android.database.Cursor;
+import de.greenrobot.dao.AbstractDao;
+
+/**
+ * A repeatable query returning a raw android.database.Cursor. Note, that using cursors is usually a hassle and
+ * greenDAO provides a higher level abstraction using entities (see {@link de.greenrobot.dao.query.Query}). This class
+ * can nevertheless be useful to work with legacy code that is based on Cursors or CursorLoaders.
+ *
+ * @param <T> The entity class the query will return results for.
+ * @author Markus
+ */
+public class CursorQuery<T> extends AbstractQueryWithLimit<T> {
+    private final static class QueryData<T2> extends AbstractQueryData<T2, CursorQuery<T2>> {
+        private final int limitPosition;
+        private final int offsetPosition;
+
+        QueryData(AbstractDao dao, String sql, String[] initialValues, int limitPosition, int offsetPosition) {
+            super(dao, sql, initialValues);
+            this.limitPosition = limitPosition;
+            this.offsetPosition = offsetPosition;
+        }
+
+        @Override
+        protected CursorQuery<T2> createQuery() {
+            return new CursorQuery<T2>(this, dao, sql, initialValues.clone(), limitPosition, offsetPosition);
+        }
+
+    }
+
+    /** For internal use by greenDAO only. */
+    public static <T2> CursorQuery<T2> internalCreate(AbstractDao<T2, ?> dao, String sql, Object[] initialValues) {
+        return create(dao, sql, initialValues, -1, -1);
+    }
+
+    static <T2> CursorQuery<T2> create(AbstractDao<T2, ?> dao, String sql, Object[] initialValues, int limitPosition,
+                                       int offsetPosition) {
+        QueryData<T2> queryData = new QueryData<T2>(dao, sql, toStringArray(initialValues), limitPosition,
+                offsetPosition);
+        return queryData.forCurrentThread();
+    }
+
+    private final QueryData<T> queryData;
+
+    private CursorQuery(QueryData<T> queryData, AbstractDao<T, ?> dao, String sql, String[] initialValues, int limitPosition,
+                        int offsetPosition) {
+        super(dao, sql, initialValues, limitPosition, offsetPosition);
+        this.queryData = queryData;
+    }
+
+    public CursorQuery forCurrentThread() {
+        return queryData.forCurrentThread(this);
+    }
+
+    /** Executes the query and returns a raw android.database.Cursor. Don't forget to close it. */
+    public Cursor query() {
+        checkThread();
+        return dao.getDatabase().rawQuery(sql, parameters);
+    }
+
+}
diff --git a/DaoCore/src/de/greenrobot/dao/query/DeleteQuery.java b/DaoCore/src/main/java/de/greenrobot/dao/query/DeleteQuery.java
similarity index 97%
rename from DaoCore/src/de/greenrobot/dao/query/DeleteQuery.java
rename to DaoCore/src/main/java/de/greenrobot/dao/query/DeleteQuery.java
index 983e3720..ae4960e8 100644
--- a/DaoCore/src/de/greenrobot/dao/query/DeleteQuery.java
+++ b/DaoCore/src/main/java/de/greenrobot/dao/query/DeleteQuery.java
@@ -25,7 +25,7 @@
  * @author Markus
  * 
  * @param <T>
- *            The enitity class the query will delete from.
+ *            The entity class the query will delete from.
  */
 public class DeleteQuery<T> extends AbstractQuery<T> {
     private final static class QueryData<T2> extends AbstractQueryData<T2, DeleteQuery<T2>> {
diff --git a/DaoCore/src/de/greenrobot/dao/query/Join.java b/DaoCore/src/main/java/de/greenrobot/dao/query/Join.java
similarity index 91%
rename from DaoCore/src/de/greenrobot/dao/query/Join.java
rename to DaoCore/src/main/java/de/greenrobot/dao/query/Join.java
index ab142a06..04dba3fe 100644
--- a/DaoCore/src/de/greenrobot/dao/query/Join.java
+++ b/DaoCore/src/main/java/de/greenrobot/dao/query/Join.java
@@ -80,4 +80,12 @@ public WhereCondition and(WhereCondition cond1, WhereCondition cond2, WhereCondi
         return whereCollector.combineWhereConditions(" AND ", cond1, cond2, condMore);
     }
 
+    /**
+     * Usually you don't need this value; just in case you are mixing custom
+     * {@link de.greenrobot.dao.query.WhereCondition.StringCondition} into the query, this value allows to reference
+     * the joined (target) table.
+     */
+    public String getTablePrefix() {
+        return tablePrefix;
+    }
 }
diff --git a/DaoCore/src/de/greenrobot/dao/query/LazyList.java b/DaoCore/src/main/java/de/greenrobot/dao/query/LazyList.java
similarity index 100%
rename from DaoCore/src/de/greenrobot/dao/query/LazyList.java
rename to DaoCore/src/main/java/de/greenrobot/dao/query/LazyList.java
diff --git a/DaoCore/src/de/greenrobot/dao/query/Query.java b/DaoCore/src/main/java/de/greenrobot/dao/query/Query.java
similarity index 66%
rename from DaoCore/src/de/greenrobot/dao/query/Query.java
rename to DaoCore/src/main/java/de/greenrobot/dao/query/Query.java
index d3d3e47a..301712f5 100644
--- a/DaoCore/src/de/greenrobot/dao/query/Query.java
+++ b/DaoCore/src/main/java/de/greenrobot/dao/query/Query.java
@@ -25,14 +25,10 @@
 /**
  * A repeatable query returning entities.
  *
- * @param <T> The enitity class the query will return results for.
+ * @param <T> The entity class the query will return results for.
  * @author Markus
  */
-// TODO support long, double and other types, not just Strings, for parameters
-// TODO Make parameters setable by Property (if unique in paramaters)
-// TODO Query for PKs/ROW IDs
-// TODO Make query compilable
-public class Query<T> extends AbstractQuery<T> {
+public class Query<T> extends AbstractQueryWithLimit<T> {
     private final static class QueryData<T2> extends AbstractQueryData<T2, Query<T2>> {
         private final int limitPosition;
         private final int offsetPosition;
@@ -62,67 +58,18 @@
         return queryData.forCurrentThread();
     }
 
-    private final int limitPosition;
-    private final int offsetPosition;
     private final QueryData<T> queryData;
 
     private Query(QueryData<T> queryData, AbstractDao<T, ?> dao, String sql, String[] initialValues, int limitPosition,
                   int offsetPosition) {
-        super(dao, sql, initialValues);
+        super(dao, sql, initialValues, limitPosition, offsetPosition);
         this.queryData = queryData;
-        this.limitPosition = limitPosition;
-        this.offsetPosition = offsetPosition;
     }
 
     public Query<T> forCurrentThread() {
         return queryData.forCurrentThread(this);
     }
 
-    /**
-     * Sets the parameter (0 based) using the position in which it was added during building the query. Note: all
-     * standard WHERE parameters come first. After that come the WHERE parameters of joins (if any).
-     */
-    public void setParameter(int index, Object parameter) {
-        if (index >= 0 && (index == limitPosition || index == offsetPosition)) {
-            throw new IllegalArgumentException("Illegal parameter index: " + index);
-        }
-        super.setParameter(index, parameter);
-    }
-
-    public void setParameter(int index, Date parameter) {
-        Long converted = parameter != null ? parameter.getTime() : null;
-        setParameter(index, converted);
-    }
-
-    public void setParameter(int index, Boolean parameter) {
-        Integer converted = parameter != null ? (parameter ? 1 : 0) : null;
-        setParameter(index, converted);
-    }
-
-    /**
-     * Sets the limit of the maximum number of results returned by this Query. {@link QueryBuilder#limit(int)} must
-     * have been called on the QueryBuilder that created this Query object.
-     */
-    public void setLimit(int limit) {
-        checkThread();
-        if (limitPosition == -1) {
-            throw new IllegalStateException("Limit must be set with QueryBuilder before it can be used here");
-        }
-        parameters[limitPosition] = Integer.toString(limit);
-    }
-
-    /**
-     * Sets the offset for results returned by this Query. {@link QueryBuilder#offset(int)} must have been called on
-     * the QueryBuilder that created this Query object.
-     */
-    public void setOffset(int offset) {
-        checkThread();
-        if (offsetPosition == -1) {
-            throw new IllegalStateException("Offset must be set with QueryBuilder before it can be used here");
-        }
-        parameters[offsetPosition] = Integer.toString(offset);
-    }
-
     /** Executes the query and returns the result as a list containing all entities loaded into memory. */
     public List<T> list() {
         checkThread();
@@ -185,4 +132,18 @@ public T uniqueOrThrow() {
         return entity;
     }
 
+    @Override
+    public Query<T> setParameter(int index, Object parameter) {
+        return (Query<T>) super.setParameter(index, parameter);
+    }
+
+    @Override
+    public Query<T> setParameter(int index, Date parameter) {
+        return (Query<T>) super.setParameter(index, parameter);
+    }
+
+    @Override
+    public Query<T> setParameter(int index, Boolean parameter) {
+        return (Query<T>) super.setParameter(index, parameter);
+    }
 }
diff --git a/DaoCore/src/de/greenrobot/dao/query/QueryBuilder.java b/DaoCore/src/main/java/de/greenrobot/dao/query/QueryBuilder.java
similarity index 92%
rename from DaoCore/src/de/greenrobot/dao/query/QueryBuilder.java
rename to DaoCore/src/main/java/de/greenrobot/dao/query/QueryBuilder.java
index 96b904bf..2e621838 100644
--- a/DaoCore/src/de/greenrobot/dao/query/QueryBuilder.java
+++ b/DaoCore/src/main/java/de/greenrobot/dao/query/QueryBuilder.java
@@ -58,6 +58,7 @@
 
     private Integer limit;
     private Integer offset;
+    private boolean distinct;
 
     /** For internal use by greenDAO only. */
     public static <T2> QueryBuilder<T2> internalCreate(AbstractDao<T2, ?> dao) {
@@ -84,6 +85,12 @@ private void checkOrderBuilder() {
         }
     }
 
+    /** Use a SELECT DISTINCT to avoid duplicate entities returned, e.g. when doing joins. */
+    public QueryBuilder<T> distinct() {
+        distinct = true;
+        return this;
+    }
+
     /**
      * Adds the given conditions to the where clause using an logical AND. To create new conditions, use the properties
      * given in the generated dao classes.
@@ -236,7 +243,33 @@ protected StringBuilder append(StringBuilder builder, Property property) {
      * each execution.
      */
     public Query<T> build() {
-        String select = SqlUtils.createSqlSelect(dao.getTablename(), tablePrefix, dao.getAllColumns());
+        StringBuilder builder = createSelectBuilder();
+        int limitPosition = checkAddLimit(builder);
+        int offsetPosition = checkAddOffset(builder);
+
+        String sql = builder.toString();
+        checkLog(sql);
+
+        return Query.create(dao, sql, values.toArray(), limitPosition, offsetPosition);
+    }
+
+    /**
+     * Builds a reusable query object for low level android.database.Cursor access.
+     * (Query objects can be executed more efficiently than creating a QueryBuilder for each execution.
+     */
+    public CursorQuery buildCursor() {
+        StringBuilder builder = createSelectBuilder();
+        int limitPosition = checkAddLimit(builder);
+        int offsetPosition = checkAddOffset(builder);
+
+        String sql = builder.toString();
+        checkLog(sql);
+
+        return CursorQuery.create(dao, sql, values.toArray(), limitPosition, offsetPosition);
+    }
+
+    private StringBuilder createSelectBuilder() {
+        String select = SqlUtils.createSqlSelect(dao.getTablename(), tablePrefix, dao.getAllColumns(), distinct);
         StringBuilder builder = new StringBuilder(select);
 
         appendJoinsAndWheres(builder, tablePrefix);
@@ -244,14 +277,20 @@ protected StringBuilder append(StringBuilder builder, Property property) {
         if (orderBuilder != null && orderBuilder.length() > 0) {
             builder.append(" ORDER BY ").append(orderBuilder);
         }
+        return builder;
+    }
 
+    private int checkAddLimit(StringBuilder builder) {
         int limitPosition = -1;
         if (limit != null) {
             builder.append(" LIMIT ?");
             values.add(limit);
             limitPosition = values.size() - 1;
         }
+        return limitPosition;
+    }
 
+    private int checkAddOffset(StringBuilder builder) {
         int offsetPosition = -1;
         if (offset != null) {
             if (limit == null) {
@@ -261,11 +300,7 @@ protected StringBuilder append(StringBuilder builder, Property property) {
             values.add(offset);
             offsetPosition = values.size() - 1;
         }
-
-        String sql = builder.toString();
-        checkLog(sql);
-
-        return Query.create(dao, sql, values.toArray(), limitPosition, offsetPosition);
+        return offsetPosition;
     }
 
     /**
@@ -287,7 +322,7 @@ protected StringBuilder append(StringBuilder builder, Property property) {
         String sql = builder.toString();
         // Remove table aliases, not supported for DELETE queries.
         // TODO(?): don't create table aliases in the first place.
-        sql = sql.replace(tablePrefix + ".\"", '"'+tablename + "\".\"");
+        sql = sql.replace(tablePrefix + ".\"", '"' + tablename + "\".\"");
         checkLog(sql);
 
         return DeleteQuery.create(dao, sql, values.toArray());
diff --git a/DaoCore/src/de/greenrobot/dao/query/WhereCollector.java b/DaoCore/src/main/java/de/greenrobot/dao/query/WhereCollector.java
similarity index 100%
rename from DaoCore/src/de/greenrobot/dao/query/WhereCollector.java
rename to DaoCore/src/main/java/de/greenrobot/dao/query/WhereCollector.java
diff --git a/DaoCore/src/de/greenrobot/dao/query/WhereCondition.java b/DaoCore/src/main/java/de/greenrobot/dao/query/WhereCondition.java
similarity index 98%
rename from DaoCore/src/de/greenrobot/dao/query/WhereCondition.java
rename to DaoCore/src/main/java/de/greenrobot/dao/query/WhereCondition.java
index aa234d07..49f17a73 100644
--- a/DaoCore/src/de/greenrobot/dao/query/WhereCondition.java
+++ b/DaoCore/src/main/java/de/greenrobot/dao/query/WhereCondition.java
@@ -99,7 +99,7 @@ private static Object checkValueForType(Property property, Object value) {
                         return 0;
                     } else {
                         throw new DaoException(
-                                "Illegal boolean value: Strings must be \"TRUE\" or \"FALSE\" (case insesnsitive), but was "
+                                "Illegal boolean value: Strings must be \"TRUE\" or \"FALSE\" (case insensitive), but was "
                                         + value);
                     }
                 }
diff --git a/DaoCore/src/de/greenrobot/dao/test/AbstractDaoSessionTest.java b/DaoCore/src/main/java/de/greenrobot/dao/test/AbstractDaoSessionTest.java
similarity index 100%
rename from DaoCore/src/de/greenrobot/dao/test/AbstractDaoSessionTest.java
rename to DaoCore/src/main/java/de/greenrobot/dao/test/AbstractDaoSessionTest.java
diff --git a/DaoCore/src/de/greenrobot/dao/test/AbstractDaoTest.java b/DaoCore/src/main/java/de/greenrobot/dao/test/AbstractDaoTest.java
similarity index 100%
rename from DaoCore/src/de/greenrobot/dao/test/AbstractDaoTest.java
rename to DaoCore/src/main/java/de/greenrobot/dao/test/AbstractDaoTest.java
diff --git a/DaoCore/src/de/greenrobot/dao/test/AbstractDaoTestLongPk.java b/DaoCore/src/main/java/de/greenrobot/dao/test/AbstractDaoTestLongPk.java
similarity index 100%
rename from DaoCore/src/de/greenrobot/dao/test/AbstractDaoTestLongPk.java
rename to DaoCore/src/main/java/de/greenrobot/dao/test/AbstractDaoTestLongPk.java
diff --git a/DaoCore/src/de/greenrobot/dao/test/AbstractDaoTestSinglePk.java b/DaoCore/src/main/java/de/greenrobot/dao/test/AbstractDaoTestSinglePk.java
similarity index 100%
rename from DaoCore/src/de/greenrobot/dao/test/AbstractDaoTestSinglePk.java
rename to DaoCore/src/main/java/de/greenrobot/dao/test/AbstractDaoTestSinglePk.java
diff --git a/DaoCore/src/de/greenrobot/dao/test/AbstractDaoTestStringPk.java b/DaoCore/src/main/java/de/greenrobot/dao/test/AbstractDaoTestStringPk.java
similarity index 100%
rename from DaoCore/src/de/greenrobot/dao/test/AbstractDaoTestStringPk.java
rename to DaoCore/src/main/java/de/greenrobot/dao/test/AbstractDaoTestStringPk.java
diff --git a/DaoCore/src/de/greenrobot/dao/test/DbTest.java b/DaoCore/src/main/java/de/greenrobot/dao/test/DbTest.java
similarity index 100%
rename from DaoCore/src/de/greenrobot/dao/test/DbTest.java
rename to DaoCore/src/main/java/de/greenrobot/dao/test/DbTest.java
diff --git a/DaoExample/.gitignore b/DaoExample/.gitignore
deleted file mode 100644
index c181ae51..00000000
--- a/DaoExample/.gitignore
+++ /dev/null
@@ -1,3 +0,0 @@
-/bin
-/gen
-/build
diff --git a/DaoExample/AndroidManifest.xml b/DaoExample/AndroidManifest.xml
deleted file mode 100644
index 28fb3a4f..00000000
--- a/DaoExample/AndroidManifest.xml
+++ /dev/null
@@ -1,18 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-      package="de.greenrobot.daoexample"
-      android:versionCode="1"
-      android:versionName="1.0">
-    <uses-sdk android:minSdkVersion="4" />
-
-    <instrumentation android:targetPackage="de.greenrobot.daoexample" android:name="android.test.InstrumentationTestRunner" />
-    <application android:icon="@drawable/icon" android:label="@string/app_name">
-        <activity android:name=".NoteActivity">
-            <intent-filter>
-                <action android:name="android.intent.action.MAIN" />
-                <category android:name="android.intent.category.LAUNCHER" />
-            </intent-filter>
-        </activity>
-        <uses-library android:name="android.test.runner" />
-    </application>
-</manifest>
\ No newline at end of file
diff --git a/DaoExample/build.gradle b/DaoExample/build.gradle
index 6bce52b3..5b7bee89 100644
--- a/DaoExample/build.gradle
+++ b/DaoExample/build.gradle
@@ -1,28 +1,40 @@
-// Just a dummy script building a useless jar file. Waiting for version 0.3 of Android's new build system. 
-apply plugin: 'java'
-apply plugin: 'maven'
+buildscript {
+    repositories {
+        mavenCentral()
+    }
+
+    dependencies {
+        classpath 'com.android.tools.build:gradle:2.1.2'
+    }
+}
 
-group = 'de.greenrobot'
-version = '1.3.0'
-sourceCompatibility = 1.6
+apply plugin: 'com.android.application'
 
 repositories {
     mavenCentral()
 }
 
-dependencies {
-    compile('de.greenrobot:greendao:1.3.0')
-}
+android {
+    buildToolsVersion rootProject.ext.buildToolsVersion
+    compileSdkVersion rootProject.ext.compileSdkVersion
 
-sourceSets {
-    main {
-        java {
-            srcDir 'src'
-            srcDir 'src-gen'
-            srcDir 'gen'
-        }
+    defaultConfig {
+        applicationId "de.greenrobot.daoexample"
+        minSdkVersion rootProject.ext.minSdkVersion
+        targetSdkVersion rootProject.ext.targetSdkVersion
+        versionCode 1
+        versionName "1.3.0"
+
+        testInstrumentationRunner "android.test.InstrumentationTestRunner"
+    }
+
+    compileOptions {
+        encoding = "UTF-8"
+        sourceCompatibility JavaVersion.VERSION_1_6
+        targetCompatibility JavaVersion.VERSION_1_6
     }
 }
-artifacts {
-    archives jar
-}
+
+dependencies {
+    compile project(':DaoCore')
+}
\ No newline at end of file
diff --git a/DaoExample/docs/greenDAO-javadoc.jar b/DaoExample/docs/greenDAO-javadoc.jar
deleted file mode 100644
index 51df4738..00000000
Binary files a/DaoExample/docs/greenDAO-javadoc.jar and /dev/null differ
diff --git a/DaoExample/libs/greendao-1.3.0-beta-1.jar b/DaoExample/libs/greendao-1.3.0-beta-1.jar
deleted file mode 100644
index 473993d4..00000000
Binary files a/DaoExample/libs/greendao-1.3.0-beta-1.jar and /dev/null differ
diff --git a/DaoExample/settings.gradle b/DaoExample/settings.gradle
deleted file mode 100644
index 96dff2be..00000000
--- a/DaoExample/settings.gradle
+++ /dev/null
@@ -1 +0,0 @@
-rootProject.name = 'greendao-example'
\ No newline at end of file
diff --git a/DaoExample/src-test/de/greenrobot/daoexample/CustomerOrderTest.java b/DaoExample/src/androidTest/Java/de/greenrobot/daoexample/CustomerOrderTest.java
similarity index 94%
rename from DaoExample/src-test/de/greenrobot/daoexample/CustomerOrderTest.java
rename to DaoExample/src/androidTest/Java/de/greenrobot/daoexample/CustomerOrderTest.java
index 28980818..e24eca48 100644
--- a/DaoExample/src-test/de/greenrobot/daoexample/CustomerOrderTest.java
+++ b/DaoExample/src/androidTest/Java/de/greenrobot/daoexample/CustomerOrderTest.java
@@ -6,7 +6,7 @@
 import android.app.Application;
 import de.greenrobot.dao.test.AbstractDaoSessionTest;
 
-public class CustomerOrderTest extends AbstractDaoSessionTest<Application, DaoMaster, DaoSession> {
+public class CustomerOrderTest extends AbstractDaoSessionTest<DaoMaster, DaoSession> {
 
     public CustomerOrderTest() {
         super(DaoMaster.class);
diff --git a/DaoExample/src-test/de/greenrobot/daoexample/NoteTest.java b/DaoExample/src/androidTest/Java/de/greenrobot/daoexample/NoteTest.java
similarity index 100%
rename from DaoExample/src-test/de/greenrobot/daoexample/NoteTest.java
rename to DaoExample/src/androidTest/Java/de/greenrobot/daoexample/NoteTest.java
diff --git a/DaoExample/src/main/AndroidManifest.xml b/DaoExample/src/main/AndroidManifest.xml
new file mode 100644
index 00000000..c46d2e15
--- /dev/null
+++ b/DaoExample/src/main/AndroidManifest.xml
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="de.greenrobot.daoexample">
+
+    <application
+        android:icon="@drawable/icon"
+        android:label="@string/app_name"
+        android:allowBackup="true">
+        <activity android:name=".NoteActivity">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+        </activity>
+    </application>
+
+</manifest>
\ No newline at end of file
diff --git a/DaoExample/src-gen/de/greenrobot/daoexample/Customer.java b/DaoExample/src/main/java/de/greenrobot/daoexample/Customer.java
similarity index 98%
rename from DaoExample/src-gen/de/greenrobot/daoexample/Customer.java
rename to DaoExample/src/main/java/de/greenrobot/daoexample/Customer.java
index ed2996f7..0198288d 100644
--- a/DaoExample/src-gen/de/greenrobot/daoexample/Customer.java
+++ b/DaoExample/src/main/java/de/greenrobot/daoexample/Customer.java
@@ -6,7 +6,7 @@
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
 /**
- * Entity mapped to table CUSTOMER.
+ * Entity mapped to table "CUSTOMER".
  */
 public class Customer {
 
diff --git a/DaoExample/src-gen/de/greenrobot/daoexample/CustomerDao.java b/DaoExample/src/main/java/de/greenrobot/daoexample/CustomerDao.java
similarity index 93%
rename from DaoExample/src-gen/de/greenrobot/daoexample/CustomerDao.java
rename to DaoExample/src/main/java/de/greenrobot/daoexample/CustomerDao.java
index 25a88fc3..f9df3d31 100644
--- a/DaoExample/src-gen/de/greenrobot/daoexample/CustomerDao.java
+++ b/DaoExample/src/main/java/de/greenrobot/daoexample/CustomerDao.java
@@ -12,7 +12,7 @@
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
- * DAO for table CUSTOMER.
+ * DAO for table "CUSTOMER".
 */
 public class CustomerDao extends AbstractDao<Customer, Long> {
 
@@ -42,14 +42,14 @@ public CustomerDao(DaoConfig config, DaoSession daoSession) {
     /** Creates the underlying database table. */
     public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
-        db.execSQL("CREATE TABLE " + constraint + "'CUSTOMER' (" + //
-                "'_id' INTEGER PRIMARY KEY ," + // 0: id
-                "'NAME' TEXT NOT NULL );"); // 1: name
+        db.execSQL("CREATE TABLE " + constraint + "\"CUSTOMER\" (" + //
+                "\"_id\" INTEGER PRIMARY KEY ," + // 0: id
+                "\"NAME\" TEXT NOT NULL );"); // 1: name
     }
 
     /** Drops the underlying database table. */
     public static void dropTable(SQLiteDatabase db, boolean ifExists) {
-        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'CUSTOMER'";
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "\"CUSTOMER\"";
         db.execSQL(sql);
     }
 
diff --git a/DaoExample/src-gen/de/greenrobot/daoexample/DaoMaster.java b/DaoExample/src/main/java/de/greenrobot/daoexample/DaoMaster.java
similarity index 100%
rename from DaoExample/src-gen/de/greenrobot/daoexample/DaoMaster.java
rename to DaoExample/src/main/java/de/greenrobot/daoexample/DaoMaster.java
diff --git a/DaoExample/src-gen/de/greenrobot/daoexample/DaoSession.java b/DaoExample/src/main/java/de/greenrobot/daoexample/DaoSession.java
similarity index 100%
rename from DaoExample/src-gen/de/greenrobot/daoexample/DaoSession.java
rename to DaoExample/src/main/java/de/greenrobot/daoexample/DaoSession.java
diff --git a/DaoExample/src-gen/de/greenrobot/daoexample/Note.java b/DaoExample/src/main/java/de/greenrobot/daoexample/Note.java
similarity index 97%
rename from DaoExample/src-gen/de/greenrobot/daoexample/Note.java
rename to DaoExample/src/main/java/de/greenrobot/daoexample/Note.java
index ed057058..e8d9e1e9 100644
--- a/DaoExample/src-gen/de/greenrobot/daoexample/Note.java
+++ b/DaoExample/src/main/java/de/greenrobot/daoexample/Note.java
@@ -2,7 +2,7 @@
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
 /**
- * Entity mapped to table NOTE.
+ * Entity mapped to table "NOTE".
  */
 public class Note {
 
diff --git a/DaoExample/src/de/greenrobot/daoexample/NoteActivity.java b/DaoExample/src/main/java/de/greenrobot/daoexample/NoteActivity.java
similarity index 100%
rename from DaoExample/src/de/greenrobot/daoexample/NoteActivity.java
rename to DaoExample/src/main/java/de/greenrobot/daoexample/NoteActivity.java
diff --git a/DaoExample/src-gen/de/greenrobot/daoexample/NoteDao.java b/DaoExample/src/main/java/de/greenrobot/daoexample/NoteDao.java
similarity index 92%
rename from DaoExample/src-gen/de/greenrobot/daoexample/NoteDao.java
rename to DaoExample/src/main/java/de/greenrobot/daoexample/NoteDao.java
index 0fcaceee..6d7d8306 100644
--- a/DaoExample/src-gen/de/greenrobot/daoexample/NoteDao.java
+++ b/DaoExample/src/main/java/de/greenrobot/daoexample/NoteDao.java
@@ -12,7 +12,7 @@
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
- * DAO for table NOTE.
+ * DAO for table "NOTE".
 */
 public class NoteDao extends AbstractDao<Note, Long> {
 
@@ -41,16 +41,16 @@ public NoteDao(DaoConfig config, DaoSession daoSession) {
     /** Creates the underlying database table. */
     public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
-        db.execSQL("CREATE TABLE " + constraint + "'NOTE' (" + //
-                "'_id' INTEGER PRIMARY KEY ," + // 0: id
-                "'TEXT' TEXT NOT NULL ," + // 1: text
-                "'COMMENT' TEXT," + // 2: comment
-                "'DATE' INTEGER);"); // 3: date
+        db.execSQL("CREATE TABLE " + constraint + "\"NOTE\" (" + //
+                "\"_id\" INTEGER PRIMARY KEY ," + // 0: id
+                "\"TEXT\" TEXT NOT NULL ," + // 1: text
+                "\"COMMENT\" TEXT," + // 2: comment
+                "\"DATE\" INTEGER);"); // 3: date
     }
 
     /** Drops the underlying database table. */
     public static void dropTable(SQLiteDatabase db, boolean ifExists) {
-        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'NOTE'";
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "\"NOTE\"";
         db.execSQL(sql);
     }
 
diff --git a/DaoExample/src-gen/de/greenrobot/daoexample/Order.java b/DaoExample/src/main/java/de/greenrobot/daoexample/Order.java
similarity index 98%
rename from DaoExample/src-gen/de/greenrobot/daoexample/Order.java
rename to DaoExample/src/main/java/de/greenrobot/daoexample/Order.java
index 95ecfb86..49dcd4f3 100644
--- a/DaoExample/src-gen/de/greenrobot/daoexample/Order.java
+++ b/DaoExample/src/main/java/de/greenrobot/daoexample/Order.java
@@ -5,7 +5,7 @@
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
 /**
- * Entity mapped to table ORDERS.
+ * Entity mapped to table "ORDERS".
  */
 public class Order {
 
diff --git a/DaoExample/src-gen/de/greenrobot/daoexample/OrderDao.java b/DaoExample/src/main/java/de/greenrobot/daoexample/OrderDao.java
similarity index 94%
rename from DaoExample/src-gen/de/greenrobot/daoexample/OrderDao.java
rename to DaoExample/src/main/java/de/greenrobot/daoexample/OrderDao.java
index d3ac55a7..9cb68bc3 100644
--- a/DaoExample/src-gen/de/greenrobot/daoexample/OrderDao.java
+++ b/DaoExample/src/main/java/de/greenrobot/daoexample/OrderDao.java
@@ -17,7 +17,7 @@
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
- * DAO for table ORDERS.
+ * DAO for table "ORDERS".
 */
 public class OrderDao extends AbstractDao<Order, Long> {
 
@@ -49,15 +49,15 @@ public OrderDao(DaoConfig config, DaoSession daoSession) {
     /** Creates the underlying database table. */
     public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
-        db.execSQL("CREATE TABLE " + constraint + "'ORDERS' (" + //
-                "'_id' INTEGER PRIMARY KEY ," + // 0: id
-                "'DATE' INTEGER," + // 1: date
-                "'CUSTOMER_ID' INTEGER NOT NULL );"); // 2: customerId
+        db.execSQL("CREATE TABLE " + constraint + "\"ORDERS\" (" + //
+                "\"_id\" INTEGER PRIMARY KEY ," + // 0: id
+                "\"DATE\" INTEGER," + // 1: date
+                "\"CUSTOMER_ID\" INTEGER NOT NULL );"); // 2: customerId
     }
 
     /** Drops the underlying database table. */
     public static void dropTable(SQLiteDatabase db, boolean ifExists) {
-        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'ORDERS'";
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "\"ORDERS\"";
         db.execSQL(sql);
     }
 
@@ -138,7 +138,7 @@ protected boolean isEntityUpdateable() {
             if (customer_OrdersQuery == null) {
                 QueryBuilder<Order> queryBuilder = queryBuilder();
                 queryBuilder.where(Properties.CustomerId.eq(null));
-                queryBuilder.orderRaw("DATE ASC");
+                queryBuilder.orderRaw("T.'DATE' ASC");
                 customer_OrdersQuery = queryBuilder.build();
             }
         }
@@ -156,7 +156,7 @@ protected String getSelectDeep() {
             builder.append(',');
             SqlUtils.appendColumns(builder, "T0", daoSession.getCustomerDao().getAllColumns());
             builder.append(" FROM ORDERS T");
-            builder.append(" LEFT JOIN CUSTOMER T0 ON T.'CUSTOMER_ID'=T0.'_id'");
+            builder.append(" LEFT JOIN CUSTOMER T0 ON T.\"CUSTOMER_ID\"=T0.\"_id\"");
             builder.append(' ');
             selectDeep = builder.toString();
         }
diff --git a/DaoExample/res/drawable-hdpi/icon.png b/DaoExample/src/main/res/drawable-hdpi/icon.png
similarity index 100%
rename from DaoExample/res/drawable-hdpi/icon.png
rename to DaoExample/src/main/res/drawable-hdpi/icon.png
diff --git a/DaoExample/res/drawable-ldpi/icon.png b/DaoExample/src/main/res/drawable-ldpi/icon.png
similarity index 100%
rename from DaoExample/res/drawable-ldpi/icon.png
rename to DaoExample/src/main/res/drawable-ldpi/icon.png
diff --git a/DaoExample/res/drawable-mdpi/icon.png b/DaoExample/src/main/res/drawable-mdpi/icon.png
similarity index 100%
rename from DaoExample/res/drawable-mdpi/icon.png
rename to DaoExample/src/main/res/drawable-mdpi/icon.png
diff --git a/DaoExample/res/layout/main.xml b/DaoExample/src/main/res/layout/main.xml
similarity index 100%
rename from DaoExample/res/layout/main.xml
rename to DaoExample/src/main/res/layout/main.xml
diff --git a/DaoExample/res/values/strings.xml b/DaoExample/src/main/res/values/strings.xml
similarity index 100%
rename from DaoExample/res/values/strings.xml
rename to DaoExample/src/main/res/values/strings.xml
diff --git a/DaoExampleGenerator/.gitignore b/DaoExampleGenerator/.gitignore
deleted file mode 100644
index 81631c69..00000000
--- a/DaoExampleGenerator/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-/bin
-/build
diff --git a/DaoExampleGenerator/build.gradle b/DaoExampleGenerator/build.gradle
index 8d092fd4..059503dd 100644
--- a/DaoExampleGenerator/build.gradle
+++ b/DaoExampleGenerator/build.gradle
@@ -2,9 +2,12 @@ apply plugin: 'java'
 apply plugin: 'maven'
 apply plugin:'application'
 
-group = 'de.greenrobot'
+group = 'org.greenrobot'
+archivesBaseName = 'greendao-example-generator'
 version = '1.4.0-SNAPSHOT'
 sourceCompatibility = 1.6
+
+// If your IDE fails to run generation (NoClassDefFoundError), run it using gradle
 mainClassName = "de.greenrobot.daogenerator.gentest.ExampleDaoGenerator"
 
 dependencies {
diff --git a/DaoExampleGenerator/settings.gradle b/DaoExampleGenerator/settings.gradle
deleted file mode 100644
index 4cd77a8b..00000000
--- a/DaoExampleGenerator/settings.gradle
+++ /dev/null
@@ -1 +0,0 @@
-rootProject.name = 'greendao-example-generator'
\ No newline at end of file
diff --git a/DaoExampleGenerator/src/de/greenrobot/daogenerator/gentest/ExampleDaoGenerator.java b/DaoExampleGenerator/src/de/greenrobot/daogenerator/gentest/ExampleDaoGenerator.java
index f51f9f67..23d957a7 100644
--- a/DaoExampleGenerator/src/de/greenrobot/daogenerator/gentest/ExampleDaoGenerator.java
+++ b/DaoExampleGenerator/src/de/greenrobot/daogenerator/gentest/ExampleDaoGenerator.java
@@ -36,7 +36,7 @@ public static void main(String[] args) throws Exception {
         addNote(schema);
         addCustomerOrder(schema);
 
-        new DaoGenerator().generateAll(schema, "../DaoExample/src-gen");
+        new DaoGenerator().generateAll(schema, "../DaoExample/src/main/java");
     }
 
     private static void addNote(Schema schema) {
diff --git a/DaoGenerator/.gitignore b/DaoGenerator/.gitignore
index 90ffd1f9..6a0dc5ea 100644
--- a/DaoGenerator/.gitignore
+++ b/DaoGenerator/.gitignore
@@ -1,5 +1 @@
-/test-out
-/release
-/bin
 /gradle.properties
-/build
diff --git a/DaoGenerator/build.gradle b/DaoGenerator/build.gradle
index cff744a5..2c64cd07 100644
--- a/DaoGenerator/build.gradle
+++ b/DaoGenerator/build.gradle
@@ -2,9 +2,10 @@ apply plugin: 'java'
 apply plugin: 'maven'
 apply plugin: 'signing'
 
-group = 'de.greenrobot'
-version = '2.0.0'
-sourceCompatibility = 1.6
+group = 'org.greenrobot'
+archivesBaseName = 'greendao-generator'
+version = '2.2.0'
+sourceCompatibility = 1.7
 
 def isSnapshot = version.endsWith('-SNAPSHOT')
 def sonatypeRepositoryUrl
@@ -18,15 +19,12 @@ repositories {
     mavenCentral()
 }
 
-// provided is not supported in Gradle 1.4, see http://issues.gradle.org/browse/GRADLE-784
-// Like this, it won't appear at all in the POM
 configurations {
-    provided
     deployerJars
 }
 
 dependencies {
-    compile 'org.freemarker:freemarker:2.3.22'
+    compile 'org.freemarker:freemarker:2.3.23'
     testCompile 'junit:junit:4.12'
     // deployerJars 'org.apache.maven.wagon:wagon-webdav-jackrabbit:2.4'
     deployerJars 'org.apache.maven.wagon:wagon-webdav:1.0-beta-2'
@@ -58,10 +56,11 @@ test {
 }
 
 javadoc {
+    failOnError = false
     title = "greenDAO Generator ${version} API"
     // Unfinished APIs:
     excludes = ['de/greenrobot/daogenerator/Query*']
-    options.bottom = 'Available under the GPLv3 - <i>Copyright &#169; 2011-2015 <a href="http://greenrobot.de/">greenrobot.de</a>. All Rights Reserved.</i>'
+    options.bottom = 'Available under the GPLv3 - <i>Copyright &#169; 2011-2016 <a href="http://greenrobot.org/">greenrobot.org</a>. All Rights Reserved.</i>'
 }
 
 task javadocJar(type: Jar, dependsOn: javadoc) {
@@ -111,7 +110,7 @@ uploadArchives {
                name 'greenDAO Generator'
                packaging 'jar'
                description 'Code generator for greenDAO, the light and fast ORM for Android'
-               url 'http://greendao-orm.com'
+               url 'http://greenrobot.org/greendao'
 
                scm {
                    url 'https://github.com/greenrobot/greenDAO'
@@ -141,7 +140,7 @@ uploadArchives {
                
                organization {
                    name 'greenrobot'
-                   url 'http://greenrobot.de'
+                   url 'http://greenrobot.org'
                }
            }
         }
diff --git a/DaoGenerator/mybuild.xml b/DaoGenerator/mybuild.xml
deleted file mode 100644
index 72ae38f0..00000000
--- a/DaoGenerator/mybuild.xml
+++ /dev/null
@@ -1,80 +0,0 @@
-<!--
-
-Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)     
-                                                                           
-This file is part of greenDAO Generator.                                   
-                                                                           
-greenDAO Generator is free software: you can redistribute it and/or modify 
-it under the terms of the GNU General Public License as published by       
-the Free Software Foundation, either version 3 of the License, or          
-(at your option) any later version.                                        
-greenDAO Generator is distributed in the hope that it will be useful,      
-but WITHOUT ANY WARRANTY; without even the implied warranty of             
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              
-GNU General Public License for more details.                               
-                                                                           
-You should have received a copy of the GNU General Public License          
-along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
-
--->
-<project name="DaoGenerator" default="build-generator">
-
-    <property name="version" value="1.3.0-SNAPSHOT" />
-	
-	<target name="build-generator" depends="delete-release, build-jar, build-javadoc"></target>
-	
-	<target name="delete-release">
-		<delete dir="release" />
-	</target>
-	
-	<target name="build-jar" description="Depends on Eclipse to have everthing compiled into bin/">
-		<mkdir dir="release" />
-		<jar jarfile="release/greenDAO-generator-${version}.jar" basedir="bin"/>
-	</target>
-
-	<target name="build-javadoc" description="Creates javadoc for classes">
-	    <delete dir="release/docs/api" />
-		<mkdir dir="release/docs/api" />
-		<javadoc destdir="release/docs/api" author="false" version="false" use="true" windowtitle="greenDAO generator API">
-		    <packageset dir="src" defaultexcludes="yes">
-	              <include name="de/greenrobot/daogenerator/**"/>
-		    </packageset>
-			<doctitle><![CDATA[<h1>greenDAO generator API</h1>]]></doctitle>
-		    <bottom><![CDATA[<i>Copyright &#169; 2011-2013 greenrobot.de. All Rights Reserved.</i>]]></bottom>
-		</javadoc>
-        <jar jarfile="release/greenDAO-generator-${version}-javadoc.jar" basedir="release/docs/api"/>
-	</target>
-
-    <target name="refresh-example-jars" description="(Also builds DaoCore and DaoGenerator)">
-        <ant antfile="../DaoCore/mybuild.xml" dir="../DaoCore/"/>
-        <antcall target="build-generator"></antcall>
-        <copy file="../DaoCore/release/greenDAO-${version}.jar" todir="../DaoExample/libs" ></copy>
-        <copy file="../DaoCore/release/greenDAO-${version}-javadoc.jar" todir="../DaoExample/docs" ></copy>
-        <copy file="release/greenDAO-generator-${version}.jar" todir="../DaoExampleGenerator/lib" ></copy>
-        <copy file="release/greenDAO-generator-${version}-javadoc.jar" todir="../DaoExampleGenerator/lib" ></copy>
-    </target>
-	
-	<target name="build-starter-package" description="Builds everything">
-    	<delete dir="release/example"/>
-        <antcall target="refresh-example-jars" />
-
-        <copy todir="release/example/javadoc/greendao" >
-            <fileset dir="../DaoCore/release/docs/api/"/>
-        </copy>
-        <copy todir="release/example/javadoc/greendao-generator" >
-            <fileset dir="release/docs/api/"/>
-        </copy>
-        <copy todir="release/example/DaoExample" >
-            <fileset dir="../DaoExample"/>
-        </copy>
-        <copy todir="release/example/DaoExampleGenerator" >
-            <fileset dir="../DaoExampleGenerator"/>
-        </copy>
-        <copy file="../DaoCore/release/greenDAO-${version}.jar" todir="release/example/" ></copy>
-        <copy file="../DaoCore/release/greenDAO-${version}-javadoc.jar" todir="release/example/" ></copy>
-        <copy file="release/greenDAO-generator-${version}.jar" todir="release/example/" ></copy>
-        <copy file="release/greenDAO-generator-${version}-javadoc.jar" todir="release/example/" ></copy>
-    	<zip destfile="release/greenDAO-${version}.zip" basedir="release/example/"></zip>
-    </target>
-
-</project>
diff --git a/DaoGenerator/settings.gradle b/DaoGenerator/settings.gradle
deleted file mode 100644
index 86014829..00000000
--- a/DaoGenerator/settings.gradle
+++ /dev/null
@@ -1 +0,0 @@
-rootProject.name = 'greendao-generator'
\ No newline at end of file
diff --git a/DaoGenerator/src-template/encryption/content-provider.ftl b/DaoGenerator/src-template/encryption/content-provider.ftl
new file mode 100644
index 00000000..9a61abcf
--- /dev/null
+++ b/DaoGenerator/src-template/encryption/content-provider.ftl
@@ -0,0 +1,218 @@
+package ${contentProvider.javaPackage};
+
+import android.content.ContentProvider;
+import android.content.ContentResolver;
+import android.content.ContentValues;
+import android.content.UriMatcher;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteQueryBuilder;
+import android.net.Uri;
+
+import de.greenrobot.dao.DaoLog;
+import de.greenrobot.dao.database.StandardDatabase;
+import de.greenrobot.dao.database.Database;
+
+import ${schema.defaultJavaPackageDao}.DaoSession;
+import ${entity.javaPackageDao}.${entity.classNameDao};
+
+/* Copy this code snippet into your AndroidManifest.xml inside the
+<application> element:
+
+    <provider
+            android:name="${contentProvider.javaPackage}.${contentProvider.className}"
+            android:authorities="${contentProvider.authority}"/>
+    */
+
+    public class ${contentProvider.className} extends ContentProvider {
+
+    public static final String AUTHORITY = "${contentProvider.authority}";
+    public static final String BASE_PATH = "${contentProvider.basePath}";
+    public static final Uri CONTENT_URI = Uri.parse("content://" + AUTHORITY + "/" + BASE_PATH);
+    public static final String CONTENT_TYPE = ContentResolver.CURSOR_DIR_BASE_TYPE
+    + "/" + BASE_PATH;
+    public static final String CONTENT_ITEM_TYPE = ContentResolver.CURSOR_ITEM_BASE_TYPE
+    + "/" + BASE_PATH;
+
+    private static final String TABLENAME = ${entity.classNameDao}.TABLENAME;
+    private static final String PK = ${entity.classNameDao}.Properties.${entity.pkProperty.propertyName?cap_first}
+    .columnName;
+
+<#assign counter = 0>
+    private static final int ${entity.className?upper_case}_DIR = ${counter};
+    private static final int ${entity.className?upper_case}_ID = ${counter+1};
+
+    private static final UriMatcher sURIMatcher;
+
+    static {
+    sURIMatcher = new UriMatcher(UriMatcher.NO_MATCH);
+    sURIMatcher.addURI(AUTHORITY, BASE_PATH, ${entity.className?upper_case}_DIR);
+    sURIMatcher.addURI(AUTHORITY, BASE_PATH + "/#", ${entity.className?upper_case}_ID);
+    }
+
+    /**
+    * This must be set from outside, it's recommended to do this inside your Application object.
+    * Subject to change (static isn't nice).
+    */
+    public static DaoSession daoSession;
+
+    @Override
+    public boolean onCreate() {
+    // if(daoSession == null) {
+    // throw new IllegalStateException("DaoSession must be set before content provider is created");
+    // }
+    DaoLog.d("Content Provider started: " + CONTENT_URI);
+    return true;
+    }
+
+    protected Database getDatabase() {
+    if(daoSession == null) {
+    throw new IllegalStateException("DaoSession must be set during content provider is active");
+    }
+    return daoSession.getDatabase();
+    }
+
+<#--
+##########################################
+########## Insert ##############
+##########################################
+-->
+    @Override
+    public Uri insert(Uri uri, ContentValues values) {
+<#if contentProvider.isReadOnly()>
+    throw new UnsupportedOperationException("This content provider is readonly");
+<#else>
+    int uriType = sURIMatcher.match(uri);
+    long id = 0;
+    String path = "";
+    switch (uriType) {
+    case ${entity.className?upper_case}_DIR:
+    id = getDatabase().insert(TABLENAME, null, values);
+    path = BASE_PATH + "/" + id;
+    break;
+    default:
+    throw new IllegalArgumentException("Unknown URI: " + uri);
+    }
+    getContext().getContentResolver().notifyChange(uri, null);
+    return Uri.parse(path);
+</#if>
+    }
+
+<#--
+##########################################
+########## Delete ##############
+##########################################
+-->
+    @Override
+    public int delete(Uri uri, String selection, String[] selectionArgs) {
+<#if contentProvider.isReadOnly()>
+    throw new UnsupportedOperationException("This content provider is readonly");
+<#else>
+    int uriType = sURIMatcher.match(uri);
+    Database db = getDatabase();
+    int rowsDeleted = 0;
+    String id;
+    switch (uriType) {
+    case ${entity.className?upper_case}_DIR:
+    rowsDeleted = db.delete(TABLENAME, selection, selectionArgs);
+    break;
+    case ${entity.className?upper_case}_ID:
+    id = uri.getLastPathSegment();
+    if (TextUtils.isEmpty(selection)) {
+    rowsDeleted = db.delete(TABLENAME, PK + "=" + id, null);
+    } else {
+    rowsDeleted = db.delete(TABLENAME, PK + "=" + id + " and "
+    + selection, selectionArgs);
+    }
+    break;
+    default:
+    throw new IllegalArgumentException("Unknown URI: " + uri);
+    }
+    getContext().getContentResolver().notifyChange(uri, null);
+    return rowsDeleted;
+</#if>
+    }
+
+<#--
+##########################################
+########## Update ##############
+##########################################
+-->
+    @Override
+    public int update(Uri uri, ContentValues values, String selection,
+    String[] selectionArgs) {
+<#if contentProvider.isReadOnly()>
+    throw new UnsupportedOperationException("This content provider is readonly");
+<#else>
+    int uriType = sURIMatcher.match(uri);
+    Database db = getDatabase();
+    int rowsUpdated = 0;
+    String id;
+    switch (uriType) {
+    case ${entity.className?upper_case}_DIR:
+    rowsUpdated = db.update(TABLENAME, values, selection, selectionArgs);
+    break;
+    case ${entity.className?upper_case}_ID:
+    id = uri.getLastPathSegment();
+    if (TextUtils.isEmpty(selection)) {
+    rowsUpdated = db.update(TABLENAME, values, PK + "=" + id, null);
+    } else {
+    rowsUpdated = db.update(TABLENAME, values, PK + "=" + id
+    + " and " + selection, selectionArgs);
+    }
+    break;
+    default:
+    throw new IllegalArgumentException("Unknown URI: " + uri);
+    }
+    getContext().getContentResolver().notifyChange(uri, null);
+    return rowsUpdated;
+</#if>
+    }
+<#--
+##########################################
+########## Query ##############
+##########################################
+-->
+    @Override
+    public Cursor query(Uri uri, String[] projection, String selection,
+    String[] selectionArgs, String sortOrder) {
+
+    SQLiteQueryBuilder queryBuilder = new SQLiteQueryBuilder();
+    int uriType = sURIMatcher.match(uri);
+    switch (uriType) {
+    case ${entity.className?upper_case}_DIR:
+    queryBuilder.setTables(TABLENAME);
+    break;
+    case ${entity.className?upper_case}_ID:
+    queryBuilder.setTables(TABLENAME);
+    queryBuilder.appendWhere(PK + "="
+    + uri.getLastPathSegment());
+    break;
+    default:
+    throw new IllegalArgumentException("Unknown URI: " + uri);
+    }
+
+    Database db = getDatabase();
+    Cursor cursor = queryBuilder.query(((StandardDatabase) db).getSQLiteDatabase(), projection, selection,
+    selectionArgs, null, null, sortOrder);
+    cursor.setNotificationUri(getContext().getContentResolver(), uri);
+
+    return cursor;
+    }
+
+<#--
+##########################################
+########## GetType ##############
+##########################################
+-->
+    @Override
+    public final String getType(Uri uri) {
+    switch (sURIMatcher.match(uri)) {
+    case ${entity.className?upper_case}_DIR:
+    return CONTENT_TYPE;
+    case ${entity.className?upper_case}_ID:
+    return CONTENT_ITEM_TYPE;
+    default :
+    throw new IllegalArgumentException("Unsupported URI: " + uri);
+    }
+    }
+    }
diff --git a/DaoGenerator/src-template/dao-deep.ftl b/DaoGenerator/src-template/encryption/dao-deep.ftl
similarity index 100%
rename from DaoGenerator/src-template/dao-deep.ftl
rename to DaoGenerator/src-template/encryption/dao-deep.ftl
diff --git a/DaoGenerator/src-template/encryption/dao-master.ftl b/DaoGenerator/src-template/encryption/dao-master.ftl
new file mode 100644
index 00000000..15050914
--- /dev/null
+++ b/DaoGenerator/src-template/encryption/dao-master.ftl
@@ -0,0 +1,145 @@
+<#--
+
+Copyright (C) 2011-2016 Markus Junginger, greenrobot (http://greenrobot.org)
+                                                                           
+This file is part of greenDAO Generator.                                   
+                                                                           
+greenDAO Generator is free software: you can redistribute it and/or modify 
+it under the terms of the GNU General Public License as published by       
+the Free Software Foundation, either version 3 of the License, or          
+(at your option) any later version.                                        
+greenDAO Generator is distributed in the hope that it will be useful,      
+but WITHOUT ANY WARRANTY; without even the implied warranty of             
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              
+GNU General Public License for more details.                               
+                                                                           
+You should have received a copy of the GNU General Public License          
+along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+
+-->
+package ${schema.defaultJavaPackageDao};
+
+import android.content.Context;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteDatabase.CursorFactory;
+import android.util.Log;
+
+import de.greenrobot.dao.AbstractDaoMaster;
+import de.greenrobot.dao.database.StandardDatabase;
+import de.greenrobot.dao.database.Database;
+import de.greenrobot.dao.database.EncryptedDatabaseOpenHelper;
+import de.greenrobot.dao.database.DatabaseOpenHelper;
+import de.greenrobot.dao.identityscope.IdentityScopeType;
+
+<#list schema.entities as entity>
+import ${entity.javaPackageDao}.${entity.classNameDao};
+</#list>
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+/** 
+ * Master of DAO (schema version ${schema.version?c}): knows all DAOs.
+*/
+public class DaoMaster extends AbstractDaoMaster {
+    public static final int SCHEMA_VERSION = ${schema.version?c};
+
+    /** Creates underlying database table using DAOs. */
+    public static void createAllTables(Database db, boolean ifNotExists) {
+<#list schema.entities as entity>
+<#if !entity.skipTableCreation>
+        ${entity.classNameDao}.createTable(db, ifNotExists);
+</#if>
+</#list>
+    }
+    
+    /** Drops underlying database table using DAOs. */
+    public static void dropAllTables(Database db, boolean ifExists) {
+<#list schema.entities as entity>
+<#if !entity.skipTableCreation>
+        ${entity.classNameDao}.dropTable(db, ifExists);
+</#if>
+</#list>
+    }
+    
+    public static abstract class OpenHelper extends DatabaseOpenHelper {
+        public OpenHelper(Context context, String name) {
+            super(context, name, SCHEMA_VERSION);
+        }
+        public OpenHelper(Context context, String name, CursorFactory factory) {
+            super(context, name, factory, SCHEMA_VERSION);
+        }
+
+        @Override
+        public void onCreate(Database db) {
+            Log.i("greenDAO", "Creating tables for schema version " + SCHEMA_VERSION);
+            createAllTables(db, false);
+        }
+    }
+    
+    /** WARNING: Drops all table on Upgrade! Use only during development. */
+    public static class DevOpenHelper extends OpenHelper {
+        public DevOpenHelper(Context context, String name) {
+            super(context, name);
+        }
+
+        @Override
+        public void onUpgrade(Database db, int oldVersion, int newVersion) {
+            Log.i("greenDAO", "Upgrading schema from version " + oldVersion + " to " + newVersion + " by dropping all tables");
+            dropAllTables(db, true);
+            onCreate(db);
+        }
+    }
+
+    public static abstract class EncryptedOpenHelper extends EncryptedDatabaseOpenHelper {
+        public EncryptedOpenHelper(Context context, String name) {
+            super(context, name, SCHEMA_VERSION);
+        }
+
+        public EncryptedOpenHelper(Context context, String name, Object cursorFactory, boolean loadNativeLibs) {
+            super(context, name, cursorFactory, SCHEMA_VERSION, loadNativeLibs);
+        }
+
+        @Override
+        public void onCreate(Database db) {
+            Log.i("greenDAO", "Creating tables for schema version " + SCHEMA_VERSION);
+            createAllTables(db, false);
+        }
+    }
+
+    /** WARNING: Drops all table on Upgrade! Use only during development. */
+    public static class EncryptedDevOpenHelper extends EncryptedOpenHelper {
+        public EncryptedDevOpenHelper(Context context, String name) {
+            super(context, name);
+        }
+
+        public EncryptedDevOpenHelper(Context context, String name, Object cursorFactory, boolean loadNativeLibs) {
+            super(context, name, cursorFactory, loadNativeLibs);
+        }
+
+        @Override
+        public void onUpgrade(Database db, int oldVersion, int newVersion) {
+            Log.i("greenDAO", "Upgrading schema from version " + oldVersion + " to " + newVersion + " by dropping all tables");
+            dropAllTables(db, true);
+            onCreate(db);
+        }
+    }
+
+    public DaoMaster(SQLiteDatabase db) {
+        this(new StandardDatabase(db));
+    }
+
+    public DaoMaster(Database db) {
+        super(db, SCHEMA_VERSION);
+<#list schema.entities as entity>
+        registerDaoClass(${entity.classNameDao}.class);
+</#list>
+    }
+    
+    public DaoSession newSession() {
+        return new DaoSession(db, IdentityScopeType.Session, daoConfigMap);
+    }
+    
+    public DaoSession newSession(IdentityScopeType type) {
+        return new DaoSession(db, type, daoConfigMap);
+    }
+    
+}
diff --git a/DaoGenerator/src-template/encryption/dao-session.ftl b/DaoGenerator/src-template/encryption/dao-session.ftl
new file mode 100644
index 00000000..e35c95a6
--- /dev/null
+++ b/DaoGenerator/src-template/encryption/dao-session.ftl
@@ -0,0 +1,86 @@
+<#--
+
+Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)     
+                                                                           
+This file is part of greenDAO Generator.                                   
+                                                                           
+greenDAO Generator is free software: you can redistribute it and/or modify 
+it under the terms of the GNU General Public License as published by       
+the Free Software Foundation, either version 3 of the License, or          
+(at your option) any later version.                                        
+greenDAO Generator is distributed in the hope that it will be useful,      
+but WITHOUT ANY WARRANTY; without even the implied warranty of             
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              
+GNU General Public License for more details.                               
+                                                                           
+You should have received a copy of the GNU General Public License          
+along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+
+-->
+package ${schema.defaultJavaPackageDao};
+
+import java.util.Map;
+
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.AbstractDaoSession;
+import de.greenrobot.dao.database.Database;
+import de.greenrobot.dao.identityscope.IdentityScopeType;
+import de.greenrobot.dao.internal.DaoConfig;
+
+<#list schema.entities as entity>
+import ${entity.javaPackage}.${entity.className};
+</#list>
+
+<#list schema.entities as entity>
+import ${entity.javaPackageDao}.${entity.classNameDao};
+</#list>
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+
+/**
+ * {@inheritDoc}
+ * 
+ * @see de.greenrobot.dao.AbstractDaoSession
+ */
+public class DaoSession extends AbstractDaoSession {
+
+<#list schema.entities as entity>
+    private final DaoConfig ${entity.classNameDao?uncap_first}Config;
+</#list>        
+
+<#list schema.entities as entity>
+    private final ${entity.classNameDao} ${entity.classNameDao?uncap_first};
+</#list>        
+
+    public DaoSession(Database db, IdentityScopeType type, Map<Class<? extends AbstractDao<?, ?>>, DaoConfig>
+            daoConfigMap) {
+        super(db);
+
+<#list schema.entities as entity>
+        ${entity.classNameDao?uncap_first}Config = daoConfigMap.get(${entity.classNameDao}.class).clone();
+        ${entity.classNameDao?uncap_first}Config.initIdentityScope(type);
+
+</#list>        
+<#list schema.entities as entity>
+        ${entity.classNameDao?uncap_first} = new ${entity.classNameDao}<#--
+-->(${entity.classNameDao?uncap_first}Config, this);
+</#list>        
+
+<#list schema.entities as entity>
+        registerDao(${entity.className}.class, ${entity.classNameDao?uncap_first});
+</#list>        
+    }
+    
+    public void clear() {
+<#list schema.entities as entity>
+        ${entity.classNameDao?uncap_first}Config.getIdentityScope().clear();
+</#list>    
+    }
+
+<#list schema.entities as entity>
+    public ${entity.classNameDao} get${entity.classNameDao?cap_first}() {
+        return ${entity.classNameDao?uncap_first};
+    }
+
+</#list>        
+}
diff --git a/DaoGenerator/src-template/dao-unit-test.ftl b/DaoGenerator/src-template/encryption/dao-unit-test.ftl
similarity index 100%
rename from DaoGenerator/src-template/dao-unit-test.ftl
rename to DaoGenerator/src-template/encryption/dao-unit-test.ftl
diff --git a/DaoGenerator/src-template/encryption/dao.ftl b/DaoGenerator/src-template/encryption/dao.ftl
new file mode 100644
index 00000000..674eaa83
--- /dev/null
+++ b/DaoGenerator/src-template/encryption/dao.ftl
@@ -0,0 +1,309 @@
+<#--
+
+Copyright (C) 2011-2015 Markus Junginger, greenrobot (http://greenrobot.de)
+                                                                           
+This file is part of greenDAO Generator.                                   
+                                                                           
+greenDAO Generator is free software: you can redistribute it and/or modify 
+it under the terms of the GNU General Public License as published by       
+the Free Software Foundation, either version 3 of the License, or          
+(at your option) any later version.                                        
+greenDAO Generator is distributed in the hope that it will be useful,      
+but WITHOUT ANY WARRANTY; without even the implied warranty of             
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              
+GNU General Public License for more details.                               
+                                                                           
+You should have received a copy of the GNU General Public License          
+along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+
+-->
+<#assign toBindType = {"Boolean":"Long", "Byte":"Long", "Short":"Long", "Int":"Long", "Long":"Long", "Float":"Double", "Double":"Double", "String":"String", "ByteArray":"Blob", "Date": "Long" } />
+<#assign toCursorType = {"Boolean":"Short", "Byte":"Short", "Short":"Short", "Int":"Int", "Long":"Long", "Float":"Float", "Double":"Double", "String":"String", "ByteArray":"Blob", "Date": "Long"  } />
+package ${entity.javaPackageDao};
+
+<#if entity.toOneRelations?has_content || entity.incomingToManyRelations?has_content>
+import java.util.List;
+</#if>
+<#if entity.toOneRelations?has_content>
+import java.util.ArrayList;
+</#if>
+import android.database.Cursor;
+
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.Property;
+<#if entity.toOneRelations?has_content>
+import de.greenrobot.dao.internal.SqlUtils;
+</#if>
+import de.greenrobot.dao.internal.DaoConfig;
+import de.greenrobot.dao.database.Database;
+import de.greenrobot.dao.database.DatabaseStatement;
+<#if entity.incomingToManyRelations?has_content>
+import de.greenrobot.dao.query.Query;
+import de.greenrobot.dao.query.QueryBuilder;
+</#if>
+
+<#if entity.javaPackageDao != schema.defaultJavaPackageDao>
+import ${schema.defaultJavaPackageDao}.DaoSession;
+
+</#if>
+<#if entity.additionalImportsDao?has_content>
+<#list entity.additionalImportsDao as additionalImport>
+import ${additionalImport};
+</#list>
+
+</#if>
+import ${entity.javaPackage}.${entity.className};
+<#if entity.protobuf>
+import ${entity.javaPackage}.${entity.className}.Builder;
+</#if>
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+/** 
+ * DAO for table "${entity.tableName}".
+*/
+public class ${entity.classNameDao} extends ${entity.superclassDao}<${entity.className}, ${entity.pkType}> {
+
+    public static final String TABLENAME = "${entity.tableName}";
+
+    /**
+     * Properties of entity ${entity.className}.<br/>
+     * Can be used for QueryBuilder and for referencing column names.
+    */
+    public static class Properties {
+<#list entity.propertiesColumns as property>
+        public final static Property ${property.propertyName?cap_first} = new Property(${property_index}, ${property.javaType}.class, "${property.propertyName}", ${property.primaryKey?string}, "${property.columnName}");
+</#list>
+    };
+
+<#if entity.active>
+    private DaoSession daoSession;
+
+</#if>
+<#list entity.properties as property><#if property.customType?has_content><#--
+-->    private final ${property.converterClassName} ${property.propertyName}Converter = new ${property.converterClassName}();
+</#if></#list>
+<#list entity.incomingToManyRelations as toMany>
+    private Query<${toMany.targetEntity.className}> ${toMany.sourceEntity.className?uncap_first}_${toMany.name?cap_first}Query;
+</#list>
+
+    public ${entity.classNameDao}(DaoConfig config) {
+        super(config);
+    }
+    
+    public ${entity.classNameDao}(DaoConfig config, DaoSession daoSession) {
+        super(config, daoSession);
+<#if entity.active>        
+        this.daoSession = daoSession;
+</#if>
+    }
+
+<#if !entity.skipTableCreation>
+    /** Creates the underlying database table. */
+    public static void createTable(Database db, boolean ifNotExists) {
+        String constraint = ifNotExists? "IF NOT EXISTS ": "";
+        db.execSQL("CREATE TABLE " + constraint + "\"${entity.tableName}\" (" + //
+<#list entity.propertiesColumns as property>
+                "\"${property.columnName}\" ${property.columnType}<#if property.constraints??> ${property.constraints} </#if><#if property_has_next>," +<#else>);");</#if> // ${property_index}: ${property.propertyName}
+</#list>
+<#if entity.indexes?has_content >
+        // Add Indexes
+<#list entity.indexes as index>
+        db.execSQL("CREATE <#if index.unique>UNIQUE </#if>INDEX " + constraint + "${index.name} ON ${entity.tableName}" +
+                " (<#list index.properties 
+as property>\"${property.columnName}\"<#if property_has_next>,</#if></#list>);");
+</#list>
+</#if>         
+    }
+
+    /** Drops the underlying database table. */
+    public static void dropTable(Database db, boolean ifExists) {
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "\"${entity.tableName}\"";
+        db.execSQL(sql);
+    }
+
+</#if>
+    /** @inheritdoc */
+    @Override
+    protected void bindValues(DatabaseStatement stmt, ${entity.className} entity) {
+        stmt.clearBindings();
+<#list entity.properties as property>
+<#if property.notNull || entity.protobuf>
+<#if entity.protobuf>
+        if(entity.has${property.propertyName?cap_first}()) {
+    </#if>        stmt.bind${toBindType[property.propertyType]}(${property_index + 1}, ${property.databaseValueExpressionNotNull});
+<#if entity.protobuf>
+        }
+</#if>
+<#else> <#-- nullable, non-protobuff -->
+        ${property.javaTypeInEntity} ${property.propertyName} = entity.get${property.propertyName?cap_first}();
+        if (${property.propertyName} != null) {
+            stmt.bind${toBindType[property.propertyType]}(${property_index + 1}, ${property.databaseValueExpression});
+        }
+</#if>
+</#list>
+<#list entity.toOneRelations as toOne>
+<#if !toOne.fkProperties?has_content>
+
+        ${toOne.targetEntity.className} ${toOne.name} = entity.peak${toOne.name?cap_first}();
+        if(${toOne.name} != null) {
+            ${toOne.targetEntity.pkProperty.javaType} ${toOne.name}__targetKey = ${toOne.name}.get${toOne.targetEntity.pkProperty.propertyName?cap_first}();
+<#if !toOne.targetEntity.pkProperty.notNull>
+            if(${toOne.name}__targetKey != null) {
+                // TODO bind ${toOne.name}__targetKey
+            }
+<#else>
+            // TODO bind ${toOne.name}__targetKey
+</#if>
+        }
+</#if>
+</#list>
+    }
+
+<#if entity.active>
+    @Override
+    protected void attachEntity(${entity.className} entity) {
+        super.attachEntity(entity);
+        entity.__setDaoSession(daoSession);
+    }
+
+</#if>
+    /** @inheritdoc */
+    @Override
+    public ${entity.pkType} readKey(Cursor cursor, int offset) {
+<#if entity.pkProperty??>
+        return <#if !entity.pkProperty.notNull>cursor.isNull(offset + ${entity.pkProperty.ordinal}) ? null : </#if><#if
+            entity.pkProperty.propertyType == "Byte">(byte) </#if><#if
+            entity.pkProperty.propertyType == "Date">new java.util.Date(</#if>cursor.get${toCursorType[entity.pkProperty.propertyType]}(offset + ${entity.pkProperty.ordinal})<#if
+            entity.pkProperty.propertyType == "Boolean"> != 0</#if><#if
+            entity.pkProperty.propertyType == "Date">)</#if>;
+<#else>
+        return null;
+</#if>  
+    }    
+
+    /** @inheritdoc */
+    @Override
+    public ${entity.className} readEntity(Cursor cursor, int offset) {
+<#if entity.protobuf>
+        Builder builder = ${entity.className}.newBuilder();
+<#list entity.properties as property>
+<#if !property.notNull>
+        if (!cursor.isNull(offset + ${property_index})) {
+    </#if>        builder.set${property.propertyName?cap_first}(cursor.get${toCursorType[property.propertyType]}(offset + ${property_index}));
+<#if !property.notNull>
+        }
+</#if>        
+</#list>        
+        return builder.build();
+<#elseif entity.constructors>
+<#--
+############################## readEntity non-protobuff, constructor ############################## 
+-->
+        ${entity.className} entity = new ${entity.className}( //
+<#list entity.properties as property>
+            <#if !property.notNull>cursor.isNull(offset + ${property_index}) ? null : </#if><#--
+            -->${property.getEntityValueExpression("cursor.get${toCursorType[property.propertyType]}(offset + ${property_index})")}<#--
+            --><#if property_has_next>,</#if> // ${property.propertyName}
+</#list>        
+        );
+        return entity;
+<#else>
+<#--
+############################## readEntity non-protobuff, setters ############################## 
+-->
+        ${entity.className} entity = new ${entity.className}();
+        readEntity(cursor, entity, offset);
+        return entity;
+</#if>
+    }
+     
+    /** @inheritdoc */
+    @Override
+    public void readEntity(Cursor cursor, ${entity.className} entity, int offset) {
+<#if entity.protobuf>
+        throw new UnsupportedOperationException("Protobuf objects cannot be modified");
+<#else> 
+<#list entity.properties as property>
+        entity.set${property.propertyName?cap_first}(<#if !property.notNull>cursor.isNull(offset + ${property_index}) ? null : </#if><#--
+            -->${property.getEntityValueExpression("cursor.get${toCursorType[property.propertyType]}(offset + ${property_index})")});
+</#list>
+</#if>
+     }
+    
+    /** @inheritdoc */
+    @Override
+    protected ${entity.pkType} updateKeyAfterInsert(${entity.className} entity, long rowId) {
+<#if entity.pkProperty??>
+<#if entity.pkProperty.propertyType == "Long">
+<#if !entity.protobuf>
+        entity.set${entity.pkProperty.propertyName?cap_first}(rowId);
+</#if>
+        return rowId;
+<#else>
+        return entity.get${entity.pkProperty.propertyName?cap_first}();
+</#if>
+<#else>
+        // Unsupported or missing PK type
+        return null;
+</#if>
+    }
+    
+    /** @inheritdoc */
+    @Override
+    public ${entity.pkType} getKey(${entity.className} entity) {
+<#if entity.pkProperty??>
+        if(entity != null) {
+            return entity.get${entity.pkProperty.propertyName?cap_first}();
+        } else {
+            return null;
+        }
+<#else>
+        return null;
+</#if>    
+    }
+
+    /** @inheritdoc */
+    @Override    
+    protected boolean isEntityUpdateable() {
+        return ${(!entity.protobuf)?string};
+    }
+    
+<#list entity.incomingToManyRelations as toMany>
+    /** Internal query to resolve the "${toMany.name}" to-many relationship of ${toMany.sourceEntity.className}. */
+    public List<${toMany.targetEntity.className}> _query${toMany.sourceEntity.className?cap_first}_${toMany.name?cap_first}(<#--
+    --><#if toMany.targetProperties??><#list toMany.targetProperties as property><#--
+    -->${property.javaType} ${property.propertyName}<#if property_has_next>, </#if></#list><#else><#--
+    -->${toMany.sourceProperty.javaType} ${toMany.sourceProperty.propertyName}</#if>) {
+        synchronized (this) {
+            if (${toMany.sourceEntity.className?uncap_first}_${toMany.name?cap_first}Query == null) {
+                QueryBuilder<${toMany.targetEntity.className}> queryBuilder = queryBuilder();
+<#if toMany.targetProperties??>
+    <#list toMany.targetProperties as property>
+                queryBuilder.where(Properties.${property.propertyName?cap_first}.eq(null));
+    </#list>
+<#else>
+                queryBuilder.join(${toMany.joinEntity.className}.class, ${toMany.joinEntity.classNameDao}.Properties.${toMany.targetProperty.propertyName?cap_first})
+                    .where(${toMany.joinEntity.classNameDao}.Properties.${toMany.sourceProperty.propertyName?cap_first}.eq(${toMany.sourceProperty.propertyName}));
+</#if>
+<#if toMany.order?has_content>
+                queryBuilder.orderRaw("${toMany.order}");
+</#if>
+                ${toMany.sourceEntity.className?uncap_first}_${toMany.name?cap_first}Query = queryBuilder.build();
+            }
+        }
+        Query<${toMany.targetEntity.className}> query = ${toMany.sourceEntity.className?uncap_first}_${toMany.name?cap_first}Query.forCurrentThread();
+<#if toMany.targetProperties??>
+    <#list toMany.targetProperties as property>
+        query.setParameter(${property_index}, ${property.propertyName});
+    </#list>
+<#else>
+        query.setParameter(0, ${toMany.sourceProperty.propertyName});
+</#if>
+        return query.list();
+    }
+
+</#list>   
+<#if entity.toOneRelations?has_content>
+    <#include "dao-deep.ftl">
+</#if>
+}
diff --git a/DaoGenerator/src-template/entity.ftl b/DaoGenerator/src-template/encryption/entity.ftl
similarity index 96%
rename from DaoGenerator/src-template/entity.ftl
rename to DaoGenerator/src-template/encryption/entity.ftl
index 63a26ff7..0e383d84 100644
--- a/DaoGenerator/src-template/entity.ftl
+++ b/DaoGenerator/src-template/encryption/entity.ftl
@@ -44,9 +44,17 @@ import ${additionalImport};
 <#else>
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
 </#if>
+<#if entity.javaDoc ??>
+
+${entity.javaDoc}
+<#else>
 /**
  * Entity mapped to table "${entity.tableName}".
  */
+</#if>
+<#if entity.codeBeforeClass ??>
+${entity.codeBeforeClass}
+</#if>
 public class ${entity.className}<#if
 entity.superclass?has_content> extends ${entity.superclass} </#if><#if
 entity.interfacesToImplement?has_content> implements <#list entity.interfacesToImplement
@@ -56,6 +64,9 @@ as ifc>${ifc}<#if ifc_has_next>, </#if></#list></#if> {
 <#if property.notNull && complexTypes?seq_contains(property.propertyType)>
     /** Not-null value. */
 </#if>
+<#if property.javaDocField ??>
+${property.javaDocField}
+</#if>
 <#if property.codeBeforeField ??>
      ${property.codeBeforeField}
 </#if>
@@ -121,6 +132,9 @@ property>${property.javaTypeInEntity} ${property.propertyName}<#if property_has_
 <#if property.notNull && complexTypes?seq_contains(property.propertyType)>
     /** Not-null value. */
 </#if>
+<#if property.javaDocGetter ??>
+${property.javaDocGetter}
+</#if>
 <#if property.codeBeforeGetter ??>
     ${property.codeBeforeGetter}
 </#if>
@@ -131,8 +145,11 @@ property>${property.javaTypeInEntity} ${property.propertyName}<#if property_has_
 <#if property.notNull && complexTypes?seq_contains(property.propertyType)>
     /** Not-null value; ensure this value is available before it is saved to the database. */
 </#if>
-<#if property.codeBeforeGetter ??>
-    ${property.codeBeforeGetter}
+<#if property.javaDocSetter ??>
+${property.javaDocSetter}
+</#if>
+<#if property.codeBeforeSetter ??>
+    ${property.codeBeforeSetter}
 </#if>
     public void set${property.propertyName?cap_first}(${property.javaTypeInEntity} ${property.propertyName}) {
         this.${property.propertyName} = ${property.propertyName};
diff --git a/DaoGenerator/src-template/content-provider.ftl b/DaoGenerator/src-template/standard/content-provider.ftl
similarity index 100%
rename from DaoGenerator/src-template/content-provider.ftl
rename to DaoGenerator/src-template/standard/content-provider.ftl
diff --git a/DaoGenerator/src-template/standard/dao-deep.ftl b/DaoGenerator/src-template/standard/dao-deep.ftl
new file mode 100644
index 00000000..35123713
--- /dev/null
+++ b/DaoGenerator/src-template/standard/dao-deep.ftl
@@ -0,0 +1,129 @@
+<#--
+
+Copyright (C) 2011-2015 Markus Junginger, greenrobot (http://greenrobot.de)
+                                                                           
+This file is part of greenDAO Generator.                                   
+                                                                           
+greenDAO Generator is free software: you can redistribute it and/or modify 
+it under the terms of the GNU General Public License as published by       
+the Free Software Foundation, either version 3 of the License, or          
+(at your option) any later version.                                        
+greenDAO Generator is distributed in the hope that it will be useful,      
+but WITHOUT ANY WARRANTY; without even the implied warranty of             
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              
+GNU General Public License for more details.                               
+                                                                           
+You should have received a copy of the GNU General Public License          
+along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+
+-->
+<#if entity.toOneRelations?has_content>
+    private String selectDeep;
+
+    protected String getSelectDeep() {
+        if (selectDeep == null) {
+            StringBuilder builder = new StringBuilder("SELECT ");
+            SqlUtils.appendColumns(builder, "T", getAllColumns());
+            builder.append(',');
+<#list entity.toOneRelations as toOne>
+            SqlUtils.appendColumns(builder, "T${toOne_index}", daoSession.get${toOne.targetEntity.classNameDao}().getAllColumns());
+<#if toOne_has_next>
+            builder.append(',');
+</#if>
+</#list>
+            builder.append(" FROM ${entity.tableName} T");
+<#list entity.toOneRelations as toOne>
+            builder.append(" LEFT JOIN ${toOne.targetEntity.tableName} T${toOne_index}<#--
+--> ON T.\"${toOne.fkProperties[0].columnName}\"=T${toOne_index}.\"${toOne.targetEntity.pkProperty.columnName}\"");
+</#list>
+            builder.append(' ');
+            selectDeep = builder.toString();
+        }
+        return selectDeep;
+    }
+    
+    protected ${entity.className} loadCurrentDeep(Cursor cursor, boolean lock) {
+        ${entity.className} entity = loadCurrent(cursor, 0, lock);
+        int offset = getAllColumns().length;
+
+<#list entity.toOneRelations as toOne>
+        ${toOne.targetEntity.className} ${toOne.name} = loadCurrentOther(daoSession.get${toOne.targetEntity.classNameDao}(), cursor, offset);
+<#if toOne.fkProperties[0].notNull>         if(${toOne.name} != null) {
+    </#if>        entity.set${toOne.name?cap_first}(${toOne.name});
+<#if toOne.fkProperties[0].notNull>
+        }
+</#if>
+<#if toOne_has_next>
+        offset += daoSession.get${toOne.targetEntity.classNameDao}().getAllColumns().length;
+</#if>
+
+</#list>
+        return entity;    
+    }
+
+    public ${entity.className} loadDeep(Long key) {
+        assertSinglePk();
+        if (key == null) {
+            return null;
+        }
+
+        StringBuilder builder = new StringBuilder(getSelectDeep());
+        builder.append("WHERE ");
+        SqlUtils.appendColumnsEqValue(builder, "T", getPkColumns());
+        String sql = builder.toString();
+        
+        String[] keyArray = new String[] { key.toString() };
+        Cursor cursor = db.rawQuery(sql, keyArray);
+        
+        try {
+            boolean available = cursor.moveToFirst();
+            if (!available) {
+                return null;
+            } else if (!cursor.isLast()) {
+                throw new IllegalStateException("Expected unique result, but count was " + cursor.getCount());
+            }
+            return loadCurrentDeep(cursor, true);
+        } finally {
+            cursor.close();
+        }
+    }
+    
+    /** Reads all available rows from the given cursor and returns a list of new ImageTO objects. */
+    public List<${entity.className}> loadAllDeepFromCursor(Cursor cursor) {
+        int count = cursor.getCount();
+        List<${entity.className}> list = new ArrayList<${entity.className}>(count);
+        
+        if (cursor.moveToFirst()) {
+            if (identityScope != null) {
+                identityScope.lock();
+                identityScope.reserveRoom(count);
+            }
+            try {
+                do {
+                    list.add(loadCurrentDeep(cursor, false));
+                } while (cursor.moveToNext());
+            } finally {
+                if (identityScope != null) {
+                    identityScope.unlock();
+                }
+            }
+        }
+        return list;
+    }
+    
+    protected List<${entity.className}> loadDeepAllAndCloseCursor(Cursor cursor) {
+        try {
+            return loadAllDeepFromCursor(cursor);
+        } finally {
+            cursor.close();
+        }
+    }
+    
+
+    /** A raw-style query where you can pass any WHERE clause and arguments. */
+    public List<${entity.className}> queryDeep(String where, String... selectionArg) {
+        Cursor cursor = db.rawQuery(getSelectDeep() + where, selectionArg);
+        return loadDeepAllAndCloseCursor(cursor);
+    }
+ 
+</#if>
\ No newline at end of file
diff --git a/DaoGenerator/src-template/dao-master.ftl b/DaoGenerator/src-template/standard/dao-master.ftl
similarity index 100%
rename from DaoGenerator/src-template/dao-master.ftl
rename to DaoGenerator/src-template/standard/dao-master.ftl
diff --git a/DaoGenerator/src-template/dao-session.ftl b/DaoGenerator/src-template/standard/dao-session.ftl
similarity index 100%
rename from DaoGenerator/src-template/dao-session.ftl
rename to DaoGenerator/src-template/standard/dao-session.ftl
diff --git a/DaoGenerator/src-template/standard/dao-unit-test.ftl b/DaoGenerator/src-template/standard/dao-unit-test.ftl
new file mode 100644
index 00000000..9e9d9c51
--- /dev/null
+++ b/DaoGenerator/src-template/standard/dao-unit-test.ftl
@@ -0,0 +1,53 @@
+<#--
+
+Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)     
+                                                                           
+This file is part of greenDAO Generator.                                   
+                                                                           
+greenDAO Generator is free software: you can redistribute it and/or modify 
+it under the terms of the GNU General Public License as published by       
+the Free Software Foundation, either version 3 of the License, or          
+(at your option) any later version.                                        
+greenDAO Generator is distributed in the hope that it will be useful,      
+but WITHOUT ANY WARRANTY; without even the implied warranty of             
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              
+GNU General Public License for more details.                               
+                                                                           
+You should have received a copy of the GNU General Public License          
+along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+
+-->
+package ${entity.javaPackageTest};
+
+<#assign isStringPK = entity.pkProperty?? && entity.pkProperty.propertyType == "String" />
+<#if isStringPK>
+import de.greenrobot.dao.test.AbstractDaoTestStringPk;
+<#else>
+import de.greenrobot.dao.test.AbstractDaoTestLongPk;
+</#if>
+
+import ${entity.javaPackage}.${entity.className};
+import ${entity.javaPackageDao}.${entity.classNameDao};
+
+public class ${entity.classNameTest} extends <#if
+isStringPK>AbstractDaoTestStringPk<${entity.classNameDao}, ${entity.className}><#else>AbstractDaoTestLongPk<${entity.classNameDao}, ${entity.className}></#if> {
+
+    public ${entity.classNameTest}() {
+        super(${entity.classNameDao}.class);
+    }
+
+    @Override
+    protected ${entity.className} createEntity(<#if isStringPK>String<#else>Long</#if> key) {
+        ${entity.className} entity = new ${entity.className}();
+<#if entity.pkProperty??>
+        entity.set${entity.pkProperty.propertyName?cap_first}(key);
+</#if>
+<#list entity.properties as property>
+<#if property.notNull>
+        entity.set${property.propertyName?cap_first}();
+</#if> 
+</#list>
+        return entity;
+    }
+
+}
diff --git a/DaoGenerator/src-template/dao.ftl b/DaoGenerator/src-template/standard/dao.ftl
similarity index 100%
rename from DaoGenerator/src-template/dao.ftl
rename to DaoGenerator/src-template/standard/dao.ftl
diff --git a/DaoGenerator/src-template/standard/entity.ftl b/DaoGenerator/src-template/standard/entity.ftl
new file mode 100644
index 00000000..0e383d84
--- /dev/null
+++ b/DaoGenerator/src-template/standard/entity.ftl
@@ -0,0 +1,287 @@
+<#--
+
+Copyright (C) 2011-2015 Markus Junginger, greenrobot (http://greenrobot.de)
+                                                                           
+This file is part of greenDAO Generator.                                   
+                                                                           
+greenDAO Generator is free software: you can redistribute it and/or modify 
+it under the terms of the GNU General Public License as published by       
+the Free Software Foundation, either version 3 of the License, or          
+(at your option) any later version.                                        
+greenDAO Generator is distributed in the hope that it will be useful,      
+but WITHOUT ANY WARRANTY; without even the implied warranty of             
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              
+GNU General Public License for more details.                               
+                                                                           
+You should have received a copy of the GNU General Public License          
+along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+
+-->
+<#assign toBindType = {"Boolean":"Long", "Byte":"Long", "Short":"Long", "Int":"Long", "Long":"Long", "Float":"Double", "Double":"Double", "String":"String", "ByteArray":"Blob" }/>
+<#assign toCursorType = {"Boolean":"Short", "Byte":"Short", "Short":"Short", "Int":"Int", "Long":"Long", "Float":"Float", "Double":"Double", "String":"String", "ByteArray":"Blob" }/>
+<#assign complexTypes = ["String", "ByteArray", "Date"]/>
+package ${entity.javaPackage};
+
+<#if entity.toManyRelations?has_content>
+import java.util.List;
+</#if>
+<#if entity.active>
+import ${schema.defaultJavaPackageDao}.DaoSession;
+import de.greenrobot.dao.DaoException;
+
+</#if>
+<#if entity.additionalImportsEntity?has_content>
+<#list entity.additionalImportsEntity as additionalImport>
+import ${additionalImport};
+</#list>
+
+</#if>
+<#if entity.hasKeepSections>
+// THIS CODE IS GENERATED BY greenDAO, EDIT ONLY INSIDE THE "KEEP"-SECTIONS
+
+// KEEP INCLUDES - put your custom includes here
+<#if keepIncludes?has_content>${keepIncludes!}</#if>// KEEP INCLUDES END
+<#else>
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
+</#if>
+<#if entity.javaDoc ??>
+
+${entity.javaDoc}
+<#else>
+/**
+ * Entity mapped to table "${entity.tableName}".
+ */
+</#if>
+<#if entity.codeBeforeClass ??>
+${entity.codeBeforeClass}
+</#if>
+public class ${entity.className}<#if
+entity.superclass?has_content> extends ${entity.superclass} </#if><#if
+entity.interfacesToImplement?has_content> implements <#list entity.interfacesToImplement
+as ifc>${ifc}<#if ifc_has_next>, </#if></#list></#if> {
+
+<#list entity.properties as property>
+<#if property.notNull && complexTypes?seq_contains(property.propertyType)>
+    /** Not-null value. */
+</#if>
+<#if property.javaDocField ??>
+${property.javaDocField}
+</#if>
+<#if property.codeBeforeField ??>
+     ${property.codeBeforeField}
+</#if>
+    private ${property.javaTypeInEntity} ${property.propertyName};
+</#list>
+
+<#if entity.active>
+    /** Used to resolve relations */
+    private transient DaoSession daoSession;
+
+    /** Used for active entity operations. */
+    private transient ${entity.classNameDao} myDao;
+
+<#list entity.toOneRelations as toOne>
+    private ${toOne.targetEntity.className} ${toOne.name};
+<#if toOne.useFkProperty>
+    private ${toOne.resolvedKeyJavaType[0]} ${toOne.name}__resolvedKey;
+<#else>
+    private boolean ${toOne.name}__refreshed;
+</#if>
+
+</#list>
+<#list entity.toManyRelations as toMany>
+    private List<${toMany.targetEntity.className}> ${toMany.name};
+</#list>
+
+</#if>
+<#if entity.hasKeepSections>
+    // KEEP FIELDS - put your custom fields here
+${keepFields!}    // KEEP FIELDS END
+
+</#if>
+<#if entity.constructors>
+    public ${entity.className}() {
+    }
+<#if entity.propertiesPk?has_content && entity.propertiesPk?size != entity.properties?size>
+
+    public ${entity.className}(<#list entity.propertiesPk as
+property>${property.javaType} ${property.propertyName}<#if property_has_next>, </#if></#list>) {
+<#list entity.propertiesPk as property>
+        this.${property.propertyName} = ${property.propertyName};
+</#list>
+    }
+</#if>
+
+    public ${entity.className}(<#list entity.properties as
+property>${property.javaTypeInEntity} ${property.propertyName}<#if property_has_next>, </#if></#list>) {
+<#list entity.properties as property>
+        this.${property.propertyName} = ${property.propertyName};
+</#list>
+    }
+</#if>
+
+<#if entity.active>
+    /** called by internal mechanisms, do not call yourself. */
+    public void __setDaoSession(DaoSession daoSession) {
+        this.daoSession = daoSession;
+        myDao = daoSession != null ? daoSession.get${entity.classNameDao?cap_first}() : null;
+    }
+
+</#if>
+<#list entity.properties as property>
+<#if property.notNull && complexTypes?seq_contains(property.propertyType)>
+    /** Not-null value. */
+</#if>
+<#if property.javaDocGetter ??>
+${property.javaDocGetter}
+</#if>
+<#if property.codeBeforeGetter ??>
+    ${property.codeBeforeGetter}
+</#if>
+    public ${property.javaTypeInEntity} get${property.propertyName?cap_first}() {
+        return ${property.propertyName};
+    }
+
+<#if property.notNull && complexTypes?seq_contains(property.propertyType)>
+    /** Not-null value; ensure this value is available before it is saved to the database. */
+</#if>
+<#if property.javaDocSetter ??>
+${property.javaDocSetter}
+</#if>
+<#if property.codeBeforeSetter ??>
+    ${property.codeBeforeSetter}
+</#if>
+    public void set${property.propertyName?cap_first}(${property.javaTypeInEntity} ${property.propertyName}) {
+        this.${property.propertyName} = ${property.propertyName};
+    }
+
+</#list>
+<#--
+##########################################
+########## To-One Relations ##############
+##########################################
+-->
+<#list entity.toOneRelations as toOne>
+    /** To-one relationship, resolved on first access. */
+    public ${toOne.targetEntity.className} get${toOne.name?cap_first}() {
+<#if toOne.useFkProperty>
+        ${toOne.fkProperties[0].javaType} __key = this.${toOne.fkProperties[0].propertyName};
+        if (${toOne.name}__resolvedKey == null || <#--
+        --><#if toOne.resolvedKeyUseEquals[0]>!${toOne.name}__resolvedKey.equals(__key)<#--
+        --><#else>${toOne.name}__resolvedKey != __key</#if>) {
+            if (daoSession == null) {
+                throw new DaoException("Entity is detached from DAO context");
+            }
+            ${toOne.targetEntity.classNameDao} targetDao = daoSession.get${toOne.targetEntity.classNameDao?cap_first}();
+            ${toOne.targetEntity.className} ${toOne.name}New = targetDao.load(__key);
+            synchronized (this) {
+                ${toOne.name} = ${toOne.name}New;
+            	${toOne.name}__resolvedKey = __key;
+            }
+        }
+<#else>
+        if (${toOne.name} != null || !${toOne.name}__refreshed) {
+            if (daoSession == null) {
+                throw new DaoException("Entity is detached from DAO context");
+            }
+            ${toOne.targetEntity.classNameDao} targetDao = daoSession.get${toOne.targetEntity.classNameDao?cap_first}();
+            targetDao.refresh(${toOne.name});
+            ${toOne.name}__refreshed = true;
+        }
+</#if>
+        return ${toOne.name};
+    }
+<#if !toOne.useFkProperty>
+
+    /** To-one relationship, returned entity is not refreshed and may carry only the PK property. */
+    public ${toOne.targetEntity.className} peak${toOne.name?cap_first}() {
+        return ${toOne.name};
+    }
+</#if>
+
+    public void set${toOne.name?cap_first}(${toOne.targetEntity.className} ${toOne.name}) {
+<#if toOne.fkProperties[0].notNull>
+        if (${toOne.name} == null) {
+            throw new DaoException("To-one property '${toOne.fkProperties[0].propertyName}' has not-null constraint; cannot set to-one to null");
+        }
+</#if>
+        synchronized (this) {
+            this.${toOne.name} = ${toOne.name};
+<#if toOne.useFkProperty>        
+            ${toOne.fkProperties[0].propertyName} = <#if !toOne.fkProperties[0].notNull>${toOne.name} == null ? null : </#if>${toOne.name}.get${toOne.targetEntity.pkProperty.propertyName?cap_first}();
+            ${toOne.name}__resolvedKey = ${toOne.fkProperties[0].propertyName};
+<#else>
+            ${toOne.name}__refreshed = true;
+</#if>
+        }
+    }
+
+</#list>
+<#--
+##########################################
+########## To-Many Relations #############
+##########################################
+-->
+<#list entity.toManyRelations as toMany>
+    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
+    public List<${toMany.targetEntity.className}> get${toMany.name?cap_first}() {
+        if (${toMany.name} == null) {
+            if (daoSession == null) {
+                throw new DaoException("Entity is detached from DAO context");
+            }
+            ${toMany.targetEntity.classNameDao} targetDao = daoSession.get${toMany.targetEntity.classNameDao?cap_first}();
+            List<${toMany.targetEntity.className}> ${toMany.name}New = targetDao._query${toMany.sourceEntity.className?cap_first}_${toMany.name?cap_first}(<#--
+                --><#if toMany.sourceProperties??><#list toMany.sourceProperties as property>${property.propertyName}<#if property_has_next>, </#if></#list><#else><#--
+                -->${entity.pkProperty.propertyName}</#if>);
+            synchronized (this) {<#-- Check if another thread was faster, we cannot lock while doing the query to prevent deadlocks -->
+                if(${toMany.name} == null) {
+                    ${toMany.name} = ${toMany.name}New;
+                }
+            }
+        }
+        return ${toMany.name};
+    }
+
+    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
+    public synchronized void reset${toMany.name?cap_first}() {
+        ${toMany.name} = null;
+    }
+
+</#list>
+<#--
+##########################################
+########## Active entity operations ######
+##########################################
+-->
+<#if entity.active>
+    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
+    public void delete() {
+        if (myDao == null) {
+            throw new DaoException("Entity is detached from DAO context");
+        }    
+        myDao.delete(this);
+    }
+
+    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
+    public void update() {
+        if (myDao == null) {
+            throw new DaoException("Entity is detached from DAO context");
+        }    
+        myDao.update(this);
+    }
+
+    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
+    public void refresh() {
+        if (myDao == null) {
+            throw new DaoException("Entity is detached from DAO context");
+        }    
+        myDao.refresh(this);
+    }
+
+</#if>
+<#if entity.hasKeepSections>
+    // KEEP METHODS - put your custom methods here
+${keepMethods!}    // KEEP METHODS END
+
+</#if>
+}
diff --git a/DaoGenerator/src/de/greenrobot/daogenerator/DaoGenerator.java b/DaoGenerator/src/de/greenrobot/daogenerator/DaoGenerator.java
index b99c4fec..4bbe9c0f 100644
--- a/DaoGenerator/src/de/greenrobot/daogenerator/DaoGenerator.java
+++ b/DaoGenerator/src/de/greenrobot/daogenerator/DaoGenerator.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2015 Markus Junginger, greenrobot (http://greenrobot.de)
+ * Copyright (C) 2011-2016 Markus Junginger, greenrobot (http://greenrobot.org)
  *
  * This file is part of greenDAO Generator.
  * 
@@ -28,7 +28,6 @@
 import java.util.regex.Pattern;
 
 import freemarker.template.Configuration;
-import freemarker.template.DefaultObjectWrapper;
 import freemarker.template.Template;
 
 /**
@@ -50,17 +49,21 @@
     private Template templateContentProvider;
 
     public DaoGenerator() throws IOException {
-        System.out.println("greenDAO Generator");
-        System.out.println("Copyright 2011-2015 Markus Junginger, greenrobot.de. Licensed under GPL V3.");
+        this(false);
+    }
+
+    public DaoGenerator(boolean encryption) throws IOException {
+        System.out.println("greenDAO Generator" + (encryption ? " (enryption mode)" : ""));
+        System.out.println("Copyright 2011-2016 Markus Junginger, greenrobot.de. Licensed under GPL V3.");
         System.out.println("This program comes with ABSOLUTELY NO WARRANTY");
 
         patternKeepIncludes = compilePattern("INCLUDES");
         patternKeepFields = compilePattern("FIELDS");
         patternKeepMethods = compilePattern("METHODS");
 
-        Configuration config = new Configuration();
-        config.setClassForTemplateLoading(this.getClass(), "/");
-        config.setObjectWrapper(new DefaultObjectWrapper());
+        Configuration config = new Configuration(Configuration.VERSION_2_3_23);
+        String basePackagePath = encryption ? "/encryption/" : "/standard/";
+        config.setClassForTemplateLoading(this.getClass(), basePackagePath);
 
         templateDao = config.getTemplate("dao.ftl");
         templateDaoMaster = config.getTemplate("dao-master.ftl");
@@ -86,7 +89,7 @@ public void generateAll(Schema schema, String outDir, String outDirEntity, Strin
         long start = System.currentTimeMillis();
 
         File outDirFile = toFileForceExists(outDir);
-        File outDirEntityFile = outDirEntity != null? toFileForceExists(outDirEntity): outDirFile;
+        File outDirEntityFile = outDirEntity != null ? toFileForceExists(outDirEntity) : outDirFile;
         File outDirTestFile = outDirTest != null ? toFileForceExists(outDirTest) : null;
 
         schema.init2ndPass();
diff --git a/DaoGenerator/src/de/greenrobot/daogenerator/DaoUtil.java b/DaoGenerator/src/de/greenrobot/daogenerator/DaoUtil.java
index feb76469..a8a2e965 100644
--- a/DaoGenerator/src/de/greenrobot/daogenerator/DaoUtil.java
+++ b/DaoGenerator/src/de/greenrobot/daogenerator/DaoUtil.java
@@ -104,5 +104,11 @@ public static int copyAllBytes(InputStream in, OutputStream out) throws IOExcept
         return byteCount;
     }
 
-
+    public static String checkConvertToJavaDoc(String javaDoc, String indent) {
+        if (javaDoc != null && !javaDoc.trim().startsWith("/**")) {
+            javaDoc = javaDoc.replace("\n", "\n" + indent + " * ");
+            javaDoc = indent + "/**\n" + indent + " * " + javaDoc + "\n" + indent + " */";
+        }
+        return javaDoc;
+    }
 }
diff --git a/DaoGenerator/src/de/greenrobot/daogenerator/Entity.java b/DaoGenerator/src/de/greenrobot/daogenerator/Entity.java
index b26e4ed8..79265ae8 100644
--- a/DaoGenerator/src/de/greenrobot/daogenerator/Entity.java
+++ b/DaoGenerator/src/de/greenrobot/daogenerator/Entity.java
@@ -1,680 +1,698 @@
-/*
- * Copyright (C) 2011-2015 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daogenerator;
-
-import de.greenrobot.daogenerator.Property.PropertyBuilder;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Set;
-import java.util.TreeSet;
-
-/**
- * Model class for an entity: a Java data object mapped to a data base table. A new entity is added to a {@link Schema}
- * by the method {@link Schema#addEntity(String)} (there is no public constructor for {@link Entity} itself). <br/>
- * <br/> Use the various addXXX methods to add entity properties, indexes, and relations to other entities (addToOne,
- * addToMany).<br/> <br/> There are further configuration possibilities: <ul> <li>{@link
- * Entity#implementsInterface(String...)} and {@link #implementsSerializable()} to specify interfaces the entity will
- * implement</li> <li>{@link #setSuperclass(String)} to specify a class of which the entity will extend from</li>
- * <li>Various setXXX methods</li> </ul>
- *
- * @see <a href="http://greendao-orm.com/documentation/modelling-entities/">Modelling Entities (Documentation page)</a>
- * @see <a href="http://greendao-orm.com/documentation/relations/">Relations (Documentation page)</a>
- */
-public class Entity {
-    private final Schema schema;
-    private final String className;
-    private final List<Property> properties;
-    private List<Property> propertiesColumns;
-    private final List<Property> propertiesPk;
-    private final List<Property> propertiesNonPk;
-    private final Set<String> propertyNames;
-    private final List<Index> indexes;
-    private final List<ToOne> toOneRelations;
-    private final List<ToManyBase> toManyRelations;
-    private final List<ToManyBase> incomingToManyRelations;
-    private final Collection<String> additionalImportsEntity;
-    private final Collection<String> additionalImportsDao;
-    private final List<String> interfacesToImplement;
-    private final List<ContentProvider> contentProviders;
-
-    private String tableName;
-    private String classNameDao;
-    private String classNameTest;
-    private String javaPackage;
-    private String javaPackageDao;
-    private String javaPackageTest;
-    private Property pkProperty;
-    private String pkType;
-    private String superclass;
-    private String superclassDao;
-
-    private boolean protobuf;
-    private boolean constructors;
-    private boolean skipGeneration;
-    private boolean skipGenerationTest;
-    private boolean skipTableCreation;
-    private Boolean active;
-    private Boolean hasKeepSections;
-
-    Entity(Schema schema, String className) {
-        this.schema = schema;
-        this.className = className;
-        this.superclassDao = "AbstractDao";
-        properties = new ArrayList<Property>();
-        propertiesPk = new ArrayList<Property>();
-        propertiesNonPk = new ArrayList<Property>();
-        propertyNames = new HashSet<String>();
-        indexes = new ArrayList<Index>();
-        toOneRelations = new ArrayList<ToOne>();
-        toManyRelations = new ArrayList<ToManyBase>();
-        incomingToManyRelations = new ArrayList<ToManyBase>();
-        additionalImportsEntity = new TreeSet<String>();
-        additionalImportsDao = new TreeSet<String>();
-        interfacesToImplement = new ArrayList<String>();
-        contentProviders = new ArrayList<ContentProvider>();
-        constructors = true;
-    }
-
-    public PropertyBuilder addBooleanProperty(String propertyName) {
-        return addProperty(PropertyType.Boolean, propertyName);
-    }
-
-    public PropertyBuilder addByteProperty(String propertyName) {
-        return addProperty(PropertyType.Byte, propertyName);
-    }
-
-    public PropertyBuilder addShortProperty(String propertyName) {
-        return addProperty(PropertyType.Short, propertyName);
-    }
-
-    public PropertyBuilder addIntProperty(String propertyName) {
-        return addProperty(PropertyType.Int, propertyName);
-    }
-
-    public PropertyBuilder addLongProperty(String propertyName) {
-        return addProperty(PropertyType.Long, propertyName);
-    }
-
-    public PropertyBuilder addFloatProperty(String propertyName) {
-        return addProperty(PropertyType.Float, propertyName);
-    }
-
-    public PropertyBuilder addDoubleProperty(String propertyName) {
-        return addProperty(PropertyType.Double, propertyName);
-    }
-
-    public PropertyBuilder addByteArrayProperty(String propertyName) {
-        return addProperty(PropertyType.ByteArray, propertyName);
-    }
-
-    public PropertyBuilder addStringProperty(String propertyName) {
-        return addProperty(PropertyType.String, propertyName);
-    }
-
-    public PropertyBuilder addDateProperty(String propertyName) {
-        return addProperty(PropertyType.Date, propertyName);
-    }
-
-    public PropertyBuilder addProperty(PropertyType propertyType, String propertyName) {
-        if (!propertyNames.add(propertyName)) {
-            throw new RuntimeException("Property already defined: " + propertyName);
-        }
-        PropertyBuilder builder = new Property.PropertyBuilder(schema, this, propertyType, propertyName);
-        properties.add(builder.getProperty());
-        return builder;
-    }
-
-    /** Adds a standard _id column required by standard Android classes, e.g. list adapters. */
-    public PropertyBuilder addIdProperty() {
-        PropertyBuilder builder = addLongProperty("id");
-        builder.columnName("_id").primaryKey();
-        return builder;
-    }
-
-    /** Adds a to-many relationship; the target entity is joined to the PK property of this entity (typically the ID). */
-    public ToMany addToMany(Entity target, Property targetProperty) {
-        Property[] targetProperties = {targetProperty};
-        return addToMany(null, target, targetProperties);
-    }
-
-    /**
-     * Convenience method for {@link Entity#addToMany(Entity, Property)} with a subsequent call to {@link
-     * ToMany#setName(String)}.
-     */
-    public ToMany addToMany(Entity target, Property targetProperty, String name) {
-        ToMany toMany = addToMany(target, targetProperty);
-        toMany.setName(name);
-        return toMany;
-    }
-
-    /**
-     * Add a to-many relationship; the target entity is joined using the given target property (of the target entity)
-     * and given source property (of this entity).
-     */
-    public ToMany addToMany(Property sourceProperty, Entity target, Property targetProperty) {
-        Property[] sourceProperties = {sourceProperty};
-        Property[] targetProperties = {targetProperty};
-        return addToMany(sourceProperties, target, targetProperties);
-    }
-
-    public ToMany addToMany(Property[] sourceProperties, Entity target, Property[] targetProperties) {
-        if (protobuf) {
-            throw new IllegalStateException("Protobuf entities do not support relations, currently");
-        }
-
-        ToMany toMany = new ToMany(schema, this, sourceProperties, target, targetProperties);
-        toManyRelations.add(toMany);
-        target.incomingToManyRelations.add(toMany);
-        return toMany;
-    }
-
-    public ToManyWithJoinEntity addToMany(Entity target, Entity joinEntity, Property id1, Property id2) {
-        ToManyWithJoinEntity toMany = new ToManyWithJoinEntity(schema, this, target, joinEntity, id1, id2);
-        toManyRelations.add(toMany);
-        target.incomingToManyRelations.add(toMany);
-        return toMany;
-    }
-
-
-    /**
-     * Adds a to-one relationship to the given target entity using the given given foreign key property (which belongs
-     * to this entity).
-     */
-    public ToOne addToOne(Entity target, Property fkProperty) {
-        if (protobuf) {
-            throw new IllegalStateException("Protobuf entities do not support realtions, currently");
-        }
-
-        Property[] fkProperties = {fkProperty};
-        ToOne toOne = new ToOne(schema, this, target, fkProperties, true);
-        toOneRelations.add(toOne);
-        return toOne;
-    }
-
-    /** Convenience for {@link #addToOne(Entity, Property)} with a subsequent call to {@link ToOne#setName(String)}. */
-    public ToOne addToOne(Entity target, Property fkProperty, String name) {
-        ToOne toOne = addToOne(target, fkProperty);
-        toOne.setName(name);
-        return toOne;
-    }
-
-    public ToOne addToOneWithoutProperty(String name, Entity target, String fkColumnName) {
-        return addToOneWithoutProperty(name, target, fkColumnName, false, false);
-    }
-
-    public ToOne addToOneWithoutProperty(String name, Entity target, String fkColumnName, boolean notNull,
-                                         boolean unique) {
-        PropertyBuilder propertyBuilder = new PropertyBuilder(schema, this, null, name);
-        if (notNull) {
-            propertyBuilder.notNull();
-        }
-        if (unique) {
-            propertyBuilder.unique();
-        }
-        propertyBuilder.columnName(fkColumnName);
-        Property column = propertyBuilder.getProperty();
-        Property[] fkColumns = {column};
-        ToOne toOne = new ToOne(schema, this, target, fkColumns, false);
-        toOne.setName(name);
-        toOneRelations.add(toOne);
-        return toOne;
-    }
-
-    protected void addIncomingToMany(ToMany toMany) {
-        incomingToManyRelations.add(toMany);
-    }
-
-    public ContentProvider addContentProvider() {
-        List<Entity> entities = new ArrayList<Entity>();
-        entities.add(this);
-        ContentProvider contentProvider = new ContentProvider(schema, entities);
-        contentProviders.add(contentProvider);
-        return contentProvider;
-    }
-
-    /** Adds a new index to the entity. */
-    public Entity addIndex(Index index) {
-        indexes.add(index);
-        return this;
-    }
-
-    public Entity addImport(String additionalImport) {
-        additionalImportsEntity.add(additionalImport);
-        return this;
-    }
-
-    /** The entity is represented by a protocol buffers object. Requires some special actions like using builders. */
-    Entity useProtobuf() {
-        protobuf = true;
-        return this;
-    }
-
-    public boolean isProtobuf() {
-        return protobuf;
-    }
-
-    public Schema getSchema() {
-        return schema;
-    }
-
-    public String getTableName() {
-        return tableName;
-    }
-
-    public void setTableName(String tableName) {
-        this.tableName = tableName;
-    }
-
-    public String getClassName() {
-        return className;
-    }
-
-    public List<Property> getProperties() {
-        return properties;
-    }
-
-    public List<Property> getPropertiesColumns() {
-        return propertiesColumns;
-    }
-
-    public String getJavaPackage() {
-        return javaPackage;
-    }
-
-    public void setJavaPackage(String javaPackage) {
-        this.javaPackage = javaPackage;
-    }
-
-    public String getJavaPackageDao() {
-        return javaPackageDao;
-    }
-
-    public void setJavaPackageDao(String javaPackageDao) {
-        this.javaPackageDao = javaPackageDao;
-    }
-
-    public String getClassNameDao() {
-        return classNameDao;
-    }
-
-    public void setClassNameDao(String classNameDao) {
-        this.classNameDao = classNameDao;
-    }
-
-    public String getClassNameTest() {
-        return classNameTest;
-    }
-
-    public void setClassNameTest(String classNameTest) {
-        this.classNameTest = classNameTest;
-    }
-
-    public String getJavaPackageTest() {
-        return javaPackageTest;
-    }
-
-    public void setJavaPackageTest(String javaPackageTest) {
-        this.javaPackageTest = javaPackageTest;
-    }
-
-    /** Internal property used by templates, don't use during entity definition. */
-    public List<Property> getPropertiesPk() {
-        return propertiesPk;
-    }
-
-    /** Internal property used by templates, don't use during entity definition. */
-    public List<Property> getPropertiesNonPk() {
-        return propertiesNonPk;
-    }
-
-    /** Internal property used by templates, don't use during entity definition. */
-    public Property getPkProperty() {
-        return pkProperty;
-    }
-
-    public List<Index> getIndexes() {
-        return indexes;
-    }
-
-    /** Internal property used by templates, don't use during entity definition. */
-    public String getPkType() {
-        return pkType;
-    }
-
-    public boolean isConstructors() {
-        return constructors;
-    }
-
-    public void setConstructors(boolean constructors) {
-        this.constructors = constructors;
-    }
-
-    public boolean isSkipGeneration() {
-        return skipGeneration;
-    }
-
-    /**
-     * Flag if the entity's code generation should be skipped. E.g. if you need to change the class after initial
-     * generation.
-     */
-    public void setSkipGeneration(boolean skipGeneration) {
-        this.skipGeneration = skipGeneration;
-    }
-
-    /** Flag if CREATE & DROP TABLE scripts should be skipped in Dao. */
-    public void setSkipTableCreation(boolean skipTableCreation) {
-        this.skipTableCreation = skipTableCreation;
-    }
-
-    public boolean isSkipTableCreation() {
-        return skipTableCreation;
-    }
-
-    public boolean isSkipGenerationTest() {
-        return skipGenerationTest;
-    }
-
-    public void setSkipGenerationTest(boolean skipGenerationTest) {
-        this.skipGenerationTest = skipGenerationTest;
-    }
-
-    public List<ToOne> getToOneRelations() {
-        return toOneRelations;
-    }
-
-    public List<ToManyBase> getToManyRelations() {
-        return toManyRelations;
-    }
-
-    public List<ToManyBase> getIncomingToManyRelations() {
-        return incomingToManyRelations;
-    }
-
-    /**
-     * Entities with relations are active, but this method allows to make the entities active even if it does not have
-     * relations.
-     */
-    public void setActive(Boolean active) {
-        this.active = active;
-    }
-
-    public Boolean getActive() {
-        return active;
-    }
-
-    public Boolean getHasKeepSections() {
-        return hasKeepSections;
-    }
-
-    public Collection<String> getAdditionalImportsEntity() {
-        return additionalImportsEntity;
-    }
-
-    public Collection<String> getAdditionalImportsDao() {
-        return additionalImportsDao;
-    }
-
-    public void setHasKeepSections(Boolean hasKeepSections) {
-        this.hasKeepSections = hasKeepSections;
-    }
-
-    public List<String> getInterfacesToImplement() {
-        return interfacesToImplement;
-    }
-
-    public List<ContentProvider> getContentProviders() {
-        return contentProviders;
-    }
-
-    public void implementsInterface(String... interfaces) {
-        for (String interfaceToImplement : interfaces) {
-            if (interfacesToImplement.contains(interfaceToImplement)) {
-                throw new RuntimeException("Interface defined more than once: " + interfaceToImplement);
-            }
-            interfacesToImplement.add(interfaceToImplement);
-        }
-    }
-
-    public void implementsSerializable() {
-        interfacesToImplement.add("java.io.Serializable");
-    }
-
-    public String getSuperclass() {
-        return superclass;
-    }
-
-    public void setSuperclass(String classToExtend) {
-        this.superclass = classToExtend;
-    }
-
-    public String getSuperclassDao() {
-        return superclassDao;
-    }
-
-    public void setSuperclassDao(String classToExtend) {
-        this.superclassDao = classToExtend;
-    }
-
-    void init2ndPass() {
-        init2ndPassNamesWithDefaults();
-
-        for (int i = 0; i < properties.size(); i++) {
-            Property property = properties.get(i);
-            property.setOrdinal(i);
-            property.init2ndPass();
-            if (property.isPrimaryKey()) {
-                propertiesPk.add(property);
-            } else {
-                propertiesNonPk.add(property);
-            }
-        }
-
-        if (propertiesPk.size() == 1) {
-            pkProperty = propertiesPk.get(0);
-            pkType = schema.mapToJavaTypeNullable(pkProperty.getPropertyType());
-        } else {
-            pkType = "Void";
-        }
-
-        propertiesColumns = new ArrayList<Property>(properties);
-        for (ToOne toOne : toOneRelations) {
-            toOne.init2ndPass();
-            Property[] fkProperties = toOne.getFkProperties();
-            for (Property fkProperty : fkProperties) {
-                if (!propertiesColumns.contains(fkProperty)) {
-                    propertiesColumns.add(fkProperty);
-                }
-            }
-        }
-
-        for (ToManyBase toMany : toManyRelations) {
-            toMany.init2ndPass();
-            // Source Properties may not be virtual, so we do not need the following code:
-            // for (Property sourceProperty : toMany.getSourceProperties()) {
-            // if (!propertiesColumns.contains(sourceProperty)) {
-            // propertiesColumns.add(sourceProperty);
-            // }
-            // }
-        }
-
-        if (active == null) {
-            active = schema.isUseActiveEntitiesByDefault();
-        }
-        active |= !toOneRelations.isEmpty() || !toManyRelations.isEmpty();
-
-        if (hasKeepSections == null) {
-            hasKeepSections = schema.isHasKeepSectionsByDefault();
-        }
-
-        init2ndPassIndexNamesWithDefaults();
-
-        for (ContentProvider contentProvider : contentProviders) {
-            contentProvider.init2ndPass();
-        }
-    }
-
-    protected void init2ndPassNamesWithDefaults() {
-        if (tableName == null) {
-            tableName = DaoUtil.dbName(className);
-        }
-
-        if (classNameDao == null) {
-            classNameDao = className + "Dao";
-        }
-        if (classNameTest == null) {
-            classNameTest = className + "Test";
-        }
-
-        if (javaPackage == null) {
-            javaPackage = schema.getDefaultJavaPackage();
-        }
-
-        if (javaPackageDao == null) {
-            javaPackageDao = schema.getDefaultJavaPackageDao();
-            if (javaPackageDao == null) {
-                javaPackageDao = javaPackage;
-            }
-        }
-        if (javaPackageTest == null) {
-            javaPackageTest = schema.getDefaultJavaPackageTest();
-            if (javaPackageTest == null) {
-                javaPackageTest = javaPackage;
-            }
-        }
-    }
-
-    protected void init2ndPassIndexNamesWithDefaults() {
-        for (int i = 0; i < indexes.size(); i++) {
-            Index index = indexes.get(i);
-            if (index.getName() == null) {
-                String indexName = "IDX_" + getTableName();
-                List<Property> properties = index.getProperties();
-                for (int j = 0; j < properties.size(); j++) {
-                    Property property = properties.get(j);
-                    indexName += "_" + property.getColumnName();
-                    if ("DESC".equalsIgnoreCase(index.getPropertiesOrder().get(j))) {
-                        indexName += "_DESC";
-                    }
-                }
-                // TODO can this get too long? how to shorten reliably without depending on the order (i)
-                index.setName(indexName);
-            }
-        }
-    }
-
-    void init3rdPass() {
-        for (Property property : properties) {
-            property.init3ndPass();
-        }
-
-        init3rdPassRelations();
-        init3rdPassAdditionalImports();
-    }
-
-    private void init3rdPassRelations() {
-        Set<String> toOneNames = new HashSet<String>();
-        for (ToOne toOne : toOneRelations) {
-            toOne.init3ndPass();
-            if (!toOneNames.add(toOne.getName().toLowerCase())) {
-                throw new RuntimeException("Duplicate name for " + toOne);
-            }
-        }
-
-        Set<String> toManyNames = new HashSet<String>();
-        for (ToManyBase toMany : toManyRelations) {
-            toMany.init3rdPass();
-            if (toMany instanceof ToMany) {
-                Entity targetEntity = toMany.getTargetEntity();
-                for (Property targetProperty : ((ToMany) toMany).getTargetProperties()) {
-                    if (!targetEntity.propertiesColumns.contains(targetProperty)) {
-                        targetEntity.propertiesColumns.add(targetProperty);
-                    }
-                }
-            }
-            if (!toManyNames.add(toMany.getName().toLowerCase())) {
-                throw new RuntimeException("Duplicate name for " + toMany);
-            }
-        }
-    }
-
-    private void init3rdPassAdditionalImports() {
-        if (active && !javaPackage.equals(javaPackageDao)) {
-            additionalImportsEntity.add(javaPackageDao + "." + classNameDao);
-        }
-
-        for (ToOne toOne : toOneRelations) {
-            Entity targetEntity = toOne.getTargetEntity();
-            checkAdditionalImportsEntityTargetEntity(targetEntity);
-            // For deep loading
-            if (!targetEntity.getJavaPackage().equals(javaPackageDao)) {
-                additionalImportsDao.add(targetEntity.getJavaPackage() + "." + targetEntity.getClassName());
-            }
-        }
-
-        for (ToManyBase toMany : toManyRelations) {
-            Entity targetEntity = toMany.getTargetEntity();
-            checkAdditionalImportsEntityTargetEntity(targetEntity);
-        }
-
-        for (Property property : properties) {
-            String customType = property.getCustomType();
-            if (customType != null) {
-                String pack = DaoUtil.getPackageFromFullyQualified(customType);
-                if (!pack.equals(javaPackage)) {
-                    additionalImportsEntity.add(customType);
-                }
-                if (!pack.equals(javaPackageDao)) {
-                    additionalImportsDao.add(customType);
-                }
-            }
-
-            String converter = property.getConverter();
-            if (converter != null) {
-                String pack = DaoUtil.getPackageFromFullyQualified(converter);
-                if (!pack.equals(javaPackageDao)) {
-                    additionalImportsDao.add(converter);
-                }
-            }
-
-        }
-    }
-
-    private void checkAdditionalImportsEntityTargetEntity(Entity targetEntity) {
-        if (!targetEntity.getJavaPackage().equals(javaPackage)) {
-            additionalImportsEntity.add(targetEntity.getJavaPackage() + "." + targetEntity.getClassName());
-        }
-        if (!targetEntity.getJavaPackageDao().equals(javaPackage)) {
-            additionalImportsEntity.add(targetEntity.getJavaPackageDao() + "." + targetEntity.getClassNameDao());
-        }
-    }
-
-    public void validatePropertyExists(Property property) {
-        if (!properties.contains(property)) {
-            throw new RuntimeException("Property " + property + " does not exist in " + this);
-        }
-    }
-
-    @Override
-    public String toString() {
-        return "Entity " + className + " (package: " + javaPackage + ")";
-    }
-
-}
+/*
+ * Copyright (C) 2011-2015 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daogenerator;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import java.util.TreeSet;
+
+import de.greenrobot.daogenerator.Property.PropertyBuilder;
+
+/**
+ * Model class for an entity: a Java data object mapped to a data base table. A new entity is added to a {@link Schema}
+ * by the method {@link Schema#addEntity(String)} (there is no public constructor for {@link Entity} itself). <br/>
+ * <br/> Use the various addXXX methods to add entity properties, indexes, and relations to other entities (addToOne,
+ * addToMany).<br/> <br/> There are further configuration possibilities: <ul> <li>{@link
+ * Entity#implementsInterface(String...)} and {@link #implementsSerializable()} to specify interfaces the entity will
+ * implement</li> <li>{@link #setSuperclass(String)} to specify a class of which the entity will extend from</li>
+ * <li>Various setXXX methods</li> </ul>
+ *
+ * @see <a href="http://greendao-orm.com/documentation/modelling-entities/">Modelling Entities (Documentation page)</a>
+ * @see <a href="http://greendao-orm.com/documentation/relations/">Relations (Documentation page)</a>
+ */
+public class Entity {
+    private final Schema schema;
+    private final String className;
+    private final List<Property> properties;
+    private List<Property> propertiesColumns;
+    private final List<Property> propertiesPk;
+    private final List<Property> propertiesNonPk;
+    private final Set<String> propertyNames;
+    private final List<Index> indexes;
+    private final List<ToOne> toOneRelations;
+    private final List<ToManyBase> toManyRelations;
+    private final List<ToManyBase> incomingToManyRelations;
+    private final Collection<String> additionalImportsEntity;
+    private final Collection<String> additionalImportsDao;
+    private final List<String> interfacesToImplement;
+    private final List<ContentProvider> contentProviders;
+
+    private String tableName;
+    private String classNameDao;
+    private String classNameTest;
+    private String javaPackage;
+    private String javaPackageDao;
+    private String javaPackageTest;
+    private Property pkProperty;
+    private String pkType;
+    private String superclass;
+    private String superclassDao;
+    private String javaDoc;
+    private String codeBeforeClass;
+
+    private boolean protobuf;
+    private boolean constructors;
+    private boolean skipGeneration;
+    private boolean skipGenerationTest;
+    private boolean skipTableCreation;
+    private Boolean active;
+    private Boolean hasKeepSections;
+
+    Entity(Schema schema, String className) {
+        this.schema = schema;
+        this.className = className;
+        this.superclassDao = "AbstractDao";
+        properties = new ArrayList<Property>();
+        propertiesPk = new ArrayList<Property>();
+        propertiesNonPk = new ArrayList<Property>();
+        propertyNames = new HashSet<String>();
+        indexes = new ArrayList<Index>();
+        toOneRelations = new ArrayList<ToOne>();
+        toManyRelations = new ArrayList<ToManyBase>();
+        incomingToManyRelations = new ArrayList<ToManyBase>();
+        additionalImportsEntity = new TreeSet<String>();
+        additionalImportsDao = new TreeSet<String>();
+        interfacesToImplement = new ArrayList<String>();
+        contentProviders = new ArrayList<ContentProvider>();
+        constructors = true;
+    }
+
+    public PropertyBuilder addBooleanProperty(String propertyName) {
+        return addProperty(PropertyType.Boolean, propertyName);
+    }
+
+    public PropertyBuilder addByteProperty(String propertyName) {
+        return addProperty(PropertyType.Byte, propertyName);
+    }
+
+    public PropertyBuilder addShortProperty(String propertyName) {
+        return addProperty(PropertyType.Short, propertyName);
+    }
+
+    public PropertyBuilder addIntProperty(String propertyName) {
+        return addProperty(PropertyType.Int, propertyName);
+    }
+
+    public PropertyBuilder addLongProperty(String propertyName) {
+        return addProperty(PropertyType.Long, propertyName);
+    }
+
+    public PropertyBuilder addFloatProperty(String propertyName) {
+        return addProperty(PropertyType.Float, propertyName);
+    }
+
+    public PropertyBuilder addDoubleProperty(String propertyName) {
+        return addProperty(PropertyType.Double, propertyName);
+    }
+
+    public PropertyBuilder addByteArrayProperty(String propertyName) {
+        return addProperty(PropertyType.ByteArray, propertyName);
+    }
+
+    public PropertyBuilder addStringProperty(String propertyName) {
+        return addProperty(PropertyType.String, propertyName);
+    }
+
+    public PropertyBuilder addDateProperty(String propertyName) {
+        return addProperty(PropertyType.Date, propertyName);
+    }
+
+    public PropertyBuilder addProperty(PropertyType propertyType, String propertyName) {
+        if (!propertyNames.add(propertyName)) {
+            throw new RuntimeException("Property already defined: " + propertyName);
+        }
+        PropertyBuilder builder = new Property.PropertyBuilder(schema, this, propertyType, propertyName);
+        properties.add(builder.getProperty());
+        return builder;
+    }
+
+    /** Adds a standard _id column required by standard Android classes, e.g. list adapters. */
+    public PropertyBuilder addIdProperty() {
+        PropertyBuilder builder = addLongProperty("id");
+        builder.columnName("_id").primaryKey();
+        return builder;
+    }
+
+    /** Adds a to-many relationship; the target entity is joined to the PK property of this entity (typically the ID). */
+    public ToMany addToMany(Entity target, Property targetProperty) {
+        Property[] targetProperties = {targetProperty};
+        return addToMany(null, target, targetProperties);
+    }
+
+    /**
+     * Convenience method for {@link Entity#addToMany(Entity, Property)} with a subsequent call to {@link
+     * ToMany#setName(String)}.
+     */
+    public ToMany addToMany(Entity target, Property targetProperty, String name) {
+        ToMany toMany = addToMany(target, targetProperty);
+        toMany.setName(name);
+        return toMany;
+    }
+
+    /**
+     * Add a to-many relationship; the target entity is joined using the given target property (of the target entity)
+     * and given source property (of this entity).
+     */
+    public ToMany addToMany(Property sourceProperty, Entity target, Property targetProperty) {
+        Property[] sourceProperties = {sourceProperty};
+        Property[] targetProperties = {targetProperty};
+        return addToMany(sourceProperties, target, targetProperties);
+    }
+
+    public ToMany addToMany(Property[] sourceProperties, Entity target, Property[] targetProperties) {
+        if (protobuf) {
+            throw new IllegalStateException("Protobuf entities do not support relations, currently");
+        }
+
+        ToMany toMany = new ToMany(schema, this, sourceProperties, target, targetProperties);
+        toManyRelations.add(toMany);
+        target.incomingToManyRelations.add(toMany);
+        return toMany;
+    }
+
+    public ToManyWithJoinEntity addToMany(Entity target, Entity joinEntity, Property id1, Property id2) {
+        ToManyWithJoinEntity toMany = new ToManyWithJoinEntity(schema, this, target, joinEntity, id1, id2);
+        toManyRelations.add(toMany);
+        target.incomingToManyRelations.add(toMany);
+        return toMany;
+    }
+
+
+    /**
+     * Adds a to-one relationship to the given target entity using the given given foreign key property (which belongs
+     * to this entity).
+     */
+    public ToOne addToOne(Entity target, Property fkProperty) {
+        if (protobuf) {
+            throw new IllegalStateException("Protobuf entities do not support realtions, currently");
+        }
+
+        Property[] fkProperties = {fkProperty};
+        ToOne toOne = new ToOne(schema, this, target, fkProperties, true);
+        toOneRelations.add(toOne);
+        return toOne;
+    }
+
+    /** Convenience for {@link #addToOne(Entity, Property)} with a subsequent call to {@link ToOne#setName(String)}. */
+    public ToOne addToOne(Entity target, Property fkProperty, String name) {
+        ToOne toOne = addToOne(target, fkProperty);
+        toOne.setName(name);
+        return toOne;
+    }
+
+    public ToOne addToOneWithoutProperty(String name, Entity target, String fkColumnName) {
+        return addToOneWithoutProperty(name, target, fkColumnName, false, false);
+    }
+
+    public ToOne addToOneWithoutProperty(String name, Entity target, String fkColumnName, boolean notNull,
+                                         boolean unique) {
+        PropertyBuilder propertyBuilder = new PropertyBuilder(schema, this, null, name);
+        if (notNull) {
+            propertyBuilder.notNull();
+        }
+        if (unique) {
+            propertyBuilder.unique();
+        }
+        propertyBuilder.columnName(fkColumnName);
+        Property column = propertyBuilder.getProperty();
+        Property[] fkColumns = {column};
+        ToOne toOne = new ToOne(schema, this, target, fkColumns, false);
+        toOne.setName(name);
+        toOneRelations.add(toOne);
+        return toOne;
+    }
+
+    protected void addIncomingToMany(ToMany toMany) {
+        incomingToManyRelations.add(toMany);
+    }
+
+    public ContentProvider addContentProvider() {
+        List<Entity> entities = new ArrayList<Entity>();
+        entities.add(this);
+        ContentProvider contentProvider = new ContentProvider(schema, entities);
+        contentProviders.add(contentProvider);
+        return contentProvider;
+    }
+
+    /** Adds a new index to the entity. */
+    public Entity addIndex(Index index) {
+        indexes.add(index);
+        return this;
+    }
+
+    public Entity addImport(String additionalImport) {
+        additionalImportsEntity.add(additionalImport);
+        return this;
+    }
+
+    /** The entity is represented by a protocol buffers object. Requires some special actions like using builders. */
+    Entity useProtobuf() {
+        protobuf = true;
+        return this;
+    }
+
+    public boolean isProtobuf() {
+        return protobuf;
+    }
+
+    public Schema getSchema() {
+        return schema;
+    }
+
+    public String getTableName() {
+        return tableName;
+    }
+
+    public void setTableName(String tableName) {
+        this.tableName = tableName;
+    }
+
+    public String getClassName() {
+        return className;
+    }
+
+    public List<Property> getProperties() {
+        return properties;
+    }
+
+    public List<Property> getPropertiesColumns() {
+        return propertiesColumns;
+    }
+
+    public String getJavaPackage() {
+        return javaPackage;
+    }
+
+    public void setJavaPackage(String javaPackage) {
+        this.javaPackage = javaPackage;
+    }
+
+    public String getJavaPackageDao() {
+        return javaPackageDao;
+    }
+
+    public void setJavaPackageDao(String javaPackageDao) {
+        this.javaPackageDao = javaPackageDao;
+    }
+
+    public String getClassNameDao() {
+        return classNameDao;
+    }
+
+    public void setClassNameDao(String classNameDao) {
+        this.classNameDao = classNameDao;
+    }
+
+    public String getClassNameTest() {
+        return classNameTest;
+    }
+
+    public void setClassNameTest(String classNameTest) {
+        this.classNameTest = classNameTest;
+    }
+
+    public String getJavaPackageTest() {
+        return javaPackageTest;
+    }
+
+    public void setJavaPackageTest(String javaPackageTest) {
+        this.javaPackageTest = javaPackageTest;
+    }
+
+    /** Internal property used by templates, don't use during entity definition. */
+    public List<Property> getPropertiesPk() {
+        return propertiesPk;
+    }
+
+    /** Internal property used by templates, don't use during entity definition. */
+    public List<Property> getPropertiesNonPk() {
+        return propertiesNonPk;
+    }
+
+    /** Internal property used by templates, don't use during entity definition. */
+    public Property getPkProperty() {
+        return pkProperty;
+    }
+
+    public List<Index> getIndexes() {
+        return indexes;
+    }
+
+    /** Internal property used by templates, don't use during entity definition. */
+    public String getPkType() {
+        return pkType;
+    }
+
+    public boolean isConstructors() {
+        return constructors;
+    }
+
+    public void setConstructors(boolean constructors) {
+        this.constructors = constructors;
+    }
+
+    public boolean isSkipGeneration() {
+        return skipGeneration;
+    }
+
+    /**
+     * Flag if the entity's code generation should be skipped. E.g. if you need to change the class after initial
+     * generation.
+     */
+    public void setSkipGeneration(boolean skipGeneration) {
+        this.skipGeneration = skipGeneration;
+    }
+
+    /** Flag if CREATE & DROP TABLE scripts should be skipped in Dao. */
+    public void setSkipTableCreation(boolean skipTableCreation) {
+        this.skipTableCreation = skipTableCreation;
+    }
+
+    public boolean isSkipTableCreation() {
+        return skipTableCreation;
+    }
+
+    public boolean isSkipGenerationTest() {
+        return skipGenerationTest;
+    }
+
+    public void setSkipGenerationTest(boolean skipGenerationTest) {
+        this.skipGenerationTest = skipGenerationTest;
+    }
+
+    public List<ToOne> getToOneRelations() {
+        return toOneRelations;
+    }
+
+    public List<ToManyBase> getToManyRelations() {
+        return toManyRelations;
+    }
+
+    public List<ToManyBase> getIncomingToManyRelations() {
+        return incomingToManyRelations;
+    }
+
+    /**
+     * Entities with relations are active, but this method allows to make the entities active even if it does not have
+     * relations.
+     */
+    public void setActive(Boolean active) {
+        this.active = active;
+    }
+
+    public Boolean getActive() {
+        return active;
+    }
+
+    public Boolean getHasKeepSections() {
+        return hasKeepSections;
+    }
+
+    public Collection<String> getAdditionalImportsEntity() {
+        return additionalImportsEntity;
+    }
+
+    public Collection<String> getAdditionalImportsDao() {
+        return additionalImportsDao;
+    }
+
+    public void setHasKeepSections(Boolean hasKeepSections) {
+        this.hasKeepSections = hasKeepSections;
+    }
+
+    public List<String> getInterfacesToImplement() {
+        return interfacesToImplement;
+    }
+
+    public List<ContentProvider> getContentProviders() {
+        return contentProviders;
+    }
+
+    public void implementsInterface(String... interfaces) {
+        for (String interfaceToImplement : interfaces) {
+            if (interfacesToImplement.contains(interfaceToImplement)) {
+                throw new RuntimeException("Interface defined more than once: " + interfaceToImplement);
+            }
+            interfacesToImplement.add(interfaceToImplement);
+        }
+    }
+
+    public void implementsSerializable() {
+        interfacesToImplement.add("java.io.Serializable");
+    }
+
+    public String getSuperclass() {
+        return superclass;
+    }
+
+    public void setSuperclass(String classToExtend) {
+        this.superclass = classToExtend;
+    }
+
+    public String getSuperclassDao() {
+        return superclassDao;
+    }
+
+    public void setSuperclassDao(String classToExtend) {
+        this.superclassDao = classToExtend;
+    }
+
+    public String getJavaDoc() {
+        return javaDoc;
+    }
+
+    public void setJavaDoc(String javaDoc) {
+        this.javaDoc = DaoUtil.checkConvertToJavaDoc(javaDoc, "");
+    }
+
+    public String getCodeBeforeClass() {
+        return codeBeforeClass;
+    }
+
+    public void setCodeBeforeClass(String codeBeforeClass) {
+        this.codeBeforeClass = codeBeforeClass;
+    }
+
+    void init2ndPass() {
+        init2ndPassNamesWithDefaults();
+
+        for (int i = 0; i < properties.size(); i++) {
+            Property property = properties.get(i);
+            property.setOrdinal(i);
+            property.init2ndPass();
+            if (property.isPrimaryKey()) {
+                propertiesPk.add(property);
+            } else {
+                propertiesNonPk.add(property);
+            }
+        }
+
+        if (propertiesPk.size() == 1) {
+            pkProperty = propertiesPk.get(0);
+            pkType = schema.mapToJavaTypeNullable(pkProperty.getPropertyType());
+        } else {
+            pkType = "Void";
+        }
+
+        propertiesColumns = new ArrayList<Property>(properties);
+        for (ToOne toOne : toOneRelations) {
+            toOne.init2ndPass();
+            Property[] fkProperties = toOne.getFkProperties();
+            for (Property fkProperty : fkProperties) {
+                if (!propertiesColumns.contains(fkProperty)) {
+                    propertiesColumns.add(fkProperty);
+                }
+            }
+        }
+
+        for (ToManyBase toMany : toManyRelations) {
+            toMany.init2ndPass();
+            // Source Properties may not be virtual, so we do not need the following code:
+            // for (Property sourceProperty : toMany.getSourceProperties()) {
+            // if (!propertiesColumns.contains(sourceProperty)) {
+            // propertiesColumns.add(sourceProperty);
+            // }
+            // }
+        }
+
+        if (active == null) {
+            active = schema.isUseActiveEntitiesByDefault();
+        }
+        active |= !toOneRelations.isEmpty() || !toManyRelations.isEmpty();
+
+        if (hasKeepSections == null) {
+            hasKeepSections = schema.isHasKeepSectionsByDefault();
+        }
+
+        init2ndPassIndexNamesWithDefaults();
+
+        for (ContentProvider contentProvider : contentProviders) {
+            contentProvider.init2ndPass();
+        }
+    }
+
+    protected void init2ndPassNamesWithDefaults() {
+        if (tableName == null) {
+            tableName = DaoUtil.dbName(className);
+        }
+
+        if (classNameDao == null) {
+            classNameDao = className + "Dao";
+        }
+        if (classNameTest == null) {
+            classNameTest = className + "Test";
+        }
+
+        if (javaPackage == null) {
+            javaPackage = schema.getDefaultJavaPackage();
+        }
+
+        if (javaPackageDao == null) {
+            javaPackageDao = schema.getDefaultJavaPackageDao();
+            if (javaPackageDao == null) {
+                javaPackageDao = javaPackage;
+            }
+        }
+        if (javaPackageTest == null) {
+            javaPackageTest = schema.getDefaultJavaPackageTest();
+            if (javaPackageTest == null) {
+                javaPackageTest = javaPackage;
+            }
+        }
+    }
+
+    protected void init2ndPassIndexNamesWithDefaults() {
+        for (int i = 0; i < indexes.size(); i++) {
+            Index index = indexes.get(i);
+            if (index.getName() == null) {
+                String indexName = "IDX_" + getTableName();
+                List<Property> properties = index.getProperties();
+                for (int j = 0; j < properties.size(); j++) {
+                    Property property = properties.get(j);
+                    indexName += "_" + property.getColumnName();
+                    if ("DESC".equalsIgnoreCase(index.getPropertiesOrder().get(j))) {
+                        indexName += "_DESC";
+                    }
+                }
+                // TODO can this get too long? how to shorten reliably without depending on the order (i)
+                index.setName(indexName);
+            }
+        }
+    }
+
+    void init3rdPass() {
+        for (Property property : properties) {
+            property.init3ndPass();
+        }
+
+        init3rdPassRelations();
+        init3rdPassAdditionalImports();
+    }
+
+    private void init3rdPassRelations() {
+        Set<String> toOneNames = new HashSet<String>();
+        for (ToOne toOne : toOneRelations) {
+            toOne.init3ndPass();
+            if (!toOneNames.add(toOne.getName().toLowerCase())) {
+                throw new RuntimeException("Duplicate name for " + toOne);
+            }
+        }
+
+        Set<String> toManyNames = new HashSet<String>();
+        for (ToManyBase toMany : toManyRelations) {
+            toMany.init3rdPass();
+            if (toMany instanceof ToMany) {
+                Entity targetEntity = toMany.getTargetEntity();
+                for (Property targetProperty : ((ToMany) toMany).getTargetProperties()) {
+                    if (!targetEntity.propertiesColumns.contains(targetProperty)) {
+                        targetEntity.propertiesColumns.add(targetProperty);
+                    }
+                }
+            }
+            if (!toManyNames.add(toMany.getName().toLowerCase())) {
+                throw new RuntimeException("Duplicate name for " + toMany);
+            }
+        }
+    }
+
+    private void init3rdPassAdditionalImports() {
+        if (active && !javaPackage.equals(javaPackageDao)) {
+            additionalImportsEntity.add(javaPackageDao + "." + classNameDao);
+        }
+
+        for (ToOne toOne : toOneRelations) {
+            Entity targetEntity = toOne.getTargetEntity();
+            checkAdditionalImportsEntityTargetEntity(targetEntity);
+            // For deep loading
+            if (!targetEntity.getJavaPackage().equals(javaPackageDao)) {
+                additionalImportsDao.add(targetEntity.getJavaPackage() + "." + targetEntity.getClassName());
+            }
+        }
+
+        for (ToManyBase toMany : toManyRelations) {
+            Entity targetEntity = toMany.getTargetEntity();
+            checkAdditionalImportsEntityTargetEntity(targetEntity);
+        }
+
+        for (Property property : properties) {
+            String customType = property.getCustomType();
+            if (customType != null) {
+                String pack = DaoUtil.getPackageFromFullyQualified(customType);
+                if (!pack.equals(javaPackage)) {
+                    additionalImportsEntity.add(customType);
+                }
+                if (!pack.equals(javaPackageDao)) {
+                    additionalImportsDao.add(customType);
+                }
+            }
+
+            String converter = property.getConverter();
+            if (converter != null) {
+                String pack = DaoUtil.getPackageFromFullyQualified(converter);
+                if (!pack.equals(javaPackageDao)) {
+                    additionalImportsDao.add(converter);
+                }
+            }
+
+        }
+    }
+
+    private void checkAdditionalImportsEntityTargetEntity(Entity targetEntity) {
+        if (!targetEntity.getJavaPackage().equals(javaPackage)) {
+            additionalImportsEntity.add(targetEntity.getJavaPackage() + "." + targetEntity.getClassName());
+        }
+        if (!targetEntity.getJavaPackageDao().equals(javaPackage)) {
+            additionalImportsEntity.add(targetEntity.getJavaPackageDao() + "." + targetEntity.getClassNameDao());
+        }
+    }
+
+    public void validatePropertyExists(Property property) {
+        if (!properties.contains(property)) {
+            throw new RuntimeException("Property " + property + " does not exist in " + this);
+        }
+    }
+
+    @Override
+    public String toString() {
+        return "Entity " + className + " (package: " + javaPackage + ")";
+    }
+
+}
diff --git a/DaoGenerator/src/de/greenrobot/daogenerator/Property.java b/DaoGenerator/src/de/greenrobot/daogenerator/Property.java
index 267a1541..14534df5 100644
--- a/DaoGenerator/src/de/greenrobot/daogenerator/Property.java
+++ b/DaoGenerator/src/de/greenrobot/daogenerator/Property.java
@@ -125,6 +125,38 @@ public PropertyBuilder codeBeforeSetter(String code) {
             return this;
         }
 
+        public PropertyBuilder codeBeforeGetterAndSetter(String code) {
+            property.codeBeforeGetter = code;
+            property.codeBeforeSetter = code;
+            return this;
+        }
+
+        public PropertyBuilder javaDocField(String javaDoc) {
+            property.javaDocField = checkConvertToJavaDoc(javaDoc);
+            return this;
+        }
+
+        private String checkConvertToJavaDoc(String javaDoc) {
+            return DaoUtil.checkConvertToJavaDoc(javaDoc, "    ");
+        }
+
+        public PropertyBuilder javaDocGetter(String javaDoc) {
+            property.javaDocGetter = checkConvertToJavaDoc(javaDoc);
+            return this;
+        }
+
+        public PropertyBuilder javaDocSetter(String javaDoc) {
+            property.javaDocSetter = checkConvertToJavaDoc(javaDoc);
+            return this;
+        }
+
+        public PropertyBuilder javaDocGetterAndSetter(String javaDoc) {
+            javaDoc = checkConvertToJavaDoc(javaDoc);
+            property.javaDocGetter = javaDoc;
+            property.javaDocSetter = javaDoc;
+            return this;
+        }
+
         public Property getProperty() {
             return property;
         }
@@ -147,6 +179,10 @@ public Property getProperty() {
     private String codeBeforeGetter;
     private String codeBeforeSetter;
 
+    private String javaDocField;
+    private String javaDocGetter;
+    private String javaDocSetter;
+
     private boolean primaryKey;
     private boolean pkAsc;
     private boolean pkDesc;
@@ -257,6 +293,18 @@ public String getCodeBeforeSetter() {
         return codeBeforeSetter;
     }
 
+    public String getJavaDocField() {
+        return javaDocField;
+    }
+
+    public String getJavaDocGetter() {
+        return javaDocGetter;
+    }
+
+    public String getJavaDocSetter() {
+        return javaDocSetter;
+    }
+
     public String getDatabaseValueExpression() {
         return getDatabaseValueExpression(propertyName);
     }
@@ -278,9 +326,9 @@ public String getDatabaseValueExpression(String entityValue) {
         if (customType != null) {
             builder.append(')');
         }
-        if(propertyType == PropertyType.Boolean) {
+        if (propertyType == PropertyType.Boolean) {
             builder.append(" ? 1L: 0L");
-        } else if(propertyType == PropertyType.Date) {
+        } else if (propertyType == PropertyType.Date) {
             builder.append(".getTime()");
         }
         return builder.toString();
@@ -297,16 +345,15 @@ public String getEntityValueExpression(String databaseValue) {
         if (customType != null) {
             builder.append(propertyName).append("Converter.convertToEntityProperty(");
         }
-        if(propertyType == PropertyType.Byte) {
+        if (propertyType == PropertyType.Byte) {
             builder.append("(byte) ");
-        }else
-        if(propertyType == PropertyType.Date) {
+        } else if (propertyType == PropertyType.Date) {
             builder.append("new java.util.Date(");
         }
         builder.append(databaseValue);
-        if(propertyType == PropertyType.Boolean) {
+        if (propertyType == PropertyType.Boolean) {
             builder.append(" != 0");
-        } else if(propertyType == PropertyType.Date) {
+        } else if (propertyType == PropertyType.Date) {
             builder.append(")");
         }
         if (customType != null) {
diff --git a/DaoGenerator/src/de/greenrobot/daogenerator/ToManyWithJoinEntity.java b/DaoGenerator/src/de/greenrobot/daogenerator/ToManyWithJoinEntity.java
index 75221566..0f897f05 100644
--- a/DaoGenerator/src/de/greenrobot/daogenerator/ToManyWithJoinEntity.java
+++ b/DaoGenerator/src/de/greenrobot/daogenerator/ToManyWithJoinEntity.java
@@ -45,8 +45,8 @@ public Property getTargetProperty() {
         return targetProperty;
     }
 
-    void init2ndPass() {
-        super.init2ndPass();
+    void init3rdPass() {
+        super.init3rdPass();
         List<Property> pks = sourceEntity.getPropertiesPk();
         if (pks.isEmpty()) {
             throw new RuntimeException("Source entity has no primary key, but we need it for " + this);
@@ -57,8 +57,4 @@ void init2ndPass() {
         }
     }
 
-    void init3rdPass() {
-        super.init3rdPass();
-    }
-
 }
diff --git a/DaoTest/.gitignore b/DaoTest/.gitignore
deleted file mode 100644
index 31ec0aee..00000000
--- a/DaoTest/.gitignore
+++ /dev/null
@@ -1,3 +0,0 @@
-/gen
-/DaoCore_src
-/bin
diff --git a/DaoTest/build.gradle b/DaoTest/build.gradle
index 4ee9927f..5a2dfb1d 100644
--- a/DaoTest/build.gradle
+++ b/DaoTest/build.gradle
@@ -4,32 +4,20 @@ buildscript {
     }
 
     dependencies {
-        classpath 'com.android.tools.build:gradle:1.2.3'
+        classpath 'com.android.tools.build:gradle:2.1.2'
     }
 }
 
-apply plugin: 'android'
+apply plugin: 'com.android.application'
 
 dependencies {
-    androidTestCompile project(':DaoCore')
+    compile project(':DaoTestBase')
+    testCompile 'org.robolectric:robolectric:3.0'
 }
 
 android {
-    buildToolsVersion '22.0.1'
-    compileSdkVersion 19
-
-    sourceSets {
-        main {
-            manifest.srcFile 'AndroidManifest.xml'
-            // Workaround: assets.srcDirs in androidTest doesn't seem to work currently
-            assets.srcDirs = ['assets']
-        }
-
-        androidTest {
-            assets.srcDirs = ['assets']
-            java.srcDirs = ['src','src-gen']
-        }
-    }
+    buildToolsVersion rootProject.ext.buildToolsVersion
+    compileSdkVersion rootProject.ext.compileSdkVersion
 
     defaultConfig {
         testApplicationId "de.greenrobot.daotest"
diff --git a/DaoTest/res/values/dummy.xml b/DaoTest/res/values/dummy.xml
deleted file mode 100644
index 4c670337..00000000
--- a/DaoTest/res/values/dummy.xml
+++ /dev/null
@@ -1,4 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<resources>
-    
-</resources>
diff --git a/DaoTest/src/de/greenrobot/daotest/DaoSessionConcurrentTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/DaoSessionConcurrentTest.java
similarity index 96%
rename from DaoTest/src/de/greenrobot/daotest/DaoSessionConcurrentTest.java
rename to DaoTest/src/androidTest/java/de/greenrobot/daotest/DaoSessionConcurrentTest.java
index ffa9e718..e243c4c5 100644
--- a/DaoTest/src/de/greenrobot/daotest/DaoSessionConcurrentTest.java
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/DaoSessionConcurrentTest.java
@@ -5,6 +5,7 @@
 import android.database.sqlite.SQLiteDatabase;
 import android.database.sqlite.SQLiteStatement;
 import android.os.SystemClock;
+
 import de.greenrobot.dao.DaoLog;
 import de.greenrobot.dao.query.DeleteQuery;
 import de.greenrobot.dao.query.Query;
@@ -209,17 +210,14 @@ public void run() {
         latchThreadsDone.await();
     }
 
-    // No connection for read can be acquired while TX is active; this will deadlock!
-    public void _testConcurrentLockAndQueryDuringTx() throws InterruptedException {
+    public void testConcurrentLockAndQueryDuringTx() throws InterruptedException {
         final TestEntity entity = createEntity(null);
         dao.insert(entity);
         final Query<TestEntity> query = dao.queryBuilder().build();
         Runnable runnable1 = new Runnable() {
             @Override
             public void run() {
-                synchronized (query) {
-                    query.list();
-                }
+                query.forCurrentThread().list();
             }
         };
 
@@ -229,9 +227,7 @@ public void run() {
         doTx(new Runnable() {
             @Override
             public void run() {
-                synchronized (query) {
-                    query.list();
-                }
+                query.list();
             }
         });
         latchThreadsDone.await();
diff --git a/DaoTest/src/de/greenrobot/daotest/DaoSessionConcurrentWALTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/DaoSessionConcurrentWALTest.java
similarity index 100%
rename from DaoTest/src/de/greenrobot/daotest/DaoSessionConcurrentWALTest.java
rename to DaoTest/src/androidTest/java/de/greenrobot/daotest/DaoSessionConcurrentWALTest.java
diff --git a/DaoTest/src/de/greenrobot/daotest/DaoSessionTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/DaoSessionTest.java
similarity index 100%
rename from DaoTest/src/de/greenrobot/daotest/DaoSessionTest.java
rename to DaoTest/src/androidTest/java/de/greenrobot/daotest/DaoSessionTest.java
diff --git a/DaoTest/src/de/greenrobot/daotest/DbTestTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/DbTestTest.java
similarity index 100%
rename from DaoTest/src/de/greenrobot/daotest/DbTestTest.java
rename to DaoTest/src/androidTest/java/de/greenrobot/daotest/DbTestTest.java
diff --git a/DaoTest/src/de/greenrobot/daotest/DbUtilsTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/DbUtilsTest.java
similarity index 100%
rename from DaoTest/src/de/greenrobot/daotest/DbUtilsTest.java
rename to DaoTest/src/androidTest/java/de/greenrobot/daotest/DbUtilsTest.java
diff --git a/DaoTest/src/androidTest/java/de/greenrobot/daotest/DeadlockPreventionTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/DeadlockPreventionTest.java
new file mode 100644
index 00000000..ae015fb2
--- /dev/null
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/DeadlockPreventionTest.java
@@ -0,0 +1,153 @@
+/*
+ * Copyright (C) 2011-2015 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+import de.greenrobot.dao.test.AbstractDaoSessionTest;
+
+/**
+ * Test to reproduce https://github.com/greenrobot/greenDAO/issues/223 (works at least on a Android 2.3 emulator).
+ */
+public class DeadlockPreventionTest extends AbstractDaoSessionTest<DaoMaster, DaoSession> {
+
+    CountDownLatch done = new CountDownLatch(1);
+    private TestEntityDao dao;
+
+    public DeadlockPreventionTest() {
+        super(DaoMaster.class);
+    }
+
+    // Runs pretty long, only run manually
+    public void _testLoadAll() throws InterruptedException {
+        dao = daoSession.getTestEntityDao();
+        List<TestEntity> entities = new ArrayList<>();
+        for (int i = 0; i < 10000; i++) {
+            TestEntity entity = new TestEntity();
+            entity.setSimpleStringNotNull("Text" + i);
+            entities.add(entity);
+        }
+        dao.insertInTx(entities);
+        System.out.println("Entities inserted");
+
+        LoadThread loadThread = new LoadThread();
+        InsertThread insertThread = new InsertThread();
+        InsertBatchThread insertBatchThread = new InsertBatchThread();
+        loadThread.start();
+        insertThread.start();
+        insertBatchThread.start();
+
+        int lastCounterInsert = insertThread.counter;
+        int lastCounterInsertBatch = insertBatchThread.counter;
+        int noProgressCount = 0;
+        while (!done.await(10, TimeUnit.SECONDS)) {
+            if (lastCounterInsert == insertThread.counter && lastCounterInsertBatch == insertBatchThread.counter) {
+                noProgressCount++;
+                System.err.println("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
+                System.err.println("No progress #" + noProgressCount + ", dumping threads");
+                System.err.println("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
+                dumpStacktrace("LOAD", loadThread);
+                dumpStacktrace("INSERT", insertThread);
+                dumpStacktrace("INSERT BATCH", insertBatchThread);
+
+                if (noProgressCount >= 3) {
+                    // Test seems to be stuck, kill everything!
+                    System.exit(1);
+                }
+            } else {
+                lastCounterInsert = insertThread.counter;
+                lastCounterInsertBatch = insertBatchThread.counter;
+                noProgressCount = 0;
+            }
+        }
+
+        loadThread.join();
+        insertThread.join();
+        insertBatchThread.join();
+    }
+
+    private void dumpStacktrace(String name, Thread thread) {
+        System.err.println("--- Thread dump of " + name + " ------------------------");
+        for (StackTraceElement element : thread.getStackTrace()) {
+            System.err.println(element);
+        }
+    }
+
+    private class LoadThread extends Thread {
+        @Override
+        public void run() {
+            for (int i = 0; i < 10; i++) {
+                System.out.println("Starting loadAll #" + i);
+                dao.loadAll();
+            }
+            done.countDown();
+        }
+    }
+
+
+    private class InsertThread extends Thread {
+        volatile int counter = 0;
+
+        @Override
+        public void run() {
+            List<TestEntity> toDelete = new ArrayList<>();
+            while (done.getCount() > 0) {
+                TestEntity entity = new TestEntity();
+                entity.setSimpleStringNotNull("TextThread" + counter);
+                dao.insert(entity);
+                toDelete.add(entity);
+                counter++;
+                if (counter % 10 == 0) {
+                    System.out.println("Thread inserted " + counter+ ", now deleting");
+                    dao.deleteInTx(toDelete);
+                    toDelete.clear();
+                }
+            }
+        }
+    }
+
+    private class InsertBatchThread extends Thread {
+        volatile int counter = 0;
+
+        @Override
+        public void run() {
+            List<TestEntity> batch = new ArrayList<>();
+            List<TestEntity> toDelete = new ArrayList<>();
+            while (done.getCount() > 0) {
+                TestEntity entity = new TestEntity();
+                entity.setSimpleStringNotNull("TextThreadBatch" + counter);
+                batch.add(entity);
+                counter++;
+                if (counter % 10 == 0) {
+                    dao.insertInTx(batch);
+                    System.out.println("Batch Thread inserted " + counter);
+                    toDelete.addAll(batch);
+                    batch.clear();
+                }
+                if (counter % 1000 == 0) {
+                    dao.deleteInTx(toDelete);
+                    toDelete.clear();
+                    System.out.println("Batch Thread deleted " + counter);
+                }
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/DaoTest/src/de/greenrobot/daotest/IndexTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/IndexTest.java
similarity index 100%
rename from DaoTest/src/de/greenrobot/daotest/IndexTest.java
rename to DaoTest/src/androidTest/java/de/greenrobot/daotest/IndexTest.java
diff --git a/DaoTest/src/de/greenrobot/daotest/LongHashMapTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/LongHashMapTest.java
similarity index 100%
rename from DaoTest/src/de/greenrobot/daotest/LongHashMapTest.java
rename to DaoTest/src/androidTest/java/de/greenrobot/daotest/LongHashMapTest.java
diff --git a/DaoTest/src/de/greenrobot/daotest/async/AbstractAsyncTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/async/AbstractAsyncTest.java
similarity index 100%
rename from DaoTest/src/de/greenrobot/daotest/async/AbstractAsyncTest.java
rename to DaoTest/src/androidTest/java/de/greenrobot/daotest/async/AbstractAsyncTest.java
diff --git a/DaoTest/src/de/greenrobot/daotest/async/BasicAsyncTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/async/BasicAsyncTest.java
similarity index 100%
rename from DaoTest/src/de/greenrobot/daotest/async/BasicAsyncTest.java
rename to DaoTest/src/androidTest/java/de/greenrobot/daotest/async/BasicAsyncTest.java
diff --git a/DaoTest/src/de/greenrobot/daotest/async/MergeTxAsyncTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/async/MergeTxAsyncTest.java
similarity index 100%
rename from DaoTest/src/de/greenrobot/daotest/async/MergeTxAsyncTest.java
rename to DaoTest/src/androidTest/java/de/greenrobot/daotest/async/MergeTxAsyncTest.java
diff --git a/DaoTest/src/de/greenrobot/daotest/contentprovider/SimpleEntityContentProviderTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/contentprovider/SimpleEntityContentProviderTest.java
similarity index 100%
rename from DaoTest/src/de/greenrobot/daotest/contentprovider/SimpleEntityContentProviderTest.java
rename to DaoTest/src/androidTest/java/de/greenrobot/daotest/contentprovider/SimpleEntityContentProviderTest.java
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/AbcdefEntityTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/AbcdefEntityTest.java
similarity index 100%
rename from DaoTest/src/de/greenrobot/daotest/entity/AbcdefEntityTest.java
rename to DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/AbcdefEntityTest.java
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/AnActiveEntityMultithreadingTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/AnActiveEntityMultithreadingTest.java
similarity index 100%
rename from DaoTest/src/de/greenrobot/daotest/entity/AnActiveEntityMultithreadingTest.java
rename to DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/AnActiveEntityMultithreadingTest.java
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/AnActiveEntityTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/AnActiveEntityTest.java
similarity index 100%
rename from DaoTest/src/de/greenrobot/daotest/entity/AnActiveEntityTest.java
rename to DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/AnActiveEntityTest.java
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/AutoincrementEntityTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/AutoincrementEntityTest.java
similarity index 100%
rename from DaoTest/src/de/greenrobot/daotest/entity/AutoincrementEntityTest.java
rename to DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/AutoincrementEntityTest.java
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/CustomTypeEntityTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/CustomTypeEntityTest.java
similarity index 100%
rename from DaoTest/src/de/greenrobot/daotest/entity/CustomTypeEntityTest.java
rename to DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/CustomTypeEntityTest.java
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/DateEntityTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/DateEntityTest.java
similarity index 100%
rename from DaoTest/src/de/greenrobot/daotest/entity/DateEntityTest.java
rename to DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/DateEntityTest.java
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/ExtendsImplementsEntityTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/ExtendsImplementsEntityTest.java
similarity index 100%
rename from DaoTest/src/de/greenrobot/daotest/entity/ExtendsImplementsEntityTest.java
rename to DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/ExtendsImplementsEntityTest.java
diff --git a/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/IndexedStringEntityTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/IndexedStringEntityTest.java
new file mode 100644
index 00000000..437de999
--- /dev/null
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/IndexedStringEntityTest.java
@@ -0,0 +1,21 @@
+package de.greenrobot.daotest.entity;
+
+import de.greenrobot.dao.test.AbstractDaoTestLongPk;
+
+import de.greenrobot.daotest.IndexedStringEntity;
+import de.greenrobot.daotest.IndexedStringEntityDao;
+
+public class IndexedStringEntityTest extends AbstractDaoTestLongPk<IndexedStringEntityDao, IndexedStringEntity> {
+
+    public IndexedStringEntityTest() {
+        super(IndexedStringEntityDao.class);
+    }
+
+    @Override
+    protected IndexedStringEntity createEntity(Long key) {
+        IndexedStringEntity entity = new IndexedStringEntity();
+        entity.setId(key);
+        return entity;
+    }
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/JoinManyToDateEntityTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/JoinManyToDateEntityTest.java
similarity index 100%
rename from DaoTest/src/de/greenrobot/daotest/entity/JoinManyToDateEntityTest.java
rename to DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/JoinManyToDateEntityTest.java
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/RelationEntityTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/RelationEntityTest.java
similarity index 100%
rename from DaoTest/src/de/greenrobot/daotest/entity/RelationEntityTest.java
rename to DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/RelationEntityTest.java
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/RelationEntityTestIdentityScope.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/RelationEntityTestIdentityScope.java
similarity index 100%
rename from DaoTest/src/de/greenrobot/daotest/entity/RelationEntityTestIdentityScope.java
rename to DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/RelationEntityTestIdentityScope.java
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/SimpleEntityNotNullTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/SimpleEntityNotNullTest.java
similarity index 100%
rename from DaoTest/src/de/greenrobot/daotest/entity/SimpleEntityNotNullTest.java
rename to DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/SimpleEntityNotNullTest.java
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/SimpleEntityTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/SimpleEntityTest.java
similarity index 100%
rename from DaoTest/src/de/greenrobot/daotest/entity/SimpleEntityTest.java
rename to DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/SimpleEntityTest.java
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/SpecialNamesEntityTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/SpecialNamesEntityTest.java
similarity index 100%
rename from DaoTest/src/de/greenrobot/daotest/entity/SpecialNamesEntityTest.java
rename to DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/SpecialNamesEntityTest.java
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/SqliteMasterTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/SqliteMasterTest.java
similarity index 100%
rename from DaoTest/src/de/greenrobot/daotest/entity/SqliteMasterTest.java
rename to DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/SqliteMasterTest.java
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/StringKeyValueEntityIdentityScopeTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/StringKeyValueEntityIdentityScopeTest.java
similarity index 100%
rename from DaoTest/src/de/greenrobot/daotest/entity/StringKeyValueEntityIdentityScopeTest.java
rename to DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/StringKeyValueEntityIdentityScopeTest.java
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/StringKeyValueEntityTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/StringKeyValueEntityTest.java
similarity index 100%
rename from DaoTest/src/de/greenrobot/daotest/entity/StringKeyValueEntityTest.java
rename to DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/StringKeyValueEntityTest.java
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/TestEntityIdentityScopeTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/TestEntityIdentityScopeTest.java
similarity index 86%
rename from DaoTest/src/de/greenrobot/daotest/entity/TestEntityIdentityScopeTest.java
rename to DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/TestEntityIdentityScopeTest.java
index 755156cb..10de895c 100644
--- a/DaoTest/src/de/greenrobot/daotest/entity/TestEntityIdentityScopeTest.java
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/TestEntityIdentityScopeTest.java
@@ -50,6 +50,17 @@ public void testDetach() {
         assertNotSame(entity, entity3);
     }
 
+    public void testDetachAll() {
+        TestEntity entity1 = createEntity(null);
+        TestEntity entity2 = createEntity(null);
+        dao.insertInTx(entity1, entity2);
+        dao.detachAll();
+        TestEntity entity1a = dao.load(entity1.getId());
+        TestEntity entity2a = dao.load(entity2.getId());
+        assertNotSame(entity1, entity1a);
+        assertNotSame(entity2, entity2a);
+    }
+
     public void testDetachOther() {
         TestEntity entity = createEntity(null);
         dao.insert(entity);
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/TestEntityTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/TestEntityTest.java
similarity index 100%
rename from DaoTest/src/de/greenrobot/daotest/entity/TestEntityTest.java
rename to DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/TestEntityTest.java
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/TestEntityTestBase.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/TestEntityTestBase.java
similarity index 100%
rename from DaoTest/src/de/greenrobot/daotest/entity/TestEntityTestBase.java
rename to DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/TestEntityTestBase.java
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/ToManyEntityTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/ToManyEntityTest.java
similarity index 100%
rename from DaoTest/src/de/greenrobot/daotest/entity/ToManyEntityTest.java
rename to DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/ToManyEntityTest.java
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/ToManyTargetEntityTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/ToManyTargetEntityTest.java
similarity index 100%
rename from DaoTest/src/de/greenrobot/daotest/entity/ToManyTargetEntityTest.java
rename to DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/ToManyTargetEntityTest.java
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/TreeEntityTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/TreeEntityTest.java
similarity index 100%
rename from DaoTest/src/de/greenrobot/daotest/entity/TreeEntityTest.java
rename to DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/TreeEntityTest.java
diff --git a/DaoTest/src/de/greenrobot/daotest/query/CountQueryTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/query/CountQueryTest.java
similarity index 100%
rename from DaoTest/src/de/greenrobot/daotest/query/CountQueryTest.java
rename to DaoTest/src/androidTest/java/de/greenrobot/daotest/query/CountQueryTest.java
diff --git a/DaoTest/src/de/greenrobot/daotest/query/CountQueryThreadLocalTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/query/CountQueryThreadLocalTest.java
similarity index 100%
rename from DaoTest/src/de/greenrobot/daotest/query/CountQueryThreadLocalTest.java
rename to DaoTest/src/androidTest/java/de/greenrobot/daotest/query/CountQueryThreadLocalTest.java
diff --git a/DaoTest/src/androidTest/java/de/greenrobot/daotest/query/CursorQueryTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/query/CursorQueryTest.java
new file mode 100644
index 00000000..be86693b
--- /dev/null
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/query/CursorQueryTest.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2011-2015 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.query;
+
+import android.database.Cursor;
+import de.greenrobot.dao.query.CursorQuery;
+import de.greenrobot.dao.query.QueryBuilder;
+import de.greenrobot.daotest.TestEntityDao.Properties;
+import de.greenrobot.daotest.entity.TestEntityTestBase;
+
+// TODO more tests
+public class CursorQueryTest extends TestEntityTestBase {
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        QueryBuilder.LOG_SQL = true;
+        QueryBuilder.LOG_VALUES = true;
+    }
+
+    public void testCursorQuerySimple() {
+        insert(3);
+        CursorQuery query = dao.queryBuilder().orderAsc(Properties.SimpleInteger).buildCursor();
+        Cursor cursor = query.query();
+        try {
+            assertEquals(3, cursor.getCount());
+            assertTrue(cursor.moveToNext());
+            int columnIndex = cursor.getColumnIndexOrThrow(Properties.SimpleInteger.columnName);
+            assertEquals(getSimpleInteger(0), cursor.getInt(columnIndex));
+            assertTrue(cursor.moveToNext());
+            assertEquals(getSimpleInteger(1), cursor.getInt(columnIndex));
+            assertTrue(cursor.moveToNext());
+            assertEquals(getSimpleInteger(2), cursor.getInt(columnIndex));
+            assertFalse(cursor.moveToNext());
+        } finally {
+            cursor.close();
+        }
+    }
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/query/DeleteQueryTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/query/DeleteQueryTest.java
similarity index 100%
rename from DaoTest/src/de/greenrobot/daotest/query/DeleteQueryTest.java
rename to DaoTest/src/androidTest/java/de/greenrobot/daotest/query/DeleteQueryTest.java
diff --git a/DaoTest/src/de/greenrobot/daotest/query/DeleteQueryThreadLocalTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/query/DeleteQueryThreadLocalTest.java
similarity index 100%
rename from DaoTest/src/de/greenrobot/daotest/query/DeleteQueryThreadLocalTest.java
rename to DaoTest/src/androidTest/java/de/greenrobot/daotest/query/DeleteQueryThreadLocalTest.java
diff --git a/DaoTest/src/de/greenrobot/daotest/query/JoinTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/query/JoinTest.java
similarity index 100%
rename from DaoTest/src/de/greenrobot/daotest/query/JoinTest.java
rename to DaoTest/src/androidTest/java/de/greenrobot/daotest/query/JoinTest.java
diff --git a/DaoTest/src/de/greenrobot/daotest/query/LazyListTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/query/LazyListTest.java
similarity index 100%
rename from DaoTest/src/de/greenrobot/daotest/query/LazyListTest.java
rename to DaoTest/src/androidTest/java/de/greenrobot/daotest/query/LazyListTest.java
diff --git a/DaoTest/src/de/greenrobot/daotest/query/QueryBuilderAndOrTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/query/QueryBuilderAndOrTest.java
similarity index 100%
rename from DaoTest/src/de/greenrobot/daotest/query/QueryBuilderAndOrTest.java
rename to DaoTest/src/androidTest/java/de/greenrobot/daotest/query/QueryBuilderAndOrTest.java
diff --git a/DaoTest/src/de/greenrobot/daotest/query/QueryBuilderOrderTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/query/QueryBuilderOrderTest.java
similarity index 100%
rename from DaoTest/src/de/greenrobot/daotest/query/QueryBuilderOrderTest.java
rename to DaoTest/src/androidTest/java/de/greenrobot/daotest/query/QueryBuilderOrderTest.java
diff --git a/DaoTest/src/de/greenrobot/daotest/query/QueryBuilderSimpleTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/query/QueryBuilderSimpleTest.java
similarity index 83%
rename from DaoTest/src/de/greenrobot/daotest/query/QueryBuilderSimpleTest.java
rename to DaoTest/src/androidTest/java/de/greenrobot/daotest/query/QueryBuilderSimpleTest.java
index 93106d13..221a80bd 100644
--- a/DaoTest/src/de/greenrobot/daotest/query/QueryBuilderSimpleTest.java
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/query/QueryBuilderSimpleTest.java
@@ -21,10 +21,11 @@
 import java.util.Date;
 import java.util.List;
 
+import de.greenrobot.dao.internal.SqlUtils;
 import de.greenrobot.dao.query.Query;
 import de.greenrobot.dao.query.QueryBuilder;
+import de.greenrobot.dao.query.WhereCondition;
 import de.greenrobot.daotest.TestEntity;
-import de.greenrobot.daotest.TestEntityDao;
 import de.greenrobot.daotest.TestEntityDao.Properties;
 import de.greenrobot.daotest.entity.TestEntityTestBase;
 
@@ -171,6 +172,31 @@ public void testEqBoolean() {
         assertEquals(testEntity.getId(), testEntity2.getId());
     }
 
+    // TODO fix byte arrays? Android is doing String args everywhere
+    public void testEqByteArray() {
+        ArrayList<TestEntity> inserted = insert(3);
+        TestEntity testEntity = inserted.get(1);
+
+        byte[] byteArray = {96, 77, 37, -21};
+        testEntity.setSimpleByteArray(byteArray);
+        dao.update(testEntity);
+
+        // Unsupported: Query<TestEntity> query = dao.queryBuilder().where(Properties.SimpleByteArray.eq(byteArray)).build();
+
+        // Works, but probably voids any index on BLOBs (Note: there's no hex2blob function and X'?' is bad syntax):
+        // String conditionString = "HEX(" + Properties.SimpleByteArray.columnName + ")=?";
+        // WhereCondition condition = new WhereCondition.StringCondition(conditionString, SqlUtils.toHex(byteArray));
+
+        String conditionString = Properties.SimpleByteArray.columnName + '=' + SqlUtils.escapeBlobArgument(byteArray);
+        WhereCondition condition = new WhereCondition.StringCondition(conditionString);
+        Query<TestEntity> query = dao.queryBuilder().where(condition).build();
+        TestEntity testEntity2 = query.uniqueOrThrow();
+        assertEquals(testEntity.getId(), testEntity2.getId());
+
+        // Unsupported: query.setParameter(0, new byte[]{96, 77, 37, -21, 99});
+        // Unsupported: assertNull(query.unique());
+    }
+
     public void testIsNullIsNotNull() {
         ArrayList<TestEntity> inserted = insert(2);
         TestEntity testEntityNull = inserted.get(0);
@@ -210,18 +236,28 @@ public void testLike() {
         Query<TestEntity> query = dao.queryBuilder().where(Properties.SimpleString.like("%robot")).build();
         TestEntity entity2 = query.uniqueOrThrow();
         assertEquals(entity.getId(), entity2.getId());
-        
+
         query.setParameter(0, "green%");
         entity2 = query.uniqueOrThrow();
         assertEquals(entity.getId(), entity2.getId());
-        
+
         query.setParameter(0, "%enrob%");
         entity2 = query.uniqueOrThrow();
         assertEquals(entity.getId(), entity2.getId());
-        
+
         query.setParameter(0, "%nothere%");
         entity2 = query.unique();
         assertNull(entity2);
     }
 
+    public void testDistinct() {
+        TestEntity entity = insert(3).get(1);
+
+        Query<TestEntity> query = dao.queryBuilder().distinct()
+                .where(Properties.SimpleString.eq(entity.getSimpleString())).build();
+        TestEntity entity2 = query.uniqueOrThrow();
+        assertEquals(entity.getId(), entity2.getId());
+        // TODO improve test to check functionality
+    }
+
 }
diff --git a/DaoTest/src/de/greenrobot/daotest/query/QueryForThreadTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/query/QueryForThreadTest.java
similarity index 100%
rename from DaoTest/src/de/greenrobot/daotest/query/QueryForThreadTest.java
rename to DaoTest/src/androidTest/java/de/greenrobot/daotest/query/QueryForThreadTest.java
diff --git a/DaoTest/src/de/greenrobot/daotest/query/QueryLimitOffsetTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/query/QueryLimitOffsetTest.java
similarity index 100%
rename from DaoTest/src/de/greenrobot/daotest/query/QueryLimitOffsetTest.java
rename to DaoTest/src/androidTest/java/de/greenrobot/daotest/query/QueryLimitOffsetTest.java
diff --git a/DaoTest/src/de/greenrobot/daotest/query/QuerySpecialNamesTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/query/QuerySpecialNamesTest.java
similarity index 100%
rename from DaoTest/src/de/greenrobot/daotest/query/QuerySpecialNamesTest.java
rename to DaoTest/src/androidTest/java/de/greenrobot/daotest/query/QuerySpecialNamesTest.java
diff --git a/DaoTest/src/de/greenrobot/daotest/query/RawQueryTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/query/RawQueryTest.java
similarity index 100%
rename from DaoTest/src/de/greenrobot/daotest/query/RawQueryTest.java
rename to DaoTest/src/androidTest/java/de/greenrobot/daotest/query/RawQueryTest.java
diff --git a/DaoTest/src/de/greenrobot/daotest2/entity/KeepEntityTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest2/entity/KeepEntityTest.java
similarity index 100%
rename from DaoTest/src/de/greenrobot/daotest2/entity/KeepEntityTest.java
rename to DaoTest/src/androidTest/java/de/greenrobot/daotest2/entity/KeepEntityTest.java
diff --git a/DaoTest/AndroidManifest.xml b/DaoTest/src/main/AndroidManifest.xml
similarity index 100%
rename from DaoTest/AndroidManifest.xml
rename to DaoTest/src/main/AndroidManifest.xml
diff --git a/DaoTest/assets/minimal-entity.sql b/DaoTest/src/main/assets/minimal-entity.sql
similarity index 100%
rename from DaoTest/assets/minimal-entity.sql
rename to DaoTest/src/main/assets/minimal-entity.sql
diff --git a/DaoTest/src/test/java/de/greenrobot/dao/unittest/DaoMaster.java b/DaoTest/src/test/java/de/greenrobot/dao/unittest/DaoMaster.java
new file mode 100644
index 00000000..45473f60
--- /dev/null
+++ b/DaoTest/src/test/java/de/greenrobot/dao/unittest/DaoMaster.java
@@ -0,0 +1,70 @@
+package de.greenrobot.dao.unittest;
+
+import android.content.Context;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteDatabase.CursorFactory;
+import android.database.sqlite.SQLiteOpenHelper;
+import android.util.Log;
+import de.greenrobot.dao.AbstractDaoMaster;
+import de.greenrobot.dao.identityscope.IdentityScopeType;
+
+import de.greenrobot.dao.unittest.MinimalEntityDao;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+/** 
+ * Master of DAO (schema version 1): knows all DAOs.
+*/
+public class DaoMaster extends AbstractDaoMaster {
+    public static final int SCHEMA_VERSION = 1;
+
+    /** Creates underlying database table using DAOs. */
+    public static void createAllTables(SQLiteDatabase db, boolean ifNotExists) {
+        MinimalEntityDao.createTable(db, ifNotExists);
+    }
+    
+    /** Drops underlying database table using DAOs. */
+    public static void dropAllTables(SQLiteDatabase db, boolean ifExists) {
+        MinimalEntityDao.dropTable(db, ifExists);
+    }
+    
+    public static abstract class OpenHelper extends SQLiteOpenHelper {
+
+        public OpenHelper(Context context, String name, CursorFactory factory) {
+            super(context, name, factory, SCHEMA_VERSION);
+        }
+
+        @Override
+        public void onCreate(SQLiteDatabase db) {
+            Log.i("greenDAO", "Creating tables for schema version " + SCHEMA_VERSION);
+            createAllTables(db, false);
+        }
+    }
+    
+    /** WARNING: Drops all table on Upgrade! Use only during development. */
+    public static class DevOpenHelper extends OpenHelper {
+        public DevOpenHelper(Context context, String name, CursorFactory factory) {
+            super(context, name, factory);
+        }
+
+        @Override
+        public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+            Log.i("greenDAO", "Upgrading schema from version " + oldVersion + " to " + newVersion + " by dropping all tables");
+            dropAllTables(db, true);
+            onCreate(db);
+        }
+    }
+
+    public DaoMaster(SQLiteDatabase db) {
+        super(db, SCHEMA_VERSION);
+        registerDaoClass(MinimalEntityDao.class);
+    }
+    
+    public DaoSession newSession() {
+        return new DaoSession(db, IdentityScopeType.Session, daoConfigMap);
+    }
+    
+    public DaoSession newSession(IdentityScopeType type) {
+        return new DaoSession(db, type, daoConfigMap);
+    }
+    
+}
diff --git a/DaoTest/src/test/java/de/greenrobot/dao/unittest/DaoSession.java b/DaoTest/src/test/java/de/greenrobot/dao/unittest/DaoSession.java
new file mode 100644
index 00000000..53dabbcb
--- /dev/null
+++ b/DaoTest/src/test/java/de/greenrobot/dao/unittest/DaoSession.java
@@ -0,0 +1,49 @@
+package de.greenrobot.dao.unittest;
+
+import android.database.sqlite.SQLiteDatabase;
+
+import java.util.Map;
+
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.AbstractDaoSession;
+import de.greenrobot.dao.identityscope.IdentityScopeType;
+import de.greenrobot.dao.internal.DaoConfig;
+
+import de.greenrobot.dao.unittest.MinimalEntity;
+
+import de.greenrobot.dao.unittest.MinimalEntityDao;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+
+/**
+ * {@inheritDoc}
+ * 
+ * @see de.greenrobot.dao.AbstractDaoSession
+ */
+public class DaoSession extends AbstractDaoSession {
+
+    private final DaoConfig minimalEntityDaoConfig;
+
+    private final MinimalEntityDao minimalEntityDao;
+
+    public DaoSession(SQLiteDatabase db, IdentityScopeType type, Map<Class<? extends AbstractDao<?, ?>>, DaoConfig>
+            daoConfigMap) {
+        super(db);
+
+        minimalEntityDaoConfig = daoConfigMap.get(MinimalEntityDao.class).clone();
+        minimalEntityDaoConfig.initIdentityScope(type);
+
+        minimalEntityDao = new MinimalEntityDao(minimalEntityDaoConfig, this);
+
+        registerDao(MinimalEntity.class, minimalEntityDao);
+    }
+    
+    public void clear() {
+        minimalEntityDaoConfig.getIdentityScope().clear();
+    }
+
+    public MinimalEntityDao getMinimalEntityDao() {
+        return minimalEntityDao;
+    }
+
+}
diff --git a/DaoTest/src/test/java/de/greenrobot/dao/unittest/MinimalEntity.java b/DaoTest/src/test/java/de/greenrobot/dao/unittest/MinimalEntity.java
new file mode 100644
index 00000000..7e44d860
--- /dev/null
+++ b/DaoTest/src/test/java/de/greenrobot/dao/unittest/MinimalEntity.java
@@ -0,0 +1,26 @@
+package de.greenrobot.dao.unittest;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
+/**
+ * Entity mapped to table "MINIMAL_ENTITY".
+ */
+public class MinimalEntity {
+
+    private Long id;
+
+    public MinimalEntity() {
+    }
+
+    public MinimalEntity(Long id) {
+        this.id = id;
+    }
+
+    public Long getId() {
+        return id;
+    }
+
+    public void setId(Long id) {
+        this.id = id;
+    }
+
+}
diff --git a/DaoTest/src/test/java/de/greenrobot/dao/unittest/MinimalEntityDao.java b/DaoTest/src/test/java/de/greenrobot/dao/unittest/MinimalEntityDao.java
new file mode 100644
index 00000000..530442c5
--- /dev/null
+++ b/DaoTest/src/test/java/de/greenrobot/dao/unittest/MinimalEntityDao.java
@@ -0,0 +1,106 @@
+package de.greenrobot.dao.unittest;
+
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteStatement;
+
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.Property;
+import de.greenrobot.dao.internal.DaoConfig;
+
+import de.greenrobot.dao.unittest.MinimalEntity;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+/** 
+ * DAO for table "MINIMAL_ENTITY".
+*/
+public class MinimalEntityDao extends AbstractDao<MinimalEntity, Long> {
+
+    public static final String TABLENAME = "MINIMAL_ENTITY";
+
+    /**
+     * Properties of entity MinimalEntity.<br/>
+     * Can be used for QueryBuilder and for referencing column names.
+    */
+    public static class Properties {
+        public final static Property Id = new Property(0, Long.class, "id", true, "_id");
+    };
+
+
+    public MinimalEntityDao(DaoConfig config) {
+        super(config);
+    }
+    
+    public MinimalEntityDao(DaoConfig config, DaoSession daoSession) {
+        super(config, daoSession);
+    }
+
+    /** Creates the underlying database table. */
+    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+        String constraint = ifNotExists? "IF NOT EXISTS ": "";
+        db.execSQL("CREATE TABLE " + constraint + "\"MINIMAL_ENTITY\" (" + //
+                "\"_id\" INTEGER PRIMARY KEY );"); // 0: id
+    }
+
+    /** Drops the underlying database table. */
+    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "\"MINIMAL_ENTITY\"";
+        db.execSQL(sql);
+    }
+
+    /** @inheritdoc */
+    @Override
+    protected void bindValues(SQLiteStatement stmt, MinimalEntity entity) {
+        stmt.clearBindings();
+ 
+        Long id = entity.getId();
+        if (id != null) {
+            stmt.bindLong(1, id);
+        }
+    }
+
+    /** @inheritdoc */
+    @Override
+    public Long readKey(Cursor cursor, int offset) {
+        return cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0);
+    }    
+
+    /** @inheritdoc */
+    @Override
+    public MinimalEntity readEntity(Cursor cursor, int offset) {
+        MinimalEntity entity = new MinimalEntity( //
+            cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0) // id
+        );
+        return entity;
+    }
+     
+    /** @inheritdoc */
+    @Override
+    public void readEntity(Cursor cursor, MinimalEntity entity, int offset) {
+        entity.setId(cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0));
+     }
+    
+    /** @inheritdoc */
+    @Override
+    protected Long updateKeyAfterInsert(MinimalEntity entity, long rowId) {
+        entity.setId(rowId);
+        return rowId;
+    }
+    
+    /** @inheritdoc */
+    @Override
+    public Long getKey(MinimalEntity entity) {
+        if(entity != null) {
+            return entity.getId();
+        } else {
+            return null;
+        }
+    }
+
+    /** @inheritdoc */
+    @Override    
+    protected boolean isEntityUpdateable() {
+        return true;
+    }
+    
+}
diff --git a/DaoTest/src/test/java/de/greenrobot/dao/unittest/MinimalEntityTest.java b/DaoTest/src/test/java/de/greenrobot/dao/unittest/MinimalEntityTest.java
new file mode 100644
index 00000000..702ba039
--- /dev/null
+++ b/DaoTest/src/test/java/de/greenrobot/dao/unittest/MinimalEntityTest.java
@@ -0,0 +1,71 @@
+package de.greenrobot.dao.unittest;
+
+import android.database.sqlite.SQLiteDatabase;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+import java.util.concurrent.CountDownLatch;
+
+import de.greenrobot.dao.query.Query;
+import de.greenrobot.daotest.dummyapp.BuildConfig;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = BuildConfig.class, sdk = 16)
+public class MinimalEntityTest {
+
+    private DaoSession daoSession;
+    private MinimalEntityDao minimalEntityDao;
+
+    @Before
+    public void setUp() {
+        DaoMaster.DevOpenHelper openHelper = new DaoMaster.DevOpenHelper(RuntimeEnvironment.application, null, null);
+        SQLiteDatabase db = openHelper.getWritableDatabase();
+        daoSession = new DaoMaster(db).newSession();
+        minimalEntityDao = daoSession.getMinimalEntityDao();
+    }
+
+    @Test
+    public void testBasics() {
+        MinimalEntity entity = new MinimalEntity();
+        daoSession.insert(entity);
+        assertNotNull(entity.getId());
+        assertNotNull(minimalEntityDao.load(entity.getId()));
+        assertEquals(1, minimalEntityDao.count());
+        assertEquals(1, daoSession.loadAll(MinimalEntity.class).size());
+
+        daoSession.update(entity);
+        daoSession.delete(entity);
+        assertNull(minimalEntityDao.load(entity.getId()));
+    }
+
+    @Test
+    // Testing the work around for Process.myTid() being always 0 in Robolectric
+    public void testQueryForCurrentThread() throws InterruptedException {
+        final CountDownLatch latch = new CountDownLatch(1);
+        final Query<MinimalEntity>[] queryHolder = new Query[1];
+        new Thread() {
+            @Override
+            public void run() {
+                try {
+                    queryHolder[0] = minimalEntityDao.queryBuilder().build();
+                    queryHolder[0].list();
+                } finally {
+                    latch.countDown();
+                }
+            }
+        }.start();
+        latch.await();
+        Query<MinimalEntity> query = queryHolder[0].forCurrentThread();
+        query.list();
+    }
+
+}
diff --git a/DaoTestBase/build.gradle b/DaoTestBase/build.gradle
new file mode 100644
index 00000000..162abe30
--- /dev/null
+++ b/DaoTestBase/build.gradle
@@ -0,0 +1,9 @@
+apply plugin: 'java'
+
+sourceCompatibility = 1.7
+targetCompatibility = 1.7
+
+dependencies {
+    compile project(':DaoCore')
+    compileOnly 'com.google.android:android:4.1.1.4'
+}
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/AbcdefEntity.java b/DaoTestBase/src/main/java/de/greenrobot/daotest/AbcdefEntity.java
similarity index 100%
rename from DaoTest/src-gen/de/greenrobot/daotest/AbcdefEntity.java
rename to DaoTestBase/src/main/java/de/greenrobot/daotest/AbcdefEntity.java
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/AbcdefEntityDao.java b/DaoTestBase/src/main/java/de/greenrobot/daotest/AbcdefEntityDao.java
similarity index 100%
rename from DaoTest/src-gen/de/greenrobot/daotest/AbcdefEntityDao.java
rename to DaoTestBase/src/main/java/de/greenrobot/daotest/AbcdefEntityDao.java
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/AnActiveEntity.java b/DaoTestBase/src/main/java/de/greenrobot/daotest/AnActiveEntity.java
similarity index 100%
rename from DaoTest/src-gen/de/greenrobot/daotest/AnActiveEntity.java
rename to DaoTestBase/src/main/java/de/greenrobot/daotest/AnActiveEntity.java
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/AnActiveEntityDao.java b/DaoTestBase/src/main/java/de/greenrobot/daotest/AnActiveEntityDao.java
similarity index 100%
rename from DaoTest/src-gen/de/greenrobot/daotest/AnActiveEntityDao.java
rename to DaoTestBase/src/main/java/de/greenrobot/daotest/AnActiveEntityDao.java
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/AutoincrementEntity.java b/DaoTestBase/src/main/java/de/greenrobot/daotest/AutoincrementEntity.java
similarity index 100%
rename from DaoTest/src-gen/de/greenrobot/daotest/AutoincrementEntity.java
rename to DaoTestBase/src/main/java/de/greenrobot/daotest/AutoincrementEntity.java
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/AutoincrementEntityDao.java b/DaoTestBase/src/main/java/de/greenrobot/daotest/AutoincrementEntityDao.java
similarity index 100%
rename from DaoTest/src-gen/de/greenrobot/daotest/AutoincrementEntityDao.java
rename to DaoTestBase/src/main/java/de/greenrobot/daotest/AutoincrementEntityDao.java
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/CustomTypeEntity.java b/DaoTestBase/src/main/java/de/greenrobot/daotest/CustomTypeEntity.java
similarity index 100%
rename from DaoTest/src-gen/de/greenrobot/daotest/CustomTypeEntity.java
rename to DaoTestBase/src/main/java/de/greenrobot/daotest/CustomTypeEntity.java
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/CustomTypeEntityDao.java b/DaoTestBase/src/main/java/de/greenrobot/daotest/CustomTypeEntityDao.java
similarity index 100%
rename from DaoTest/src-gen/de/greenrobot/daotest/CustomTypeEntityDao.java
rename to DaoTestBase/src/main/java/de/greenrobot/daotest/CustomTypeEntityDao.java
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/DaoMaster.java b/DaoTestBase/src/main/java/de/greenrobot/daotest/DaoMaster.java
similarity index 96%
rename from DaoTest/src-gen/de/greenrobot/daotest/DaoMaster.java
rename to DaoTestBase/src/main/java/de/greenrobot/daotest/DaoMaster.java
index 9df78105..9a9bfdc6 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/DaoMaster.java
+++ b/DaoTestBase/src/main/java/de/greenrobot/daotest/DaoMaster.java
@@ -25,6 +25,7 @@
 import de.greenrobot.daotest.AutoincrementEntityDao;
 import de.greenrobot.daotest.SqliteMasterDao;
 import de.greenrobot.daotest.CustomTypeEntityDao;
+import de.greenrobot.daotest.IndexedStringEntityDao;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
@@ -51,6 +52,7 @@ public static void createAllTables(SQLiteDatabase db, boolean ifNotExists) {
         StringKeyValueEntityDao.createTable(db, ifNotExists);
         AutoincrementEntityDao.createTable(db, ifNotExists);
         CustomTypeEntityDao.createTable(db, ifNotExists);
+        IndexedStringEntityDao.createTable(db, ifNotExists);
     }
     
     /** Drops underlying database table using DAOs. */
@@ -71,6 +73,7 @@ public static void dropAllTables(SQLiteDatabase db, boolean ifExists) {
         StringKeyValueEntityDao.dropTable(db, ifExists);
         AutoincrementEntityDao.dropTable(db, ifExists);
         CustomTypeEntityDao.dropTable(db, ifExists);
+        IndexedStringEntityDao.dropTable(db, ifExists);
     }
     
     public static abstract class OpenHelper extends SQLiteOpenHelper {
@@ -119,6 +122,7 @@ public DaoMaster(SQLiteDatabase db) {
         registerDaoClass(AutoincrementEntityDao.class);
         registerDaoClass(SqliteMasterDao.class);
         registerDaoClass(CustomTypeEntityDao.class);
+        registerDaoClass(IndexedStringEntityDao.class);
     }
     
     public DaoSession newSession() {
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/DaoSession.java b/DaoTestBase/src/main/java/de/greenrobot/daotest/DaoSession.java
similarity index 94%
rename from DaoTest/src-gen/de/greenrobot/daotest/DaoSession.java
rename to DaoTestBase/src/main/java/de/greenrobot/daotest/DaoSession.java
index 951c4b6e..0e608cb9 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/DaoSession.java
+++ b/DaoTestBase/src/main/java/de/greenrobot/daotest/DaoSession.java
@@ -26,6 +26,7 @@
 import de.greenrobot.daotest.AutoincrementEntity;
 import de.greenrobot.daotest.SqliteMaster;
 import de.greenrobot.daotest.CustomTypeEntity;
+import de.greenrobot.daotest.IndexedStringEntity;
 
 import de.greenrobot.daotest.SimpleEntityDao;
 import de.greenrobot.daotest.SimpleEntityNotNullDao;
@@ -44,6 +45,7 @@
 import de.greenrobot.daotest.AutoincrementEntityDao;
 import de.greenrobot.daotest.SqliteMasterDao;
 import de.greenrobot.daotest.CustomTypeEntityDao;
+import de.greenrobot.daotest.IndexedStringEntityDao;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 
@@ -71,6 +73,7 @@
     private final DaoConfig autoincrementEntityDaoConfig;
     private final DaoConfig sqliteMasterDaoConfig;
     private final DaoConfig customTypeEntityDaoConfig;
+    private final DaoConfig indexedStringEntityDaoConfig;
 
     private final SimpleEntityDao simpleEntityDao;
     private final SimpleEntityNotNullDao simpleEntityNotNullDao;
@@ -89,6 +92,7 @@
     private final AutoincrementEntityDao autoincrementEntityDao;
     private final SqliteMasterDao sqliteMasterDao;
     private final CustomTypeEntityDao customTypeEntityDao;
+    private final IndexedStringEntityDao indexedStringEntityDao;
 
     public DaoSession(SQLiteDatabase db, IdentityScopeType type, Map<Class<? extends AbstractDao<?, ?>>, DaoConfig>
             daoConfigMap) {
@@ -145,6 +149,9 @@ public DaoSession(SQLiteDatabase db, IdentityScopeType type, Map<Class<? extends
         customTypeEntityDaoConfig = daoConfigMap.get(CustomTypeEntityDao.class).clone();
         customTypeEntityDaoConfig.initIdentityScope(type);
 
+        indexedStringEntityDaoConfig = daoConfigMap.get(IndexedStringEntityDao.class).clone();
+        indexedStringEntityDaoConfig.initIdentityScope(type);
+
         simpleEntityDao = new SimpleEntityDao(simpleEntityDaoConfig, this);
         simpleEntityNotNullDao = new SimpleEntityNotNullDao(simpleEntityNotNullDaoConfig, this);
         testEntityDao = new TestEntityDao(testEntityDaoConfig, this);
@@ -162,6 +169,7 @@ public DaoSession(SQLiteDatabase db, IdentityScopeType type, Map<Class<? extends
         autoincrementEntityDao = new AutoincrementEntityDao(autoincrementEntityDaoConfig, this);
         sqliteMasterDao = new SqliteMasterDao(sqliteMasterDaoConfig, this);
         customTypeEntityDao = new CustomTypeEntityDao(customTypeEntityDaoConfig, this);
+        indexedStringEntityDao = new IndexedStringEntityDao(indexedStringEntityDaoConfig, this);
 
         registerDao(SimpleEntity.class, simpleEntityDao);
         registerDao(SimpleEntityNotNull.class, simpleEntityNotNullDao);
@@ -180,6 +188,7 @@ public DaoSession(SQLiteDatabase db, IdentityScopeType type, Map<Class<? extends
         registerDao(AutoincrementEntity.class, autoincrementEntityDao);
         registerDao(SqliteMaster.class, sqliteMasterDao);
         registerDao(CustomTypeEntity.class, customTypeEntityDao);
+        registerDao(IndexedStringEntity.class, indexedStringEntityDao);
     }
     
     public void clear() {
@@ -200,6 +209,7 @@ public void clear() {
         autoincrementEntityDaoConfig.getIdentityScope().clear();
         sqliteMasterDaoConfig.getIdentityScope().clear();
         customTypeEntityDaoConfig.getIdentityScope().clear();
+        indexedStringEntityDaoConfig.getIdentityScope().clear();
     }
 
     public SimpleEntityDao getSimpleEntityDao() {
@@ -270,4 +280,8 @@ public CustomTypeEntityDao getCustomTypeEntityDao() {
         return customTypeEntityDao;
     }
 
+    public IndexedStringEntityDao getIndexedStringEntityDao() {
+        return indexedStringEntityDao;
+    }
+
 }
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/DateEntity.java b/DaoTestBase/src/main/java/de/greenrobot/daotest/DateEntity.java
similarity index 98%
rename from DaoTest/src-gen/de/greenrobot/daotest/DateEntity.java
rename to DaoTestBase/src/main/java/de/greenrobot/daotest/DateEntity.java
index 850b2c75..7b8f305a 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/DateEntity.java
+++ b/DaoTestBase/src/main/java/de/greenrobot/daotest/DateEntity.java
@@ -43,7 +43,7 @@ public void setId(Long id) {
     }
 
     // Test code for
-    // getter
+    // setter
     public void setDate(java.util.Date date) {
         this.date = date;
     }
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/DateEntityDao.java b/DaoTestBase/src/main/java/de/greenrobot/daotest/DateEntityDao.java
similarity index 100%
rename from DaoTest/src-gen/de/greenrobot/daotest/DateEntityDao.java
rename to DaoTestBase/src/main/java/de/greenrobot/daotest/DateEntityDao.java
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/ExtendsImplementsEntity.java b/DaoTestBase/src/main/java/de/greenrobot/daotest/ExtendsImplementsEntity.java
similarity index 100%
rename from DaoTest/src-gen/de/greenrobot/daotest/ExtendsImplementsEntity.java
rename to DaoTestBase/src/main/java/de/greenrobot/daotest/ExtendsImplementsEntity.java
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/ExtendsImplementsEntityDao.java b/DaoTestBase/src/main/java/de/greenrobot/daotest/ExtendsImplementsEntityDao.java
similarity index 100%
rename from DaoTest/src-gen/de/greenrobot/daotest/ExtendsImplementsEntityDao.java
rename to DaoTestBase/src/main/java/de/greenrobot/daotest/ExtendsImplementsEntityDao.java
diff --git a/DaoTestBase/src/main/java/de/greenrobot/daotest/IndexedStringEntity.java b/DaoTestBase/src/main/java/de/greenrobot/daotest/IndexedStringEntity.java
new file mode 100644
index 00000000..7aeb7cde
--- /dev/null
+++ b/DaoTestBase/src/main/java/de/greenrobot/daotest/IndexedStringEntity.java
@@ -0,0 +1,40 @@
+package de.greenrobot.daotest;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
+/**
+ * Entity mapped to table "INDEXED_STRING_ENTITY".
+ */
+public class IndexedStringEntity {
+
+    private Long id;
+    private String indexedString;
+
+    public IndexedStringEntity() {
+    }
+
+    public IndexedStringEntity(Long id) {
+        this.id = id;
+    }
+
+    public IndexedStringEntity(Long id, String indexedString) {
+        this.id = id;
+        this.indexedString = indexedString;
+    }
+
+    public Long getId() {
+        return id;
+    }
+
+    public void setId(Long id) {
+        this.id = id;
+    }
+
+    public String getIndexedString() {
+        return indexedString;
+    }
+
+    public void setIndexedString(String indexedString) {
+        this.indexedString = indexedString;
+    }
+
+}
diff --git a/DaoTestBase/src/main/java/de/greenrobot/daotest/IndexedStringEntityDao.java b/DaoTestBase/src/main/java/de/greenrobot/daotest/IndexedStringEntityDao.java
new file mode 100644
index 00000000..3724a9af
--- /dev/null
+++ b/DaoTestBase/src/main/java/de/greenrobot/daotest/IndexedStringEntityDao.java
@@ -0,0 +1,118 @@
+package de.greenrobot.daotest;
+
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteStatement;
+
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.Property;
+import de.greenrobot.dao.internal.DaoConfig;
+
+import de.greenrobot.daotest.IndexedStringEntity;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+/** 
+ * DAO for table "INDEXED_STRING_ENTITY".
+*/
+public class IndexedStringEntityDao extends AbstractDao<IndexedStringEntity, Long> {
+
+    public static final String TABLENAME = "INDEXED_STRING_ENTITY";
+
+    /**
+     * Properties of entity IndexedStringEntity.<br/>
+     * Can be used for QueryBuilder and for referencing column names.
+    */
+    public static class Properties {
+        public final static Property Id = new Property(0, Long.class, "id", true, "_id");
+        public final static Property IndexedString = new Property(1, String.class, "indexedString", false, "INDEXED_STRING");
+    };
+
+
+    public IndexedStringEntityDao(DaoConfig config) {
+        super(config);
+    }
+    
+    public IndexedStringEntityDao(DaoConfig config, DaoSession daoSession) {
+        super(config, daoSession);
+    }
+
+    /** Creates the underlying database table. */
+    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+        String constraint = ifNotExists? "IF NOT EXISTS ": "";
+        db.execSQL("CREATE TABLE " + constraint + "\"INDEXED_STRING_ENTITY\" (" + //
+                "\"_id\" INTEGER PRIMARY KEY ," + // 0: id
+                "\"INDEXED_STRING\" TEXT);"); // 1: indexedString
+        // Add Indexes
+        db.execSQL("CREATE INDEX " + constraint + "IDX_INDEXED_STRING_ENTITY_INDEXED_STRING ON INDEXED_STRING_ENTITY" +
+                " (\"INDEXED_STRING\");");
+    }
+
+    /** Drops the underlying database table. */
+    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "\"INDEXED_STRING_ENTITY\"";
+        db.execSQL(sql);
+    }
+
+    /** @inheritdoc */
+    @Override
+    protected void bindValues(SQLiteStatement stmt, IndexedStringEntity entity) {
+        stmt.clearBindings();
+ 
+        Long id = entity.getId();
+        if (id != null) {
+            stmt.bindLong(1, id);
+        }
+ 
+        String indexedString = entity.getIndexedString();
+        if (indexedString != null) {
+            stmt.bindString(2, indexedString);
+        }
+    }
+
+    /** @inheritdoc */
+    @Override
+    public Long readKey(Cursor cursor, int offset) {
+        return cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0);
+    }    
+
+    /** @inheritdoc */
+    @Override
+    public IndexedStringEntity readEntity(Cursor cursor, int offset) {
+        IndexedStringEntity entity = new IndexedStringEntity( //
+            cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0), // id
+            cursor.isNull(offset + 1) ? null : cursor.getString(offset + 1) // indexedString
+        );
+        return entity;
+    }
+     
+    /** @inheritdoc */
+    @Override
+    public void readEntity(Cursor cursor, IndexedStringEntity entity, int offset) {
+        entity.setId(cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0));
+        entity.setIndexedString(cursor.isNull(offset + 1) ? null : cursor.getString(offset + 1));
+     }
+    
+    /** @inheritdoc */
+    @Override
+    protected Long updateKeyAfterInsert(IndexedStringEntity entity, long rowId) {
+        entity.setId(rowId);
+        return rowId;
+    }
+    
+    /** @inheritdoc */
+    @Override
+    public Long getKey(IndexedStringEntity entity) {
+        if(entity != null) {
+            return entity.getId();
+        } else {
+            return null;
+        }
+    }
+
+    /** @inheritdoc */
+    @Override    
+    protected boolean isEntityUpdateable() {
+        return true;
+    }
+    
+}
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/JoinManyToDateEntity.java b/DaoTestBase/src/main/java/de/greenrobot/daotest/JoinManyToDateEntity.java
similarity index 100%
rename from DaoTest/src-gen/de/greenrobot/daotest/JoinManyToDateEntity.java
rename to DaoTestBase/src/main/java/de/greenrobot/daotest/JoinManyToDateEntity.java
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/JoinManyToDateEntityDao.java b/DaoTestBase/src/main/java/de/greenrobot/daotest/JoinManyToDateEntityDao.java
similarity index 100%
rename from DaoTest/src-gen/de/greenrobot/daotest/JoinManyToDateEntityDao.java
rename to DaoTestBase/src/main/java/de/greenrobot/daotest/JoinManyToDateEntityDao.java
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/RelationEntity.java b/DaoTestBase/src/main/java/de/greenrobot/daotest/RelationEntity.java
similarity index 100%
rename from DaoTest/src-gen/de/greenrobot/daotest/RelationEntity.java
rename to DaoTestBase/src/main/java/de/greenrobot/daotest/RelationEntity.java
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/RelationEntityDao.java b/DaoTestBase/src/main/java/de/greenrobot/daotest/RelationEntityDao.java
similarity index 100%
rename from DaoTest/src-gen/de/greenrobot/daotest/RelationEntityDao.java
rename to DaoTestBase/src/main/java/de/greenrobot/daotest/RelationEntityDao.java
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntity.java b/DaoTestBase/src/main/java/de/greenrobot/daotest/SimpleEntity.java
similarity index 100%
rename from DaoTest/src-gen/de/greenrobot/daotest/SimpleEntity.java
rename to DaoTestBase/src/main/java/de/greenrobot/daotest/SimpleEntity.java
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntityContentProvider.java b/DaoTestBase/src/main/java/de/greenrobot/daotest/SimpleEntityContentProvider.java
similarity index 100%
rename from DaoTest/src-gen/de/greenrobot/daotest/SimpleEntityContentProvider.java
rename to DaoTestBase/src/main/java/de/greenrobot/daotest/SimpleEntityContentProvider.java
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntityDao.java b/DaoTestBase/src/main/java/de/greenrobot/daotest/SimpleEntityDao.java
similarity index 100%
rename from DaoTest/src-gen/de/greenrobot/daotest/SimpleEntityDao.java
rename to DaoTestBase/src/main/java/de/greenrobot/daotest/SimpleEntityDao.java
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntityNotNull.java b/DaoTestBase/src/main/java/de/greenrobot/daotest/SimpleEntityNotNull.java
similarity index 100%
rename from DaoTest/src-gen/de/greenrobot/daotest/SimpleEntityNotNull.java
rename to DaoTestBase/src/main/java/de/greenrobot/daotest/SimpleEntityNotNull.java
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntityNotNullDao.java b/DaoTestBase/src/main/java/de/greenrobot/daotest/SimpleEntityNotNullDao.java
similarity index 100%
rename from DaoTest/src-gen/de/greenrobot/daotest/SimpleEntityNotNullDao.java
rename to DaoTestBase/src/main/java/de/greenrobot/daotest/SimpleEntityNotNullDao.java
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/SpecialNamesEntity.java b/DaoTestBase/src/main/java/de/greenrobot/daotest/SpecialNamesEntity.java
similarity index 100%
rename from DaoTest/src-gen/de/greenrobot/daotest/SpecialNamesEntity.java
rename to DaoTestBase/src/main/java/de/greenrobot/daotest/SpecialNamesEntity.java
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/SpecialNamesEntityDao.java b/DaoTestBase/src/main/java/de/greenrobot/daotest/SpecialNamesEntityDao.java
similarity index 100%
rename from DaoTest/src-gen/de/greenrobot/daotest/SpecialNamesEntityDao.java
rename to DaoTestBase/src/main/java/de/greenrobot/daotest/SpecialNamesEntityDao.java
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/SqliteMaster.java b/DaoTestBase/src/main/java/de/greenrobot/daotest/SqliteMaster.java
similarity index 100%
rename from DaoTest/src-gen/de/greenrobot/daotest/SqliteMaster.java
rename to DaoTestBase/src/main/java/de/greenrobot/daotest/SqliteMaster.java
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/SqliteMasterDao.java b/DaoTestBase/src/main/java/de/greenrobot/daotest/SqliteMasterDao.java
similarity index 100%
rename from DaoTest/src-gen/de/greenrobot/daotest/SqliteMasterDao.java
rename to DaoTestBase/src/main/java/de/greenrobot/daotest/SqliteMasterDao.java
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/StringKeyValueEntity.java b/DaoTestBase/src/main/java/de/greenrobot/daotest/StringKeyValueEntity.java
similarity index 100%
rename from DaoTest/src-gen/de/greenrobot/daotest/StringKeyValueEntity.java
rename to DaoTestBase/src/main/java/de/greenrobot/daotest/StringKeyValueEntity.java
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/StringKeyValueEntityDao.java b/DaoTestBase/src/main/java/de/greenrobot/daotest/StringKeyValueEntityDao.java
similarity index 100%
rename from DaoTest/src-gen/de/greenrobot/daotest/StringKeyValueEntityDao.java
rename to DaoTestBase/src/main/java/de/greenrobot/daotest/StringKeyValueEntityDao.java
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/TestEntity.java b/DaoTestBase/src/main/java/de/greenrobot/daotest/TestEntity.java
similarity index 79%
rename from DaoTest/src-gen/de/greenrobot/daotest/TestEntity.java
rename to DaoTestBase/src/main/java/de/greenrobot/daotest/TestEntity.java
index 5e7688d0..15863049 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/TestEntity.java
+++ b/DaoTestBase/src/main/java/de/greenrobot/daotest/TestEntity.java
@@ -1,11 +1,17 @@
 package de.greenrobot.daotest;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
+
 /**
- * Entity mapped to table "TEST_ENTITY".
+ * This entity is used by internal tests of greenDAO.
+ * (This JavaDoc is defined in the generator project.)
  */
+// This is another test comment, you could also apply annotations like this
 public class TestEntity {
 
+    /**
+     * JavaDoc test field
+     */
     private Long id;
     private int simpleInt;
     private Integer simpleInteger;
@@ -16,6 +22,7 @@
     private String indexedStringAscUnique;
     private java.util.Date simpleDate;
     private Boolean simpleBoolean;
+    private byte[] simpleByteArray;
 
     public TestEntity() {
     }
@@ -24,7 +31,7 @@ public TestEntity(Long id) {
         this.id = id;
     }
 
-    public TestEntity(Long id, int simpleInt, Integer simpleInteger, String simpleStringNotNull, String simpleString, String indexedString, String indexedStringAscUnique, java.util.Date simpleDate, Boolean simpleBoolean) {
+    public TestEntity(Long id, int simpleInt, Integer simpleInteger, String simpleStringNotNull, String simpleString, String indexedString, String indexedStringAscUnique, java.util.Date simpleDate, Boolean simpleBoolean, byte[] simpleByteArray) {
         this.id = id;
         this.simpleInt = simpleInt;
         this.simpleInteger = simpleInteger;
@@ -34,6 +41,7 @@ public TestEntity(Long id, int simpleInt, Integer simpleInteger, String simpleSt
         this.indexedStringAscUnique = indexedStringAscUnique;
         this.simpleDate = simpleDate;
         this.simpleBoolean = simpleBoolean;
+        this.simpleByteArray = simpleByteArray;
     }
 
     public Long getId() {
@@ -44,6 +52,9 @@ public void setId(Long id) {
         this.id = id;
     }
 
+    /**
+     * JavaDoc test getter
+     */
     public int getSimpleInt() {
         return simpleInt;
     }
@@ -56,16 +67,25 @@ public Integer getSimpleInteger() {
         return simpleInteger;
     }
 
+    /**
+     * JavaDoc test setter
+     */
     public void setSimpleInteger(Integer simpleInteger) {
         this.simpleInteger = simpleInteger;
     }
 
     /** Not-null value. */
+    /**
+     * JavaDoc test getter and setter
+     */
     public String getSimpleStringNotNull() {
         return simpleStringNotNull;
     }
 
     /** Not-null value; ensure this value is available before it is saved to the database. */
+    /**
+     * JavaDoc test getter and setter
+     */
     public void setSimpleStringNotNull(String simpleStringNotNull) {
         this.simpleStringNotNull = simpleStringNotNull;
     }
@@ -110,4 +130,12 @@ public void setSimpleBoolean(Boolean simpleBoolean) {
         this.simpleBoolean = simpleBoolean;
     }
 
+    public byte[] getSimpleByteArray() {
+        return simpleByteArray;
+    }
+
+    public void setSimpleByteArray(byte[] simpleByteArray) {
+        this.simpleByteArray = simpleByteArray;
+    }
+
 }
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/TestEntityDao.java b/DaoTestBase/src/main/java/de/greenrobot/daotest/TestEntityDao.java
similarity index 91%
rename from DaoTest/src-gen/de/greenrobot/daotest/TestEntityDao.java
rename to DaoTestBase/src/main/java/de/greenrobot/daotest/TestEntityDao.java
index dd904651..5febaa8b 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/TestEntityDao.java
+++ b/DaoTestBase/src/main/java/de/greenrobot/daotest/TestEntityDao.java
@@ -32,6 +32,7 @@
         public final static Property IndexedStringAscUnique = new Property(6, String.class, "indexedStringAscUnique", false, "INDEXED_STRING_ASC_UNIQUE");
         public final static Property SimpleDate = new Property(7, java.util.Date.class, "simpleDate", false, "SIMPLE_DATE");
         public final static Property SimpleBoolean = new Property(8, Boolean.class, "simpleBoolean", false, "SIMPLE_BOOLEAN");
+        public final static Property SimpleByteArray = new Property(9, byte[].class, "simpleByteArray", false, "SIMPLE_BYTE_ARRAY");
     };
 
 
@@ -55,7 +56,8 @@ public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
                 "\"INDEXED_STRING\" TEXT," + // 5: indexedString
                 "\"INDEXED_STRING_ASC_UNIQUE\" TEXT," + // 6: indexedStringAscUnique
                 "\"SIMPLE_DATE\" INTEGER," + // 7: simpleDate
-                "\"SIMPLE_BOOLEAN\" INTEGER);"); // 8: simpleBoolean
+                "\"SIMPLE_BOOLEAN\" INTEGER," + // 8: simpleBoolean
+                "\"SIMPLE_BYTE_ARRAY\" BLOB);"); // 9: simpleByteArray
         // Add Indexes
         db.execSQL("CREATE INDEX " + constraint + "IDX_TEST_ENTITY_INDEXED_STRING ON TEST_ENTITY" +
                 " (\"INDEXED_STRING\");");
@@ -110,6 +112,11 @@ protected void bindValues(SQLiteStatement stmt, TestEntity entity) {
         if (simpleBoolean != null) {
             stmt.bindLong(9, simpleBoolean ? 1L: 0L);
         }
+ 
+        byte[] simpleByteArray = entity.getSimpleByteArray();
+        if (simpleByteArray != null) {
+            stmt.bindBlob(10, simpleByteArray);
+        }
     }
 
     /** @inheritdoc */
@@ -130,7 +137,8 @@ public TestEntity readEntity(Cursor cursor, int offset) {
             cursor.isNull(offset + 5) ? null : cursor.getString(offset + 5), // indexedString
             cursor.isNull(offset + 6) ? null : cursor.getString(offset + 6), // indexedStringAscUnique
             cursor.isNull(offset + 7) ? null : new java.util.Date(cursor.getLong(offset + 7)), // simpleDate
-            cursor.isNull(offset + 8) ? null : cursor.getShort(offset + 8) != 0 // simpleBoolean
+            cursor.isNull(offset + 8) ? null : cursor.getShort(offset + 8) != 0, // simpleBoolean
+            cursor.isNull(offset + 9) ? null : cursor.getBlob(offset + 9) // simpleByteArray
         );
         return entity;
     }
@@ -147,6 +155,7 @@ public void readEntity(Cursor cursor, TestEntity entity, int offset) {
         entity.setIndexedStringAscUnique(cursor.isNull(offset + 6) ? null : cursor.getString(offset + 6));
         entity.setSimpleDate(cursor.isNull(offset + 7) ? null : new java.util.Date(cursor.getLong(offset + 7)));
         entity.setSimpleBoolean(cursor.isNull(offset + 8) ? null : cursor.getShort(offset + 8) != 0);
+        entity.setSimpleByteArray(cursor.isNull(offset + 9) ? null : cursor.getBlob(offset + 9));
      }
     
     /** @inheritdoc */
diff --git a/DaoTest/src/de/greenrobot/daotest/TestInterface.java b/DaoTestBase/src/main/java/de/greenrobot/daotest/TestInterface.java
similarity index 100%
rename from DaoTest/src/de/greenrobot/daotest/TestInterface.java
rename to DaoTestBase/src/main/java/de/greenrobot/daotest/TestInterface.java
diff --git a/DaoTest/src/de/greenrobot/daotest/TestSuperclass.java b/DaoTestBase/src/main/java/de/greenrobot/daotest/TestSuperclass.java
similarity index 100%
rename from DaoTest/src/de/greenrobot/daotest/TestSuperclass.java
rename to DaoTestBase/src/main/java/de/greenrobot/daotest/TestSuperclass.java
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/ToManyEntity.java b/DaoTestBase/src/main/java/de/greenrobot/daotest/ToManyEntity.java
similarity index 100%
rename from DaoTest/src-gen/de/greenrobot/daotest/ToManyEntity.java
rename to DaoTestBase/src/main/java/de/greenrobot/daotest/ToManyEntity.java
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/ToManyEntityDao.java b/DaoTestBase/src/main/java/de/greenrobot/daotest/ToManyEntityDao.java
similarity index 100%
rename from DaoTest/src-gen/de/greenrobot/daotest/ToManyEntityDao.java
rename to DaoTestBase/src/main/java/de/greenrobot/daotest/ToManyEntityDao.java
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/ToManyTargetEntity.java b/DaoTestBase/src/main/java/de/greenrobot/daotest/ToManyTargetEntity.java
similarity index 100%
rename from DaoTest/src-gen/de/greenrobot/daotest/ToManyTargetEntity.java
rename to DaoTestBase/src/main/java/de/greenrobot/daotest/ToManyTargetEntity.java
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/ToManyTargetEntityDao.java b/DaoTestBase/src/main/java/de/greenrobot/daotest/ToManyTargetEntityDao.java
similarity index 100%
rename from DaoTest/src-gen/de/greenrobot/daotest/ToManyTargetEntityDao.java
rename to DaoTestBase/src/main/java/de/greenrobot/daotest/ToManyTargetEntityDao.java
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/TreeEntity.java b/DaoTestBase/src/main/java/de/greenrobot/daotest/TreeEntity.java
similarity index 100%
rename from DaoTest/src-gen/de/greenrobot/daotest/TreeEntity.java
rename to DaoTestBase/src/main/java/de/greenrobot/daotest/TreeEntity.java
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/TreeEntityDao.java b/DaoTestBase/src/main/java/de/greenrobot/daotest/TreeEntityDao.java
similarity index 100%
rename from DaoTest/src-gen/de/greenrobot/daotest/TreeEntityDao.java
rename to DaoTestBase/src/main/java/de/greenrobot/daotest/TreeEntityDao.java
diff --git a/DaoTest/src/de/greenrobot/daotest/customtype/IntegerListConverter.java b/DaoTestBase/src/main/java/de/greenrobot/daotest/customtype/IntegerListConverter.java
similarity index 100%
rename from DaoTest/src/de/greenrobot/daotest/customtype/IntegerListConverter.java
rename to DaoTestBase/src/main/java/de/greenrobot/daotest/customtype/IntegerListConverter.java
diff --git a/DaoTest/src/de/greenrobot/daotest/customtype/MyTimestamp.java b/DaoTestBase/src/main/java/de/greenrobot/daotest/customtype/MyTimestamp.java
similarity index 100%
rename from DaoTest/src/de/greenrobot/daotest/customtype/MyTimestamp.java
rename to DaoTestBase/src/main/java/de/greenrobot/daotest/customtype/MyTimestamp.java
diff --git a/DaoTest/src/de/greenrobot/daotest/customtype/MyTimestampConverter.java b/DaoTestBase/src/main/java/de/greenrobot/daotest/customtype/MyTimestampConverter.java
similarity index 100%
rename from DaoTest/src/de/greenrobot/daotest/customtype/MyTimestampConverter.java
rename to DaoTestBase/src/main/java/de/greenrobot/daotest/customtype/MyTimestampConverter.java
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/SimpleEntityNotNullHelper.java b/DaoTestBase/src/main/java/de/greenrobot/daotest/entity/SimpleEntityNotNullHelper.java
similarity index 100%
rename from DaoTest/src/de/greenrobot/daotest/entity/SimpleEntityNotNullHelper.java
rename to DaoTestBase/src/main/java/de/greenrobot/daotest/entity/SimpleEntityNotNullHelper.java
diff --git a/DaoTest/src-gen/de/greenrobot/daotest2/KeepEntity.java b/DaoTestBase/src/main/java/de/greenrobot/daotest2/KeepEntity.java
similarity index 100%
rename from DaoTest/src-gen/de/greenrobot/daotest2/KeepEntity.java
rename to DaoTestBase/src/main/java/de/greenrobot/daotest2/KeepEntity.java
diff --git a/DaoTest/src-gen/de/greenrobot/daotest2/ToManyTarget2.java b/DaoTestBase/src/main/java/de/greenrobot/daotest2/ToManyTarget2.java
similarity index 100%
rename from DaoTest/src-gen/de/greenrobot/daotest2/ToManyTarget2.java
rename to DaoTestBase/src/main/java/de/greenrobot/daotest2/ToManyTarget2.java
diff --git a/DaoTest/src-gen/de/greenrobot/daotest2/dao/DaoMaster.java b/DaoTestBase/src/main/java/de/greenrobot/daotest2/dao/DaoMaster.java
similarity index 100%
rename from DaoTest/src-gen/de/greenrobot/daotest2/dao/DaoMaster.java
rename to DaoTestBase/src/main/java/de/greenrobot/daotest2/dao/DaoMaster.java
diff --git a/DaoTest/src-gen/de/greenrobot/daotest2/dao/DaoSession.java b/DaoTestBase/src/main/java/de/greenrobot/daotest2/dao/DaoSession.java
similarity index 100%
rename from DaoTest/src-gen/de/greenrobot/daotest2/dao/DaoSession.java
rename to DaoTestBase/src/main/java/de/greenrobot/daotest2/dao/DaoSession.java
diff --git a/DaoTest/src-gen/de/greenrobot/daotest2/dao/KeepEntityDao.java b/DaoTestBase/src/main/java/de/greenrobot/daotest2/dao/KeepEntityDao.java
similarity index 100%
rename from DaoTest/src-gen/de/greenrobot/daotest2/dao/KeepEntityDao.java
rename to DaoTestBase/src/main/java/de/greenrobot/daotest2/dao/KeepEntityDao.java
diff --git a/DaoTest/src-gen/de/greenrobot/daotest2/dao/ToManyTarget2Dao.java b/DaoTestBase/src/main/java/de/greenrobot/daotest2/dao/ToManyTarget2Dao.java
similarity index 100%
rename from DaoTest/src-gen/de/greenrobot/daotest2/dao/ToManyTarget2Dao.java
rename to DaoTestBase/src/main/java/de/greenrobot/daotest2/dao/ToManyTarget2Dao.java
diff --git a/DaoTest/src-gen/de/greenrobot/daotest2/specialdao/RelationSource2Dao.java b/DaoTestBase/src/main/java/de/greenrobot/daotest2/specialdao/RelationSource2Dao.java
similarity index 100%
rename from DaoTest/src-gen/de/greenrobot/daotest2/specialdao/RelationSource2Dao.java
rename to DaoTestBase/src/main/java/de/greenrobot/daotest2/specialdao/RelationSource2Dao.java
diff --git a/DaoTest/src-gen/de/greenrobot/daotest2/specialentity/RelationSource2.java b/DaoTestBase/src/main/java/de/greenrobot/daotest2/specialentity/RelationSource2.java
similarity index 100%
rename from DaoTest/src-gen/de/greenrobot/daotest2/specialentity/RelationSource2.java
rename to DaoTestBase/src/main/java/de/greenrobot/daotest2/specialentity/RelationSource2.java
diff --git a/DaoTest/src-gen/de/greenrobot/daotest2/to1_specialdao/ToOneTarget2Dao.java b/DaoTestBase/src/main/java/de/greenrobot/daotest2/to1_specialdao/ToOneTarget2Dao.java
similarity index 100%
rename from DaoTest/src-gen/de/greenrobot/daotest2/to1_specialdao/ToOneTarget2Dao.java
rename to DaoTestBase/src/main/java/de/greenrobot/daotest2/to1_specialdao/ToOneTarget2Dao.java
diff --git a/DaoTest/src-gen/de/greenrobot/daotest2/to1_specialentity/ToOneTarget2.java b/DaoTestBase/src/main/java/de/greenrobot/daotest2/to1_specialentity/ToOneTarget2.java
similarity index 100%
rename from DaoTest/src-gen/de/greenrobot/daotest2/to1_specialentity/ToOneTarget2.java
rename to DaoTestBase/src/main/java/de/greenrobot/daotest2/to1_specialentity/ToOneTarget2.java
diff --git a/DaoTestGenerator/build.gradle b/DaoTestGenerator/build.gradle
index fad5dbbd..de5503c9 100644
--- a/DaoTestGenerator/build.gradle
+++ b/DaoTestGenerator/build.gradle
@@ -1,4 +1,8 @@
 apply plugin: 'java'
+apply plugin:'application'
+
+// If your IDE fails to run generation (NoClassDefFoundError), run it using gradle
+mainClassName = "de.greenrobot.daogenerator.gentest.TestDaoGenerator"
 
 sourceSets {
     main {
diff --git a/DaoTestGenerator/src/de/greenrobot/daogenerator/gentest/TestDaoGenerator.java b/DaoTestGenerator/src/de/greenrobot/daogenerator/gentest/TestDaoGenerator.java
index a5c6a3f0..91780b10 100644
--- a/DaoTestGenerator/src/de/greenrobot/daogenerator/gentest/TestDaoGenerator.java
+++ b/DaoTestGenerator/src/de/greenrobot/daogenerator/gentest/TestDaoGenerator.java
@@ -39,6 +39,7 @@ public static void main(String[] args) throws Exception {
     private final Entity testEntity;
     private final Entity dateEntity;
     private final Schema schema2;
+    private final Schema schemaUnitTest;
 
     public TestDaoGenerator() {
         schema = new Schema(1, "de.greenrobot.daotest");
@@ -59,14 +60,17 @@ public TestDaoGenerator() {
         createAutoincrement();
         createSqliteMaster();
         createCustomType();
+        createIndexedString();
 
         schema2 = createSchema2();
+        schemaUnitTest = createSchemaUnitTest();
     }
 
     public void generate() throws Exception {
         DaoGenerator daoGenerator = new DaoGenerator();
-        daoGenerator.generateAll(schema, "../DaoTest/src-gen", null, "../DaoTest/src");
-        daoGenerator.generateAll(schema2, "../DaoTest/src-gen", null, "../DaoTest/src");
+        daoGenerator.generateAll(schema, "../DaoTestBase/src/main/java");
+        daoGenerator.generateAll(schema2, "../DaoTestBase/src/main/java");
+        daoGenerator.generateAll(schemaUnitTest, "../DaoTestBase/src/test/java");
     }
 
     protected void createSimple() {
@@ -101,15 +105,19 @@ protected void createSimpleNotNull() {
 
     protected Entity createTest() {
         Entity testEntity = schema.addEntity("TestEntity");
-        testEntity.addIdProperty();
-        testEntity.addIntProperty("simpleInt").notNull();
-        testEntity.addIntProperty("simpleInteger");
-        testEntity.addStringProperty("simpleStringNotNull").notNull();
+        testEntity.setJavaDoc("This entity is used by internal tests of greenDAO.\n" +
+                "(This JavaDoc is defined in the generator project.)");
+        testEntity.setCodeBeforeClass("// This is another test comment, you could also apply annotations like this");
+        testEntity.addIdProperty().javaDocField("JavaDoc test field");
+        testEntity.addIntProperty("simpleInt").notNull().javaDocGetter("JavaDoc test getter");
+        testEntity.addIntProperty("simpleInteger").javaDocSetter("JavaDoc test setter");
+        testEntity.addStringProperty("simpleStringNotNull").notNull().javaDocGetterAndSetter("JavaDoc test getter and setter");
         testEntity.addStringProperty("simpleString");
         testEntity.addStringProperty("indexedString").index();
         testEntity.addStringProperty("indexedStringAscUnique").indexAsc(null, true);
         testEntity.addDateProperty("simpleDate");
         testEntity.addBooleanProperty("simpleBoolean");
+        testEntity.addByteArrayProperty("simpleByteArray");
         return testEntity;
     }
 
@@ -258,6 +266,12 @@ protected void createCustomType() {
                 "de.greenrobot.daotest.customtype.MyTimestampConverter");
     }
 
+    protected void createIndexedString() {
+        Entity entity = schema.addEntity("IndexedStringEntity");
+        entity.addIdProperty();
+        entity.addStringProperty("indexedString").index();
+    }
+
     private Schema createSchema2() {
         Schema schema2 = new Schema(1, "de.greenrobot.daotest2");
         schema2.setDefaultJavaPackageTest("de.greenrobot.daotest2.entity");
@@ -291,5 +305,12 @@ private Schema createSchema2() {
         return schema2;
     }
 
+    private Schema createSchemaUnitTest() {
+        Schema schema = new Schema(1, "de.greenrobot.dao.unittest");
+
+        Entity entity = schema.addEntity("MinimalEntity");
+        entity.addIdProperty();
+        return schema;
+    }
 
 }
diff --git a/DaoTestPerformance/build.gradle b/DaoTestPerformance/build.gradle
new file mode 100644
index 00000000..eedcc3f9
--- /dev/null
+++ b/DaoTestPerformance/build.gradle
@@ -0,0 +1,33 @@
+buildscript {
+    repositories {
+        mavenCentral()
+    }
+
+    dependencies {
+        classpath 'com.android.tools.build:gradle:2.1.2'
+    }
+}
+
+apply plugin: 'com.android.application'
+
+repositories {
+    maven {
+        url 'https://oss.sonatype.org/content/repositories/snapshots'
+    }
+}
+
+dependencies {
+    compile project(':DaoTestBase')
+    androidTestCompile 'org.greenrobot:essentials:3.0.0-SNAPSHOT'
+}
+
+android {
+    buildToolsVersion rootProject.ext.buildToolsVersion
+    compileSdkVersion rootProject.ext.compileSdkVersion
+
+    defaultConfig {
+        minSdkVersion 5
+        testApplicationId "org.greenrobot.greendao.perftest"
+        testInstrumentationRunner "android.test.InstrumentationTestRunner"
+    }
+}
diff --git a/DaoTestPerformance/src/androidTest/java/de/greenrobot/daotest/performance/Benchmark.java b/DaoTestPerformance/src/androidTest/java/de/greenrobot/daotest/performance/Benchmark.java
new file mode 100644
index 00000000..e8dd7b86
--- /dev/null
+++ b/DaoTestPerformance/src/androidTest/java/de/greenrobot/daotest/performance/Benchmark.java
@@ -0,0 +1,189 @@
+package de.greenrobot.daotest.performance;
+
+import android.os.Build;
+import android.os.SystemClock;
+import android.util.Log;
+import android.util.Pair;
+
+import org.greenrobot.essentials.StringUtils;
+import org.greenrobot.essentials.io.FileUtils;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.text.SimpleDateFormat;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Date;
+import java.util.List;
+
+public class Benchmark {
+    public static final String TAG = "Benchmark";
+
+    private final List<Pair<String, String>> fixedColumns = new ArrayList<>();
+    private final List<Pair<String, String>> values = new ArrayList<>();
+    private final File file;
+    private final SimpleDateFormat dateFormat;
+    private final char separator = '\t';
+
+    private String[] headers;
+    private boolean storeThreadTime;
+
+    private boolean started;
+    private long threadTimeMillis;
+    private long timeMillis;
+    private String name;
+    private int runs;
+    private int warmUpRuns;
+
+    public Benchmark(File file) {
+        this.file = file;
+        dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
+        checkForLastHeader(file);
+    }
+
+    private void checkForLastHeader(File file) {
+        String contents = null;
+        try {
+            contents = FileUtils.readUtf8(file);
+        } catch (FileNotFoundException e) {
+            // OK
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+        if (contents == null) {
+            return;
+        }
+
+        String[] lines = StringUtils.split(contents, '\n');
+        for (int i = lines.length - 1; i >= 0; i--) {
+            String[] columnValues = StringUtils.split(lines[i], separator);
+            if (columnValues.length > 1) {
+                boolean longValueFound = false;
+                for (String value : columnValues) {
+                    try {
+                        Long.parseLong(value);
+                        longValueFound = true;
+                        break;
+                    } catch (NumberFormatException e) {
+                        // OK, header candidate
+                    }
+                }
+                if (!longValueFound) {
+                    headers = columnValues;
+                    break;
+                }
+            }
+        }
+    }
+
+    public Benchmark warmUpRuns(int warmUpRuns) {
+        this.warmUpRuns = warmUpRuns;
+        return this;
+    }
+
+    public Benchmark enableThreadTime() {
+        this.storeThreadTime = true;
+        return this;
+    }
+
+    public Benchmark disableThreadTime() {
+        this.storeThreadTime = false;
+        return this;
+    }
+
+    public Benchmark addFixedColumn(String key, String value) {
+        fixedColumns.add(new Pair<String, String>(key, value));
+        return this;
+    }
+
+    public Benchmark addFixedColumnDevice() {
+        addFixedColumn("device", Build.MODEL);
+        return this;
+    }
+
+    public void start(String name) {
+        if (started) {
+            throw new RuntimeException("Already started");
+        }
+        started = true;
+        prepareForNextRun();
+        if (values.isEmpty()) {
+            values.addAll(fixedColumns);
+            String startTime = dateFormat.format(new Date());
+            values.add(new Pair<>("time", startTime));
+        }
+        this.name = name;
+        threadTimeMillis = SystemClock.currentThreadTimeMillis();
+        timeMillis = SystemClock.elapsedRealtime();
+    }
+
+    /**
+     * Try to give GC some time to settle down.
+     */
+    public void prepareForNextRun() {
+        for (int i = 0; i < 5; i++) {
+            System.gc();
+            try {
+                Thread.sleep(20);
+            } catch (InterruptedException e) {
+                e.printStackTrace();
+            }
+        }
+    }
+
+    public void stop() {
+        long time = SystemClock.elapsedRealtime() - timeMillis;
+        long timeThread = SystemClock.currentThreadTimeMillis() - threadTimeMillis;
+        if (!started) {
+            throw new RuntimeException("Not started");
+        }
+        started = false;
+
+        Log.d(TAG, name + ": " + time + " ms (thread: " + timeThread + " ms)");
+        values.add(new Pair<>(name, Long.toString(time)));
+        if (storeThreadTime) {
+            values.add(new Pair<>(name + "-thread", Long.toString(timeThread)));
+        }
+        name = null;
+    }
+
+    public void commit() {
+        runs++;
+        if (runs > warmUpRuns) {
+            Log.d(TAG, "Writing results for run " + runs);
+            String[] collectedHeaders = getAllFirsts(values);
+            if (!Arrays.equals(collectedHeaders, headers)) {
+                headers = collectedHeaders;
+                String line = StringUtils.join(headers, "" + separator) + '\n';
+                try {
+                    FileUtils.appendUtf8(file, line);
+                } catch (IOException e) {
+                    throw new RuntimeException("Could not write header in benchmark file", e);
+                }
+            }
+
+            StringBuilder line = new StringBuilder();
+            for (Pair<String, String> pair : values) {
+                line.append(pair.second).append(separator);
+            }
+            line.append('\n');
+            try {
+                FileUtils.appendUtf8(file, line);
+            } catch (IOException e) {
+                throw new RuntimeException("Could not write header in benchmark file", e);
+            }
+        } else {
+            Log.d(TAG, "Ignoring results for run " + runs + " (warm up)");
+        }
+        values.clear();
+    }
+
+    private String[] getAllFirsts(List<Pair<String, String>> columns) {
+        String[] firsts = new String[columns.size()];
+        for (int i = 0; i < firsts.length; i++) {
+            firsts[i] = columns.get(i).first;
+        }
+        return firsts;
+    }
+}
diff --git a/DaoTestPerformance/src/androidTest/java/de/greenrobot/daotest/performance/IndexedStringPerformanceTest.java b/DaoTestPerformance/src/androidTest/java/de/greenrobot/daotest/performance/IndexedStringPerformanceTest.java
new file mode 100644
index 00000000..dfb30b63
--- /dev/null
+++ b/DaoTestPerformance/src/androidTest/java/de/greenrobot/daotest/performance/IndexedStringPerformanceTest.java
@@ -0,0 +1,73 @@
+package de.greenrobot.daotest.performance;
+
+import de.greenrobot.dao.DaoLog;
+import de.greenrobot.dao.test.AbstractDaoTest;
+import de.greenrobot.daotest.IndexedStringEntity;
+import de.greenrobot.daotest.IndexedStringEntityDao;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Stores entities with an indexed string property and measures the duration to query them by this
+ * string. The generated strings are in a fixed random sequence. The strings to query for are also
+ * in a fixed random sequence.
+ */
+public class IndexedStringPerformanceTest
+        extends AbstractDaoTest<IndexedStringEntityDao, IndexedStringEntity, Long> {
+
+    private static final int BATCH_SIZE = 10000;
+    private static final int QUERY_COUNT = 1000;
+    private static final int RUNS = 8;
+
+    public IndexedStringPerformanceTest() {
+        super(IndexedStringEntityDao.class, false);
+    }
+
+    public void testIndexedStringEntityQuery() {
+        // disabled for regular builds
+//        DaoLog.d("--------Indexed Queries: Start");
+//        for (int i = 0; i < RUNS; i++) {
+//            DaoLog.d("----Run " + (i + 1) + " of " + RUNS);
+//            doIndexedStringEntityQuery();
+//        }
+//        DaoLog.d("--------Indexed Queries: End");
+    }
+
+    private void doIndexedStringEntityQuery() {
+        // create entities
+        List<IndexedStringEntity> entities = new ArrayList<>(BATCH_SIZE);
+        String[] fixedRandomStrings = StringGenerator.createFixedRandomStrings(BATCH_SIZE);
+        for (int i = 0; i < BATCH_SIZE; i++) {
+            IndexedStringEntity entity = new IndexedStringEntity();
+            entity.setId((long) i);
+            entity.setIndexedString(fixedRandomStrings[i]);
+            entities.add(entity);
+        }
+        DaoLog.d("Built entities.");
+
+        // insert entities
+        dao.insertInTx(entities);
+        DaoLog.d("Inserted entities.");
+
+        // query for entities by indexed string at random
+        int[] randomIndices = StringGenerator.getFixedRandomIndices(QUERY_COUNT, BATCH_SIZE - 1);
+
+        long start = System.currentTimeMillis();
+        for (int i = 0; i < QUERY_COUNT; i++) {
+            int nextIndex = randomIndices[i];
+            //noinspection unused
+            List<IndexedStringEntity> query = dao.queryBuilder()
+                    .where(IndexedStringEntityDao.Properties.IndexedString.eq(
+                            fixedRandomStrings[nextIndex]))
+                    .list();
+        }
+        long time = System.currentTimeMillis() - start;
+        DaoLog.d("Queried for " + QUERY_COUNT + " of " + BATCH_SIZE + " indexed entities in " + time
+                + " ms.");
+
+        // delete all entities
+        dao.deleteAll();
+        DaoLog.d("Deleted all entities.");
+    }
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/performance/LoockupPerformanceTest.java b/DaoTestPerformance/src/androidTest/java/de/greenrobot/daotest/performance/LoockupPerformanceTest.java
similarity index 100%
rename from DaoTest/src/de/greenrobot/daotest/performance/LoockupPerformanceTest.java
rename to DaoTestPerformance/src/androidTest/java/de/greenrobot/daotest/performance/LoockupPerformanceTest.java
diff --git a/DaoTest/src/de/greenrobot/daotest/performance/PerformanceTest.java b/DaoTestPerformance/src/androidTest/java/de/greenrobot/daotest/performance/PerformanceTest.java
similarity index 59%
rename from DaoTest/src/de/greenrobot/daotest/performance/PerformanceTest.java
rename to DaoTestPerformance/src/androidTest/java/de/greenrobot/daotest/performance/PerformanceTest.java
index 6eb3aab6..d9d918fb 100644
--- a/DaoTest/src/de/greenrobot/daotest/performance/PerformanceTest.java
+++ b/DaoTestPerformance/src/androidTest/java/de/greenrobot/daotest/performance/PerformanceTest.java
@@ -17,57 +17,81 @@
  */
 package de.greenrobot.daotest.performance;
 
+import android.os.Debug;
+import android.os.Environment;
+
+import java.io.File;
 import java.util.ArrayList;
 import java.util.Date;
 import java.util.List;
 
-import android.os.Debug;
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.DaoLog;
 import de.greenrobot.dao.test.AbstractDaoTest;
 
-public abstract class PerformanceTest<D extends AbstractDao<T, K>, T, K> extends AbstractDaoTest<D, T, K> {
-    long start;
-    private String traceName;
+public abstract class PerformanceTest<D extends AbstractDao<T, K>, T, K>
+        extends AbstractDaoTest<D, T, K> {
+
+    private static final int BATCH_SIZE = 10000;
+    private static final int RUNS = 10;
+
     boolean useTraceView = false;
+    private Benchmark benchmark;
+    private ArrayList<T> entities;
 
     public PerformanceTest(Class<D> daoClass) {
         super(daoClass, false);
     }
 
-    public void testPerformance() throws Exception {
-        // runTests(1000);
-        // runTests(1000);
-        // runTests(1000);
-        // runTests(1000);
-        // runTests(1000);
-        // runTests(1000);
-    }
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
 
-    protected void runTests(int entityCount) {
         DaoLog.d("####################");
-        DaoLog.d(getClass().getSimpleName() + ": " + entityCount + " entities on " + new Date());
+        DaoLog.d(getClass().getSimpleName() + ": " + BATCH_SIZE + " entities on " + new Date());
         DaoLog.d("####################");
         clearIdentityScopeIfAny();
 
-        List<T> list = new ArrayList<T>(entityCount);
-        for (int i = 0; i < entityCount; i++) {
-            list.add(createEntity());
+        entities = new ArrayList<T>(BATCH_SIZE);
+        for (int i = 0; i < BATCH_SIZE; i++) {
+            entities.add(createEntity());
         }
-        System.gc();
 
         dao.deleteAll();
-        // runOneByOneTests(list, entityCount, entityCount / 10);
-        dao.deleteAll();
-        DaoLog.d("------------------------");
-        System.gc();
+    }
 
-        // runBatchTests(list);
+    // disable for regular builds
+    public void _testPerformanceOneByOne() throws Exception {
+        int count = BATCH_SIZE / 10;
+        File benchFile = new File(Environment.getExternalStorageDirectory(), "greendao-1by1-" + count + ".tsv");
+        benchmark = new Benchmark(benchFile);
+        benchmark.addFixedColumnDevice().warmUpRuns(2);
+        for (int i = 0; i < RUNS; i++) {
+            runOneByOneTests(entities, count, count);
 
-        startClock("delete-all");
-        dao.deleteAll();
-        stopClock();
-        System.gc();
+            startClock("delete-all");
+            dao.deleteAll();
+            stopClock();
+
+            benchmark.commit();
+        }
+    }
+
+    // disable for regular builds
+    public void testPerformanceBatch() throws Exception {
+        File benchFile = new File(Environment.getExternalStorageDirectory(), "greendao-batch-" + BATCH_SIZE + ".tsv");
+        benchmark = new Benchmark(benchFile);
+        benchmark.addFixedColumnDevice().warmUpRuns(2);
+
+        for (int i = 0; i < RUNS; i++) {
+            runBatchTests(entities);
+
+            startClock("delete-all");
+            dao.deleteAll();
+            stopClock();
+
+            benchmark.commit();
+        }
     }
 
     protected void runOneByOneTests(List<T> list, int loadCount, int modifyCount) {
@@ -77,35 +101,30 @@ protected void runOneByOneTests(List<T> list, int loadCount, int modifyCount) {
             keys.add(daoAccess.getKey(list.get(i)));
         }
         clearIdentityScopeIfAny();
-        System.gc();
 
         list = runLoadOneByOne(keys, "load-one-by-one-1");
         list = runLoadOneByOne(keys, "load-one-by-one-2");
         Debug.stopMethodTracing();
 
         dao.deleteAll();
-        System.gc();
 
         startClock("insert-one-by-one");
         for (int i = 0; i < modifyCount; i++) {
             dao.insert(list.get(i));
         }
-        stopClock(modifyCount + " entities");
-        System.gc();
+        stopClock();
 
         startClock("update-one-by-one");
         for (int i = 0; i < modifyCount; i++) {
             dao.update(list.get(i));
         }
-        stopClock(modifyCount + " entities");
-        System.gc();
+        stopClock();
 
         startClock("delete-one-by-one");
         for (int i = 0; i < modifyCount; i++) {
             dao.delete(list.get(i));
         }
-        stopClock(modifyCount + " entities");
-        System.gc();
+        stopClock();
     }
 
     protected List<T> runLoadOneByOne(List<K> keys, String traceName) {
@@ -114,56 +133,55 @@ protected void runOneByOneTests(List<T> list, int loadCount, int modifyCount) {
         for (K key : keys) {
             list.add(dao.load(key));
         }
-        stopClock(keys.size() + " entities");
+        stopClock();
         return list;
     }
 
     protected void runBatchTests(List<T> list) {
         startClock("insert");
         dao.insertInTx(list);
-        stopClock(list.size() + " entities");
+        stopClock();
 
         list = null;
         System.gc();
 
         clearIdentityScopeIfAny();
         list = runLoadAll("load-all-1");
+        accessAll(list, "access-all-1");
         list = runLoadAll("load-all-2");
+        accessAll(list, "access-all-2");
 
         startClock("update");
         dao.updateInTx(list);
-        stopClock(list.size() + " entities");
+        stopClock();
     }
 
     protected List<T> runLoadAll(String traceName) {
         startClock(traceName);
         List<T> list = dao.loadAll();
-        stopClock(list.size() + " entities");
+        stopClock();
         return list;
     }
 
-    protected void startClock(String traceName) {
-        System.gc();
-        this.traceName = traceName;
+    protected void startClock(String name) {
+        benchmark.start(name);
         if (useTraceView) {
-            Debug.startMethodTracing(traceName);
+            Debug.startMethodTracing(name);
         }
-        start = System.currentTimeMillis();
     }
 
     protected void stopClock() {
-        stopClock(null);
-    }
-
-    protected void stopClock(String extraInfoOrNull) {
-        long time = System.currentTimeMillis() - start;
-        String extraLog = extraInfoOrNull != null ? " (" + extraInfoOrNull + ")" : "";
-        DaoLog.d(traceName + " completed in " + time + "ms" + extraLog);
+        benchmark.stop();
         if (useTraceView) {
             Debug.stopMethodTracing();
         }
-        System.gc();
     }
 
     protected abstract T createEntity();
+
+    /**
+     * Access every property of the entity under test and record execution time with {@link
+     * #startClock(String)} and {@link #stopClock()}.
+     */
+    protected abstract void accessAll(List<T> list, String traceName);
 }
diff --git a/DaoTest/src/de/greenrobot/daotest/performance/PerformanceTestNotNull.java b/DaoTestPerformance/src/androidTest/java/de/greenrobot/daotest/performance/PerformanceTestNotNull.java
similarity index 67%
rename from DaoTest/src/de/greenrobot/daotest/performance/PerformanceTestNotNull.java
rename to DaoTestPerformance/src/androidTest/java/de/greenrobot/daotest/performance/PerformanceTestNotNull.java
index 7b256544..b34aef06 100644
--- a/DaoTest/src/de/greenrobot/daotest/performance/PerformanceTestNotNull.java
+++ b/DaoTestPerformance/src/androidTest/java/de/greenrobot/daotest/performance/PerformanceTestNotNull.java
@@ -20,6 +20,7 @@
 import de.greenrobot.daotest.SimpleEntityNotNull;
 import de.greenrobot.daotest.SimpleEntityNotNullDao;
 import de.greenrobot.daotest.entity.SimpleEntityNotNullHelper;
+import java.util.List;
 
 public class PerformanceTestNotNull extends PerformanceTest<SimpleEntityNotNullDao, SimpleEntityNotNull, Long> {
 
@@ -34,4 +35,23 @@ protected SimpleEntityNotNull createEntity() {
         return SimpleEntityNotNullHelper.createEntity(sequence++);
     }
 
+    @Override
+    protected void accessAll(List<SimpleEntityNotNull> list, String traceName) {
+        startClock(traceName);
+        for (int i = 0; i < list.size(); i++) {
+            SimpleEntityNotNull entity = list.get(i);
+            entity.getId();
+            entity.getSimpleBoolean();
+            entity.getSimpleByte();
+            entity.getSimpleShort();
+            entity.getSimpleInt();
+            entity.getSimpleLong();
+            entity.getSimpleFloat();
+            entity.getSimpleDouble();
+            entity.getSimpleString();
+            entity.getSimpleByteArray();
+        }
+        stopClock();
+    }
+
 }
diff --git a/DaoTest/src/de/greenrobot/daotest/performance/PerformanceTestNotNullIdentityScope.java b/DaoTestPerformance/src/androidTest/java/de/greenrobot/daotest/performance/PerformanceTestNotNullIdentityScope.java
similarity index 100%
rename from DaoTest/src/de/greenrobot/daotest/performance/PerformanceTestNotNullIdentityScope.java
rename to DaoTestPerformance/src/androidTest/java/de/greenrobot/daotest/performance/PerformanceTestNotNullIdentityScope.java
diff --git a/DaoTest/src/de/greenrobot/daotest/performance/ReflectionPerformanceTest.java b/DaoTestPerformance/src/androidTest/java/de/greenrobot/daotest/performance/ReflectionPerformanceTest.java
similarity index 100%
rename from DaoTest/src/de/greenrobot/daotest/performance/ReflectionPerformanceTest.java
rename to DaoTestPerformance/src/androidTest/java/de/greenrobot/daotest/performance/ReflectionPerformanceTest.java
diff --git a/DaoTestPerformance/src/androidTest/java/de/greenrobot/daotest/performance/StringGenerator.java b/DaoTestPerformance/src/androidTest/java/de/greenrobot/daotest/performance/StringGenerator.java
new file mode 100644
index 00000000..3fd87902
--- /dev/null
+++ b/DaoTestPerformance/src/androidTest/java/de/greenrobot/daotest/performance/StringGenerator.java
@@ -0,0 +1,58 @@
+package de.greenrobot.daotest.performance;
+
+import java.util.Random;
+
+/**
+ * Helper class to generate a pre-determined set of random strings.
+ */
+public class StringGenerator {
+
+    // Fixed seed so we generate the same set of strings every time.
+    public static final long SEED = -2662502316022774L;
+    private static final int MIN_LENGTH = 5;
+    private static final int MAX_LENGTH = 500;
+    // limit to a fixed set of chars
+    private static final char[] CHARS = new char[]{'0', '1', '2', '3', '4', '5', '6', '7', '8',
+            '9', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p',
+            'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'};
+
+    /**
+     * Creates the same random sequence of strings.
+     */
+    public static String[] createFixedRandomStrings(int count) {
+        String[] strings = new String[count];
+
+        Random lengthRandom = new Random();
+        lengthRandom.setSeed(SEED);
+
+        Random stringRandom = new Random();
+        stringRandom.setSeed(SEED);
+
+        for (int i = 0; i < count; i++) {
+            int nextLength = MIN_LENGTH + lengthRandom.nextInt(MAX_LENGTH - MIN_LENGTH - 1);
+            char[] chars = new char[nextLength];
+            for (int j = 0; j < nextLength; j++) {
+                chars[j] = CHARS[stringRandom.nextInt(CHARS.length)];
+            }
+            strings[i] = new String(chars);
+        }
+        return strings;
+    }
+
+    /**
+     * Creates the same random sequence of indexes. To be used to select strings by {@link
+     * #createFixedRandomStrings(int)}.
+     */
+    public static int[] getFixedRandomIndices(int count, int maxIndex) {
+        int[] indices = new int[count];
+
+        Random random = new Random();
+        random.setSeed(StringGenerator.SEED);
+
+        for (int i = 0; i < count; i++) {
+            indices[i] = random.nextInt(maxIndex + 1);
+        }
+
+        return indices;
+    }
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/performance/target/ArrayUtils.java b/DaoTestPerformance/src/androidTest/java/de/greenrobot/daotest/performance/target/ArrayUtils.java
similarity index 100%
rename from DaoTest/src/de/greenrobot/daotest/performance/target/ArrayUtils.java
rename to DaoTestPerformance/src/androidTest/java/de/greenrobot/daotest/performance/target/ArrayUtils.java
diff --git a/DaoTest/src/de/greenrobot/daotest/performance/target/LongHashMapAmarena2DZechner.java b/DaoTestPerformance/src/androidTest/java/de/greenrobot/daotest/performance/target/LongHashMapAmarena2DZechner.java
similarity index 100%
rename from DaoTest/src/de/greenrobot/daotest/performance/target/LongHashMapAmarena2DZechner.java
rename to DaoTestPerformance/src/androidTest/java/de/greenrobot/daotest/performance/target/LongHashMapAmarena2DZechner.java
diff --git a/DaoTest/src/de/greenrobot/daotest/performance/target/LongHashMapJDBM.java b/DaoTestPerformance/src/androidTest/java/de/greenrobot/daotest/performance/target/LongHashMapJDBM.java
similarity index 100%
rename from DaoTest/src/de/greenrobot/daotest/performance/target/LongHashMapJDBM.java
rename to DaoTestPerformance/src/androidTest/java/de/greenrobot/daotest/performance/target/LongHashMapJDBM.java
diff --git a/DaoTest/src/de/greenrobot/daotest/performance/target/LongSparseArray.java b/DaoTestPerformance/src/androidTest/java/de/greenrobot/daotest/performance/target/LongSparseArray.java
similarity index 100%
rename from DaoTest/src/de/greenrobot/daotest/performance/target/LongSparseArray.java
rename to DaoTestPerformance/src/androidTest/java/de/greenrobot/daotest/performance/target/LongSparseArray.java
diff --git a/DaoTestPerformance/src/main/AndroidManifest.xml b/DaoTestPerformance/src/main/AndroidManifest.xml
new file mode 100644
index 00000000..ad1fefb0
--- /dev/null
+++ b/DaoTestPerformance/src/main/AndroidManifest.xml
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="org.greenrobot.daotest.dummyapp"
+    android:versionCode="1"
+    android:versionName="1.0" >
+
+    <uses-sdk android:minSdkVersion="4" />
+
+    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
+    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
+
+    <application>
+        <uses-library android:name="android.test.runner" />
+    </application>
+
+</manifest>
\ No newline at end of file
diff --git a/PerformanceTestOrmLite/.gitignore b/PerformanceTestOrmLite/.gitignore
deleted file mode 100644
index a02fbbe0..00000000
--- a/PerformanceTestOrmLite/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-/gen
-/bin
diff --git a/PerformanceTestOrmLite/AndroidManifest.xml b/PerformanceTestOrmLite/AndroidManifest.xml
deleted file mode 100644
index 47a10c35..00000000
--- a/PerformanceTestOrmLite/AndroidManifest.xml
+++ /dev/null
@@ -1,14 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<manifest
-	xmlns:android="http://schemas.android.com/apk/res/android"
-	package="de.greenrobot.performance.ormlite"
-	android:versionCode="1"
-	android:versionName="1.0">
-	<uses-sdk android:minSdkVersion="4" />
-	<instrumentation
-		android:targetPackage="de.greenrobot.performance.ormlite"
-		android:name="android.test.InstrumentationTestRunner" />
-	<application>
-		<uses-library android:name="android.test.runner" />
-	</application>
-</manifest>
\ No newline at end of file
diff --git a/PerformanceTestOrmLite/lib/ormlite-android-4.34-SNAPSHOT.jar b/PerformanceTestOrmLite/lib/ormlite-android-4.34-SNAPSHOT.jar
deleted file mode 100644
index 7c41c0b9..00000000
Binary files a/PerformanceTestOrmLite/lib/ormlite-android-4.34-SNAPSHOT.jar and /dev/null differ
diff --git a/PerformanceTestOrmLite/lib/ormlite-core-4.34-SNAPSHOT.jar b/PerformanceTestOrmLite/lib/ormlite-core-4.34-SNAPSHOT.jar
deleted file mode 100644
index 24299339..00000000
Binary files a/PerformanceTestOrmLite/lib/ormlite-core-4.34-SNAPSHOT.jar and /dev/null differ
diff --git a/PerformanceTestOrmLite/proguard.cfg b/PerformanceTestOrmLite/proguard.cfg
deleted file mode 100644
index b1cdf17b..00000000
--- a/PerformanceTestOrmLite/proguard.cfg
+++ /dev/null
@@ -1,40 +0,0 @@
--optimizationpasses 5
--dontusemixedcaseclassnames
--dontskipnonpubliclibraryclasses
--dontpreverify
--verbose
--optimizations !code/simplification/arithmetic,!field/*,!class/merging/*
-
--keep public class * extends android.app.Activity
--keep public class * extends android.app.Application
--keep public class * extends android.app.Service
--keep public class * extends android.content.BroadcastReceiver
--keep public class * extends android.content.ContentProvider
--keep public class * extends android.app.backup.BackupAgentHelper
--keep public class * extends android.preference.Preference
--keep public class com.android.vending.licensing.ILicensingService
-
--keepclasseswithmembernames class * {
-    native <methods>;
-}
-
--keepclasseswithmembers class * {
-    public <init>(android.content.Context, android.util.AttributeSet);
-}
-
--keepclasseswithmembers class * {
-    public <init>(android.content.Context, android.util.AttributeSet, int);
-}
-
--keepclassmembers class * extends android.app.Activity {
-   public void *(android.view.View);
-}
-
--keepclassmembers enum * {
-    public static **[] values();
-    public static ** valueOf(java.lang.String);
-}
-
--keep class * implements android.os.Parcelable {
-  public static final android.os.Parcelable$Creator *;
-}
diff --git a/PerformanceTestOrmLite/project.properties b/PerformanceTestOrmLite/project.properties
deleted file mode 100644
index c957743c..00000000
--- a/PerformanceTestOrmLite/project.properties
+++ /dev/null
@@ -1,11 +0,0 @@
-# This file is automatically generated by Android Tools.
-# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
-#
-# This file must be checked in Version Control Systems.
-#
-# To customize properties used by the Ant build system use,
-# "ant.properties", and override values to adapt the script to your
-# project structure.
-
-# Project target.
-target=android-4
diff --git a/PerformanceTestOrmLite/res/values/dummy.xml b/PerformanceTestOrmLite/res/values/dummy.xml
deleted file mode 100644
index 3261aff6..00000000
--- a/PerformanceTestOrmLite/res/values/dummy.xml
+++ /dev/null
@@ -1,4 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<resources>
-    
-</resources>
\ No newline at end of file
diff --git a/PerformanceTestOrmLite/src/de/greenrobot/performance/ormlite/DbHelper.java b/PerformanceTestOrmLite/src/de/greenrobot/performance/ormlite/DbHelper.java
deleted file mode 100644
index e14c25d7..00000000
--- a/PerformanceTestOrmLite/src/de/greenrobot/performance/ormlite/DbHelper.java
+++ /dev/null
@@ -1,39 +0,0 @@
-package de.greenrobot.performance.ormlite;
-
-import android.content.Context;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteOpenHelper;
-
-public class DbHelper extends SQLiteOpenHelper {
-
-    public DbHelper(Context context, String name) {
-        super(context, name, null, 1);
-    }
-
-    @Override
-    public void onCreate(SQLiteDatabase db) {
-        String sql = "CREATE TABLE SIMPLE_ENTITY_NOT_NULL (" + //
-                "_id INTEGER PRIMARY KEY NOT NULL ," + // 0
-                "SIMPLE_BOOLEAN INTEGER NOT NULL ," + // 1
-                "SIMPLE_BYTE INTEGER NOT NULL ," + // 2
-                "SIMPLE_SHORT INTEGER NOT NULL ," + // 3
-                "SIMPLE_INT INTEGER NOT NULL ," + // 4
-                "SIMPLE_LONG INTEGER NOT NULL ," + // 5
-                "SIMPLE_FLOAT REAL NOT NULL ," + // 6
-                "SIMPLE_DOUBLE REAL NOT NULL ," + // 7
-                "SIMPLE_STRING TEXT NOT NULL ," + // 8
-                "SIMPLE_BYTE_ARRAY BLOB NOT NULL )"; // 9
-        db.execSQL(sql);
-        
-        String sql2 = "CREATE TABLE MINIMAL_ENTITY (_id INTEGER PRIMARY KEY)";
-        db.execSQL(sql2);
-    }
-
-    @Override
-    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
-        db.execSQL("DROP TABLE IF EXISTS SIMPLE_ENTITY_NOT_NULL");
-        db.execSQL("DROP TABLE IF EXISTS MINIMAL_ENTITY");
-        onCreate(db);
-    }
-
-}
diff --git a/PerformanceTestOrmLite/src/de/greenrobot/performance/ormlite/MinimalEntity.java b/PerformanceTestOrmLite/src/de/greenrobot/performance/ormlite/MinimalEntity.java
deleted file mode 100644
index d8e1ad59..00000000
--- a/PerformanceTestOrmLite/src/de/greenrobot/performance/ormlite/MinimalEntity.java
+++ /dev/null
@@ -1,20 +0,0 @@
-package de.greenrobot.performance.ormlite;
-
-import com.j256.ormlite.field.DatabaseField;
-import com.j256.ormlite.table.DatabaseTable;
-
-@DatabaseTable(tableName = "MINIMAL_ENTITY")
-public class MinimalEntity {
-
-    @DatabaseField(id = true, columnName="_id")
-    private Long id;
-
-    public Long getId() {
-        return id;
-    }
-
-    public void setId(Long id) {
-        this.id = id;
-    }
-    
-}
diff --git a/PerformanceTestOrmLite/src/de/greenrobot/performance/ormlite/PerformanceTestOrmLite.java b/PerformanceTestOrmLite/src/de/greenrobot/performance/ormlite/PerformanceTestOrmLite.java
deleted file mode 100644
index 358093ac..00000000
--- a/PerformanceTestOrmLite/src/de/greenrobot/performance/ormlite/PerformanceTestOrmLite.java
+++ /dev/null
@@ -1,163 +0,0 @@
-package de.greenrobot.performance.ormlite;
-
-import java.sql.SQLException;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.concurrent.Callable;
-
-import android.app.Application;
-import android.test.ApplicationTestCase;
-import android.util.Log;
-
-import com.j256.ormlite.android.AndroidConnectionSource;
-import com.j256.ormlite.dao.Dao;
-import com.j256.ormlite.dao.DaoManager;
-
-public class PerformanceTestOrmLite extends ApplicationTestCase<Application> {
-
-    private Dao<SimpleEntityNotNull, Long> dao;
-    private boolean inMemory;
-    private DbHelper dbHelper;
-    private AndroidConnectionSource connectionSource;
-
-    public PerformanceTestOrmLite() {
-        super(Application.class);
-        inMemory = false;
-    }
-
-    @Override
-    protected void setUp() {
-        createApplication();
-        prepareDb();
-    }
-
-    protected void prepareDb() {
-        String name;
-        if (inMemory) {
-            name = null;
-        } else {
-            name = "test-db";
-            getApplication().deleteDatabase(name);
-        }
-        dbHelper = new DbHelper(getApplication(), name);
-        connectionSource = new AndroidConnectionSource(dbHelper);
-        try {
-            dao = DaoManager.createDao(connectionSource, SimpleEntityNotNull.class);
-        } catch (SQLException e) {
-            throw new RuntimeException(e);
-        }
-    }
-
-    @Override
-    protected void tearDown() throws Exception {
-        if (!inMemory) {
-            getApplication().deleteDatabase("test-db");
-        }
-    }
-
-    public void testPerformance() throws Exception {
-        runTests(100); // Warmup
-        deleteAll();
-        runTests(1000);
-        deleteAll();
-        runTests(1000);
-        deleteAll();
-        runTests(1000);
-        deleteAll();
-        runTests(1000);
-        deleteAll();
-        runTests(1000);
-        Log.d("DAO", "---------------End");
-    }
-
-    protected void deleteAll() {
-        dbHelper.getWritableDatabase().execSQL("DELETE FROM SIMPLE_ENTITY_NOT_NULL");
-    }
-
-    protected void runTests(int entityCount) throws Exception {
-        Log.d("DAO", "---------------Start: " + entityCount);
-
-        long start, time;
-
-        final List<SimpleEntityNotNull> list = new ArrayList<SimpleEntityNotNull>();
-        for (int i = 0; i < entityCount; i++) {
-            list.add(SimpleEntityNotNullHelper.createEntity((long) i));
-        }
-        System.gc();
-
-        runOneByOne(list, entityCount / 10);
-
-        System.gc();
-        deleteAll();
-
-        start = System.currentTimeMillis();
-        dao.callBatchTasks(new Callable<Void>() {
-
-            @Override
-            public Void call() throws Exception {
-                for (SimpleEntityNotNull entity : list) {
-                    dao.create(entity);
-                }
-                return null;
-            }
-        });
-        time = System.currentTimeMillis() - start;
-        Log.d("DAO", "ORMLite: Created (batch) " + list.size() + " entities in " + time + "ms");
-
-        start = System.currentTimeMillis();
-        dao.callBatchTasks(new Callable<Void>() {
-
-            @Override
-            public Void call() throws Exception {
-                for (SimpleEntityNotNull entity : list) {
-                    dao.update(entity);
-                }
-                return null;
-            }
-        });
-        time = System.currentTimeMillis() - start;
-        Log.d("DAO", "ORMLite: Updated (batch) " + list.size() + " entities in " + time + "ms");
-
-        start = System.currentTimeMillis();
-        List<SimpleEntityNotNull> reloaded = dao.queryForAll();
-        time = System.currentTimeMillis() - start;
-        Log.d("DAO", "ORMLite: Loaded " + reloaded.size() + " entities in " + time + "ms");
-
-        System.gc();
-        Log.d("DAO", "---------------End: " + entityCount);
-    }
-
-    protected void runOneByOne(List<SimpleEntityNotNull> list, int count) throws SQLException {
-        long start;
-        long time;
-        start = System.currentTimeMillis();
-        for (int i = 0; i < count; i++) {
-            dao.create(list.get(i));
-        }
-        time = System.currentTimeMillis() - start;
-        Log.d("DAO", "ORMLite: Inserted (one-by-one) " + count + " entities in " + time + "ms");
-
-        start = System.currentTimeMillis();
-        for (int i = 0; i < count; i++) {
-            dao.update(list.get(i));
-        }
-        time = System.currentTimeMillis() - start;
-        Log.d("DAO", "ORMLite: Updated (one-by-one) " + count + " entities in " + time + "ms");
-    }
-
-    public void testSemantics() {
-        try {
-            Dao<MinimalEntity, Long> minimalDao = DaoManager.createDao(connectionSource, MinimalEntity.class);
-            MinimalEntity data = new MinimalEntity();
-            minimalDao.create(data);
-            assertNull(data.getId()); // ORMLite does not update PK after insert
-            MinimalEntity data2 = minimalDao.queryForAll().get(0);
-            MinimalEntity data3 = minimalDao.queryForId(data2.getId());
-            assertNotSame(data, data2);
-            assertNotSame(data2, data3); // ORMLite does not provide object equality
-            assertEquals(data2.getId(), data3.getId());
-        } catch (SQLException e) {
-            throw new RuntimeException(e);
-        }
-    }
-}
diff --git a/PerformanceTestOrmLite/src/de/greenrobot/performance/ormlite/SimpleEntityNotNull.java b/PerformanceTestOrmLite/src/de/greenrobot/performance/ormlite/SimpleEntityNotNull.java
deleted file mode 100644
index 86ab776f..00000000
--- a/PerformanceTestOrmLite/src/de/greenrobot/performance/ormlite/SimpleEntityNotNull.java
+++ /dev/null
@@ -1,116 +0,0 @@
-package de.greenrobot.performance.ormlite;
-
-import com.j256.ormlite.field.DataType;
-import com.j256.ormlite.field.DatabaseField;
-import com.j256.ormlite.table.DatabaseTable;
-
-
-/** 
- * Entity mapped to table SIMPLE_ENTITY_NOT_NULL (schema version 1).
-*/
-@DatabaseTable(tableName = "SIMPLE_ENTITY_NOT_NULL")
-public class SimpleEntityNotNull {
-
-    @DatabaseField(id = true, columnName="_id")
-    private long id;
-    
-    @DatabaseField(columnName="SIMPLE_BOOLEAN")
-    private boolean simpleBoolean;
-    @DatabaseField(columnName="SIMPLE_BYTE")
-    private byte simpleByte;
-    @DatabaseField(columnName="SIMPLE_SHORT")
-    private short simpleShort;
-    @DatabaseField(columnName="SIMPLE_INT")
-    private int simpleInt;
-    @DatabaseField(columnName="SIMPLE_LONG")
-    private long simpleLong;
-    @DatabaseField(columnName="SIMPLE_FLOAT")
-    private float simpleFloat;
-    @DatabaseField(columnName="SIMPLE_DOUBLE")
-    private double simpleDouble;
-    @DatabaseField(columnName="SIMPLE_STRING")
-    private String simpleString;
-    @DatabaseField(dataType=DataType.BYTE_ARRAY,columnName="SIMPLE_BYTE_ARRAY")
-    private byte[] simpleByteArray; 
-    
-    public long getId() {
-        return id;
-    } 
-
-    public void setId(long id) {
-        this.id = id;
-    } 
-
-    public boolean getSimpleBoolean() {
-        return simpleBoolean;
-    } 
-
-    public void setSimpleBoolean(boolean simpleBoolean) {
-        this.simpleBoolean = simpleBoolean;
-    } 
-
-    public byte getSimpleByte() {
-        return simpleByte;
-    } 
-
-    public void setSimpleByte(byte simpleByte) {
-        this.simpleByte = simpleByte;
-    } 
-
-    public short getSimpleShort() {
-        return simpleShort;
-    } 
-
-    public void setSimpleShort(short simpleShort) {
-        this.simpleShort = simpleShort;
-    } 
-
-    public int getSimpleInt() {
-        return simpleInt;
-    } 
-
-    public void setSimpleInt(int simpleInt) {
-        this.simpleInt = simpleInt;
-    } 
-
-    public long getSimpleLong() {
-        return simpleLong;
-    } 
-
-    public void setSimpleLong(long simpleLong) {
-        this.simpleLong = simpleLong;
-    } 
-
-    public float getSimpleFloat() {
-        return simpleFloat;
-    } 
-
-    public void setSimpleFloat(float simpleFloat) {
-        this.simpleFloat = simpleFloat;
-    } 
-
-    public double getSimpleDouble() {
-        return simpleDouble;
-    } 
-
-    public void setSimpleDouble(double simpleDouble) {
-        this.simpleDouble = simpleDouble;
-    } 
-
-    public String getSimpleString() {
-        return simpleString;
-    } 
-
-    public void setSimpleString(String simpleString) {
-        this.simpleString = simpleString;
-    } 
-
-    public byte[] getSimpleByteArray() {
-        return simpleByteArray;
-    } 
-
-    public void setSimpleByteArray(byte[] simpleByteArray) {
-        this.simpleByteArray = simpleByteArray;
-    } 
-
-}
diff --git a/PerformanceTestOrmLite/src/de/greenrobot/performance/ormlite/SimpleEntityNotNullHelper.java b/PerformanceTestOrmLite/src/de/greenrobot/performance/ormlite/SimpleEntityNotNullHelper.java
deleted file mode 100644
index 59078355..00000000
--- a/PerformanceTestOrmLite/src/de/greenrobot/performance/ormlite/SimpleEntityNotNullHelper.java
+++ /dev/null
@@ -1,22 +0,0 @@
-package de.greenrobot.performance.ormlite;
-
-public class SimpleEntityNotNullHelper {
-    protected static SimpleEntityNotNull createEntity(Long key) {
-        if (key == null) {
-            return null;
-        }
-        SimpleEntityNotNull entity = new SimpleEntityNotNull();
-        entity.setId(key);
-        entity.setSimpleBoolean(true);
-        entity.setSimpleByte(Byte.MAX_VALUE);
-        entity.setSimpleShort(Short.MAX_VALUE);
-        entity.setSimpleInt(Integer.MAX_VALUE);
-        entity.setSimpleLong(Long.MAX_VALUE);
-        entity.setSimpleFloat(Float.MAX_VALUE);
-        entity.setSimpleDouble(Double.MAX_VALUE);
-        entity.setSimpleString("greenrobot greenDAO");
-        byte[] bytes = { 42, -17, 23, 0, 127, -128 };
-        entity.setSimpleByteArray(bytes);
-        return entity;
-    }
-}
diff --git a/README.md b/README.md
index 2560bd88..1d966c34 100644
--- a/README.md
+++ b/README.md
@@ -2,37 +2,51 @@ greenDAO
 ========
 greenDAO is a light & fast ORM solution for Android that maps objects to SQLite databases. Being highly optimized for Android, greenDAO offers great performance and consumes minimal memory.
 
-**<font size="+1">Home page, documentation, and support links: http://greendao-orm.com/</font>**
+**<font size="+1">Home page, documentation, and support links: http://greenrobot.org/greendao/</font>**
 
 [![Build Status](https://travis-ci.org/greenrobot/greenDAO.svg?branch=master)](https://travis-ci.org/greenrobot/greenDAO)
 
 Features
 --------
-greenDAO has a unique set of features:
+greenDAO's unique set of features:
 
 * Rock solid: greenDAO has been around since 2011 and is used by countless famous apps
 * Super simple: concise and straight-forward API
 * Small: The library is <100K and it's just plain Java jar (no CPU dependent native parts)
 * Fast: Probably the fastest ORM for Android, driven by intelligent code generation
 * Safe and expressive query API: QueryBuilder uses property constants to avoid typos
-* V2.0.0 Powerful joins: query across entities and even chain joins for complex relations
-* V2.0.0 Flexible property types: use custom classes or enums to represent data in your entity
+* Powerful joins: query across entities and even chain joins for complex relations
+* Flexible property types: use custom classes or enums to represent data in your entity
 
 
 Add greenDAO to your project
 ----------------------------
-greenDAO is available on Maven Central. Please ensure that you are using the latest versions by [checking here](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22de.greenrobot%22%20AND%20a%3A%22greendao%22) [and here](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22de.greenrobot%22%20AND%20a%3A%22greendao-generator%22)
+greenDAO is available on Maven Central. Please ensure that you are using the latest versions by [checking here](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22org.greenrobot%22%20AND%20a%3A%22greendao%22) [and here](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22org.greenrobot%22%20AND%20a%3A%22greendao-generator%22)
 
 Gradle dependency for your Android app:
 ```
-    compile 'de.greenrobot:greendao:2.0.0'
+    compile 'org.greenrobot:greendao:2.2.1'
 ```
 
 Gradle dependency for your Java generator project:
 ```
-    compile 'de.greenrobot:greendao-generator:2.0.0'
+    compile 'org.greenrobot:greendao-generator:2.2.0'
 ```
+*Note:* to use encrypted databases using SQLCipher, you need to reference different artifacts (postfix '-encryption'). For all details, please refer to the documentation on [database encryption](http://greenrobot.org/greendao/documentation/database-encryption/).
 
+Homepage, Documentation, Links
+------------------------------
+For more details on greenDAO please check [greenDAO's website](http://greenrobot.org/greendao). Here are some direct links you may find useful:
+
+[Features](http://greenrobot.org/greendao/features/)
+
+[Documentation](http://greenrobot.org/greendao/documentation/)
+
+[Changelog](http://greenrobot.org/greendao/changelog/)
+
+[Technical FAQ](http://greenrobot.org/greendao/documentation/technical-faq/)
+
+[Non-Technical FAQ](http://greenrobot.org/greendao/documentation/faq/)
 
 Features in Beta
 ----------------
@@ -49,7 +63,7 @@ More Open Source by greenrobot
 ==============================
 [__EventBus__](https://github.com/greenrobot/EventBus) is a central publish/subscribe bus for Android with optional delivery threads, priorities, and sticky events. A great tool to decouple components (e.g. Activities, Fragments, logic components) from each other.
 
-[__greenrobot-common__](https://github.com/greenrobot/greenrobot-common) is a set of utility classes and hash functions for Android & Java projects.
+[__Essentials__](https://github.com/greenrobot/essentials) is a set of utility classes and hash functions for Android & Java projects.
 
 [Follow us on Google+](https://plus.google.com/b/114381455741141514652/+GreenrobotDe/posts) to stay up to date.
 
diff --git a/build.gradle b/build.gradle
index 0b3869be..6813a582 100644
--- a/build.gradle
+++ b/build.gradle
@@ -1,9 +1,26 @@
+if (JavaVersion.current().isJava8Compatible()) {
+    allprojects {
+        tasks.withType(Javadoc) {
+            options.addStringOption('Xdoclint:none', '-quiet')
+        }
+    }
+}
+
 subprojects {
     repositories {
         mavenCentral()
+        jcenter()
     }
 }
 
 task wrapper(type: Wrapper) {
-    gradleVersion = '2.4'
+    gradleVersion = '2.12'
+}
+
+ext {
+    buildToolsVersion = '23.0.1'
+    compileSdkVersion = 23
+
+    minSdkVersion = 4
+    targetSdkVersion = 19
 }
\ No newline at end of file
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
index b5166dad..2c6137b8 100644
Binary files a/gradle/wrapper/gradle-wrapper.jar and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index a198531e..e6f72f81 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Mon Jun 22 22:22:22 CEST 2015
+#Thu Mar 31 20:39:08 CEST 2016
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.4-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.12-all.zip
diff --git a/gradlew b/gradlew
index 91a7e269..9d82f789 100755
--- a/gradlew
+++ b/gradlew
@@ -42,11 +42,6 @@ case "`uname`" in
     ;;
 esac
 
-# For Cygwin, ensure paths are in UNIX format before anything is touched.
-if $cygwin ; then
-    [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
-fi
-
 # Attempt to set APP_HOME
 # Resolve links: $0 may be a link
 PRG="$0"
@@ -61,9 +56,9 @@ while [ -h "$PRG" ] ; do
     fi
 done
 SAVED="`pwd`"
-cd "`dirname \"$PRG\"`/" >&-
+cd "`dirname \"$PRG\"`/" >/dev/null
 APP_HOME="`pwd -P`"
-cd "$SAVED" >&-
+cd "$SAVED" >/dev/null
 
 CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
 
@@ -114,6 +109,7 @@ fi
 if $cygwin ; then
     APP_HOME=`cygpath --path --mixed "$APP_HOME"`
     CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+    JAVACMD=`cygpath --unix "$JAVACMD"`
 
     # We build the pattern for arguments to be converted via cygpath
     ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
diff --git a/gradlew.bat b/gradlew.bat
index 8a0b282a..5f192121 100644
--- a/gradlew.bat
+++ b/gradlew.bat
@@ -46,7 +46,7 @@ echo location of your Java installation.
 goto fail
 
 :init
-@rem Get command-line arguments, handling Windowz variants
+@rem Get command-line arguments, handling Windows variants
 
 if not "%OS%" == "Windows_NT" goto win9xME_args
 if "%@eval[2+2]" == "4" goto 4NT_args
diff --git a/settings.gradle b/settings.gradle
index 2a8691a1..c0b1fc57 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -1,3 +1,7 @@
 include 'DaoCore', 'DaoGenerator', 'DaoExampleGenerator'
-include 'DaoTest' // Travis needs some Android setup for this
-include 'DaoTestGenerator'
\ No newline at end of file
+include 'DaoTestBase'
+include 'DaoTest'
+include 'DaoTestPerformance'
+include 'DaoTestGenerator'
+include 'DaoExample'
+
