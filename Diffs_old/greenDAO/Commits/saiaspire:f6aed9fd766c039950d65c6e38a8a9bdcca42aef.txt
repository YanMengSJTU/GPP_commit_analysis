diff --git a/DaoCore/libs/commons-lang3-3.0.1.jar b/DaoCore/libs/commons-lang3-3.0.1.jar
new file mode 100644
index 00000000..911e8d89
Binary files /dev/null and b/DaoCore/libs/commons-lang3-3.0.1.jar differ
diff --git a/DaoCore/libs/guava-r09.jar b/DaoCore/libs/guava-r09.jar
new file mode 100644
index 00000000..f8da8b1c
Binary files /dev/null and b/DaoCore/libs/guava-r09.jar differ
diff --git a/DaoCore/src/de/greenrobot/dao/AbstractDao.java b/DaoCore/src/de/greenrobot/dao/AbstractDao.java
index af01658a..e84ea6fe 100644
--- a/DaoCore/src/de/greenrobot/dao/AbstractDao.java
+++ b/DaoCore/src/de/greenrobot/dao/AbstractDao.java
@@ -16,24 +16,26 @@
 
 package de.greenrobot.dao;
 
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-
 import android.database.CrossProcessCursor;
 import android.database.Cursor;
 import android.database.CursorWindow;
 import android.database.DatabaseUtils;
 import android.database.sqlite.SQLiteDatabase;
 import android.database.sqlite.SQLiteStatement;
+import com.google.common.collect.Lists;
+import org.apache.commons.lang3.StringUtils;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
 
 /**
  * Base class for all DAOs: Implements entity operations like insert, load, delete, and query.
- * 
+ *
  * This class is thread-safe.
- * 
+ *
  * @author Markus
- * 
+ *
  * @param <T>
  *            Entity type
  * @param <K>
@@ -100,7 +102,7 @@ public Property getPkProperty() {
 
     /**
      * Loads and entity for the given PK.
-     * 
+     *
      * @param key
      *            a PK value or null
      * @return The entity or null, if no entity matched the PK value
@@ -172,7 +174,7 @@ public boolean detach(T entity) {
 
     /**
      * Inserts the given entities in the database using a transaction.
-     * 
+     *
      * @param entities
      *            The entities to insert.
      */
@@ -182,7 +184,7 @@ public void insertInTx(Iterable<T> entities) {
 
     /**
      * Inserts the given entities in the database using a transaction.
-     * 
+     *
      * @param entities
      *            The entities to insert.
      */
@@ -193,7 +195,7 @@ public void insertInTx(T... entities) {
     /**
      * Inserts the given entities in the database using a transaction. The given entities will become tracked if the PK
      * is set.
-     * 
+     *
      * @param entities
      *            The entities to insert.
      * @param setPrimaryKey
@@ -207,7 +209,7 @@ public void insertInTx(Iterable<T> entities, boolean setPrimaryKey) {
     /**
      * Inserts or replaces the given entities in the database using a transaction. The given entities will become
      * tracked if the PK is set.
-     * 
+     *
      * @param entities
      *            The entities to insert.
      * @param setPrimaryKey
@@ -220,7 +222,7 @@ public void insertOrReplaceInTx(Iterable<T> entities, boolean setPrimaryKey) {
 
     /**
      * Inserts or replaces the given entities in the database using a transaction.
-     * 
+     *
      * @param entities
      *            The entities to insert.
      */
@@ -230,7 +232,7 @@ public void insertOrReplaceInTx(Iterable<T> entities) {
 
     /**
      * Inserts or replaces the given entities in the database using a transaction.
-     * 
+     *
      * @param entities
      *            The entities to insert.
      */
@@ -269,7 +271,7 @@ private void executeInsertInTx(SQLiteStatement stmt, Iterable<T> entities, boole
 
     /**
      * Insert an entity into the table associated with a concrete DAO.
-     * 
+     *
      * @return row ID of newly inserted entity
      */
     public long insert(T entity) {
@@ -279,7 +281,7 @@ public long insert(T entity) {
     /**
      * Insert an entity into the table associated with a concrete DAO <b>without</b> setting key property. Warning: This
      * may be faster, but the entity should not be used anymore. The entity also won't be attached to identy scope.
-     * 
+     *
      * @return row ID of newly inserted entity
      */
     public long insertWithoutSettingPk(T entity) {
@@ -292,7 +294,7 @@ public long insertWithoutSettingPk(T entity) {
 
     /**
      * Insert an entity into the table associated with a concrete DAO.
-     * 
+     *
      * @return row ID of newly inserted entity
      */
     public long insertOrReplace(T entity) {
@@ -465,7 +467,7 @@ private void deleteByKeyInsideSynchronized(K key, SQLiteStatement stmt) {
 
     /**
      * Deletes the given entities in the database using a transaction.
-     * 
+     *
      * @param entities
      *            The entities to delete.
      */
@@ -505,7 +507,7 @@ public void deleteInTx(Iterable<T> entities) {
 
     /**
      * Deletes the given entities in the database using a transaction.
-     * 
+     *
      * @param entities
      *            The entities to delete.
      */
@@ -563,7 +565,7 @@ protected void updateInsideSynchronized(T entity, SQLiteStatement stmt, boolean
 
     /**
      * Attaches the entity to the identity scope. Calls attachEntity(T entity).
-     * 
+     *
      * @param key
      *            Needed only for identity scope, pass null if there's none.
      * @param entity
@@ -582,7 +584,7 @@ protected final void attachEntity(K key, T entity, boolean lock) {
 
     /**
      * Sub classes with relations additionally set the DaoMaster here.
-     * 
+     *
      * @param entity
      *            The entitiy to attach
      * */
@@ -591,7 +593,7 @@ protected void attachEntity(T entity) {
 
     /**
      * Updates the given entities in the database using a transaction.
-     * 
+     *
      * @param entities
      *            The entities to insert.
      */
@@ -621,7 +623,7 @@ public void updateInTx(Iterable<T> entities) {
 
     /**
      * Updates the given entities in the database using a transaction.
-     * 
+     *
      * @param entities
      *            The entities to update.
      */
@@ -658,6 +660,20 @@ public SQLiteDatabase getDatabase() {
         return db;
     }
 
+    protected List<String> deserializeStringList(String stringList) {
+        if(stringList == null) {
+            return Lists.newArrayList();
+        }
+        return Lists.newArrayList(StringUtils.split(stringList, ","));
+    }
+
+    protected String serializeStringList(List<String> items) {
+        if(items == null) {
+            return null;
+        }
+        return StringUtils.join(items, ",");
+    }
+
     /** Reads the values from the current position of the given cursor and returns a new entity. */
     abstract protected T readEntity(Cursor cursor, int offset);
 
diff --git a/DaoCore/src/de/greenrobot/dao/DbUtils.java b/DaoCore/src/de/greenrobot/dao/DbUtils.java
index 62e5c976..be61b15b 100644
--- a/DaoCore/src/de/greenrobot/dao/DbUtils.java
+++ b/DaoCore/src/de/greenrobot/dao/DbUtils.java
@@ -16,15 +16,13 @@
 
 package de.greenrobot.dao;
 
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-
 import android.content.Context;
 import android.database.Cursor;
 import android.database.DatabaseUtils;
 import android.database.sqlite.SQLiteDatabase;
+import android.util.Log;
+
+import java.io.*;
 
 /** Database utils, for example to execute SQL scripts */
 // TODO add unit tests
@@ -36,7 +34,7 @@ public static void vacuum(SQLiteDatabase db) {
 
     /**
      * Calls {@link #executeSqlScript(Context, SQLiteDatabase, String, boolean)} with transactional set to true.
-     * 
+     *
      * @return number of statements executed.
      */
     public static int executeSqlScript(Context context, SQLiteDatabase db, String assetFilename) throws IOException {
@@ -48,7 +46,7 @@ public static int executeSqlScript(Context context, SQLiteDatabase db, String as
      * multiple SQL statements. Statements are split using a simple regular expression (something like
      * "semicolon before a line break"), not by analyzing the SQL syntax. This will work for many SQL files, but check
      * yours.
-     * 
+     *
      * @return number of statements executed.
      */
     public static int executeSqlScript(Context context, SQLiteDatabase db, String assetFilename, boolean transactional)
@@ -91,7 +89,7 @@ public static int executeSqlStatements(SQLiteDatabase db, String[] statements) {
 
     /**
      * Copies all available data from in to out without closing any stream.
-     * 
+     *
      * @return number of bytes copied
      */
     public static int copyAllBytes(InputStream in, OutputStream out) throws IOException {
@@ -133,4 +131,41 @@ public static void logTableDump(SQLiteDatabase db, String tablename) {
         }
     }
 
+    public static byte[] serializeObject(Object o) {
+        if(o == null) {
+            return null;
+        }
+        ByteArrayOutputStream bos = new ByteArrayOutputStream();
+        try {
+            ObjectOutput out = new ObjectOutputStream(bos);
+            out.writeObject(o);
+            out.close();
+
+            // Get the bytes of the serialized object
+            byte[] buf = bos.toByteArray();
+
+            return buf;
+        } catch(IOException ioe) {
+            Log.d("DBUTIL", "error" + ioe == null ? "null" : ioe.getMessage());
+            return null;
+        }
+    }
+
+    public static Object deserializeObject(byte[] b) {
+        if(b == null) {
+            return null;
+        }
+        try {
+            ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(b));
+            Object object = in.readObject();
+            in.close();
+
+            return object;
+        } catch(ClassNotFoundException cnfe) {
+            return null;
+        } catch(IOException ioe) {
+            return null;
+        }
+    }
+
 }
diff --git a/DaoGenerator/src-template/dao-master.ftl b/DaoGenerator/src-template/dao-master.ftl
index 7ead78a7..b22d6284 100644
--- a/DaoGenerator/src-template/dao-master.ftl
+++ b/DaoGenerator/src-template/dao-master.ftl
@@ -1,101 +1,101 @@
-<#--
-
-Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)     
-                                                                           
-This file is part of greenDAO Generator.                                   
-                                                                           
-greenDAO Generator is free software: you can redistribute it and/or modify 
-it under the terms of the GNU General Public License as published by       
-the Free Software Foundation, either version 3 of the License, or          
-(at your option) any later version.                                        
-greenDAO Generator is distributed in the hope that it will be useful,      
-but WITHOUT ANY WARRANTY; without even the implied warranty of             
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              
-GNU General Public License for more details.                               
-                                                                           
-You should have received a copy of the GNU General Public License          
-along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
-
--->
-package ${schema.defaultJavaPackageDao};
-
-import android.content.Context;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteDatabase.CursorFactory;
-import android.database.sqlite.SQLiteOpenHelper;
-import android.util.Log;
-import de.greenrobot.dao.AbstractDaoMaster;
-import de.greenrobot.dao.IdentityScopeType;
-
-<#list schema.entities as entity>
-import ${entity.javaPackageDao}.${entity.classNameDao};
-</#list>
-
-// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
-/** 
- * Master of DAO (schema version ${schema.version}): knows all DAOs.
-*/
-public class DaoMaster extends AbstractDaoMaster {
-    public static final int SCHEMA_VERSION = ${schema.version};
-
-    /** Creates underlying database table using DAOs. */
-    public static void createAllTables(SQLiteDatabase db, boolean ifNotExists) {
-<#list schema.entities as entity>
-<#if !entity.skipTableCreation>
-        ${entity.classNameDao}.createTable(db, ifNotExists);
-</#if>
-</#list>
-    }
-    
-    /** Drops underlying database table using DAOs. */
-    public static void dropAllTables(SQLiteDatabase db, boolean ifExists) {
-<#list schema.entities as entity>
-<#if !entity.skipTableCreation>
-        ${entity.classNameDao}.dropTable(db, ifExists);
-</#if>
-</#list>
-    }
-    
-    public static abstract class OpenHelper extends SQLiteOpenHelper {
-
-        public OpenHelper(Context context, String name, CursorFactory factory) {
-            super(context, name, factory, SCHEMA_VERSION);
-        }
-
-        @Override
-        public void onCreate(SQLiteDatabase db) {
-            Log.i("greenDAO", "Creating tables for schema version " + SCHEMA_VERSION);
-            createAllTables(db, false);
-        }
-    }
-    
-    /** WARNING: Drops all table on Upgrade! Use only during development. */
-    public static class DevOpenHelper extends OpenHelper {
-        public DevOpenHelper(Context context, String name, CursorFactory factory) {
-            super(context, name, factory);
-        }
-
-        @Override
-        public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
-            Log.i("greenDAO", "Upgrading schema from version " + oldVersion + " to " + newVersion + " by dropping all tables");
-            dropAllTables(db, true);
-            onCreate(db);
-        }
-    }
-
-    public DaoMaster(SQLiteDatabase db) {
-        super(db, SCHEMA_VERSION);
-<#list schema.entities as entity>
-        registerDaoClass(${entity.classNameDao}.class);
-</#list>
-    }
-    
-    public DaoSession newSession() {
-        return new DaoSession(db, IdentityScopeType.Session, daoConfigMap);
-    }
-    
-    public DaoSession newSession(IdentityScopeType type) {
-        return new DaoSession(db, type, daoConfigMap);
-    }
-    
-}
+<#--
+
+Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+
+This file is part of greenDAO Generator.
+
+greenDAO Generator is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+greenDAO Generator is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+
+-->
+package ${schema.defaultJavaPackageDao};
+
+import android.content.Context;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteDatabase.CursorFactory;
+import android.database.sqlite.SQLiteOpenHelper;
+import android.util.Log;
+import de.greenrobot.dao.AbstractDaoMaster;
+import de.greenrobot.dao.IdentityScopeType;
+
+<#list schema.entities as entity>
+import ${entity.javaPackageDao}.${entity.classNameDao};
+</#list>
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+/**
+ * Master of DAO (schema version ${schema.version}): knows all DAOs.
+*/
+public class DaoMaster extends AbstractDaoMaster {
+    public static final int SCHEMA_VERSION = ${schema.version?c};
+
+    /** Creates underlying database table using DAOs. */
+    public static void createAllTables(SQLiteDatabase db, boolean ifNotExists) {
+<#list schema.entities as entity>
+<#if !entity.skipTableCreation>
+        ${entity.classNameDao}.createTable(db, ifNotExists);
+</#if>
+</#list>
+    }
+
+    /** Drops underlying database table using DAOs. */
+    public static void dropAllTables(SQLiteDatabase db, boolean ifExists) {
+<#list schema.entities as entity>
+<#if !entity.skipTableCreation>
+        ${entity.classNameDao}.dropTable(db, ifExists);
+</#if>
+</#list>
+    }
+
+    public static abstract class OpenHelper extends SQLiteOpenHelper {
+
+        public OpenHelper(Context context, String name, CursorFactory factory) {
+            super(context, name, factory, SCHEMA_VERSION);
+        }
+
+        @Override
+        public void onCreate(SQLiteDatabase db) {
+            Log.i("greenDAO", "Creating tables for schema version " + SCHEMA_VERSION);
+            createAllTables(db, false);
+        }
+    }
+
+    /** WARNING: Drops all table on Upgrade! Use only during development. */
+    public static class DevOpenHelper extends OpenHelper {
+        public DevOpenHelper(Context context, String name, CursorFactory factory) {
+            super(context, name, factory);
+        }
+
+        @Override
+        public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+            Log.i("greenDAO", "Upgrading schema from version " + oldVersion + " to " + newVersion + " by dropping all tables");
+            dropAllTables(db, true);
+            onCreate(db);
+        }
+    }
+
+    public DaoMaster(SQLiteDatabase db) {
+        super(db, SCHEMA_VERSION);
+<#list schema.entities as entity>
+        registerDaoClass(${entity.classNameDao}.class);
+</#list>
+    }
+
+    public DaoSession newSession() {
+        return new DaoSession(db, IdentityScopeType.Session, daoConfigMap);
+    }
+
+    public DaoSession newSession(IdentityScopeType type) {
+        return new DaoSession(db, type, daoConfigMap);
+    }
+
+}
diff --git a/DaoGenerator/src-template/dao.ftl b/DaoGenerator/src-template/dao.ftl
index b9275906..a3a41652 100644
--- a/DaoGenerator/src-template/dao.ftl
+++ b/DaoGenerator/src-template/dao.ftl
@@ -1,300 +1,341 @@
-<#--
-
-Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)     
-                                                                           
-This file is part of greenDAO Generator.                                   
-                                                                           
-greenDAO Generator is free software: you can redistribute it and/or modify 
-it under the terms of the GNU General Public License as published by       
-the Free Software Foundation, either version 3 of the License, or          
-(at your option) any later version.                                        
-greenDAO Generator is distributed in the hope that it will be useful,      
-but WITHOUT ANY WARRANTY; without even the implied warranty of             
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              
-GNU General Public License for more details.                               
-                                                                           
-You should have received a copy of the GNU General Public License          
-along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
-
--->
-<#assign toBindType = {"Boolean":"Long", "Byte":"Long", "Short":"Long", "Int":"Long", "Long":"Long", "Float":"Double", "Double":"Double", "String":"String", "ByteArray":"Blob", "Date": "Long" } />
-<#assign toCursorType = {"Boolean":"Short", "Byte":"Short", "Short":"Short", "Int":"Int", "Long":"Long", "Float":"Float", "Double":"Double", "String":"String", "ByteArray":"Blob", "Date": "Long"  } />
-package ${entity.javaPackageDao};
-
-<#if entity.toOneRelations?has_content || entity.incomingToManyRelations?has_content>
-import java.util.List;
-</#if>
-<#if entity.toOneRelations?has_content>
-import java.util.ArrayList;
-</#if>
-import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteStatement;
-
-import de.greenrobot.dao.AbstractDao;
-import de.greenrobot.dao.DaoConfig;
-import de.greenrobot.dao.Property;
-<#if entity.toOneRelations?has_content>
-import de.greenrobot.dao.SqlUtils;
-</#if>
-<#if entity.incomingToManyRelations?has_content>
-import de.greenrobot.dao.Query;
-import de.greenrobot.dao.QueryBuilder;
-</#if>
-
-<#if entity.javaPackageDao != schema.defaultJavaPackageDao>
-import ${schema.defaultJavaPackageDao}.DaoSession;
-
-</#if>
-<#if entity.additionalImportsDao?has_content>
-<#list entity.additionalImportsDao as additionalImport>
-import ${additionalImport};
-</#list>
-
-</#if>
-import ${entity.javaPackage}.${entity.className};
-<#if entity.protobuf>
-import ${entity.javaPackage}.${entity.className}.Builder;
-</#if>
-
-// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
-/** 
- * DAO for table ${entity.tableName}.
-*/
-public class ${entity.classNameDao} extends AbstractDao<${entity.className}, ${entity.pkType}> {
-
-    public static final String TABLENAME = "${entity.tableName}";
-
-    /**
-     * Properties of entity ${entity.className}.<br/>
-     * Can be used for QueryBuilder and for referencing column names.
-    */
-    public static class Properties {
-<#list entity.propertiesColumns as property>
-        public final static Property ${property.propertyName?cap_first} = new Property(${property_index}, ${property.javaType}.class, "${property.propertyName}", ${property.primaryKey?string}, "${property.columnName}");
-</#list>
-    };
-
-<#if entity.active>
-    private DaoSession daoSession;
-
-</#if>
-<#list entity.incomingToManyRelations as toMany>
-    private Query<${toMany.targetEntity.className}> ${toMany.sourceEntity.className?uncap_first}_${toMany.name?cap_first}Query;
-</#list>
-
-    public ${entity.classNameDao}(DaoConfig config) {
-        super(config);
-    }
-    
-    public ${entity.classNameDao}(DaoConfig config, DaoSession daoSession) {
-        super(config, daoSession);
-<#if entity.active>        
-        this.daoSession = daoSession;
-</#if>
-    }
-
-<#if !entity.skipTableCreation>
-    /** Creates the underlying database table. */
-    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
-        String constraint = ifNotExists? "IF NOT EXISTS ": "";
-        db.execSQL("CREATE TABLE " + constraint + "'${entity.tableName}' (" + //
-<#list entity.propertiesColumns as property>
-                "'${property.columnName}' ${property.columnType}<#if property.constraints??> ${property.constraints} </#if><#if property_has_next>," +<#else>);");</#if> // ${property_index}: ${property.propertyName}
-</#list>
-<#if entity.indexes?has_content >
-        // Add Indexes
-<#list entity.indexes as index>
-        db.execSQL("CREATE <#if index.unique>UNIQUE </#if>INDEX " + constraint + "${index.name} ON ${entity.tableName}" +
-                " (<#list index.properties 
-as property>${property.columnName}<#if property_has_next>,</#if></#list>);");
-</#list>
-</#if>         
-    }
-
-    /** Drops the underlying database table. */
-    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
-        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'${entity.tableName}'";
-        db.execSQL(sql);
-    }
-
-</#if>
-    /** @inheritdoc */
-    @Override
-    protected void bindValues(SQLiteStatement stmt, ${entity.className} entity) {
-        stmt.clearBindings();
-<#list entity.properties as property>
-<#if property.notNull || entity.protobuf>
-<#if entity.protobuf>
-        if(entity.has${property.propertyName?cap_first}()) {
-    </#if>        stmt.bind${toBindType[property.propertyType]}(${property_index + 1}, entity.get${property.propertyName?cap_first}()<#if
-     property.propertyType == "Boolean"> ? 1l: 0l</#if><#if property.propertyType == "Date">.getTime()</#if>);
-<#if entity.protobuf>
-        }
-</#if>
-<#else> <#-- nullable, non-protobuff -->
-        ${property.javaType} ${property.propertyName} = entity.get${property.propertyName?cap_first}();
-        if (${property.propertyName} != null) {
-            stmt.bind${toBindType[property.propertyType]}(${property_index + 1}, ${property.propertyName}<#if
- property.propertyType == "Boolean"> ? 1l: 0l</#if><#if property.propertyType == "Date">.getTime()</#if>);
-        }
-</#if>
-</#list>
-<#list entity.toOneRelations as toOne>
-<#if !toOne.fkProperties?has_content>
-
-        ${toOne.targetEntity.className} ${toOne.name} = entity.peak${toOne.name?cap_first}();
-        if(${toOne.name} != null) {
-            ${toOne.targetEntity.pkProperty.javaType} ${toOne.name}__targetKey = ${toOne.name}.get${toOne.targetEntity.pkProperty.propertyName?cap_first}();
-<#if !toOne.targetEntity.pkProperty.notNull>
-            if(${toOne.name}__targetKey != null) {
-                // TODO bind ${toOne.name}__targetKey
-            }
-<#else>
-            // TODO bind ${toOne.name}__targetKey
-</#if>
-        }
-</#if>
-</#list>
-    }
-
-<#if entity.active>
-    @Override
-    protected void attachEntity(${entity.className} entity) {
-        super.attachEntity(entity);
-        entity.__setDaoSession(daoSession);
-    }
-
-</#if>
-    /** @inheritdoc */
-    @Override
-    public ${entity.pkType} readKey(Cursor cursor, int offset) {
-<#if entity.pkProperty??>
-        return <#if !entity.pkProperty.notNull>cursor.isNull(offset + ${entity.pkProperty.ordinal}) ? null : </#if><#if
-            entity.pkProperty.propertyType == "Byte">(byte) </#if><#if
-            entity.pkProperty.propertyType == "Date">new java.util.Date(</#if>cursor.get${toCursorType[entity.pkProperty.propertyType]}(offset + ${entity.pkProperty.ordinal})<#if
-            entity.pkProperty.propertyType == "Boolean"> != 0</#if><#if
-            entity.pkProperty.propertyType == "Date">)</#if>;
-<#else>
-        return null;
-</#if>  
-    }    
-
-    /** @inheritdoc */
-    @Override
-    public ${entity.className} readEntity(Cursor cursor, int offset) {
-<#if entity.protobuf>
-        Builder builder = ${entity.className}.newBuilder();
-<#list entity.properties as property>
-<#if !property.notNull>
-        if (!cursor.isNull(offset + ${property_index})) {
-    </#if>        builder.set${property.propertyName?cap_first}(cursor.get${toCursorType[property.propertyType]}(offset + ${property_index}));
-<#if !property.notNull>
-        }
-</#if>        
-</#list>        
-        return builder.build();
-<#elseif entity.constructors>
-<#--
-############################## readEntity non-protobuff, constructor ############################## 
--->
-        ${entity.className} entity = new ${entity.className}( //
-<#list entity.properties as property>
-            <#if !property.notNull>cursor.isNull(offset + ${property_index}) ? null : </#if><#if
-            property.propertyType == "Byte">(byte) </#if><#if
-            property.propertyType == "Date">new java.util.Date(</#if>cursor.get${toCursorType[property.propertyType]}(offset + ${property_index})<#if
-            property.propertyType == "Boolean"> != 0</#if><#if
-            property.propertyType == "Date">)</#if><#if property_has_next>,</#if> // ${property.propertyName}
-</#list>        
-        );
-        return entity;
-<#else>
-<#--
-############################## readEntity non-protobuff, setters ############################## 
--->
-        ${entity.className} entity = new ${entity.className}();
-        readEntity(cursor, entity, offset);
-        return entity;
-</#if>
-    }
-     
-    /** @inheritdoc */
-    @Override
-    public void readEntity(Cursor cursor, ${entity.className} entity, int offset) {
-<#if entity.protobuf>
-        throw new UnsupportedOperationException("Protobuf objects cannot be modified");
-<#else> 
-<#list entity.properties as property>
-        entity.set${property.propertyName?cap_first}(<#if !property.notNull>cursor.isNull(offset + ${property_index}) ? null : </#if><#if
-            property.propertyType == "Byte">(byte) </#if><#if
-            property.propertyType == "Date">new java.util.Date(</#if>cursor.get${toCursorType[property.propertyType]}(offset + ${property_index})<#if
-            property.propertyType == "Boolean"> != 0</#if><#if
-            property.propertyType == "Date">)</#if>);
-</#list>
-</#if>
-     }
-    
-    /** @inheritdoc */
-    @Override
-    protected ${entity.pkType} updateKeyAfterInsert(${entity.className} entity, long rowId) {
-<#if entity.pkProperty??>
-<#if entity.pkProperty.propertyType == "Long">
-<#if !entity.protobuf>
-        entity.set${entity.pkProperty.propertyName?cap_first}(rowId);
-</#if>
-        return rowId;
-<#else>
-        return entity.get${entity.pkProperty.propertyName?cap_first}();
-</#if>
-<#else>
-        // Unsupported or missing PK type
-        return null;
-</#if>
-    }
-    
-    /** @inheritdoc */
-    @Override
-    public ${entity.pkType} getKey(${entity.className} entity) {
-<#if entity.pkProperty??>
-        if(entity != null) {
-            return entity.get${entity.pkProperty.propertyName?cap_first}();
-        } else {
-            return null;
-        }
-<#else>
-        return null;
-</#if>    
-    }
-
-    /** @inheritdoc */
-    @Override    
-    protected boolean isEntityUpdateable() {
-        return ${(!entity.protobuf)?string};
-    }
-    
-<#list entity.incomingToManyRelations as toMany>
-    /** Internal query to resolve the "${toMany.name}" to-many relationship of ${toMany.sourceEntity.className}. */
-    public synchronized List<${toMany.targetEntity.className}> _query${toMany.sourceEntity.className?cap_first}_${toMany.name?cap_first}(<#--
-    --><#list toMany.targetProperties as property>${property.javaType} ${property.propertyName}<#if property_has_next>, </#if></#list>) {
-        if (${toMany.sourceEntity.className?uncap_first}_${toMany.name?cap_first}Query == null) {
-            QueryBuilder<${toMany.targetEntity.className}> queryBuilder = queryBuilder();
-<#list toMany.targetProperties as property>
-            queryBuilder.where(Properties.${property.propertyName?cap_first}.eq(${property.propertyName}));
-</#list>
-<#if toMany.order?has_content>
-            queryBuilder.orderRaw("${toMany.order}");
-</#if>
-            ${toMany.sourceEntity.className?uncap_first}_${toMany.name?cap_first}Query = queryBuilder.build();
-        } else {
-<#list toMany.targetProperties as property>
-            ${toMany.sourceEntity.className?uncap_first}_${toMany.name?cap_first}Query.setParameter(${property_index}, ${property.propertyName});
-</#list>
-        }
-        return ${toMany.sourceEntity.className?uncap_first}_${toMany.name?cap_first}Query.list();
-    }
-
-</#list>   
-<#if entity.toOneRelations?has_content>
-    <#include "dao-deep.ftl">
-</#if>
-}
+<#--
+
+Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+
+This file is part of greenDAO Generator.
+
+greenDAO Generator is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+greenDAO Generator is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+
+-->
+<#assign toBindType = {"Boolean":"Long", "Byte":"Long", "Short":"Long", "Int":"Long", "Long":"Long", "Float":"Double", "Double":"Double", "String":"String", "ByteArray":"Blob", "Date": "Long", "StringList" : "String"} />
+<#assign toCursorType = {"Boolean":"Short", "Byte":"Short", "Short":"Short", "Int":"Int", "Long":"Long", "Float":"Float", "Double":"Double", "String":"String", "ByteArray":"Blob", "Date": "Long", "StringList", "String"} />
+
+<#assign serializers = {"StringList", "serializeStringList"} />
+<#assign deSerializers = {"StringList", "deserializeStringList"} />
+
+<#macro print_class type>
+    <#if type == "java.util.List<String>">
+        java.util.List.class
+    <#else>
+        ${type}.class
+    </#if>
+</#macro>
+package ${entity.javaPackageDao};
+
+<#if entity.toOneRelations?has_content || entity.incomingToManyRelations?has_content>
+import java.util.List;
+</#if>
+<#if entity.toOneRelations?has_content>
+import java.util.ArrayList;
+</#if>
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteStatement;
+
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.DaoConfig;
+import de.greenrobot.dao.Property;
+<#if entity.toOneRelations?has_content>
+import de.greenrobot.dao.SqlUtils;
+</#if>
+<#if entity.incomingToManyRelations?has_content>
+import de.greenrobot.dao.Query;
+import de.greenrobot.dao.QueryBuilder;
+</#if>
+
+<#if entity.javaPackageDao != schema.defaultJavaPackageDao>
+import ${schema.defaultJavaPackageDao}.DaoSession;
+
+</#if>
+<#if entity.additionalImportsDao?has_content>
+<#list entity.additionalImportsDao as additionalImport>
+import ${additionalImport};
+</#list>
+
+</#if>
+import ${entity.javaPackage}.${entity.className};
+<#if entity.protobuf>
+import ${entity.javaPackage}.${entity.className}.Builder;
+</#if>
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+/**
+ * DAO for table ${entity.tableName}.
+*/
+public class ${entity.classNameDao} extends AbstractDao<${entity.className}, ${entity.pkType}> {
+
+    public static final String TABLENAME = "${entity.tableName}";
+
+    /**
+     * Properties of entity ${entity.className}.<br/>
+     * Can be used for QueryBuilder and for referencing column names.
+    */
+    public static class Properties {
+<#list entity.propertiesColumns as property>
+        public final static Property ${property.propertyName?cap_first} =<#rt>
+        <@compress single_line=true>
+        new Property(${property_index},
+        <@print_class property.javaType/>,
+        "${property.propertyName}",
+        ${property.primaryKey?string},
+        "${property.columnName}");
+        </@compress>
+
+</#list>
+    };
+
+<#if entity.active>
+    private DaoSession daoSession;
+
+</#if>
+<#list entity.incomingToManyRelations as toMany>
+    private Query<${toMany.targetEntity.className}> ${toMany.sourceEntity.className?uncap_first}_${toMany.name?cap_first}Query;
+</#list>
+
+    public ${entity.classNameDao}(DaoConfig config) {
+        super(config);
+    }
+
+    public ${entity.classNameDao}(DaoConfig config, DaoSession daoSession) {
+        super(config, daoSession);
+<#if entity.active>
+        this.daoSession = daoSession;
+</#if>
+    }
+
+<#if !entity.skipTableCreation>
+    /** Creates the underlying database table. */
+    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+        String constraint = ifNotExists? "IF NOT EXISTS ": "";
+        db.execSQL("CREATE TABLE " + constraint + "'${entity.tableName}' (" + //
+<#list entity.propertiesColumns as property>
+                "'${property.columnName}' ${property.columnType}<#if property.constraints??> ${property.constraints} </#if><#if property_has_next>," +<#else>);");</#if> // ${property_index}: ${property.propertyName}
+</#list>
+<#if entity.indexes?has_content >
+        // Add Indexes
+<#list entity.indexes as index>
+        db.execSQL("CREATE <#if index.unique>UNIQUE </#if>INDEX " + constraint + "${index.name} ON ${entity.tableName}" +
+                " (<#list index.properties
+as property>${property.columnName}<#if property_has_next>,</#if></#list>);");
+</#list>
+</#if>
+    }
+
+    /** Drops the underlying database table. */
+    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'${entity.tableName}'";
+        db.execSQL(sql);
+    }
+
+</#if>
+    /** @inheritdoc */
+    @Override
+    protected void bindValues(SQLiteStatement stmt, ${entity.className} entity) {
+        stmt.clearBindings();
+        entity.onBeforeSave();
+<#list entity.properties as property>
+<#if property.notNull || entity.protobuf>
+<#if entity.protobuf>
+        if(entity.has${property.propertyName?cap_first}()) {
+    </#if>        stmt.bind${toBindType[property.propertyType]}(${property_index + 1}, entity.get${property.propertyName?cap_first}()<#if
+     property.propertyType == "Boolean"> ? 1l: 0l</#if><#if property.propertyType == "Date">.getTime()</#if>);
+<#if entity.protobuf>
+        }
+</#if>
+<#else> <#-- nullable, non-protobuff -->
+        ${property.javaType} ${property.propertyName} = entity.get${property.propertyName?cap_first}();
+        if (${property.propertyName} != null) {
+            <#if serializers[property.propertyType]?? >
+            stmt.bind${toBindType[property.propertyType]}(${property_index + 1}, ${serializers[property.propertyType]}(${property.propertyName}<#if
+ property.propertyType == "Boolean"> ? 1l: 0l</#if><#if property.propertyType == "Date">.getTime()</#if>));
+            <#else>
+            stmt.bind${toBindType[property.propertyType]}(${property_index + 1}, ${property.propertyName}<#if
+ property.propertyType == "Boolean"> ? 1l: 0l</#if><#if property.propertyType == "Date">.getTime()</#if>);
+            </#if>
+
+        }
+</#if>
+</#list>
+<#list entity.toOneRelations as toOne>
+<#if !toOne.fkProperties?has_content>
+
+        ${toOne.targetEntity.className} ${toOne.name} = entity.peak${toOne.name?cap_first}();
+        if(${toOne.name} != null) {
+            ${toOne.targetEntity.pkProperty.javaType} ${toOne.name}__targetKey = ${toOne.name}.get${toOne.targetEntity.pkProperty.propertyName?cap_first}();
+<#if !toOne.targetEntity.pkProperty.notNull>
+            if(${toOne.name}__targetKey != null) {
+                // TODO bind ${toOne.name}__targetKey
+            }
+<#else>
+            // TODO bind ${toOne.name}__targetKey
+</#if>
+        }
+</#if>
+</#list>
+    }
+
+<#if entity.active>
+    @Override
+    protected void attachEntity(${entity.className} entity) {
+        super.attachEntity(entity);
+        entity.__setDaoSession(daoSession);
+    }
+
+</#if>
+    /** @inheritdoc */
+    @Override
+    public ${entity.pkType} readKey(Cursor cursor, int offset) {
+<#if entity.pkProperty??>
+        return <#if !entity.pkProperty.notNull>cursor.isNull(offset + ${entity.pkProperty.ordinal}) ? null : </#if><#if
+            entity.pkProperty.propertyType == "Byte">(byte) </#if><#if
+            entity.pkProperty.propertyType == "Date">new java.util.Date(</#if>cursor.get${toCursorType[entity.pkProperty.propertyType]}(offset + ${entity.pkProperty.ordinal})<#if
+            entity.pkProperty.propertyType == "Boolean"> != 0</#if><#if
+            entity.pkProperty.propertyType == "Date">)</#if>;
+<#else>
+        return null;
+</#if>
+    }
+
+    /** @inheritdoc */
+    @Override
+    public ${entity.className} readEntity(Cursor cursor, int offset) {
+<#if entity.protobuf>
+        Builder builder = ${entity.className}.newBuilder();
+<#list entity.properties as property>
+<#if !property.notNull>
+        if (!cursor.isNull(offset + ${property_index})) {
+    </#if>        builder.set${property.propertyName?cap_first}(cursor.get${toCursorType[property.propertyType]}(offset + ${property_index}));
+<#if !property.notNull>
+        }
+</#if>
+</#list>
+        return builder.build();
+<#elseif entity.constructors>
+<#--
+############################## readEntity non-protobuff, constructor ##############################
+-->
+        ${entity.className} entity = new ${entity.className}( //
+<#list entity.properties as property>
+
+            <#if !property.notNull>cursor.isNull(offset + ${property_index}) ? null : </#if><#rt>
+            <@compress single_line=true>
+            <#if property.propertyType == "Byte">(byte) </#if>
+            <#if deSerializers[property.propertyType]??>${deSerializers[property.propertyType]}(</#if>
+            <#if property.propertyType == "Date">new java.util.Date(</#if>
+                cursor.get${toCursorType[property.propertyType]}(offset + ${property_index})
+            <#if property.propertyType == "Boolean"> != 0</#if>
+            <#if property.propertyType == "Date">)</#if>
+            <#if deSerializers[property.propertyType]??>)</#if>
+            <#if property_has_next>,</#if> // ${property.propertyName}
+            </@compress>
+</#list>
+
+        );
+        return entity;
+<#else>
+<#--
+############################## readEntity non-protobuff, setters ##############################
+-->
+        ${entity.className} entity = new ${entity.className}();
+        readEntity(cursor, entity, offset);
+        return entity;
+</#if>
+    }
+
+    /** @inheritdoc */
+    @Override
+    public void readEntity(Cursor cursor, ${entity.className} entity, int offset) {
+<#if entity.protobuf>
+        throw new UnsupportedOperationException("Protobuf objects cannot be modified");
+<#else>
+<#list entity.properties as property>
+        entity.set${property.propertyName?cap_first}(<#rt>
+        <@compress single_line=true>
+        <#if !property.notNull>cursor.isNull(offset + ${property_index}) ? null : </#if>
+        <#if property.propertyType == "Byte">(byte) </#if>
+        <#if property.propertyType == "Date">new java.util.Date(</#if>
+        <#if deSerializers[property.propertyType]??>${deSerializers[property.propertyType]}(</#if>
+        cursor.get${toCursorType[property.propertyType]}(offset + ${property_index})
+        <#if property.propertyType == "Boolean"> != 0</#if>
+        <#if property.propertyType == "Date">)</#if>
+        <#if deSerializers[property.propertyType]??>)</#if>);
+        </@compress>
+
+</#list>
+</#if>
+     }
+
+    /** @inheritdoc */
+    @Override
+    protected ${entity.pkType} updateKeyAfterInsert(${entity.className} entity, long rowId) {
+<#if entity.pkProperty??>
+<#if entity.pkProperty.propertyType == "Long">
+<#if !entity.protobuf>
+        entity.set${entity.pkProperty.propertyName?cap_first}(rowId);
+</#if>
+        return rowId;
+<#else>
+        return entity.get${entity.pkProperty.propertyName?cap_first}();
+</#if>
+<#else>
+        // Unsupported or missing PK type
+        return null;
+</#if>
+    }
+
+    /** @inheritdoc */
+    @Override
+    public ${entity.pkType} getKey(${entity.className} entity) {
+<#if entity.pkProperty??>
+        if(entity != null) {
+            return entity.get${entity.pkProperty.propertyName?cap_first}();
+        } else {
+            return null;
+        }
+<#else>
+        return null;
+</#if>
+    }
+
+    /** @inheritdoc */
+    @Override
+    protected boolean isEntityUpdateable() {
+        return ${(!entity.protobuf)?string};
+    }
+
+<#list entity.incomingToManyRelations as toMany>
+    /** Internal query to resolve the "${toMany.name}" to-many relationship of ${toMany.sourceEntity.className}. */
+    public synchronized List<${toMany.targetEntity.className}> _query${toMany.sourceEntity.className?cap_first}_${toMany.name?cap_first}(<#--
+    --><#list toMany.targetProperties as property>${property.javaType} ${property.propertyName}<#if property_has_next>, </#if></#list>) {
+        if (${toMany.sourceEntity.className?uncap_first}_${toMany.name?cap_first}Query == null) {
+            QueryBuilder<${toMany.targetEntity.className}> queryBuilder = queryBuilder();
+<#list toMany.targetProperties as property>
+            queryBuilder.where(Properties.${property.propertyName?cap_first}.eq(${property.propertyName}));
+</#list>
+<#if toMany.order?has_content>
+            queryBuilder.orderRaw("${toMany.order}");
+</#if>
+            ${toMany.sourceEntity.className?uncap_first}_${toMany.name?cap_first}Query = queryBuilder.build();
+        } else {
+<#list toMany.targetProperties as property>
+            ${toMany.sourceEntity.className?uncap_first}_${toMany.name?cap_first}Query.setParameter(${property_index}, ${property.propertyName});
+</#list>
+        }
+        return ${toMany.sourceEntity.className?uncap_first}_${toMany.name?cap_first}Query.list();
+    }
+
+</#list>
+<#if entity.toOneRelations?has_content>
+    <#include "dao-deep.ftl">
+</#if>
+}
diff --git a/DaoGenerator/src-template/entity-base.ftl b/DaoGenerator/src-template/entity-base.ftl
index 79d860dc..edcc72d7 100644
--- a/DaoGenerator/src-template/entity-base.ftl
+++ b/DaoGenerator/src-template/entity-base.ftl
@@ -1,257 +1,293 @@
-<#include "*/annotation.ftl">
-<#--
-
-Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
-
-This file is part of greenDAO Generator.
-
-greenDAO Generator is free software: you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation, either version 3 of the License, or
-(at your option) any later version.
-greenDAO Generator is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
-
--->
-
-<#assign toBindType = {"Boolean":"Long", "Byte":"Long", "Short":"Long", "Int":"Long", "Long":"Long", "Float":"Double", "Double":"Double", "String":"String", "ByteArray":"Blob" }/>
-<#assign toCursorType = {"Boolean":"Short", "Byte":"Short", "Short":"Short", "Int":"Int", "Long":"Long", "Float":"Float", "Double":"Double", "String":"String", "ByteArray":"Blob" }/>
-<#assign complexTypes = ["String", "ByteArray", "Date"]/>
-package ${entity.javaPackage};
-
-<#if entity.toManyRelations?has_content>
-import java.util.List;
-</#if>
-<#if entity.active>
-import ${schema.defaultJavaPackageDao}.DaoSession;
-import de.greenrobot.dao.DaoException;
-
-</#if>
-<#if entity.additionalImportsEntity?has_content>
-<#list entity.additionalImportsEntity as additionalImport>
-import ${additionalImport};
-</#list>
-
-</#if>
-<#if entity.hasKeepSections>
-// THIS CODE IS GENERATED BY greenDAO, EDIT ONLY INSIDE THE "KEEP"-SECTIONS
-
-// KEEP INCLUDES - put your custom includes here
-<#if keepIncludes?has_content>${keepIncludes!}</#if>// KEEP INCLUDES END
-<#else>
-// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit.
-</#if>
-/**
- * Entity mapped to table ${entity.tableName}.
- */
-<@print_annotations entity.annotations, ""/>
-abstract public class ${entity.classNameBase}<#if
-entity.superclass?has_content> extends ${entity.superclass} </#if><#if
-entity.interfacesToImplement?has_content> implements <#list entity.interfacesToImplement
-as ifc>${ifc}<#if ifc_has_next>, </#if></#list></#if> {
-
-<#list entity.properties as property>
-<#if property.notNull && complexTypes?seq_contains(property.propertyType)>
-    /** Not-null value. */
-</#if>
-    <@print_annotations property.fieldAnnotations, "    "/>
-    protected ${property.javaType} ${property.propertyName};
-</#list>
-
-<#if entity.active>
-    /** Used to resolve relations */
-    protected transient DaoSession daoSession;
-
-    /** Used for active entity operations. */
-    protected transient ${entity.classNameDao} myDao;
-
-<#list entity.toOneRelations as toOne>
-    protected ${toOne.targetEntity.className} ${toOne.name};
-<#if toOne.useFkProperty>
-    protected ${toOne.resolvedKeyJavaType[0]} ${toOne.name}__resolvedKey;
-<#else>
-    protected boolean ${toOne.name}__refreshed;
-</#if>
-
-</#list>
-<#list entity.toManyRelations as toMany>
-    protected List<${toMany.targetEntity.className}> ${toMany.name};
-</#list>
-
-</#if>
-<#if entity.hasKeepSections>
-    // KEEP FIELDS - put your custom fields here
-${keepFields!}    // KEEP FIELDS END
-
-</#if>
-<#if entity.constructors>
-    <@print_annotations entity.emptyConstructorAnnotations, "    "/>
-    public ${entity.classNameBase}() {
-    }
-<#if entity.propertiesPk?has_content && entity.propertiesPk?size != entity.properties?size>
-
-    public ${entity.classNameBase}(<#list entity.propertiesPk as
-property>${property.javaType} ${property.propertyName}<#if property_has_next>, </#if></#list>) {
-<#list entity.propertiesPk as property>
-        this.${property.propertyName} = ${property.propertyName};
-</#list>
-    }
-</#if>
-
-    <@print_annotations entity.fullConstructorAnnotations, "    "/>
-    public ${entity.classNameBase}(<#list entity.properties as
-property>${property.javaType} ${property.propertyName}<#if property_has_next>, </#if></#list>) {
-<#list entity.properties as property>
-        this.${property.propertyName} = ${property.propertyName};
-</#list>
-    }
-</#if>
-
-<#if entity.active>
-    /** called by internal mechanisms, do not call yourself. */
-    public void __setDaoSession(DaoSession daoSession) {
-        this.daoSession = daoSession;
-        myDao = daoSession != null ? daoSession.get${entity.classNameDao?cap_first}() : null;
-    }
-
-</#if>
-<#list entity.properties as property>
-<#if property.notNull && complexTypes?seq_contains(property.propertyType)>
-    /** Not-null value. */
-</#if>
-    <@print_annotations property.getterAnnotations, "    "/>
-    public ${property.javaType} get${property.propertyName?cap_first}() {
-        return ${property.propertyName};
-    }
-
-<#if property.notNull && complexTypes?seq_contains(property.propertyType)>
-    /** Not-null value; ensure this value is available before it is saved to the database. */
-</#if>
-    <@print_annotations property.setterAnnotations, "    "/>
-    public void set${property.propertyName?cap_first}(${property.javaType} ${property.propertyName}) {
-        this.${property.propertyName} = ${property.propertyName};
-    }
-
-</#list>
-<#--
-##########################################
-########## To-One Relations ##############
-##########################################
--->
-<#list entity.toOneRelations as toOne>
-    /** To-one relationship, resolved on first access. */
-    public ${toOne.targetEntity.className} get${toOne.name?cap_first}() {
-<#if toOne.useFkProperty>
-        if (${toOne.name}__resolvedKey == null || <#--
-        --><#if toOne.resolvedKeyUseEquals[0]>!${toOne.name}__resolvedKey.equals(${toOne.fkProperties[0].propertyName})<#--
-        --><#else>${toOne.name}__resolvedKey != ${toOne.fkProperties[0].propertyName}</#if>) {
-            if (daoSession == null) {
-                throw new DaoException("Entity is detached from DAO context");
-            }
-            ${toOne.targetEntity.classNameDao} targetDao = daoSession.get${toOne.targetEntity.classNameDao?cap_first}();
-            ${toOne.name} = targetDao.load(${toOne.fkProperties[0].propertyName});
-            ${toOne.name}__resolvedKey = ${toOne.fkProperties[0].propertyName};
-        }
-<#else>
-        if (${toOne.name} != null || !${toOne.name}__refreshed) {
-            if (daoSession == null) {
-                throw new DaoException("Entity is detached from DAO context");
-            }
-            ${toOne.targetEntity.classNameDao} targetDao = daoSession.get${toOne.targetEntity.classNameDao?cap_first}();
-            targetDao.refresh(${toOne.name});
-            ${toOne.name}__refreshed = true;
-        }
-</#if>
-        return ${toOne.name};
-    }
-<#if !toOne.useFkProperty>
-
-    /** To-one relationship, returned entity is not refreshed and may carry only the PK property. */
-    public ${toOne.targetEntity.className} peak${toOne.name?cap_first}() {
-        return ${toOne.name};
-    }
-</#if>
-
-    public void set${toOne.name?cap_first}(${toOne.targetEntity.className} ${toOne.name}) {
-<#if toOne.fkProperties[0].notNull>
-        if (${toOne.name} == null) {
-            throw new DaoException("To-one property '${toOne.fkProperties[0].propertyName}' has not-null constraint; cannot set to-one to null");
-        }
-</#if>
-        this.${toOne.name} = ${toOne.name};
-<#if toOne.useFkProperty>
-        ${toOne.fkProperties[0].propertyName} = <#if !toOne.fkProperties[0].notNull>${toOne.name} == null ? null : </#if>${toOne.name}.get${toOne.targetEntity.pkProperty.propertyName?cap_first}();
-        ${toOne.name}__resolvedKey = ${toOne.fkProperties[0].propertyName};
-<#else>
-        ${toOne.name}__refreshed = true;
-</#if>
-    }
-
-</#list>
-<#--
-##########################################
-########## To-Many Relations #############
-##########################################
--->
-<#list entity.toManyRelations as toMany>
-    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
-    public synchronized List<${toMany.targetEntity.className}> get${toMany.name?cap_first}() {
-        if (${toMany.name} == null) {
-            if (daoSession == null) {
-                throw new DaoException("Entity is detached from DAO context");
-            }
-            ${toMany.targetEntity.classNameDao} targetDao = daoSession.get${toMany.targetEntity.classNameDao?cap_first}();
-            ${toMany.name} = targetDao._query${toMany.sourceEntity.className?cap_first}_${toMany.name?cap_first}(<#--
-                --><#list toMany.sourceProperties as property>${property.propertyName}<#if property_has_next>, </#if></#list>);
-        }
-        return ${toMany.name};
-    }
-
-    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
-    public synchronized void reset${toMany.name?cap_first}() {
-        ${toMany.name} = null;
-    }
-
-</#list>
-<#--
-##########################################
-########## Active entity operations ######
-##########################################
--->
-<#if entity.active>
-    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
-    public void delete() {
-        if (myDao == null) {
-            throw new DaoException("Entity is detached from DAO context");
-        }
-        myDao.delete((${entity.className})this);
-    }
-
-    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
-    public void update() {
-        if (myDao == null) {
-            throw new DaoException("Entity is detached from DAO context");
-        }
-        myDao.update((${entity.className})this);
-    }
-
-    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
-    public void refresh() {
-        if (myDao == null) {
-            throw new DaoException("Entity is detached from DAO context");
-        }
-        myDao.refresh((${entity.className})this);
-    }
-
-</#if>
-<#if entity.hasKeepSections>
-    // KEEP METHODS - put your custom methods here
-${keepMethods!}    // KEEP METHODS END
-
-</#if>
-}
+<#include "*/annotation.ftl">
+<#include "*/serialize-helper.ftl">
+<#--
+
+Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+
+This file is part of greenDAO Generator.
+
+greenDAO Generator is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+greenDAO Generator is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+
+-->
+
+<#assign toBindType = {"Boolean":"Long", "Byte":"Long", "Short":"Long", "Int":"Long", "Long":"Long", "Float":"Double", "Double":"Double", "String":"String", "ByteArray":"Blob" }/>
+<#assign toCursorType = {"Boolean":"Short", "Byte":"Short", "Short":"Short", "Int":"Int", "Long":"Long", "Float":"Float", "Double":"Double", "String":"String", "ByteArray":"Blob" }/>
+<#assign complexTypes = ["String", "ByteArray", "Date"]/>
+package ${entity.javaPackage};
+
+<#if entity.toManyRelations?has_content>
+import java.util.List;
+</#if>
+<#if entity.active>
+import ${schema.defaultJavaPackageDao}.DaoSession;
+import de.greenrobot.dao.DaoException;
+
+</#if>
+<#if entity.additionalImportsEntity?has_content>
+<#list entity.additionalImportsEntity as additionalImport>
+import ${additionalImport};
+</#list>
+</#if>
+
+<#if entity.serializedProperties?has_content>
+import de.greenrobot.dao.DbUtils;
+</#if>
+
+<#list entity.serializedProperties as serialized>
+    <#list serialized.imports as import>
+import ${import};
+    </#list>
+</#list>
+
+
+<#if entity.hasKeepSections>
+// THIS CODE IS GENERATED BY greenDAO, EDIT ONLY INSIDE THE "KEEP"-SECTIONS
+
+// KEEP INCLUDES - put your custom includes here
+<#if keepIncludes?has_content>${keepIncludes!}</#if>// KEEP INCLUDES END
+<#else>
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT . Enable "keep" sections if you want to edit.
+</#if>
+/**
+ * Entity mapped to table ${entity.tableName}.
+ */
+<@print_annotations entity.annotations, ""/>
+abstract public class ${entity.classNameBase}<#if
+entity.superclass?has_content> extends ${entity.superclass} </#if><#if
+entity.interfacesToImplement?has_content> implements <#list entity.interfacesToImplement
+as ifc>${ifc}<#if ifc_has_next>, </#if></#list></#if> {
+
+<#list entity.properties as property>
+<#if property.notNull && complexTypes?seq_contains(property.propertyType)>
+    /** Not-null value. */
+</#if>
+    <@print_annotations property.fieldAnnotations, "    "/>
+    protected ${property.javaType} ${property.propertyName};
+</#list>
+
+<#if  entity.serializedProperties?has_content>
+    //denormalized properties
+    <#list entity.serializedProperties as serialized>
+    private ${serialized.className} ${serialized.propertyName};
+    </#list>
+</#if>
+
+
+<#if entity.active>
+    /** Used to resolve relations */
+    protected transient DaoSession daoSession;
+
+    /** Used for active entity operations. */
+    protected transient ${entity.classNameDao} myDao;
+
+<#list entity.toOneRelations as toOne>
+    protected ${toOne.targetEntity.className} ${toOne.name};
+<#if toOne.useFkProperty>
+    protected ${toOne.resolvedKeyJavaType[0]} ${toOne.name}__resolvedKey;
+<#else>
+    protected boolean ${toOne.name}__refreshed;
+</#if>
+
+</#list>
+<#list entity.toManyRelations as toMany>
+    protected List<${toMany.targetEntity.className}> ${toMany.name};
+</#list>
+
+</#if>
+<#if entity.hasKeepSections>
+    // KEEP FIELDS - put your custom fields here
+${keepFields!}    // KEEP FIELDS END
+
+</#if>
+<#if entity.constructors>
+    <@print_annotations entity.emptyConstructorAnnotations, "    "/>
+    public ${entity.classNameBase}() {
+    }
+<#if entity.propertiesPk?has_content && entity.propertiesPk?size != entity.properties?size>
+
+    public ${entity.classNameBase}(<#list entity.propertiesPk as
+property>${property.javaType} ${property.propertyName}<#if property_has_next>, </#if></#list>) {
+<#list entity.propertiesPk as property>
+        this.${property.propertyName} = ${property.propertyName};
+</#list>
+    }
+</#if>
+
+    <@print_annotations entity.fullConstructorAnnotations, "    "/>
+    public ${entity.classNameBase}(<#list entity.properties as
+property>${property.javaType} ${property.propertyName}<#if property_has_next>, </#if></#list>) {
+<#list entity.properties as property>
+        this.${property.propertyName} = ${property.propertyName};
+</#list>
+    }
+</#if>
+
+<#if entity.active>
+    /** called by internal mechanisms, do not call yourself. */
+    public void __setDaoSession(DaoSession daoSession) {
+        this.daoSession = daoSession;
+        myDao = daoSession != null ? daoSession.get${entity.classNameDao?cap_first}() : null;
+    }
+
+</#if>
+<#list entity.properties as property>
+<#if property.notNull && complexTypes?seq_contains(property.propertyType)>
+    /** Not-null value. */
+</#if>
+    <@print_annotations property.getterAnnotations, "    "/>
+    public ${property.javaType} get${property.propertyName?cap_first}() {
+        return ${property.propertyName};
+    }
+
+<#if property.notNull && complexTypes?seq_contains(property.propertyType)>
+    /** Not-null value; ensure this value is available before it is saved to the database. */
+</#if>
+    <@print_annotations property.setterAnnotations, "    "/>
+    public void set${property.propertyName?cap_first}(${property.javaType} ${property.propertyName}) {
+        this.${property.propertyName} = ${property.propertyName};
+    }
+
+</#list>
+<#--
+##########################################
+########## To-One Relations ##############
+##########################################
+-->
+<#list entity.toOneRelations as toOne>
+    /** To-one relationship, resolved on first access. */
+    public ${toOne.targetEntity.className} get${toOne.name?cap_first}() {
+<#if toOne.useFkProperty>
+        if (${toOne.name}__resolvedKey == null || <#--
+        --><#if toOne.resolvedKeyUseEquals[0]>!${toOne.name}__resolvedKey.equals(${toOne.fkProperties[0].propertyName})<#--
+        --><#else>${toOne.name}__resolvedKey != ${toOne.fkProperties[0].propertyName}</#if>) {
+            if (daoSession == null) {
+                throw new DaoException("Entity is detached from DAO context");
+            }
+            ${toOne.targetEntity.classNameDao} targetDao = daoSession.get${toOne.targetEntity.classNameDao?cap_first}();
+            ${toOne.name} = targetDao.load(${toOne.fkProperties[0].propertyName});
+            ${toOne.name}__resolvedKey = ${toOne.fkProperties[0].propertyName};
+        }
+<#else>
+        if (${toOne.name} != null || !${toOne.name}__refreshed) {
+            if (daoSession == null) {
+                throw new DaoException("Entity is detached from DAO context");
+            }
+            ${toOne.targetEntity.classNameDao} targetDao = daoSession.get${toOne.targetEntity.classNameDao?cap_first}();
+            targetDao.refresh(${toOne.name});
+            ${toOne.name}__refreshed = true;
+        }
+</#if>
+        return ${toOne.name};
+    }
+<#if !toOne.useFkProperty>
+
+    /** To-one relationship, returned entity is not refreshed and may carry only the PK property. */
+    public ${toOne.targetEntity.className} peak${toOne.name?cap_first}() {
+        return ${toOne.name};
+    }
+</#if>
+
+    public void set${toOne.name?cap_first}(${toOne.targetEntity.className} ${toOne.name}) {
+<#if toOne.fkProperties[0].notNull>
+        if (${toOne.name} == null) {
+            throw new DaoException("To-one property '${toOne.fkProperties[0].propertyName}' has not-null constraint; cannot set to-one to null");
+        }
+</#if>
+        this.${toOne.name} = ${toOne.name};
+<#if toOne.useFkProperty>
+        ${toOne.fkProperties[0].propertyName} = <#if !toOne.fkProperties[0].notNull>${toOne.name} == null ? null : </#if>${toOne.name}.get${toOne.targetEntity.pkProperty.propertyName?cap_first}();
+        ${toOne.name}__resolvedKey = ${toOne.fkProperties[0].propertyName};
+<#else>
+        ${toOne.name}__refreshed = true;
+</#if>
+    }
+
+</#list>
+<#--
+##########################################
+########## To-Many Relations #############
+##########################################
+-->
+<#list entity.toManyRelations as toMany>
+    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
+    public synchronized List<${toMany.targetEntity.className}> get${toMany.name?cap_first}() {
+        if (${toMany.name} == null) {
+            if (daoSession == null) {
+                throw new DaoException("Entity is detached from DAO context");
+            }
+            ${toMany.targetEntity.classNameDao} targetDao = daoSession.get${toMany.targetEntity.classNameDao?cap_first}();
+            ${toMany.name} = targetDao._query${toMany.sourceEntity.className?cap_first}_${toMany.name?cap_first}(<#--
+                --><#list toMany.sourceProperties as property>${property.propertyName}<#if property_has_next>, </#if></#list>);
+        }
+        return ${toMany.name};
+    }
+
+    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
+    public synchronized void reset${toMany.name?cap_first}() {
+        ${toMany.name} = null;
+    }
+
+</#list>
+<#--
+##########################################
+########## Active entity operations ######
+##########################################
+-->
+<#if entity.active>
+    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
+    public void delete() {
+        if (myDao == null) {
+            throw new DaoException("Entity is detached from DAO context");
+        }
+        myDao.delete((${entity.className})this);
+    }
+
+    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
+    public void update() {
+        if (myDao == null) {
+            throw new DaoException("Entity is detached from DAO context");
+        }
+        myDao.update((${entity.className})this);
+    }
+
+    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
+    public void refresh() {
+        if (myDao == null) {
+            throw new DaoException("Entity is detached from DAO context");
+        }
+        myDao.refresh((${entity.className})this);
+    }
+
+</#if>
+<#--
+##########################################
+########## Serialized field Operations ######
+##########################################
+-->
+<#list entity.serializedProperties as serialization>
+<@print_serialization_stub serialization />
+</#list>
+
+<#if entity.hasKeepSections>
+    // KEEP METHODS - put your custom methods here
+${keepMethods!}    // KEEP METHODS END
+
+    public void onBeforeSave() {
+        //you can override this method and do some stuff if you want to :)
+        <#list entity.serializedProperties as serialization>
+        ${serialization.property.propertyName} = DbUtils.serializeObject(${serialization.propertyName});
+        </#list>
+
+    }
+</#if>
+}
diff --git a/DaoGenerator/src-template/serialize-helper.ftl b/DaoGenerator/src-template/serialize-helper.ftl
new file mode 100644
index 00000000..cf36d87c
--- /dev/null
+++ b/DaoGenerator/src-template/serialize-helper.ftl
@@ -0,0 +1,17 @@
+<#include "*/annotation.ftl">
+<#macro print_serialization_stub stub>
+    <@print_annotations stub.getterAnnotations, "    "/>
+    public ${stub.className} get${stub.propertyName?cap_first}() {
+        if(${stub.propertyName} == null) {
+           ${stub.propertyName}  = (${stub.className}) DbUtils.deserializeObject(${stub.property.propertyName});
+           ${stub.property.propertyName} = null; //clear memory, before save, we'll re-serialize anyways if needed
+        }
+        return ${stub.propertyName};
+    }
+
+    <@print_annotations stub.setterAnnotations, "    "/>
+    public void set${stub.propertyName?cap_first}(${stub.className} ${stub.propertyName}) {
+        this.${stub.propertyName} = ${stub.propertyName};
+        //onBeforeSave will do serialization
+    }
+</#macro>
\ No newline at end of file
diff --git a/DaoGenerator/src/de/greenrobot/daogenerator/Annotation.java b/DaoGenerator/src/de/greenrobot/daogenerator/Annotation.java
index aa47324e..f96df23d 100644
--- a/DaoGenerator/src/de/greenrobot/daogenerator/Annotation.java
+++ b/DaoGenerator/src/de/greenrobot/daogenerator/Annotation.java
@@ -10,6 +10,7 @@
  */
 public class Annotation {
     private String name;
+    protected String _package;
     private Map<String, String> parameters = new HashMap<String, String>();
     public static Pattern QUOTE = Pattern.compile("\"");
 
@@ -32,6 +33,14 @@ public Annotation(String name, String... params) {
         }
     }
 
+    public String getPackage() {
+        return _package;
+    }
+
+    public void setPackage(String _package) {
+        this._package = _package;
+    }
+
     public Annotation(String name) {
         this.name = name;
     }
diff --git a/DaoGenerator/src/de/greenrobot/daogenerator/DaoUtil.java b/DaoGenerator/src/de/greenrobot/daogenerator/DaoUtil.java
index 88a65867..79bdbe2f 100644
--- a/DaoGenerator/src/de/greenrobot/daogenerator/DaoUtil.java
+++ b/DaoGenerator/src/de/greenrobot/daogenerator/DaoUtil.java
@@ -2,7 +2,7 @@
  * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
  *
  * This file is part of greenDAO Generator.
- * 
+ *
  * greenDAO Generator is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
@@ -11,18 +11,13 @@
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
  */
 package de.greenrobot.daogenerator;
 
-import java.io.ByteArrayOutputStream;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
+import java.io.*;
 
 /** Internal API */
 public class DaoUtil {
@@ -38,13 +33,13 @@ public static String dbName(String javaName) {
         }
         return builder.toString().toUpperCase();
     }
-    
+
     public static byte[] readAllBytes(InputStream in) throws IOException {
         ByteArrayOutputStream out = new ByteArrayOutputStream();
         copyAllBytes(in, out);
         return out.toByteArray();
     }
-    
+
     public static byte[] readAllBytes(File file) throws IOException {
         FileInputStream is = new FileInputStream(file);
         try {
@@ -53,7 +48,7 @@ public static String dbName(String javaName) {
             is.close();
         }
     }
-    
+
     public static byte[] readAllBytes(String filename) throws IOException {
         FileInputStream is = new FileInputStream(filename);
         try {
@@ -62,10 +57,10 @@ public static String dbName(String javaName) {
             is.close();
         }
     }
-    
+
     /**
      * Copies all available data from in to out without closing any stream.
-     * 
+     *
      * @return number of bytes copied
      */
     public static int copyAllBytes(InputStream in, OutputStream out) throws IOException {
@@ -81,7 +76,5 @@ public static int copyAllBytes(InputStream in, OutputStream out) throws IOExcept
         }
         return byteCount;
     }
-    
-
 
 }
diff --git a/DaoGenerator/src/de/greenrobot/daogenerator/Entity.java b/DaoGenerator/src/de/greenrobot/daogenerator/Entity.java
index 52d50409..08192b0a 100644
--- a/DaoGenerator/src/de/greenrobot/daogenerator/Entity.java
+++ b/DaoGenerator/src/de/greenrobot/daogenerator/Entity.java
@@ -58,6 +58,7 @@
     private final List<Annotation> annotations;
     private final List<Annotation> emptyConstructorAnnotations;
     private final List<Annotation> fullConstructorAnnotations;
+    private final List<SerializedProperty> serializedProperties;
 
     private String tableName;
     private String classNameDao;
@@ -96,6 +97,7 @@
         annotations = new ArrayList<Annotation>();
         emptyConstructorAnnotations = new ArrayList<Annotation>();
         fullConstructorAnnotations = new ArrayList<Annotation>();
+        serializedProperties = new ArrayList<SerializedProperty>();
         constructors = true;
     }
 
@@ -143,6 +145,23 @@ public PropertyBuilder addStringList(String propertyName) {
         return addProperty(PropertyType.StringList, propertyName);
     }
 
+    public SerializedProperty addSerializedProperty(Property property, String propertyName, String className) {
+        SerializedProperty serializedProperty = new SerializedProperty(property, propertyName, className);
+        this.serializedProperties.add(serializedProperty);
+        return serializedProperty;
+    }
+
+    public SerializedProperty addSerializedProperty(String propertyName, String className, Annotation basePropertyAnnotation) {
+        Property property = this.addProperty(PropertyType.ByteArray, "__" + propertyName)
+                .addSetterGetterAnnotation(basePropertyAnnotation)
+                .getProperty();
+        return this.addSerializedProperty(property, propertyName, className);
+    }
+
+    public List<SerializedProperty> getSerializedProperties() {
+        return serializedProperties;
+    }
+
     public Entity addAnnotation(Annotation annotation) {
         this.annotations.add(annotation);
         return this;
@@ -634,6 +653,24 @@ private void init3rdPassAdditionalImports() {
             Entity targetEntity = toMany.getTargetEntity();
             checkAdditionalImportsEntityTargetEntity(targetEntity);
         }
+
+        for(Property property : properties) {
+            checkAdditionalImportsProperty(property);
+        }
+    }
+
+    private void checkAdditionalImportsProperty(Property property) {
+        checkAddionalImportsAnnotaion(property.getFieldAnnotations());
+        checkAddionalImportsAnnotaion(property.getGetterAnnotations());
+        checkAddionalImportsAnnotaion(property.getSetterAnnotations());
+    }
+
+    private void checkAddionalImportsAnnotaion(List<Annotation> annotations) {
+        for(Annotation annotation : annotations) {
+            if(annotation.getPackage() != null) {
+                additionalImportsEntity.add(annotation.getPackage());
+            }
+        }
     }
 
     private void checkAdditionalImportsEntityTargetEntity(Entity targetEntity) {
diff --git a/DaoGenerator/src/de/greenrobot/daogenerator/Property.java b/DaoGenerator/src/de/greenrobot/daogenerator/Property.java
index 8e39a054..397c63ab 100644
--- a/DaoGenerator/src/de/greenrobot/daogenerator/Property.java
+++ b/DaoGenerator/src/de/greenrobot/daogenerator/Property.java
@@ -147,6 +147,8 @@ public Property getProperty() {
     private boolean unique;
     private boolean notNull;
 
+    private Entity backingEntity;
+
     private List<Annotation> fieldAnnotations = new ArrayList<Annotation>();
     private List<Annotation> setterAnnotations = new ArrayList<Annotation>();
     private List<Annotation> getterAnnotations = new ArrayList<Annotation>();
@@ -233,6 +235,18 @@ public Entity getEntity() {
         return getterAnnotations;
     }
 
+    public Entity getBackingEntity() {
+        return backingEntity;
+    }
+
+    public void setBackingEntity(Entity backingEntity, String propertyName) {
+        if(propertyType != PropertyType.ByteArray) {
+            throw new RuntimeException("can only serialize byte array properties");
+        }
+        backingEntity.implementsSerializable();
+        this.backingEntity = backingEntity;
+    }
+
     void init2ndPass() {
         initConstraint();
         if (columnType == null) {
diff --git a/DaoGenerator/src/de/greenrobot/daogenerator/SerializedProperty.java b/DaoGenerator/src/de/greenrobot/daogenerator/SerializedProperty.java
new file mode 100644
index 00000000..d1f5d71e
--- /dev/null
+++ b/DaoGenerator/src/de/greenrobot/daogenerator/SerializedProperty.java
@@ -0,0 +1,69 @@
+package de.greenrobot.daogenerator;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * This can be used to auto-generate serialization-deserialization code
+ * User: yigit
+ */
+public class SerializedProperty {
+    protected Property property;
+    protected String propertyName;
+    protected String className;
+    protected List<String> imports = new ArrayList<String>();
+
+    private List<Annotation> setterAnnotations = new ArrayList<Annotation>();
+    private List<Annotation> getterAnnotations = new ArrayList<Annotation>();
+
+    public SerializedProperty(Property property, String propertyName, String className) {
+        this.property = property;
+        this.propertyName = propertyName;
+        this.className = className;
+    }
+
+    public Property getProperty() {
+        return property;
+    }
+
+    public String getPropertyName() {
+        return propertyName;
+    }
+
+    public String getClassName() {
+        return className;
+    }
+
+    public List<Annotation> getSetterAnnotations() {
+        return setterAnnotations;
+    }
+
+    public List<Annotation> getGetterAnnotations() {
+        return getterAnnotations;
+    }
+
+    public SerializedProperty addSetterAnnotation(Annotation annotation) {
+        setterAnnotations.add(annotation);
+        return this;
+    }
+
+    public SerializedProperty addSetterGetterAnnotation(Annotation annotation) {
+        setterAnnotations.add(annotation);
+        getterAnnotations.add(annotation);
+        return this;
+    }
+
+    public SerializedProperty addGetterAnnotation(Annotation annotation) {
+        getterAnnotations.add(annotation);
+        return this;
+    }
+
+    public SerializedProperty addImport(String pack) {
+        this.imports.add(pack);
+        return this;
+    }
+
+    public List<String> getImports() {
+        return imports;
+    }
+}
