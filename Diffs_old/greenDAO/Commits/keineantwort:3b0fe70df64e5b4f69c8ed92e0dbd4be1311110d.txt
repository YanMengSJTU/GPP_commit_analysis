diff --git a/DaoCore/.classpath b/DaoCore/.classpath
index 26bdfa6e..3cf4066d 100644
--- a/DaoCore/.classpath
+++ b/DaoCore/.classpath
@@ -3,7 +3,9 @@
 	<classpathentry kind="src" path="src"/>
 	<classpathentry kind="src" path="gen"/>
 	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
-	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
 	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
+	<classpathentry exported="true" kind="con" path="org.springsource.ide.eclipse.gradle.classpathcontainer"/>
 	<classpathentry kind="output" path="bin/classes"/>
 </classpath>
diff --git a/DaoCore/.project b/DaoCore/.project
index 6fdcae5d..63a36ae3 100644
--- a/DaoCore/.project
+++ b/DaoCore/.project
@@ -1,39 +1,40 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<projectDescription>
-	<name>DaoCore</name>
-	<comment></comment>
-	<projects>
-	</projects>
-	<buildSpec>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>org.eclipse.jdt.core.javabuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>edu.umd.cs.findbugs.plugin.eclipse.findbugsBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-	</buildSpec>
-	<natures>
-		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
-		<nature>org.eclipse.jdt.core.javanature</nature>
-		<nature>edu.umd.cs.findbugs.plugin.eclipse.findbugsNature</nature>
-	</natures>
-</projectDescription>
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>DaoCore</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>edu.umd.cs.findbugs.plugin.eclipse.findbugsBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.springsource.ide.eclipse.gradle.core.nature</nature>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
+		<nature>edu.umd.cs.findbugs.plugin.eclipse.findbugsNature</nature>
+	</natures>
+</projectDescription>
diff --git a/DaoCore/.settings/gradle/org.springsource.ide.eclipse.gradle.core.prefs b/DaoCore/.settings/gradle/org.springsource.ide.eclipse.gradle.core.prefs
new file mode 100644
index 00000000..a28cd259
--- /dev/null
+++ b/DaoCore/.settings/gradle/org.springsource.ide.eclipse.gradle.core.prefs
@@ -0,0 +1,4 @@
+#org.springsource.ide.eclipse.gradle.core.preferences.GradleProjectPreferences
+#Wed Aug 14 07:00:13 CEST 2013
+org.springsource.ide.eclipse.gradle.linkedresources=
+org.springsource.ide.eclipse.gradle.rootprojectloc=
diff --git a/DaoCore/build.gradle b/DaoCore/build.gradle
index 32cd349f..d8239bfe 100644
--- a/DaoCore/build.gradle
+++ b/DaoCore/build.gradle
@@ -3,7 +3,7 @@ apply plugin: 'maven'
 apply plugin: 'signing'
 
 group = 'de.greenrobot'
-version = '1.3.1'
+version = '1.3.1.keineantwort.github1-SNAPSHOT'
 sourceCompatibility = 1.6
 
 def isSnapshot = version.endsWith('-SNAPSHOT')
diff --git a/DaoCore/src/de/greenrobot/dao/AbstractDao.java b/DaoCore/src/de/greenrobot/dao/AbstractDao.java
index 042d4c3e..8a57a6b9 100644
--- a/DaoCore/src/de/greenrobot/dao/AbstractDao.java
+++ b/DaoCore/src/de/greenrobot/dao/AbstractDao.java
@@ -36,772 +36,869 @@
 import de.greenrobot.dao.query.QueryBuilder;
 
 /**
- * Base class for all DAOs: Implements entity operations like insert, load, delete, and query.
+ * Base class for all DAOs: Implements entity operations like insert, load,
+ * delete, and query.
  * 
  * This class is thread-safe.
  * 
  * @author Markus
  * 
  * @param <T>
- *            Entity type
+ *          Entity type
  * @param <K>
- *            Primary key (PK) type; use Void if entity does not have exactly one PK
+ *          Primary key (PK) type; use Void if entity does not have exactly one
+ *          PK
  */
 /*
- * When operating on TX, statements, or identity scope the following locking order must be met to avoid deadlocks:
+ * When operating on TX, statements, or identity scope the following locking
+ * order must be met to avoid deadlocks:
  * 
- * 1.) If not inside a TX already, begin a TX to acquire a DB connection (connection is to be handled like a lock)
+ * 1.) If not inside a TX already, begin a TX to acquire a DB connection
+ * (connection is to be handled like a lock)
  * 
  * 2.) The SQLiteStatement
  * 
  * 3.) identityScope
  */
 public abstract class AbstractDao<T, K> {
-    protected final SQLiteDatabase db;
-    protected final DaoConfig config;
-    protected IdentityScope<K, T> identityScope;
-    protected IdentityScopeLong<T> identityScopeLong;
-    protected TableStatements statements;
-
-    protected final AbstractDaoSession session;
-    protected final int pkOrdinal;
-
-    public AbstractDao(DaoConfig config) {
-        this(config, null);
-    }
-
-    @SuppressWarnings("unchecked")
-    public AbstractDao(DaoConfig config, AbstractDaoSession daoSession) {
-        this.config = config;
-        this.session = daoSession;
-        db = config.db;
-        identityScope = (IdentityScope<K, T>) config.getIdentityScope();
-        if (identityScope instanceof IdentityScopeLong) {
-            identityScopeLong = (IdentityScopeLong<T>) identityScope;
-        }
-        statements = config.statements;
-        pkOrdinal = config.pkProperty != null ? config.pkProperty.ordinal : -1;
-    }
-
-    public AbstractDaoSession getSession() {
-        return session;
-    }
-
-    TableStatements getStatements() {
-        return config.statements;
-    }
-
-    public String getTablename() {
-        return config.tablename;
-    }
-
-    public Property[] getProperties() {
-        return config.properties;
-    }
-
-    public Property getPkProperty() {
-        return config.pkProperty;
-    }
-
-    public String[] getAllColumns() {
-        return config.allColumns;
-    }
-
-    public String[] getPkColumns() {
-        return config.pkColumns;
-    }
-
-    public String[] getNonPkColumns() {
-        return config.nonPkColumns;
-    }
-
-    /**
-     * Loads and entity for the given PK.
-     * 
-     * @param key
-     *            a PK value or null
-     * @return The entity or null, if no entity matched the PK value
-     */
-    public T load(K key) {
-        assertSinglePk();
-        if (key == null) {
-            return null;
-        }
-        if (identityScope != null) {
-            T entity = identityScope.get(key);
-            if (entity != null) {
-                return entity;
-            }
-        }
-        String sql = statements.getSelectByKey();
-        String[] keyArray = new String[] { key.toString() };
-        Cursor cursor = db.rawQuery(sql, keyArray);
-        return loadUniqueAndCloseCursor(cursor);
-    }
-
-    public T loadByRowId(long rowId) {
-        String[] idArray = new String[] { Long.toString(rowId) };
-        Cursor cursor = db.rawQuery(statements.getSelectByRowId(), idArray);
-        return loadUniqueAndCloseCursor(cursor);
-    }
-
-    protected T loadUniqueAndCloseCursor(Cursor cursor) {
-        try {
-            return loadUnique(cursor);
-        } finally {
-            cursor.close();
-        }
-    }
-
-    protected T loadUnique(Cursor cursor) {
-        boolean available = cursor.moveToFirst();
-        if (!available) {
-            return null;
-        } else if (!cursor.isLast()) {
-            throw new DaoException("Expected unique result, but count was " + cursor.getCount());
-        }
-        return loadCurrent(cursor, 0, true);
-    }
-
-    /** Loads all available entities from the database. */
-    public List<T> loadAll() {
-        Cursor cursor = db.rawQuery(statements.getSelectAll(), null);
-        return loadAllAndCloseCursor(cursor);
-    }
-
-    /** Detaches an entity from the identity scope (session). Subsequent query results won't return this object. */
-    public boolean detach(T entity) {
-        if (identityScope != null) {
-            K key = getKeyVerified(entity);
-            return identityScope.detach(key, entity);
-        } else {
-            return false;
-        }
-    }
-
-    protected List<T> loadAllAndCloseCursor(Cursor cursor) {
-        try {
-            return loadAllFromCursor(cursor);
-        } finally {
-            cursor.close();
+  protected final SQLiteDatabase db;
+  protected final DaoConfig config;
+  protected IdentityScope<K, T> identityScope;
+  protected IdentityScopeLong<T> identityScopeLong;
+  protected TableStatements statements;
+
+  protected final AbstractDaoSession session;
+  protected final int pkOrdinal;
+
+  public AbstractDao(DaoConfig config) {
+    this(config, null);
+  }
+
+  @SuppressWarnings("unchecked")
+  public AbstractDao(DaoConfig config, AbstractDaoSession daoSession) {
+    this.config = config;
+    this.session = daoSession;
+    this.db = config.db;
+    this.identityScope = (IdentityScope<K, T>) config.getIdentityScope();
+    if (this.identityScope instanceof IdentityScopeLong) {
+      this.identityScopeLong = (IdentityScopeLong<T>) this.identityScope;
+    }
+    this.statements = config.statements;
+    this.pkOrdinal = config.pkProperty != null ? config.pkProperty.ordinal : -1;
+  }
+
+  public AbstractDaoSession getSession() {
+    return this.session;
+  }
+
+  TableStatements getStatements() {
+    return this.config.statements;
+  }
+
+  public String getTablename() {
+    return this.config.tablename;
+  }
+
+  public Property[] getProperties() {
+    return this.config.properties;
+  }
+
+  public Property getPkProperty() {
+    return this.config.pkProperty;
+  }
+
+  public String[] getAllColumns() {
+    return this.config.allColumns;
+  }
+
+  public String[] getPkColumns() {
+    return this.config.pkColumns;
+  }
+
+  public String[] getNonPkColumns() {
+    return this.config.nonPkColumns;
+  }
+
+  /**
+   * Loads and entity for the given PK.
+   * 
+   * @param key
+   *          a PK value or null
+   * @return The entity or null, if no entity matched the PK value
+   */
+  public T load(K key) {
+    this.assertSinglePk();
+    if (key == null) {
+      return null;
+    }
+    if (this.identityScope != null) {
+      T entity = this.identityScope.get(key);
+      if (entity != null) {
+        return entity;
+      }
+    }
+    String sql = this.statements.getSelectByKey();
+    String[] keyArray = new String[] { key.toString() };
+    Cursor cursor = this.db.rawQuery(sql, keyArray);
+    return this.loadUniqueAndCloseCursor(cursor);
+  }
+
+  public T loadByRowId(long rowId) {
+    String[] idArray = new String[] { Long.toString(rowId) };
+    Cursor cursor = this.db.rawQuery(this.statements.getSelectByRowId(), idArray);
+    return this.loadUniqueAndCloseCursor(cursor);
+  }
+
+  protected T loadUniqueAndCloseCursor(Cursor cursor) {
+    try {
+      return this.loadUnique(cursor);
+    } finally {
+      cursor.close();
+    }
+  }
+
+  protected T loadUnique(Cursor cursor) {
+    boolean available = cursor.moveToFirst();
+    if (!available) {
+      return null;
+    } else if (!cursor.isLast()) {
+      throw new DaoException("Expected unique result, but count was " + cursor.getCount());
+    }
+    return this.loadCurrent(cursor, 0, true);
+  }
+
+  /** Loads all available entities from the database. */
+  public List<T> loadAll() {
+    Cursor cursor = this.db.rawQuery(this.statements.getSelectAll(), null);
+    return this.loadAllAndCloseCursor(cursor);
+  }
+
+  /**
+   * Detaches an entity from the identity scope (session). Subsequent query
+   * results won't return this object.
+   */
+  public boolean detach(T entity) {
+    if (this.identityScope != null) {
+      K key = this.getKeyVerified(entity);
+      return this.identityScope.detach(key, entity);
+    } else {
+      return false;
+    }
+  }
+
+  protected List<T> loadAllAndCloseCursor(Cursor cursor) {
+    try {
+      return this.loadAllFromCursor(cursor);
+    } finally {
+      cursor.close();
+    }
+  }
+
+  /**
+   * Inserts the given entities in the database using a transaction.
+   * 
+   * @param entities
+   *          The entities to insert.
+   */
+  public void insertInTx(Iterable<T> entities) {
+    this.insertInTx(entities, this.isEntityUpdateable());
+  }
+
+  /**
+   * Inserts the given entities in the database using a transaction.
+   * 
+   * @param entities
+   *          The entities to insert.
+   */
+  public void insertInTx(T... entities) {
+    this.insertInTx(Arrays.asList(entities), this.isEntityUpdateable());
+  }
+
+  /**
+   * Inserts the given entities in the database using a transaction. The given
+   * entities will become tracked if the PK is set.
+   * 
+   * @param entities
+   *          The entities to insert.
+   * @param setPrimaryKey
+   *          if true, the PKs of the given will be set after the insert; pass
+   *          false to improve performance.
+   */
+  public void insertInTx(Iterable<T> entities, boolean setPrimaryKey) {
+    SQLiteStatement stmt = this.statements.getInsertStatement();
+    this.executeInsertInTx(stmt, entities, setPrimaryKey);
+  }
+
+  /**
+   * Inserts or replaces the given entities in the database using a transaction.
+   * The given entities will become tracked if the PK is set.
+   * 
+   * @param entities
+   *          The entities to insert.
+   * @param setPrimaryKey
+   *          if true, the PKs of the given will be set after the insert; pass
+   *          false to improve performance.
+   */
+  public void insertOrReplaceInTx(Iterable<T> entities, boolean setPrimaryKey) {
+    SQLiteStatement stmt = this.statements.getInsertOrReplaceStatement();
+    this.executeInsertInTx(stmt, entities, setPrimaryKey);
+  }
+
+  /**
+   * Inserts or replaces the given entities in the database using a transaction.
+   * 
+   * @param entities
+   *          The entities to insert.
+   */
+  public void insertOrReplaceInTx(Iterable<T> entities) {
+    this.insertOrReplaceInTx(entities, this.isEntityUpdateable());
+  }
+
+  /**
+   * Inserts or replaces the given entities in the database using a transaction.
+   * 
+   * @param entities
+   *          The entities to insert.
+   */
+  public void insertOrReplaceInTx(T... entities) {
+    this.insertOrReplaceInTx(Arrays.asList(entities), this.isEntityUpdateable());
+  }
+
+  private void executeInsertInTx(SQLiteStatement stmt, Iterable<T> entities, boolean setPrimaryKey) {
+    this.db.beginTransaction();
+    try {
+      synchronized (stmt) {
+        if (this.identityScope != null) {
+          this.identityScope.lock();
         }
-    }
-
-    /**
-     * Inserts the given entities in the database using a transaction.
-     * 
-     * @param entities
-     *            The entities to insert.
-     */
-    public void insertInTx(Iterable<T> entities) {
-        insertInTx(entities, isEntityUpdateable());
-    }
-
-    /**
-     * Inserts the given entities in the database using a transaction.
-     * 
-     * @param entities
-     *            The entities to insert.
-     */
-    public void insertInTx(T... entities) {
-        insertInTx(Arrays.asList(entities), isEntityUpdateable());
-    }
-
-    /**
-     * Inserts the given entities in the database using a transaction. The given entities will become tracked if the PK
-     * is set.
-     * 
-     * @param entities
-     *            The entities to insert.
-     * @param setPrimaryKey
-     *            if true, the PKs of the given will be set after the insert; pass false to improve performance.
-     */
-    public void insertInTx(Iterable<T> entities, boolean setPrimaryKey) {
-        SQLiteStatement stmt = statements.getInsertStatement();
-        executeInsertInTx(stmt, entities, setPrimaryKey);
-    }
-
-    /**
-     * Inserts or replaces the given entities in the database using a transaction. The given entities will become
-     * tracked if the PK is set.
-     * 
-     * @param entities
-     *            The entities to insert.
-     * @param setPrimaryKey
-     *            if true, the PKs of the given will be set after the insert; pass false to improve performance.
-     */
-    public void insertOrReplaceInTx(Iterable<T> entities, boolean setPrimaryKey) {
-        SQLiteStatement stmt = statements.getInsertOrReplaceStatement();
-        executeInsertInTx(stmt, entities, setPrimaryKey);
-    }
-
-    /**
-     * Inserts or replaces the given entities in the database using a transaction.
-     * 
-     * @param entities
-     *            The entities to insert.
-     */
-    public void insertOrReplaceInTx(Iterable<T> entities) {
-        insertOrReplaceInTx(entities, isEntityUpdateable());
-    }
-
-    /**
-     * Inserts or replaces the given entities in the database using a transaction.
-     * 
-     * @param entities
-     *            The entities to insert.
-     */
-    public void insertOrReplaceInTx(T... entities) {
-        insertOrReplaceInTx(Arrays.asList(entities), isEntityUpdateable());
-    }
-
-    private void executeInsertInTx(SQLiteStatement stmt, Iterable<T> entities, boolean setPrimaryKey) {
-        db.beginTransaction();
         try {
-            synchronized (stmt) {
-                if (identityScope != null) {
-                    identityScope.lock();
-                }
-                try {
-                    for (T entity : entities) {
-                        bindValues(stmt, entity);
-                        if (setPrimaryKey) {
-                            long rowId = stmt.executeInsert();
-                            updateKeyAfterInsertAndAttach(entity, rowId, false);
-                        } else {
-                            stmt.execute();
-                        }
-                    }
-                } finally {
-                    if (identityScope != null) {
-                        identityScope.unlock();
-                    }
-                }
+          for (T entity : entities) {
+            this.bindValues(stmt, entity);
+            if (setPrimaryKey) {
+              long rowId = stmt.executeInsert();
+              this.updateKeyAfterInsertAndAttach(entity, rowId, false);
+            } else {
+              stmt.execute();
             }
-            db.setTransactionSuccessful();
+          }
         } finally {
-            db.endTransaction();
+          if (this.identityScope != null) {
+            this.identityScope.unlock();
+          }
         }
-    }
-
-    /**
-     * Insert an entity into the table associated with a concrete DAO.
-     * 
-     * @return row ID of newly inserted entity
-     */
-    public long insert(T entity) {
-        return executeInsert(entity, statements.getInsertStatement());
-    }
-
-    /**
-     * Insert an entity into the table associated with a concrete DAO <b>without</b> setting key property. Warning: This
-     * may be faster, but the entity should not be used anymore. The entity also won't be attached to identy scope.
-     * 
-     * @return row ID of newly inserted entity
-     */
-    public long insertWithoutSettingPk(T entity) {
-        SQLiteStatement stmt = statements.getInsertStatement();
-        long rowId;
-        if (db.isDbLockedByCurrentThread()) {
-            synchronized (stmt) {
-                bindValues(stmt, entity);
-                rowId = stmt.executeInsert();
-            }
-        } else {
-            // Do TX to acquire a connection before locking the stmt to avoid deadlocks
-            db.beginTransaction();
-            try {
-                synchronized (stmt) {
-                    bindValues(stmt, entity);
-                    rowId = stmt.executeInsert();
-                }
-                db.setTransactionSuccessful();
-            } finally {
-                db.endTransaction();
-            }
+      }
+      this.db.setTransactionSuccessful();
+    } finally {
+      this.db.endTransaction();
+    }
+  }
+
+  /**
+   * Insert an entity into the table associated with a concrete DAO.
+   * 
+   * @return row ID of newly inserted entity
+   */
+  public long insert(T entity) {
+    return this.executeInsert(entity, this.statements.getInsertStatement());
+  }
+
+  /**
+   * Insert an entity into the table associated with a concrete DAO
+   * <b>without</b> setting key property. Warning: This may be faster, but the
+   * entity should not be used anymore. The entity also won't be attached to
+   * identy scope.
+   * 
+   * @return row ID of newly inserted entity
+   */
+  public long insertWithoutSettingPk(T entity) {
+    SQLiteStatement stmt = this.statements.getInsertStatement();
+    long rowId;
+    if (this.db.isDbLockedByCurrentThread()) {
+      synchronized (stmt) {
+        this.bindValues(stmt, entity);
+        rowId = stmt.executeInsert();
+      }
+    } else {
+      // Do TX to acquire a connection before locking the stmt to avoid
+      // deadlocks
+      this.db.beginTransaction();
+      try {
+        synchronized (stmt) {
+          this.bindValues(stmt, entity);
+          rowId = stmt.executeInsert();
         }
-        return rowId;
-    }
-
-    /**
-     * Insert an entity into the table associated with a concrete DAO.
-     * 
-     * @return row ID of newly inserted entity
-     */
-    public long insertOrReplace(T entity) {
-        return executeInsert(entity, statements.getInsertOrReplaceStatement());
-    }
-
-    private long executeInsert(T entity, SQLiteStatement stmt) {
-        long rowId;
-        if (db.isDbLockedByCurrentThread()) {
-            synchronized (stmt) {
-                bindValues(stmt, entity);
-                rowId = stmt.executeInsert();
-            }
-        } else {
-            // Do TX to acquire a connection before locking the stmt to avoid deadlocks
-            db.beginTransaction();
-            try {
-                synchronized (stmt) {
-                    bindValues(stmt, entity);
-                    rowId = stmt.executeInsert();
-                }
-                db.setTransactionSuccessful();
-            } finally {
-                db.endTransaction();
-            }
+        this.db.setTransactionSuccessful();
+      } finally {
+        this.db.endTransaction();
+      }
+    }
+    return rowId;
+  }
+
+  /**
+   * Insert an entity into the table associated with a concrete DAO.
+   * 
+   * @return row ID of newly inserted entity
+   */
+  public long insertOrReplace(T entity) {
+    return this.executeInsert(entity, this.statements.getInsertOrReplaceStatement());
+  }
+
+  private long executeInsert(T entity, SQLiteStatement stmt) {
+    long rowId;
+    if (this.db.isDbLockedByCurrentThread()) {
+      synchronized (stmt) {
+        this.bindValues(stmt, entity);
+        rowId = stmt.executeInsert();
+      }
+    } else {
+      // Do TX to acquire a connection before locking the stmt to avoid
+      // deadlocks
+      this.db.beginTransaction();
+      try {
+        synchronized (stmt) {
+          this.bindValues(stmt, entity);
+          rowId = stmt.executeInsert();
         }
-        updateKeyAfterInsertAndAttach(entity, rowId, true);
-        return rowId;
-    }
-
-    protected void updateKeyAfterInsertAndAttach(T entity, long rowId, boolean lock) {
-        if (rowId != -1) {
-            K key = updateKeyAfterInsert(entity, rowId);
-            attachEntity(key, entity, lock);
+        this.db.setTransactionSuccessful();
+      } finally {
+        this.db.endTransaction();
+      }
+    }
+    this.updateKeyAfterInsertAndAttach(entity, rowId, true);
+    return rowId;
+  }
+
+  protected void updateKeyAfterInsertAndAttach(T entity, long rowId, boolean lock) {
+    if (rowId != -1) {
+      K key = this.updateKeyAfterInsert(entity, rowId);
+      this.attachEntity(key, entity, lock);
+    } else {
+      // TODO When does this actually happen? Should we throw instead?
+      DaoLog.w("Could not insert row (executeInsert returned -1)");
+    }
+  }
+
+  /**
+   * Reads all available rows from the given cursor and returns a list of
+   * entities.
+   */
+  protected List<T> loadAllFromCursor(Cursor cursor) {
+    int count = cursor.getCount();
+    List<T> list = new ArrayList<T>(count);
+    if (cursor instanceof CrossProcessCursor) {
+      CursorWindow window = ((CrossProcessCursor) cursor).getWindow();
+      if (window != null) { // E.g. Roboelectric has no Window at this point
+        if (window.getNumRows() == count) {
+          cursor = new FastCursor(window);
         } else {
-            // TODO When does this actually happen? Should we throw instead?
-            DaoLog.w("Could not insert row (executeInsert returned -1)");
+          DaoLog.d("Window vs. result size: " + window.getNumRows() + "/" + count);
         }
-    }
-
-    /** Reads all available rows from the given cursor and returns a list of entities. */
-    protected List<T> loadAllFromCursor(Cursor cursor) {
-        int count = cursor.getCount();
-        List<T> list = new ArrayList<T>(count);
-        if (cursor instanceof CrossProcessCursor) {
-            CursorWindow window = ((CrossProcessCursor) cursor).getWindow();
-            if (window != null) { // E.g. Roboelectric has no Window at this point
-                if (window.getNumRows() == count) {
-                    cursor = new FastCursor(window);
-                } else {
-                    DaoLog.d("Window vs. result size: " + window.getNumRows() + "/" + count);
-                }
-            }
+      }
+    }
+
+    if (cursor.moveToFirst()) {
+      if (this.identityScope != null) {
+        this.identityScope.lock();
+        this.identityScope.reserveRoom(count);
+      }
+      try {
+        do {
+          list.add(this.loadCurrent(cursor, 0, false));
+        } while (cursor.moveToNext());
+      } finally {
+        if (this.identityScope != null) {
+          this.identityScope.unlock();
         }
-
-        if (cursor.moveToFirst()) {
-            if (identityScope != null) {
-                identityScope.lock();
-                identityScope.reserveRoom(count);
-            }
-            try {
-                do {
-                    list.add(loadCurrent(cursor, 0, false));
-                } while (cursor.moveToNext());
-            } finally {
-                if (identityScope != null) {
-                    identityScope.unlock();
-                }
-            }
+      }
+    }
+    return list;
+  }
+
+  /** Internal use only. Considers identity scope. */
+  final protected T loadCurrent(Cursor cursor, int offset, boolean lock) {
+    if (this.identityScopeLong != null) {
+      if (offset != 0) {
+        // Occurs with deep loads (left outer joins)
+        if (cursor.isNull(this.pkOrdinal + offset)) {
+          return null;
         }
-        return list;
-    }
-
-    /** Internal use only. Considers identity scope. */
-    final protected T loadCurrent(Cursor cursor, int offset, boolean lock) {
-        if (identityScopeLong != null) {
-            if (offset != 0) {
-                // Occurs with deep loads (left outer joins)
-                if (cursor.isNull(pkOrdinal + offset)) {
-                    return null;
-                }
-            }
-
-            long key = cursor.getLong(pkOrdinal + offset);
-            T entity = lock ? identityScopeLong.get2(key) : identityScopeLong.get2NoLock(key);
-            if (entity != null) {
-                return entity;
-            } else {
-                entity = readEntity(cursor, offset);
-                if (lock) {
-                    identityScopeLong.put2(key, entity);
-                } else {
-                    identityScopeLong.put2NoLock(key, entity);
-                }
-                attachEntity(entity);
-                return entity;
-            }
-        } else if (identityScope != null) {
-            K key = readKey(cursor, offset);
-            if (offset != 0 && key == null) {
-                // Occurs with deep loads (left outer joins)
-                return null;
-            }
-            T entity = lock ? identityScope.get(key) : identityScope.getNoLock(key);
-            if (entity != null) {
-                return entity;
-            } else {
-                entity = readEntity(cursor, offset);
-                attachEntity(key, entity, lock);
-                return entity;
-            }
+      }
+
+      long key = cursor.getLong(this.pkOrdinal + offset);
+      T entity = lock ? this.identityScopeLong.get2(key) : this.identityScopeLong.get2NoLock(key);
+      if (entity != null) {
+        return entity;
+      } else {
+        entity = this.readEntity(cursor, offset);
+        if (lock) {
+          this.identityScopeLong.put2(key, entity);
         } else {
-            // Check offset, assume a value !=0 indicating a potential outer join, so check PK
-            if (offset != 0) {
-                K key = readKey(cursor, offset);
-                if (key == null) {
-                    // Occurs with deep loads (left outer joins)
-                    return null;
-                }
-            }
-            T entity = readEntity(cursor, offset);
-            attachEntity(entity);
-            return entity;
-        }
-    }
-
-    /** Internal use only. Considers identity scope. */
-    final protected <O> O loadCurrentOther(AbstractDao<O, ?> dao, Cursor cursor, int offset) {
-        return dao.loadCurrent(cursor, offset, /* TODO check this */true);
-    }
-
-    /** A raw-style query where you can pass any WHERE clause and arguments. */
-    public List<T> queryRaw(String where, String... selectionArg) {
-        Cursor cursor = db.rawQuery(statements.getSelectAll() + where, selectionArg);
-        return loadAllAndCloseCursor(cursor);
-    }
-
-    /**
-     * Creates a repeatable {@link Query} object based on the given raw SQL where you can pass any WHERE clause and
-     * arguments.
-     */
-    public Query<T> queryRawCreate(String where, Object... selectionArg) {
-        List<Object> argList = Arrays.asList(selectionArg);
-        return queryRawCreateListArgs(where, argList);
-    }
-
-    /**
-     * Creates a repeatable {@link Query} object based on the given raw SQL where you can pass any WHERE clause and
-     * arguments.
-     */
-    public Query<T> queryRawCreateListArgs(String where, Collection<Object> selectionArg) {
-        return Query.internalCreate(this, statements.getSelectAll() + where, selectionArg.toArray());
-    }
-
-    public void deleteAll() {
-        // String sql = SqlUtils.createSqlDelete(config.tablename, null);
-        // db.execSQL(sql);
-
-        db.execSQL("DELETE FROM '" + config.tablename + "'");
-        if (identityScope != null) {
-            identityScope.clear();
+          this.identityScopeLong.put2NoLock(key, entity);
         }
-    }
-
-    /** Deletes the given entity from the database. Currently, only single value PK entities are supported. */
-    public void delete(T entity) {
-        assertSinglePk();
-        K key = getKeyVerified(entity);
-        deleteByKey(key);
-    }
-
-    /** Deletes an entity with the given PK from the database. Currently, only single value PK entities are supported. */
-    public void deleteByKey(K key) {
-        assertSinglePk();
-        SQLiteStatement stmt = statements.getDeleteStatement();
-        if (db.isDbLockedByCurrentThread()) {
-            synchronized (stmt) {
-                deleteByKeyInsideSynchronized(key, stmt);
-            }
-        } else {
-            // Do TX to acquire a connection before locking the stmt to avoid deadlocks
-            db.beginTransaction();
-            try {
-                synchronized (stmt) {
-                    deleteByKeyInsideSynchronized(key, stmt);
-                }
-                db.setTransactionSuccessful();
-            } finally {
-                db.endTransaction();
-            }
+        this.attachEntity(entity);
+        return entity;
+      }
+    } else if (this.identityScope != null) {
+      K key = this.readKey(cursor, offset);
+      if ((offset != 0) && (key == null)) {
+        // Occurs with deep loads (left outer joins)
+        return null;
+      }
+      T entity = lock ? this.identityScope.get(key) : this.identityScope.getNoLock(key);
+      if (entity != null) {
+        return entity;
+      } else {
+        entity = this.readEntity(cursor, offset);
+        this.attachEntity(key, entity, lock);
+        return entity;
+      }
+    } else {
+      // Check offset, assume a value !=0 indicating a potential outer join, so
+      // check PK
+      if (offset != 0) {
+        K key = this.readKey(cursor, offset);
+        if (key == null) {
+          // Occurs with deep loads (left outer joins)
+          return null;
         }
-        if (identityScope != null) {
-            identityScope.remove(key);
+      }
+      T entity = this.readEntity(cursor, offset);
+      this.attachEntity(entity);
+      return entity;
+    }
+  }
+
+  /** Internal use only. Considers identity scope. */
+  final protected <O> O loadCurrentOther(AbstractDao<O, ?> dao, Cursor cursor, int offset) {
+    return dao.loadCurrent(cursor, offset, /* TODO check this */true);
+  }
+
+  /** A raw-style query where you can pass any WHERE clause and arguments. */
+  public List<T> queryRaw(String where, String... selectionArg) {
+    Cursor cursor = this.db.rawQuery(this.statements.getSelectAll() + where, selectionArg);
+    return this.loadAllAndCloseCursor(cursor);
+  }
+
+  /**
+   * Creates a repeatable {@link Query} object based on the given raw SQL where
+   * you can pass any WHERE clause and arguments.
+   */
+  public Query<T> queryRawCreate(String where, Object... selectionArg) {
+    List<Object> argList = Arrays.asList(selectionArg);
+    return this.queryRawCreateListArgs(where, argList);
+  }
+
+  /**
+   * Creates a repeatable {@link Query} object based on the given raw SQL where
+   * you can pass any WHERE clause and arguments.
+   */
+  public Query<T> queryRawCreateListArgs(String where, Collection<Object> selectionArg) {
+    return Query.internalCreate(this, this.statements.getSelectAll() + where, selectionArg.toArray());
+  }
+
+  public void deleteAll() {
+    // String sql = SqlUtils.createSqlDelete(config.tablename, null);
+    // db.execSQL(sql);
+
+    this.db.execSQL("DELETE FROM '" + this.config.tablename + "'");
+    if (this.identityScope != null) {
+      this.identityScope.clear();
+    }
+  }
+
+  /**
+   * Deletes the given entity from the database. Currently, only single value PK
+   * entities are supported.
+   */
+  public void delete(T entity) {
+    this.assertSinglePk();
+    K key = this.getKeyVerified(entity);
+    this.deleteByKey(key);
+  }
+
+  /**
+   * Deletes an entity with the given PK from the database. Currently, only
+   * single value PK entities are supported.
+   */
+  public void deleteByKey(K key) {
+    this.assertSinglePk();
+    SQLiteStatement stmt = this.statements.getDeleteStatement();
+    if (this.db.isDbLockedByCurrentThread()) {
+      synchronized (stmt) {
+        this.deleteByKeyInsideSynchronized(key, stmt);
+      }
+    } else {
+      // Do TX to acquire a connection before locking the stmt to avoid
+      // deadlocks
+      this.db.beginTransaction();
+      try {
+        synchronized (stmt) {
+          this.deleteByKeyInsideSynchronized(key, stmt);
         }
-    }
-
-    private void deleteByKeyInsideSynchronized(K key, SQLiteStatement stmt) {
-        if (key instanceof Long) {
-            stmt.bindLong(1, (Long) key);
-        } else if (key == null) {
-            throw new DaoException("Cannot delete entity, key is null");
-        } else {
-            stmt.bindString(1, key.toString());
+        this.db.setTransactionSuccessful();
+      } finally {
+        this.db.endTransaction();
+      }
+    }
+    if (this.identityScope != null) {
+      this.identityScope.remove(key);
+    }
+  }
+
+  private void deleteByKeyInsideSynchronized(K key, SQLiteStatement stmt) {
+    if (key instanceof Long) {
+      stmt.bindLong(1, (Long) key);
+    } else if (key == null) {
+      throw new DaoException("Cannot delete entity, key is null");
+    } else {
+      stmt.bindString(1, key.toString());
+    }
+    stmt.execute();
+  }
+
+  private void deleteInTxInternal(Iterable<T> entities, Iterable<K> keys) {
+    this.assertSinglePk();
+    SQLiteStatement stmt = this.statements.getDeleteStatement();
+    List<K> keysToRemoveFromIdentityScope = null;
+    this.db.beginTransaction();
+    try {
+      synchronized (stmt) {
+        if (this.identityScope != null) {
+          this.identityScope.lock();
+          keysToRemoveFromIdentityScope = new ArrayList<K>();
         }
-        stmt.execute();
-    }
-
-    private void deleteInTxInternal(Iterable<T> entities, Iterable<K> keys) {
-        assertSinglePk();
-        SQLiteStatement stmt = statements.getDeleteStatement();
-        List<K> keysToRemoveFromIdentityScope = null;
-        db.beginTransaction();
         try {
-            synchronized (stmt) {
-                if (identityScope != null) {
-                    identityScope.lock();
-                    keysToRemoveFromIdentityScope = new ArrayList<K>();
-                }
-                try {
-                    if (entities != null) {
-                        for (T entity : entities) {
-                            K key = getKeyVerified(entity);
-                            deleteByKeyInsideSynchronized(key, stmt);
-                            if (keysToRemoveFromIdentityScope != null) {
-                                keysToRemoveFromIdentityScope.add(key);
-                            }
-                        }
-                    }
-                    if (keys != null) {
-                        for (K key : keys) {
-                            deleteByKeyInsideSynchronized(key, stmt);
-                            if (keysToRemoveFromIdentityScope != null) {
-                                keysToRemoveFromIdentityScope.add(key);
-                            }
-                        }
-                    }
-                } finally {
-                    if (identityScope != null) {
-                        identityScope.unlock();
-                    }
-                }
+          if (entities != null) {
+            for (T entity : entities) {
+              K key = this.getKeyVerified(entity);
+              this.deleteByKeyInsideSynchronized(key, stmt);
+              if (keysToRemoveFromIdentityScope != null) {
+                keysToRemoveFromIdentityScope.add(key);
+              }
             }
-            db.setTransactionSuccessful();
-            if (keysToRemoveFromIdentityScope != null && identityScope != null) {
-                identityScope.remove(keysToRemoveFromIdentityScope);
-            }
-        } finally {
-            db.endTransaction();
-        }
-    }
-
-    /**
-     * Deletes the given entities in the database using a transaction.
-     * 
-     * @param entities
-     *            The entities to delete.
-     */
-    public void deleteInTx(Iterable<T> entities) {
-        deleteInTxInternal(entities, null);
-    }
-
-    /**
-     * Deletes the given entities in the database using a transaction.
-     * 
-     * @param entities
-     *            The entities to delete.
-     */
-    public void deleteInTx(T... entities) {
-        deleteInTxInternal(Arrays.asList(entities), null);
-    }
-
-    /**
-     * Deletes all entities with the given keys in the database using a transaction.
-     * 
-     * @param keys
-     *            Keys of the entities to delete.
-     */
-    public void deleteByKeyInTx(Iterable<K> keys) {
-        deleteInTxInternal(null, keys);
-    }
-
-    /**
-     * Deletes all entities with the given keys in the database using a transaction.
-     * 
-     * @param keys
-     *            Keys of the entities to delete.
-     */
-    public void deleteByKeyInTx(K... keys) {
-        deleteInTxInternal(null, Arrays.asList(keys));
-    }
-
-    /** Resets all locally changed properties of the entity by reloading the values from the database. */
-    public void refresh(T entity) {
-        assertSinglePk();
-        K key = getKeyVerified(entity);
-        String sql = statements.getSelectByKey();
-        String[] keyArray = new String[] { key.toString() };
-        Cursor cursor = db.rawQuery(sql, keyArray);
-        try {
-            boolean available = cursor.moveToFirst();
-            if (!available) {
-                throw new DaoException("Entity does not exist in the database anymore: " + entity.getClass()
-                        + " with key " + key);
-            } else if (!cursor.isLast()) {
-                throw new DaoException("Expected unique result, but count was " + cursor.getCount());
+          }
+          if (keys != null) {
+            for (K key : keys) {
+              this.deleteByKeyInsideSynchronized(key, stmt);
+              if (keysToRemoveFromIdentityScope != null) {
+                keysToRemoveFromIdentityScope.add(key);
+              }
             }
-            readEntity(cursor, entity, 0);
-            attachEntity(key, entity, true);
+          }
         } finally {
-            cursor.close();
+          if (this.identityScope != null) {
+            this.identityScope.unlock();
+          }
         }
-    }
-
-    public void update(T entity) {
-        assertSinglePk();
-        SQLiteStatement stmt = statements.getUpdateStatement();
-        if (db.isDbLockedByCurrentThread()) {
-            synchronized (stmt) {
-                updateInsideSynchronized(entity, stmt, true);
-            }
-        } else {
-            // Do TX to acquire a connection before locking the stmt to avoid deadlocks
-            db.beginTransaction();
-            try {
-                synchronized (stmt) {
-                    updateInsideSynchronized(entity, stmt, true);
-                }
-                db.setTransactionSuccessful();
-            } finally {
-                db.endTransaction();
-            }
-        }
-    }
-
-    public QueryBuilder<T> queryBuilder() {
-        return QueryBuilder.internalCreate(this);
-    }
-
-    protected void updateInsideSynchronized(T entity, SQLiteStatement stmt, boolean lock) {
-        // To do? Check if it's worth not to bind PKs here (performance).
-        bindValues(stmt, entity);
-        int index = config.allColumns.length + 1;
-        K key = getKey(entity);
-        if (key instanceof Long) {
-            stmt.bindLong(index, (Long) key);
-        } else if (key == null) {
-            throw new DaoException("Cannot update entity without key - was it inserted before?");
-        } else {
-            stmt.bindString(index, key.toString());
+      }
+      this.db.setTransactionSuccessful();
+      if ((keysToRemoveFromIdentityScope != null) && (this.identityScope != null)) {
+        this.identityScope.remove(keysToRemoveFromIdentityScope);
+      }
+    } finally {
+      this.db.endTransaction();
+    }
+  }
+
+  /**
+   * Deletes the given entities in the database using a transaction.
+   * 
+   * @param entities
+   *          The entities to delete.
+   */
+  public void deleteInTx(Iterable<T> entities) {
+    this.deleteInTxInternal(entities, null);
+  }
+
+  /**
+   * Deletes the given entities in the database using a transaction.
+   * 
+   * @param entities
+   *          The entities to delete.
+   */
+  public void deleteInTx(T... entities) {
+    this.deleteInTxInternal(Arrays.asList(entities), null);
+  }
+
+  /**
+   * Deletes all entities with the given keys in the database using a
+   * transaction.
+   * 
+   * @param keys
+   *          Keys of the entities to delete.
+   */
+  public void deleteByKeyInTx(Iterable<K> keys) {
+    this.deleteInTxInternal(null, keys);
+  }
+
+  /**
+   * Deletes all entities with the given keys in the database using a
+   * transaction.
+   * 
+   * @param keys
+   *          Keys of the entities to delete.
+   */
+  public void deleteByKeyInTx(K... keys) {
+    this.deleteInTxInternal(null, Arrays.asList(keys));
+  }
+
+  /**
+   * Resets all locally changed properties of the entity by reloading the values
+   * from the database.
+   */
+  public void refresh(T entity) {
+    this.assertSinglePk();
+    K key = this.getKeyVerified(entity);
+    String sql = this.statements.getSelectByKey();
+    String[] keyArray = new String[] { key.toString() };
+    Cursor cursor = this.db.rawQuery(sql, keyArray);
+    try {
+      boolean available = cursor.moveToFirst();
+      if (!available) {
+        throw new DaoException("Entity does not exist in the database anymore: " + entity.getClass() + " with key " + key);
+      } else if (!cursor.isLast()) {
+        throw new DaoException("Expected unique result, but count was " + cursor.getCount());
+      }
+      this.readEntity(cursor, entity, 0);
+      this.attachEntity(key, entity, true);
+    } finally {
+      cursor.close();
+    }
+  }
+
+  public void update(T entity) {
+    this.assertSinglePk();
+    SQLiteStatement stmt = this.statements.getUpdateStatement();
+    if (this.db.isDbLockedByCurrentThread()) {
+      synchronized (stmt) {
+        this.updateInsideSynchronized(entity, stmt, true);
+      }
+    } else {
+      // Do TX to acquire a connection before locking the stmt to avoid
+      // deadlocks
+      this.db.beginTransaction();
+      try {
+        synchronized (stmt) {
+          this.updateInsideSynchronized(entity, stmt, true);
         }
-        stmt.execute();
-        attachEntity(key, entity, lock);
-    }
-
-    /**
-     * Attaches the entity to the identity scope. Calls attachEntity(T entity).
-     * 
-     * @param key
-     *            Needed only for identity scope, pass null if there's none.
-     * @param entity
-     *            The entitiy to attach
-     * */
-    protected final void attachEntity(K key, T entity, boolean lock) {
-        if (identityScope != null && key != null) {
-            if (lock) {
-                identityScope.put(key, entity);
-            } else {
-                identityScope.putNoLock(key, entity);
-            }
+        this.db.setTransactionSuccessful();
+      } finally {
+        this.db.endTransaction();
+      }
+    }
+  }
+
+  public QueryBuilder<T> queryBuilder() {
+    return QueryBuilder.internalCreate(this);
+  }
+
+  protected void updateInsideSynchronized(T entity, SQLiteStatement stmt, boolean lock) {
+    // To do? Check if it's worth not to bind PKs here (performance).
+    this.bindValues(stmt, entity);
+    int index = this.config.allColumns.length + 1;
+    K key = this.getKey(entity);
+    if (key instanceof Long) {
+      stmt.bindLong(index, (Long) key);
+    } else if (key == null) {
+      throw new DaoException("Cannot update entity without key - was it inserted before?");
+    } else {
+      stmt.bindString(index, key.toString());
+    }
+    stmt.execute();
+    this.attachEntity(key, entity, lock);
+  }
+
+  /**
+   * Attaches the entity to the identity scope. Calls attachEntity(T entity).
+   * 
+   * @param key
+   *          Needed only for identity scope, pass null if there's none.
+   * @param entity
+   *          The entitiy to attach
+   * */
+  protected final void attachEntity(K key, T entity, boolean lock) {
+    if ((this.identityScope != null) && (key != null)) {
+      if (lock) {
+        this.identityScope.put(key, entity);
+      } else {
+        this.identityScope.putNoLock(key, entity);
+      }
+    }
+    this.attachEntity(entity);
+  }
+
+  /**
+   * Sub classes with relations additionally set the DaoMaster here.
+   * 
+   * @param entity
+   *          The entitiy to attach
+   * */
+  protected void attachEntity(T entity) {
+  }
+
+  /**
+   * Updates the given entities in the database using a transaction.
+   * 
+   * @param entities
+   *          The entities to insert.
+   */
+  public void updateInTx(Iterable<T> entities) {
+    SQLiteStatement stmt = this.statements.getUpdateStatement();
+    this.db.beginTransaction();
+    try {
+      synchronized (stmt) {
+        if (this.identityScope != null) {
+          this.identityScope.lock();
         }
-        attachEntity(entity);
-    }
-
-    /**
-     * Sub classes with relations additionally set the DaoMaster here.
-     * 
-     * @param entity
-     *            The entitiy to attach
-     * */
-    protected void attachEntity(T entity) {
-    }
-
-    /**
-     * Updates the given entities in the database using a transaction.
-     * 
-     * @param entities
-     *            The entities to insert.
-     */
-    public void updateInTx(Iterable<T> entities) {
-        SQLiteStatement stmt = statements.getUpdateStatement();
-        db.beginTransaction();
         try {
-            synchronized (stmt) {
-                if (identityScope != null) {
-                    identityScope.lock();
-                }
-                try {
-                    for (T entity : entities) {
-                        updateInsideSynchronized(entity, stmt, false);
-                    }
-                } finally {
-                    if (identityScope != null) {
-                        identityScope.unlock();
-                    }
-                }
-            }
-            db.setTransactionSuccessful();
+          for (T entity : entities) {
+            this.updateInsideSynchronized(entity, stmt, false);
+          }
         } finally {
-            db.endTransaction();
-        }
-    }
-
-    /**
-     * Updates the given entities in the database using a transaction.
-     * 
-     * @param entities
-     *            The entities to update.
-     */
-    public void updateInTx(T... entities) {
-        updateInTx(Arrays.asList(entities));
-    }
-
-    protected void assertSinglePk() {
-        if (config.pkColumns.length != 1) {
-            throw new DaoException(this + " (" + config.tablename + ") does not have a single-column primary key");
+          if (this.identityScope != null) {
+            this.identityScope.unlock();
+          }
         }
-    }
-
-    public long count() {
-        return DatabaseUtils.queryNumEntries(db, '\'' + config.tablename + '\'');
-    }
-
-    /** See {@link #getKey(Object)}, but guarantees that the returned key is never null (throws if null). */
-    protected K getKeyVerified(T entity) {
-        K key = getKey(entity);
-        if (key == null) {
-            if (entity == null) {
-                throw new NullPointerException("Entity may not be null");
-            } else {
-                throw new DaoException("Entity has no key");
-            }
+      }
+      this.db.setTransactionSuccessful();
+    } finally {
+      this.db.endTransaction();
+    }
+  }
+
+  /**
+   * Updates the given entities in the database using a transaction.
+   * 
+   * @param entities
+   *          The entities to update.
+   */
+  public void updateInTx(T... entities) {
+    this.updateInTx(Arrays.asList(entities));
+  }
+
+  protected void assertSinglePk() {
+    if (this.config.pkColumns.length != 1) {
+      throw new DaoException(this + " (" + this.config.tablename + ") does not have a single-column primary key");
+    }
+  }
+
+  public long count() {
+    return DatabaseUtils.queryNumEntries(this.db, '\'' + this.config.tablename + '\'');
+  }
+
+  /**
+   * See {@link #getKey(Object)}, but guarantees that the returned key is never
+   * null (throws if null).
+   */
+  protected K getKeyVerified(T entity) {
+    K key = this.getKey(entity);
+    if (key == null) {
+      if (entity == null) {
+        throw new NullPointerException("Entity may not be null");
+      } else {
+        throw new DaoException("Entity has no key");
+      }
+    } else {
+      return key;
+    }
+  }
+
+  /**
+   * Gets the SQLiteDatabase for custom database access. Not needed for greenDAO
+   * entities.
+   */
+  public SQLiteDatabase getDatabase() {
+    return this.db;
+  }
+
+  /**
+   * just stores the given entity, if the primary key field is filled, it will
+   * be updated, a check if the given primary key exists will be performed.
+   * Otherwise it will be inserted.
+   * 
+   * @see AbstractDao#save(Object, boolean)
+   * @param entity
+   *          the entity to save
+   * @return the saved entity
+   */
+  public T save(T entity) {
+    return this.save(entity, true);
+  }
+
+  /**
+   * just stores the given entity. if <code>checkExisting</code> is set to
+   * <code>true</code>, it will be checked if the given entity with the given
+   * primary key exists in the database
+   * 
+   * @param entity
+   *          the entity to save
+   * @param checkExistingPK
+   *          if <code>true</code> the primary key of the entity will be checked
+   *          against the database
+   * @return the saved entity
+   */
+  public T save(T entity, boolean checkExistingPK) {
+    K primaryKeyValue = this.getKey(entity);
+    if (primaryKeyValue == null) { // insert if there is no PK
+      this.insert(entity);
+    } else {
+      if (checkExistingPK) { // if have to chack, load the entity for the PK and
+                             // insert or update
+        T loadedEntity = this.load(primaryKeyValue);
+        if (loadedEntity != null) {
+          this.update(entity);
         } else {
-            return key;
+          this.insert(entity);
         }
-    }
-
-    /** Gets the SQLiteDatabase for custom database access. Not needed for greenDAO entities. */
-    public SQLiteDatabase getDatabase() {
-        return db;
-    }
-
-    /** Reads the values from the current position of the given cursor and returns a new entity. */
-    abstract protected T readEntity(Cursor cursor, int offset);
-
-    /** Reads the key from the current position of the given cursor, or returns null if there's no single-value key. */
-    abstract protected K readKey(Cursor cursor, int offset);
-
-    /** Reads the values from the current position of the given cursor into an existing entity. */
-    abstract protected void readEntity(Cursor cursor, T entity, int offset);
-
-    /** Binds the entity's values to the statement. Make sure to synchronize the statement outside of the method. */
-    abstract protected void bindValues(SQLiteStatement stmt, T entity);
-
-    /**
-     * Updates the entity's key if possible (only for Long PKs currently). This method must always return the entity's
-     * key regardless of whether the key existed before or not.
-     */
-    abstract protected K updateKeyAfterInsert(T entity, long rowId);
-
-    /**
-     * Returns the value of the primary key, if the entity has a single primary key, or, if not, null. Returns null if
-     * entity is null.
-     */
-    abstract protected K getKey(T entity);
-
-    /** Returns true if the Entity class can be updated, e.g. for setting the PK after insert. */
-    abstract protected boolean isEntityUpdateable();
-
+      } else { // if pk is set and no check wanted, just update. maybe an error
+               // will be thrown
+        this.update(entity);
+      }
+    }
+    return entity;
+  }
+
+  /**
+   * Reads the values from the current position of the given cursor and returns
+   * a new entity.
+   */
+  abstract protected T readEntity(Cursor cursor, int offset);
+
+  /**
+   * Reads the key from the current position of the given cursor, or returns
+   * null if there's no single-value key.
+   */
+  abstract protected K readKey(Cursor cursor, int offset);
+
+  /**
+   * Reads the values from the current position of the given cursor into an
+   * existing entity.
+   */
+  abstract protected void readEntity(Cursor cursor, T entity, int offset);
+
+  /**
+   * Binds the entity's values to the statement. Make sure to synchronize the
+   * statement outside of the method.
+   */
+  abstract protected void bindValues(SQLiteStatement stmt, T entity);
+
+  /**
+   * Updates the entity's key if possible (only for Long PKs currently). This
+   * method must always return the entity's key regardless of whether the key
+   * existed before or not.
+   */
+  abstract protected K updateKeyAfterInsert(T entity, long rowId);
+
+  /**
+   * Returns the value of the primary key, if the entity has a single primary
+   * key, or, if not, null. Returns null if entity is null.
+   */
+  abstract protected K getKey(T entity);
+
+  /**
+   * Returns true if the Entity class can be updated, e.g. for setting the PK
+   * after insert.
+   */
+  abstract protected boolean isEntityUpdateable();
 }
diff --git a/DaoCore/src/de/greenrobot/dao/query/AbstractEntityQueryBuilder.java b/DaoCore/src/de/greenrobot/dao/query/AbstractEntityQueryBuilder.java
new file mode 100644
index 00000000..c5f988c2
--- /dev/null
+++ b/DaoCore/src/de/greenrobot/dao/query/AbstractEntityQueryBuilder.java
@@ -0,0 +1,36 @@
+/**
+ * 
+ */
+package de.greenrobot.dao.query;
+
+import de.greenrobot.dao.AbstractDao;
+
+/**
+ * @author martin.s.schumacher
+ * @since 14.08.2013 17:25:38
+ * 
+ */
+public abstract class AbstractEntityQueryBuilder<T> extends QueryBuilder<T> {
+
+  protected AbstractEntityQueryBuilder(AbstractDao<T, ?> dao) {
+    super(dao);
+  }
+
+  protected AbstractEntityQueryBuilder(AbstractDao<T, ?> dao, String tablePrefix) {
+    super(dao, tablePrefix);
+  }
+
+  /**
+   * <p>
+   * creates a {@link Query} for <code>T</code> to find one by example.
+   * <p>
+   * Just nullable fields can be used.
+   * 
+   * @param example
+   *          the entity filled with example values
+   * 
+   * @return a {@link Query} to find the example entity
+   */
+  public abstract Query<T> findByExample(T example);
+
+}
diff --git a/DaoGenerator/src-generator-testentities/de/greenrobot/daogenerator/gentest/TestDaoGenerator.java b/DaoGenerator/src-generator-testentities/de/greenrobot/daogenerator/gentest/TestDaoGenerator.java
index cdb557a2..5a9267e2 100644
--- a/DaoGenerator/src-generator-testentities/de/greenrobot/daogenerator/gentest/TestDaoGenerator.java
+++ b/DaoGenerator/src-generator-testentities/de/greenrobot/daogenerator/gentest/TestDaoGenerator.java
@@ -59,6 +59,7 @@ public TestDaoGenerator() {
     this.createAutoincrement();
     this.createSqliteMaster();
     this.createEntityQueryBuilder();
+    this.createSave();
 
     this.createSchema2();
   }
@@ -288,4 +289,11 @@ protected void createEntityQueryBuilder() {
     entity.setEntityQueryBuilder(true);
   }
 
+  protected void createSave() {
+    Entity entity = this.schema.addEntity("SaveEntity");
+    entity.addIdProperty();
+    entity.addStringProperty("text");
+    entity.setEntityQueryBuilder(true);
+  }
+
 }
diff --git a/DaoGenerator/src-template/dao.ftl b/DaoGenerator/src-template/dao.ftl
index c8977b34..f876bbad 100644
--- a/DaoGenerator/src-template/dao.ftl
+++ b/DaoGenerator/src-template/dao.ftl
@@ -26,6 +26,7 @@ import java.util.List;
 </#if>
 <#if entity.toOneRelations?has_content || entity.hasEntityQueryBuilder>
 import java.util.ArrayList;
+import de.greenrobot.dao.query.AbstractEntityQueryBuilder;
 </#if>
 import android.database.Cursor;
 import android.database.sqlite.SQLiteDatabase;
@@ -303,7 +304,8 @@ as property>${property.columnName}<#if property_has_next>,</#if></#list>);");
         return query.list();
     }
 
-</#list>   
+</#list>  
+ 
 <#if entity.toOneRelations?has_content>
     <#include "dao-deep.ftl">
 </#if>
@@ -312,7 +314,7 @@ as property>${property.columnName}<#if property_has_next>,</#if></#list>);");
       return new ${entity.referencedClassName}QueryBuilder(this);
     }
 
-    public static class ${entity.referencedClassName}QueryBuilder extends QueryBuilder<${entity.referencedClassName}> {
+    public static class ${entity.referencedClassName}QueryBuilder extends AbstractEntityQueryBuilder<${entity.referencedClassName}> {
         ${entity.referencedClassName}QueryBuilder(AbstractDao<${entity.referencedClassName}, ?> dao) {
             super(dao);
         }
diff --git a/DaoTest/.classpath b/DaoTest/.classpath
index 6e692568..d7c57284 100644
--- a/DaoTest/.classpath
+++ b/DaoTest/.classpath
@@ -4,7 +4,7 @@
 	<classpathentry kind="src" path="gen"/>
 	<classpathentry kind="src" path="src-gen"/>
 	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
-	<classpathentry kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
 	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
 	<classpathentry kind="output" path="bin/classes"/>
 </classpath>
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/AbcdefEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/AbcdefEntityDao.java
index 63bcfc74..029b4122 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/AbcdefEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/AbcdefEntityDao.java
@@ -202,4 +202,5 @@ protected boolean isEntityUpdateable() {
         return true;
     }
     
+ 
 }
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/AnActiveEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/AnActiveEntityDao.java
index 21837b20..27d4c916 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/AnActiveEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/AnActiveEntityDao.java
@@ -121,4 +121,5 @@ protected boolean isEntityUpdateable() {
         return true;
     }
     
+ 
 }
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/AutoincrementEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/AutoincrementEntityDao.java
index 344db8df..ca2a470a 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/AutoincrementEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/AutoincrementEntityDao.java
@@ -103,4 +103,5 @@ protected boolean isEntityUpdateable() {
         return true;
     }
     
+ 
 }
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/ChildclassEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/ChildclassEntityDao.java
index c1576b2a..b411ad9b 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/ChildclassEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/ChildclassEntityDao.java
@@ -110,4 +110,5 @@ protected boolean isEntityUpdateable() {
         return true;
     }
     
+ 
 }
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/DaoMaster.java b/DaoTest/src-gen/de/greenrobot/daotest/DaoMaster.java
index 4abe6a70..31f47b4e 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/DaoMaster.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/DaoMaster.java
@@ -25,6 +25,7 @@
 import de.greenrobot.daotest.AutoincrementEntityDao;
 import de.greenrobot.daotest.SqliteMasterDao;
 import de.greenrobot.daotest.EntityQueryBuilderEntityDao;
+import de.greenrobot.daotest.SaveEntityDao;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
@@ -51,6 +52,7 @@ public static void createAllTables(SQLiteDatabase db, boolean ifNotExists) {
         StringKeyValueEntityDao.createTable(db, ifNotExists);
         AutoincrementEntityDao.createTable(db, ifNotExists);
         EntityQueryBuilderEntityDao.createTable(db, ifNotExists);
+        SaveEntityDao.createTable(db, ifNotExists);
     }
     
     /** Drops underlying database table using DAOs. */
@@ -71,6 +73,7 @@ public static void dropAllTables(SQLiteDatabase db, boolean ifExists) {
         StringKeyValueEntityDao.dropTable(db, ifExists);
         AutoincrementEntityDao.dropTable(db, ifExists);
         EntityQueryBuilderEntityDao.dropTable(db, ifExists);
+        SaveEntityDao.dropTable(db, ifExists);
     }
     
     public static abstract class OpenHelper extends SQLiteOpenHelper {
@@ -119,6 +122,7 @@ public DaoMaster(SQLiteDatabase db) {
         registerDaoClass(AutoincrementEntityDao.class);
         registerDaoClass(SqliteMasterDao.class);
         registerDaoClass(EntityQueryBuilderEntityDao.class);
+        registerDaoClass(SaveEntityDao.class);
     }
     
     public DaoSession newSession() {
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/DaoSession.java b/DaoTest/src-gen/de/greenrobot/daotest/DaoSession.java
index 4186c731..a89ee5c6 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/DaoSession.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/DaoSession.java
@@ -26,6 +26,7 @@
 import de.greenrobot.daotest.AutoincrementEntity;
 import de.greenrobot.daotest.SqliteMaster;
 import de.greenrobot.daotest.EntityQueryBuilderEntity;
+import de.greenrobot.daotest.SaveEntity;
 
 import de.greenrobot.daotest.SimpleEntityDao;
 import de.greenrobot.daotest.SimpleEntityNotNullDao;
@@ -44,6 +45,7 @@
 import de.greenrobot.daotest.AutoincrementEntityDao;
 import de.greenrobot.daotest.SqliteMasterDao;
 import de.greenrobot.daotest.EntityQueryBuilderEntityDao;
+import de.greenrobot.daotest.SaveEntityDao;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 
@@ -71,6 +73,7 @@
     private final DaoConfig autoincrementEntityDaoConfig;
     private final DaoConfig sqliteMasterDaoConfig;
     private final DaoConfig entityQueryBuilderEntityDaoConfig;
+    private final DaoConfig saveEntityDaoConfig;
 
     private final SimpleEntityDao simpleEntityDao;
     private final SimpleEntityNotNullDao simpleEntityNotNullDao;
@@ -89,6 +92,7 @@
     private final AutoincrementEntityDao autoincrementEntityDao;
     private final SqliteMasterDao sqliteMasterDao;
     private final EntityQueryBuilderEntityDao entityQueryBuilderEntityDao;
+    private final SaveEntityDao saveEntityDao;
 
     public DaoSession(SQLiteDatabase db, IdentityScopeType type, Map<Class<? extends AbstractDao<?, ?>>, DaoConfig>
             daoConfigMap) {
@@ -145,6 +149,9 @@ public DaoSession(SQLiteDatabase db, IdentityScopeType type, Map<Class<? extends
         entityQueryBuilderEntityDaoConfig = daoConfigMap.get(EntityQueryBuilderEntityDao.class).clone();
         entityQueryBuilderEntityDaoConfig.initIdentityScope(type);
 
+        saveEntityDaoConfig = daoConfigMap.get(SaveEntityDao.class).clone();
+        saveEntityDaoConfig.initIdentityScope(type);
+
         simpleEntityDao = new SimpleEntityDao(simpleEntityDaoConfig, this);
         simpleEntityNotNullDao = new SimpleEntityNotNullDao(simpleEntityNotNullDaoConfig, this);
         testEntityDao = new TestEntityDao(testEntityDaoConfig, this);
@@ -162,6 +169,7 @@ public DaoSession(SQLiteDatabase db, IdentityScopeType type, Map<Class<? extends
         autoincrementEntityDao = new AutoincrementEntityDao(autoincrementEntityDaoConfig, this);
         sqliteMasterDao = new SqliteMasterDao(sqliteMasterDaoConfig, this);
         entityQueryBuilderEntityDao = new EntityQueryBuilderEntityDao(entityQueryBuilderEntityDaoConfig, this);
+        saveEntityDao = new SaveEntityDao(saveEntityDaoConfig, this);
 
         registerDao(SimpleEntity.class, simpleEntityDao);
         registerDao(SimpleEntityNotNull.class, simpleEntityNotNullDao);
@@ -180,6 +188,7 @@ public DaoSession(SQLiteDatabase db, IdentityScopeType type, Map<Class<? extends
         registerDao(AutoincrementEntity.class, autoincrementEntityDao);
         registerDao(SqliteMaster.class, sqliteMasterDao);
         registerDao(EntityQueryBuilderEntity.class, entityQueryBuilderEntityDao);
+        registerDao(SaveEntity.class, saveEntityDao);
     }
     
     public void clear() {
@@ -200,6 +209,7 @@ public void clear() {
         autoincrementEntityDaoConfig.getIdentityScope().clear();
         sqliteMasterDaoConfig.getIdentityScope().clear();
         entityQueryBuilderEntityDaoConfig.getIdentityScope().clear();
+        saveEntityDaoConfig.getIdentityScope().clear();
     }
 
     public SimpleEntityDao getSimpleEntityDao() {
@@ -270,4 +280,8 @@ public EntityQueryBuilderEntityDao getEntityQueryBuilderEntityDao() {
         return entityQueryBuilderEntityDao;
     }
 
+    public SaveEntityDao getSaveEntityDao() {
+        return saveEntityDao;
+    }
+
 }
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/DateEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/DateEntityDao.java
index b3eb348f..26a70f2c 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/DateEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/DateEntityDao.java
@@ -117,4 +117,5 @@ protected boolean isEntityUpdateable() {
         return true;
     }
     
+ 
 }
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/EntityQueryBuilderEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/EntityQueryBuilderEntityDao.java
index a6919d18..ed60c9f9 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/EntityQueryBuilderEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/EntityQueryBuilderEntityDao.java
@@ -153,6 +153,7 @@ protected boolean isEntityUpdateable() {
         return true;
     }
     
+ 
     public EntityQueryBuilderEntityQueryBuilder queryBuilder() {
       return new EntityQueryBuilderEntityQueryBuilder(this);
     }
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/ExtendsImplementsEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/ExtendsImplementsEntityDao.java
index 10e62249..4ff30c89 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/ExtendsImplementsEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/ExtendsImplementsEntityDao.java
@@ -112,4 +112,5 @@ protected boolean isEntityUpdateable() {
         return true;
     }
     
+ 
 }
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/RelationEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/RelationEntityDao.java
index e98cf0e2..5131852a 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/RelationEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/RelationEntityDao.java
@@ -149,6 +149,7 @@ protected boolean isEntityUpdateable() {
         return true;
     }
     
+ 
     private String selectDeep;
 
     protected String getSelectDeep() {
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/SaveEntity.java b/DaoTest/src-gen/de/greenrobot/daotest/SaveEntity.java
new file mode 100644
index 00000000..79c5d49f
--- /dev/null
+++ b/DaoTest/src-gen/de/greenrobot/daotest/SaveEntity.java
@@ -0,0 +1,40 @@
+package de.greenrobot.daotest;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
+/**
+ * Entity mapped to table SAVE_ENTITY.
+ */
+public class SaveEntity {
+
+    private Long id;
+    private String text;
+
+    public SaveEntity() {
+    }
+
+    public SaveEntity(Long id) {
+        this.id = id;
+    }
+
+    public SaveEntity(Long id, String text) {
+        this.id = id;
+        this.text = text;
+    }
+
+    public Long getId() {
+        return id;
+    }
+
+    public void setId(Long id) {
+        this.id = id;
+    }
+
+    public String getText() {
+        return text;
+    }
+
+    public void setText(String text) {
+        this.text = text;
+    }
+
+}
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/SaveEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/SaveEntityDao.java
new file mode 100644
index 00000000..38e7ac4f
--- /dev/null
+++ b/DaoTest/src-gen/de/greenrobot/daotest/SaveEntityDao.java
@@ -0,0 +1,172 @@
+package de.greenrobot.daotest;
+
+import java.util.ArrayList;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteStatement;
+
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.Property;
+import de.greenrobot.dao.internal.DaoConfig;
+import de.greenrobot.dao.query.Query;
+import de.greenrobot.dao.query.QueryBuilder;
+import de.greenrobot.dao.query.WhereCondition;
+
+import de.greenrobot.daotest.SaveEntity;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+/** 
+ * DAO for table SAVE_ENTITY.
+*/
+public class SaveEntityDao extends AbstractDao<SaveEntity, Long> {
+
+    public static final String TABLENAME = "SAVE_ENTITY";
+
+    /**
+     * Properties of entity SaveEntity.<br/>
+     * Can be used for QueryBuilder and for referencing column names.
+    */
+    public static class Properties {
+        public final static Property Id = new Property(0, Long.class, "id", true, "_id");
+        public final static Property Text = new Property(1, String.class, "text", false, "TEXT");
+    };
+
+
+    public SaveEntityDao(DaoConfig config) {
+        super(config);
+    }
+    
+    public SaveEntityDao(DaoConfig config, DaoSession daoSession) {
+        super(config, daoSession);
+    }
+
+    /** Creates the underlying database table. */
+    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+        String constraint = ifNotExists? "IF NOT EXISTS ": "";
+        db.execSQL("CREATE TABLE " + constraint + "'SAVE_ENTITY' (" + //
+                "'_id' INTEGER PRIMARY KEY ," + // 0: id
+                "'TEXT' TEXT);"); // 1: text
+    }
+
+    /** Drops the underlying database table. */
+    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'SAVE_ENTITY'";
+        db.execSQL(sql);
+    }
+
+    /** @inheritdoc */
+    @Override
+    protected void bindValues(SQLiteStatement stmt, SaveEntity entity) {
+        stmt.clearBindings();
+ 
+        Long id = entity.getId();
+        if (id != null) {
+            stmt.bindLong(1, id);
+        }
+ 
+        String text = entity.getText();
+        if (text != null) {
+            stmt.bindString(2, text);
+        }
+    }
+
+    /** @inheritdoc */
+    @Override
+    public Long readKey(Cursor cursor, int offset) {
+        return cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0);
+    }    
+
+    /** @inheritdoc */
+    @Override
+    public SaveEntity readEntity(Cursor cursor, int offset) {
+        SaveEntity entity = new SaveEntity( //
+            cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0), // id
+            cursor.isNull(offset + 1) ? null : cursor.getString(offset + 1) // text
+        );
+        return entity;
+    }
+     
+    /** @inheritdoc */
+    @Override
+    public void readEntity(Cursor cursor, SaveEntity entity, int offset) {
+        entity.setId(cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0));
+        entity.setText(cursor.isNull(offset + 1) ? null : cursor.getString(offset + 1));
+     }
+    
+    /** @inheritdoc */
+    @Override
+    protected Long updateKeyAfterInsert(SaveEntity entity, long rowId) {
+        entity.setId(rowId);
+        return rowId;
+    }
+    
+    /** @inheritdoc */
+    @Override
+    public Long getKey(SaveEntity entity) {
+        if(entity != null) {
+            return entity.getId();
+        } else {
+            return null;
+        }
+    }
+
+    /** @inheritdoc */
+    @Override    
+    protected boolean isEntityUpdateable() {
+        return true;
+    }
+    
+ 
+    public SaveEntityQueryBuilder queryBuilder() {
+      return new SaveEntityQueryBuilder(this);
+    }
+
+    public static class SaveEntityQueryBuilder extends QueryBuilder<SaveEntity> {
+        SaveEntityQueryBuilder(AbstractDao<SaveEntity, ?> dao) {
+            super(dao);
+        }
+        
+        public Query<SaveEntity> findByPrimaryKey(Long pk) {
+            this.where(Properties.Id.eq(pk));
+            return this.build();
+        }
+        
+        public Query<SaveEntity> findAll() {
+            return this.build();
+        }
+        
+        /**
+         * <p>creates a {@link Query} for {@link SaveEntity} to find one by example.
+         * <p>Just nullable fields can be used. Just set one of these properties:
+         * <ul>
+         * <li><code>String text</code></li>
+         * </ul>
+         *
+         * @param example
+         *          the entity filled with example values
+         * 
+         * @return a {@link Query} to find the example entity
+         */
+        public Query<SaveEntity> findByExample(SaveEntity example) { 
+            if(example.getId() != null) {
+                return findByPrimaryKey(example.getId());
+            }
+        	
+            ArrayList<WhereCondition> conditions = new ArrayList<WhereCondition>();
+
+            if (example.getText() != null) {
+                conditions.add(Properties.Text.eq(example.getText()));
+            }
+           
+            if (conditions.isEmpty()) {
+                throw new IllegalArgumentException("No example values given. Please provide at least one value!");
+            }
+
+            WhereCondition firstCondition = conditions.get(0);
+            conditions.remove(0);
+            this.where(firstCondition, conditions.toArray(new WhereCondition[0]));
+
+        	return this.build();
+        }
+    }
+}
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntityDao.java
index 70a5df92..cb71aad0 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntityDao.java
@@ -184,4 +184,5 @@ protected boolean isEntityUpdateable() {
         return true;
     }
     
+ 
 }
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntityNotNullDao.java b/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntityNotNullDao.java
index 246d9392..3e6c4e65 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntityNotNullDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntityNotNullDao.java
@@ -144,4 +144,5 @@ protected boolean isEntityUpdateable() {
         return true;
     }
     
+ 
 }
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/SpecialNamesEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/SpecialNamesEntityDao.java
index 184203a7..279d9638 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/SpecialNamesEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/SpecialNamesEntityDao.java
@@ -184,4 +184,5 @@ protected boolean isEntityUpdateable() {
         return true;
     }
     
+ 
 }
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/SqliteMasterDao.java b/DaoTest/src-gen/de/greenrobot/daotest/SqliteMasterDao.java
index b83e409c..66641a1d 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/SqliteMasterDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/SqliteMasterDao.java
@@ -118,4 +118,5 @@ protected boolean isEntityUpdateable() {
         return true;
     }
     
+ 
 }
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/StringKeyValueEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/StringKeyValueEntityDao.java
index bdf2cd83..29c8e916 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/StringKeyValueEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/StringKeyValueEntityDao.java
@@ -111,4 +111,5 @@ protected boolean isEntityUpdateable() {
         return true;
     }
     
+ 
 }
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/TestEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/TestEntityDao.java
index b3d584ae..5f77a265 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/TestEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/TestEntityDao.java
@@ -172,4 +172,5 @@ protected boolean isEntityUpdateable() {
         return true;
     }
     
+ 
 }
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/ToManyEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/ToManyEntityDao.java
index 953c2ad0..0f106dac 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/ToManyEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/ToManyEntityDao.java
@@ -121,4 +121,5 @@ protected boolean isEntityUpdateable() {
         return true;
     }
     
+ 
 }
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/ToManyTargetEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/ToManyTargetEntityDao.java
index ff44764b..4bbd6a69 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/ToManyTargetEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/ToManyTargetEntityDao.java
@@ -199,4 +199,5 @@ protected boolean isEntityUpdateable() {
         return query.list();
     }
 
+ 
 }
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/TreeEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/TreeEntityDao.java
index 0e0009b9..a0864665 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/TreeEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/TreeEntityDao.java
@@ -141,6 +141,7 @@ protected boolean isEntityUpdateable() {
         return query.list();
     }
 
+ 
     private String selectDeep;
 
     protected String getSelectDeep() {
diff --git a/DaoTest/src-gen/de/greenrobot/daotest2/dao/KeepEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest2/dao/KeepEntityDao.java
index f8de31aa..01138a78 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest2/dao/KeepEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest2/dao/KeepEntityDao.java
@@ -103,4 +103,5 @@ protected boolean isEntityUpdateable() {
         return true;
     }
     
+ 
 }
diff --git a/DaoTest/src-gen/de/greenrobot/daotest2/dao/ToManyTarget2Dao.java b/DaoTest/src-gen/de/greenrobot/daotest2/dao/ToManyTarget2Dao.java
index a55df346..3fb6ceb5 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest2/dao/ToManyTarget2Dao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest2/dao/ToManyTarget2Dao.java
@@ -130,4 +130,5 @@ protected boolean isEntityUpdateable() {
         return query.list();
     }
 
+ 
 }
diff --git a/DaoTest/src-gen/de/greenrobot/daotest2/specialdao/RelationSource2Dao.java b/DaoTest/src-gen/de/greenrobot/daotest2/specialdao/RelationSource2Dao.java
index a1faad37..f839c3fa 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest2/specialdao/RelationSource2Dao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest2/specialdao/RelationSource2Dao.java
@@ -127,6 +127,7 @@ protected boolean isEntityUpdateable() {
         return true;
     }
     
+ 
     private String selectDeep;
 
     protected String getSelectDeep() {
diff --git a/DaoTest/src-gen/de/greenrobot/daotest2/to1_specialdao/ToOneTarget2Dao.java b/DaoTest/src-gen/de/greenrobot/daotest2/to1_specialdao/ToOneTarget2Dao.java
index 5938da1e..8b83de9d 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest2/to1_specialdao/ToOneTarget2Dao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest2/to1_specialdao/ToOneTarget2Dao.java
@@ -105,4 +105,5 @@ protected boolean isEntityUpdateable() {
         return true;
     }
     
+ 
 }
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/SaveEntityTest.java b/DaoTest/src/de/greenrobot/daotest/entity/SaveEntityTest.java
new file mode 100644
index 00000000..bb2803ac
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/entity/SaveEntityTest.java
@@ -0,0 +1,89 @@
+package de.greenrobot.daotest.entity;
+
+import java.util.List;
+
+import de.greenrobot.dao.test.AbstractDaoTestLongPk;
+import de.greenrobot.daotest.SaveEntity;
+import de.greenrobot.daotest.SaveEntityDao;
+
+public class SaveEntityTest extends AbstractDaoTestLongPk<SaveEntityDao, SaveEntity> {
+
+  public SaveEntityTest() {
+    super(SaveEntityDao.class);
+  }
+
+  @Override
+  protected SaveEntity createEntity(Long key) {
+    SaveEntity entity = new SaveEntity(key, "save");
+    return entity;
+  }
+
+  public void testSaveInsert() {
+    SaveEntity entity = this.createEntity(null);
+    SaveEntity actual = this.dao.save(entity);
+
+    assertNotNull(actual);
+    assertNotNull(actual.getId());
+    assertEquals("save", actual.getText());
+
+    this.assertEntity(actual.getId(), "save");
+
+  }
+
+  protected void assertEntity(Long pk, String assertString) {
+    List<SaveEntity> queryresult = this.dao.queryBuilder().findByPrimaryKey(pk).list();
+
+    assertNotNull(queryresult);
+    assertEquals(1, queryresult.size());
+    assertEquals(assertString, queryresult.get(0).getText());
+  }
+
+  public void testSaveUpdateWithoutCheck() {
+    Long nextPk = this.nextPk();
+    SaveEntity entity = this.createEntity(nextPk);
+    SaveEntity actual = this.dao.save(entity);
+
+    assertNotNull(actual);
+    assertNotNull(actual.getId());
+    assertEquals("save", actual.getText());
+    this.assertEntity(nextPk, "save");
+
+    entity.setText("new text");
+
+    actual = this.dao.save(entity);
+
+    assertNotNull(actual);
+    assertEquals(nextPk, actual.getId());
+    assertEquals("new text", actual.getText());
+    this.assertEntity(nextPk, "new text");
+
+    entity.setText("another new text");
+
+    actual = this.dao.save(entity, false);
+
+    assertNotNull(actual);
+    assertEquals(nextPk, actual.getId());
+    assertEquals("another new text", actual.getText());
+    this.assertEntity(nextPk, "another new text");
+  }
+
+  public void testSaveUpdateWithCheck() {
+    Long nextPk = this.nextPk();
+    SaveEntity entity = this.createEntity(nextPk);
+    SaveEntity actual = this.dao.save(entity, true);
+
+    assertNotNull(actual);
+    assertNotNull(actual.getId());
+    assertEquals("save", actual.getText());
+    this.assertEntity(nextPk, "save");
+
+    entity.setText("new text");
+
+    actual = this.dao.save(entity, true);
+
+    assertNotNull(actual);
+    assertEquals(nextPk, actual.getId());
+    assertEquals("new text", actual.getText());
+    this.assertEntity(nextPk, "new text");
+  }
+}
