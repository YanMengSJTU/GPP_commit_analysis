diff --git a/AndroidOtto/otto-sample/.gitignore b/AndroidOtto/otto-sample/.gitignore
new file mode 100644
index 0000000..796b96d
--- /dev/null
+++ b/AndroidOtto/otto-sample/.gitignore
@@ -0,0 +1 @@
+/build
diff --git a/AndroidOtto/otto-sample/build.gradle b/AndroidOtto/otto-sample/build.gradle
new file mode 100644
index 0000000..6b2c266
--- /dev/null
+++ b/AndroidOtto/otto-sample/build.gradle
@@ -0,0 +1,27 @@
+apply plugin: 'com.android.application'
+
+android {
+    compileSdkVersion 23
+    buildToolsVersion "23.0.2"
+
+    defaultConfig {
+        applicationId "com.squareup.otto.sample"
+        minSdkVersion 15
+        targetSdkVersion 23
+        versionCode 1
+        versionName "1.0"
+    }
+    buildTypes {
+        release {
+            minifyEnabled false
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
+        }
+    }
+}
+
+dependencies {
+    compile fileTree(dir: 'libs', include: ['*.jar'])
+    testCompile 'junit:junit:4.12'
+    compile 'com.android.support:appcompat-v7:23.2.0'
+    compile project(':otto')
+}
diff --git a/AndroidOtto/otto-sample/proguard-rules.pro b/AndroidOtto/otto-sample/proguard-rules.pro
new file mode 100644
index 0000000..7cc6bcf
--- /dev/null
+++ b/AndroidOtto/otto-sample/proguard-rules.pro
@@ -0,0 +1,17 @@
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in /Users/chenzhiyong/Library/Android/sdk/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the proguardFiles
+# directive in build.gradle.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
diff --git a/AndroidOtto/otto-sample/src/androidTest/java/com/squareup/otto/sample/ApplicationTest.java b/AndroidOtto/otto-sample/src/androidTest/java/com/squareup/otto/sample/ApplicationTest.java
new file mode 100644
index 0000000..4f1150a
--- /dev/null
+++ b/AndroidOtto/otto-sample/src/androidTest/java/com/squareup/otto/sample/ApplicationTest.java
@@ -0,0 +1,13 @@
+package com.squareup.otto.sample;
+
+import android.app.Application;
+import android.test.ApplicationTestCase;
+
+/**
+ * <a href="http://d.android.com/tools/testing/testing_android.html">Testing Fundamentals</a>
+ */
+public class ApplicationTest extends ApplicationTestCase<Application> {
+	public ApplicationTest() {
+		super(Application.class);
+	}
+}
\ No newline at end of file
diff --git a/AndroidOtto/otto-sample/src/main/AndroidManifest.xml b/AndroidOtto/otto-sample/src/main/AndroidManifest.xml
new file mode 100644
index 0000000..df6a621
--- /dev/null
+++ b/AndroidOtto/otto-sample/src/main/AndroidManifest.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest package="com.squareup.otto.sample"
+          xmlns:android="http://schemas.android.com/apk/res/android">
+    <uses-permission android:name="android.permission.INTERNET"/>
+    <application
+        android:allowBackup="true"
+        android:icon="@mipmap/ic_launcher"
+        android:label="@string/app_name"
+        android:supportsRtl="true"
+        android:theme="@style/AppTheme">
+
+        <activity
+            android:name=".LocationActivity"
+            android:label="@string/app_name">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN"/>
+                <category android:name="android.intent.category.LAUNCHER"/>
+                <category android:name="android.intent.category.DEFAULT"/>
+            </intent-filter>
+        </activity>
+    </application>
+
+</manifest>
diff --git a/AndroidOtto/otto-sample/src/main/java/com/squareup/otto/sample/BusProvider.java b/AndroidOtto/otto-sample/src/main/java/com/squareup/otto/sample/BusProvider.java
new file mode 100644
index 0000000..9ab71c1
--- /dev/null
+++ b/AndroidOtto/otto-sample/src/main/java/com/squareup/otto/sample/BusProvider.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.squareup.otto.sample;
+
+import com.squareup.otto.Bus;
+
+/**
+ * Maintains a singleton instance for obtaining the bus. Ideally this would be replaced with a more efficient means
+ * such as through injection directly into interested classes.
+ */
+public final class BusProvider {
+  private static final Bus BUS = new Bus();
+
+  public static Bus getInstance() {
+    return BUS;
+  }
+
+  private BusProvider() {
+    // No instances.
+  }
+}
diff --git a/AndroidOtto/otto-sample/src/main/java/com/squareup/otto/sample/LocationActivity.java b/AndroidOtto/otto-sample/src/main/java/com/squareup/otto/sample/LocationActivity.java
new file mode 100644
index 0000000..0d5704a
--- /dev/null
+++ b/AndroidOtto/otto-sample/src/main/java/com/squareup/otto/sample/LocationActivity.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.squareup.otto.sample;
+
+import android.os.Bundle;
+import android.support.v4.app.FragmentActivity;
+import android.view.View;
+import com.squareup.otto.Produce;
+
+import java.util.Random;
+
+import static android.view.View.OnClickListener;
+
+public class LocationActivity extends FragmentActivity {
+  public static final float DEFAULT_LAT = 40.440866f;
+  public static final float DEFAULT_LON = -79.994085f;
+  private static final float OFFSET = 0.1f;
+  private static final Random RANDOM = new Random();
+
+  private static float lastLatitude = DEFAULT_LAT;
+  private static float lastLongitude = DEFAULT_LON;
+
+  @Override protected void onCreate(Bundle savedInstanceState) {
+    super.onCreate(savedInstanceState);
+    setContentView(R.layout.location_history);
+
+    findViewById(R.id.clear_location).setOnClickListener(new OnClickListener() {
+      @Override public void onClick(View v) {
+        // Tell everyone to clear their location history.
+        BusProvider.getInstance().post(new LocationClearEvent());
+
+        // Post new location event for the default location.
+        lastLatitude = DEFAULT_LAT;
+        lastLongitude = DEFAULT_LON;
+        BusProvider.getInstance().post(produceLocationEvent());
+      }
+    });
+
+    findViewById(R.id.move_location).setOnClickListener(new OnClickListener() {
+      @Override public void onClick(View v) {
+        lastLatitude += (RANDOM.nextFloat() * OFFSET * 2) - OFFSET;
+        lastLongitude += (RANDOM.nextFloat() * OFFSET * 2) - OFFSET;
+        BusProvider.getInstance().post(produceLocationEvent());
+      }
+    });
+  }
+
+  @Override protected void onResume() {
+    super.onResume();
+
+    // Register ourselves so that we can provide the initial value.
+    BusProvider.getInstance().register(this);
+  }
+
+  @Override protected void onPause() {
+    super.onPause();
+
+    // Always unregister when an object no longer should be on the bus.
+    BusProvider.getInstance().unregister(this);
+  }
+
+  @Produce public LocationChangedEvent produceLocationEvent() {
+    // Provide an initial value for location based on the last known position.
+    return new LocationChangedEvent(lastLatitude, lastLongitude);
+  }
+}
diff --git a/AndroidOtto/otto-sample/src/main/java/com/squareup/otto/sample/LocationChangedEvent.java b/AndroidOtto/otto-sample/src/main/java/com/squareup/otto/sample/LocationChangedEvent.java
new file mode 100644
index 0000000..e2e0b32
--- /dev/null
+++ b/AndroidOtto/otto-sample/src/main/java/com/squareup/otto/sample/LocationChangedEvent.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.squareup.otto.sample;
+
+public class LocationChangedEvent {
+  public final float lat;
+  public final float lon;
+
+  public LocationChangedEvent(float lat, float lon) {
+    this.lat = lat;
+    this.lon = lon;
+  }
+
+  @Override public String toString() {
+    return new StringBuilder("(") //
+        .append(lat) //
+        .append(", ") //
+        .append(lon) //
+        .append(")") //
+        .toString();
+  }
+}
diff --git a/AndroidOtto/otto-sample/src/main/java/com/squareup/otto/sample/LocationClearEvent.java b/AndroidOtto/otto-sample/src/main/java/com/squareup/otto/sample/LocationClearEvent.java
new file mode 100644
index 0000000..b489a28
--- /dev/null
+++ b/AndroidOtto/otto-sample/src/main/java/com/squareup/otto/sample/LocationClearEvent.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.squareup.otto.sample;
+
+public class LocationClearEvent {
+}
diff --git a/AndroidOtto/otto-sample/src/main/java/com/squareup/otto/sample/LocationHistoryFragment.java b/AndroidOtto/otto-sample/src/main/java/com/squareup/otto/sample/LocationHistoryFragment.java
new file mode 100644
index 0000000..70a7f23
--- /dev/null
+++ b/AndroidOtto/otto-sample/src/main/java/com/squareup/otto/sample/LocationHistoryFragment.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.squareup.otto.sample;
+
+import android.os.Bundle;
+import android.support.v4.app.ListFragment;
+import android.view.View;
+import android.widget.ArrayAdapter;
+
+import com.squareup.otto.Produce;
+import com.squareup.otto.Subscribe;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Maintain a scrollable history of location events.
+ */
+public class LocationHistoryFragment extends ListFragment {
+	private final List<String> locationEvents = new ArrayList<String>();
+	private ArrayAdapter<String> adapter;
+
+	@Override
+	public void onResume() {
+		super.onResume();
+		BusProvider.getInstance().register(this);
+	}
+
+	@Override
+	public void onPause() {
+		super.onPause();
+		BusProvider.getInstance().unregister(this);
+	}
+
+	@Override
+	public void onViewCreated(View view, Bundle savedInstanceState) {
+		super.onViewCreated(view, savedInstanceState);
+		adapter = new ArrayAdapter<String>(getActivity(), android.R.layout.simple_list_item_1, locationEvents);
+		setListAdapter(adapter);
+	}
+
+	@Subscribe
+	public void onLocationChanged(LocationChangedEvent event) {
+		locationEvents.add(0, event.toString());
+		if (adapter != null) {
+			adapter.notifyDataSetChanged();
+		}
+	}
+
+	@Subscribe
+	public void onLocationCleared(LocationClearEvent event) {
+		locationEvents.clear();
+		if (adapter != null) {
+			adapter.notifyDataSetChanged();
+		}
+	}
+
+}
diff --git a/AndroidOtto/otto-sample/src/main/java/com/squareup/otto/sample/LocationMapFragment.java b/AndroidOtto/otto-sample/src/main/java/com/squareup/otto/sample/LocationMapFragment.java
new file mode 100644
index 0000000..ced9eb1
--- /dev/null
+++ b/AndroidOtto/otto-sample/src/main/java/com/squareup/otto/sample/LocationMapFragment.java
@@ -0,0 +1,106 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.squareup.otto.sample;
+
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import android.os.AsyncTask;
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+import android.util.Log;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.ImageView;
+import com.squareup.otto.Subscribe;
+
+import java.net.URL;
+
+import static android.widget.ImageView.ScaleType.CENTER_INSIDE;
+
+/** Display a map centered on the last known location. */
+public class LocationMapFragment extends Fragment {
+  private static final String URL =
+      "https://maps.googleapis.com/maps/api/staticmap?sensor=false&size=400x400&zoom=13&center=%s,%s";
+  private static DownloadTask downloadTask;
+
+  private ImageView imageView;
+
+  @Override public void onResume() {
+    super.onResume();
+    BusProvider.getInstance().register(this);
+  }
+
+  @Override public void onPause() {
+    super.onPause();
+    BusProvider.getInstance().unregister(this);
+
+    // Stop existing download, if it exists.
+    if (downloadTask != null) {
+      downloadTask.cancel(true);
+      downloadTask = null;
+    }
+  }
+
+  @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
+    imageView = new ImageView(getActivity());
+    imageView.setScaleType(CENTER_INSIDE);
+    return imageView;
+  }
+
+  @Subscribe public void onLocationChanged(LocationChangedEvent event) {
+    // Stop existing download, if it exists.
+    if (downloadTask != null) {
+      downloadTask.cancel(true);
+    }
+
+    // Trigger a background download of an image for the new location.
+    downloadTask = new DownloadTask();
+    downloadTask.execute(String.format(URL, event.lat, event.lon));
+  }
+
+  @Subscribe public void onImageAvailable(ImageAvailableEvent event) {
+    if (imageView != null) {
+      imageView.setImageDrawable(event.image);
+    }
+  }
+
+  private static class ImageAvailableEvent {
+    public final Drawable image;
+
+    ImageAvailableEvent(Drawable image) {
+      this.image = image;
+    }
+  }
+
+  private static class DownloadTask extends AsyncTask<String, Void, Drawable> {
+    @Override protected Drawable doInBackground(String... params) {
+      try {
+        return BitmapDrawable.createFromStream(new URL(params[0]).openStream(), "bitmap.jpg");
+      } catch (Exception e) {
+        Log.e("LocationMapFragment", "Unable to download image.", e);
+        return null;
+      }
+    }
+
+    @Override protected void onPostExecute(Drawable drawable) {
+      if (!isCancelled() && drawable != null) {
+        BusProvider.getInstance().post(new ImageAvailableEvent(drawable));
+      }
+    }
+  }
+}
diff --git a/AndroidOtto/otto-sample/src/main/res/layout/location_history.xml b/AndroidOtto/otto-sample/src/main/res/layout/location_history.xml
new file mode 100644
index 0000000..15a1956
--- /dev/null
+++ b/AndroidOtto/otto-sample/src/main/res/layout/location_history.xml
@@ -0,0 +1,39 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              android:layout_width="match_parent"
+              android:layout_height="match_parent"
+              android:orientation="vertical"
+              android:padding="@dimen/holo_gap">
+    <LinearLayout
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:layout_marginBottom="@dimen/holo_gap"
+            android:orientation="horizontal">
+        <Button android:id="@+id/clear_location"
+                android:layout_width="0dp"
+                android:layout_height="wrap_content"
+                android:layout_weight="1"
+                android:layout_marginRight="@dimen/holo_gap"
+                android:text="@string/clear_location"
+                />
+        <Button android:id="@+id/move_location"
+                android:layout_width="0dp"
+                android:layout_height="wrap_content"
+                android:layout_weight="1"
+                android:text="@string/move_location"
+                />
+    </LinearLayout>
+    <fragment class="com.squareup.otto.sample.LocationMapFragment"
+              android:id="@+id/map"
+              android:layout_width="match_parent"
+              android:layout_height="0dp"
+              android:layout_weight="1"
+              android:layout_marginBottom="@dimen/holo_gap"/>
+    <fragment class="com.squareup.otto.sample.LocationHistoryFragment"
+              android:id="@+id/history"
+              android:layout_width="match_parent"
+              android:layout_height="0dp"
+              android:layout_weight="1"
+            />
+</LinearLayout>
\ No newline at end of file
diff --git a/AndroidOtto/otto-sample/src/main/res/mipmap-hdpi/ic_launcher.png b/AndroidOtto/otto-sample/src/main/res/mipmap-hdpi/ic_launcher.png
new file mode 100644
index 0000000..cde69bc
Binary files /dev/null and b/AndroidOtto/otto-sample/src/main/res/mipmap-hdpi/ic_launcher.png differ
diff --git a/AndroidOtto/otto-sample/src/main/res/mipmap-mdpi/ic_launcher.png b/AndroidOtto/otto-sample/src/main/res/mipmap-mdpi/ic_launcher.png
new file mode 100644
index 0000000..c133a0c
Binary files /dev/null and b/AndroidOtto/otto-sample/src/main/res/mipmap-mdpi/ic_launcher.png differ
diff --git a/AndroidOtto/otto-sample/src/main/res/mipmap-xhdpi/ic_launcher.png b/AndroidOtto/otto-sample/src/main/res/mipmap-xhdpi/ic_launcher.png
new file mode 100644
index 0000000..bfa42f0
Binary files /dev/null and b/AndroidOtto/otto-sample/src/main/res/mipmap-xhdpi/ic_launcher.png differ
diff --git a/AndroidOtto/otto-sample/src/main/res/mipmap-xxhdpi/ic_launcher.png b/AndroidOtto/otto-sample/src/main/res/mipmap-xxhdpi/ic_launcher.png
new file mode 100644
index 0000000..324e72c
Binary files /dev/null and b/AndroidOtto/otto-sample/src/main/res/mipmap-xxhdpi/ic_launcher.png differ
diff --git a/AndroidOtto/otto-sample/src/main/res/mipmap-xxxhdpi/ic_launcher.png b/AndroidOtto/otto-sample/src/main/res/mipmap-xxxhdpi/ic_launcher.png
new file mode 100644
index 0000000..aee44e1
Binary files /dev/null and b/AndroidOtto/otto-sample/src/main/res/mipmap-xxxhdpi/ic_launcher.png differ
diff --git a/AndroidOtto/otto-sample/src/main/res/values-w820dp/dimens.xml b/AndroidOtto/otto-sample/src/main/res/values-w820dp/dimens.xml
new file mode 100644
index 0000000..63fc816
--- /dev/null
+++ b/AndroidOtto/otto-sample/src/main/res/values-w820dp/dimens.xml
@@ -0,0 +1,6 @@
+<resources>
+    <!-- Example customization of dimensions originally defined in res/values/dimens.xml
+         (such as screen margins) for screens with more than 820dp of available width. This
+         would include 7" and 10" devices in landscape (~960dp and ~1280dp respectively). -->
+    <dimen name="activity_horizontal_margin">64dp</dimen>
+</resources>
diff --git a/AndroidOtto/otto-sample/src/main/res/values/colors.xml b/AndroidOtto/otto-sample/src/main/res/values/colors.xml
new file mode 100644
index 0000000..3ab3e9c
--- /dev/null
+++ b/AndroidOtto/otto-sample/src/main/res/values/colors.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <color name="colorPrimary">#3F51B5</color>
+    <color name="colorPrimaryDark">#303F9F</color>
+    <color name="colorAccent">#FF4081</color>
+</resources>
diff --git a/AndroidOtto/otto-sample/src/main/res/values/dimens.xml b/AndroidOtto/otto-sample/src/main/res/values/dimens.xml
new file mode 100644
index 0000000..9019ca5
--- /dev/null
+++ b/AndroidOtto/otto-sample/src/main/res/values/dimens.xml
@@ -0,0 +1,6 @@
+<resources>
+    <!-- Default screen margins, per the Android Design guidelines. -->
+    <dimen name="activity_horizontal_margin">16dp</dimen>
+    <dimen name="activity_vertical_margin">16dp</dimen>
+    <dimen name="holo_gap">8dp</dimen>
+</resources>
diff --git a/AndroidOtto/otto-sample/src/main/res/values/strings.xml b/AndroidOtto/otto-sample/src/main/res/values/strings.xml
new file mode 100644
index 0000000..489214a
--- /dev/null
+++ b/AndroidOtto/otto-sample/src/main/res/values/strings.xml
@@ -0,0 +1,5 @@
+<resources>
+    <string name="app_name">Otto Sample</string>
+    <string name="move_location">Move Location</string>
+    <string name="clear_location">Clear History</string>
+</resources>
diff --git a/AndroidOtto/otto-sample/src/main/res/values/styles.xml b/AndroidOtto/otto-sample/src/main/res/values/styles.xml
new file mode 100644
index 0000000..5885930
--- /dev/null
+++ b/AndroidOtto/otto-sample/src/main/res/values/styles.xml
@@ -0,0 +1,11 @@
+<resources>
+
+    <!-- Base application theme. -->
+    <style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
+        <!-- Customize your theme here. -->
+        <item name="colorPrimary">@color/colorPrimary</item>
+        <item name="colorPrimaryDark">@color/colorPrimaryDark</item>
+        <item name="colorAccent">@color/colorAccent</item>
+    </style>
+
+</resources>
diff --git a/AndroidOtto/otto-sample/src/test/java/com/squareup/otto/sample/ExampleUnitTest.java b/AndroidOtto/otto-sample/src/test/java/com/squareup/otto/sample/ExampleUnitTest.java
new file mode 100644
index 0000000..26bf88a
--- /dev/null
+++ b/AndroidOtto/otto-sample/src/test/java/com/squareup/otto/sample/ExampleUnitTest.java
@@ -0,0 +1,15 @@
+package com.squareup.otto.sample;
+
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+/**
+ * To work on unit tests, switch the Test Artifact in the Build Variants view.
+ */
+public class ExampleUnitTest {
+	@Test
+	public void addition_isCorrect() throws Exception {
+		assertEquals(4, 2 + 2);
+	}
+}
\ No newline at end of file
diff --git a/AndroidOtto/otto/.gitignore b/AndroidOtto/otto/.gitignore
new file mode 100644
index 0000000..796b96d
--- /dev/null
+++ b/AndroidOtto/otto/.gitignore
@@ -0,0 +1 @@
+/build
diff --git a/AndroidOtto/otto/build.gradle b/AndroidOtto/otto/build.gradle
new file mode 100644
index 0000000..42610dc
--- /dev/null
+++ b/AndroidOtto/otto/build.gradle
@@ -0,0 +1,25 @@
+apply plugin: 'com.android.library'
+
+android {
+    compileSdkVersion 23
+    buildToolsVersion "23.0.2"
+
+    defaultConfig {
+        minSdkVersion 15
+        targetSdkVersion 23
+        versionCode 1
+        versionName "1.0"
+    }
+    buildTypes {
+        release {
+            minifyEnabled false
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
+        }
+    }
+}
+
+dependencies {
+    compile fileTree(dir: 'libs', include: ['*.jar'])
+    testCompile 'junit:junit:4.12'
+    compile 'com.android.support:appcompat-v7:23.2.0'
+}
diff --git a/AndroidOtto/otto/proguard-rules.pro b/AndroidOtto/otto/proguard-rules.pro
new file mode 100644
index 0000000..7cc6bcf
--- /dev/null
+++ b/AndroidOtto/otto/proguard-rules.pro
@@ -0,0 +1,17 @@
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in /Users/chenzhiyong/Library/Android/sdk/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the proguardFiles
+# directive in build.gradle.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
diff --git a/AndroidOtto/otto/src/androidTest/java/com/squareup/otto/ApplicationTest.java b/AndroidOtto/otto/src/androidTest/java/com/squareup/otto/ApplicationTest.java
new file mode 100644
index 0000000..6d2cfb7
--- /dev/null
+++ b/AndroidOtto/otto/src/androidTest/java/com/squareup/otto/ApplicationTest.java
@@ -0,0 +1,13 @@
+package com.squareup.otto;
+
+import android.app.Application;
+import android.test.ApplicationTestCase;
+
+/**
+ * <a href="http://d.android.com/tools/testing/testing_android.html">Testing Fundamentals</a>
+ */
+public class ApplicationTest extends ApplicationTestCase<Application> {
+	public ApplicationTest() {
+		super(Application.class);
+	}
+}
\ No newline at end of file
diff --git a/AndroidOtto/otto/src/main/AndroidManifest.xml b/AndroidOtto/otto/src/main/AndroidManifest.xml
new file mode 100644
index 0000000..c253d26
--- /dev/null
+++ b/AndroidOtto/otto/src/main/AndroidManifest.xml
@@ -0,0 +1,11 @@
+<manifest package="com.squareup.otto"
+          xmlns:android="http://schemas.android.com/apk/res/android">
+
+    <application android:allowBackup="true"
+                 android:label="@string/app_name"
+                 android:supportsRtl="true"
+        >
+
+    </application>
+
+</manifest>
diff --git a/AndroidOtto/otto/src/main/java/com/squareup/otto/AnnotatedHandlerFinder.java b/AndroidOtto/otto/src/main/java/com/squareup/otto/AnnotatedHandlerFinder.java
new file mode 100644
index 0000000..fb746f9
--- /dev/null
+++ b/AndroidOtto/otto/src/main/java/com/squareup/otto/AnnotatedHandlerFinder.java
@@ -0,0 +1,235 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ * Copyright (C) 2007 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.squareup.otto;
+
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+
+/**
+ * Helper methods for finding methods annotated with {@link Produce} and {@link Subscribe}.
+ *
+ * @author Cliff Biffle
+ * @author Louis Wasserman
+ * @author Jake Wharton
+ */
+final class AnnotatedHandlerFinder {
+
+	/**
+	 * Cache event bus producer methods for each class.
+	 *
+	 * 订阅对象的类   对应 map<事件类型 , Produce 生产者  注解 方法 >
+	 */
+	private static final ConcurrentMap<Class<?>, Map<Class<?>, Method>> PRODUCERS_CACHE =
+			new ConcurrentHashMap<Class<?>, Map<Class<?>, Method>>();
+
+	/**
+	 * Cache event bus subscriber methods for each class.
+	 *
+	 * 订阅对象的类   对应 map<事件类型 , Subscribe 订阅者 注解 方法 集合>
+	 *
+	 *     存在 一个类中 有多个方法订阅同一个事件
+	 */
+	private static final ConcurrentMap<Class<?>, Map<Class<?>, Set<Method>>> SUBSCRIBERS_CACHE =
+			new ConcurrentHashMap<Class<?>, Map<Class<?>, Set<Method>>>();
+
+	/**
+	 *
+	 * @param listenerClass 注册者的 类
+	 * @param producerMethods map<事件类型 , Produce 生产者  注解 方法 >
+	 */
+	private static void loadAnnotatedProducerMethods(Class<?> listenerClass,
+													 Map<Class<?>, Method> producerMethods) {
+		Map<Class<?>, Set<Method>> subscriberMethods = new HashMap<Class<?>, Set<Method>>();
+		loadAnnotatedMethods(listenerClass, producerMethods, subscriberMethods);
+	}
+
+	/**
+	 * @param listenerClass 注册者的 类
+	 * @param subscriberMethods map<事件类型 , Subscribe 订阅者 注解 方法 >
+	 */
+	private static void loadAnnotatedSubscriberMethods(Class<?> listenerClass,
+													   Map<Class<?>, Set<Method>> subscriberMethods) {
+		Map<Class<?>, Method> producerMethods = new HashMap<Class<?>, Method>();
+		loadAnnotatedMethods(listenerClass, producerMethods, subscriberMethods);
+	}
+
+	/**
+	 *
+	 * Load all methods annotated with {@link Produce} or {@link Subscribe} into their respective caches for the
+	 * specified class.
+	 * @param listenerClass 注册者的 类
+	 * @param producerMethods map<事件类型 ,  Produce 生产者  注解 方法 >
+	 * @param subscriberMethods map<事件类型 , Subscribe 订阅者 注解 方法 >
+	 */
+	private static void loadAnnotatedMethods(Class<?> listenerClass,
+											 Map<Class<?>, Method> producerMethods, Map<Class<?>, Set<Method>> subscriberMethods) {
+
+		// 遍历  注册者 的所有方法
+		for (Method method : listenerClass.getDeclaredMethods()) {
+			// The compiler sometimes creates synthetic bridge methods as part of the
+			// type erasure process. As of JDK8 these methods now include the same
+			// annotations as the original declarations. They should be ignored for
+			// subscribe/produce.
+			// 一线编译器 产生的 桥接方法 应该被护绿
+			if (method.isBridge()) {
+				continue;
+			}
+			if (method.isAnnotationPresent(Subscribe.class)) {
+				// 订阅者的 注解
+				Class<?>[] parameterTypes = method.getParameterTypes();
+				if (parameterTypes.length != 1) {
+					// 只能哟一个参数
+					throw new IllegalArgumentException("Method " + method + " has @Subscribe annotation but requires "
+							+ parameterTypes.length + " arguments.  Methods must require a single argument.");
+				}
+
+				Class<?> eventType = parameterTypes[0];
+				if (eventType.isInterface()) {
+					// 事件类型不能是接口
+					throw new IllegalArgumentException("Method " + method + " has @Subscribe annotation on " + eventType
+							+ " which is an interface.  Subscription must be on a concrete class type.");
+				}
+
+				if ((method.getModifiers() & Modifier.PUBLIC) == 0) {
+					// 方法必须是public
+					throw new IllegalArgumentException("Method " + method + " has @Subscribe annotation on " + eventType
+							+ " but is not 'public'.");
+				}
+
+				// 加入 这个种 事件类型的对应的 集合
+				// 这里加入 集合 没有其他特殊的判断,  不像 EventBus 只能有一种类型的订阅者 方法
+				// 这里可以有多个 方法  订阅 同一个事件
+				Set<Method> methods = subscriberMethods.get(eventType);
+				if (methods == null) {
+					methods = new HashSet<Method>();
+					subscriberMethods.put(eventType, methods);
+				}
+				methods.add(method);
+			} else if (method.isAnnotationPresent(Produce.class)) {
+				// 生产者注解
+				Class<?>[] parameterTypes = method.getParameterTypes();
+				if (parameterTypes.length != 0) {
+					// 生产者注解方法 必须没有参数
+					throw new IllegalArgumentException("Method " + method + "has @Produce annotation but requires "
+							+ parameterTypes.length + " arguments.  Methods must require zero arguments.");
+				}
+				if (method.getReturnType() == Void.class) {
+					// 返回值不能为空
+					throw new IllegalArgumentException("Method " + method
+							+ " has a return type of void.  Must declare a non-void type.");
+				}
+
+				Class<?> eventType = method.getReturnType();
+				if (eventType.isInterface()) {
+					// 返回值不能是接口
+					throw new IllegalArgumentException("Method " + method + " has @Produce annotation on " + eventType
+							+ " which is an interface.  Producers must return a concrete class type.");
+				}
+				if (eventType.equals(Void.TYPE)) {
+					// 返回值 不能死 Void 类型
+					throw new IllegalArgumentException("Method " + method + " has @Produce annotation but has no return type.");
+				}
+
+				if ((method.getModifiers() & Modifier.PUBLIC) == 0) {
+					// 必须是 public 方法
+					throw new IllegalArgumentException("Method " + method + " has @Produce annotation on " + eventType
+							+ " but is not 'public'.");
+				}
+
+				if (producerMethods.containsKey(eventType)) {
+					// 生产者 集合中 已经有这种方法,  表示 一个类中 不能 多个方法 使用 Produce 注册同一个类型
+					throw new IllegalArgumentException("Producer for type " + eventType + " has already been registered.");
+				}
+				// 加入集合
+				producerMethods.put(eventType, method);
+			}
+		}
+
+		// 加入缓存
+		PRODUCERS_CACHE.put(listenerClass, producerMethods);
+		SUBSCRIBERS_CACHE.put(listenerClass, subscriberMethods);
+	}
+
+	/**
+	 * This implementation finds all methods marked with a {@link Produce} annotation.
+	 *
+	 * 更具注解 找出所有的生产者 方法
+	 */
+	static Map<Class<?>, EventProducer> findAllProducers(Object listener) {
+		final Class<?> listenerClass = listener.getClass();
+		Map<Class<?>, EventProducer> handlersInMethod = new HashMap<Class<?>, EventProducer>();
+
+		// 先从缓存中 获取  该类 对应 map<事件类型 , 订阅方法 >
+		// 这里的map 是  map<事件类型 , 订阅方法 >
+		Map<Class<?>, Method> methods = PRODUCERS_CACHE.get(listenerClass);
+		if (null == methods) {
+			methods = new HashMap<Class<?>, Method>();
+			// 通过注解 获取 map<事件类型 , 订阅方法 >
+			loadAnnotatedProducerMethods(listenerClass, methods);
+		}
+		if (!methods.isEmpty()) {
+			for (Map.Entry<Class<?>, Method> e : methods.entrySet()) {
+				// 更具事件类型   生产者方法 勾着一个 事件生产者
+				EventProducer producer = new EventProducer(listener, e.getValue());
+				handlersInMethod.put(e.getKey(), producer);
+			}
+		}
+
+		return handlersInMethod;
+	}
+
+	/**
+	 * This implementation finds all methods marked with a {@link Subscribe} annotation.
+	 * 找到所有的 订阅者 方法
+	 */
+	static Map<Class<?>, Set<EventHandler>> findAllSubscribers(Object listener) {
+		Class<?> listenerClass = listener.getClass();
+		Map<Class<?>, Set<EventHandler>> handlersInMethod = new HashMap<Class<?>, Set<EventHandler>>();
+
+		// 先从缓存张昭 , 离乱上 只要执行了一遍  findAllProducers 或 findAllSubscribers
+		// 那么  缓存 SUBSCRIBERS_CACHE PRODUCERS_CACHE 都会有相应的值了  就不需要 再次遍历方法了
+		Map<Class<?>, Set<Method>> methods = SUBSCRIBERS_CACHE.get(listenerClass);
+		if (null == methods) {
+			methods = new HashMap<Class<?>, Set<Method>>();
+			loadAnnotatedSubscriberMethods(listenerClass, methods);
+		}
+		if (!methods.isEmpty()) {
+			for (Map.Entry<Class<?>, Set<Method>> e : methods.entrySet()) {
+				// 存在 一个类中有 有多个订阅方法的 情况
+				Set<EventHandler> handlers = new HashSet<EventHandler>();
+				for (Method m : e.getValue()) {
+					handlers.add(new EventHandler(listener, m));
+				}
+				handlersInMethod.put(e.getKey(), handlers);
+			}
+		}
+
+		return handlersInMethod;
+	}
+
+	private AnnotatedHandlerFinder() {
+		// No instances.
+	}
+
+}
diff --git a/AndroidOtto/otto/src/main/java/com/squareup/otto/Bus.java b/AndroidOtto/otto/src/main/java/com/squareup/otto/Bus.java
new file mode 100644
index 0000000..fb142d9
--- /dev/null
+++ b/AndroidOtto/otto/src/main/java/com/squareup/otto/Bus.java
@@ -0,0 +1,644 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ * Copyright (C) 2007 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.squareup.otto;
+
+import java.lang.reflect.InvocationTargetException;
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.CopyOnWriteArraySet;
+
+
+/**
+ * Dispatches events to listeners, and provides ways for listeners to register themselves.
+ * <p/>
+ * <p>The Bus allows publish-subscribe-style communication between components without requiring the components to
+ * explicitly register with one another (and thus be aware of each other).  It is designed exclusively to replace
+ * traditional Android in-process event distribution using explicit registration or listeners. It is <em>not</em> a
+ * general-purpose publish-subscribe system, nor is it intended for interprocess communication.
+ * <p/>
+ * <h2>Receiving Events</h2>
+ * To receive events, an object should:
+ * <ol>
+ * <li>Expose a public method, known as the <i>event handler</i>, which accepts a single argument of the type of event
+ * desired;</li>
+ * <li>Mark it with a {@link com.squareup.otto.Subscribe} annotation;</li>
+ * <li>Pass itself to an Bus instance's {@link #register(Object)} method.
+ * </li>
+ * </ol>
+ * <p/>
+ * <h2>Posting Events</h2>
+ * To post an event, simply provide the event object to the {@link #post(Object)} method.  The Bus instance will
+ * determine the type of event and route it to all registered listeners.
+ * <p/>
+ * <p>Events are routed based on their type &mdash; an event will be delivered to any handler for any type to which the
+ * event is <em>assignable.</em>  This includes implemented interfaces, all superclasses, and all interfaces implemented
+ * by superclasses.
+ * <p/>
+ * <p>When {@code post} is called, all registered handlers for an event are run in sequence, so handlers should be
+ * reasonably quick.  If an event may trigger an extended process (such as a database load), spawn a thread or queue it
+ * for later.
+ * <p/>
+ * <h2>Handler Methods</h2>
+ * Event handler methods must accept only one argument: the event.
+ * <p/>
+ * <p>Handlers should not, in general, throw.  If they do, the Bus will wrap the exception and
+ * re-throw it.
+ * <p/>
+ * <p>The Bus by default enforces that all interactions occur on the main thread.  You can provide an alternate
+ * enforcement by passing a {@link ThreadEnforcer} to the constructor.
+ * <p/>
+ * <h2>Producer Methods</h2>
+ * Producer methods should accept no arguments and return their event type. When a subscriber is registered for a type
+ * that a producer is also already registered for, the subscriber will be called with the return value from the
+ * producer.
+ * <p/>
+ * <h2>Dead Events</h2>
+ * If an event is posted, but no registered handlers can accept it, it is considered "dead."  To give the system a
+ * second chance to handle dead events, they are wrapped in an instance of {@link com.squareup.otto.DeadEvent} and
+ * reposted.
+ * <p/>
+ * <p>This class is safe for concurrent use.
+ *
+ * @author Cliff Biffle
+ * @author Jake Wharton
+ *
+ *
+ * 有几点需要注意:
+ * 1. 有两个注解: @Subscribe @Produce
+ * 		@Subscribe  表示是订阅者注解
+ * 		@Produce	生产者注解
+ *
+ * 2. 当 一个对象 register的时候
+ *	如果 有Produce 方法
+ * 	那么 他会去找 已经注册的 相关订阅在方法
+ * 	然后执行 Produce 方法  和 相关的订阅方法
+ *
+ * 	如果有 Subscribe 方法
+ * 	那么回去 找相关的 记忆中的额 生产者方法
+ * 	然后执行  相关的Produce 方法  和  Subscribe 方法
+ */
+public class Bus {
+	public static final String DEFAULT_IDENTIFIER = "default";
+
+	/**
+	 * All registered event handlers, indexed by event type.
+	 *
+	 * map<事件类型, 事件订阅者 方法集合>
+	 *
+	 * 一个事件 对应多个方法
+	 */
+	private final ConcurrentMap<Class<?>, Set<EventHandler>> handlersByType =
+			new ConcurrentHashMap<Class<?>, Set<EventHandler>>();
+
+	/**
+	 * All registered event producers, index by event type.
+	 *
+	 * 一种事件类型 只能 有一种生产者
+	 * Map<事件类型,  生产者封装对象>
+	 */
+	private final ConcurrentMap<Class<?>, EventProducer> producersByType =
+			new ConcurrentHashMap<Class<?>, EventProducer>();
+
+	/**
+	 * Identifier used to differentiate the event bus instance.
+	 */
+	private final String identifier;
+
+	/**
+	 * Thread enforcer for register, unregister, and posting events.
+	 */
+	private final ThreadEnforcer enforcer;
+
+	/**
+	 * Used to find handler methods in register and unregister.
+	 */
+	private final HandlerFinder handlerFinder;
+
+	/**
+	 * Queues of events for the current thread to dispatch.
+	 *
+	 * 一个 每个线程 都独立的 一个变量
+	 *
+	 * 通过get 取值  返回的是一个  ConcurrentLinkedQueue<EventWithHandler>()
+	 *
+	 * 就是 执行 订阅者方法的任务队列
+	 */
+	private final ThreadLocal<ConcurrentLinkedQueue<EventWithHandler>> eventsToDispatch =
+			new ThreadLocal<ConcurrentLinkedQueue<EventWithHandler>>() {
+				@Override
+				protected ConcurrentLinkedQueue<EventWithHandler> initialValue() {
+					return new ConcurrentLinkedQueue<EventWithHandler>();
+				}
+			};
+
+	/**
+	 * True if the current thread is currently dispatching an event.
+	 *
+	 * 同样 也是每个现场 都独立的一个 bool 数据
+	 */
+	private final ThreadLocal<Boolean> isDispatching = new ThreadLocal<Boolean>() {
+		@Override
+		protected Boolean initialValue() {
+			return false;
+		}
+	};
+
+	/**
+	 * Creates a new Bus named "default" that enforces actions on the main thread.
+	 *
+	 * 构造一个默认的 Bus
+	 */
+	public Bus() {
+		this(DEFAULT_IDENTIFIER);
+	}
+
+	/**
+	 * Creates a new Bus with the given {@code identifier} that enforces actions on the main thread.
+	 *
+	 * @param identifier a brief name for this bus, for debugging purposes.  Should be a valid Java identifier.
+	 *                   bus 的名字
+	 */
+	public Bus(String identifier) {
+		this(ThreadEnforcer.MAIN, identifier);
+	}
+
+	/**
+	 * Creates a new Bus named "default" with the given {@code enforcer} for actions.
+	 *
+	 * @param enforcer Thread enforcer for register, unregister, and post actions.
+	 *                 是一个 限定的 线程的东西
+	 */
+	public Bus(ThreadEnforcer enforcer) {
+		this(enforcer, DEFAULT_IDENTIFIER);
+	}
+
+	/**
+	 * Creates a new Bus with the given {@code enforcer} for actions and the given {@code identifier}.
+	 *
+	 * @param enforcer   Thread enforcer for register, unregister, and post actions.
+	 *                   约定 订阅者执行的线程
+	 * @param identifier A brief name for this bus, for debugging purposes.  Should be a valid Java identifier.
+	 *                   bus 名字
+	 */
+	public Bus(ThreadEnforcer enforcer, String identifier) {
+		this(enforcer, identifier, HandlerFinder.ANNOTATED);
+	}
+
+	/**
+	 * Test constructor which allows replacing the default {@code HandlerFinder}.
+	 *
+	 * @param enforcer      Thread enforcer for register, unregister, and post actions.
+	 *                      约定订阅者 方法执行的线程
+	 * @param identifier    A brief name for this bus, for debugging purposes.  Should be a valid Java identifier.
+	 *                      bus 的名字
+	 * @param handlerFinder Used to discover event handlers and producers when registering/unregistering an object.
+	 *                      寻找注解的一个 帮助对象
+	 */
+	Bus(ThreadEnforcer enforcer, String identifier, HandlerFinder handlerFinder) {
+		this.enforcer = enforcer;
+		this.identifier = identifier;
+		this.handlerFinder = handlerFinder;
+	}
+
+	@Override
+	public String toString() {
+		return "[Bus \"" + identifier + "\"]";
+	}
+
+	/**
+	 * Registers all handler methods on {@code object} to receive events and producer methods to provide events.
+	 * <p/>
+	 * If any subscribers are registering for types which already have a producer they will be called immediately
+	 * with the result of calling that producer.
+	 * <p/>
+	 * If any producers are registering for types which already have subscribers, each subscriber will be called with
+	 * the value from the result of calling the producer.
+	 *
+	 * 注册
+	 *
+	 *  有几点需要注意:
+	 * 1. 有两个注解: @Subscribe @Produce
+	 * 		@Subscribe  表示是订阅者注解
+	 * 		@Produce	生产者注解
+	 *
+	 * 2. 如果 有Produce 方法
+	 * 	那么 他会去找 已经注册的 相关订阅在方法
+	 * 	然后执行 Produce 方法  和 相关的订阅方法
+	 *
+	 * 3. 如果有 Subscribe 方法
+	 * 	那么回去 找相关的 记忆中的额 生产者方法
+	 * 	然后执行  相关的Produce 方法  和  Subscribe 方法
+	 *
+	 * @param object object whose handler methods should be registered.
+	 * @throws NullPointerException if the object is null.
+	 */
+	public void register(Object object) {
+		if (object == null) {
+			throw new NullPointerException("Object to register must not be null.");
+		}
+		// 校验线程 默认的是 必须在主线程 不然 报错
+		enforcer.enforce(this);
+
+		// 获取这个类 所有的生产者 方法
+		Map<Class<?>, EventProducer> foundProducers = handlerFinder.findAllProducers(object);
+		for (Class<?> type : foundProducers.keySet()) {
+
+			final EventProducer producer = foundProducers.get(type);
+			// putIfAbsent ConcurrentMap 一个方法
+			// 大概功能是 如果 存在 map 中有这个key  那么 就返回 这个key 对应的值
+			// 如果没有这个key 那么就 把对应的key value 注入到map中
+			EventProducer previousProducer = producersByType.putIfAbsent(type, producer);
+			//checking if the previous producer existed
+			if (previousProducer != null) {
+				// 如果 之前 有值 那么这里抛出异常
+				// 抛出 多次注册的异常
+
+				// 生产者 方法 只能是一个
+				throw new IllegalArgumentException("Producer method for type " + type
+						+ " found on type " + producer.target.getClass()
+						+ ", but already registered by type " + previousProducer.target.getClass() + ".");
+			}
+			// 获取 这个 事件 对应的 订阅者 方法
+			Set<EventHandler> handlers = handlersByType.get(type);
+			if (handlers != null && !handlers.isEmpty()) {
+				for (EventHandler handler : handlers) {
+					// 把这个事件 分发出去
+					dispatchProducerResultToHandler(handler, producer);
+				}
+			}
+		}
+
+		// 获取所有的 订阅者 方法
+		Map<Class<?>, Set<EventHandler>> foundHandlersMap = handlerFinder.findAllSubscribers(object);
+		// 遍历 所有的事件类型 , 每一个事件类型 对应一个 Set 方法集合
+		for (Class<?> type : foundHandlersMap.keySet()) {
+			Set<EventHandler> handlers = handlersByType.get(type);
+			// 获取 这个事件 对应的生产者集合
+			// 咩有则创建
+			if (handlers == null) {
+				//concurrent put if absent
+				Set<EventHandler> handlersCreation = new CopyOnWriteArraySet<EventHandler>();
+				// 理论啊还是那个 这里 handlersByType 肯定没有对应 key == type 因为上面就判断过
+				// 但是由于 可能有多线程的问题 这里再次判断下
+				handlers = handlersByType.putIfAbsent(type, handlersCreation);
+				if (handlers == null) {
+					handlers = handlersCreation;
+				}
+			}
+
+			final Set<EventHandler> foundHandlers = foundHandlersMap.get(type);
+			// 吧当前 事件类型的 订阅者方法 全部加入集合
+			if (!handlers.addAll(foundHandlers)) {
+				// 由于是个 set 集合 所有如果加入失败, 说明已经存在了 已经订阅 抛出异常
+				throw new IllegalArgumentException("Object already registered.");
+			}
+		}
+
+		// 遍历 所有的事件类型 , 每一个事件类型 对应一个 Set 方法集合
+		for (Map.Entry<Class<?>, Set<EventHandler>> entry : foundHandlersMap.entrySet()) {
+			Class<?> type = entry.getKey();
+			// 获取该事件的 生产者
+			EventProducer producer = producersByType.get(type);
+			if (producer != null && producer.isValid()) {
+				//生产者 有效
+				Set<EventHandler> foundHandlers = entry.getValue();
+				for (EventHandler foundHandler : foundHandlers) {
+					if (!producer.isValid()) {
+						break;
+					}
+					if (foundHandler.isValid()) {
+						// 如果生产者  和 订阅者 都有效 那么 分发事件
+						// 执行 生产者 方法 和订阅者方法
+						dispatchProducerResultToHandler(foundHandler, producer);
+					}
+				}
+			}
+		}
+	}
+
+	/**
+	 * 处理分发 事件
+	 * @param handler 事件 处理独享
+	 * @param producer 事件产生对象
+	 */
+	private void dispatchProducerResultToHandler(EventHandler handler, EventProducer producer) {
+		Object event = null;
+		try {
+			// 生成事件
+			event = producer.produceEvent();
+		} catch (InvocationTargetException e) {
+			throwRuntimeException("Producer " + producer + " threw an exception.", e);
+		}
+		if (event == null) {
+			return;
+		}
+		//
+		dispatch(event, handler);
+	}
+
+	/**
+	 * Unregisters all producer and handler methods on a registered {@code object}.
+	 *
+	 * 解除注册
+	 *
+	 * @param object object whose producer and handler methods should be unregistered.
+	 * @throws IllegalArgumentException if the object was not previously registered.
+	 * @throws NullPointerException     if the object is null.
+	 */
+	public void unregister(Object object) {
+		if (object == null) {
+			throw new NullPointerException("Object to unregister must not be null.");
+		}
+		// 校验线程
+		enforcer.enforce(this);
+
+		// 获取这个类所有的生产者
+		Map<Class<?>, EventProducer> producersInListener = handlerFinder.findAllProducers(object);
+		for (Map.Entry<Class<?>, EventProducer> entry : producersInListener.entrySet()) {
+			final Class<?> key = entry.getKey();
+			EventProducer producer = getProducerForEventType(key);
+			EventProducer value = entry.getValue();
+
+			if (value == null || !value.equals(producer)) {
+				throw new IllegalArgumentException(
+						"Missing event producer for an annotated method. Is " + object.getClass()
+								+ " registered?");
+			}
+			// 想出 相应的 生产者 且设置为 无效
+			// 这里可以看到 invalidate 这个变量的好处,
+			// 如果这里仅仅是移除, 其实这对象 短时间 还是存在的 那么就可能导致出现一些问题
+			// 加上 invalidate 约束就好了
+			producersByType.remove(key).invalidate();
+		}
+
+		// 获取所有的订阅者
+		Map<Class<?>, Set<EventHandler>> handlersInListener = handlerFinder.findAllSubscribers(object);
+		for (Map.Entry<Class<?>, Set<EventHandler>> entry : handlersInListener.entrySet()) {
+			Set<EventHandler> currentHandlers = getHandlersForEventType(entry.getKey());
+			Collection<EventHandler> eventMethodsInListener = entry.getValue();
+
+			if (currentHandlers == null || !currentHandlers.containsAll(eventMethodsInListener)) {
+				throw new IllegalArgumentException(
+						"Missing event handler for an annotated method. Is " + object.getClass()
+								+ " registered?");
+			}
+
+			for (EventHandler handler : currentHandlers) {
+				if (eventMethodsInListener.contains(handler)) {
+					//订阅者 设置为 无效
+					handler.invalidate();
+				}
+			}
+			// 移除所有的订阅者
+			currentHandlers.removeAll(eventMethodsInListener);
+		}
+	}
+
+	/**
+	 * Posts an event to all registered handlers.  This method will return successfully after the event has been posted to
+	 * all handlers, and regardless of any exceptions thrown by handlers.
+	 * <p/>
+	 * <p>If no handlers have been subscribed for {@code event}'s class, and {@code event} is not already a
+	 * {@link DeadEvent}, it will be wrapped in a DeadEvent and reposted.
+	 *
+	 * 发送一个事件
+	 *
+	 * @param event event to post.
+	 * @throws NullPointerException if the event is null.
+	 */
+	public void post(Object event) {
+		if (event == null) {
+			throw new NullPointerException("Event to post must not be null.");
+		}
+		// 校验线程
+		enforcer.enforce(this);
+
+		// 获取这个事件 所有的 父类 接口 集合 也包括自己
+		// 由于 泛型 他们的父类 也可能是 其他 订阅者的事件
+		Set<Class<?>> dispatchTypes = flattenHierarchy(event.getClass());
+
+		// 是否有订阅者的标记
+		boolean dispatched = false;
+		// 遍历所有的 事件
+		for (Class<?> eventType : dispatchTypes) {
+			// 找到 该事件对应的方法
+			Set<EventHandler> wrappers = getHandlersForEventType(eventType);
+
+			if (wrappers != null && !wrappers.isEmpty()) {
+				// 表示有订阅者
+				dispatched = true;
+				for (EventHandler wrapper : wrappers) {
+					// 依次  放入队列
+					enqueueEvent(event, wrapper);
+				}
+			}
+		}
+
+		if (!dispatched && !(event instanceof DeadEvent)) {
+			// 如果没有订阅者 且时间 不是 DeadEvent
+			// 则发送一个 表示没有订阅者的事件
+			post(new DeadEvent(this, event));
+		}
+
+		// 分发队列中的 任务
+		dispatchQueuedEvents();
+	}
+
+	/**
+	 *
+	 * Queue the {@code event} for dispatch during {@link #dispatchQueuedEvents()}. Events are queued in-order of
+	 * occurrence so they can be dispatched in the same order.
+	 *
+	 * @param event 事件类型
+	 * @param handler 订阅者 方法包装对象
+	 */
+	protected void enqueueEvent(Object event, EventHandler handler) {
+		// eventsToDispatch.get()  是 ConcurrentLinkedQueue<EventWithHandler>()
+		// offer 方法是 加入到 队列 尾部
+		eventsToDispatch.get().offer(new EventWithHandler(event, handler));
+	}
+
+	/**
+	 * Drain the queue of events to be dispatched. As the queue is being drained, new events may be posted to the end of
+	 * the queue.
+	 *
+	 * 分发 队列中的 事件
+	 *
+	 */
+	protected void dispatchQueuedEvents() {
+		// don't dispatch if we're already dispatching, that would allow reentrancy and out-of-order events. Instead, leave
+		// the events to be dispatched after the in-progress dispatch is complete.
+		if (isDispatching.get()) {
+			// 如果正在分发 处理队列
+			return;
+		}
+
+		// 标记正在处理队列
+		isDispatching.set(true);
+		try {
+			while (true) {
+				// 获取队列中的数据
+				EventWithHandler eventWithHandler = eventsToDispatch.get().poll();
+				if (eventWithHandler == null) {
+					// 队列中没有数据了
+					break;
+				}
+
+				if (eventWithHandler.handler.isValid()) {
+					// 订阅方法 还有效的话 执行 订阅方法
+					dispatch(eventWithHandler.event, eventWithHandler.handler);
+				}
+			}
+		} finally {
+			isDispatching.set(false);
+		}
+	}
+
+	/**
+	 * Dispatches {@code event} to the handler in {@code wrapper}.  This method is an appropriate override point for
+	 * subclasses that wish to make event delivery asynchronous.
+	 *
+	 * @param event   event to dispatch. 事件
+	 * @param wrapper wrapper that will call the handler.  订阅者 封装独享
+	 */
+	protected void dispatch(Object event, EventHandler wrapper) {
+		try {
+			// 执行 订阅者方法
+			wrapper.handleEvent(event);
+		} catch (InvocationTargetException e) {
+			throwRuntimeException(
+					"Could not dispatch event: " + event.getClass() + " to handler " + wrapper, e);
+		}
+	}
+
+	/**
+	 * Retrieves the currently registered producer for {@code type}.  If no producer is currently registered for
+	 * {@code type}, this method will return {@code null}.
+	 *
+	 * 更具事件类型  获取 生产者
+	 *
+	 * @param type type of producer to retrieve.
+	 * @return currently registered producer, or {@code null}.
+	 */
+	EventProducer getProducerForEventType(Class<?> type) {
+		return producersByType.get(type);
+	}
+
+	/**
+	 * Retrieves a mutable set of the currently registered handlers for {@code type}.  If no handlers are currently
+	 * registered for {@code type}, this method may either return {@code null} or an empty set.
+	 *
+	 * 获取 事件类型对应到 订阅方法包装对象 集合
+	 * @param type type of handlers to retrieve.
+	 * @return currently registered handlers, or {@code null}.
+	 */
+	Set<EventHandler> getHandlersForEventType(Class<?> type) {
+		return handlersByType.get(type);
+	}
+
+	/**
+	 * Flattens a class's type hierarchy into a set of Class objects.  The set will include all superclasses
+	 * (transitively), and all interfaces implemented by these superclasses.
+	 *
+	 * 更具 一个事件类型
+	 * 获取 搜友 相应的  父类 接口 集合
+	 * 由于 泛型 他们 也可能是 其他 订阅者的事件
+	 *
+	 * 这里不像 EventBus 可以自己定义 是否考虑 事件的 父类
+	 *
+	 * @param concreteClass class whose type hierarchy will be retrieved. 事件类型
+	 * @return {@code concreteClass}'s complete type hierarchy, flattened and uniqued.
+	 */
+	Set<Class<?>> flattenHierarchy(Class<?> concreteClass) {
+		// 从缓存中获取
+		Set<Class<?>> classes = flattenHierarchyCache.get(concreteClass);
+		if (classes == null) {
+			Set<Class<?>> classesCreation = getClassesFor(concreteClass);
+			classes = flattenHierarchyCache.putIfAbsent(concreteClass, classesCreation);
+			if (classes == null) {
+				classes = classesCreation;
+			}
+		}
+
+		return classes;
+	}
+
+	/**
+	 * 获取 所有的 父类 接口
+	 * @param concreteClass
+	 * @return
+	 */
+	private Set<Class<?>> getClassesFor(Class<?> concreteClass) {
+		List<Class<?>> parents = new LinkedList<Class<?>>();
+		Set<Class<?>> classes = new HashSet<Class<?>>();
+
+		parents.add(concreteClass);
+
+		// 向上循环父类
+		while (!parents.isEmpty()) {
+			// 这个算法 是以 父类 集合为空作为 判断条件
+			Class<?> clazz = parents.remove(0);
+			classes.add(clazz);
+
+			Class<?> parent = clazz.getSuperclass();
+			if (parent != null) {
+				parents.add(parent);
+			}
+		}
+		return classes;
+	}
+
+	/**
+	 * Throw a {@link RuntimeException} with given message and cause lifted from an {@link
+	 * InvocationTargetException}. If the specified {@link InvocationTargetException} does not have a
+	 * cause, neither will the {@link RuntimeException}.
+	 */
+	private static void throwRuntimeException(String msg, InvocationTargetException e) {
+		Throwable cause = e.getCause();
+		if (cause != null) {
+			throw new RuntimeException(msg + ": " + cause.getMessage(), cause);
+		} else {
+			throw new RuntimeException(msg + ": " + e.getMessage(), e);
+		}
+	}
+
+	private final ConcurrentMap<Class<?>, Set<Class<?>>> flattenHierarchyCache =
+			new ConcurrentHashMap<Class<?>, Set<Class<?>>>();
+
+	/**
+	 * Simple struct representing an event and its handler.
+	 *
+	 * 事件 和 订阅者 的一个简单封装
+	 */
+	static class EventWithHandler {
+		final Object event;
+		final EventHandler handler;
+
+		public EventWithHandler(Object event, EventHandler handler) {
+			this.event = event;
+			this.handler = handler;
+		}
+	}
+}
diff --git a/AndroidOtto/otto/src/main/java/com/squareup/otto/DeadEvent.java b/AndroidOtto/otto/src/main/java/com/squareup/otto/DeadEvent.java
new file mode 100644
index 0000000..7f29f92
--- /dev/null
+++ b/AndroidOtto/otto/src/main/java/com/squareup/otto/DeadEvent.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2007 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.squareup.otto;
+
+/**
+ * Wraps an event that was posted, but which had no subscribers and thus could not be delivered.
+ * <p/>
+ * <p>Subscribing a DeadEvent handler is useful for debugging or logging, as it can detect misconfigurations in a
+ * system's event distribution.
+ *
+ * 表示没有订阅者的事件
+ *
+ * @author Cliff Biffle
+ */
+public class DeadEvent {
+
+	public final Object source;
+	public final Object event;
+
+	/**
+	 * Creates a new DeadEvent.
+	 *
+	 * @param source object broadcasting the DeadEvent (generally the {@link Bus}).
+	 * @param event  the event that could not be delivered.
+	 */
+	public DeadEvent(Object source, Object event) {
+		this.source = source;
+		this.event = event;
+	}
+
+}
diff --git a/AndroidOtto/otto/src/main/java/com/squareup/otto/EventHandler.java b/AndroidOtto/otto/src/main/java/com/squareup/otto/EventHandler.java
new file mode 100644
index 0000000..4a4db7e
--- /dev/null
+++ b/AndroidOtto/otto/src/main/java/com/squareup/otto/EventHandler.java
@@ -0,0 +1,147 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ * Copyright (C) 2007 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.squareup.otto;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
+/**
+ * Wraps a single-argument 'handler' method on a specific object.
+ * <p/>
+ * <p>This class only verifies the suitability of the method and event type if something fails.  Callers are expected t
+ * verify their uses of this class.
+ * <p/>
+ * <p>Two EventHandlers are equivalent when they refer to the same method on the same object (not class).   This
+ * property is used to ensure that no handler method is registered more than once.
+ *
+ * 订阅者的一个封装
+ * 就是  Subscribe 注解方法的一个封装
+ *
+ * @author Cliff Biffle
+ */
+class EventHandler {
+
+	/**
+	 * Object sporting the handler method.
+	 */
+	private final Object target;
+	/**
+	 * Handler method.
+	 */
+	private final Method method;
+	/**
+	 * Object hash code.
+	 */
+	private final int hashCode;
+	/**
+	 * Should this handler receive events?
+	 * 决定 是否能够 执行 Subscribe 注解方法
+	 */
+	private boolean valid = true;
+
+	/**
+	 *
+	 * @param target 注册类 对象
+	 * @param method Subscribe 注解方法
+	 */
+	EventHandler(Object target, Method method) {
+		if (target == null) {
+			throw new NullPointerException("EventHandler target cannot be null.");
+		}
+		if (method == null) {
+			throw new NullPointerException("EventHandler method cannot be null.");
+		}
+
+		this.target = target;
+		this.method = method;
+		method.setAccessible(true);
+
+		// Compute hash code eagerly since we know it will be used frequently and we cannot estimate the runtime of the
+		// target's hashCode call.
+		final int prime = 31;
+		hashCode = (prime + method.hashCode()) * prime + target.hashCode();
+	}
+
+	public boolean isValid() {
+		return valid;
+	}
+
+	/**
+	 * If invalidated, will subsequently refuse to handle events.
+	 * <p/>
+	 * Should be called when the wrapped object is unregistered from the Bus.
+	 */
+	public void invalidate() {
+		valid = false;
+	}
+
+	/**
+	 * Invokes the wrapped handler method to handle {@code event}.
+	 * 执行 @Subscribe 方法
+	 *
+	 * @param event event to handle
+	 * @throws IllegalStateException     if previously invalidated.
+	 * @throws InvocationTargetException if the wrapped method throws any {@link Throwable} that is not
+	 *                                   an {@link Error} ({@code Error}s are propagated as-is).
+	 */
+	public void handleEvent(Object event) throws InvocationTargetException {
+		if (!valid) {
+			throw new IllegalStateException(toString() + " has been invalidated and can no longer handle events.");
+		}
+		try {
+			method.invoke(target, event);
+		} catch (IllegalAccessException e) {
+			throw new AssertionError(e);
+		} catch (InvocationTargetException e) {
+			if (e.getCause() instanceof Error) {
+				throw (Error) e.getCause();
+			}
+			throw e;
+		}
+	}
+
+	@Override
+	public String toString() {
+		return "[EventHandler " + method + "]";
+	}
+
+	@Override
+	public int hashCode() {
+		return hashCode;
+	}
+
+	@Override
+	public boolean equals(Object obj) {
+		if (this == obj) {
+			return true;
+		}
+
+		if (obj == null) {
+			return false;
+		}
+
+		if (getClass() != obj.getClass()) {
+			return false;
+		}
+
+		final EventHandler other = (EventHandler) obj;
+
+		return method.equals(other.method) && target == other.target;
+	}
+
+}
diff --git a/AndroidOtto/otto/src/main/java/com/squareup/otto/EventProducer.java b/AndroidOtto/otto/src/main/java/com/squareup/otto/EventProducer.java
new file mode 100644
index 0000000..78b2760
--- /dev/null
+++ b/AndroidOtto/otto/src/main/java/com/squareup/otto/EventProducer.java
@@ -0,0 +1,150 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.squareup.otto;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
+/**
+ * Wraps a 'producer' method on a specific object.
+ * <p/>
+ * <p> This class only verifies the suitability of the method and event type if something fails.  Callers are expected
+ * to verify their uses of this class.
+ *
+ * 事件生产者
+ * Produce 注解 方法的一个封装
+ *
+ * @author Jake Wharton
+ */
+class EventProducer {
+
+	/**
+	 * Object sporting the producer method.
+	 * 订阅对象
+	 */
+	final Object target;
+	/**
+	 * Producer method.
+	 * 订阅方法
+	 */
+	private final Method method;
+	/**
+	 * Object hash code.
+	 */
+	private final int hashCode;
+	/**
+	 * Should this producer produce events?
+	 * 这个值 决定 是否能够执行 生产者方法  是够能够 产生事件
+	 */
+	private boolean valid = true;
+
+	/**
+	 *
+	 * @param target 注册 类对象
+	 * @param method 生产者 方法
+	 */
+	EventProducer(Object target, Method method) {
+		if (target == null) {
+			throw new NullPointerException("EventProducer target cannot be null.");
+		}
+		if (method == null) {
+			throw new NullPointerException("EventProducer method cannot be null.");
+		}
+
+		this.target = target;
+		this.method = method;
+		// 提高反射速率
+		method.setAccessible(true);
+
+		// Compute hash code eagerly since we know it will be used frequently and we cannot estimate the runtime of the
+		// target's hashCode call.
+		final int prime = 31;
+		// 生成 hashcode  用于 比较时使用 节省事件
+		hashCode = (prime + method.hashCode()) * prime + target.hashCode();
+	}
+
+	public boolean isValid() {
+		return valid;
+	}
+
+	/**
+	 * If invalidated, will subsequently refuse to produce events.
+	 * <p/>
+	 * Should be called when the wrapped object is unregistered from the Bus.
+	 */
+	public void invalidate() {
+		valid = false;
+	}
+
+	/**
+	 * Invokes the wrapped producer method.
+	 *
+	 * 执行 Produce 注解方法
+	 *
+	 * @throws IllegalStateException     if previously invalidated.
+	 * @throws InvocationTargetException if the wrapped method throws any {@link Throwable} that is not
+	 *                                   an {@link Error} ({@code Error}s are propagated as-is).
+	 *
+	 * @return 返回事件
+	 */
+	public Object produceEvent() throws InvocationTargetException {
+		if (!valid) {
+			// 如果 无效
+			throw new IllegalStateException(toString() + " has been invalidated and can no longer produce events.");
+		}
+		try {
+			// 执行方法
+			return method.invoke(target);
+		} catch (IllegalAccessException e) {
+			throw new AssertionError(e);
+		} catch (InvocationTargetException e) {
+			if (e.getCause() instanceof Error) {
+				throw (Error) e.getCause();
+			}
+			throw e;
+		}
+	}
+
+	@Override
+	public String toString() {
+		return "[EventProducer " + method + "]";
+	}
+
+	@Override
+	public int hashCode() {
+		return hashCode;
+	}
+
+	@Override
+	public boolean equals(Object obj) {
+		if (this == obj) {
+			return true;
+		}
+
+		if (obj == null) {
+			return false;
+		}
+
+		if (getClass() != obj.getClass()) {
+			return false;
+		}
+
+		final EventProducer other = (EventProducer) obj;
+
+		return method.equals(other.method) && target == other.target;
+	}
+}
diff --git a/AndroidOtto/otto/src/main/java/com/squareup/otto/HandlerFinder.java b/AndroidOtto/otto/src/main/java/com/squareup/otto/HandlerFinder.java
new file mode 100644
index 0000000..53aa1c2
--- /dev/null
+++ b/AndroidOtto/otto/src/main/java/com/squareup/otto/HandlerFinder.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.squareup.otto;
+
+import java.util.Map;
+import java.util.Set;
+
+/**
+ * Finds producer and subscriber methods.
+ */
+interface HandlerFinder {
+
+	Map<Class<?>, EventProducer> findAllProducers(Object listener);
+
+	Map<Class<?>, Set<EventHandler>> findAllSubscribers(Object listener);
+
+
+	HandlerFinder ANNOTATED = new HandlerFinder() {
+		@Override
+		public Map<Class<?>, EventProducer> findAllProducers(Object listener) {
+			return AnnotatedHandlerFinder.findAllProducers(listener);
+		}
+
+		@Override
+		public Map<Class<?>, Set<EventHandler>> findAllSubscribers(Object listener) {
+			return AnnotatedHandlerFinder.findAllSubscribers(listener);
+		}
+	};
+}
diff --git a/AndroidOtto/otto/src/main/java/com/squareup/otto/Produce.java b/AndroidOtto/otto/src/main/java/com/squareup/otto/Produce.java
new file mode 100644
index 0000000..2ca0be1
--- /dev/null
+++ b/AndroidOtto/otto/src/main/java/com/squareup/otto/Produce.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.squareup.otto;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Marks a method as an instance producer, as used by {@link AnnotatedHandlerFinder} and {@link Bus}.
+ * <p/>
+ * Otto infers the instance type from the annotated method's return type. Producer methods may return null when there is
+ * no appropriate value to share. The calling {@link Bus} ignores such returns and posts nothing.
+ *
+ * @author Jake Wharton
+ *
+ * otto 有两种注解
+ *
+ * 有这种注解的 方法,  当执行这个方法时, 他的返回值 就是 事件类型
+ *
+ *
+ * 这种 注解 一个进程中
+ * 一个类型  只能 有一个 被注册
+ *
+ * 不能出现 两个 类 都注册了
+ *
+ * 也不能出现 一个类中 注册多次
+ *
+ * 可以吧 Produce 和 粘性事件相类比
+ *
+ */
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.METHOD)
+public @interface Produce {
+}
diff --git a/AndroidOtto/otto/src/main/java/com/squareup/otto/Subscribe.java b/AndroidOtto/otto/src/main/java/com/squareup/otto/Subscribe.java
new file mode 100644
index 0000000..8e3d77c
--- /dev/null
+++ b/AndroidOtto/otto/src/main/java/com/squareup/otto/Subscribe.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2007 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.squareup.otto;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Marks a method as an event handler, as used by {@link AnnotatedHandlerFinder} and {@link Bus}.
+ * <p/>
+ * <p>The method's first (and only) parameter defines the event type.
+ * <p>If this annotation is applied to methods with zero parameters or more than one parameter, the object containing
+ * the method will not be able to register for event delivery from the {@link Bus}. Otto fails fast by throwing
+ * runtime exceptions in these cases.
+ *
+ * @author Cliff Biffle
+ */
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.METHOD)
+public @interface Subscribe {
+}
diff --git a/AndroidOtto/otto/src/main/java/com/squareup/otto/ThreadEnforcer.java b/AndroidOtto/otto/src/main/java/com/squareup/otto/ThreadEnforcer.java
new file mode 100644
index 0000000..ed8cb27
--- /dev/null
+++ b/AndroidOtto/otto/src/main/java/com/squareup/otto/ThreadEnforcer.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.squareup.otto;
+
+import android.os.Looper;
+
+/**
+ * Enforces a thread confinement policy for methods on a particular event bus.
+ *
+ * 检查线程的一个东西
+ * @author Jake Wharton
+ */
+public interface ThreadEnforcer {
+
+	/**
+	 * Enforce a valid thread for the given {@code bus}. Implementations may throw any runtime exception.
+	 *
+	 * @param bus Event bus instance on which an action is being performed.
+	 */
+	void enforce(Bus bus);
+
+
+	/**
+	 * A {@link ThreadEnforcer} that does no verification.
+	 */
+	ThreadEnforcer ANY = new ThreadEnforcer() {
+		@Override
+		public void enforce(Bus bus) {
+			// 这个不做任何检查
+			// Allow any thread.
+		}
+	};
+
+	/**
+	 * A {@link ThreadEnforcer} that confines {@link Bus} methods to the main thread.
+	 */
+	ThreadEnforcer MAIN = new ThreadEnforcer() {
+		@Override
+		public void enforce(Bus bus) {
+			// 检查是否在主线程
+			if (Looper.myLooper() != Looper.getMainLooper()) {
+				throw new IllegalStateException("Event bus " + bus + " accessed from non-main thread " + Looper.myLooper());
+			}
+		}
+	};
+
+}
diff --git a/AndroidOtto/otto/src/main/res/values/strings.xml b/AndroidOtto/otto/src/main/res/values/strings.xml
new file mode 100644
index 0000000..98beefb
--- /dev/null
+++ b/AndroidOtto/otto/src/main/res/values/strings.xml
@@ -0,0 +1,3 @@
+<resources>
+    <string name="app_name">otto</string>
+</resources>
diff --git a/AndroidOtto/otto/src/test/java/com/squareup/otto/ExampleUnitTest.java b/AndroidOtto/otto/src/test/java/com/squareup/otto/ExampleUnitTest.java
new file mode 100644
index 0000000..cfd0d7e
--- /dev/null
+++ b/AndroidOtto/otto/src/test/java/com/squareup/otto/ExampleUnitTest.java
@@ -0,0 +1,15 @@
+package com.squareup.otto;
+
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+/**
+ * To work on unit tests, switch the Test Artifact in the Build Variants view.
+ */
+public class ExampleUnitTest {
+	@Test
+	public void addition_isCorrect() throws Exception {
+		assertEquals(4, 2 + 2);
+	}
+}
\ No newline at end of file
