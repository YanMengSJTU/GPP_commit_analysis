diff --git a/otto/build.gradle b/otto/build.gradle
index 32ed6ee..415a391 100644
--- a/otto/build.gradle
+++ b/otto/build.gradle
@@ -25,4 +25,5 @@ dependencies {
     })
     compile 'com.android.support:appcompat-v7:24.2.1'
     testCompile 'junit:junit:4.12'
+    compile 'org.easytesting:fest-assert-core:2.0M10'
 }
diff --git a/otto/src/test/java/com/squareup/otto/outside/AnnotatedHandlerFinderTest.java b/otto/src/test/java/com/squareup/otto/outside/AnnotatedHandlerFinderTest.java
index 66194eb..1da28de 100644
--- a/otto/src/test/java/com/squareup/otto/outside/AnnotatedHandlerFinderTest.java
+++ b/otto/src/test/java/com/squareup/otto/outside/AnnotatedHandlerFinderTest.java
@@ -36,7 +36,7 @@
 
 /**
  * Test that Bus finds the correct handlers.
- *
+ * <p>
  * This test must be outside the c.g.c.eventbus package to test correctly.
  *
  * @author Louis Wasserman
@@ -45,165 +45,179 @@
 @SuppressWarnings("UnusedDeclaration")
 public class AnnotatedHandlerFinderTest {
 
-  private static final Object EVENT = new Object();
-
-  @Ignore // Tests are in extending classes.
-  public abstract static class AbstractEventBusTest<H> {
-    abstract H createHandler();
-
-    private H handler;
-
-    H getHandler() {
-      return handler;
-    }
-
-    @Before
-    public void setUp() throws Exception {
-      handler = createHandler();
-      Bus bus = new Bus(ThreadEnforcer.ANY);
-      bus.register(handler);
-      bus.post(EVENT);
-    }
-
-    @After
-    public void tearDown() throws Exception {
-      handler = null;
-    }
-  }
-
-  /*
-   * We break the tests up based on whether they are annotated or abstract in the superclass.
-   */
-  public static class BaseHandlerFinderTest
-      extends AbstractEventBusTest<BaseHandlerFinderTest.Handler> {
-    static class Handler {
-      final List<Object> nonSubscriberEvents = new ArrayList<Object>();
-      final List<Object> subscriberEvents = new ArrayList<Object>();
-
-      public void notASubscriber(Object o) {
-        nonSubscriberEvents.add(o);
-      }
-
-      @Subscribe
-      public void subscriber(Object o) {
-        subscriberEvents.add(o);
-      }
-    }
-
-    @Test public void nonSubscriber() {
-      assertThat(getHandler().nonSubscriberEvents).isEmpty();
-    }
-
-    @Test public void subscriber() {
-      assertThat(getHandler().subscriberEvents).containsExactly(EVENT);
-    }
-
-    @Override Handler createHandler() {
-      return new Handler();
-    }
-  }
-
-  public static class AbstractNotAnnotatedInSuperclassTest
-      extends AbstractEventBusTest<AbstractNotAnnotatedInSuperclassTest.SubClass> {
-    abstract static class SuperClass {
-      public abstract void overriddenInSubclassNowhereAnnotated(Object o);
-
-      public abstract void overriddenAndAnnotatedInSubclass(Object o);
-    }
-
-    static class SubClass extends SuperClass {
-      final List<Object> overriddenInSubclassNowhereAnnotatedEvents = new ArrayList<Object>();
-      final List<Object> overriddenAndAnnotatedInSubclassEvents = new ArrayList<Object>();
-
-      @Override
-      public void overriddenInSubclassNowhereAnnotated(Object o) {
-        overriddenInSubclassNowhereAnnotatedEvents.add(o);
-      }
-
-      @Subscribe @Override
-      public void overriddenAndAnnotatedInSubclass(Object o) {
-        overriddenAndAnnotatedInSubclassEvents.add(o);
-      }
-    }
-
-    @Test public void overriddenAndAnnotatedInSubclass() {
-      assertThat(getHandler().overriddenAndAnnotatedInSubclassEvents).containsExactly(EVENT);
-    }
-
-    @Test public void overriddenInSubclassNowhereAnnotated() {
-      assertThat(getHandler().overriddenInSubclassNowhereAnnotatedEvents).isEmpty();
-    }
-
-    @Override SubClass createHandler() {
-      return new SubClass();
-    }
-  }
-
-  public static class NeitherAbstractNorAnnotatedInSuperclassTest
-      extends AbstractEventBusTest<NeitherAbstractNorAnnotatedInSuperclassTest.SubClass> {
-    static class SuperClass {
-      final List<Object> neitherOverriddenNorAnnotatedEvents = new ArrayList<Object>();
-      final List<Object> overriddenInSubclassNowhereAnnotatedEvents = new ArrayList<Object>();
-      final List<Object> overriddenAndAnnotatedInSubclassEvents = new ArrayList<Object>();
-
-      public void neitherOverriddenNorAnnotated(Object o) {
-        neitherOverriddenNorAnnotatedEvents.add(o);
-      }
-
-      public void overriddenInSubclassNowhereAnnotated(Object o) {
-        overriddenInSubclassNowhereAnnotatedEvents.add(o);
-      }
-
-      public void overriddenAndAnnotatedInSubclass(Object o) {
-        overriddenAndAnnotatedInSubclassEvents.add(o);
-      }
-    }
-
-    static class SubClass extends SuperClass {
-      @Override
-      public void overriddenInSubclassNowhereAnnotated(Object o) {
-        super.overriddenInSubclassNowhereAnnotated(o);
-      }
-
-      @Subscribe @Override
-      public void overriddenAndAnnotatedInSubclass(Object o) {
-        super.overriddenAndAnnotatedInSubclass(o);
-      }
-    }
-
-    @Test public void neitherOverriddenNorAnnotated() {
-      assertThat(getHandler().neitherOverriddenNorAnnotatedEvents).isEmpty();
-    }
-
-    @Test public void overriddenInSubclassNowhereAnnotated() {
-      assertThat(getHandler().overriddenInSubclassNowhereAnnotatedEvents).isEmpty();
-    }
-
-    @Test public void overriddenAndAnnotatedInSubclass() {
-      assertThat(getHandler().overriddenAndAnnotatedInSubclassEvents).containsExactly(EVENT);
-    }
-
-    @Override SubClass createHandler() {
-      return new SubClass();
-    }
-  }
-
-  public static class FailsOnInterfaceSubscription {
-
-    static class InterfaceSubscriber {
-      @Subscribe public void whatever(Serializable thingy) {
-        // Do nothing.
-      }
-    }
-
-    @Test public void subscribingToInterfacesFails() {
-      try {
-        new Bus(ThreadEnforcer.ANY).register(new InterfaceSubscriber());
-        fail("Annotation finder allowed subscription to illegal interface type.");
-      } catch (IllegalArgumentException expected) {
-        // Do nothing.
-      }
+    private static final Object EVENT = new Object();
+
+    @Ignore // Tests are in extending classes.
+    public abstract static class AbstractEventBusTest<H> {
+        abstract H createHandler();
+
+        private H handler;
+
+        H getHandler() {
+            return handler;
+        }
+
+        @Before
+        public void setUp() throws Exception {
+            handler = createHandler();
+            Bus bus = new Bus(ThreadEnforcer.ANY);
+            bus.register(handler);
+            bus.post(EVENT);
+        }
+
+        @After
+        public void tearDown() throws Exception {
+            handler = null;
+        }
+    }
+
+    /*
+     * We break the tests up based on whether they are annotated or abstract in the superclass.
+     */
+    public static class BaseHandlerFinderTest
+            extends AbstractEventBusTest<BaseHandlerFinderTest.Handler> {
+        static class Handler {
+            final List<Object> nonSubscriberEvents = new ArrayList<Object>();
+            final List<Object> subscriberEvents = new ArrayList<Object>();
+
+            public void notASubscriber(Object o) {
+                nonSubscriberEvents.add(o);
+            }
+
+            @Subscribe
+            public void subscriber(Object o) {
+                subscriberEvents.add(o);
+            }
+        }
+
+        @Test
+        public void nonSubscriber() {
+            assertThat(getHandler().nonSubscriberEvents).isEmpty();
+        }
+
+        @Test
+        public void subscriber() {
+            assertThat(getHandler().subscriberEvents).containsExactly(EVENT);
+        }
+
+        @Override
+        Handler createHandler() {
+            return new Handler();
+        }
+    }
+
+    public static class AbstractNotAnnotatedInSuperclassTest
+            extends AbstractEventBusTest<AbstractNotAnnotatedInSuperclassTest.SubClass> {
+        abstract static class SuperClass {
+            public abstract void overriddenInSubclassNowhereAnnotated(Object o);
+
+            public abstract void overriddenAndAnnotatedInSubclass(Object o);
+        }
+
+        static class SubClass extends SuperClass {
+            final List<Object> overriddenInSubclassNowhereAnnotatedEvents = new ArrayList<Object>();
+            final List<Object> overriddenAndAnnotatedInSubclassEvents = new ArrayList<Object>();
+
+            @Override
+            public void overriddenInSubclassNowhereAnnotated(Object o) {
+                overriddenInSubclassNowhereAnnotatedEvents.add(o);
+            }
+
+            @Subscribe
+            @Override
+            public void overriddenAndAnnotatedInSubclass(Object o) {
+                overriddenAndAnnotatedInSubclassEvents.add(o);
+            }
+        }
+
+        @Test
+        public void overriddenAndAnnotatedInSubclass() {
+            assertThat(getHandler().overriddenAndAnnotatedInSubclassEvents).containsExactly(EVENT);
+        }
+
+        @Test
+        public void overriddenInSubclassNowhereAnnotated() {
+            assertThat(getHandler().overriddenInSubclassNowhereAnnotatedEvents).isEmpty();
+        }
+
+        @Override
+        SubClass createHandler() {
+            return new SubClass();
+        }
+    }
+
+    public static class NeitherAbstractNorAnnotatedInSuperclassTest
+            extends AbstractEventBusTest<NeitherAbstractNorAnnotatedInSuperclassTest.SubClass> {
+        static class SuperClass {
+            final List<Object> neitherOverriddenNorAnnotatedEvents = new ArrayList<Object>();
+            final List<Object> overriddenInSubclassNowhereAnnotatedEvents = new ArrayList<Object>();
+            final List<Object> overriddenAndAnnotatedInSubclassEvents = new ArrayList<Object>();
+
+            public void neitherOverriddenNorAnnotated(Object o) {
+                neitherOverriddenNorAnnotatedEvents.add(o);
+            }
+
+            public void overriddenInSubclassNowhereAnnotated(Object o) {
+                overriddenInSubclassNowhereAnnotatedEvents.add(o);
+            }
+
+            public void overriddenAndAnnotatedInSubclass(Object o) {
+                overriddenAndAnnotatedInSubclassEvents.add(o);
+            }
+        }
+
+        static class SubClass extends SuperClass {
+            @Override
+            public void overriddenInSubclassNowhereAnnotated(Object o) {
+                super.overriddenInSubclassNowhereAnnotated(o);
+            }
+
+            @Subscribe
+            @Override
+            public void overriddenAndAnnotatedInSubclass(Object o) {
+                super.overriddenAndAnnotatedInSubclass(o);
+            }
+        }
+
+        @Test
+        public void neitherOverriddenNorAnnotated() {
+            assertThat(getHandler().neitherOverriddenNorAnnotatedEvents).isEmpty();
+        }
+
+        @Test
+        public void overriddenInSubclassNowhereAnnotated() {
+            assertThat(getHandler().overriddenInSubclassNowhereAnnotatedEvents).isEmpty();
+        }
+
+        @Test
+        public void overriddenAndAnnotatedInSubclass() {
+            assertThat(getHandler().overriddenAndAnnotatedInSubclassEvents).containsExactly(EVENT);
+        }
+
+        @Override
+        SubClass createHandler() {
+            return new SubClass();
+        }
+    }
+
+    public static class FailsOnInterfaceSubscription {
+
+        static class InterfaceSubscriber {
+            @Subscribe
+            public void whatever(Serializable thingy) {
+                // Do nothing.
+            }
+        }
+
+        @Test
+        public void subscribingToInterfacesFails() {
+            try {
+                new Bus(ThreadEnforcer.ANY).register(new InterfaceSubscriber());
+                fail("Annotation finder allowed subscription to illegal interface type.");
+            } catch (IllegalArgumentException expected) {
+                // Do nothing.
+            }
+        }
     }
-  }
 
 }
diff --git a/otto/src/test/java/com/squareup/otto/outside/AnnotatedProducerFinderTest.java b/otto/src/test/java/com/squareup/otto/outside/AnnotatedProducerFinderTest.java
index 37b9295..c112018 100644
--- a/otto/src/test/java/com/squareup/otto/outside/AnnotatedProducerFinderTest.java
+++ b/otto/src/test/java/com/squareup/otto/outside/AnnotatedProducerFinderTest.java
@@ -20,6 +20,7 @@
 import com.squareup.otto.Produce;
 import com.squareup.otto.Subscribe;
 import com.squareup.otto.ThreadEnforcer;
+
 import org.junit.Test;
 
 import java.util.ArrayList;
@@ -31,7 +32,7 @@
 
 /**
  * Test that Bus finds the correct producers.
- *
+ * <p>
  * This test must be outside the c.g.c.eventbus package to test correctly.
  *
  * @author Jake Wharton
@@ -39,45 +40,49 @@
 @SuppressWarnings("UnusedDeclaration")
 public class AnnotatedProducerFinderTest {
 
-  static class Subscriber {
-    final List<Object> events = new ArrayList<Object>();
+    static class Subscriber {
+        final List<Object> events = new ArrayList<Object>();
 
-    @Subscribe public void subscribe(Object o) {
-      events.add(o);
+        @Subscribe
+        public void subscribe(Object o) {
+            events.add(o);
+        }
     }
-  }
 
-  static class SimpleProducer {
-    static final Object VALUE = new Object();
+    static class SimpleProducer {
+        static final Object VALUE = new Object();
 
-    int produceCalled = 0;
+        int produceCalled = 0;
 
-    @Produce public Object produceIt() {
-      produceCalled += 1;
-      return VALUE;
+        @Produce
+        public Object produceIt() {
+            produceCalled += 1;
+            return VALUE;
+        }
     }
-  }
 
-  @Test public void simpleProducer() {
-    Bus bus = new Bus(ThreadEnforcer.ANY);
-    Subscriber subscriber = new Subscriber();
-    SimpleProducer producer = new SimpleProducer();
+    @Test
+    public void simpleProducer() {
+        Bus bus = new Bus(ThreadEnforcer.ANY);
+        Subscriber subscriber = new Subscriber();
+        SimpleProducer producer = new SimpleProducer();
 
-    bus.register(producer);
-    assertThat(producer.produceCalled).isEqualTo(0);
-    bus.register(subscriber);
-    assertThat(producer.produceCalled).isEqualTo(1);
-    assertEquals(Arrays.asList(SimpleProducer.VALUE), subscriber.events);
-  }
+        bus.register(producer);
+        assertThat(producer.produceCalled).isEqualTo(0);
+        bus.register(subscriber);
+        assertThat(producer.produceCalled).isEqualTo(1);
+        assertEquals(Arrays.asList(SimpleProducer.VALUE), subscriber.events);
+    }
 
-  @Test public void multipleSubscriptionsCallsProviderEachTime() {
-    Bus bus = new Bus(ThreadEnforcer.ANY);
-    SimpleProducer producer = new SimpleProducer();
+    @Test
+    public void multipleSubscriptionsCallsProviderEachTime() {
+        Bus bus = new Bus(ThreadEnforcer.ANY);
+        SimpleProducer producer = new SimpleProducer();
 
-    bus.register(producer);
-    bus.register(new Subscriber());
-    assertThat(producer.produceCalled).isEqualTo(1);
-    bus.register(new Subscriber());
-    assertThat(producer.produceCalled).isEqualTo(2);
-  }
+        bus.register(producer);
+        bus.register(new Subscriber());
+        assertThat(producer.produceCalled).isEqualTo(1);
+        bus.register(new Subscriber());
+        assertThat(producer.produceCalled).isEqualTo(2);
+    }
 }
