diff --git a/otto/src/main/java/com/squareup/otto/AnnotatedHandlerFinder.java b/otto/src/main/java/com/squareup/otto/AnnotatedHandlerFinder.java
index c7fb155..bfbeb71 100644
--- a/otto/src/main/java/com/squareup/otto/AnnotatedHandlerFinder.java
+++ b/otto/src/main/java/com/squareup/otto/AnnotatedHandlerFinder.java
@@ -19,6 +19,8 @@
 
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Map;
@@ -34,12 +36,12 @@
 final class AnnotatedHandlerFinder {
 
   /** Cache event bus producer methods for each class. */
-  private static final Map<Class<?>, Map<Class<?>, Method>> PRODUCERS_CACHE =
-      new HashMap<Class<?>, Map<Class<?>, Method>>();
+  private static final ConcurrentMap<Class<?>, Map<Class<?>, Method>> PRODUCERS_CACHE =
+      new ConcurrentHashMap<Class<?>, Map<Class<?>, Method>>();
 
   /** Cache event bus subscriber methods for each class. */
-  private static final Map<Class<?>, Map<Class<?>, Set<Method>>> SUBSCRIBERS_CACHE =
-      new HashMap<Class<?>, Map<Class<?>, Set<Method>>>();
+  private static final ConcurrentMap<Class<?>, Map<Class<?>, Set<Method>>> SUBSCRIBERS_CACHE =
+      new ConcurrentHashMap<Class<?>, Map<Class<?>, Set<Method>>>();
 
   /**
    * Load all methods annotated with {@link Produce} or {@link Subscribe} into their respective caches for the
@@ -113,8 +115,9 @@ private static void loadAnnotatedMethods(Class<?> listenerClass) {
       }
     }
 
-    PRODUCERS_CACHE.put(listenerClass, producerMethods);
-    SUBSCRIBERS_CACHE.put(listenerClass, subscriberMethods);
+    // if this method is called from multiple threads concurrently, only store the winner
+    PRODUCERS_CACHE.putIfAbsent(listenerClass, producerMethods);
+    SUBSCRIBERS_CACHE.putIfAbsent(listenerClass, subscriberMethods);
   }
 
   /** This implementation finds all methods marked with a {@link Produce} annotation. */
@@ -122,6 +125,10 @@ private static void loadAnnotatedMethods(Class<?> listenerClass) {
     final Class<?> listenerClass = listener.getClass();
     Map<Class<?>, EventProducer> handlersInMethod = new HashMap<Class<?>, EventProducer>();
 
+    // if this method is called from multiple threads concurrently, there
+    // is a chance the annotated methods cache will be built more than once
+    // but the implementation handles this case consistently and with minimal 
+    // blocking
     if (!PRODUCERS_CACHE.containsKey(listenerClass)) {
       loadAnnotatedMethods(listenerClass);
     }
@@ -141,6 +148,10 @@ private static void loadAnnotatedMethods(Class<?> listenerClass) {
     Class<?> listenerClass = listener.getClass();
     Map<Class<?>, Set<EventHandler>> handlersInMethod = new HashMap<Class<?>, Set<EventHandler>>();
 
+    // if this method is called from multiple threads concurrently, there
+    // is a chance the annotated methods cache will be built more than once
+    // but the implementation handles this case consistently and with minimal 
+    // blocking
     if (!SUBSCRIBERS_CACHE.containsKey(listenerClass)) {
       loadAnnotatedMethods(listenerClass);
     }
