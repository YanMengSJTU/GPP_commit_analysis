diff --git a/otto-sample/src/main/java/com/squareup/otto/sample/LocationHistoryFragment.java b/otto-sample/src/main/java/com/squareup/otto/sample/LocationHistoryFragment.java
index ce44b42..2ffac6f 100644
--- a/otto-sample/src/main/java/com/squareup/otto/sample/LocationHistoryFragment.java
+++ b/otto-sample/src/main/java/com/squareup/otto/sample/LocationHistoryFragment.java
@@ -20,8 +20,9 @@
 import android.support.v4.app.ListFragment;
 import android.view.View;
 import android.widget.ArrayAdapter;
+import com.squareup.otto.Callback;
 import com.squareup.otto.Subscribe;
-
+import java.lang.reflect.InvocationTargetException;
 import java.util.ArrayList;
 import java.util.List;
 
@@ -29,30 +30,37 @@
 public class LocationHistoryFragment extends ListFragment {
   private final List<String> locationEvents = new ArrayList<String>();
   private ArrayAdapter<String> adapter;
+  private Callback callback;
 
   @Override public void onResume() {
     super.onResume();
     BusProvider.getInstance().register(this);
+    // Example of explicit registration of Callbacks
+    callback = new Callback() {
+      @Override public void call(Object event) throws InvocationTargetException {
+        locationEvents.add(0, event.toString());
+        if (adapter != null) {
+          adapter.notifyDataSetChanged();
+        }
+      }
+    };
+    BusProvider.getInstance().register(LocationChangedEvent.class, callback);
   }
 
   @Override public void onPause() {
     super.onPause();
     BusProvider.getInstance().unregister(this);
+    // Example of explicit un-registration of Callbacks
+    BusProvider.getInstance().unregister(LocationHistoryFragment.class, callback);
   }
 
   @Override public void onViewCreated(View view, Bundle savedInstanceState) {
     super.onViewCreated(view, savedInstanceState);
-    adapter = new ArrayAdapter<String>(getActivity(), android.R.layout.simple_list_item_1, locationEvents);
+    adapter = new ArrayAdapter<String>(getActivity(), android.R.layout.simple_list_item_1,
+        locationEvents);
     setListAdapter(adapter);
   }
 
-  @Subscribe public void onLocationChanged(LocationChangedEvent event) {
-    locationEvents.add(0, event.toString());
-    if (adapter != null) {
-      adapter.notifyDataSetChanged();
-    }
-  }
-
   @Subscribe public void onLocationCleared(LocationClearEvent event) {
     locationEvents.clear();
     if (adapter != null) {
diff --git a/otto/src/main/java/com/squareup/otto/Bus.java b/otto/src/main/java/com/squareup/otto/Bus.java
index 0ab6620..4792d49 100644
--- a/otto/src/main/java/com/squareup/otto/Bus.java
+++ b/otto/src/main/java/com/squareup/otto/Bus.java
@@ -29,19 +29,22 @@
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.CopyOnWriteArraySet;
 
-
 /**
  * Dispatches events to listeners, and provides ways for listeners to register themselves.
  *
- * <p>The Bus allows publish-subscribe-style communication between components without requiring the components to
- * explicitly register with one another (and thus be aware of each other).  It is designed exclusively to replace
- * traditional Android in-process event distribution using explicit registration or listeners. It is <em>not</em> a
+ * <p>The Bus allows publish-subscribe-style communication between components without requiring the
+ * components to
+ * explicitly register with one another (and thus be aware of each other).  It is designed
+ * exclusively to replace
+ * traditional Android in-process event distribution using explicit registration or listeners. It is
+ * <em>not</em> a
  * general-purpose publish-subscribe system, nor is it intended for interprocess communication.
  *
  * <h2>Receiving Events</h2>
  * To receive events, an object should:
  * <ol>
- * <li>Expose a public method, known as the <i>event handler</i>, which accepts a single argument of the type of event
+ * <li>Expose a public method, known as the <i>event handler</i>, which accepts a single argument of
+ * the type of event
  * desired;</li>
  * <li>Mark it with a {@link com.squareup.otto.Subscribe} annotation;</li>
  * <li>Pass itself to an Bus instance's {@link #register(Object)} method.
@@ -49,15 +52,20 @@
  * </ol>
  *
  * <h2>Posting Events</h2>
- * To post an event, simply provide the event object to the {@link #post(Object)} method.  The Bus instance will
+ * To post an event, simply provide the event object to the {@link #post(Object)} method.  The Bus
+ * instance will
  * determine the type of event and route it to all registered listeners.
  *
- * <p>Events are routed based on their type &mdash; an event will be delivered to any handler for any type to which the
- * event is <em>assignable.</em>  This includes implemented interfaces, all superclasses, and all interfaces implemented
+ * <p>Events are routed based on their type &mdash; an event will be delivered to any handler for
+ * any type to which the
+ * event is <em>assignable.</em>  This includes implemented interfaces, all superclasses, and all
+ * interfaces implemented
  * by superclasses.
  *
- * <p>When {@code post} is called, all registered handlers for an event are run in sequence, so handlers should be
- * reasonably quick.  If an event may trigger an extended process (such as a database load), spawn a thread or queue it
+ * <p>When {@code post} is called, all registered handlers for an event are run in sequence, so
+ * handlers should be
+ * reasonably quick.  If an event may trigger an extended process (such as a database load), spawn a
+ * thread or queue it
  * for later.
  *
  * <h2>Handler Methods</h2>
@@ -66,17 +74,22 @@
  * <p>Handlers should not, in general, throw.  If they do, the Bus will wrap the exception and
  * re-throw it.
  *
- * <p>The Bus by default enforces that all interactions occur on the main thread.  You can provide an alternate
+ * <p>The Bus by default enforces that all interactions occur on the main thread.  You can provide
+ * an alternate
  * enforcement by passing a {@link ThreadEnforcer} to the constructor.
  *
  * <h2>Producer Methods</h2>
- * Producer methods should accept no arguments and return their event type. When a subscriber is registered for a type
- * that a producer is also already registered for, the subscriber will be called with the return value from the
+ * Producer methods should accept no arguments and return their event type. When a subscriber is
+ * registered for a type
+ * that a producer is also already registered for, the subscriber will be called with the return
+ * value from the
  * producer.
  *
  * <h2>Dead Events</h2>
- * If an event is posted, but no registered handlers can accept it, it is considered "dead."  To give the system a
- * second chance to handle dead events, they are wrapped in an instance of {@link com.squareup.otto.DeadEvent} and
+ * If an event is posted, but no registered handlers can accept it, it is considered "dead."  To
+ * give the system a
+ * second chance to handle dead events, they are wrapped in an instance of {@link
+ * com.squareup.otto.DeadEvent} and
  * reposted.
  *
  * <p>This class is safe for concurrent use.
@@ -89,11 +102,11 @@
 
   /** All registered event handlers, indexed by event type. */
   private final ConcurrentMap<Class<?>, Set<EventHandler>> handlersByType =
-          new ConcurrentHashMap<Class<?>, Set<EventHandler>>();
+      new ConcurrentHashMap<Class<?>, Set<EventHandler>>();
 
   /** All registered event producers, index by event type. */
   private final ConcurrentMap<Class<?>, EventProducer> producersByType =
-          new ConcurrentHashMap<Class<?>, EventProducer>();
+      new ConcurrentHashMap<Class<?>, EventProducer>();
 
   /** Identifier used to differentiate the event bus instance. */
   private final String identifier;
@@ -127,7 +140,8 @@ public Bus() {
   /**
    * Creates a new Bus with the given {@code identifier} that enforces actions on the main thread.
    *
-   * @param identifier a brief name for this bus, for debugging purposes.  Should be a valid Java identifier.
+   * @param identifier a brief name for this bus, for debugging purposes.  Should be a valid Java
+   * identifier.
    */
   public Bus(String identifier) {
     this(ThreadEnforcer.MAIN, identifier);
@@ -143,10 +157,12 @@ public Bus(ThreadEnforcer enforcer) {
   }
 
   /**
-   * Creates a new Bus with the given {@code enforcer} for actions and the given {@code identifier}.
+   * Creates a new Bus with the given {@code enforcer} for actions and the given {@code
+   * identifier}.
    *
    * @param enforcer Thread enforcer for register, unregister, and post actions.
-   * @param identifier A brief name for this bus, for debugging purposes.  Should be a valid Java identifier.
+   * @param identifier A brief name for this bus, for debugging purposes.  Should be a valid Java
+   * identifier.
    */
   public Bus(ThreadEnforcer enforcer, String identifier) {
     this(enforcer, identifier, HandlerFinder.ANNOTATED);
@@ -156,11 +172,13 @@ public Bus(ThreadEnforcer enforcer, String identifier) {
    * Test constructor which allows replacing the default {@code HandlerFinder}.
    *
    * @param enforcer Thread enforcer for register, unregister, and post actions.
-   * @param identifier A brief name for this bus, for debugging purposes.  Should be a valid Java identifier.
-   * @param handlerFinder Used to discover event handlers and producers when registering/unregistering an object.
+   * @param identifier A brief name for this bus, for debugging purposes.  Should be a valid Java
+   * identifier.
+   * @param handlerFinder Used to discover event handlers and producers when
+   * registering/unregistering an object.
    */
   Bus(ThreadEnforcer enforcer, String identifier, HandlerFinder handlerFinder) {
-    this.enforcer =  enforcer;
+    this.enforcer = enforcer;
     this.identifier = identifier;
     this.handlerFinder = handlerFinder;
   }
@@ -170,12 +188,15 @@ public Bus(ThreadEnforcer enforcer, String identifier) {
   }
 
   /**
-   * Registers all handler methods on {@code object} to receive events and producer methods to provide events.
+   * Registers all handler methods on {@code object} to receive events and producer methods to
+   * provide events.
    * <p>
-   * If any subscribers are registering for types which already have a producer they will be called immediately
+   * If any subscribers are registering for types which already have a producer they will be called
+   * immediately
    * with the result of calling that producer.
    * <p>
-   * If any producers are registering for types which already have subscribers, each subscriber will be called with
+   * If any producers are registering for types which already have subscribers, each subscriber will
+   * be called with
    * the value from the result of calling the producer.
    *
    * @param object object whose handler methods should be registered.
@@ -194,9 +215,13 @@ public void register(Object object) {
       EventProducer previousProducer = producersByType.putIfAbsent(type, producer);
       //checking if the previous producer existed
       if (previousProducer != null) {
-        throw new IllegalArgumentException("Producer method for type " + type
-          + " found on type " + producer.target.getClass()
-          + ", but already registered by type " + previousProducer.target.getClass() + ".");
+        throw new IllegalArgumentException("Producer method for type "
+            + type
+            + " found on type "
+            + producer.target.getClass()
+            + ", but already registered by type "
+            + previousProducer.target.getClass()
+            + ".");
       }
       Set<EventHandler> handlers = handlersByType.get(type);
       if (handlers != null && !handlers.isEmpty()) {
@@ -214,7 +239,7 @@ public void register(Object object) {
         Set<EventHandler> handlersCreation = new CopyOnWriteArraySet<EventHandler>();
         handlers = handlersByType.putIfAbsent(type, handlersCreation);
         if (handlers == null) {
-            handlers = handlersCreation;
+          handlers = handlersCreation;
         }
       }
       final Set<EventHandler> foundHandlers = foundHandlersMap.get(type);
@@ -240,6 +265,27 @@ public void register(Object object) {
     }
   }
 
+  /**
+   * Registers a new EventHandler for events of the provided type that will execute
+   * the provided callback whenever it is posted.
+   *
+   * @param type event class to subscribe to.
+   * @param callback Callback instance that will be executed when an event of the
+   * provided type is posted.
+   */
+  public void register(Class type, Callback callback) {
+    Set<EventHandler> handlers = handlersByType.get(type);
+    if (handlers == null) {
+      //concurrent put if absent
+      Set<EventHandler> handlersCreation = new CopyOnWriteArraySet<EventHandler>();
+      handlers = handlersByType.putIfAbsent(type, handlersCreation);
+      if (handlers == null) {
+        handlers = handlersCreation;
+      }
+    }
+    handlers.add(new EventHandler(callback));
+  }
+
   private void dispatchProducerResultToHandler(EventHandler handler, EventProducer producer) {
     Object event = null;
     try {
@@ -273,9 +319,9 @@ public void unregister(Object object) {
       EventProducer value = entry.getValue();
 
       if (value == null || !value.equals(producer)) {
-        throw new IllegalArgumentException(
-            "Missing event producer for an annotated method. Is " + object.getClass()
-                + " registered?");
+        throw new IllegalArgumentException("Missing event producer for an annotated method. Is "
+            + object.getClass()
+            + " registered?");
       }
       producersByType.remove(key).invalidate();
     }
@@ -286,9 +332,9 @@ public void unregister(Object object) {
       Collection<EventHandler> eventMethodsInListener = entry.getValue();
 
       if (currentHandlers == null || !currentHandlers.containsAll(eventMethodsInListener)) {
-        throw new IllegalArgumentException(
-            "Missing event handler for an annotated method. Is " + object.getClass()
-                + " registered?");
+        throw new IllegalArgumentException("Missing event handler for an annotated method. Is "
+            + object.getClass()
+            + " registered?");
       }
 
       for (EventHandler handler : currentHandlers) {
@@ -301,10 +347,38 @@ public void unregister(Object object) {
   }
 
   /**
-   * Posts an event to all registered handlers.  This method will return successfully after the event has been posted to
+   * Unregisters a Callback for a particular event type.
+   *
+   * @param type event class to unsubscribe from.
+   * @param callback Callback instance that would be executed when an event of the
+   * provided type was posted.
+   */
+  public void unregister(Class type, Callback callback) {
+    Set<EventHandler> currentHandlers = getHandlersForEventType(type);
+    if (currentHandlers == null) {
+      throw new IllegalArgumentException("There are no EventHandlers for type " + type);
+    }
+    EventHandler eventHandler = null;
+    for (EventHandler candidate : currentHandlers) {
+      if (candidate.hasCallback(callback)) {
+        eventHandler = candidate;
+      }
+    }
+    if (eventHandler == null) {
+      throw new IllegalArgumentException(
+          "There is no EventHandler for type " + type + " with callback " + callback);
+    }
+    eventHandler.invalidate();
+    currentHandlers.remove(eventHandler);
+  }
+
+  /**
+   * Posts an event to all registered handlers.  This method will return successfully after the
+   * event has been posted to
    * all handlers, and regardless of any exceptions thrown by handlers.
    *
-   * <p>If no handlers have been subscribed for {@code event}'s class, and {@code event} is not already a
+   * <p>If no handlers have been subscribed for {@code event}'s class, and {@code event} is not
+   * already a
    * {@link DeadEvent}, it will be wrapped in a DeadEvent and reposted.
    *
    * @param event event to post.
@@ -338,7 +412,8 @@ public void post(Object event) {
   }
 
   /**
-   * Queue the {@code event} for dispatch during {@link #dispatchQueuedEvents()}. Events are queued in-order of
+   * Queue the {@code event} for dispatch during {@link #dispatchQueuedEvents()}. Events are queued
+   * in-order of
    * occurrence so they can be dispatched in the same order.
    */
   protected void enqueueEvent(Object event, EventHandler handler) {
@@ -346,7 +421,8 @@ protected void enqueueEvent(Object event, EventHandler handler) {
   }
 
   /**
-   * Drain the queue of events to be dispatched. As the queue is being drained, new events may be posted to the end of
+   * Drain the queue of events to be dispatched. As the queue is being drained, new events may be
+   * posted to the end of
    * the queue.
    */
   protected void dispatchQueuedEvents() {
@@ -374,7 +450,8 @@ protected void dispatchQueuedEvents() {
   }
 
   /**
-   * Dispatches {@code event} to the handler in {@code wrapper}.  This method is an appropriate override point for
+   * Dispatches {@code event} to the handler in {@code wrapper}.  This method is an appropriate
+   * override point for
    * subclasses that wish to make event delivery asynchronous.
    *
    * @param event event to dispatch.
@@ -390,7 +467,8 @@ protected void dispatch(Object event, EventHandler wrapper) {
   }
 
   /**
-   * Retrieves the currently registered producer for {@code type}.  If no producer is currently registered for
+   * Retrieves the currently registered producer for {@code type}.  If no producer is currently
+   * registered for
    * {@code type}, this method will return {@code null}.
    *
    * @param type type of producer to retrieve.
@@ -401,7 +479,8 @@ EventProducer getProducerForEventType(Class<?> type) {
   }
 
   /**
-   * Retrieves a mutable set of the currently registered handlers for {@code type}.  If no handlers are currently
+   * Retrieves a mutable set of the currently registered handlers for {@code type}.  If no handlers
+   * are currently
    * registered for {@code type}, this method may either return {@code null} or an empty set.
    *
    * @param type type of handlers to retrieve.
@@ -412,7 +491,8 @@ EventProducer getProducerForEventType(Class<?> type) {
   }
 
   /**
-   * Flattens a class's type hierarchy into a set of Class objects.  The set will include all superclasses
+   * Flattens a class's type hierarchy into a set of Class objects.  The set will include all
+   * superclasses
    * (transitively), and all interfaces implemented by these superclasses.
    *
    * @param concreteClass class whose type hierarchy will be retrieved.
diff --git a/otto/src/main/java/com/squareup/otto/Callback.java b/otto/src/main/java/com/squareup/otto/Callback.java
new file mode 100644
index 0000000..365cae5
--- /dev/null
+++ b/otto/src/main/java/com/squareup/otto/Callback.java
@@ -0,0 +1,21 @@
+package com.squareup.otto;
+
+import java.lang.reflect.InvocationTargetException;
+
+/**
+ * <p>This interface represents something that an EventHandler can call whenever it is posted an
+ * Event.</p>
+ *
+ * @author Guillermo Gutierrez
+ */
+public interface Callback<T> {
+  /**
+   * <p>This method will be called whenever an Event is posted to the EventHandler that has an
+   * implementation of this
+   * interface.</p>
+   *
+   * @param event event object that has been posted
+   * @throws InvocationTargetException
+   */
+  void call(T event) throws InvocationTargetException;
+}
diff --git a/otto/src/main/java/com/squareup/otto/EventHandler.java b/otto/src/main/java/com/squareup/otto/EventHandler.java
index 843a31b..c5fda8c 100644
--- a/otto/src/main/java/com/squareup/otto/EventHandler.java
+++ b/otto/src/main/java/com/squareup/otto/EventHandler.java
@@ -23,20 +23,20 @@
 /**
  * Wraps a single-argument 'handler' method on a specific object.
  *
- * <p>This class only verifies the suitability of the method and event type if something fails.  Callers are expected t
+ * <p>This class only verifies the suitability of the method and event type if something fails.
+ * Callers are expected t
  * verify their uses of this class.
- *
- * <p>Two EventHandlers are equivalent when they refer to the same method on the same object (not class).   This
+ * <p/>
+ * <p>Two EventHandlers are equivalent when they refer to the same method on the same object (not
+ * class).   This
  * property is used to ensure that no handler method is registered more than once.
  *
  * @author Cliff Biffle
  */
 class EventHandler {
 
-  /** Object sporting the handler method. */
-  private final Object target;
-  /** Handler method. */
-  private final Method method;
+  /** Handler Callback. */
+  private final Callback callback;
   /** Object hash code. */
   private final int hashCode;
   /** Should this handler receive events? */
@@ -50,14 +50,23 @@
       throw new NullPointerException("EventHandler method cannot be null.");
     }
 
-    this.target = target;
-    this.method = method;
-    method.setAccessible(true);
+    // Compute hash code eagerly since we know it will be used frequently and we cannot estimate the runtime of the
+    // target's hashCode call.
+    final int prime = 31;
+    this.callback = new MethodInvokingCallback(target, method);
+    this.hashCode = (prime + callback.hashCode()) * prime + target.hashCode();
+  }
+
+  EventHandler(final Callback callback) {
+    if (callback == null) {
+      throw new NullPointerException("EventHandler callback cannot be null.");
+    }
 
     // Compute hash code eagerly since we know it will be used frequently and we cannot estimate the runtime of the
     // target's hashCode call.
     final int prime = 31;
-    hashCode = (prime + method.hashCode()) * prime + target.hashCode();
+    this.callback = callback;
+    this.hashCode = (prime + callback.hashCode()) * prime;
   }
 
   public boolean isValid() {
@@ -74,31 +83,25 @@ public void invalidate() {
   }
 
   /**
-   * Invokes the wrapped handler method to handle {@code event}.
+   * Invokes the wrapped handler callback to handle {@code event}.
    *
-   * @param event  event to handle
-   * @throws java.lang.IllegalStateException  if previously invalidated.
-   * @throws java.lang.reflect.InvocationTargetException  if the wrapped method throws any {@link Throwable} that is not
-   *     an {@link Error} ({@code Error}s are propagated as-is).
+   * @param event event to handle
+   * @throws java.lang.reflect.InvocationTargetException if the wrapped callback throws any
+   * {@link Throwable} that is not
+   * an {@link Error} ({@code Error}s
+   * are propagated as-is).
    */
-  public void handleEvent(Object event) throws InvocationTargetException {
+  @SuppressWarnings("unchecked") public void handleEvent(Object event)
+      throws InvocationTargetException {
     if (!valid) {
-      throw new IllegalStateException(toString() + " has been invalidated and can no longer handle events.");
-    }
-    try {
-      method.invoke(target, event);
-    } catch (IllegalAccessException e) {
-      throw new AssertionError(e);
-    } catch (InvocationTargetException e) {
-      if (e.getCause() instanceof Error) {
-        throw (Error) e.getCause();
-      }
-      throw e;
+      throw new IllegalStateException(
+          toString() + " has been invalidated and can no longer handle events.");
     }
+    callback.call(event);
   }
 
   @Override public String toString() {
-    return "[EventHandler " + method + "]";
+    return "[EventHandler " + callback.toString() + "]";
   }
 
   @Override public int hashCode() {
@@ -120,7 +123,10 @@ public void handleEvent(Object event) throws InvocationTargetException {
 
     final EventHandler other = (EventHandler) obj;
 
-    return method.equals(other.method) && target == other.target;
+    return callback.equals(other.callback);
   }
 
+  public boolean hasCallback(Callback callback) {
+    return this.callback.equals(callback);
+  }
 }
diff --git a/otto/src/main/java/com/squareup/otto/MethodInvokingCallback.java b/otto/src/main/java/com/squareup/otto/MethodInvokingCallback.java
new file mode 100644
index 0000000..243c01a
--- /dev/null
+++ b/otto/src/main/java/com/squareup/otto/MethodInvokingCallback.java
@@ -0,0 +1,86 @@
+package com.squareup.otto;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
+/**
+ * <p>Extracted from EventHandler's original implementation</p>
+ * <p>Wraps a Method in a Callback interface in order to be called whenever the EventHandler is
+ * posted an Event</p>
+ * <p>This class only verifies the suitability of the method and event type if something fails.
+ * Callers are expected to
+ * verify their uses of this class.</p>
+ * <p>Two MethodInvokingCallback are equivalent when they refer to the same method on the same
+ * object (not class).
+ * This property is used to ensure that no handler method is registered more than once.</p>
+ *
+ * @author Guillermo Gutierrez
+ */
+public class MethodInvokingCallback implements Callback {
+  private final Object target;
+  private final Method method;
+  private final int hashCode;
+
+  public MethodInvokingCallback(Object target, Method method) {
+    method.setAccessible(true);
+    this.target = target;
+    this.method = method;
+    // Compute hash code eagerly since we know it will be used frequently and we cannot estimate the runtime of the
+    // target's hashCode call.
+    final int prime = 31;
+    hashCode = (prime + method.hashCode()) * prime + target.hashCode();
+  }
+
+  /**
+   * <p>This method will be called whenever an Event is posted to the EventHandler that has an
+   * implementation of this
+   * interface.</p>
+   *
+   * @param event event to handle
+   * @throws java.lang.reflect.InvocationTargetException if the wrapped method throws any {@link
+   * Throwable} that is not
+   * an {@link Error} ({@code Error}s are propagated as-is).
+   */
+  @Override public void call(Object event) throws InvocationTargetException {
+    try {
+      method.invoke(target, event);
+    } catch (IllegalAccessException e) {
+      throw new AssertionError(e);
+    } catch (InvocationTargetException e) {
+      if (e.getCause() instanceof Error) {
+        throw (Error) e.getCause();
+      }
+      throw e;
+    }
+  }
+
+  public Method getMethod() {
+    return method;
+  }
+
+  @Override public String toString() {
+    return method.toString();
+  }
+
+  @Override public int hashCode() {
+    return hashCode;
+  }
+
+  @Override public boolean equals(Object obj) {
+    if (this == obj) {
+      return true;
+    }
+
+    if (obj == null) {
+      return false;
+    }
+
+    if (getClass() != obj.getClass()) {
+      return false;
+    }
+
+    final MethodInvokingCallback other = (MethodInvokingCallback) obj;
+
+    return method.equals(other.getMethod()) && target == other.target;
+  }
+}
diff --git a/otto/src/test/java/com/squareup/otto/BusTest.java b/otto/src/test/java/com/squareup/otto/BusTest.java
index 3cc0572..3188c6b 100644
--- a/otto/src/test/java/com/squareup/otto/BusTest.java
+++ b/otto/src/test/java/com/squareup/otto/BusTest.java
@@ -16,14 +16,14 @@
 
 package com.squareup.otto;
 
-import org.junit.Before;
-import org.junit.Test;
-
+import java.lang.reflect.InvocationTargetException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.List;
 import java.util.Set;
+import org.junit.Before;
+import org.junit.Test;
 
 import static junit.framework.Assert.assertEquals;
 import static junit.framework.Assert.assertNotNull;
@@ -86,8 +86,7 @@
 
     final List<Object> objectEvents = new ArrayList<Object>();
     Object objCatcher = new Object() {
-      @SuppressWarnings("unused")
-      @Subscribe public void eat(Object food) {
+      @SuppressWarnings("unused") @Subscribe public void eat(Object food) {
         objectEvents.add(food);
       }
     };
@@ -105,20 +104,15 @@
 
     // Check the StringCatcher...
     List<String> stringEvents = stringCatcher.getEvents();
-    assertEquals("Only one String should be delivered.",
-        1, stringEvents.size());
-    assertEquals("Correct string should be delivered.",
-        EVENT, stringEvents.get(0));
+    assertEquals("Only one String should be delivered.", 1, stringEvents.size());
+    assertEquals("Correct string should be delivered.", EVENT, stringEvents.get(0));
 
     // Check the Catcher<Object>...
-    assertEquals("Three Objects should be delivered.",
-        3, objectEvents.size());
-    assertEquals("String fixture must be first object delivered.",
-        EVENT, objectEvents.get(0));
-    assertEquals("Object fixture must be second object delivered.",
-        OBJ_EVENT, objectEvents.get(1));
-    assertEquals("Comparable fixture must be thirdobject delivered.",
-        COMP_EVENT, objectEvents.get(2));
+    assertEquals("Three Objects should be delivered.", 3, objectEvents.size());
+    assertEquals("String fixture must be first object delivered.", EVENT, objectEvents.get(0));
+    assertEquals("Object fixture must be second object delivered.", OBJ_EVENT, objectEvents.get(1));
+    assertEquals("Comparable fixture must be thirdobject delivered.", COMP_EVENT,
+        objectEvents.get(2));
   }
 
   @Test public void deadEventForwarding() {
@@ -130,8 +124,7 @@
 
     List<DeadEvent> events = catcher.getEvents();
     assertEquals("One dead event should be delivered.", 1, events.size());
-    assertEquals("The dead event should wrap the original event.",
-        EVENT, events.get(0).event);
+    assertEquals("The dead event should wrap the original event.", EVENT, events.get(0).event);
   }
 
   @Test public void deadEventPosting() {
@@ -141,10 +134,8 @@
     bus.post(new DeadEvent(this, EVENT));
 
     List<DeadEvent> events = catcher.getEvents();
-    assertEquals("The explicit DeadEvent should be delivered.",
-        1, events.size());
-    assertEquals("The dead event must not be re-wrapped.",
-        EVENT, events.get(0).event);
+    assertEquals("The explicit DeadEvent should be delivered.", 1, events.size());
+    assertEquals("The dead event must not be re-wrapped.", EVENT, events.get(0).event);
   }
 
   @Test public void testNullInteractions() {
@@ -194,7 +185,8 @@
   @Test public void subscribingOrProducingOnlyAllowedOnPublicMethods() {
     try {
       bus.register(new Object() {
-        @Subscribe protected void method(Object o) {}
+        @Subscribe protected void method(Object o) {
+        }
       });
       fail();
     } catch (IllegalArgumentException expected) {
@@ -202,45 +194,54 @@
     }
     try {
       bus.register(new Object() {
-        @Subscribe void method(Object o) {}
+        @Subscribe void method(Object o) {
+        }
       });
       fail();
     } catch (IllegalArgumentException expected) {
     }
     try {
       bus.register(new Object() {
-        @Subscribe private void method(Object o) {}
+        @Subscribe private void method(Object o) {
+        }
       });
       fail();
     } catch (IllegalArgumentException expected) {
     }
     try {
       bus.register(new Object() {
-        @Produce protected Object method() { return null; }
+        @Produce protected Object method() {
+          return null;
+        }
       });
       fail();
     } catch (IllegalArgumentException expected) {
     }
     try {
       bus.register(new Object() {
-        @Produce Object method() { return null; }
+        @Produce Object method() {
+          return null;
+        }
       });
       fail();
     } catch (IllegalArgumentException expected) {
     }
     try {
       bus.register(new Object() {
-        @Produce private Object method() { return null; }
+        @Produce private Object method() {
+          return null;
+        }
       });
       fail();
     } catch (IllegalArgumentException expected) {
     }
   }
 
-  @Test(expected = IllegalArgumentException.class)
-  public void voidProducerThrowsException() throws Exception {
+  @Test(expected = IllegalArgumentException.class) public void voidProducerThrowsException()
+      throws Exception {
     class VoidProducer {
-      @Produce public void things() {}
+      @Produce public void things() {
+      }
     }
     bus.register(new VoidProducer());
   }
@@ -287,19 +288,17 @@ public void voidProducerThrowsException() throws Exception {
     expectedEvents.add(EVENT);
     expectedEvents.add(EVENT);
 
-    assertEquals("Two correct events should be delivered.",
-                 expectedEvents, catcher1.getEvents());
+    assertEquals("Two correct events should be delivered.", expectedEvents, catcher1.getEvents());
 
-    assertEquals("One correct event should be delivered.",
-        Arrays.asList(EVENT), catcher2.getEvents());
+    assertEquals("One correct event should be delivered.", Arrays.asList(EVENT),
+        catcher2.getEvents());
 
     bus.unregister(catcher1);
     bus.post(EVENT);
 
-    assertEquals("Shouldn't catch any more events when unregistered.",
-                 expectedEvents, catcher1.getEvents());
-    assertEquals("Two correct events should be delivered.",
-                 expectedEvents, catcher2.getEvents());
+    assertEquals("Shouldn't catch any more events when unregistered.", expectedEvents,
+        catcher1.getEvents());
+    assertEquals("Two correct events should be delivered.", expectedEvents, catcher2.getEvents());
 
     try {
       bus.unregister(catcher1);
@@ -310,10 +309,66 @@ public void voidProducerThrowsException() throws Exception {
 
     bus.unregister(catcher2);
     bus.post(EVENT);
-    assertEquals("Shouldn't catch any more events when unregistered.",
-                 expectedEvents, catcher1.getEvents());
-    assertEquals("Shouldn't catch any more events when unregistered.",
-                 expectedEvents, catcher2.getEvents());
+    assertEquals("Shouldn't catch any more events when unregistered.", expectedEvents,
+        catcher1.getEvents());
+    assertEquals("Shouldn't catch any more events when unregistered.", expectedEvents,
+        catcher2.getEvents());
+  }
+
+  @Test public void unregisterCallback() {
+    final StringCatcher catcher1 = new StringCatcher();
+    final StringCatcher catcher2 = new StringCatcher();
+    Callback catcher1Callback = new Callback<String>() {
+      @Override public void call(String event) throws InvocationTargetException {
+        catcher1.hereHaveAString(event);
+      }
+    };
+    Callback catcher2Callback = new Callback<String>() {
+      @Override public void call(String event) throws InvocationTargetException {
+        catcher2.hereHaveAString(event);
+      }
+    };
+    try {
+      bus.unregister(String.class, catcher1Callback);
+      fail("Attempting to unregister an unregistered object succeeded");
+    } catch (IllegalArgumentException expected) {
+      // OK.
+    }
+
+    bus.register(String.class, catcher1Callback);
+    bus.post(EVENT);
+    bus.register(String.class, catcher2Callback);
+    bus.post(EVENT);
+
+    List<String> expectedEvents = new ArrayList<String>();
+    expectedEvents.add(EVENT);
+    expectedEvents.add(EVENT);
+
+    assertEquals("Two correct events should be delivered.", expectedEvents, catcher1.getEvents());
+
+    assertEquals("One correct event should be delivered.", Arrays.asList(EVENT),
+        catcher2.getEvents());
+
+    bus.unregister(String.class, catcher1Callback);
+    bus.post(EVENT);
+
+    assertEquals("Shouldn't catch any more events when unregistered.", expectedEvents,
+        catcher1.getEvents());
+    assertEquals("Two correct events should be delivered.", expectedEvents, catcher2.getEvents());
+
+    try {
+      bus.unregister(String.class, catcher1Callback);
+      fail("Attempting to unregister an unregistered object succeeded");
+    } catch (IllegalArgumentException expected) {
+      // OK.
+    }
+
+    bus.unregister(String.class, catcher2Callback);
+    bus.post(EVENT);
+    assertEquals("Shouldn't catch any more events when unregistered.", expectedEvents,
+        catcher1.getEvents());
+    assertEquals("Shouldn't catch any more events when unregistered.", expectedEvents,
+        catcher2.getEvents());
   }
 
   @Test public void producingNullIsInvalid() {
@@ -362,21 +417,18 @@ public void voidProducerThrowsException() throws Exception {
   }
 
   private <T> void assertContains(T element, Collection<T> collection) {
-    assertTrue("Collection must contain " + element,
-        collection.contains(element));
+    assertTrue("Collection must contain " + element, collection.contains(element));
   }
 
   /**
    * A collector for DeadEvents.
    *
    * @author cbiffle
-   *
    */
   public static class GhostCatcher {
     private List<DeadEvent> events = new ArrayList<DeadEvent>();
 
-    @Subscribe
-    public void ohNoesIHaveDied(DeadEvent event) {
+    @Subscribe public void ohNoesIHaveDied(DeadEvent event) {
       events.add(event);
     }
 
@@ -399,13 +451,11 @@ public void ohNoesIHaveDied(DeadEvent event) {
     // Exists only for hierarchy mapping; no members.
   }
 
-  public interface HierarchyFixtureSubinterface
-      extends HierarchyFixtureInterface {
+  public interface HierarchyFixtureSubinterface extends HierarchyFixtureInterface {
     // Exists only for hierarchy mapping; no members.
   }
 
-  public static class HierarchyFixtureParent
-      implements HierarchyFixtureSubinterface {
+  public static class HierarchyFixtureParent implements HierarchyFixtureSubinterface {
     // Exists only for hierarchy mapping; no members.
   }
 
@@ -414,13 +464,11 @@ public void ohNoesIHaveDied(DeadEvent event) {
   }
 
   interface SubscriberInterface<T> {
-    @Subscribe
-    void subscribeToT(T value);
+    @Subscribe void subscribeToT(T value);
   }
 
   static class SubscriberImpl implements SubscriberInterface<Number> {
-    @Subscribe
-    public void subscribeToT(Number value) {
+    @Subscribe public void subscribeToT(Number value) {
       // No numbers are expected to be published.
       fail();
     }
@@ -435,5 +483,4 @@ public void subscribeToT(Number value) {
     bus.register(catcher);
     bus.post(EVENT);
   }
-
 }
diff --git a/otto/src/test/java/com/squareup/otto/EventHandlerTest.java b/otto/src/test/java/com/squareup/otto/EventHandlerTest.java
index 98fd510..a8f1c46 100644
--- a/otto/src/test/java/com/squareup/otto/EventHandlerTest.java
+++ b/otto/src/test/java/com/squareup/otto/EventHandlerTest.java
@@ -16,11 +16,10 @@
 
 package com.squareup.otto;
 
-import org.junit.Before;
-import org.junit.Test;
-
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
+import org.junit.Before;
+import org.junit.Test;
 
 import static junit.framework.Assert.assertSame;
 import static junit.framework.Assert.assertTrue;
@@ -41,7 +40,7 @@
   /**
    * Checks that a no-frills, no-issues method call is properly executed.
    *
-   * @throws Exception  if the aforementioned proper execution is not to be had.
+   * @throws Exception if the aforementioned proper execution is not to be had.
    */
   @Test public void basicMethodCall() throws Exception {
     Method method = getRecordingMethod();
@@ -51,8 +50,8 @@
     handler.handleEvent(FIXTURE_ARGUMENT);
 
     assertTrue("Handler must call provided method.", methodCalled);
-    assertSame("Handler argument must be *exactly* the provided object.",
-        methodArgument, FIXTURE_ARGUMENT);
+    assertSame("Handler argument must be *exactly* the provided object.", methodArgument,
+        FIXTURE_ARGUMENT);
   }
 
   /** Checks that EventHandler's constructor disallows null methods. */
@@ -65,6 +64,16 @@
     }
   }
 
+  /** Checks that EventHandler's constructor disallows null callbacks. */
+  @Test public void rejectionOfNullCallbacks() {
+    try {
+      new EventHandler(null);
+      fail("EventHandler must immediately reject null methods.");
+    } catch (NullPointerException expected) {
+      // Hooray!
+    }
+  }
+
   /** Checks that EventHandler's constructor disallows null targets. */
   @Test public void rejectionOfNullTargets() throws NoSuchMethodException {
     Method method = getRecordingMethod();
@@ -117,7 +126,7 @@ private Method getErrorThrowingMethod() throws NoSuchMethodException {
    * Records the provided object in {@link #methodArgument} and sets
    * {@link #methodCalled}.
    *
-   * @param arg  argument to record.
+   * @param arg argument to record.
    */
   public void recordingMethod(Object arg) {
     if (methodCalled) {
