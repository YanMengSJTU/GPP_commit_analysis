diff --git a/otto/src/main/java/com/squareup/otto/AnnotatedHandlerFinder.java b/otto/src/main/java/com/squareup/otto/AnnotatedHandlerFinder.java
index 7d79b71..64d23a2 100644
--- a/otto/src/main/java/com/squareup/otto/AnnotatedHandlerFinder.java
+++ b/otto/src/main/java/com/squareup/otto/AnnotatedHandlerFinder.java
@@ -36,22 +36,22 @@
 final class AnnotatedHandlerFinder {
 
   /** Cache event bus producer methods for each class. */
-  private static final ConcurrentMap<Class<?>, Map<Class<?>, Method>> PRODUCERS_CACHE =
-    new ConcurrentHashMap<Class<?>, Map<Class<?>, Method>>();
+  private static final ConcurrentMap<Class<?>, Map<String, Method>> PRODUCERS_CACHE =
+          new ConcurrentHashMap<>();
 
   /** Cache event bus subscriber methods for each class. */
-  private static final ConcurrentMap<Class<?>, Map<Class<?>, Set<Method>>> SUBSCRIBERS_CACHE =
-    new ConcurrentHashMap<Class<?>, Map<Class<?>, Set<Method>>>();
+  private static final ConcurrentMap<Class<?>, Map<String, Set<Method>>> SUBSCRIBERS_CACHE =
+          new ConcurrentHashMap<>();
 
   private static void loadAnnotatedProducerMethods(Class<?> listenerClass,
-      Map<Class<?>, Method> producerMethods) {
-    Map<Class<?>, Set<Method>> subscriberMethods = new HashMap<Class<?>, Set<Method>>();
+                                                   Map<String, Method> producerMethods) {
+    Map<String, Set<Method>> subscriberMethods = new HashMap<>();
     loadAnnotatedMethods(listenerClass, producerMethods, subscriberMethods);
   }
 
   private static void loadAnnotatedSubscriberMethods(Class<?> listenerClass,
-      Map<Class<?>, Set<Method>> subscriberMethods) {
-    Map<Class<?>, Method> producerMethods = new HashMap<Class<?>, Method>();
+                                                     Map<String, Set<Method>> subscriberMethods) {
+    Map<String, Method> producerMethods = new HashMap<>();
     loadAnnotatedMethods(listenerClass, producerMethods, subscriberMethods);
   }
 
@@ -59,8 +59,7 @@ private static void loadAnnotatedSubscriberMethods(Class<?> listenerClass,
    * Load all methods annotated with {@link Produce} or {@link Subscribe} into their respective caches for the
    * specified class.
    */
-  private static void loadAnnotatedMethods(Class<?> listenerClass,
-      Map<Class<?>, Method> producerMethods, Map<Class<?>, Set<Method>> subscriberMethods) {
+  private static void loadAnnotatedMethods(Class<?> listenerClass, Map<String, Method> producerMethods, Map<String, Set<Method>> subscriberMethods) {
     for (Method method : listenerClass.getDeclaredMethods()) {
       // The compiler sometimes creates synthetic bridge methods as part of the
       // type erasure process. As of JDK8 these methods now include the same
@@ -87,10 +86,16 @@ private static void loadAnnotatedMethods(Class<?> listenerClass,
               + " but is not 'public'.");
         }
 
-        Set<Method> methods = subscriberMethods.get(eventType);
+        Subscribe annotation = method.getAnnotation(Subscribe.class);
+        String keyName = annotation.event();
+        if ("".equals(keyName)) {
+          keyName = eventType.getName();
+        }
+
+        Set<Method> methods = subscriberMethods.get(keyName);
         if (methods == null) {
           methods = new HashSet<Method>();
-          subscriberMethods.put(eventType, methods);
+          subscriberMethods.put(keyName, methods);
         }
         methods.add(method);
       } else if (method.isAnnotationPresent(Produce.class)) {
@@ -121,7 +126,13 @@ private static void loadAnnotatedMethods(Class<?> listenerClass,
         if (producerMethods.containsKey(eventType)) {
           throw new IllegalArgumentException("Producer for type " + eventType + " has already been registered.");
         }
-        producerMethods.put(eventType, method);
+
+        Produce annotation = method.getAnnotation(Produce.class);
+        String keyName = annotation.event();
+        if ("".equals(keyName)) {
+          keyName = eventType.getName();
+        }
+        producerMethods.put(keyName, method);
       }
     }
 
@@ -130,17 +141,17 @@ private static void loadAnnotatedMethods(Class<?> listenerClass,
   }
 
   /** This implementation finds all methods marked with a {@link Produce} annotation. */
-  static Map<Class<?>, EventProducer> findAllProducers(Object listener) {
+  static Map<String, EventProducer> findAllProducers(Object listener) {
     final Class<?> listenerClass = listener.getClass();
-    Map<Class<?>, EventProducer> handlersInMethod = new HashMap<Class<?>, EventProducer>();
+    Map<String, EventProducer> handlersInMethod = new HashMap<>();
 
-    Map<Class<?>, Method> methods = PRODUCERS_CACHE.get(listenerClass);
+    Map<String, Method> methods = PRODUCERS_CACHE.get(listenerClass);
     if (null == methods) {
-      methods = new HashMap<Class<?>, Method>();
+      methods = new HashMap<>();
       loadAnnotatedProducerMethods(listenerClass, methods);
     }
     if (!methods.isEmpty()) {
-      for (Map.Entry<Class<?>, Method> e : methods.entrySet()) {
+      for (Map.Entry<String, Method> e : methods.entrySet()) {
         EventProducer producer = new EventProducer(listener, e.getValue());
         handlersInMethod.put(e.getKey(), producer);
       }
@@ -150,17 +161,17 @@ private static void loadAnnotatedMethods(Class<?> listenerClass,
   }
 
   /** This implementation finds all methods marked with a {@link Subscribe} annotation. */
-  static Map<Class<?>, Set<EventHandler>> findAllSubscribers(Object listener) {
+  static Map<String, Set<EventHandler>> findAllSubscribers(Object listener) {
     Class<?> listenerClass = listener.getClass();
-    Map<Class<?>, Set<EventHandler>> handlersInMethod = new HashMap<Class<?>, Set<EventHandler>>();
+    Map<String, Set<EventHandler>> handlersInMethod = new HashMap<>();
 
-    Map<Class<?>, Set<Method>> methods = SUBSCRIBERS_CACHE.get(listenerClass);
+    Map<String, Set<Method>> methods = SUBSCRIBERS_CACHE.get(listenerClass);
     if (null == methods) {
-      methods = new HashMap<Class<?>, Set<Method>>();
+      methods = new HashMap<>();
       loadAnnotatedSubscriberMethods(listenerClass, methods);
     }
     if (!methods.isEmpty()) {
-      for (Map.Entry<Class<?>, Set<Method>> e : methods.entrySet()) {
+      for (Map.Entry<String, Set<Method>> e : methods.entrySet()) {
         Set<EventHandler> handlers = new HashSet<EventHandler>();
         for (Method m : e.getValue()) {
           handlers.add(new EventHandler(listener, m));
diff --git a/otto/src/main/java/com/squareup/otto/Bus.java b/otto/src/main/java/com/squareup/otto/Bus.java
index 0ab6620..3de4029 100644
--- a/otto/src/main/java/com/squareup/otto/Bus.java
+++ b/otto/src/main/java/com/squareup/otto/Bus.java
@@ -88,12 +88,12 @@
   public static final String DEFAULT_IDENTIFIER = "default";
 
   /** All registered event handlers, indexed by event type. */
-  private final ConcurrentMap<Class<?>, Set<EventHandler>> handlersByType =
-          new ConcurrentHashMap<Class<?>, Set<EventHandler>>();
+  private final ConcurrentMap<String, Set<EventHandler>> handlersByType =
+          new ConcurrentHashMap<>();
 
   /** All registered event producers, index by event type. */
-  private final ConcurrentMap<Class<?>, EventProducer> producersByType =
-          new ConcurrentHashMap<Class<?>, EventProducer>();
+  private final ConcurrentMap<String, EventProducer> producersByType =
+          new ConcurrentHashMap<>();
 
   /** Identifier used to differentiate the event bus instance. */
   private final String identifier;
@@ -187,8 +187,9 @@ public void register(Object object) {
     }
     enforcer.enforce(this);
 
-    Map<Class<?>, EventProducer> foundProducers = handlerFinder.findAllProducers(object);
-    for (Class<?> type : foundProducers.keySet()) {
+    // object has producer, so send the event to all handler
+    Map<String, EventProducer> foundProducers = handlerFinder.findAllProducers(object);
+    for (String type : foundProducers.keySet()) {
 
       final EventProducer producer = foundProducers.get(type);
       EventProducer previousProducer = producersByType.putIfAbsent(type, producer);
@@ -206,8 +207,9 @@ public void register(Object object) {
       }
     }
 
-    Map<Class<?>, Set<EventHandler>> foundHandlersMap = handlerFinder.findAllSubscribers(object);
-    for (Class<?> type : foundHandlersMap.keySet()) {
+    // find available handler from object
+    Map<String, Set<EventHandler>> foundHandlersMap = handlerFinder.findAllSubscribers(object);
+    for (String type : foundHandlersMap.keySet()) {
       Set<EventHandler> handlers = handlersByType.get(type);
       if (handlers == null) {
         //concurrent put if absent
@@ -223,8 +225,9 @@ public void register(Object object) {
       }
     }
 
-    for (Map.Entry<Class<?>, Set<EventHandler>> entry : foundHandlersMap.entrySet()) {
-      Class<?> type = entry.getKey();
+    // foundHandlersMap from new object, and dispatch event it subsribe
+    for (Map.Entry<String, Set<EventHandler>> entry : foundHandlersMap.entrySet()) {
+      String type = entry.getKey();
       EventProducer producer = producersByType.get(type);
       if (producer != null && producer.isValid()) {
         Set<EventHandler> foundHandlers = entry.getValue();
@@ -266,9 +269,9 @@ public void unregister(Object object) {
     }
     enforcer.enforce(this);
 
-    Map<Class<?>, EventProducer> producersInListener = handlerFinder.findAllProducers(object);
-    for (Map.Entry<Class<?>, EventProducer> entry : producersInListener.entrySet()) {
-      final Class<?> key = entry.getKey();
+    Map<String, EventProducer> producersInListener = handlerFinder.findAllProducers(object);
+    for (Map.Entry<String, EventProducer> entry : producersInListener.entrySet()) {
+      final String key = entry.getKey();
       EventProducer producer = getProducerForEventType(key);
       EventProducer value = entry.getValue();
 
@@ -280,8 +283,8 @@ public void unregister(Object object) {
       producersByType.remove(key).invalidate();
     }
 
-    Map<Class<?>, Set<EventHandler>> handlersInListener = handlerFinder.findAllSubscribers(object);
-    for (Map.Entry<Class<?>, Set<EventHandler>> entry : handlersInListener.entrySet()) {
+    Map<String, Set<EventHandler>> handlersInListener = handlerFinder.findAllSubscribers(object);
+    for (Map.Entry<String, Set<EventHandler>> entry : handlersInListener.entrySet()) {
       Set<EventHandler> currentHandlers = getHandlersForEventType(entry.getKey());
       Collection<EventHandler> eventMethodsInListener = entry.getValue();
 
@@ -320,7 +323,7 @@ public void post(Object event) {
 
     boolean dispatched = false;
     for (Class<?> eventType : dispatchTypes) {
-      Set<EventHandler> wrappers = getHandlersForEventType(eventType);
+      Set<EventHandler> wrappers = getHandlersForEventType(eventType.getName());
 
       if (wrappers != null && !wrappers.isEmpty()) {
         dispatched = true;
@@ -337,6 +340,39 @@ public void post(Object event) {
     dispatchQueuedEvents();
   }
 
+  /**
+   * Posts an event to all registered handlers.  This method will return successfully after the event has been posted to
+   * all handlers, and regardless of any exceptions thrown by handlers.
+   *
+   * <p>If no handlers have been subscribed for {@code event}'s class, and {@code event} is not already a
+   * {@link DeadEvent}, it will be wrapped in a DeadEvent and reposted.
+   *
+   * @param event event to post.
+   * @throws NullPointerException if the event is null.
+   */
+  public void post(String name, Object event) {
+    if (event == null) {
+      throw new NullPointerException("Event to post must not be null.");
+    }
+    enforcer.enforce(this);
+
+    boolean dispatched = false;
+    Set<EventHandler> wrappers = getHandlersForEventType(name);
+
+    if (wrappers != null && !wrappers.isEmpty()) {
+      dispatched = true;
+      for (EventHandler wrapper : wrappers) {
+        enqueueEvent(event, wrapper);
+      }
+    }
+
+    if (!dispatched && !(event instanceof DeadEvent)) {
+      post(new DeadEvent(this, event));
+    }
+
+    dispatchQueuedEvents();
+  }
+
   /**
    * Queue the {@code event} for dispatch during {@link #dispatchQueuedEvents()}. Events are queued in-order of
    * occurrence so they can be dispatched in the same order.
@@ -396,7 +432,7 @@ protected void dispatch(Object event, EventHandler wrapper) {
    * @param type type of producer to retrieve.
    * @return currently registered producer, or {@code null}.
    */
-  EventProducer getProducerForEventType(Class<?> type) {
+  EventProducer getProducerForEventType(String type) {
     return producersByType.get(type);
   }
 
@@ -407,7 +443,7 @@ EventProducer getProducerForEventType(Class<?> type) {
    * @param type type of handlers to retrieve.
    * @return currently registered handlers, or {@code null}.
    */
-  Set<EventHandler> getHandlersForEventType(Class<?> type) {
+  Set<EventHandler> getHandlersForEventType(String type) {
     return handlersByType.get(type);
   }
 
diff --git a/otto/src/main/java/com/squareup/otto/HandlerFinder.java b/otto/src/main/java/com/squareup/otto/HandlerFinder.java
index ff61a2c..7a113d7 100644
--- a/otto/src/main/java/com/squareup/otto/HandlerFinder.java
+++ b/otto/src/main/java/com/squareup/otto/HandlerFinder.java
@@ -22,19 +22,19 @@
 /** Finds producer and subscriber methods. */
 interface HandlerFinder {
 
-  Map<Class<?>, EventProducer> findAllProducers(Object listener);
+  Map<String, EventProducer> findAllProducers(Object listener);
 
-  Map<Class<?>, Set<EventHandler>> findAllSubscribers(Object listener);
+  Map<String, Set<EventHandler>> findAllSubscribers(Object listener);
 
 
   HandlerFinder ANNOTATED = new HandlerFinder() {
     @Override
-    public Map<Class<?>, EventProducer> findAllProducers(Object listener) {
+    public Map<String, EventProducer> findAllProducers(Object listener) {
       return AnnotatedHandlerFinder.findAllProducers(listener);
     }
 
     @Override
-    public Map<Class<?>, Set<EventHandler>> findAllSubscribers(Object listener) {
+    public Map<String, Set<EventHandler>> findAllSubscribers(Object listener) {
       return AnnotatedHandlerFinder.findAllSubscribers(listener);
     }
   };
diff --git a/otto/src/main/java/com/squareup/otto/Produce.java b/otto/src/main/java/com/squareup/otto/Produce.java
index 1497a39..72ba9c5 100644
--- a/otto/src/main/java/com/squareup/otto/Produce.java
+++ b/otto/src/main/java/com/squareup/otto/Produce.java
@@ -32,4 +32,11 @@
 @Retention(RetentionPolicy.RUNTIME)
 @Target(ElementType.METHOD)
 public @interface Produce {
+
+    /**
+     * Default event name.
+     * <p>
+     * If its empty, the class type will be used instead.
+     */
+    String event() default "";
 }
diff --git a/otto/src/main/java/com/squareup/otto/Subscribe.java b/otto/src/main/java/com/squareup/otto/Subscribe.java
index f0217e3..9d64508 100644
--- a/otto/src/main/java/com/squareup/otto/Subscribe.java
+++ b/otto/src/main/java/com/squareup/otto/Subscribe.java
@@ -34,4 +34,11 @@
 @Retention(RetentionPolicy.RUNTIME)
 @Target(ElementType.METHOD)
 public @interface Subscribe {
+
+    /**
+     * Default event name.
+     * <p>
+     * If its empty, the class type will be used instead.
+     */
+    String event() default "";
 }
