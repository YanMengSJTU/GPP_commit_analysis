diff --git a/otto/src/main/java/com/squareup/otto/AnnotatedHandlerFinder.java b/otto/src/main/java/com/squareup/otto/AnnotatedHandlerFinder.java
index 7d79b71..17ab0fd 100644
--- a/otto/src/main/java/com/squareup/otto/AnnotatedHandlerFinder.java
+++ b/otto/src/main/java/com/squareup/otto/AnnotatedHandlerFinder.java
@@ -32,6 +32,7 @@
  * @author Cliff Biffle
  * @author Louis Wasserman
  * @author Jake Wharton
+ * @author Sergey Solovyev
  */
 final class AnnotatedHandlerFinder {
 
@@ -163,7 +164,7 @@ private static void loadAnnotatedMethods(Class<?> listenerClass,
       for (Map.Entry<Class<?>, Set<Method>> e : methods.entrySet()) {
         Set<EventHandler> handlers = new HashSet<EventHandler>();
         for (Method m : e.getValue()) {
-          handlers.add(new EventHandler(listener, m));
+          handlers.add(new ReflectiveEventHandler(listener, m));
         }
         handlersInMethod.put(e.getKey(), handlers);
       }
diff --git a/otto/src/main/java/com/squareup/otto/BaseEventHandler.java b/otto/src/main/java/com/squareup/otto/BaseEventHandler.java
new file mode 100644
index 0000000..690ed51
--- /dev/null
+++ b/otto/src/main/java/com/squareup/otto/BaseEventHandler.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2016 Sergey Solovyev
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.squareup.otto;
+
+/**
+ * Partial implementation of {@link EventHandler} containing common fields
+ *
+ * @author Sergey Solovyev
+ */
+public abstract class BaseEventHandler implements EventHandler {
+
+  /**
+   * Should this handler receive events?
+   */
+  private boolean valid = true;
+
+  @Override
+  public boolean isValid() {
+    return valid;
+  }
+
+  @Override
+  public void invalidate() {
+    valid = false;
+  }
+}
diff --git a/otto/src/main/java/com/squareup/otto/Bus.java b/otto/src/main/java/com/squareup/otto/Bus.java
index 0ab6620..3e89002 100644
--- a/otto/src/main/java/com/squareup/otto/Bus.java
+++ b/otto/src/main/java/com/squareup/otto/Bus.java
@@ -83,6 +83,7 @@
  *
  * @author Cliff Biffle
  * @author Jake Wharton
+ * @author Sergey Solovyev
  */
 public class Bus {
   public static final String DEFAULT_IDENTIFIER = "default";
@@ -124,6 +125,15 @@ public Bus() {
     this(DEFAULT_IDENTIFIER);
   }
 
+  /**
+   * Creates a new Bus named "default" with the given {@code handlerFinder} that enforces actions on the main thread.
+   *
+   * @param handlerFinder Used to discover event handlers and producers when registering/unregistering an object.
+   */
+  public Bus(HandlerFinder handlerFinder) {
+    this(ThreadEnforcer.MAIN, handlerFinder);
+  }
+
   /**
    * Creates a new Bus with the given {@code identifier} that enforces actions on the main thread.
    *
@@ -133,6 +143,16 @@ public Bus(String identifier) {
     this(ThreadEnforcer.MAIN, identifier);
   }
 
+  /**
+   * Creates a new Bus with the given {@code identifier} and {@code handlerFinder} that enforces actions on the main thread.
+   *
+   * @param identifier a brief name for this bus, for debugging purposes.  Should be a valid Java identifier.
+   * @param handlerFinder Used to discover event handlers and producers when registering/unregistering an object.
+   */
+  public Bus(String identifier, HandlerFinder handlerFinder) {
+    this(ThreadEnforcer.MAIN, identifier, handlerFinder);
+  }
+
   /**
    * Creates a new Bus named "default" with the given {@code enforcer} for actions.
    *
@@ -142,6 +162,17 @@ public Bus(ThreadEnforcer enforcer) {
     this(enforcer, DEFAULT_IDENTIFIER);
   }
 
+  /**
+   * Creates a new Bus named "default" with the given {@code enforcer} for actions and {@code handlerFinder} for
+   * discovering subscribers/producers.
+   *
+   * @param enforcer Thread enforcer for register, unregister, and post actions.
+   * @param handlerFinder Used to discover event handlers and producers when registering/unregistering an object.
+   */
+  public Bus(ThreadEnforcer enforcer, HandlerFinder handlerFinder) {
+    this(enforcer, DEFAULT_IDENTIFIER, handlerFinder);
+  }
+
   /**
    * Creates a new Bus with the given {@code enforcer} for actions and the given {@code identifier}.
    *
@@ -153,13 +184,13 @@ public Bus(ThreadEnforcer enforcer, String identifier) {
   }
 
   /**
-   * Test constructor which allows replacing the default {@code HandlerFinder}.
+   * Creates a new Bus with the given {@code enforcer} for actions, {@code identifier} and {@code handlerFinder}.
    *
    * @param enforcer Thread enforcer for register, unregister, and post actions.
    * @param identifier A brief name for this bus, for debugging purposes.  Should be a valid Java identifier.
    * @param handlerFinder Used to discover event handlers and producers when registering/unregistering an object.
    */
-  Bus(ThreadEnforcer enforcer, String identifier, HandlerFinder handlerFinder) {
+  public Bus(ThreadEnforcer enforcer, String identifier, HandlerFinder handlerFinder) {
     this.enforcer =  enforcer;
     this.identifier = identifier;
     this.handlerFinder = handlerFinder;
@@ -381,12 +412,7 @@ protected void dispatchQueuedEvents() {
    * @param wrapper wrapper that will call the handler.
    */
   protected void dispatch(Object event, EventHandler wrapper) {
-    try {
-      wrapper.handleEvent(event);
-    } catch (InvocationTargetException e) {
-      throwRuntimeException(
-          "Could not dispatch event: " + event.getClass() + " to handler " + wrapper, e);
-    }
+    wrapper.handleEvent(event);
   }
 
   /**
@@ -454,7 +480,7 @@ EventProducer getProducerForEventType(Class<?> type) {
    * InvocationTargetException}. If the specified {@link InvocationTargetException} does not have a
    * cause, neither will the {@link RuntimeException}.
    */
-  private static void throwRuntimeException(String msg, InvocationTargetException e) {
+  static void throwRuntimeException(String msg, InvocationTargetException e) {
     Throwable cause = e.getCause();
     if (cause != null) {
       throw new RuntimeException(msg + ": " + cause.getMessage(), cause);
diff --git a/otto/src/main/java/com/squareup/otto/EventHandler.java b/otto/src/main/java/com/squareup/otto/EventHandler.java
index 843a31b..aa68965 100644
--- a/otto/src/main/java/com/squareup/otto/EventHandler.java
+++ b/otto/src/main/java/com/squareup/otto/EventHandler.java
@@ -1,6 +1,5 @@
 /*
- * Copyright (C) 2012 Square, Inc.
- * Copyright (C) 2007 The Guava Authors
+ * Copyright (C) 2016 Sergey Solovyev
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -17,110 +16,31 @@
 
 package com.squareup.otto;
 
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-
 /**
- * Wraps a single-argument 'handler' method on a specific object.
- *
- * <p>This class only verifies the suitability of the method and event type if something fails.  Callers are expected t
- * verify their uses of this class.
- *
- * <p>Two EventHandlers are equivalent when they refer to the same method on the same object (not class).   This
- * property is used to ensure that no handler method is registered more than once.
+ * Encapsulates information about event receiver, it's up to {@link HandlerFinder} to
+ * decide what implementation to use
  *
- * @author Cliff Biffle
+ * @author Sergey Solovyev
  */
-class EventHandler {
-
-  /** Object sporting the handler method. */
-  private final Object target;
-  /** Handler method. */
-  private final Method method;
-  /** Object hash code. */
-  private final int hashCode;
-  /** Should this handler receive events? */
-  private boolean valid = true;
-
-  EventHandler(Object target, Method method) {
-    if (target == null) {
-      throw new NullPointerException("EventHandler target cannot be null.");
-    }
-    if (method == null) {
-      throw new NullPointerException("EventHandler method cannot be null.");
-    }
-
-    this.target = target;
-    this.method = method;
-    method.setAccessible(true);
-
-    // Compute hash code eagerly since we know it will be used frequently and we cannot estimate the runtime of the
-    // target's hashCode call.
-    final int prime = 31;
-    hashCode = (prime + method.hashCode()) * prime + target.hashCode();
-  }
-
-  public boolean isValid() {
-    return valid;
-  }
+interface EventHandler {
+  /**
+   * @return current state of this {@link EventHandler}
+   * @see {@link #invalidate()}
+   */
+  boolean isValid();
 
   /**
    * If invalidated, will subsequently refuse to handle events.
-   *
+   * <p/>
    * Should be called when the wrapped object is unregistered from the Bus.
    */
-  public void invalidate() {
-    valid = false;
-  }
+  void invalidate();
 
   /**
-   * Invokes the wrapped handler method to handle {@code event}.
+   * Delivers event to a subscriber
    *
-   * @param event  event to handle
-   * @throws java.lang.IllegalStateException  if previously invalidated.
-   * @throws java.lang.reflect.InvocationTargetException  if the wrapped method throws any {@link Throwable} that is not
-   *     an {@link Error} ({@code Error}s are propagated as-is).
+   * @param event event to be consumed
+   * @throws RuntimeException thrown if error occurs while subscriber is processing the event
    */
-  public void handleEvent(Object event) throws InvocationTargetException {
-    if (!valid) {
-      throw new IllegalStateException(toString() + " has been invalidated and can no longer handle events.");
-    }
-    try {
-      method.invoke(target, event);
-    } catch (IllegalAccessException e) {
-      throw new AssertionError(e);
-    } catch (InvocationTargetException e) {
-      if (e.getCause() instanceof Error) {
-        throw (Error) e.getCause();
-      }
-      throw e;
-    }
-  }
-
-  @Override public String toString() {
-    return "[EventHandler " + method + "]";
-  }
-
-  @Override public int hashCode() {
-    return hashCode;
-  }
-
-  @Override public boolean equals(Object obj) {
-    if (this == obj) {
-      return true;
-    }
-
-    if (obj == null) {
-      return false;
-    }
-
-    if (getClass() != obj.getClass()) {
-      return false;
-    }
-
-    final EventHandler other = (EventHandler) obj;
-
-    return method.equals(other.method) && target == other.target;
-  }
-
+  void handleEvent(Object event);
 }
diff --git a/otto/src/main/java/com/squareup/otto/ReflectiveEventHandler.java b/otto/src/main/java/com/squareup/otto/ReflectiveEventHandler.java
new file mode 100644
index 0000000..7f66a5c
--- /dev/null
+++ b/otto/src/main/java/com/squareup/otto/ReflectiveEventHandler.java
@@ -0,0 +1,111 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ * Copyright (C) 2007 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.squareup.otto;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
+/**
+ * Wraps a single-argument 'handler' method on a specific object.
+ *
+ * <p>This class only verifies the suitability of the method and event type if something fails.  Callers are expected t
+ * verify their uses of this class.
+ *
+ * <p>Two EventHandlers are equivalent when they refer to the same method on the same object (not class).   This
+ * property is used to ensure that no handler method is registered more than once.
+ *
+ * @author Cliff Biffle
+ * @author Sergey Solovyev
+ */
+class ReflectiveEventHandler extends BaseEventHandler {
+
+  /** Object sporting the handler method. */
+  private final Object target;
+  /** Handler method. */
+  private final Method method;
+  /** Object hash code. */
+  private final int hashCode;
+
+  ReflectiveEventHandler(Object target, Method method) {
+    if (target == null) {
+      throw new NullPointerException("EventHandler target cannot be null.");
+    }
+    if (method == null) {
+      throw new NullPointerException("EventHandler method cannot be null.");
+    }
+
+    this.target = target;
+    this.method = method;
+    method.setAccessible(true);
+
+    // Compute hash code eagerly since we know it will be used frequently and we cannot estimate the runtime of the
+    // target's hashCode call.
+    final int prime = 31;
+    hashCode = (prime + method.hashCode()) * prime + target.hashCode();
+  }
+
+  /**
+   * Invokes the wrapped handler method to handle {@code event}.
+   *
+   * @param event  event to handle
+   * @throws java.lang.IllegalStateException  if previously invalidated.
+   */
+  @Override
+  public void handleEvent(Object event) {
+    if (!isValid()) {
+      throw new IllegalStateException(toString() + " has been invalidated and can no longer handle events.");
+    }
+    try {
+      method.invoke(target, event);
+    } catch (IllegalAccessException e) {
+      throw new AssertionError(e);
+    } catch (InvocationTargetException e) {
+      if (e.getCause() instanceof Error) {
+        throw (Error) e.getCause();
+      }
+      Bus.throwRuntimeException("Could not dispatch event: " + event.getClass() + " to handler " + this, e);
+    }
+  }
+
+  @Override public String toString() {
+    return "[EventHandler " + method + "]";
+  }
+
+  @Override public int hashCode() {
+    return hashCode;
+  }
+
+  @Override public boolean equals(Object obj) {
+    if (this == obj) {
+      return true;
+    }
+
+    if (obj == null) {
+      return false;
+    }
+
+    if (getClass() != obj.getClass()) {
+      return false;
+    }
+
+    final ReflectiveEventHandler other = (ReflectiveEventHandler) obj;
+
+    return method.equals(other.method) && target == other.target;
+  }
+
+}
diff --git a/otto/src/test/java/com/squareup/otto/EventHandlerTest.java b/otto/src/test/java/com/squareup/otto/ReflectiveEventHandlerTest.java
similarity index 92%
rename from otto/src/test/java/com/squareup/otto/EventHandlerTest.java
rename to otto/src/test/java/com/squareup/otto/ReflectiveEventHandlerTest.java
index 98fd510..74e7ef1 100644
--- a/otto/src/test/java/com/squareup/otto/EventHandlerTest.java
+++ b/otto/src/test/java/com/squareup/otto/ReflectiveEventHandlerTest.java
@@ -26,7 +26,7 @@
 import static junit.framework.Assert.assertTrue;
 import static junit.framework.Assert.fail;
 
-public class EventHandlerTest {
+public class ReflectiveEventHandlerTest {
 
   private static final Object FIXTURE_ARGUMENT = new Object();
 
@@ -46,7 +46,7 @@
   @Test public void basicMethodCall() throws Exception {
     Method method = getRecordingMethod();
 
-    EventHandler handler = new EventHandler(this, method);
+    EventHandler handler = new ReflectiveEventHandler(this, method);
 
     handler.handleEvent(FIXTURE_ARGUMENT);
 
@@ -58,7 +58,7 @@
   /** Checks that EventHandler's constructor disallows null methods. */
   @Test public void rejectionOfNullMethods() {
     try {
-      new EventHandler(this, null);
+      new ReflectiveEventHandler(this, null);
       fail("EventHandler must immediately reject null methods.");
     } catch (NullPointerException expected) {
       // Hooray!
@@ -69,7 +69,7 @@
   @Test public void rejectionOfNullTargets() throws NoSuchMethodException {
     Method method = getRecordingMethod();
     try {
-      new EventHandler(null, method);
+      new ReflectiveEventHandler(null, method);
       fail("EventHandler must immediately reject null targets.");
     } catch (NullPointerException expected) {
       // Huzzah!
@@ -78,12 +78,12 @@
 
   @Test public void exceptionWrapping() throws NoSuchMethodException {
     Method method = getExceptionThrowingMethod();
-    EventHandler handler = new EventHandler(this, method);
+    EventHandler handler = new ReflectiveEventHandler(this, method);
 
     try {
       handler.handleEvent(new Object());
       fail("Handlers whose methods throw must throw InvocationTargetException");
-    } catch (InvocationTargetException e) {
+    } catch (RuntimeException e) {
       assertTrue("Expected exception must be wrapped.",
           e.getCause() instanceof IntentionalException);
     }
@@ -91,7 +91,7 @@
 
   @Test public void errorPassthrough() throws InvocationTargetException, NoSuchMethodException {
     Method method = getErrorThrowingMethod();
-    EventHandler handler = new EventHandler(this, method);
+    EventHandler handler = new ReflectiveEventHandler(this, method);
 
     try {
       handler.handleEvent(new Object());
