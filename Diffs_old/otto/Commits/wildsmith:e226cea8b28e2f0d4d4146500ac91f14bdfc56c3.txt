diff --git a/otto/src/main/java/com/squareup/otto/AnnotatedHandlerFinder.java b/otto/src/main/java/com/squareup/otto/AnnotatedHandlerFinder.java
index 7d79b71..3067937 100644
--- a/otto/src/main/java/com/squareup/otto/AnnotatedHandlerFinder.java
+++ b/otto/src/main/java/com/squareup/otto/AnnotatedHandlerFinder.java
@@ -49,18 +49,54 @@ private static void loadAnnotatedProducerMethods(Class<?> listenerClass,
     loadAnnotatedMethods(listenerClass, producerMethods, subscriberMethods);
   }
 
+  private static void loadAnnotatedProducerMethods(Class<?> fakeListenerClass,
+      Class<?> listenerClass, Map<Class<?>, Method> producerMethods) {
+    Map<Class<?>, Set<Method>> subscriberMethods = new HashMap<Class<?>, Set<Method>>();
+    loadAnnotatedMethods(fakeListenerClass, listenerClass, producerMethods, subscriberMethods);
+  }
+
   private static void loadAnnotatedSubscriberMethods(Class<?> listenerClass,
       Map<Class<?>, Set<Method>> subscriberMethods) {
     Map<Class<?>, Method> producerMethods = new HashMap<Class<?>, Method>();
     loadAnnotatedMethods(listenerClass, producerMethods, subscriberMethods);
   }
 
+  private static void loadAnnotatedSubscriberMethods(Class<?> fakeListenerClass,
+      Class<?> listenerClass, Map<Class<?>, Set<Method>> subscriberMethods) {
+    Map<Class<?>, Method> producerMethods = new HashMap<Class<?>, Method>();
+    loadAnnotatedMethods(fakeListenerClass, listenerClass, producerMethods, subscriberMethods);
+  }
+
   /**
    * Load all methods annotated with {@link Produce} or {@link Subscribe} into their respective caches for the
    * specified class.
    */
   private static void loadAnnotatedMethods(Class<?> listenerClass,
       Map<Class<?>, Method> producerMethods, Map<Class<?>, Set<Method>> subscriberMethods) {
+    loadAnnotatedMethodsForListenerClass(listenerClass, producerMethods, subscriberMethods);
+
+    PRODUCERS_CACHE.put(listenerClass, producerMethods);
+    SUBSCRIBERS_CACHE.put(listenerClass, subscriberMethods);
+  }
+
+  /**
+   * Load all methods annotated with {@link Produce} or {@link Subscribe} into their respective caches for the
+   * specified class.
+   */
+  private static void loadAnnotatedMethods(Class<?> fakeListenerClass, Class<?> listenerClass,
+      Map<Class<?>, Method> producerMethods, Map<Class<?>, Set<Method>> subscriberMethods) {
+    loadAnnotatedMethodsForListenerClass(listenerClass, producerMethods, subscriberMethods);
+
+    PRODUCERS_CACHE.put(fakeListenerClass, producerMethods);
+    SUBSCRIBERS_CACHE.put(fakeListenerClass, subscriberMethods);
+  }
+
+  /**
+   * Load all methods annotated with {@link Produce} or {@link Subscribe} into their respective caches for the
+   * specified class.
+   */
+  private static void loadAnnotatedMethodsForListenerClass(Class<?> listenerClass, Map<Class<?>, Method> producerMethods,
+      Map<Class<?>, Set<Method>> subscriberMethods) {
     for (Method method : listenerClass.getDeclaredMethods()) {
       // The compiler sometimes creates synthetic bridge methods as part of the
       // type erasure process. As of JDK8 these methods now include the same
@@ -124,9 +160,6 @@ private static void loadAnnotatedMethods(Class<?> listenerClass,
         producerMethods.put(eventType, method);
       }
     }
-
-    PRODUCERS_CACHE.put(listenerClass, producerMethods);
-    SUBSCRIBERS_CACHE.put(listenerClass, subscriberMethods);
   }
 
   /** This implementation finds all methods marked with a {@link Produce} annotation. */
@@ -149,6 +182,26 @@ private static void loadAnnotatedMethods(Class<?> listenerClass,
     return handlersInMethod;
   }
 
+  /** This implementation finds all methods marked with a {@link Produce} annotation. */
+  static Map<Class<?>, EventProducer> findAllProducers(Object listener, Class<?> listenerClass) {
+    Class<?> fakeListenerClass = listener.getClass();
+    Map<Class<?>, EventProducer> handlersInMethod = new HashMap<Class<?>, EventProducer>();
+
+    Map<Class<?>, Method> methods = PRODUCERS_CACHE.get(fakeListenerClass);
+    if (null == methods) {
+      methods = new HashMap<Class<?>, Method>();
+      loadAnnotatedProducerMethods(fakeListenerClass, listenerClass, methods);
+    }
+    if (!methods.isEmpty()) {
+      for (Map.Entry<Class<?>, Method> e : methods.entrySet()) {
+        EventProducer producer = new EventProducer(listener, e.getValue());
+        handlersInMethod.put(e.getKey(), producer);
+      }
+    }
+
+    return handlersInMethod;
+  }
+
   /** This implementation finds all methods marked with a {@link Subscribe} annotation. */
   static Map<Class<?>, Set<EventHandler>> findAllSubscribers(Object listener) {
     Class<?> listenerClass = listener.getClass();
@@ -172,6 +225,28 @@ private static void loadAnnotatedMethods(Class<?> listenerClass,
     return handlersInMethod;
   }
 
+  static Map<Class<?>, Set<EventHandler>> findAllSubscribers(Object listener, Class<?> listenerClass) {
+    Class<?> fakeListenerClass = listener.getClass();
+    Map<Class<?>, Set<EventHandler>> handlersInMethod = new HashMap<Class<?>, Set<EventHandler>>();
+
+    Map<Class<?>, Set<Method>> methods = SUBSCRIBERS_CACHE.get(fakeListenerClass);
+    if (null == methods) {
+      methods = new HashMap<Class<?>, Set<Method>>();
+      loadAnnotatedSubscriberMethods(fakeListenerClass, listenerClass, methods);
+    }
+    if (!methods.isEmpty()) {
+      for (Map.Entry<Class<?>, Set<Method>> e : methods.entrySet()) {
+        Set<EventHandler> handlers = new HashSet<EventHandler>();
+        for (Method m : e.getValue()) {
+          handlers.add(new EventHandler(listener, m));
+        }
+        handlersInMethod.put(e.getKey(), handlers);
+      }
+    }
+
+    return handlersInMethod;
+  }
+
   private AnnotatedHandlerFinder() {
     // No instances.
   }
diff --git a/otto/src/main/java/com/squareup/otto/Bus.java b/otto/src/main/java/com/squareup/otto/Bus.java
index 0ab6620..f891f1f 100644
--- a/otto/src/main/java/com/squareup/otto/Bus.java
+++ b/otto/src/main/java/com/squareup/otto/Bus.java
@@ -187,7 +187,33 @@ public void register(Object object) {
     }
     enforcer.enforce(this);
 
-    Map<Class<?>, EventProducer> foundProducers = handlerFinder.findAllProducers(object);
+    register(handlerFinder.findAllProducers(object), handlerFinder.findAllSubscribers(object));
+  }
+
+  /**
+   * Registers all handler methods on {@code object} to receive events and producer methods to provide events.
+   * <p>
+   * If any subscribers are registering for types which already have a producer they will be called immediately
+   * with the result of calling that producer.
+   * <p>
+   * If any producers are registering for types which already have subscribers, each subscriber will be called with
+   * the value from the result of calling the producer.
+   *
+   * @param object object whose handler methods should be registered.
+   * @throws NullPointerException if the object is null.
+   */
+  public void register(Object object, Class<?> listenerClass) {
+    if (object == null) {
+      throw new NullPointerException("Object to register must not be null.");
+    }
+    enforcer.enforce(this);
+
+    register(handlerFinder.findAllProducers(object, listenerClass),
+        handlerFinder.findAllSubscribers(object, listenerClass));
+  }
+
+  private void register(Map<Class<?>, EventProducer> foundProducers,
+      Map<Class<?>, Set<EventHandler>> foundHandlersMap) {
     for (Class<?> type : foundProducers.keySet()) {
 
       final EventProducer producer = foundProducers.get(type);
@@ -206,7 +232,6 @@ public void register(Object object) {
       }
     }
 
-    Map<Class<?>, Set<EventHandler>> foundHandlersMap = handlerFinder.findAllSubscribers(object);
     for (Class<?> type : foundHandlersMap.keySet()) {
       Set<EventHandler> handlers = handlersByType.get(type);
       if (handlers == null) {
@@ -266,7 +291,28 @@ public void unregister(Object object) {
     }
     enforcer.enforce(this);
 
-    Map<Class<?>, EventProducer> producersInListener = handlerFinder.findAllProducers(object);
+    unregister(object, handlerFinder.findAllProducers(object), handlerFinder.findAllSubscribers(object));
+  }
+
+  /**
+   * Unregisters all producer and handler methods on a registered {@code object}.
+   *
+   * @param object object whose producer and handler methods should be unregistered.
+   * @throws IllegalArgumentException if the object was not previously registered.
+   * @throws NullPointerException if the object is null.
+   */
+  public void unregister(Object object, Class<?> listenerClass) {
+    if (object == null) {
+      throw new NullPointerException("Object to unregister must not be null.");
+    }
+    enforcer.enforce(this);
+
+    unregister(object, handlerFinder.findAllProducers(object, listenerClass),
+        handlerFinder.findAllSubscribers(object, listenerClass));
+  }
+
+  private void unregister(Object object, Map<Class<?>, EventProducer> producersInListener,
+      Map<Class<?>, Set<EventHandler>> handlersInListener) {
     for (Map.Entry<Class<?>, EventProducer> entry : producersInListener.entrySet()) {
       final Class<?> key = entry.getKey();
       EventProducer producer = getProducerForEventType(key);
@@ -280,7 +326,6 @@ public void unregister(Object object) {
       producersByType.remove(key).invalidate();
     }
 
-    Map<Class<?>, Set<EventHandler>> handlersInListener = handlerFinder.findAllSubscribers(object);
     for (Map.Entry<Class<?>, Set<EventHandler>> entry : handlersInListener.entrySet()) {
       Set<EventHandler> currentHandlers = getHandlersForEventType(entry.getKey());
       Collection<EventHandler> eventMethodsInListener = entry.getValue();
diff --git a/otto/src/main/java/com/squareup/otto/HandlerFinder.java b/otto/src/main/java/com/squareup/otto/HandlerFinder.java
index ff61a2c..e222870 100644
--- a/otto/src/main/java/com/squareup/otto/HandlerFinder.java
+++ b/otto/src/main/java/com/squareup/otto/HandlerFinder.java
@@ -24,18 +24,32 @@
 
   Map<Class<?>, EventProducer> findAllProducers(Object listener);
 
+  Map<Class<?>, EventProducer> findAllProducers(Object listener, Class<?> targetClass);
+
   Map<Class<?>, Set<EventHandler>> findAllSubscribers(Object listener);
 
+  Map<Class<?>, Set<EventHandler>> findAllSubscribers(Object listener, Class<?> targetClass);
 
   HandlerFinder ANNOTATED = new HandlerFinder() {
+
     @Override
     public Map<Class<?>, EventProducer> findAllProducers(Object listener) {
       return AnnotatedHandlerFinder.findAllProducers(listener);
     }
 
+    @Override
+    public Map<Class<?>, EventProducer> findAllProducers(Object listener, Class<?> targetClass) {
+      return AnnotatedHandlerFinder.findAllProducers(listener, targetClass);
+    }
+
     @Override
     public Map<Class<?>, Set<EventHandler>> findAllSubscribers(Object listener) {
       return AnnotatedHandlerFinder.findAllSubscribers(listener);
     }
+
+    @Override
+    public Map<Class<?>, Set<EventHandler>> findAllSubscribers(Object listener, Class<?> targetClass) {
+      return AnnotatedHandlerFinder.findAllSubscribers(listener, targetClass);
+    }
   };
 }
