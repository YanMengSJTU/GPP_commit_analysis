diff --git a/library/src/main/java/com/squareup/otto/AnnotatedHandlerFinder.java b/library/src/main/java/com/squareup/otto/AnnotatedHandlerFinder.java
index 861113b..a38761a 100644
--- a/library/src/main/java/com/squareup/otto/AnnotatedHandlerFinder.java
+++ b/library/src/main/java/com/squareup/otto/AnnotatedHandlerFinder.java
@@ -32,7 +32,6 @@
  * @author Jake Wharton
  */
 final class AnnotatedHandlerFinder {
-
   /** Cache event bus producer methods for each class. */
   private static final Map<Class<?>, Map<Class<?>, Method>> PRODUCERS_CACHE =
       new HashMap<Class<?>, Map<Class<?>, Method>>();
@@ -41,6 +40,27 @@
   private static final Map<Class<?>, Map<Class<?>, Set<Method>>> SUBSCRIBERS_CACHE =
       new HashMap<Class<?>, Map<Class<?>, Set<Method>>>();
 
+  /**
+   * Returns the <code>clazz</code> methods.
+   * 
+   * The system property {@link Bus#TRAVERSE_CLASS_HIERARCHY} changes the behavior of this
+   * method: if set to true, the method will include the superclasses of <code>clazz</code>
+   * in the returned methods, if they're not overriden without the {@link Subscribe}
+   * annotation. Otherwise, it'll only return the methods in the immediate class.
+   *  
+   * @param clazz the class to be inspected
+   * @return the methods of the class. Will include methods in the superclasses if 
+   * {@link Bus#TRAVERSE_CLASS_HIERARCHY} is set to true.
+   */
+  private static final Method[] getListenerMethods(Class<?> clazz) {
+    boolean traverseClassHierarchy = Boolean.parseBoolean(System.getProperty(Bus.TRAVERSE_CLASS_HIERARCHY));
+    if (traverseClassHierarchy) {
+      return clazz.getMethods();
+    } else {
+      return clazz.getDeclaredMethods();
+    }
+  }
+
   /**
    * Load all methods annotated with {@link Produce} or {@link Subscribe} into their respective caches for the
    * specified class.
@@ -49,7 +69,7 @@ private static void loadAnnotatedMethods(Class<?> listenerClass) {
     Map<Class<?>, Set<Method>> subscriberMethods = new HashMap<Class<?>, Set<Method>>();
     Map<Class<?>, Method> producerMethods = new HashMap<Class<?>, Method>();
 
-    for (Method method : listenerClass.getDeclaredMethods()) {
+    for (Method method : getListenerMethods(listenerClass)) {
       if (method.isAnnotationPresent(Subscribe.class)) {
         Class<?>[] parameterTypes = method.getParameterTypes();
         if (parameterTypes.length != 1) {
diff --git a/library/src/main/java/com/squareup/otto/Bus.java b/library/src/main/java/com/squareup/otto/Bus.java
index 4b477b7..19eb225 100644
--- a/library/src/main/java/com/squareup/otto/Bus.java
+++ b/library/src/main/java/com/squareup/otto/Bus.java
@@ -87,6 +87,14 @@
  */
 public class Bus {
   public static final String DEFAULT_IDENTIFIER = "default";
+  
+  /**
+   * The name of a system property. If set to true (with {@link System#setProperty(String, String)},
+   * it changes the default behavior of the discovery of producers and subscribers. The discovery
+   * will include methods in superclasses, if they're not overriden without the {@link Subscribe}
+   * annotation.
+   */
+  public static final String TRAVERSE_CLASS_HIERARCHY = "com.squareup.otto.traverse_hierarchy";
 
   /** All registered event handlers, indexed by event type. */
   private final ConcurrentMap<Class<?>, Set<EventHandler>> handlersByType =
diff --git a/library/src/test/java/com/squareup/otto/outside/AnnotatedHandlerFinderTest.java b/library/src/test/java/com/squareup/otto/outside/AnnotatedHandlerFinderTest.java
index 10a66d2..d782567 100644
--- a/library/src/test/java/com/squareup/otto/outside/AnnotatedHandlerFinderTest.java
+++ b/library/src/test/java/com/squareup/otto/outside/AnnotatedHandlerFinderTest.java
@@ -137,6 +137,124 @@ public void overriddenAndAnnotatedInSubclass(Object o) {
     }
   }
 
+  public static class AnnotatedInSuperclassWithHierarchyLoadingTest 
+  extends AbstractEventBusTest<AnnotatedInSuperclassWithHierarchyLoadingTest.SubClass> {
+    @Before @Override
+    public void setUp() throws Exception {
+      System.setProperty(Bus.TRAVERSE_CLASS_HIERARCHY, "true");
+      super.setUp();
+    }
+
+    @After @Override
+    public void tearDown() throws Exception {
+      super.tearDown();
+      System.setProperty(Bus.TRAVERSE_CLASS_HIERARCHY, "false");
+    }
+
+    static class SuperClass {
+      public List<Object> annotatedInSuperClassEvents = new ArrayList<Object>();
+
+      @Subscribe
+      public void superclassEventReceiver(Object object) {
+        annotatedInSuperClassEvents.add(object);
+      }
+    }
+
+    static class SubClass extends SuperClass {
+      /* Empty */
+    }
+
+    @Override
+    SubClass createHandler() {
+      return new SubClass();
+    }
+
+    @Test
+    public void annotatedInSuperClassWithHierarchyEventReceivedTest() {
+      assertThat(getHandler().annotatedInSuperClassEvents).containsExactly(EVENT);
+    }
+  }
+
+  public static class AnnotatedInSuperclassButOverrideninSubclassWithHierarchyLoadingTest 
+  extends AbstractEventBusTest<AnnotatedInSuperclassButOverrideninSubclassWithHierarchyLoadingTest.SubClass> {
+    @Before @Override
+    public void setUp() throws Exception {
+      System.setProperty(Bus.TRAVERSE_CLASS_HIERARCHY, "true");
+      super.setUp();
+    }
+
+    @After @Override
+    public void tearDown() throws Exception {
+      super.tearDown();
+      System.setProperty(Bus.TRAVERSE_CLASS_HIERARCHY, "false");
+    }
+
+    static class SuperClass {
+      public List<Object> annotatedInSuperClassEvents = new ArrayList<Object>();
+
+      @Subscribe
+      public void superclassEventReceiver(Object object) {
+        annotatedInSuperClassEvents.add(object);
+      }
+    }
+
+    static class SubClass extends SuperClass {
+      @Override
+      public void superclassEventReceiver(Object object) {
+        super.superclassEventReceiver(object);
+      }
+    }
+
+    @Override
+    SubClass createHandler() {
+      return new SubClass();
+    }
+
+    @Test
+    public void annotatedInSuperClassWithHierarchyEventReceivedTest() {
+      assertThat(getHandler().annotatedInSuperClassEvents).isEmpty();
+    }
+  }
+
+  public static class AnnotatedInAbstractSuperclassWithHierarchyLoadingTest 
+  extends AbstractEventBusTest<AnnotatedInAbstractSuperclassWithHierarchyLoadingTest.SubClass> {
+    @Before @Override
+    public void setUp() throws Exception {
+      System.setProperty(Bus.TRAVERSE_CLASS_HIERARCHY, "true");
+      super.setUp();
+    }
+
+    @After @Override
+    public void tearDown() throws Exception {
+      super.tearDown();
+      System.setProperty(Bus.TRAVERSE_CLASS_HIERARCHY, "false");
+    }
+
+    static abstract class SuperClass {
+      public List<Object> annotatedInSuperClassEvents = new ArrayList<Object>();
+
+      @Subscribe
+      public abstract void superclassEventReceiver(Object object);
+    }
+
+    static class SubClass extends SuperClass {
+      @Override
+      public void superclassEventReceiver(Object object) {
+        annotatedInSuperClassEvents.add(object);
+      }
+    }
+
+    @Override
+    SubClass createHandler() {
+      return new SubClass();
+    }
+
+    @Test
+    public void annotatedInSuperClassWithHierarchyEventReceivedTest() {
+      assertThat(getHandler().annotatedInSuperClassEvents).isEmpty();
+    }
+  }
+  
   public static class NeitherAbstractNorAnnotatedInSuperclassTest
       extends AbstractEventBusTest<NeitherAbstractNorAnnotatedInSuperclassTest.SubClass> {
     static class SuperClass {
