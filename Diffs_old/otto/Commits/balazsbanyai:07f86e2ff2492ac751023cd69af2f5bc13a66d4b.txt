diff --git a/otto-processor/src/main/java/com/squareup/otto/OttoAnnotationProcessor.java b/otto-processor/src/main/java/com/squareup/otto/OttoAnnotationProcessor.java
index f385fe1..7a38b74 100644
--- a/otto-processor/src/main/java/com/squareup/otto/OttoAnnotationProcessor.java
+++ b/otto-processor/src/main/java/com/squareup/otto/OttoAnnotationProcessor.java
@@ -25,79 +25,72 @@
 @SupportedSourceVersion(SourceVersion.RELEASE_6)
 @SupportedAnnotationTypes({ "com.squareup.otto.Subscribe" })
 public class OttoAnnotationProcessor extends AbstractProcessor {
-    private AbstractMethodVisitor[] checks = {
-            new VisibilityCheckerVisitor(),
-            new ArgumentListLengthCheckerVisitor()
-    };
+  private AbstractMethodVisitor[] checks = {
+          new VisibilityCheckerVisitor(),
+          new ArgumentListLengthCheckerVisitor()
+  };
 
-    @Override
-    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnvironment) {
+  @Override public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnvironment) {
 
-        for (Element element : roundEnvironment.getElementsAnnotatedWith(Subscribe.class)) {
-            for (AbstractMethodVisitor check : checks) {
-                element.accept(check, null);
-            }
-        }
-
-        return true;
+    for (Element element : roundEnvironment.getElementsAnnotatedWith(Subscribe.class)) {
+      for (AbstractMethodVisitor check : checks) {
+        element.accept(check, null);
+      }
     }
 
-    private class ArgumentListLengthCheckerVisitor extends AbstractMethodVisitor {
-
-        @Override
-        public Void visitExecutable(ExecutableElement element, Void aVoid) {
-            if (element.getParameters().size() != 1) {
-                String methodName = getQualifiedMethodName(element);
-                int argumentListSize = element.getParameters().size();
-                String message = ErrorMessages.newInvalidArgumentListMessage(methodName, argumentListSize);
-                processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, message);
-            }
-            return null;
-        }
-    }
+    return true;
+  }
 
-    private class VisibilityCheckerVisitor extends AbstractMethodVisitor {
-
-        @Override
-        public Void visitExecutable(ExecutableElement element, Void aVoid) {
-            if (!element.getModifiers().contains(Modifier.PUBLIC)) {
-                String methodName = getQualifiedMethodName(element);
-                String eventTypeName = element.getParameters().get(0).asType().toString();
-                String message = ErrorMessages.newNotVisibleMessage(methodName, eventTypeName);
-                processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, message);
-            }
-            return null;
-        }
-    }
+  private class ArgumentListLengthCheckerVisitor extends AbstractMethodVisitor {
 
-    private String getQualifiedMethodName(ExecutableElement element) {
-        TypeElement typeElement = (TypeElement) element.getEnclosingElement();
-        String className = typeElement.getQualifiedName().toString();
-        String methodName = element.toString();
-        return className + "." + methodName;
+    @Override public Void visitExecutable(ExecutableElement element, Void aVoid) {
+      if (element.getParameters().size() != 1) {
+        String methodName = getQualifiedMethodName(element);
+        int argumentListSize = element.getParameters().size();
+        String message = ErrorMessages.newInvalidArgumentListMessage(methodName, argumentListSize);
+        processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, message);
+      }
+      return null;
+    }
+  }
+
+  private class VisibilityCheckerVisitor extends AbstractMethodVisitor {
+
+    @Override public Void visitExecutable(ExecutableElement element, Void aVoid) {
+      if (!element.getModifiers().contains(Modifier.PUBLIC)) {
+        String methodName = getQualifiedMethodName(element);
+        String eventTypeName = element.getParameters().get(0).asType().toString();
+        String message = ErrorMessages.newNotVisibleMessage(methodName, eventTypeName);
+        processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, message);
+      }
+      return null;
     }
+  }
 
-    private abstract class AbstractMethodVisitor extends AbstractElementVisitor6<Void, Void> {
+  private String getQualifiedMethodName(ExecutableElement element) {
+    TypeElement typeElement = (TypeElement) element.getEnclosingElement();
+    String className = typeElement.getQualifiedName().toString();
+    String methodName = element.toString();
+    return className + "." + methodName;
+  }
 
-        @Override
-        public Void visitPackage(PackageElement e, Void aVoid) {
-            return null;
-        }
+  private abstract class AbstractMethodVisitor extends AbstractElementVisitor6<Void, Void> {
 
-        @Override
-        public Void visitType(TypeElement e, Void aVoid) {
-            return null;
-        }
+    @Override public Void visitPackage(PackageElement e, Void aVoid) {
+      return null;
+    }
+
+    @Override public Void visitType(TypeElement e, Void aVoid) {
+      return null;
+    }
 
-        @Override
-        public Void visitVariable(VariableElement e, Void aVoid) {
-            return null;
-        }
+    @Override public Void visitVariable(VariableElement e, Void aVoid) {
+      return null;
+    }
 
-        @Override
-        public Void visitTypeParameter(TypeParameterElement e, Void aVoid) {
-            return null;
-        }
+    @Override public Void visitTypeParameter(TypeParameterElement e, Void aVoid) {
+      return null;
     }
+  }
 
 }
diff --git a/otto-processor/src/test/java/com/squareup/otto/OttoAnnotationProcessorTest.java b/otto-processor/src/test/java/com/squareup/otto/OttoAnnotationProcessorTest.java
index c4552e9..c4d4d99 100644
--- a/otto-processor/src/test/java/com/squareup/otto/OttoAnnotationProcessorTest.java
+++ b/otto-processor/src/test/java/com/squareup/otto/OttoAnnotationProcessorTest.java
@@ -38,132 +38,122 @@
  */
 public class OttoAnnotationProcessorTest {
 
-    private static final String METHOD_ARG_TYPE_NAME = "TestEvent";
-    private static final String METHOD_NAME = "testMethod";
-    private static final String QUALIFIER = "javax.annotation";
-    private static final String QUALIFIED_METHOD_NAME = QUALIFIER + "." + METHOD_NAME;
-
-    @Mock
-    private ProcessingEnvironment env;
-
-    @Mock
-    private Messager messager;
-
-    @Mock
-    private RoundEnvironment roundEnvironment;
-
-    @Mock
-    private Set<? extends TypeElement> annotations;
-
-    private OttoAnnotationProcessor processor;
-
-    @Mock
-    private ExecutableElement executableElement;
-
-
-    @Before
-    public void setUp() {
-        MockitoAnnotations.initMocks(this);
-
-        when(env.getMessager()).thenReturn(messager);
-
-        processor = new OttoAnnotationProcessor();
-        processor.init(env);
-
-        Set<ExecutableElement> elements = Sets.newSet(executableElement);
-        when(roundEnvironment.getElementsAnnotatedWith(Subscribe.class)).thenReturn((Set) elements);
-        setupVisitableMockElement();
-    }
-
-    private void setupVisitableMockElement() {
-        when(executableElement.accept(any(ElementVisitor.class), anyObject())).then(new Answer<Object>() {
-            @Override
-            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-                ElementVisitor visitor = invocationOnMock.getArgumentAt(0, ElementVisitor.class);
-                Object parameter = invocationOnMock.getArguments()[1];
-                visitor.visitExecutable(executableElement, parameter);
-                return null;
-            }
-        });
-
-        TypeElement enclosingElement = mockTypeElementWithQualifiedName();
-        when(executableElement.getEnclosingElement()).thenReturn(enclosingElement);
-        when(executableElement.toString()).thenReturn(METHOD_NAME);
-    }
-
-    private TypeElement mockTypeElementWithQualifiedName() {
-        TypeElement mockTypeElement = mock(TypeElement.class);
-        Name mockName = mock(Name.class);
-        when(mockName.toString()).thenReturn(QUALIFIER);
-        when(mockTypeElement.getQualifiedName()).thenReturn(mockName);
-        return mockTypeElement;
-    }
-
-    private VariableElement mockMethodArgumentWithTypeName() {
-        VariableElement mockEvent = mock(VariableElement.class);
-        TypeMirror mockTypeMirror = mock(TypeMirror.class);
-        when(mockTypeMirror.toString()).thenReturn(METHOD_ARG_TYPE_NAME);
-        when(mockEvent.asType()).thenReturn(mockTypeMirror);
-        return mockEvent;
-    }
-
-    @Test
-    public void process_validSignature_noErrorReported() {
-        VariableElement argument1 = mockMethodArgumentWithTypeName();
-        when(executableElement.getModifiers()).thenReturn(EnumSet.of(Modifier.PUBLIC));
-        when(executableElement.getParameters()).thenReturn((List) asList(argument1));
-
-        processor.process(annotations, roundEnvironment);
-
-        verifyZeroInteractions(messager);
-    }
-
-    @Test
-    public void process_wrongArgumentListLength_errorReported() {
-        VariableElement argument1 = mockMethodArgumentWithTypeName();
-        VariableElement argument2 = mockMethodArgumentWithTypeName();
-        when(executableElement.getModifiers()).thenReturn(EnumSet.of(Modifier.PUBLIC));
-        when(executableElement.getParameters()).thenReturn((List) asList(argument1, argument2));
-
-        processor.process(annotations, roundEnvironment);
-
-        verifyWrongArgumentListLengthMessage();
-    }
-
-    private void verifyWrongArgumentListLengthMessage() {
-        Diagnostic.Kind expectedKind = Diagnostic.Kind.ERROR;
-        String expectedMessage = ErrorMessages.newInvalidArgumentListMessage(QUALIFIED_METHOD_NAME, executableElement.getParameters().size());
-        verify(messager).printMessage(eq(expectedKind), eq(expectedMessage));
-    }
-
-    @Test
-    public void process_wrongModifier_errorReported() {
-        VariableElement argument1 = mockMethodArgumentWithTypeName();
-        List args = asList(new VariableElement[]{argument1});
-        when(executableElement.getModifiers()).thenReturn(EnumSet.of(Modifier.PRIVATE));
-        when(executableElement.getParameters()).thenReturn(args);
-
-        processor.process(annotations, roundEnvironment);
-
-        verifyNotVisibleMessage();
-    }
-
-    private void verifyNotVisibleMessage() {
-        Diagnostic.Kind expectedKind = Diagnostic.Kind.ERROR;
-        String expectedMessage = ErrorMessages.newNotVisibleMessage(QUALIFIED_METHOD_NAME, METHOD_ARG_TYPE_NAME);
-        verify(messager).printMessage(eq(expectedKind), eq(expectedMessage));
-    }
-
-    @Test
-    public void process_wrongModifierAndParameterLength_bothErrorsReported() {
-        VariableElement argument1 = mockMethodArgumentWithTypeName();
-        VariableElement argument2 = mockMethodArgumentWithTypeName();
-        when(executableElement.getModifiers()).thenReturn(EnumSet.of(Modifier.PRIVATE));
-        when(executableElement.getParameters()).thenReturn((List) asList(argument1, argument2));
-
-        processor.process(annotations, roundEnvironment);
-
-        verifyNotVisibleMessage();
-        verifyWrongArgumentListLengthMessage();
-    }
+  private static final String METHOD_ARG_TYPE_NAME = "TestEvent";
+  private static final String METHOD_NAME = "testMethod";
+  private static final String QUALIFIER = "javax.annotation";
+  private static final String QUALIFIED_METHOD_NAME = QUALIFIER + "." + METHOD_NAME;
+
+  @Mock private ProcessingEnvironment env;
+
+  @Mock private Messager messager;
+
+  @Mock private RoundEnvironment roundEnvironment;
+
+  @Mock private Set<? extends TypeElement> annotations;
+
+  private OttoAnnotationProcessor processor;
+
+  @Mock private ExecutableElement executableElement;
+
+
+  @Before public void setUp() {
+    MockitoAnnotations.initMocks(this);
+
+    when(env.getMessager()).thenReturn(messager);
+
+    processor = new OttoAnnotationProcessor();
+    processor.init(env);
+
+    Set<ExecutableElement> elements = Sets.newSet(executableElement);
+    when(roundEnvironment.getElementsAnnotatedWith(Subscribe.class)).thenReturn((Set) elements);
+    setupVisitableMockElement();
+  }
+
+  private void setupVisitableMockElement() {
+    when(executableElement.accept(any(ElementVisitor.class), anyObject())).then(new Answer<Object>() {
+      @Override
+      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+        ElementVisitor visitor = invocationOnMock.getArgumentAt(0, ElementVisitor.class);
+        Object parameter = invocationOnMock.getArguments()[1];
+        visitor.visitExecutable(executableElement, parameter);
+        return null;
+      }
+    });
+
+    TypeElement enclosingElement = mockTypeElementWithQualifiedName();
+    when(executableElement.getEnclosingElement()).thenReturn(enclosingElement);
+    when(executableElement.toString()).thenReturn(METHOD_NAME);
+  }
+
+  private TypeElement mockTypeElementWithQualifiedName() {
+    TypeElement mockTypeElement = mock(TypeElement.class);
+    Name mockName = mock(Name.class);
+    when(mockName.toString()).thenReturn(QUALIFIER);
+    when(mockTypeElement.getQualifiedName()).thenReturn(mockName);
+    return mockTypeElement;
+  }
+
+  private VariableElement mockMethodArgumentWithTypeName() {
+    VariableElement mockEvent = mock(VariableElement.class);
+    TypeMirror mockTypeMirror = mock(TypeMirror.class);
+    when(mockTypeMirror.toString()).thenReturn(METHOD_ARG_TYPE_NAME);
+    when(mockEvent.asType()).thenReturn(mockTypeMirror);
+    return mockEvent;
+  }
+
+  @Test public void process_validSignature_noErrorReported() {
+    VariableElement argument1 = mockMethodArgumentWithTypeName();
+    when(executableElement.getModifiers()).thenReturn(EnumSet.of(Modifier.PUBLIC));
+    when(executableElement.getParameters()).thenReturn((List) asList(argument1));
+
+    processor.process(annotations, roundEnvironment);
+
+    verifyZeroInteractions(messager);
+  }
+
+  @Test public void process_wrongArgumentListLength_errorReported() {
+    VariableElement argument1 = mockMethodArgumentWithTypeName();
+    VariableElement argument2 = mockMethodArgumentWithTypeName();
+    when(executableElement.getModifiers()).thenReturn(EnumSet.of(Modifier.PUBLIC));
+    when(executableElement.getParameters()).thenReturn((List) asList(argument1, argument2));
+
+    processor.process(annotations, roundEnvironment);
+
+    verifyWrongArgumentListLengthMessage();
+  }
+
+  private void verifyWrongArgumentListLengthMessage() {
+    Diagnostic.Kind expectedKind = Diagnostic.Kind.ERROR;
+    String expectedMessage = ErrorMessages.newInvalidArgumentListMessage(QUALIFIED_METHOD_NAME, executableElement.getParameters().size());
+    verify(messager).printMessage(eq(expectedKind), eq(expectedMessage));
+  }
+
+  @Test public void process_wrongModifier_errorReported() {
+    VariableElement argument1 = mockMethodArgumentWithTypeName();
+    List args = asList(new VariableElement[]{argument1});
+    when(executableElement.getModifiers()).thenReturn(EnumSet.of(Modifier.PRIVATE));
+    when(executableElement.getParameters()).thenReturn(args);
+
+    processor.process(annotations, roundEnvironment);
+
+    verifyNotVisibleMessage();
+  }
+
+  private void verifyNotVisibleMessage() {
+    Diagnostic.Kind expectedKind = Diagnostic.Kind.ERROR;
+    String expectedMessage = ErrorMessages.newNotVisibleMessage(QUALIFIED_METHOD_NAME, METHOD_ARG_TYPE_NAME);
+    verify(messager).printMessage(eq(expectedKind), eq(expectedMessage));
+  }
+
+  @Test public void process_wrongModifierAndParameterLength_bothErrorsReported() {
+    VariableElement argument1 = mockMethodArgumentWithTypeName();
+    VariableElement argument2 = mockMethodArgumentWithTypeName();
+    when(executableElement.getModifiers()).thenReturn(EnumSet.of(Modifier.PRIVATE));
+    when(executableElement.getParameters()).thenReturn((List) asList(argument1, argument2));
+
+    processor.process(annotations, roundEnvironment);
+
+    verifyNotVisibleMessage();
+    verifyWrongArgumentListLengthMessage();
+  }
 }
diff --git a/otto/src/main/java/com/squareup/otto/ErrorMessages.java b/otto/src/main/java/com/squareup/otto/ErrorMessages.java
index b42e446..7464cc0 100644
--- a/otto/src/main/java/com/squareup/otto/ErrorMessages.java
+++ b/otto/src/main/java/com/squareup/otto/ErrorMessages.java
@@ -4,19 +4,19 @@
 
 public final class ErrorMessages {
 
-    private ErrorMessages() {
+  private ErrorMessages() {
 
-    }
+  }
 
-    private static final String INVALID_ARG_LIST = "Method %s has @Subscribe annotation but requires %d arguments. "
-            + "Methods must require a single argument.";
-    private static final String NOT_VISIBLE =  "Method %s has @Subscribe annotation on %s but is not 'public'.";
+  private static final String INVALID_ARG_LIST = "Method %s has @Subscribe annotation but requires %d arguments. "
+          + "Methods must require a single argument.";
+  private static final String NOT_VISIBLE = "Method %s has @Subscribe annotation on %s but is not 'public'.";
 
-    public static String newInvalidArgumentListMessage(String methodName, int argumentCount) {
-        return String.format(Locale.US, INVALID_ARG_LIST, methodName, argumentCount);
-    }
+  public static String newInvalidArgumentListMessage(String methodName, int argumentCount) {
+    return String.format(Locale.US, INVALID_ARG_LIST, methodName, argumentCount);
+  }
 
-    public static String newNotVisibleMessage(String name, String eventType) {
-        return String.format(Locale.US, NOT_VISIBLE, name, eventType);
-    }
+  public static String newNotVisibleMessage(String name, String eventType) {
+    return String.format(Locale.US, NOT_VISIBLE, name, eventType);
+  }
 }
