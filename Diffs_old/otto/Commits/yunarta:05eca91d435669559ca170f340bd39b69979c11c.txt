diff --git a/README.md b/README.md
index 933b380..6fdb8ba 100644
--- a/README.md
+++ b/README.md
@@ -2,7 +2,7 @@ Fork of Square Otto
 =============================
 https://github.com/square/otto
 
-Added feature of named event. 
+Added feature of named event.
 This allow multiple producer, productin same object type for different event name.
 As well as the subscriber will be able to subscribe event based on the name. 
 
@@ -24,6 +24,10 @@ bus.post('wifi_only_download', produceWifiConfigChange());
 
 Example above is just a very simple showcase of what can done with named event.
 
+
+Added feature for searching parent class for subscribe and produce annotation
+Based on https://github.com/thirogit/otto
+
 Otto - An event bus by Square
 =============================
 
diff --git a/otto/src/main/java/com/squareup/otto/AnnotatedHandlerFinder.java b/otto/src/main/java/com/squareup/otto/AnnotatedHandlerFinder.java
index cf98068..4a7e833 100644
--- a/otto/src/main/java/com/squareup/otto/AnnotatedHandlerFinder.java
+++ b/otto/src/main/java/com/squareup/otto/AnnotatedHandlerFinder.java
@@ -35,157 +35,186 @@
  */
 final class AnnotatedHandlerFinder {
 
-  /** Cache event bus producer methods for each class. */
-  private static final ConcurrentMap<Class<?>, Map<String, Method>> PRODUCERS_CACHE =
-          new ConcurrentHashMap<>();
-
-  /** Cache event bus subscriber methods for each class. */
-  private static final ConcurrentMap<Class<?>, Map<String, Set<Method>>> SUBSCRIBERS_CACHE =
-          new ConcurrentHashMap<>();
-
-  private static void loadAnnotatedProducerMethods(Class<?> listenerClass,
-                                                   Map<String, Method> producerMethods) {
-    Map<String, Set<Method>> subscriberMethods = new HashMap<>();
-    loadAnnotatedMethods(listenerClass, producerMethods, subscriberMethods);
-  }
-
-  private static void loadAnnotatedSubscriberMethods(Class<?> listenerClass,
-                                                     Map<String, Set<Method>> subscriberMethods) {
-    Map<String, Method> producerMethods = new HashMap<>();
-    loadAnnotatedMethods(listenerClass, producerMethods, subscriberMethods);
-  }
-
-  /**
-   * Load all methods annotated with {@link Produce} or {@link Subscribe} into their respective caches for the
-   * specified class.
-   */
-  private static void loadAnnotatedMethods(Class<?> listenerClass, Map<String, Method> producerMethods, Map<String, Set<Method>> subscriberMethods) {
-    for (Method method : listenerClass.getDeclaredMethods()) {
-      // The compiler sometimes creates synthetic bridge methods as part of the
-      // type erasure process. As of JDK8 these methods now include the same
-      // annotations as the original declarations. They should be ignored for
-      // subscribe/produce.
-      if (method.isBridge()) {
-        continue;
-      }
-      if (method.isAnnotationPresent(Subscribe.class)) {
-        Class<?>[] parameterTypes = method.getParameterTypes();
-        if (parameterTypes.length != 1) {
-          throw new IllegalArgumentException("Method " + method + " has @Subscribe annotation but requires "
-              + parameterTypes.length + " arguments.  Methods must require a single argument.");
-        }
+    /**
+     * Cache event bus producer methods for each class.
+     */
+    private static final ConcurrentMap<Class<?>, Map<String, Method>> PRODUCERS_CACHE =
+            new ConcurrentHashMap<>();
+
+    /**
+     * Cache event bus subscriber methods for each class.
+     */
+    private static final ConcurrentMap<Class<?>, Map<String, Set<Method>>> SUBSCRIBERS_CACHE =
+            new ConcurrentHashMap<>();
+
+    private static void loadAnnotatedProducerMethods(Class<?> listenerClass,
+                                                     Map<String, Method> producerMethods) {
+        Map<String, Set<Method>> subscriberMethods = new HashMap<>();
+        loadAnnotatedMethods(listenerClass, producerMethods, subscriberMethods);
+    }
 
-        Class<?> eventType = parameterTypes[0];
-        if (eventType.isInterface()) {
-          throw new IllegalArgumentException("Method " + method + " has @Subscribe annotation on " + eventType
-              + " which is an interface.  Subscription must be on a concrete class type.");
-        }
+    private static void loadAnnotatedSubscriberMethods(Class<?> listenerClass,
+                                                       Map<String, Set<Method>> subscriberMethods) {
+        Map<String, Method> producerMethods = new HashMap<>();
+        loadAnnotatedMethods(listenerClass, producerMethods, subscriberMethods);
+    }
 
-        if ((method.getModifiers() & Modifier.PUBLIC) == 0) {
-          throw new IllegalArgumentException("Method " + method + " has @Subscribe annotation on " + eventType
-              + " but is not 'public'.");
-        }
+    /**
+     * Load all methods annotated with {@link Produce} or {@link Subscribe} into their respective caches for the
+     * specified class.
+     */
+    private static void loadAnnotatedMethods(Class<?> listenerClass, Map<String, Method> producerMethods, Map<String, Set<Method>> subscriberMethods) {
+        Class<?> clazz = listenerClass;
+
+        do {
+            for (Method method : clazz.getDeclaredMethods())
+            {
+              // The compiler sometimes creates synthetic bridge methods as part of the
+              // type erasure process. As of JDK8 these methods now include the same
+              // annotations as the original declarations. They should be ignored for
+              // subscribe/produce.
+              if (method.isBridge())
+              {
+                continue;
+              }
+              if (method.isAnnotationPresent(Subscribe.class))
+              {
+                Class<?>[] parameterTypes = method.getParameterTypes();
+                if (parameterTypes.length != 1)
+                {
+                  throw new IllegalArgumentException("Method " + method + " has @Subscribe annotation but requires "
+                          + parameterTypes.length + " arguments.  Methods must require a single argument.");
+                }
+
+                Class<?> eventType = parameterTypes[0];
+                if (eventType.isInterface())
+                {
+                  throw new IllegalArgumentException("Method " + method + " has @Subscribe annotation on " + eventType
+                          + " which is an interface.  Subscription must be on a concrete class type.");
+                }
+
+                if ((method.getModifiers() & Modifier.PUBLIC) == 0)
+                {
+                  throw new IllegalArgumentException("Method " + method + " has @Subscribe annotation on " + eventType
+                          + " but is not 'public'.");
+                }
+
+                Subscribe annotation = method.getAnnotation(Subscribe.class);
+                String keyName = annotation.event();
+                if ("".equals(keyName))
+                {
+                  keyName = eventType.getName();
+                }
+
+                Set<Method> methods = subscriberMethods.get(keyName);
+                if (methods == null)
+                {
+                  methods = new HashSet<Method>();
+                  subscriberMethods.put(keyName, methods);
+                }
+                methods.add(method);
+              }
+              else if (method.isAnnotationPresent(Produce.class))
+              {
+                Class<?>[] parameterTypes = method.getParameterTypes();
+                if (parameterTypes.length != 0)
+                {
+                  throw new IllegalArgumentException("Method " + method + "has @Produce annotation but requires "
+                          + parameterTypes.length + " arguments.  Methods must require zero arguments.");
+                }
+                if (method.getReturnType() == Void.class)
+                {
+                  throw new IllegalArgumentException("Method " + method
+                          + " has a return type of void.  Must declare a non-void type.");
+                }
+
+                Class<?> eventType = method.getReturnType();
+                if (eventType.isInterface())
+                {
+                  throw new IllegalArgumentException("Method " + method + " has @Produce annotation on " + eventType
+                          + " which is an interface.  Producers must return a concrete class type.");
+                }
+                if (eventType.equals(Void.TYPE))
+                {
+                  throw new IllegalArgumentException("Method " + method + " has @Produce annotation but has no return type.");
+                }
+
+                Produce annotation = method.getAnnotation(Produce.class);
+                String keyName = annotation.event();
+                if ("".equals(keyName))
+                {
+                  keyName = eventType.getName();
+                }
+
+                if (producerMethods.containsKey(keyName))
+                {
+                  throw new IllegalArgumentException("Producer for type " + eventType + " has already been registered.");
+                }
+
+                producerMethods.put(keyName, method);
+              }
+            }
+
+            PRODUCERS_CACHE.put(listenerClass, producerMethods);
+            SUBSCRIBERS_CACHE.put(listenerClass, subscriberMethods);
+            if (clazz.isAnnotationPresent(InheritSubscribers.class)) {
+                clazz = clazz.getSuperclass();
+            } else {
+                clazz = null;
+            }
+        } while (clazz != null);
+    }
 
-        Subscribe annotation = method.getAnnotation(Subscribe.class);
-        String keyName = annotation.event();
-        if ("".equals(keyName)) {
-          keyName = eventType.getName();
-        }
 
-        Set<Method> methods = subscriberMethods.get(keyName);
-        if (methods == null) {
-          methods = new HashSet<Method>();
-          subscriberMethods.put(keyName, methods);
-        }
-        methods.add(method);
-      } else if (method.isAnnotationPresent(Produce.class)) {
-        Class<?>[] parameterTypes = method.getParameterTypes();
-        if (parameterTypes.length != 0) {
-          throw new IllegalArgumentException("Method " + method + "has @Produce annotation but requires "
-              + parameterTypes.length + " arguments.  Methods must require zero arguments.");
-        }
-        if (method.getReturnType() == Void.class) {
-          throw new IllegalArgumentException("Method " + method
-              + " has a return type of void.  Must declare a non-void type.");
-        }
+    /**
+     * This implementation finds all methods marked with a {@link Produce} annotation.
+     */
+    static Map<String, EventProducer> findAllProducers(Object listener) {
+        final Class<?> listenerClass = listener.getClass();
+        Map<String, EventProducer> handlersInMethod = new HashMap<>();
 
-        Class<?> eventType = method.getReturnType();
-        if (eventType.isInterface()) {
-          throw new IllegalArgumentException("Method " + method + " has @Produce annotation on " + eventType
-              + " which is an interface.  Producers must return a concrete class type.");
+        Map<String, Method> methods = PRODUCERS_CACHE.get(listenerClass);
+        if (null == methods) {
+            methods = new HashMap<>();
+            loadAnnotatedProducerMethods(listenerClass, methods);
         }
-        if (eventType.equals(Void.TYPE)) {
-          throw new IllegalArgumentException("Method " + method + " has @Produce annotation but has no return type.");
+        if (!methods.isEmpty()) {
+            for (Map.Entry<String, Method> e : methods.entrySet()) {
+                EventProducer producer = new EventProducer(listener, e.getValue());
+                handlersInMethod.put(e.getKey(), producer);
+            }
         }
 
-        if ((method.getModifiers() & Modifier.PUBLIC) == 0) {
-          throw new IllegalArgumentException("Method " + method + " has @Produce annotation on " + eventType
-              + " but is not 'public'.");
-        }
+        return handlersInMethod;
+    }
 
-        Produce annotation = method.getAnnotation(Produce.class);
-        String keyName = annotation.event();
-        if ("".equals(keyName)) {
-          keyName = eventType.getName();
+    /**
+     * This implementation finds all methods marked with a {@link Subscribe} annotation.
+     */
+    static Map<String, Set<EventHandler>> findAllSubscribers(Object listener) {
+        Class<?> listenerClass = listener.getClass();
+        Map<String, Set<EventHandler>> handlersInMethod = new HashMap<>();
+
+        Map<String, Set<Method>> methods = SUBSCRIBERS_CACHE.get(listenerClass);
+        if (null == methods) {
+            methods = new HashMap<>();
+            loadAnnotatedSubscriberMethods(listenerClass, methods);
         }
-
-        if (producerMethods.containsKey(keyName)) {
-          throw new IllegalArgumentException("Producer for type " + eventType + " has already been registered.");
+        if (!methods.isEmpty()) {
+            for (Map.Entry<String, Set<Method>> e : methods.entrySet()) {
+                Set<EventHandler> handlers = new HashSet<EventHandler>();
+                for (Method m : e.getValue()) {
+                    handlers.add(new EventHandler(listener, m));
+                }
+                handlersInMethod.put(e.getKey(), handlers);
+            }
         }
 
-        producerMethods.put(keyName, method);
-      }
-    }
-
-    PRODUCERS_CACHE.put(listenerClass, producerMethods);
-    SUBSCRIBERS_CACHE.put(listenerClass, subscriberMethods);
-  }
-
-  /** This implementation finds all methods marked with a {@link Produce} annotation. */
-  static Map<String, EventProducer> findAllProducers(Object listener) {
-    final Class<?> listenerClass = listener.getClass();
-    Map<String, EventProducer> handlersInMethod = new HashMap<>();
-
-    Map<String, Method> methods = PRODUCERS_CACHE.get(listenerClass);
-    if (null == methods) {
-      methods = new HashMap<>();
-      loadAnnotatedProducerMethods(listenerClass, methods);
-    }
-    if (!methods.isEmpty()) {
-      for (Map.Entry<String, Method> e : methods.entrySet()) {
-        EventProducer producer = new EventProducer(listener, e.getValue());
-        handlersInMethod.put(e.getKey(), producer);
-      }
+        return handlersInMethod;
     }
 
-    return handlersInMethod;
-  }
-
-  /** This implementation finds all methods marked with a {@link Subscribe} annotation. */
-  static Map<String, Set<EventHandler>> findAllSubscribers(Object listener) {
-    Class<?> listenerClass = listener.getClass();
-    Map<String, Set<EventHandler>> handlersInMethod = new HashMap<>();
-
-    Map<String, Set<Method>> methods = SUBSCRIBERS_CACHE.get(listenerClass);
-    if (null == methods) {
-      methods = new HashMap<>();
-      loadAnnotatedSubscriberMethods(listenerClass, methods);
-    }
-    if (!methods.isEmpty()) {
-      for (Map.Entry<String, Set<Method>> e : methods.entrySet()) {
-        Set<EventHandler> handlers = new HashSet<EventHandler>();
-        for (Method m : e.getValue()) {
-          handlers.add(new EventHandler(listener, m));
-        }
-        handlersInMethod.put(e.getKey(), handlers);
-      }
+    private AnnotatedHandlerFinder() {
+        // No instances.
     }
 
-    return handlersInMethod;
-  }
-
-  private AnnotatedHandlerFinder() {
-    // No instances.
-  }
-
 }
diff --git a/otto/src/main/java/com/squareup/otto/InheritSubscribers.java b/otto/src/main/java/com/squareup/otto/InheritSubscribers.java
new file mode 100644
index 0000000..89c5097
--- /dev/null
+++ b/otto/src/main/java/com/squareup/otto/InheritSubscribers.java
@@ -0,0 +1,14 @@
+package com.squareup.otto;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Created by yunarta on 6/8/15.
+ */
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.TYPE)
+public @interface InheritSubscribers {
+}
\ No newline at end of file
