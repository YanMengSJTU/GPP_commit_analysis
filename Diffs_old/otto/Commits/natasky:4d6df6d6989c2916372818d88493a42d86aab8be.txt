diff --git a/otto/src/main/java/com/squareup/otto/AnnotatedHandlerFinder.java b/otto/src/main/java/com/squareup/otto/AnnotatedHandlerFinder.java
index c7fb155..004ba74 100644
--- a/otto/src/main/java/com/squareup/otto/AnnotatedHandlerFinder.java
+++ b/otto/src/main/java/com/squareup/otto/AnnotatedHandlerFinder.java
@@ -23,6 +23,7 @@
 import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
+import java.util.concurrent.Executor;
 
 /**
  * Helper methods for finding methods annotated with {@link Produce} and {@link Subscribe}.
@@ -137,7 +138,7 @@ private static void loadAnnotatedMethods(Class<?> listenerClass) {
   }
 
   /** This implementation finds all methods marked with a {@link Subscribe} annotation. */
-  static Map<Class<?>, Set<EventHandler>> findAllSubscribers(Object listener) {
+  static Map<Class<?>, Set<EventHandler>> findAllSubscribers(Object listener, Executor executor) {
     Class<?> listenerClass = listener.getClass();
     Map<Class<?>, Set<EventHandler>> handlersInMethod = new HashMap<Class<?>, Set<EventHandler>>();
 
@@ -149,7 +150,7 @@ private static void loadAnnotatedMethods(Class<?> listenerClass) {
       for (Map.Entry<Class<?>, Set<Method>> e : methods.entrySet()) {
         Set<EventHandler> handlers = new HashSet<EventHandler>();
         for (Method m : e.getValue()) {
-          handlers.add(new EventHandler(listener, m));
+          handlers.add(new EventHandler(listener, m, executor));
         }
         handlersInMethod.put(e.getKey(), handlers);
       }
diff --git a/otto/src/main/java/com/squareup/otto/Bus.java b/otto/src/main/java/com/squareup/otto/Bus.java
index ddcf774..8d6ffea 100644
--- a/otto/src/main/java/com/squareup/otto/Bus.java
+++ b/otto/src/main/java/com/squareup/otto/Bus.java
@@ -29,6 +29,7 @@
 import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.CopyOnWriteArraySet;
+import java.util.concurrent.Executor;
 
 
 /**
@@ -182,7 +183,7 @@ public Bus(ThreadEnforcer enforcer, String identifier) {
    * @param object object whose handler methods should be registered.
    * @throws NullPointerException if the object is null.
    */
-  public void register(Object object) {
+  public void register(Object object, Executor executor) {
     if (object == null) {
       throw new NullPointerException("Object to register must not be null.");
     }
@@ -207,7 +208,7 @@ public void register(Object object) {
       }
     }
 
-    Map<Class<?>, Set<EventHandler>> foundHandlersMap = handlerFinder.findAllSubscribers(object);
+    Map<Class<?>, Set<EventHandler>> foundHandlersMap = handlerFinder.findAllSubscribers(object, executor);
     for (Class<?> type : foundHandlersMap.keySet()) {
       Set<EventHandler> handlers = handlersByType.get(type);
       if (handlers == null) {
@@ -279,7 +280,7 @@ public void unregister(Object object) {
       producersByType.remove(key).invalidate();
     }
 
-    Map<Class<?>, Set<EventHandler>> handlersInListener = handlerFinder.findAllSubscribers(object);
+    Map<Class<?>, Set<EventHandler>> handlersInListener = handlerFinder.findAllSubscribers(object, null);
     for (Map.Entry<Class<?>, Set<EventHandler>> entry : handlersInListener.entrySet()) {
       Set<EventHandler> currentHandlers = getHandlersForEventType(entry.getKey());
       Collection<EventHandler> eventMethodsInListener = entry.getValue();
diff --git a/otto/src/main/java/com/squareup/otto/EventHandler.java b/otto/src/main/java/com/squareup/otto/EventHandler.java
index 843a31b..0c42a49 100644
--- a/otto/src/main/java/com/squareup/otto/EventHandler.java
+++ b/otto/src/main/java/com/squareup/otto/EventHandler.java
@@ -19,6 +19,9 @@
 
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
+import java.util.concurrent.Executor;
+
+import javax.management.RuntimeErrorException;
 
 /**
  * Wraps a single-argument 'handler' method on a specific object.
@@ -37,12 +40,15 @@
   private final Object target;
   /** Handler method. */
   private final Method method;
+  
+  private final Executor executor;
+  
   /** Object hash code. */
   private final int hashCode;
   /** Should this handler receive events? */
   private boolean valid = true;
 
-  EventHandler(Object target, Method method) {
+  EventHandler(Object target, Method method, Executor executor) {
     if (target == null) {
       throw new NullPointerException("EventHandler target cannot be null.");
     }
@@ -52,6 +58,7 @@
 
     this.target = target;
     this.method = method;
+    this.executor = executor;
     method.setAccessible(true);
 
     // Compute hash code eagerly since we know it will be used frequently and we cannot estimate the runtime of the
@@ -81,20 +88,22 @@ public void invalidate() {
    * @throws java.lang.reflect.InvocationTargetException  if the wrapped method throws any {@link Throwable} that is not
    *     an {@link Error} ({@code Error}s are propagated as-is).
    */
-  public void handleEvent(Object event) throws InvocationTargetException {
+  public void handleEvent(final Object event) throws InvocationTargetException {
     if (!valid) {
       throw new IllegalStateException(toString() + " has been invalidated and can no longer handle events.");
     }
-    try {
-      method.invoke(target, event);
-    } catch (IllegalAccessException e) {
-      throw new AssertionError(e);
-    } catch (InvocationTargetException e) {
-      if (e.getCause() instanceof Error) {
-        throw (Error) e.getCause();
-      }
-      throw e;
-    }
+    
+    executor.execute(new Runnable() {
+		@Override
+		public void run() {
+			try {
+				method.invoke(target, event);
+			} catch (Exception e) {
+				e.printStackTrace();
+			}
+		}
+	});
+    
   }
 
   @Override public String toString() {
diff --git a/otto/src/main/java/com/squareup/otto/HandlerFinder.java b/otto/src/main/java/com/squareup/otto/HandlerFinder.java
index ff61a2c..4c6c0ab 100644
--- a/otto/src/main/java/com/squareup/otto/HandlerFinder.java
+++ b/otto/src/main/java/com/squareup/otto/HandlerFinder.java
@@ -18,13 +18,14 @@
 
 import java.util.Map;
 import java.util.Set;
+import java.util.concurrent.Executor;
 
 /** Finds producer and subscriber methods. */
 interface HandlerFinder {
 
   Map<Class<?>, EventProducer> findAllProducers(Object listener);
 
-  Map<Class<?>, Set<EventHandler>> findAllSubscribers(Object listener);
+  Map<Class<?>, Set<EventHandler>> findAllSubscribers(Object listener, Executor executor);
 
 
   HandlerFinder ANNOTATED = new HandlerFinder() {
@@ -34,8 +35,8 @@
     }
 
     @Override
-    public Map<Class<?>, Set<EventHandler>> findAllSubscribers(Object listener) {
-      return AnnotatedHandlerFinder.findAllSubscribers(listener);
+    public Map<Class<?>, Set<EventHandler>> findAllSubscribers(Object listener, Executor executor) {
+      return AnnotatedHandlerFinder.findAllSubscribers(listener, executor);
     }
   };
 }
