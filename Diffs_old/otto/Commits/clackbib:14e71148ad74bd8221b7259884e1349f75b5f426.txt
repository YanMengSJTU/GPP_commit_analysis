diff --git a/otto/src/main/java/com/squareup/otto/Bus.java b/otto/src/main/java/com/squareup/otto/Bus.java
index ad892b1..58f93ee 100644
--- a/otto/src/main/java/com/squareup/otto/Bus.java
+++ b/otto/src/main/java/com/squareup/otto/Bus.java
@@ -21,6 +21,7 @@
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.HashSet;
+import java.util.Iterator;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
@@ -313,6 +314,21 @@ public void unregister(Object object) {
    * @throws NullPointerException if the event is null.
    */
   public void post(Object event) {
+    postWithExclusions(event, (Class[])null);
+  }
+
+  /**
+   * Posts an event to all registered handlers, except the handlers targeting classes listed in the exclusions.  This method will return successfully after the event has been posted to
+   * all handlers, and regardless of any exceptions thrown by handlers.
+   *
+   * <p>If no handlers have been subscribed for {@code event}'s class or all handlers have been excluded, and {@code event} is not already a
+   * {@link DeadEvent}, it will be wrapped in a DeadEvent and reposted.
+   *
+   * @param event event to post.
+   * @param exclusions list of target classes to exclude from receiving the event
+   * @throws NullPointerException if the event is null.
+   */
+  public void postWithExclusions(Object event, Class ... exclusions){
     if (event == null) {
       throw new NullPointerException("Event to post must not be null.");
     }
@@ -322,7 +338,7 @@ public void post(Object event) {
 
     boolean dispatched = false;
     for (Class<?> eventType : dispatchTypes) {
-      Set<EventHandler> wrappers = getHandlersForEventType(eventType);
+      Set<EventHandler> wrappers = getHandlersForEventTypeWithExclusions(eventType, exclusions);
 
       if (wrappers != null && !wrappers.isEmpty()) {
         dispatched = true;
@@ -429,6 +445,36 @@ EventProducer getProducerForEventType(Class<?> type) {
     return handlersByType.get(type);
   }
 
+  /**
+   * Retrieves a mutable set of the currently registered handlers for {@code type} for which the target class
+   * isn't listed in the exclusions. If no handlers are currently registered for {@code type},
+   * or all the handlers have been excluded, this method may either return {@code null} or an empty set.
+   *
+   * @param type type of handlers to retrieve.
+   * @param exclusions list of target classes to exclude from the list of registered handlers
+   * @return currently registered handlers, or {@code null}.
+   */
+  Set<EventHandler> getHandlersForEventTypeWithExclusions(Class<?> type, Class ... exclusions){
+    Set<EventHandler> handlers = getHandlersForEventType(type);
+    if (handlers != null && exclusions != null && exclusions.length != 0) {
+      Iterator<EventHandler> eventHandlerIterator =  handlers.iterator();
+
+      while(eventHandlerIterator.hasNext()){
+        EventHandler eventHandler = eventHandlerIterator.next();
+
+        for(Class excludedClass : exclusions){
+          if(excludedClass.isInstance(eventHandler.getTarget())){
+            eventHandlerIterator.remove();
+            break;
+          }
+
+        }
+      }
+    }
+
+    return handlers;
+  }
+
   /**
    * Flattens a class's type hierarchy into a set of Class objects.  The set will include all superclasses
    * (transitively), and all interfaces implemented by these superclasses.
diff --git a/otto/src/main/java/com/squareup/otto/EventHandler.java b/otto/src/main/java/com/squareup/otto/EventHandler.java
index 6185539..73b1bfd 100644
--- a/otto/src/main/java/com/squareup/otto/EventHandler.java
+++ b/otto/src/main/java/com/squareup/otto/EventHandler.java
@@ -124,4 +124,7 @@ public void handleEvent(Object event) throws InvocationTargetException {
     return method.equals(other.method) && target == other.target;
   }
 
+  public Object getTarget() {
+    return target;
+  }
 }
