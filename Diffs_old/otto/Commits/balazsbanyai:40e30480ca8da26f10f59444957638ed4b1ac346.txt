diff --git a/otto-processor/pom.xml b/otto-processor/pom.xml
index e59fe73..09d7421 100644
--- a/otto-processor/pom.xml
+++ b/otto-processor/pom.xml
@@ -46,6 +46,12 @@
       <artifactId>fest-assert-core</artifactId>
       <scope>test</scope>
     </dependency>
+    <dependency>
+      <groupId>org.mockito</groupId>
+      <artifactId>mockito-core</artifactId>
+      <version>1.10.19</version>
+      <scope>test</scope>
+    </dependency>
   </dependencies>
 
   <build>
diff --git a/otto-processor/src/main/java/com/squareup/otto/OttoAnnotationProcessor.java b/otto-processor/src/main/java/com/squareup/otto/OttoAnnotationProcessor.java
index 0e7b777..50e6deb 100644
--- a/otto-processor/src/main/java/com/squareup/otto/OttoAnnotationProcessor.java
+++ b/otto-processor/src/main/java/com/squareup/otto/OttoAnnotationProcessor.java
@@ -17,10 +17,18 @@
 import javax.lang.model.util.AbstractElementVisitor6;
 import javax.tools.Diagnostic;
 
+/**
+ * Annotation processor that detects some cases of misusing Otto at compile time
+ *
+ * @author Balazs S Banyai
+ */
 @SupportedSourceVersion(SourceVersion.RELEASE_6)
 @SupportedAnnotationTypes({ "com.squareup.otto.Subscribe" })
 public class OttoAnnotationProcessor extends AbstractProcessor {
-    private AbstractMethodVisitor[] checks = { new VisibilityCheckerVisitor(), new ArgumentListLengthCheckerVisitor() };
+    private AbstractMethodVisitor[] checks = {
+            new VisibilityCheckerVisitor(),
+            new ArgumentListLengthCheckerVisitor()
+    };
 
     @Override
     public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnvironment) {
@@ -39,7 +47,10 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
         @Override
         public Void visitExecutable(ExecutableElement element, Void aVoid) {
             if (element.getParameters().size() != 1) {
-                processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, ErrorMessages.newInvalidArgumentListMessage(element.toString(), ((ExecutableElement) element).getParameters().size()));
+                String methodName = element.toString(); // TODO enclosingElement!
+                int argumentListSize = element.getParameters().size();
+                String message = ErrorMessages.newInvalidArgumentListMessage(methodName, argumentListSize);
+                processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, message);
             }
             return null;
         }
@@ -50,7 +61,10 @@ public Void visitExecutable(ExecutableElement element, Void aVoid) {
         @Override
         public Void visitExecutable(ExecutableElement element, Void aVoid) {
             if (!element.getModifiers().contains(Modifier.PUBLIC)) {
-                processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, ErrorMessages.newNotVisibleMessage(element.toString(), ((ExecutableElement) element).getParameters().get(0).asType().toString()));
+                String methodName = element.toString();
+                String eventTypeName = element.getParameters().get(0).asType().toString();
+                String message = ErrorMessages.newNotVisibleMessage(methodName, eventTypeName);
+                processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, message);
             }
             return null;
         }
diff --git a/otto-processor/src/test/java/com/squareup/otto/OttoAnnotationProcessorTest.java b/otto-processor/src/test/java/com/squareup/otto/OttoAnnotationProcessorTest.java
new file mode 100644
index 0000000..1aaa2ff
--- /dev/null
+++ b/otto-processor/src/test/java/com/squareup/otto/OttoAnnotationProcessorTest.java
@@ -0,0 +1,156 @@
+package com.squareup.otto;
+
+import junit.framework.TestCase;
+
+import org.fest.assertions.util.ArrayWrapperList;
+import org.junit.Before;
+import org.junit.Test;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.mockito.internal.util.collections.Sets;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+
+import java.util.Arrays;
+import java.util.EnumSet;
+import java.util.List;
+import java.util.Set;
+
+import javax.annotation.processing.Messager;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.annotation.processing.RoundEnvironment;
+import javax.lang.model.element.ElementVisitor;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeMirror;
+import javax.tools.Diagnostic;
+
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyObject;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyZeroInteractions;
+import static org.mockito.Mockito.when;
+
+public class OttoAnnotationProcessorTest {
+
+    private static final String METHOD_ARGUMENT_TYPE_NAME = "TestEvent";
+
+    @Mock
+    private ProcessingEnvironment env;
+
+    @Mock
+    private Messager messager;
+
+    @Mock
+    private RoundEnvironment roundEnvironment;
+
+    @Mock
+    private Set<? extends TypeElement> annotations;
+
+    private OttoAnnotationProcessor processor;
+
+    @Mock
+    private ExecutableElement executableElement;
+
+
+    @Before
+    public void setUp() {
+        MockitoAnnotations.initMocks(this);
+
+        when(env.getMessager()).thenReturn(messager);
+
+        processor = new OttoAnnotationProcessor();
+        processor.init(env);
+
+        Set<ExecutableElement> elements = Sets.newSet(executableElement);
+        when(roundEnvironment.getElementsAnnotatedWith(Subscribe.class)).thenReturn((Set) elements);
+        setupVisitableMockElement();
+    }
+
+    private void setupVisitableMockElement() {
+        when(executableElement.accept(any(ElementVisitor.class), anyObject())).then(new Answer<Object>() {
+            @Override
+            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+                ElementVisitor visitor = invocationOnMock.getArgumentAt(0, ElementVisitor.class);
+                Object parameter = invocationOnMock.getArguments()[1];
+                visitor.visitExecutable(executableElement, parameter);
+                return null;
+            }
+        });
+    }
+
+    private VariableElement mockMethodArgument() {
+        VariableElement mockEvent = mock(VariableElement.class);
+        TypeMirror mockTypeMirror = mock(TypeMirror.class);
+        when(mockTypeMirror.toString()).thenReturn(METHOD_ARGUMENT_TYPE_NAME);
+        when(mockEvent.asType()).thenReturn(mockTypeMirror);
+        return mockEvent;
+    }
+
+    @Test
+    public void process_validSignature_noErrorReported() {
+        VariableElement argument1 = mockMethodArgument();
+        List args = Arrays.asList(new VariableElement[]{argument1});
+        when(executableElement.getModifiers()).thenReturn(EnumSet.of(Modifier.PUBLIC));
+        when(executableElement.getParameters()).thenReturn(args);
+
+        processor.process(annotations, roundEnvironment);
+
+        verifyZeroInteractions(messager);
+    }
+
+    @Test
+    public void process_wrongArgumentListLength_errorReported() {
+        VariableElement argument1 = mockMethodArgument();
+        VariableElement argument2 = mockMethodArgument();
+        List args = Arrays.asList(new VariableElement[]{argument1, argument2});
+        when(executableElement.getModifiers()).thenReturn(EnumSet.of(Modifier.PUBLIC));
+        when(executableElement.getParameters()).thenReturn(args);
+
+        processor.process(annotations, roundEnvironment);
+
+        verifyWrongArgumentListLengthMessage();
+    }
+
+    private void verifyWrongArgumentListLengthMessage() {
+        Diagnostic.Kind expectedKind = Diagnostic.Kind.ERROR;
+        String expectedMessage = ErrorMessages.newInvalidArgumentListMessage(executableElement.toString(), executableElement.getParameters().size());
+        verify(messager).printMessage(eq(expectedKind), eq(expectedMessage));
+    }
+
+    @Test
+    public void process_wrongModifier_errorReported() {
+        VariableElement argument1 = mockMethodArgument();
+        List args = Arrays.asList(new VariableElement[]{argument1});
+        when(executableElement.getModifiers()).thenReturn(EnumSet.of(Modifier.PRIVATE));
+        when(executableElement.getParameters()).thenReturn(args);
+
+        processor.process(annotations, roundEnvironment);
+
+        verifyNotVisibleMessage();
+    }
+
+    private void verifyNotVisibleMessage() {
+        Diagnostic.Kind expectedKind = Diagnostic.Kind.ERROR;
+        String expectedMessage = ErrorMessages.newNotVisibleMessage(executableElement.toString(), METHOD_ARGUMENT_TYPE_NAME);
+        verify(messager).printMessage(eq(expectedKind), eq(expectedMessage));
+    }
+
+    @Test
+    public void process_wrongModifierAndParameterLength_bothErrorsReported() {
+        VariableElement argument1 = mockMethodArgument();
+        VariableElement argument2 = mockMethodArgument();
+        List args = Arrays.asList(new VariableElement[]{argument1, argument2});
+        when(executableElement.getModifiers()).thenReturn(EnumSet.of(Modifier.PRIVATE));
+        when(executableElement.getParameters()).thenReturn(args);
+
+        processor.process(annotations, roundEnvironment);
+
+        verifyNotVisibleMessage();
+        verifyWrongArgumentListLengthMessage();
+    }
+}
diff --git a/otto/src/main/java/com/squareup/otto/AnnotatedHandlerFinder.java b/otto/src/main/java/com/squareup/otto/AnnotatedHandlerFinder.java
index d179809..9331bf9 100644
--- a/otto/src/main/java/com/squareup/otto/AnnotatedHandlerFinder.java
+++ b/otto/src/main/java/com/squareup/otto/AnnotatedHandlerFinder.java
@@ -72,7 +72,8 @@ private static void loadAnnotatedMethods(Class<?> listenerClass,
       if (method.isAnnotationPresent(Subscribe.class)) {
         Class<?>[] parameterTypes = method.getParameterTypes();
         if (parameterTypes.length != 1) {
-          throw new IllegalArgumentException(ErrorMessages.newInvalidArgumentListMessage(method.getName(), parameterTypes.length));
+          String message = ErrorMessages.newInvalidArgumentListMessage(method.getName(), parameterTypes.length);
+          throw new IllegalArgumentException(message);
         }
 
         Class<?> eventType = parameterTypes[0];
@@ -82,7 +83,8 @@ private static void loadAnnotatedMethods(Class<?> listenerClass,
         }
 
         if ((method.getModifiers() & Modifier.PUBLIC) == 0) {
-          throw new IllegalArgumentException(ErrorMessages.newNotVisibleMessage(method.getName(), eventType.toString()));
+          String message = ErrorMessages.newNotVisibleMessage(method.toString(), eventType.toString());
+          throw new IllegalArgumentException(message);
         }
 
         Set<Method> methods = subscriberMethods.get(eventType);
diff --git a/otto/src/main/java/com/squareup/otto/ErrorMessages.java b/otto/src/main/java/com/squareup/otto/ErrorMessages.java
index 09c28a6..b42e446 100644
--- a/otto/src/main/java/com/squareup/otto/ErrorMessages.java
+++ b/otto/src/main/java/com/squareup/otto/ErrorMessages.java
@@ -2,16 +2,20 @@
 
 import java.util.Locale;
 
-public class ErrorMessages {
+public final class ErrorMessages {
 
-    private static final String INVALID_ARGUMENT_LIST = "Method %s has @Subscribe annotation but requires %d arguments. Methods must require a single argument.";
+    private ErrorMessages() {
+
+    }
+
+    private static final String INVALID_ARG_LIST = "Method %s has @Subscribe annotation but requires %d arguments. "
+            + "Methods must require a single argument.";
     private static final String NOT_VISIBLE =  "Method %s has @Subscribe annotation on %s but is not 'public'.";
 
     public static String newInvalidArgumentListMessage(String methodName, int argumentCount) {
-        return String.format(Locale.US, INVALID_ARGUMENT_LIST, methodName, argumentCount);
+        return String.format(Locale.US, INVALID_ARG_LIST, methodName, argumentCount);
     }
 
-
     public static String newNotVisibleMessage(String name, String eventType) {
         return String.format(Locale.US, NOT_VISIBLE, name, eventType);
     }
