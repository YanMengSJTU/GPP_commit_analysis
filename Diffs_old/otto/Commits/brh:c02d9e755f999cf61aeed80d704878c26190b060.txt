diff --git a/library/src/main/java/com/squareup/otto/Bus.java b/library/src/main/java/com/squareup/otto/Bus.java
index 0f5d787..bc2c132 100644
--- a/library/src/main/java/com/squareup/otto/Bus.java
+++ b/library/src/main/java/com/squareup/otto/Bus.java
@@ -30,7 +30,6 @@
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.CopyOnWriteArraySet;
 
-
 /**
  * Dispatches events to listeners, and provides ways for listeners to register themselves.
  *
@@ -350,13 +349,17 @@ protected void dispatchQueuedEvents() {
         }
 
         if (eventWithHandler.handler.isValid()) {
-          dispatch(eventWithHandler.event, eventWithHandler.handler);
+          dispatchEventWithHandler(eventWithHandler);
         }
       }
     } finally {
       isDispatching.set(false);
     }
   }
+  
+  protected void dispatchEventWithHandler(EventWithHandler eventWithHandler) {
+      dispatch(eventWithHandler.event, eventWithHandler.handler);
+  }
 
   /**
    * Dispatches {@code event} to the handler in {@code wrapper}.  This method is an appropriate override point for
diff --git a/library/src/main/java/com/squareup/otto/MainThreadPublishingBus.java b/library/src/main/java/com/squareup/otto/MainThreadPublishingBus.java
new file mode 100644
index 0000000..b1d4cc5
--- /dev/null
+++ b/library/src/main/java/com/squareup/otto/MainThreadPublishingBus.java
@@ -0,0 +1,61 @@
+package com.squareup.otto;
+
+import android.os.Handler;
+import android.os.Looper;
+import android.os.Message;
+
+/**
+ * This {@link Bus} implementation is essentially the same as {@link Bus}, but it will always call the Handlers
+ * (@Subscribe) on the main/UI thread.
+ * This is done such that events coming off of the bus won't then need to be sent through a handler to update
+ * a view.
+ * This implementation defaults the {@link ThreadEnforcer} to NONE.
+ * @see Bus
+ * @author Bobby R Hargett Jr
+ *
+ */
+public class MainThreadPublishingBus extends Bus {
+
+    Handler handler;
+
+    /**
+     * @see Bus#Bus()
+     * */
+    public MainThreadPublishingBus() {
+        this(DEFAULT_IDENTIFIER);
+    }
+
+    /**
+     * @see Bus#Bus(String)
+     */
+    public MainThreadPublishingBus(String identifier) {
+        this(ThreadEnforcer.NONE, identifier);
+    }
+
+    public MainThreadPublishingBus(ThreadEnforcer enforcer) {
+        this(enforcer, DEFAULT_IDENTIFIER);
+    }
+
+    public MainThreadPublishingBus(ThreadEnforcer enforcer, String identifier) {
+        this(enforcer, identifier, HandlerFinder.ANNOTATED);
+    }
+
+    public MainThreadPublishingBus(ThreadEnforcer enforcer, String identifier, HandlerFinder handlerFinder) {
+        super(enforcer, identifier, handlerFinder);
+        if (Looper.getMainLooper() == Looper.myLooper()) {
+            handler = new Handler() {
+                @Override
+                public void handleMessage(Message msg) {
+                    EventWithHandler eventWithHandler = (EventWithHandler) msg.obj;
+                    MainThreadPublishingBus.this.dispatch(eventWithHandler.event, eventWithHandler.handler);
+                }
+            };
+        }
+    }
+
+    @Override
+    protected void dispatchEventWithHandler(EventWithHandler eventWithHandler) {
+        handler.obtainMessage(0, eventWithHandler).sendToTarget();
+    }
+
+}
