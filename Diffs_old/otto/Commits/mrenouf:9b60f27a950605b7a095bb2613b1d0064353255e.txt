diff --git a/library/src/main/java/com/squareup/otto/AnnotatedHandlerFinder.java b/library/src/main/java/com/squareup/otto/AnnotatedHandlerFinder.java
index 31678b6..e36f3b7 100644
--- a/library/src/main/java/com/squareup/otto/AnnotatedHandlerFinder.java
+++ b/library/src/main/java/com/squareup/otto/AnnotatedHandlerFinder.java
@@ -23,6 +23,8 @@
 import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
+import java.util.SortedMap;
+import java.util.TreeMap;
 
 /**
  * Helper methods for finding methods annotated with {@link Produce} and {@link Subscribe}.
@@ -34,8 +36,8 @@
 final class AnnotatedHandlerFinder {
 
   /** Cache event bus producer methods for each class. */
-  private static final Map<Class<?>, Map<Class<?>, Method>> PRODUCERS_CACHE =
-      new HashMap<Class<?>, Map<Class<?>, Method>>();
+  private static final Map<Class<?>, Map<Class<?>, ProducerMethod>> PRODUCERS_CACHE =
+      new HashMap<Class<?>, Map<Class<?>, ProducerMethod>>();
 
   /** Cache event bus subscriber methods for each class. */
   private static final Map<Class<?>, Map<Class<?>, Set<Method>>> SUBSCRIBERS_CACHE =
@@ -47,7 +49,7 @@
    */
   private static void loadAnnotatedMethods(Class<?> listenerClass) {
     Map<Class<?>, Set<Method>> subscriberMethods = new HashMap<Class<?>, Set<Method>>();
-    Map<Class<?>, Method> producerMethods = new HashMap<Class<?>, Method>();
+    Map<Class<?>, ProducerMethod> producerMethods = new HashMap<Class<?>, ProducerMethod>();
 
     for (Method method : listenerClass.getDeclaredMethods()) {
       if (method.isAnnotationPresent(Subscribe.class)) {
@@ -75,6 +77,7 @@ private static void loadAnnotatedMethods(Class<?> listenerClass) {
         }
         methods.add(method);
       } else if (method.isAnnotationPresent(Produce.class)) {
+        Produce produceAnnotation = method.getAnnotation(Produce.class);
         Class<?>[] parameterTypes = method.getParameterTypes();
         if (parameterTypes.length != 0) {
           throw new IllegalArgumentException("Method " + method + "has @Produce annotation but requires "
@@ -90,7 +93,6 @@ private static void loadAnnotatedMethods(Class<?> listenerClass) {
           throw new IllegalArgumentException("Method " + method + " has @Produce annotation on " + eventType
               + " which is an interface.  Producers must return a concrete class type.");
         }
-
         if ((method.getModifiers() & Modifier.PUBLIC) == 0) {
           throw new IllegalArgumentException("Method " + method + " has @Produce annotation on " + eventType
               + " but is not 'public'.");
@@ -99,31 +101,31 @@ private static void loadAnnotatedMethods(Class<?> listenerClass) {
         if (producerMethods.containsKey(eventType)) {
           throw new IllegalArgumentException("Producer for type " + eventType + " has already been registered.");
         }
-        producerMethods.put(eventType, method);
+        producerMethods.put(eventType, new ProducerMethod(method, produceAnnotation.priority()));
       }
     }
-
     PRODUCERS_CACHE.put(listenerClass, producerMethods);
     SUBSCRIBERS_CACHE.put(listenerClass, subscriberMethods);
   }
 
   /** This implementation finds all methods marked with a {@link Produce} annotation. */
-  static Map<Class<?>, EventProducer> findAllProducers(Object listener) {
+  static Map<EventProducer, Class<?>> findAllProducers(Object listener) {
     final Class<?> listenerClass = listener.getClass();
-    Map<Class<?>, EventProducer> handlersInMethod = new HashMap<Class<?>, EventProducer>();
+    SortedMap<EventProducer, Class<?>> producersInClass = new TreeMap<EventProducer, Class<?>>();
 
     if (!PRODUCERS_CACHE.containsKey(listenerClass)) {
       loadAnnotatedMethods(listenerClass);
     }
-    Map<Class<?>, Method> methods = PRODUCERS_CACHE.get(listenerClass);
+    Map<Class<?>, ProducerMethod> methods = PRODUCERS_CACHE.get(listenerClass);
     if (!methods.isEmpty()) {
-      for (Map.Entry<Class<?>, Method> e : methods.entrySet()) {
-        EventProducer producer = new EventProducer(listener, e.getValue());
-        handlersInMethod.put(e.getKey(), producer);
+      for (Map.Entry<Class<?>, ProducerMethod> e : methods.entrySet()) {
+        ProducerMethod m = e.getValue();
+        EventProducer producer = new EventProducer(listener, m.method, m.priority);
+        producersInClass.put(producer, e.getKey());
       }
     }
 
-    return handlersInMethod;
+    return producersInClass;
   }
 
   /** This implementation finds all methods marked with a {@link Subscribe} annotation. */
diff --git a/library/src/main/java/com/squareup/otto/Bus.java b/library/src/main/java/com/squareup/otto/Bus.java
index 4b477b7..9dfa7aa 100644
--- a/library/src/main/java/com/squareup/otto/Bus.java
+++ b/library/src/main/java/com/squareup/otto/Bus.java
@@ -25,6 +25,8 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+import java.util.SortedMap;
+import java.util.TreeMap;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.ConcurrentMap;
@@ -184,10 +186,9 @@ public Bus(ThreadEnforcer enforcer, String identifier) {
   public void register(Object object) {
     enforcer.enforce(this);
 
-    Map<Class<?>, EventProducer> foundProducers = handlerFinder.findAllProducers(object);
-    for (Class<?> type : foundProducers.keySet()) {
-
-      final EventProducer producer = foundProducers.get(type);
+    Map<EventProducer, Class<?>> foundProducers = handlerFinder.findAllProducers(object);
+    for (EventProducer producer : foundProducers.keySet()) {
+      final Class<?> type = foundProducers.get(producer);
       EventProducer previousProducer = producersByType.putIfAbsent(type, producer);
       //checking if the previous producer existed
       if (previousProducer != null) {
@@ -216,20 +217,28 @@ public void register(Object object) {
       handlers.addAll(foundHandlers);
     }
 
+    SortedMap<EventProducer, Set<EventHandler>> dispatchMap =
+        new TreeMap<EventProducer, Set<EventHandler>>();
 
+    // Build a map of producers to the subscribers
     for (Map.Entry<Class<?>, Set<EventHandler>> entry : foundHandlersMap.entrySet()) {
       Class<?> type = entry.getKey();
       EventProducer producer = producersByType.get(type);
       if (producer != null) {
-        Set<EventHandler> currentHandlers = getHandlersForEventType(type);
-        if (currentHandlers != null) {
-          Set<EventHandler> foundHandlers = entry.getValue();
-          for (EventHandler foundHandler : foundHandlers) {
-            if (currentHandlers.contains(foundHandler)) {
-              dispatchProducerResultToHandler(foundHandler, producer);
-            }
-          }
+        Set<EventHandler> handlers = dispatchMap.get(producer);
+        if (handlers == null) {
+          handlers = new HashSet<EventHandler>();
+          dispatchMap.put(producer, handlers);
         }
+        handlers.addAll(entry.getValue());
+      }
+    }
+
+    // In sorted order, produce the events and send them to each of the subscribers
+    for (Map.Entry<EventProducer, Set<EventHandler>> entry : dispatchMap.entrySet()) {
+      EventProducer producer = entry.getKey();
+      for (EventHandler handler : entry.getValue()) {
+        dispatchProducerResultToHandler(handler, producer);
       }
     }
   }
@@ -262,11 +271,11 @@ private void dispatchProducerResultToHandler(EventHandler handler, EventProducer
   public void unregister(Object object) {
     enforcer.enforce(this);
 
-    Map<Class<?>, EventProducer> producersInListener = handlerFinder.findAllProducers(object);
-    for (Map.Entry<Class<?>, EventProducer> entry : producersInListener.entrySet()) {
-      final Class<?> key = entry.getKey();
+    Map<EventProducer, Class<?>> producersInListener = handlerFinder.findAllProducers(object);
+    for (Map.Entry<EventProducer, Class<?>> entry : producersInListener.entrySet()) {
+      final Class<?> key = entry.getValue();
       EventProducer producer = getProducerForEventType(key);
-      EventProducer value = entry.getValue();
+      EventProducer value = entry.getKey();
 
       if (value == null || !value.equals(producer)) {
         throw new IllegalArgumentException(
diff --git a/library/src/main/java/com/squareup/otto/EventProducer.java b/library/src/main/java/com/squareup/otto/EventProducer.java
index d5f113b..0440836 100644
--- a/library/src/main/java/com/squareup/otto/EventProducer.java
+++ b/library/src/main/java/com/squareup/otto/EventProducer.java
@@ -27,16 +27,18 @@
  *
  * @author Jake Wharton
  */
-class EventProducer {
+class EventProducer implements Comparable<EventProducer> {
 
   /** Object sporting the producer method. */
   private final Object target;
   /** Producer method. */
   private final Method method;
+  /** Event priority */
+  private final int priority;
   /** Object hash code. */
   private final int hashCode;
 
-  EventProducer(Object target, Method method) {
+  EventProducer(Object target, Method method, int priority) {
     if (target == null) {
       throw new NullPointerException("EventProducer target cannot be null.");
     }
@@ -46,6 +48,7 @@
 
     this.target = target;
     this.method = method;
+    this.priority = priority;
     method.setAccessible(true);
 
     // Compute hash code eagerly since we know it will be used frequently and we cannot estimate the runtime of the
@@ -99,4 +102,15 @@ public Object produceEvent() throws InvocationTargetException {
     return method.equals(other.method) && target == other.target;
   }
 
+  /**
+   * Natural ordering by priority, ascending, then by hashCode.
+   */
+  @Override
+  public int compareTo(EventProducer o) {
+	if (priority == o.priority) {
+      return hashCode > o.hashCode ? 1 : hashCode < o.hashCode ? -1 : 0;
+    }
+	return priority < o.priority ? -1 : priority > o.priority ? 1 : 0;
+  }
+
 }
diff --git a/library/src/main/java/com/squareup/otto/HandlerFinder.java b/library/src/main/java/com/squareup/otto/HandlerFinder.java
index ff61a2c..62f039a 100644
--- a/library/src/main/java/com/squareup/otto/HandlerFinder.java
+++ b/library/src/main/java/com/squareup/otto/HandlerFinder.java
@@ -22,14 +22,14 @@
 /** Finds producer and subscriber methods. */
 interface HandlerFinder {
 
-  Map<Class<?>, EventProducer> findAllProducers(Object listener);
+  Map<EventProducer, Class<?>> findAllProducers(Object listener);
 
   Map<Class<?>, Set<EventHandler>> findAllSubscribers(Object listener);
 
 
   HandlerFinder ANNOTATED = new HandlerFinder() {
     @Override
-    public Map<Class<?>, EventProducer> findAllProducers(Object listener) {
+    public Map<EventProducer, Class<?>> findAllProducers(Object listener) {
       return AnnotatedHandlerFinder.findAllProducers(listener);
     }
 
diff --git a/library/src/main/java/com/squareup/otto/Produce.java b/library/src/main/java/com/squareup/otto/Produce.java
index 1497a39..04beca7 100644
--- a/library/src/main/java/com/squareup/otto/Produce.java
+++ b/library/src/main/java/com/squareup/otto/Produce.java
@@ -32,4 +32,5 @@
 @Retention(RetentionPolicy.RUNTIME)
 @Target(ElementType.METHOD)
 public @interface Produce {
+  int priority() default 0;
 }
diff --git a/library/src/main/java/com/squareup/otto/ProducerMethod.java b/library/src/main/java/com/squareup/otto/ProducerMethod.java
new file mode 100644
index 0000000..d421b8f
--- /dev/null
+++ b/library/src/main/java/com/squareup/otto/ProducerMethod.java
@@ -0,0 +1,23 @@
+package com.squareup.otto;
+
+import java.lang.reflect.Method;
+
+public class ProducerMethod {
+  public final int priority;
+  public final Method method;
+
+  public ProducerMethod(Method method, int priority) {
+    this.method = method;
+    this.priority = priority;
+  }
+
+  @Override
+  public int hashCode() {
+    return method.hashCode();
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    return method.equals(obj);	
+  }
+}
diff --git a/library/src/test/java/com/squareup/otto/EventProducerTest.java b/library/src/test/java/com/squareup/otto/EventProducerTest.java
index 1004256..c1d0be3 100644
--- a/library/src/test/java/com/squareup/otto/EventProducerTest.java
+++ b/library/src/test/java/com/squareup/otto/EventProducerTest.java
@@ -45,7 +45,7 @@
    */
   @Test public void basicMethodCall() throws Exception {
     Method method = getRecordingMethod();
-    EventProducer producer = new EventProducer(this, method);
+    EventProducer producer = new EventProducer(this, method, 0);
     Object methodResult = producer.produceEvent();
 
     assertTrue("Producer must call provided method.", methodCalled);
@@ -55,7 +55,7 @@
   /** Checks that EventProducer's constructor disallows null methods. */
   @Test public void rejectionOfNullMethods() {
     try {
-      new EventProducer(this, null);
+      new EventProducer(this, null, 0);
       fail("EventProducer must immediately reject null methods.");
     } catch (NullPointerException expected) {
       // Hooray!
@@ -66,7 +66,7 @@
   @Test public void rejectionOfNullTargets() throws NoSuchMethodException {
     Method method = getRecordingMethod();
     try {
-      new EventProducer(null, method);
+      new EventProducer(null, method, 0);
       fail("EventProducer must immediately reject null targets.");
     } catch (NullPointerException expected) {
       // Huzzah!
@@ -75,7 +75,7 @@
 
   @Test public void testExceptionWrapping() throws NoSuchMethodException {
     Method method = getExceptionThrowingMethod();
-    EventProducer producer = new EventProducer(this, method);
+    EventProducer producer = new EventProducer(this, method, 0);
 
     try {
       producer.produceEvent();
@@ -88,7 +88,7 @@
 
   @Test public void errorPassthrough() throws InvocationTargetException, NoSuchMethodException {
     Method method = getErrorThrowingMethod();
-    EventProducer producer = new EventProducer(this, method);
+    EventProducer producer = new EventProducer(this, method, 0);
 
     try {
       producer.produceEvent();
@@ -100,7 +100,7 @@
 
   @Test public void returnValueNotCached() throws Exception {
     Method method = getRecordingMethod();
-    EventProducer producer = new EventProducer(this, method);
+    EventProducer producer = new EventProducer(this, method, 0);
     producer.produceEvent();
     methodReturnValue = new Object();
     methodCalled = false;
diff --git a/library/src/test/java/com/squareup/otto/ProducerPriorityTest.java b/library/src/test/java/com/squareup/otto/ProducerPriorityTest.java
new file mode 100644
index 0000000..98e0841
--- /dev/null
+++ b/library/src/test/java/com/squareup/otto/ProducerPriorityTest.java
@@ -0,0 +1,160 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.squareup.otto;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import static org.junit.Assert.assertEquals;
+
+/**
+ * Ensures that events from Producers are dispatched in order of descending priority.
+ * 
+ * @author Mark Renouf
+ */
+public class ProducerPriorityTest {
+
+  private Bus bus;
+  private SubscriberClass subscriber;
+  private PriorityProducerClass1 producer1;
+  private PriorityProducerClass2 producer2;
+  
+  @Before public void setUp() throws Exception {
+	bus = new Bus(ThreadEnforcer.ANY);
+	subscriber = new SubscriberClass();
+	producer1 = new PriorityProducerClass1();
+	producer2 = new PriorityProducerClass2();
+  }
+
+  /**
+   * Checks that events dispatched in priority order when their Producing class 
+   * is registered.
+   */
+  @Test public void eventPriorityOnProducerRegistration() throws Exception {
+    bus.register(subscriber);
+
+    List<Number> expected = new ArrayList<Number>();
+    expected.add(Float.valueOf(2));
+    expected.add(Long.valueOf(3));
+    expected.add(Integer.valueOf(1));
+
+    bus.register(producer1);
+    assertEquals("Producers should be invoked in order of their priority.", 
+    	expected, subscriber.received);
+    bus.unregister(producer1);
+    
+    subscriber.received.clear();
+    expected.clear();
+    
+    bus.register(producer2);
+    expected.add(Integer.valueOf(1));
+    expected.add(Float.valueOf(2));
+    expected.add(Long.valueOf(3));
+    assertEquals("Producers should be invoked in order of their priority.", 
+    	expected, subscriber.received);
+  }
+
+  /**
+   * Checks that events dispatched in priority order when a Subscribing class 
+   * is registered.
+   */
+  @Test public void eventPriorityOnSubscriberRegistration() throws Exception {
+    Bus bus = new Bus(ThreadEnforcer.ANY);
+    bus.register(producer1);
+
+    bus.register(subscriber);
+    List<Number> expected = new ArrayList<Number>();
+    expected.add(Float.valueOf(2));
+    expected.add(Long.valueOf(3));
+    expected.add(Integer.valueOf(1));
+    assertEquals("Producers should be invoked in order of their priority.", 
+    	expected, subscriber.received);
+    expected.clear();
+    bus.unregister(subscriber);
+
+    bus.unregister(producer1);
+    subscriber.clear();
+    bus.register(producer2);
+    
+    bus.register(subscriber);
+    expected.add(Integer.valueOf(1));
+    expected.add(Float.valueOf(2));
+    expected.add(Long.valueOf(3));
+    assertEquals("Producers should be invoked in order of their priority.", 
+    	expected, subscriber.received);
+  }
+
+  public static class PriorityProducerClass1 {
+	@Produce(priority=1)
+	public Float getFloat() {
+	  return Float.valueOf(2);
+	}
+	  
+    @Produce(priority=2)
+    public Long getLong() {
+      return Long.valueOf(3);
+    }
+
+    @Produce(priority=3)
+    public Integer getInteger() {
+    	return Integer.valueOf(1);
+    }
+  }
+  
+  public static class PriorityProducerClass2 {
+    @Produce(priority=1)
+    public Integer getInteger() {
+      return Integer.valueOf(1);
+    }
+
+    @Produce(priority=2)
+    public Float getFloat() {
+      return Float.valueOf(2);
+    }
+    
+    @Produce(priority=3)
+    public Long getLong() {
+      return Long.valueOf(3);
+    }
+  }
+  
+  public static class SubscriberClass {
+    List<Number> received = new ArrayList<Number>();
+	
+    @Subscribe
+    public void receiveLong(Long value) {
+      received.add(value);
+    }
+    
+    @Subscribe
+    public void receiveFloat(Float value) {
+      received.add(value);
+    }
+
+    @Subscribe
+    public void receiveInteger(Integer value) {
+      received.add(value);
+    }
+    
+    public void clear() {
+      received.clear();
+    }
+  }
+}
diff --git a/library/src/test/java/com/squareup/otto/UnregisteringHandlerTest.java b/library/src/test/java/com/squareup/otto/UnregisteringHandlerTest.java
index 32b49b4..c66a249 100644
--- a/library/src/test/java/com/squareup/otto/UnregisteringHandlerTest.java
+++ b/library/src/test/java/com/squareup/otto/UnregisteringHandlerTest.java
@@ -78,7 +78,7 @@ public int compare(EventHandler eventHandler, EventHandler eventHandler1) {
     };
 
     @Override
-    public Map<Class<?>, EventProducer> findAllProducers(Object listener) {
+    public Map<EventProducer, Class<?>> findAllProducers(Object listener) {
       return HandlerFinder.ANNOTATED.findAllProducers(listener);
     }
 
