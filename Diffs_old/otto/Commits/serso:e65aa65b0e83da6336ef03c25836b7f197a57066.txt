diff --git a/otto-compiler/src/main/java/com/squareup/otto/OttoProcessor.java b/otto-compiler/src/main/java/com/squareup/otto/OttoProcessor.java
index c25ce11..12d86c2 100644
--- a/otto-compiler/src/main/java/com/squareup/otto/OttoProcessor.java
+++ b/otto-compiler/src/main/java/com/squareup/otto/OttoProcessor.java
@@ -26,8 +26,12 @@
 import javax.lang.model.element.*;
 import javax.lang.model.type.TypeMirror;
 import javax.tools.Diagnostic;
+import javax.tools.JavaFileObject;
 import javax.validation.constraints.NotNull;
+import java.io.Closeable;
 import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
 import java.util.*;
 
 /**
@@ -38,6 +42,7 @@
  */
 public final class OttoProcessor extends AbstractProcessor {
 
+  private static final byte[] BUFFER = new byte[4 * 1024];
   private static final Set<String> SUPPORTED_ANNOTATIONS = new HashSet<String>();
 
   static {
@@ -86,7 +91,7 @@ public boolean process(@NotNull Set<? extends TypeElement> annotations, @NotNull
       final Map<TypeElement, Map<TypeMirror, List<ExecutableElement>>> methods = collectMethods(env);
       if (!methods.isEmpty()) {
         methodsInClass.putAll(methods);
-        writeToFile(generateClass(methodsInClass));
+        writeClasses(generateClass(methodsInClass));
       }
     } catch (ProcessingException e) {
       error(e.getMessage());
@@ -168,8 +173,8 @@ private MethodSpec generateFindAllProducers() {
   }
 
   @NotNull
-  private CodeBlock generateHandler(@NotNull  TypeElement type, @NotNull TypeMirror eventType,@NotNull ExecutableElement method) {
-    return CodeBlock.builder().add("\nnew $T(){public void handleEvent(Object event){(($T)$N).$N(($T)event);}}", BaseEventHandler.class, type, "listener", method.getSimpleName(), eventType).build();
+  private CodeBlock generateHandler(@NotNull TypeElement type, @NotNull TypeMirror eventType, @NotNull ExecutableElement method) {
+    return CodeBlock.builder().add("\nnew $L(listener){public void handleEvent(Object event){(($T)$N).$N(($T)event);}}", "GeneratedEventHandler", type, "listener", method.getSimpleName(), eventType).build();
   }
 
   @NotNull
@@ -233,15 +238,68 @@ private CodeBlock generateHandler(@NotNull  TypeElement type, @NotNull TypeMirro
     return methodsByClass;
   }
 
-  @NotNull
-  private JavaFile writeToFile(@NotNull TypeSpec spec) throws ProcessingException {
-    final JavaFile file = JavaFile.builder(Bus.class.getPackage().getName(), spec).build();
+  private void writeClasses(@NotNull TypeSpec handleFinderSpec) throws ProcessingException {
+    writeHandlerFinder(handleFinderSpec);
+    writeEventHandler();
+  }
+
+  private void writeEventHandler() throws ProcessingException {
+    InputStream from = null;
+    OutputStream to = null;
+    JavaFileObject file = null;
+    try {
+      from = OttoProcessor.class.getResourceAsStream("/com/squareup/otto/GeneratedEventHandler.java");
+      file = filer.createSourceFile(getPackageName() + ".GeneratedEventHandler");
+      to = file.openOutputStream();
+      copy(from, to);
+      file = null;
+    } catch (IOException e) {
+      throw new ProcessingException(e);
+    } finally {
+      close(from);
+      close(to);
+      if (file != null) {
+        file.delete();
+      }
+    }
+  }
+
+  public static long copy(@NotNull InputStream from, @NotNull OutputStream to) throws IOException {
+    long total = 0;
+    while (true) {
+      final int r = from.read(BUFFER);
+      if (r == -1) {
+        break;
+      }
+      to.write(BUFFER, 0, r);
+      total += r;
+    }
+    return total;
+  }
+
+  private void close(@NotNull Closeable c) {
+    if (c == null) {
+      return;
+    }
+    try {
+      c.close();
+    } catch (IOException e) {
+      error(e.getMessage());
+    }
+  }
+
+  private void writeHandlerFinder(@NotNull TypeSpec spec) throws ProcessingException {
+    final JavaFile file = JavaFile.builder(getPackageName(), spec).build();
     try {
       file.writeTo(filer);
     } catch (IOException e) {
       throw new ProcessingException(e);
     }
-    return file;
+  }
+
+  @NotNull
+  private String getPackageName() {
+    return Bus.class.getPackage().getName();
   }
 
   private void error(@NotNull String msg) {
diff --git a/otto-compiler/src/main/resources/com/squareup/otto/GeneratedEventHandler.java b/otto-compiler/src/main/resources/com/squareup/otto/GeneratedEventHandler.java
new file mode 100644
index 0000000..fb90279
--- /dev/null
+++ b/otto-compiler/src/main/resources/com/squareup/otto/GeneratedEventHandler.java
@@ -0,0 +1,36 @@
+package com.squareup.otto;
+
+/**
+ * Base class for generated {@link EventHandler}s.
+ * Contains {@link #equals(Object)} and {@link #hashCode()} methods which assume that implementors of this class are
+ * anonymous classes, one per subscriber's method.
+ *
+ * @author Sergey Solovyev
+ */
+abstract class GeneratedEventHandler extends BaseEventHandler {
+
+  protected final Object listener;
+
+  protected GeneratedEventHandler(Object listener) {
+    this.listener = listener;
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (this == o) return true;
+    // each anonymous class has its own unique class name, thus, checking class name should be enough to distinguish
+    // one handler from another
+    if (o == null || getClass() != o.getClass()) return false;
+
+    // but there might be several subscribers with the same class names (f.e. a fragment might be instantiated several
+    // times), thus, subscriber should als be checked
+    final GeneratedEventHandler that = (GeneratedEventHandler) o;
+    return listener.equals(that.listener);
+
+  }
+
+  @Override
+  public int hashCode() {
+    return listener.hashCode();
+  }
+}
\ No newline at end of file
