diff --git a/otto/src/main/java/com/squareup/otto/AnnotatedHandlerFinder.java b/otto/src/main/java/com/squareup/otto/AnnotatedHandlerFinder.java
index 7d79b71..329a555 100644
--- a/otto/src/main/java/com/squareup/otto/AnnotatedHandlerFinder.java
+++ b/otto/src/main/java/com/squareup/otto/AnnotatedHandlerFinder.java
@@ -36,22 +36,22 @@
 final class AnnotatedHandlerFinder {
 
   /** Cache event bus producer methods for each class. */
-  private static final ConcurrentMap<Class<?>, Map<Class<?>, Method>> PRODUCERS_CACHE =
-    new ConcurrentHashMap<Class<?>, Map<Class<?>, Method>>();
+  private static final ConcurrentMap<Class<?>, Map<EventKey, Method>> PRODUCERS_CACHE =
+    new ConcurrentHashMap<Class<?>, Map<EventKey, Method>>();
 
   /** Cache event bus subscriber methods for each class. */
-  private static final ConcurrentMap<Class<?>, Map<Class<?>, Set<Method>>> SUBSCRIBERS_CACHE =
-    new ConcurrentHashMap<Class<?>, Map<Class<?>, Set<Method>>>();
+  private static final ConcurrentMap<Class<?>, Map<EventKey, Set<Method>>> SUBSCRIBERS_CACHE =
+    new ConcurrentHashMap<Class<?>, Map<EventKey, Set<Method>>>();
 
   private static void loadAnnotatedProducerMethods(Class<?> listenerClass,
-      Map<Class<?>, Method> producerMethods) {
-    Map<Class<?>, Set<Method>> subscriberMethods = new HashMap<Class<?>, Set<Method>>();
+      Map<EventKey, Method> producerMethods) {
+    Map<EventKey, Set<Method>> subscriberMethods = new HashMap<EventKey, Set<Method>>();
     loadAnnotatedMethods(listenerClass, producerMethods, subscriberMethods);
   }
 
   private static void loadAnnotatedSubscriberMethods(Class<?> listenerClass,
-      Map<Class<?>, Set<Method>> subscriberMethods) {
-    Map<Class<?>, Method> producerMethods = new HashMap<Class<?>, Method>();
+      Map<EventKey, Set<Method>> subscriberMethods) {
+    Map<EventKey, Method> producerMethods = new HashMap<EventKey, Method>();
     loadAnnotatedMethods(listenerClass, producerMethods, subscriberMethods);
   }
 
@@ -60,7 +60,7 @@ private static void loadAnnotatedSubscriberMethods(Class<?> listenerClass,
    * specified class.
    */
   private static void loadAnnotatedMethods(Class<?> listenerClass,
-      Map<Class<?>, Method> producerMethods, Map<Class<?>, Set<Method>> subscriberMethods) {
+      Map<EventKey, Method> producerMethods, Map<EventKey, Set<Method>> subscriberMethods) {
     for (Method method : listenerClass.getDeclaredMethods()) {
       // The compiler sometimes creates synthetic bridge methods as part of the
       // type erasure process. As of JDK8 these methods now include the same
@@ -70,6 +70,7 @@ private static void loadAnnotatedMethods(Class<?> listenerClass,
         continue;
       }
       if (method.isAnnotationPresent(Subscribe.class)) {
+        Subscribe subscribe = method.getAnnotation(Subscribe.class);
         Class<?>[] parameterTypes = method.getParameterTypes();
         if (parameterTypes.length != 1) {
           throw new IllegalArgumentException("Method " + method + " has @Subscribe annotation but requires "
@@ -87,13 +88,15 @@ private static void loadAnnotatedMethods(Class<?> listenerClass,
               + " but is not 'public'.");
         }
 
-        Set<Method> methods = subscriberMethods.get(eventType);
+        EventKey key = new EventKey(subscribe.value(), eventType);
+        Set<Method> methods = subscriberMethods.get(key);
         if (methods == null) {
           methods = new HashSet<Method>();
-          subscriberMethods.put(eventType, methods);
+          subscriberMethods.put(key, methods);
         }
         methods.add(method);
       } else if (method.isAnnotationPresent(Produce.class)) {
+          Produce produce = method.getAnnotation(Produce.class);
         Class<?>[] parameterTypes = method.getParameterTypes();
         if (parameterTypes.length != 0) {
           throw new IllegalArgumentException("Method " + method + "has @Produce annotation but requires "
@@ -118,10 +121,12 @@ private static void loadAnnotatedMethods(Class<?> listenerClass,
               + " but is not 'public'.");
         }
 
-        if (producerMethods.containsKey(eventType)) {
+        EventKey eventKey = new EventKey(produce.value(), eventType);
+
+        if (producerMethods.containsKey(eventKey)) {
           throw new IllegalArgumentException("Producer for type " + eventType + " has already been registered.");
         }
-        producerMethods.put(eventType, method);
+        producerMethods.put(eventKey, method);
       }
     }
 
@@ -130,37 +135,36 @@ private static void loadAnnotatedMethods(Class<?> listenerClass,
   }
 
   /** This implementation finds all methods marked with a {@link Produce} annotation. */
-  static Map<Class<?>, EventProducer> findAllProducers(Object listener) {
+  static Map<EventKey, EventProducer> findAllProducers(Object listener) {
     final Class<?> listenerClass = listener.getClass();
-    Map<Class<?>, EventProducer> handlersInMethod = new HashMap<Class<?>, EventProducer>();
+    Map<EventKey, EventProducer> handlersInMethod = new HashMap<EventKey, EventProducer>();
 
-    Map<Class<?>, Method> methods = PRODUCERS_CACHE.get(listenerClass);
+    Map<EventKey, Method> methods = PRODUCERS_CACHE.get(listenerClass);
     if (null == methods) {
-      methods = new HashMap<Class<?>, Method>();
+      methods = new HashMap<EventKey, Method>();
       loadAnnotatedProducerMethods(listenerClass, methods);
     }
     if (!methods.isEmpty()) {
-      for (Map.Entry<Class<?>, Method> e : methods.entrySet()) {
+      for (Map.Entry<EventKey, Method> e : methods.entrySet()) {
         EventProducer producer = new EventProducer(listener, e.getValue());
         handlersInMethod.put(e.getKey(), producer);
       }
     }
-
     return handlersInMethod;
   }
 
   /** This implementation finds all methods marked with a {@link Subscribe} annotation. */
-  static Map<Class<?>, Set<EventHandler>> findAllSubscribers(Object listener) {
+  static Map<EventKey, Set<EventHandler>> findAllSubscribers(Object listener) {
     Class<?> listenerClass = listener.getClass();
-    Map<Class<?>, Set<EventHandler>> handlersInMethod = new HashMap<Class<?>, Set<EventHandler>>();
+    Map<EventKey, Set<EventHandler>> handlersInMethod = new HashMap<EventKey, Set<EventHandler>>();
 
-    Map<Class<?>, Set<Method>> methods = SUBSCRIBERS_CACHE.get(listenerClass);
+    Map<EventKey, Set<Method>> methods = SUBSCRIBERS_CACHE.get(listenerClass);
     if (null == methods) {
-      methods = new HashMap<Class<?>, Set<Method>>();
+      methods = new HashMap<EventKey, Set<Method>>();
       loadAnnotatedSubscriberMethods(listenerClass, methods);
     }
     if (!methods.isEmpty()) {
-      for (Map.Entry<Class<?>, Set<Method>> e : methods.entrySet()) {
+      for (Map.Entry<EventKey, Set<Method>> e : methods.entrySet()) {
         Set<EventHandler> handlers = new HashSet<EventHandler>();
         for (Method m : e.getValue()) {
           handlers.add(new EventHandler(listener, m));
diff --git a/otto/src/main/java/com/squareup/otto/Bus.java b/otto/src/main/java/com/squareup/otto/Bus.java
index 0ab6620..a723d3c 100644
--- a/otto/src/main/java/com/squareup/otto/Bus.java
+++ b/otto/src/main/java/com/squareup/otto/Bus.java
@@ -88,12 +88,12 @@
   public static final String DEFAULT_IDENTIFIER = "default";
 
   /** All registered event handlers, indexed by event type. */
-  private final ConcurrentMap<Class<?>, Set<EventHandler>> handlersByType =
-          new ConcurrentHashMap<Class<?>, Set<EventHandler>>();
+  private final ConcurrentMap<EventKey, Set<EventHandler>> handlersByType =
+          new ConcurrentHashMap<EventKey, Set<EventHandler>>();
 
   /** All registered event producers, index by event type. */
-  private final ConcurrentMap<Class<?>, EventProducer> producersByType =
-          new ConcurrentHashMap<Class<?>, EventProducer>();
+  private final ConcurrentMap<EventKey, EventProducer> producersByType =
+          new ConcurrentHashMap<EventKey, EventProducer>();
 
   /** Identifier used to differentiate the event bus instance. */
   private final String identifier;
@@ -106,11 +106,11 @@
 
   /** Queues of events for the current thread to dispatch. */
   private final ThreadLocal<ConcurrentLinkedQueue<EventWithHandler>> eventsToDispatch =
-      new ThreadLocal<ConcurrentLinkedQueue<EventWithHandler>>() {
-        @Override protected ConcurrentLinkedQueue<EventWithHandler> initialValue() {
-          return new ConcurrentLinkedQueue<EventWithHandler>();
-        }
-      };
+          new ThreadLocal<ConcurrentLinkedQueue<EventWithHandler>>() {
+            @Override protected ConcurrentLinkedQueue<EventWithHandler> initialValue() {
+              return new ConcurrentLinkedQueue<EventWithHandler>();
+            }
+          };
 
   /** True if the current thread is currently dispatching an event. */
   private final ThreadLocal<Boolean> isDispatching = new ThreadLocal<Boolean>() {
@@ -187,16 +187,16 @@ public void register(Object object) {
     }
     enforcer.enforce(this);
 
-    Map<Class<?>, EventProducer> foundProducers = handlerFinder.findAllProducers(object);
-    for (Class<?> type : foundProducers.keySet()) {
+    Map<EventKey, EventProducer> foundProducers = handlerFinder.findAllProducers(object);
+    for (EventKey type : foundProducers.keySet()) {
 
       final EventProducer producer = foundProducers.get(type);
       EventProducer previousProducer = producersByType.putIfAbsent(type, producer);
       //checking if the previous producer existed
       if (previousProducer != null) {
         throw new IllegalArgumentException("Producer method for type " + type
-          + " found on type " + producer.target.getClass()
-          + ", but already registered by type " + previousProducer.target.getClass() + ".");
+                + " found on type " + producer.target.getClass()
+                + ", but already registered by type " + previousProducer.target.getClass() + ".");
       }
       Set<EventHandler> handlers = handlersByType.get(type);
       if (handlers != null && !handlers.isEmpty()) {
@@ -206,15 +206,15 @@ public void register(Object object) {
       }
     }
 
-    Map<Class<?>, Set<EventHandler>> foundHandlersMap = handlerFinder.findAllSubscribers(object);
-    for (Class<?> type : foundHandlersMap.keySet()) {
+    Map<EventKey, Set<EventHandler>> foundHandlersMap = handlerFinder.findAllSubscribers(object);
+    for (EventKey type : foundHandlersMap.keySet()) {
       Set<EventHandler> handlers = handlersByType.get(type);
       if (handlers == null) {
         //concurrent put if absent
         Set<EventHandler> handlersCreation = new CopyOnWriteArraySet<EventHandler>();
         handlers = handlersByType.putIfAbsent(type, handlersCreation);
         if (handlers == null) {
-            handlers = handlersCreation;
+          handlers = handlersCreation;
         }
       }
       final Set<EventHandler> foundHandlers = foundHandlersMap.get(type);
@@ -223,8 +223,8 @@ public void register(Object object) {
       }
     }
 
-    for (Map.Entry<Class<?>, Set<EventHandler>> entry : foundHandlersMap.entrySet()) {
-      Class<?> type = entry.getKey();
+    for (Map.Entry<EventKey, Set<EventHandler>> entry : foundHandlersMap.entrySet()) {
+      EventKey type = entry.getKey();
       EventProducer producer = producersByType.get(type);
       if (producer != null && producer.isValid()) {
         Set<EventHandler> foundHandlers = entry.getValue();
@@ -266,29 +266,29 @@ public void unregister(Object object) {
     }
     enforcer.enforce(this);
 
-    Map<Class<?>, EventProducer> producersInListener = handlerFinder.findAllProducers(object);
-    for (Map.Entry<Class<?>, EventProducer> entry : producersInListener.entrySet()) {
-      final Class<?> key = entry.getKey();
+    Map<EventKey, EventProducer> producersInListener = handlerFinder.findAllProducers(object);
+    for (Map.Entry<EventKey, EventProducer> entry : producersInListener.entrySet()) {
+      final EventKey key = entry.getKey();
       EventProducer producer = getProducerForEventType(key);
       EventProducer value = entry.getValue();
 
       if (value == null || !value.equals(producer)) {
         throw new IllegalArgumentException(
-            "Missing event producer for an annotated method. Is " + object.getClass()
-                + " registered?");
+                "Missing event producer for an annotated method. Is " + object.getClass()
+                        + " registered?");
       }
       producersByType.remove(key).invalidate();
     }
 
-    Map<Class<?>, Set<EventHandler>> handlersInListener = handlerFinder.findAllSubscribers(object);
-    for (Map.Entry<Class<?>, Set<EventHandler>> entry : handlersInListener.entrySet()) {
+    Map<EventKey, Set<EventHandler>> handlersInListener = handlerFinder.findAllSubscribers(object);
+    for (Map.Entry<EventKey, Set<EventHandler>> entry : handlersInListener.entrySet()) {
       Set<EventHandler> currentHandlers = getHandlersForEventType(entry.getKey());
       Collection<EventHandler> eventMethodsInListener = entry.getValue();
 
       if (currentHandlers == null || !currentHandlers.containsAll(eventMethodsInListener)) {
         throw new IllegalArgumentException(
-            "Missing event handler for an annotated method. Is " + object.getClass()
-                + " registered?");
+                "Missing event handler for an annotated method. Is " + object.getClass()
+                        + " registered?");
       }
 
       for (EventHandler handler : currentHandlers) {
@@ -300,6 +300,10 @@ public void unregister(Object object) {
     }
   }
 
+  public void post(Object event) {
+    post("default", event);
+  }
+
   /**
    * Posts an event to all registered handlers.  This method will return successfully after the event has been posted to
    * all handlers, and regardless of any exceptions thrown by handlers.
@@ -310,7 +314,7 @@ public void unregister(Object object) {
    * @param event event to post.
    * @throws NullPointerException if the event is null.
    */
-  public void post(Object event) {
+  public void post(String name, Object event) {
     if (event == null) {
       throw new NullPointerException("Event to post must not be null.");
     }
@@ -320,7 +324,7 @@ public void post(Object event) {
 
     boolean dispatched = false;
     for (Class<?> eventType : dispatchTypes) {
-      Set<EventHandler> wrappers = getHandlersForEventType(eventType);
+      Set<EventHandler> wrappers = getHandlersForEventType(new EventKey(name, eventType));
 
       if (wrappers != null && !wrappers.isEmpty()) {
         dispatched = true;
@@ -385,7 +389,7 @@ protected void dispatch(Object event, EventHandler wrapper) {
       wrapper.handleEvent(event);
     } catch (InvocationTargetException e) {
       throwRuntimeException(
-          "Could not dispatch event: " + event.getClass() + " to handler " + wrapper, e);
+              "Could not dispatch event: " + event.getClass() + " to handler " + wrapper, e);
     }
   }
 
@@ -396,7 +400,7 @@ protected void dispatch(Object event, EventHandler wrapper) {
    * @param type type of producer to retrieve.
    * @return currently registered producer, or {@code null}.
    */
-  EventProducer getProducerForEventType(Class<?> type) {
+  EventProducer getProducerForEventType(EventKey type) {
     return producersByType.get(type);
   }
 
@@ -407,7 +411,7 @@ EventProducer getProducerForEventType(Class<?> type) {
    * @param type type of handlers to retrieve.
    * @return currently registered handlers, or {@code null}.
    */
-  Set<EventHandler> getHandlersForEventType(Class<?> type) {
+  Set<EventHandler> getHandlersForEventType(EventKey type) {
     return handlersByType.get(type);
   }
 
@@ -464,7 +468,7 @@ private static void throwRuntimeException(String msg, InvocationTargetException
   }
 
   private final ConcurrentMap<Class<?>, Set<Class<?>>> flattenHierarchyCache =
-      new ConcurrentHashMap<Class<?>, Set<Class<?>>>();
+          new ConcurrentHashMap<Class<?>, Set<Class<?>>>();
 
   /** Simple struct representing an event and its handler. */
   static class EventWithHandler {
diff --git a/otto/src/main/java/com/squareup/otto/EventKey.java b/otto/src/main/java/com/squareup/otto/EventKey.java
new file mode 100644
index 0000000..4994fab
--- /dev/null
+++ b/otto/src/main/java/com/squareup/otto/EventKey.java
@@ -0,0 +1,37 @@
+package com.squareup.otto;
+
+public class EventKey {
+    private final String name;
+    private final Class<?> type;
+
+    public EventKey(String name, Class<?> type) {
+        this.name = name;
+        this.type = type;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public Class<?> getType() {
+        return type;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+
+        EventKey eventKey = (EventKey) o;
+
+        if (name != null ? !name.equals(eventKey.name) : eventKey.name != null) return false;
+        return type != null ? type.equals(eventKey.type) : eventKey.type == null;
+    }
+
+    @Override
+    public int hashCode() {
+        int result = name != null ? name.hashCode() : 0;
+        result = 31 * result + (type != null ? type.hashCode() : 0);
+        return result;
+    }
+}
diff --git a/otto/src/main/java/com/squareup/otto/HandlerFinder.java b/otto/src/main/java/com/squareup/otto/HandlerFinder.java
index ff61a2c..734d5a1 100644
--- a/otto/src/main/java/com/squareup/otto/HandlerFinder.java
+++ b/otto/src/main/java/com/squareup/otto/HandlerFinder.java
@@ -22,19 +22,19 @@
 /** Finds producer and subscriber methods. */
 interface HandlerFinder {
 
-  Map<Class<?>, EventProducer> findAllProducers(Object listener);
+  Map<EventKey, EventProducer> findAllProducers(Object listener);
 
-  Map<Class<?>, Set<EventHandler>> findAllSubscribers(Object listener);
+  Map<EventKey, Set<EventHandler>> findAllSubscribers(Object listener);
 
 
   HandlerFinder ANNOTATED = new HandlerFinder() {
     @Override
-    public Map<Class<?>, EventProducer> findAllProducers(Object listener) {
+    public Map<EventKey, EventProducer> findAllProducers(Object listener) {
       return AnnotatedHandlerFinder.findAllProducers(listener);
     }
 
     @Override
-    public Map<Class<?>, Set<EventHandler>> findAllSubscribers(Object listener) {
+    public Map<EventKey, Set<EventHandler>> findAllSubscribers(Object listener) {
       return AnnotatedHandlerFinder.findAllSubscribers(listener);
     }
   };
diff --git a/otto/src/main/java/com/squareup/otto/Produce.java b/otto/src/main/java/com/squareup/otto/Produce.java
index 1497a39..12c6096 100644
--- a/otto/src/main/java/com/squareup/otto/Produce.java
+++ b/otto/src/main/java/com/squareup/otto/Produce.java
@@ -32,4 +32,5 @@
 @Retention(RetentionPolicy.RUNTIME)
 @Target(ElementType.METHOD)
 public @interface Produce {
+    String value() default "default";
 }
diff --git a/otto/src/main/java/com/squareup/otto/Subscribe.java b/otto/src/main/java/com/squareup/otto/Subscribe.java
index f0217e3..3a18dde 100644
--- a/otto/src/main/java/com/squareup/otto/Subscribe.java
+++ b/otto/src/main/java/com/squareup/otto/Subscribe.java
@@ -34,4 +34,5 @@
 @Retention(RetentionPolicy.RUNTIME)
 @Target(ElementType.METHOD)
 public @interface Subscribe {
+    String value() default "default";
 }
diff --git a/otto/src/test/java/com/squareup/otto/BusTest.java b/otto/src/test/java/com/squareup/otto/BusTest.java
index 3cc0572..43faa2e 100644
--- a/otto/src/test/java/com/squareup/otto/BusTest.java
+++ b/otto/src/test/java/com/squareup/otto/BusTest.java
@@ -60,7 +60,7 @@
     StringCatcher catcher = new StringCatcher();
     bus.register(catcher);
 
-    Set<EventHandler> wrappers = bus.getHandlersForEventType(String.class);
+    Set<EventHandler> wrappers = bus.getHandlersForEventType(new EventKey("default", String.class));
     assertNotNull("Should have at least one method registered.", wrappers);
     assertEquals("One method should be registered.", 1, wrappers.size());
 
diff --git a/otto/src/test/java/com/squareup/otto/UnregisteringHandlerTest.java b/otto/src/test/java/com/squareup/otto/UnregisteringHandlerTest.java
index 50b9990..17759d7 100644
--- a/otto/src/test/java/com/squareup/otto/UnregisteringHandlerTest.java
+++ b/otto/src/test/java/com/squareup/otto/UnregisteringHandlerTest.java
@@ -98,15 +98,15 @@ public int compare(EventHandler eventHandler, EventHandler eventHandler1) {
     };
 
     @Override
-    public Map<Class<?>, EventProducer> findAllProducers(Object listener) {
+    public Map<EventKey, EventProducer> findAllProducers(Object listener) {
       return HandlerFinder.ANNOTATED.findAllProducers(listener);
     }
 
     @Override
-    public Map<Class<?>, Set<EventHandler>> findAllSubscribers(Object listener) {
-      Map<Class<?>, Set<EventHandler>> found = HandlerFinder.ANNOTATED.findAllSubscribers(listener);
-      Map<Class<?>, Set<EventHandler>> sorted = new HashMap<Class<?>, Set<EventHandler>>();
-      for (Map.Entry<Class<?>, Set<EventHandler>> entry : found.entrySet()) {
+    public Map<EventKey, Set<EventHandler>> findAllSubscribers(Object listener) {
+      Map<EventKey, Set<EventHandler>> found = HandlerFinder.ANNOTATED.findAllSubscribers(listener);
+      Map<EventKey, Set<EventHandler>> sorted = new HashMap<EventKey, Set<EventHandler>>();
+      for (Map.Entry<EventKey, Set<EventHandler>> entry : found.entrySet()) {
         SortedSet<EventHandler> handlers = new TreeSet<EventHandler>(handlerComparator);
         handlers.addAll(entry.getValue());
         sorted.put(entry.getKey(), handlers);
