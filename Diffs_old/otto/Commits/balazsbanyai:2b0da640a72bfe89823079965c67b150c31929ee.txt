diff --git a/otto-processor/src/main/java/com/squareup/otto/OttoAnnotationProcessor.java b/otto-processor/src/main/java/com/squareup/otto/OttoAnnotationProcessor.java
index 50e6deb..f385fe1 100644
--- a/otto-processor/src/main/java/com/squareup/otto/OttoAnnotationProcessor.java
+++ b/otto-processor/src/main/java/com/squareup/otto/OttoAnnotationProcessor.java
@@ -18,9 +18,9 @@
 import javax.tools.Diagnostic;
 
 /**
- * Annotation processor that detects some cases of misusing Otto at compile time
+ * Annotation processor that detects some cases of misusing Otto at compile time.
  *
- * @author Balazs S Banyai
+ * @author balazsbanyai
  */
 @SupportedSourceVersion(SourceVersion.RELEASE_6)
 @SupportedAnnotationTypes({ "com.squareup.otto.Subscribe" })
@@ -47,7 +47,7 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
         @Override
         public Void visitExecutable(ExecutableElement element, Void aVoid) {
             if (element.getParameters().size() != 1) {
-                String methodName = element.toString(); // TODO enclosingElement!
+                String methodName = getQualifiedMethodName(element);
                 int argumentListSize = element.getParameters().size();
                 String message = ErrorMessages.newInvalidArgumentListMessage(methodName, argumentListSize);
                 processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, message);
@@ -61,7 +61,7 @@ public Void visitExecutable(ExecutableElement element, Void aVoid) {
         @Override
         public Void visitExecutable(ExecutableElement element, Void aVoid) {
             if (!element.getModifiers().contains(Modifier.PUBLIC)) {
-                String methodName = element.toString();
+                String methodName = getQualifiedMethodName(element);
                 String eventTypeName = element.getParameters().get(0).asType().toString();
                 String message = ErrorMessages.newNotVisibleMessage(methodName, eventTypeName);
                 processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, message);
@@ -70,6 +70,13 @@ public Void visitExecutable(ExecutableElement element, Void aVoid) {
         }
     }
 
+    private String getQualifiedMethodName(ExecutableElement element) {
+        TypeElement typeElement = (TypeElement) element.getEnclosingElement();
+        String className = typeElement.getQualifiedName().toString();
+        String methodName = element.toString();
+        return className + "." + methodName;
+    }
+
     private abstract class AbstractMethodVisitor extends AbstractElementVisitor6<Void, Void> {
 
         @Override
diff --git a/otto-processor/src/test/java/com/squareup/otto/OttoAnnotationProcessorTest.java b/otto-processor/src/test/java/com/squareup/otto/OttoAnnotationProcessorTest.java
index 1aaa2ff..c4552e9 100644
--- a/otto-processor/src/test/java/com/squareup/otto/OttoAnnotationProcessorTest.java
+++ b/otto-processor/src/test/java/com/squareup/otto/OttoAnnotationProcessorTest.java
@@ -1,8 +1,5 @@
 package com.squareup.otto;
 
-import junit.framework.TestCase;
-
-import org.fest.assertions.util.ArrayWrapperList;
 import org.junit.Before;
 import org.junit.Test;
 import org.mockito.Mock;
@@ -11,7 +8,6 @@
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 
-import java.util.Arrays;
 import java.util.EnumSet;
 import java.util.List;
 import java.util.Set;
@@ -22,11 +18,13 @@
 import javax.lang.model.element.ElementVisitor;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
+import javax.lang.model.element.Name;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.TypeMirror;
 import javax.tools.Diagnostic;
 
+import static java.util.Arrays.asList;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyObject;
 import static org.mockito.Matchers.eq;
@@ -35,9 +33,15 @@
 import static org.mockito.Mockito.verifyZeroInteractions;
 import static org.mockito.Mockito.when;
 
+/**
+ * @author balazsbanyai
+ */
 public class OttoAnnotationProcessorTest {
 
-    private static final String METHOD_ARGUMENT_TYPE_NAME = "TestEvent";
+    private static final String METHOD_ARG_TYPE_NAME = "TestEvent";
+    private static final String METHOD_NAME = "testMethod";
+    private static final String QUALIFIER = "javax.annotation";
+    private static final String QUALIFIED_METHOD_NAME = QUALIFIER + "." + METHOD_NAME;
 
     @Mock
     private ProcessingEnvironment env;
@@ -81,22 +85,33 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
                 return null;
             }
         });
+
+        TypeElement enclosingElement = mockTypeElementWithQualifiedName();
+        when(executableElement.getEnclosingElement()).thenReturn(enclosingElement);
+        when(executableElement.toString()).thenReturn(METHOD_NAME);
+    }
+
+    private TypeElement mockTypeElementWithQualifiedName() {
+        TypeElement mockTypeElement = mock(TypeElement.class);
+        Name mockName = mock(Name.class);
+        when(mockName.toString()).thenReturn(QUALIFIER);
+        when(mockTypeElement.getQualifiedName()).thenReturn(mockName);
+        return mockTypeElement;
     }
 
-    private VariableElement mockMethodArgument() {
+    private VariableElement mockMethodArgumentWithTypeName() {
         VariableElement mockEvent = mock(VariableElement.class);
         TypeMirror mockTypeMirror = mock(TypeMirror.class);
-        when(mockTypeMirror.toString()).thenReturn(METHOD_ARGUMENT_TYPE_NAME);
+        when(mockTypeMirror.toString()).thenReturn(METHOD_ARG_TYPE_NAME);
         when(mockEvent.asType()).thenReturn(mockTypeMirror);
         return mockEvent;
     }
 
     @Test
     public void process_validSignature_noErrorReported() {
-        VariableElement argument1 = mockMethodArgument();
-        List args = Arrays.asList(new VariableElement[]{argument1});
+        VariableElement argument1 = mockMethodArgumentWithTypeName();
         when(executableElement.getModifiers()).thenReturn(EnumSet.of(Modifier.PUBLIC));
-        when(executableElement.getParameters()).thenReturn(args);
+        when(executableElement.getParameters()).thenReturn((List) asList(argument1));
 
         processor.process(annotations, roundEnvironment);
 
@@ -105,11 +120,10 @@ public void process_validSignature_noErrorReported() {
 
     @Test
     public void process_wrongArgumentListLength_errorReported() {
-        VariableElement argument1 = mockMethodArgument();
-        VariableElement argument2 = mockMethodArgument();
-        List args = Arrays.asList(new VariableElement[]{argument1, argument2});
+        VariableElement argument1 = mockMethodArgumentWithTypeName();
+        VariableElement argument2 = mockMethodArgumentWithTypeName();
         when(executableElement.getModifiers()).thenReturn(EnumSet.of(Modifier.PUBLIC));
-        when(executableElement.getParameters()).thenReturn(args);
+        when(executableElement.getParameters()).thenReturn((List) asList(argument1, argument2));
 
         processor.process(annotations, roundEnvironment);
 
@@ -118,14 +132,14 @@ public void process_wrongArgumentListLength_errorReported() {
 
     private void verifyWrongArgumentListLengthMessage() {
         Diagnostic.Kind expectedKind = Diagnostic.Kind.ERROR;
-        String expectedMessage = ErrorMessages.newInvalidArgumentListMessage(executableElement.toString(), executableElement.getParameters().size());
+        String expectedMessage = ErrorMessages.newInvalidArgumentListMessage(QUALIFIED_METHOD_NAME, executableElement.getParameters().size());
         verify(messager).printMessage(eq(expectedKind), eq(expectedMessage));
     }
 
     @Test
     public void process_wrongModifier_errorReported() {
-        VariableElement argument1 = mockMethodArgument();
-        List args = Arrays.asList(new VariableElement[]{argument1});
+        VariableElement argument1 = mockMethodArgumentWithTypeName();
+        List args = asList(new VariableElement[]{argument1});
         when(executableElement.getModifiers()).thenReturn(EnumSet.of(Modifier.PRIVATE));
         when(executableElement.getParameters()).thenReturn(args);
 
@@ -136,17 +150,16 @@ public void process_wrongModifier_errorReported() {
 
     private void verifyNotVisibleMessage() {
         Diagnostic.Kind expectedKind = Diagnostic.Kind.ERROR;
-        String expectedMessage = ErrorMessages.newNotVisibleMessage(executableElement.toString(), METHOD_ARGUMENT_TYPE_NAME);
+        String expectedMessage = ErrorMessages.newNotVisibleMessage(QUALIFIED_METHOD_NAME, METHOD_ARG_TYPE_NAME);
         verify(messager).printMessage(eq(expectedKind), eq(expectedMessage));
     }
 
     @Test
     public void process_wrongModifierAndParameterLength_bothErrorsReported() {
-        VariableElement argument1 = mockMethodArgument();
-        VariableElement argument2 = mockMethodArgument();
-        List args = Arrays.asList(new VariableElement[]{argument1, argument2});
+        VariableElement argument1 = mockMethodArgumentWithTypeName();
+        VariableElement argument2 = mockMethodArgumentWithTypeName();
         when(executableElement.getModifiers()).thenReturn(EnumSet.of(Modifier.PRIVATE));
-        when(executableElement.getParameters()).thenReturn(args);
+        when(executableElement.getParameters()).thenReturn((List) asList(argument1, argument2));
 
         processor.process(annotations, roundEnvironment);
 
